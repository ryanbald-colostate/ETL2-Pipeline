PR, Issue, Issue_Title_Linked, Issue_Body_Linked, Issue_Comment_Linked, isTrain
138,76,Operator: SequenceEqual,http://msdn.microsoft.com/en-us/library/hh229024(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212108(v=vs.103).aspx,Looking at these implementations it seems that by using zip it will emit a sequence of true/false values rather than a single boolean specifying if the entire sequence is true/false.

I think it is supposed to emit only a single value based on reading the MSDN docs.

@mairbek If you re-read the docs, is it supposed to be a single value, or sequence of values emitted? If single, can you submit a fix? Probably a reduce type function that keeps going until it finds a false otherwise if it hits onComplete/onError the same on both sides it returns true. 
 =||= @benjchristensen okay, I'll submit the patch.
 =||= Reduce doesn't seems to be a good choice in this case since it would wait for all pairs of events, even if first two were different.

I will start by implementing All Operation #21 and applying it to a `zip` of two observables.
 =||= Okay, thanks.
 =||= This happens to be more complicated that I've expected.

I've come up with a test case that fails on `all` + `zip` implementation. Looks like `zip` operation completes the observation as fast as first observable completes which leads to wrong behaviour of `sequenceEqual` operation.

``` java

        @Test
        public void testSequenceEqual3() {
            Observable<Integer> first = Observable.toObservable(1, 2);
            Observable<Integer> second = Observable.toObservable(1, 2, 3);
            @SuppressWarnings("unchecked")
            Observer<Boolean> result = mock(Observer.class);
            sequenceEqual(first, second).subscribe(result);
            verify(result, times(1)).onNext(false);
            verify(result, times(1)).onCompleted();
            verifyNoMoreInteractions(result);
        }

```
 =||= Done.
 =||= ,0
146,125,Implemented: TakeWhile,nan,Hi @mairbek, thank you for contributing. 

I'm going to checkout your branch to review this and will comment more (or merge if nothing needs to change) once I've done so.

Talk to you soon ...
 =||= @mairbek I have reviewed the code and it looks good.

The missing part is the addition of methods to rx.Observable.

The 2 methods you'd need to model after are: 

https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L1324
https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L2212

Note that there is both a static and instance method.

Since takeWhile includes a Func it will also need to support an overload with Object such as this:

-> typed: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L2212
-> non-typed: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L2269

So you would end up with:

static Observable.takeWhile(final Observable<T> items, final Func1<T, Boolean> predicate)
static Observable.takeWhile(final Observable<T> items, final Func2<T, Integer, Boolean> predicate)
static Observable.takeWhile(final Observable<T> items, final Object predicate)
instance Observable.takeWhile(final Func2<T, Integer, Boolean> predicate)
instance Observable.takeWhile(final Func1<T, Boolean> predicate)
instance Observable.takeWhile(final Object predicate)

One challenge with supporting dynamic languages is that overloading can get tricky and the implementation of takeWhile as it currently stands has overloads with Func1 and Func2. This means that the overload with Object will convert to FuncN, but we won't know which of the Func1 or Func2 methods to send to.

Thus, you may want to look at changing the OperationTake to use only Func2 for the takeWhile methods.

When adding methods involving Func\* overloads I then add unit tests for at least one of the dynamic languages to make sure it's all working when going via the "Object" overloads.

For example: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java#L85

Do you want to update this pull request to include the rx.Observable methods?
 =||= > Thus, you may want to look at changing the OperationTake to use only `Func2` for the takeWhile methods.

I suppose people would mostly look for the `Func1` method and use cases when you need `Func2` function are pretty rare.
I'm going to name `takeWhile` with `Func2` as `takeWhileWithIndex` (not sure if this is a good name for this) to avoid overloading, what do you think?
 =||= I need to spend some time playing with this as I'd like to try and find a way that doesn't require a different name.

I haven't forgotten this but need to finish some other things then will come back to this.
 =||= This is for issue https://github.com/Netflix/RxJava/issues/87
 =||= This can no longer be automatically merged so I'm manually merging it into my local branch to play with and will either respond back with comments or submit with your commits in another pull request based off of yours.
 =||= To allow us to avoid having takeWhileWithIndex (and just have takeWhile) is it bad to require all closures to pass in both arguments and just ignore the index if they don't want it?

``` groovy
Observable.takeWhile(Observable.toObservable(1, 2, 3), { x, i -> i < 2}).subscribe({ result -> a.received(result)});
```

``` clojure
(-> (rx.Observable/toObservable [1 2 3]) (.takeWhile (fn [x i] (< x 2))) (.subscribe (fn [arg] (println arg))))
```

versus

``` groovy
Observable.takeWhile(Observable.toObservable(1, 2, 3), { x -> x < 2}).subscribe({ result -> a.received(result)});
```

``` clojure
(-> (rx.Observable/toObservable [1 2 3]) (.takeWhile (fn [x] (< x 2))) (.subscribe (fn [arg] (println arg))))
```

Asking around for opinions ...
 =||= I have completed the merge in pull request https://github.com/Netflix/RxJava/pull/146

I'll close this one out now.

I stuck with the proposed design by @mairbek for the pull request and it has takeWhile and takeWhileWithIndex since it seems the common use case would be takeWhile so it keeps the closure implementations simple with a single arg.

Of course since we're version 0.5 we can change this decision prior to 1.0 if there are strong opinions otherwise.
 =||= Thank you @mairbek, great implementation. I appreciate how clean and well tested your code is and that you strive to comply with the style of the project.
 =||= I prefer `takeWhile` and `takeWhileIndexed`. Two separate names is more explicit.
 =||= Thanks Dave, I also discussed with Jafar who agreed so we're good with the takeWhilte/takeWhileIndexed naming convention and I'll leave the code as committed.
 =||= ,0
146,87,Operator: TakeWhile,http://msdn.microsoft.com/en-us/library/hh244231(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229131(v=vs.103).aspx,nan,0
156,18,Operator: ToIterable,We already from toObservable(Iterable)/from(Iterable) ... add the reverse blocking toIterable() similar to the non-blocking toList() which already exists.

ToEnumerable from C#: http://msdn.microsoft.com/en-us/library/hh212132(v=vs.103).aspx,`ToEnumerable` don't seems to be different from `ToList`.

First one returns `IObservable<IList<TSource>>` second one `IEnumerable<TSource>`.
 =||= The toList operator is non-blocking as it returns Observable<List<T>> whereas to Iterable is blocking and returns Iterable<T>.

The key difference is non-blocking versus blocking, otherwise yes, they behave similarly.

The other difference though is that toList will wait until the observable sequence is onCompleted() and then emit the List whereas toIterable will buffer but start allowing take() to be called immediately as each onNext() value is emitted.
 =||= Merged.
 =||= By the way ... a key difference in Java is that Iterable is not an equal dual with Observable whereas IEnumerable is a dual to IObservable in .Net where both have extension methods with all the functional operators.

Since Java doesn't have extension methods we can't do that here. At best we could have another parallel framework for wrapping an Iterable.
 =||= ,0
165,164,rx.util.Range.createWithCount(int start, int count) yields invalid sequence when start != 1,createWithCount(1, 4) correctly yields (1, 2, 3, 4)
createWithCount(2, 4) yields (2, 3, 4, 5, 6, 7, 8, 9) where it should be (2, 3, 4, 5)
createWithCount(0, 4) yields () where it should be (0, 1, 2, 3)
createWithCount(-1, 4) yields () where it should be (-1, 0, 1, 2),Thanks @mairbek for the quick fix.

@christianbourgeois I have merged the fix (https://github.com/Netflix/RxJava/pull/165) and will include in the next release. I just want to review one more pull request to try and get it into that release.

It is okay if I wait until end of day today to release the new code or do you need the fix sooner?
 =||= Thanks @mairbek for the quick fix and @benjchristensen for the merge.

You are all very fast, I was in the process of sending a pull request when I saw the fix by @mairbek.

This issue is not critical in any way for me, no worries for the release.
 =||= Then I'll finish up the other work before doing this release (hoping either end-of-day or over weekend).

Thanks for reporting the bug and being willing to submit a pull request (until @mairbek beat you to it!).
 =||= Thank you @christianbourgeois for reporting the issue.

I had shortly realized what a dumb mistake I made in that code :)
 =||= ,0
181,154,Add OSGi manifest headers,Those of us on OSGi environments (like eclipse, netbeans, glassfish) cannot use rxjava-core or the other adapters without OSGi headers being added to the manifest.

This is pretty easy to do using the Maven Bundle plugin from apache Felix.,This looks pretty straight-forward to do with Gradle: http://www.gradle.org/docs/current/userguide/osgi_plugin.html

Since I have not used OSGi before, is there anything special about what the headers need to contain or is it basically the same information used to post to Maven Central? 

For example, this pom file: http://search.maven.org/#artifactdetails%7Ccom.netflix.rxjava%7Crxjava-core%7C0.5.3%7Cjar
 =||= This plugin looks similar enough to the felix plugin (which also uses BND) that it should work. The import/exports of RxJava are minimal and discoverable by the java code. There aren't any Class.forName() calls right?
 =||= There is one place Class.forName is used – to automatically load the plugins when they are in the classpath:

https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/util/functions/Functions.java#L49

Language adaptors can also be manually loaded using `Functions.registerLanguageAdaptor(Class<?>[] functionClasses, FunctionLanguageAdaptor adaptor)`

https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/util/functions/Functions.java#L63
 =||= Interesting. This means the language plugins are going to have to be "bundle fragments" instead of plain bundles. That means that the plugin jars will be bound to the main rxjava-core jar at runtime as a logically-merged bundle. I haven't used gradle so my best-guess addendum for the language plugins would be:

 instruction 'Fragment-Host', 'com.netflix.rxjava.rxjava-core'

This means the jar being built (like the groovy plugin) is a fragment, whose host is rxjava-core. At runtime OSGi will fit the two together.
 =||= If you set up the gradle changes I am happy to test.
 =||= I'd appreciate that as I have no way to know if it's successful or not, so I'll create a branch with the gradle changes and then if you can play with and modify the values as necessary that would be great. I'm working on something else right now that I need to get done and then can work on this.
 =||= NP, gives me a chance to experience gradle. :)

On Fri, Feb 22, 2013 at 6:07 PM, Ben Christensen
notifications@github.comwrote:

> I'd appreciate that as I have no way to know if it's successful or not, so
> I'll create a branch with the gradle changes and then if you can play with
> and modify the values as necessary that would be great. I'm working on
> something else right now that I need to get done and then can work on this.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/154#issuecomment-13978672.
 =||= I've got a jar building with the OSGi headers but that's where I stop having any idea what to put in as the headers, so I'd appreciate you getting it working as needed and submitting the pull request.

Here is how I did it:

1) Edit build.gradle of the module to change. For example, ./rxjava-core/build.gradle

I added this line at the top:

``` groovy
apply plugin: 'osgi'
```

and this at the bottom:

``` groovy
jar {
    manifest { 
        name = 'rxjava-core'
        instruction 'Bundle-Vendor', 'Netflix'
        instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava'
    }
}
```

I then run a build:

```
$ ./gradlew clean build
```

I then see the MANIFEST file by doing this:

```
$ cd ./rxjava-core/build/libs/
$ jar xvf rxjava-core-0.5.4-SNAPSHOT.jar 
$ cat META-INF/MANIFEST.MF 
```

I see the new manifest headers that normally aren't there without the build.grade changes above.
 =||= Hi Ben, I will give it a go next week.

On Wed, Feb 27, 2013 at 2:49 PM, Ben Christensen
notifications@github.comwrote:

> I've got a jar building with the OSGi headers but that's where I stop
> having any idea what to put in as the headers, so I'd appreciate you
> getting it working as needed and submitting the pull request.
> 
> Here is how I did it:
> 
> 1) Edit build.gradle of the module to change. For example,
> ./rxjava-core/build.gradle
> 
> I added this line at the top:
> 
> apply plugin: 'osgi'
> 
> and this at the bottom:
> 
> jar {
>     manifest {
>         name = 'rxjava-core'
>         instruction 'Bundle-Vendor', 'Netflix'
>         instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava'
>     }}
> 
> I then run a build:
> 
> $ ./gradlew clean build
> 
> I then see the MANIFEST file by doing this:
> 
> $ cd ./rxjava-core/build/libs/
> $ jar xvf rxjava-core-0.5.4-SNAPSHOT.jar
> $ cat META-INF/MANIFEST.MF
> 
> I see the new manifest headers that normally aren't there without the
> build.grade changes above.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/154#issuecomment-14205447
> .
 =||= I added in your jar {} section and it does generate OSGi headers in the manifest.

However, the unit tests are in the source code so it inserts dependencies for junit and mockito. I can strip them out with custom BND instructions to the OSGi plugin, but are these tests going to stay in the main src dir or will they move to a separate tests dir?
 =||= Please add this one line to the jar {} section:

```
    instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*'
```

This should mask out the unit testing packages.

NOTE: Make sure you set your version to a release name (non-SNAPSHOT) before building the project. The manifest exports specific versions of rx; right now that version is "version="0.5.5.SNAPSHOT" which will fail if the actual maven artifact version is 0.5.5.

Thanks, if you do move the tests out of the main source dir then the Import-Package instruction can be removed.
 =||= The unit tests will not be moved out. They are there on purpose.

The JUnit dependency is marked as 'provided' (https://github.com/Netflix/Hystrix/blob/master/hystrix-core/build.gradle#L9) but not included as part of the runtime dependencies when published to Maven Central:  http://search.maven.org/#artifactdetails%7Ccom.netflix.hystrix%7Chystrix-core%7C1.2.12%7Cjar

Does the addition of just the following OSGi headers satisfy your requirements?

```
jar {
    manifest { 
        name = 'rxjava-core'
        instruction 'Bundle-Vendor', 'Netflix'
        instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava'
        instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*'
    }
}
```

What about the 'bundle fragments' that you mentioned would be needed for the language-adaptors? Or do I simply just add these same headers to each of those other jars as well (with their appropriate names of course)?
 =||= The 'provided' scope still means a runtime dependency rather than a test time dependency. I don't understand why they are not separated but that doesn't matter as long as it can be managed out of the dependencies.

As for the language adapters, let me have a look at them. They will need their own instructions for gradle including the fragment instruction.
 =||= ...and to answer the question for core, yes that manifest instruction set is good.
 =||= I'll wait on your answer for the language-adaptors and then commit the changes.

Yes, it's "runtime" for running the tests, but not for production usage which is why they are marked as provided and not needed as transitive dependencies. Reasons if you care are here: http://benjchristensen.com/2011/10/23/junit-tests-as-inner-classes/
 =||= How do you build the language adaptors, or where do they land?
 =||= BenI(jamin?) I am not having much luck building the language adaptors. I am using both the top-level build command as described above as well as the subproject build like this:

Projects/RxJava$ ./gradlew :language-adaptors:build

What I get in language-adaptors/build/libs is an anemic jar file (261 bytes) with only a one-line manifest. Is there another way to generate the adaptor jars?
 =||= You can either build the entire project from the root like this:

```
cd RxJava
$ ./gradlew build
...
$ ls -al language-adaptors/rxjava-groovy/build/libs/rxjava-groovy-0.5.5-SNAPSHOT.jar 
-rw-r--r--  1 bechristensen  CORP\Domain Users  1115 Mar 11 13:08 build/libs/rxjava-groovy-0.5.5-SNAPSHOT.jar
```

Or you can go into an individual project and build it:

```
$ cd language-adaptors/rxjava-groovy/
$ ../../gradlew build
```

The contents are like this:

```
$ jar tvf build/libs/rxjava-groovy-0.5.5-SNAPSHOT.jar 
     0 Mon Mar 11 13:08:14 PDT 2013 META-INF/
    25 Mon Mar 11 13:08:14 PDT 2013 META-INF/MANIFEST.MF
     0 Thu Feb 28 12:09:40 PST 2013 rx/
     0 Thu Feb 28 12:09:40 PST 2013 rx/lang/
     0 Mon Mar 11 13:08:14 PDT 2013 rx/lang/groovy/
   809 Mon Mar 11 13:08:14 PDT 2013 rx/lang/groovy/GroovyAdaptor.class
```
 =||= Each language-adaptor will have a build.grade file which would be changed.

For example, https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-groovy/build.gradle
 =||= Is scala/groovy/clojure supposed to be available or installed or such? It could be the reason I am getting such a small jar is that it gradle doesn't know what do to with these files? I built with -d to see if any error messages would surface but I couldn't spot anything obvious.

To wit: ./gradlew clean build  generates this:

Projects/RxJava$ ls -la language-adaptors/build/libs/
total 24
drwxr-xr-x  5 matt  staff  170 Mar 11 19:16 .
drwxr-xr-x  6 matt  staff  204 Mar 11 19:16 ..
-rw-r--r--  1 matt  staff  261 Mar 11 19:16 language-adaptors-0.5.5-SNAPSHOT-javadoc.jar
-rw-r--r--  1 matt  staff  261 Mar 11 19:16 language-adaptors-0.5.5-SNAPSHOT-sources.jar
-rw-r--r--  1 matt  staff  261 Mar 11 19:16 language-adaptors-0.5.5-SNAPSHOT.jar

Which, as you can see, is a set of 261-byte jars. Each jar contains only an empty manifest file. So until I can actually build something from the git codebase, the language-adaptors can't be turned into OSGi bundles.

I'm happy to not be concerned with them in this issue as they are only used for people wanting to use them, which can be considered a separate path. Perhaps someone can raise a new issue when they want to use these languages? That would allow you to commit your change and close this issue.
 =||= There is nothing beyond Java needed to build the project so I don't know what's going on with your build.

I have submitted a pull request with the discussed changes. Please review and let me know if they look right.

Here is the rxjava-core manifest:

```
Manifest-Version: 1.0
Export-Package: rx.subjects;uses:="rx.util,rx,rx.util.functions";versi
 on="0.5.6.SNAPSHOT",rx.util;uses:="rx,rx.util.functions";version="0.5
 .6.SNAPSHOT",rx.util.functions;uses:="org.slf4j";version="0.5.6.SNAPS
 HOT",rx.observables;uses:="rx.util.functions,rx";version="0.5.6.SNAPS
 HOT",rx.operators;uses:="rx,rx.util.functions,rx.util,rx.observables"
 ;version="0.5.6.SNAPSHOT",rx.plugins;version="0.5.6.SNAPSHOT",rx;uses
 :="rx.util.functions,rx.util,rx.plugins,rx.operators";version="0.5.6.
 SNAPSHOT"
Ignore-Package: junit.framework,org.mockito,org.mockito.verification,o
 rg.mockito.stubbing,org.junit
Tool: Bnd-1.50.0
Bundle-Name: rxjava-core
Created-By: 1.7.0_13 (Oracle Corporation)
Bundle-Vendor: Netflix
Bundle-Version: 0.5.6.SNAPSHOT
Bnd-LastModified: 1363058955000
Bundle-ManifestVersion: 2
Bundle-DocURL: https://github.com/Netflix/RxJava
Import-Package: org.slf4j;version="[1.7,2)"
Bundle-SymbolicName: com.netflix.rxjava.core
```

Here is a manifest for rxjava-groovy to show a language adaptor:

```
Manifest-Version: 1.0
Export-Package: rx.lang.groovy;uses:="groovy.lang,rx.util.functions";v
 ersion="0.5.6.SNAPSHOT"
Bundle-Vendor: Netflix
Bundle-Version: 0.5.6.SNAPSHOT
Tool: Bnd-1.50.0
Bundle-Name: rxjava-groovy
Bnd-LastModified: 1363058977000
Created-By: 1.7.0_13 (Oracle Corporation)
Bundle-ManifestVersion: 2
Bundle-DocURL: https://github.com/Netflix/RxJava
Bundle-SymbolicName: com.netflix.rxjava.groovy
Import-Package: groovy.lang;version="[2.1,3)",rx.util.functions;versio
 n="[0.5,1)"
```

Of course when released the version with be correct and not have SNAPSHOT in it.
 =||= For the language modules, please add the following instruction to the jar manifest config:

instruction 'Fragment-Host', 'com.netflix.rxjava.core'

This will give the language modules the name of the rxjava-core jar to attach themselves to, thereby allowing their classes to be joined to core's class path and thus discoverable.

Otherwise, looks great! 
 =||= Okay, I'll add that.
 =||= What does this represent => com.netflix.rxjava.core

That is not a package or module name.
 =||= I see that it shows up as `Bundle-SymbolicName` but I don't understand where that comes from as the module name is `rxjava-core`.
 =||= @mattbishop Is that pull request correct?
 =||= That's the symbolic name of the rxjava-core bundle (jar).  It is generated by the OSGi plugin.

## 

Matt Bishop

On 2013-03-12, at 9:47 AM, Ben Christensen notifications@github.com wrote:

> What does this represent => com.netflix.rxjava.core
> 
> That is not a package or module name.
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= Okay ... merging now.
 =||= This will go out in the next release.
 =||= Ben, thank you for taking the time to engage this issue so decisively even though your use has no need of OSGi. It's great to see. I'll pay attention to the issues and pitch in when OSGi comes up in the future.

On 2013-03-12, at 1:27 PM, Ben Christensen notifications@github.com wrote:

> This will go out in the next release.
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= You're welcome, I appreciate your patience (a week of travel in the middle didn't help in that regard) while I got to it.

I hope ~~Hystrix~~ RxJava can create value for you as it has for us.
 =||= @benjchristensen  and by Hystrix, you meant RxJava ;)
 =||= Ugh ... yes :-)
 =||= That's what I get for flipping between two projects so much ... they morph into the same!
 =||= @mattbishop Now that the code is released have you been able to confirm that it works as needed via Maven Central?
 =||= Considering this completed as I have received no updates or complaints since releasing it.
 =||= Hi in case you're interested I am usually using a gradle plugin to convert normal jars to osgi bundles.
See https://github.com/SimonScholz/rxjava-osgi/

I've also written a tutorial how to do that: http://www.vogella.com/tutorials/EclipseJarToPlugin/article.html#convert-jar-files-to-osgi-bundles-with-gradle =||= ,0
205,202,behavior of concat(Observable<Observable<T>>),I have a question about the behavior of concat when given an observable of observables.  Currently, it seems to materialize its input into a list, then concat the list. This runs counter to my expectation, which would be that new observables could be produced while the concat is underway.  In other words, (a) elements from the first Observable<T> should be rendered by concat() even if the Observable<Observable<T>> is blocked, and (b) the concat()ed observable should not start pulling elements from the next Observable<T> (or call onCompleted) until the current Observable<T> calls onCompleted.

I have written a failing unit test which illustrates the behavior I was expecting:
https://gist.github.com/abliss/5205333

My question, then is (1) does this match the behavior of .net, (2) if so, is this a design decision you're comfortable emulating, and (3) if so, does this match everyone else's intuition given the current documentation (which is silent on this issue)?

If the answer to any of the above is "no", I'm happy to provide a patch.  ,The Observable of Observable in Concat was something I put in last minute
for completeness.  It was NOT the desired implementation.  I meant to
update that code, but never got around to it.  If you have patch, please
send it.  I probably will take a look at this weekend again.    Thanks for
bringing this up.

On Wed, Mar 20, 2013 at 8:01 AM, abliss notifications@github.com wrote:

> I have a question about the behavior of concat when given an observable of
> observables. Currently, it seems to materialize its input into a list, then
> concat the list. This runs counter to my expectation, which would be that
> new observables could be produced while the concat is underway. In other
> words, (a) elements from the first Observable should be rendered by
> concat() even if the Observable<Observable<T>> is blocked, and (b) the
> concat()ed observable should not start pulling elements from the next
> Observable (or call onCompleted) until the current Observable<T> calls
> onCompleted.
> 
> I have written a failing unit test which illustrates the behavior I was
> expecting:
> https://gist.github.com/abliss/5205333
> 
> My question, then is (1) does this match the behavior of .net, (2) if so,
> is this a design decision you're comfortable emulating, and (3) if so, does
> this match everyone else's intuition given the current documentation (which
> is silent on this issue)?
> 
> If the answer to any of the above is "no", I'm happy to provide a patch.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/202
> .
 =||= ,0
225,199,SubscribeOn/ObserveOn Implementation,Implementation SubscribeOn #11 and ObserveOn #12 alongside with basic Schedulers implementation #19.,[RxJava-pull-requests #39](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/39/) FAILURE
Looks like there's a problem with this pull request
 =||= .NET implementation of a Scheduler interface contains methods like

``` C#
Schedule<TState>(TState, Func<IScheduler, TState, IDisposable>) 
```

To be honest, I don't quite understand why it is designed to use `Func<IScheduler, TState, IDisposable>` function as an action. I used `Func0<Subscription>` in the implementation and it seems to fit well.
 =||= [RxJava-pull-requests #40](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/40/) FAILURE
Looks like there's a problem with this pull request
 =||= This is great stuff @mairbek, thank you!

This one is going to result in a lot of discussion so won't be pulled in right away and will likely involve some changes.

For example, a discussion is being kicked off with Erik Meijer (inventor of Rx at Microsoft) to clarify some design decisions on this.
 =||= @sgudiboina if you can join in on the review of this it would be helpful.

@mairbek Erik himself has stated on Twitter that RxJava needs Schedulers so this is definitely high priority!

Anyone else with time to get involved please do. The design of Schedulers will have long-lasting impact so we want to get it as close to right as possible now.
 =||= Anyone getting involved please review https://github.com/Netflix/RxJava/issues/19 for context.
 =||= @mairbek This is great work, thank you for the research and thought you obviously did for this and the clean and well-written code.

I've posted my questions and comments via the inline code mechanism so they are contextual. 
 =||= [RxJava-pull-requests #71](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/71/) FAILURE
Looks like there's a problem with this pull request
 =||= [RxJava-pull-requests #74](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/74/) FAILURE
Looks like there's a problem with this pull request
 =||= This request can no longer be automatically merged so I have manually merged it and done some further work on top of your commits at https://github.com/Netflix/RxJava/pull/225.

Please review what I've done. If possible I'd like to merge and release within the next 24 hours.

I'm closing this request since all of your commits are now contained on https://github.com/Netflix/RxJava/pull/225.

Great work @mairbek I appreciate you taking this on.
 =||= ,0
228,55,Operator: Interval,http://msdn.microsoft.com/en-us/library/hh229027(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228911(v=vs.103).aspx,It seems like `Interval` shares logic with the `Timer` from issue #92.

`Interval` could be implemented as a [`Timer` call](http://msdn.microsoft.com/en-us/library/hh229652%28v=vs.103%29.aspx) with `dueTime == 0`.
 =||= Sure, as soon as Timer is implemented or schedulers can do periodic scheduling, the implementation of `Interval` will get a lot simpler.
 =||= Is the `interval` operator intended to work if there are several subscribers? It looks as if this was simply forgotten...
 =||= Actually, I'm not sure whether `interval` itself should or shouldn't support this. - However, you should always be able to use `publish`/`connect`. If that doesn't work, then there's definitely something wrong. I can go check that later. I probably didn't think of that when implementing it...
 =||= I just tried it out in C#. This code:

```
static void Main() {
    var oneNumberPerSecond = Observable.Interval(TimeSpan.FromSeconds(1)).Take(5);
    oneNumberPerSecond.Subscribe(
    x => Console.WriteLine("subscriber 1 got " + x)
    );
    oneNumberPerSecond.Subscribe(
    x => Console.WriteLine("subscriber 2 got " + x)
    );
    Console.ReadLine();
}
```

produces this output:

```
subscriber 2 got 0
subscriber 1 got 0
subscriber 2 got 1
subscriber 1 got 1
subscriber 2 got 2
subscriber 1 got 2
subscriber 2 got 3
subscriber 1 got 3
subscriber 2 got 4
subscriber 1 got 4
```

So I think we should update the RxJava version to support multiple subscribers.
 =||= Compare to Java. Code:

```
public static void main(String[] args) {
    Observable<Long> oneNumberPerSecond = Observable.interval(1, TimeUnit.SECONDS).take(5);
    oneNumberPerSecond.subscribe(new Action1<Long>() {
        public void call(Long x) {
            System.out.println("subscriber 1 got " + x);
        }           
    });
    oneNumberPerSecond.subscribe(new Action1<Long>() {
        public void call(Long x) {
            System.out.println("subscriber 2 got " + x);
        }           
    });     
}
```

Output:

```
subscriber 1 got 0
subscriber 2 got 1
subscriber 1 got 2
subscriber 2 got 3
subscriber 1 got 4
subscriber 2 got 5
subscriber 1 got 6
subscriber 2 got 7
subscriber 1 got 8
subscriber 2 got 9
```

I think this will be used a lot for small examples and so it should be fixed soon. @benjchristensen could you please reopen this issue?
 =||= What does Rx.NET do when you wait a bit before subscribing the second time?

Will it do this?

```
subscriber 1 got 0
subscriber 1 got 1
subscriber 1 got 2
subscriber 2 got 2
subscriber 1 got 3
subscriber 2 got 3
subscriber 1 got 4
subscriber 2 got 4
```

Or will it still start at 0 with subscriber 2?
 =||= I added a first test for that use case here: https://github.com/jmhofer/RxJava/commit/2fe6da751957b41dd1b89083ec3aaed940042065

It fails, as expected from your comment above.
 =||= The Rx Design Guidelines (5.10) say:

> As many observable sequences are cold (see cold vs. hot on Channel 9), each subscription will have a separate set of side-effects. Certain situations require that these side-effects occur only once. The Publish operator provides a mechanism to share subscriptions by broadcasting a single subscription to multiple subscribers.

So I guess it would be okay for the second subscriber to always start at 0 too when subscribing to the same observable later (and not using `publish`/`connect`)?
 =||= There are probably other operators that are affected by this, too, because multiple subscribers are currently normally not getting tested by the unit tests...
 =||= Here's another  example from C#:

```
    static void Main() {
        var oneNumberPerSecond = Observable.Interval(TimeSpan.FromSeconds(1)).Take(5);
        var watch = new Stopwatch();
        watch.Start();

        Thread.Sleep(2200);

        Console.WriteLine("subscriber 1 subscribes at t=" + watch.ElapsedMilliseconds);
        oneNumberPerSecond.Subscribe(
            x => Console.WriteLine("subscriber 1 got " + x + " at t=" + watch.ElapsedMilliseconds)
        );

        Thread.Sleep(1300);

        Console.WriteLine("subscriber 2 subscribes at t=" + watch.ElapsedMilliseconds);
        oneNumberPerSecond.Subscribe(
            x => Console.WriteLine("subscriber 2 got " + x + " at t=" + watch.ElapsedMilliseconds)
        );

        Console.ReadLine();
    }
```

outputs:

```
subscriber 1 subscribes at t=2200
subscriber 1 got 0 at t=3322
subscriber 2 subscribes at t=3615
subscriber 1 got 1 at t=4319
subscriber 2 got 0 at t=4642
subscriber 1 got 2 at t=5329
subscriber 2 got 1 at t=5643
subscriber 1 got 3 at t=6331
subscriber 2 got 2 at t=6643
subscriber 1 got 4 at t=7344
subscriber 2 got 3 at t=7655
subscriber 2 got 4 at t=8656
```

So each subscriber starts at 0.
 =||= Great, thanks. This means that my PR above should fix this.
 =||= Yes, every new subscriber should start the Observable from the beginning. I have tried to make sure that's the case everywhere but apparently missed this one.

If an Observable does not want that behavior that is what the various `multicast` options are for such as `publish`, `replay`, `cache` etc.
 =||= Merged in https://github.com/Netflix/RxJava/pull/379 so closing again.
 =||= ,0
229,19,Rx Schedulers,Implementation of Rx Schedulers (http://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx) ... probably to go into the rx.concurrency package (https://github.com/Netflix/RxJava/tree/master/rxjava-core/src/main/java/rx/concurrency). ,Interesting quote from that page
"If you do not use the overload which takes a scheduler as an argument, Rx will pick a default scheduler by using the principle of least concurrency.  This means that the scheduler which introduces the least amount of concurrency that satisfies the needs of the operator is chosen.  For example, for operators returning an observable with a finite and small number of messages, Rx calls Immediate.  For operators returning a potentially large or infinite number of messages, CurrentThread is called. For operators which use timers, ThreadPool is used."
 =||= How would an operator know how many messages it is going to have? Only the origin Observable could know that - a given operator along the chain won't know so how does this get accomplished?
 =||= I guess this would mean that things like "toObservable(1, 2, 3, 4)" are a known thing and can be done immediately without a thread, but merging 4 unknown sequences can't be known.

Obviously when Timers are used a Thread of some kind is needed (java.util.Timer or another implementation like this: https://github.com/Netflix/Hystrix/blob/master/hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixTimer.java).

For the majority of cases though where the "cost" of the observable sequence is unknown I don't know that I like automatically spawning them off on threads. It has worked well for the Netflix API to leave that choice to the origin of the observable (to be synchronous or asynchronous, one thread or many, etc).

The introduction of Schedulers makes perfect sense when an app is dealing with data structures, their own synchronous IO operations or CPU bound computations, but it becomes awkward when consuming from a 3rd party API exposing Observables who can and will make their own choice about being synchronous or asynchronous.

In fact, that's been a huge part of the draw to Rx is that the API doesn't need to change when the backend implementations moves between synchronous and asynchronous for whatever reason it may choose to do so.

If the Observable is already asynchronous it would be inefficient to spin up another thread that in turn blocks on an async call.

Other than documentation on the API calls that return Observables is there a better way to handle that scenario?

I can imagine a scenario where some apps (such as the Netflix API) may want to disable any use of Schedulers so the origin retains control since Rx has allowed us to decouple the writing of business logic from the decisions of concurrency.

Before flaming me ... I DO like schedulers, it's very powerful and we will definitely get them added, I just have some questions about balancing that power (and inevitable inefficiencies of making poor scheduler choices) with the elegant simplicity of Rx Observables without them where concurrency is not a thought - everything is just asynchronous.

I'm interested in all of your perspectives so please chime in.
 =||= The docs say "least amount of concurrency" which I interpreted to mean that if the amount of work is unknown that it would it default to immediate.  We could still manipulate the defaults and probably ignore Schedulers passed in through a strategy.
 =||= Yes, I think a strategy pattern will be needed to accomplish the Netflix API use case.
 =||= Some thoughts while working on the design of this:
- The Scheduler interface should be capable of supporting different sources of concurrency such as Executors, Threads, Actors, EventLoops
- We should be capable of supporting rxjava-contrib modules with new types of Schedulers such as for Akka/Scala Actors
- We need the ability (via plugins probably) of a system to override or prevent usage of Schedulers where they want. For example, if a system doesn't want client code starting threads they should be able to intercept and ignore or throw UnsupportedOperationException.
 =||= Sections 6.9 through 6.12 of the Rx Design Guidelines PDF (http://go.microsoft.com/fwlink/?LinkID=205219) should be read by anyone involved in Schedulers design and implementation.
 =||= There's also [this video](http://channel9.msdn.com/blogs/j.van.gogh/controlling-concurrency-in-rx) explaining the motivation behind introducing schedulers in Rx.
 =||= Good video ... thanks for the link.
 =||= First round of Schedulers implementation committed via pull request https://github.com/Netflix/RxJava/pull/225 contribued by @mairbek.

It implements ObserveOn (https://github.com/Netflix/RxJava/issues/11) and SubscribeOn (https://github.com/Netflix/RxJava/issues/12).
 =||= Open questions:

### 1) Scheduler Time

We're not using the Scheduler.now value anywhere, should we be? or is that only for the Virtual scheduler used for testing?

### 2) Use of SubscribeOn vs Scheduler.scheduler

I'm trying to understand how operator overloads should use Scheduler.

Here is a potential implementation: https://github.com/Netflix/RxJava/pull/227 and another https://github.com/Netflix/RxJava/pull/226

I have not yet found C# source code or documentation that clarifies this.

I have also had feedback (that I agree with) that it this is clearer:

``` java
merge(o1, o2).subscribeOn(scheduler)
```

than this

``` java
merge(o1, o2, scheduler)
```

So is there anything different between this? 

### 3) Multiple Schedulers in Sequence

I'm trying to understand how a sequence should work when multiple `subscribeOn` operators are applied at different steps of a sequence and it is unclear to me  how the unit test below should behave.

Can someone with an Rx.Net environment setup implement a test similar to this from Java and tell me the output?

``` java
@Test
    public void testMixedSchedulers() throws InterruptedException {
        final String mainThreadName = Thread.currentThread().getName();

        Observable<String> o = Observable.<String> create(new Func1<Observer<String>, Subscription>() {

            @Override
            public Subscription call(Observer<String> observer) {

                System.out.println("Origin observable is running on: " + Thread.currentThread().getName());

                assertFalse(Thread.currentThread().getName().equals(mainThreadName));
                assertTrue("Actually: " + Thread.currentThread().getName(), Thread.currentThread().getName().startsWith("RxIOThreadPool"));

                observer.onNext("one");
                observer.onNext("two");
                observer.onNext("three");
                observer.onCompleted();

                return Subscriptions.empty();
            }
        }).subscribeOn(Schedulers.threadPoolForIO()); // subscribe to the source on the IO thread pool

        // now merge on the CPU threadpool
        o = Observable.<String> merge(o, Observable.<String> from("four", "five"))
                .subscribeOn(Schedulers.threadPoolForComputation())
                .map(new Func1<String, String>() {

                    @Override
                    public String call(String v) {
                        // opportunity to see what thread the merge is running on
                        System.out.println("Merge is running on: " + Thread.currentThread().getName());
                        return v;
                    }

                });

        final CountDownLatch latch = new CountDownLatch(1);

        final AtomicReference<RuntimeException> onError = new AtomicReference<RuntimeException>();

        // subscribe on a new thread
        o.subscribe(new Observer<String>() {

            @Override
            public void onCompleted() {
                System.out.println("==> received onCompleted");
                latch.countDown();
            }

            @Override
            public void onError(Exception e) {
                System.out.println("==> received onError: " + e.getMessage());
                onError.set((RuntimeException) e);
                latch.countDown();
            }

            @Override
            public void onNext(String v) {
                System.out.println("==> Final subscribe is running on: " + Thread.currentThread().getName());
                System.out.println("==> onNext: " + v);

            }
        }, Schedulers.newThread());

        // wait for the above to finish or blow up if it's blocked
        latch.await(5, TimeUnit.SECONDS);
    }
```

Of course Rx.Net doesn't have the IO and CPU thread pools ... those are just helper methods to Executors which would be 2 separate threadpools for different work types so you'll need to adjust that.
 =||= Concerning 1), I guess it will come in handy when implementing #90 (or clock-like observables in general), at least if I understand this correctly. I'm currently figuring out how working with the schedulers feels by playing around with an implementation for #74, which also requires a "clock", though it doesn't seem to require the current time).
 =||= I received the following feedback that will require a breaking change to the Scheduler interface:

---

> It is essential to be able to access the scheduler inside the action to recursively schedule yourself. Just having a Func1<Subscription is not very useful since there is no opportunity to return the subscription before the function terminates.

``` C#
Interface IScheduler
{
Schedule<TState>(TState s, Func<IScheduler, TState, IDisposable> a)          
               Schedule<TState>(TState s, DateTimeOffset d, Func<IScheduler, TState, IDisposable> a).
               Schedule<TState>(TState s, TimeSpan t, Func<IScheduler, TState, IDisposable> a)
}
```

> You want to be able to write something like this

``` C#
void Main()
{
     var repeat = Observable.Create<int>(observer =>
     {
         while(true) observer.OnNext(42);
         return () => {};
     });

     //var dispose = repeat.Subscribe(Console.WriteLine);

     var dispose = ObservableEx.ToObservable(NewThreadScheduler.Default)
                  .Select(_ => 42)
                  .Subscribe(x => Console.WriteLine(x));

     Console.ReadLine();
     dispose.Dispose();
     Console.WriteLine("Bye");
}

static class ObservableEx
{
     public static IObservable<Unit> ToObservable(this IScheduler scheduler)
     {
    return Observable.Create<Unit>(observer =>
         {
              return scheduler.ScheduleAsync(async (_scheduler, token) =>
              {
                  while(!token.IsCancellationRequested)
                  {
                     observer.OnNext(Unit.Default);
                       await _scheduler.Sleep(TimeSpan.FromSeconds(2));
                   }
              });
         });
     }
}
```
 =||= Here is another use case:

``` C#
var scheduler = TaskPoolScheduler.Default;

var xs = Observable.Generate
     ( 0
     , i=>true
     , i=>i+1
     , i=>i
     , i=>TimeSpan.FromSeconds(1)
     , scheduler
     );

var ys = Observable.Create<int>(observer =>
{
     return scheduler.ScheduleAsync(async (_scheduler, cancel) =>
     {
         await _scheduler.Yield();
         for(var i = 0; !cancel.IsCancellationRequested; i++)
         {
              observer.OnNext(i);
              await _scheduler.Sleep(TimeSpan.FromSeconds(1));
         }
     });
});

//var dispose = ys.Timestamp().Subscribe(x => Console.WriteLine(x.ToString()));
var dispose = ys.Timestamp().DumpLive().Subscribe();
Console.ReadLine();
dispose.Dispose();
Console.WriteLine("disposed");
Console.ReadLine();
```
 =||= Note that I'm unavailable to work on this until the 15th. Anyone else who wants to jump in and determine the changes needed based on this feedback please do. 
 =||= Here is some simple code I was playing with to prove out the use of `subscribeOn` from an "Observable API" and it appears to be working as we want and from what I can tell it is conforming to the Rx contract and not injecting concurrency where it shouldn't.

Anyone find faults in this?

``` groovy
import rx.*
import rx.concurrency.Schedulers

/*
 * ******** PRODUCER CODE ******** 
 * This is the "Observable API"
 */

Observable<Video> getVideos() {
    return Observable.create({
        observer ->
        Thread.sleep(200); // simulate network traffic
        // 10 videos are fetched in a batch and emitted
        observer.onNext(new Video(1));
        observer.onNext(new Video(2));
        observer.onNext(new Video(3));
        observer.onNext(new Video(4));
        observer.onNext(new Video(5));
        observer.onNext(new Video(6));
        observer.onNext(new Video(7));
        observer.onNext(new Video(8));
        observer.onNext(new Video(9));
        observer.onNext(new Video(10));
        observer.onCompleted();
    })
}


class Video {
    final int id;
    public Video(int id) {
        this.id = id;
    }


    Observable<Rating> getRating() {
        return Observable.create({
            observer ->
            Thread.sleep(200); // simulate network traffic
            observer.onNext(new Rating(id));
            observer.onCompleted();
        }).subscribeOn(Schedulers.threadPoolForIO())
    }

    Observable<Bookmark> getBookmark() {
        return Observable.create({
            observer ->
            Thread.sleep(200); // simulate network traffic
            observer.onNext(new Bookmark(id));
            observer.onCompleted();
        }).subscribeOn(Schedulers.newThread())
    }
}

class Rating {
    final String value;
    public Rating(int id) {
        this.value = "ratingFor_" + id;
    }
}

class Bookmark {
    final String value;
    public Bookmark(int id) {
        this.value = "bookmarkFor_" + id;
    }
}



/*
 * ******** CONSUMER CODE ********
 * This is a client consuming the "Observable API"
 */
long start = System.currentTimeMillis();
getVideos().mapMany({
    Video video ->
    // fetch and transform bookmark
    Observable ob = video.getBookmark().map({b -> 
        return "transformed-" + b.value;
    })

    // fetch ratings and zip together with bookmark
    return Observable.zip(ob, video.getRating(), {b, r -> return [b.value, r.value]})
    .map({ tuple ->
        // combine all metadata for a single Video
        return ["id" : video.id, "bookmark" : tuple[0], "rating": tuple[1]]
    })
}).forEach({
    videoMap ->
    System.out.println("Video: " + videoMap["id"] + "   bookmark: " + videoMap["bookmark"] + "   rating: " + videoMap["rating"] + " Thread: " + Thread.currentThread());
})

long end = System.currentTimeMillis();

System.out.println("time: " + (end-start))
```

Output is:

```
Video: 5   bookmark: transformed-bookmarkFor_5   rating: ratingFor_5 Thread: Thread[RxIOThreadPool-5,5,main]
Video: 9   bookmark: transformed-bookmarkFor_9   rating: ratingFor_9 Thread: Thread[RxIOThreadPool-9,5,main]
Video: 10   bookmark: transformed-bookmarkFor_10   rating: ratingFor_10 Thread: Thread[RxIOThreadPool-10,5,main]
Video: 2   bookmark: transformed-bookmarkFor_2   rating: ratingFor_2 Thread: Thread[RxIOThreadPool-2,5,main]
Video: 4   bookmark: transformed-bookmarkFor_4   rating: ratingFor_4 Thread: Thread[RxIOThreadPool-4,5,main]
Video: 8   bookmark: transformed-bookmarkFor_8   rating: ratingFor_8 Thread: Thread[RxIOThreadPool-8,5,main]
Video: 6   bookmark: transformed-bookmarkFor_6   rating: ratingFor_6 Thread: Thread[RxIOThreadPool-6,5,main]
Video: 3   bookmark: transformed-bookmarkFor_3   rating: ratingFor_3 Thread: Thread[RxIOThreadPool-3,5,main]
Video: 7   bookmark: transformed-bookmarkFor_7   rating: ratingFor_7 Thread: Thread[RxIOThreadPool-7,5,main]
Video: 1   bookmark: transformed-bookmarkFor_1   rating: ratingFor_1 Thread: Thread[RxIOThreadPool-1,5,main]
time: 659
```
 =||= @benjchristensen I'm left wondering if or how question 3) from your comment (https://github.com/Netflix/RxJava/issues/19#issuecomment-15979582) was addressed or whether this is still an open question?

In our app we haven't quite figured out yet which layer should be responsible for scheduling an observable. If we schedule on the service layer--which would make sense when trying to make client code oblivious as to whether code runs concurrently or not--then what does that mean for reusability of observables? Would, say, service A be able to take an observable from service B which has already been scheduled by B, transform and re-schedule it?

With the pre-0.8 Schedulers, this is not possible, since subscribeOn/observeOn will wrap as many times as you call these methods.
 =||= I think the JavaDocs haven't been updated yet: http://netflix.github.io/RxJava/javadoc/rx/Scheduler.html

Is there any documentation / examples around what the state parameter is used for? Looking at the existing schedulers, I only ever see it being passed through, so I wonder what this accomplishes?
 =||= Here's an example (by @mairbek) using state: https://github.com/Netflix/RxJava/pull/229#issuecomment-16115941
 =||= I forgot to upload the new Javadocs ... will do so once I'm at my laptop. Sorry about that. 
 =||= @mttkay I found wifi ... uploaded javadocs for 0.8.0.

Also, the example from @mairbek was incorporated into unit tests here: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java#L255
 =||= I believe we're pretty comfortable with the `Schedulers` implementation and interface as of 0.11/0.12 so closing this out.
 =||= ,0
234,233,ScheduledObserver doesn't Guaranty Ordering,`ScheduledObserver` should be reimplemented the way that it guaranties ordering of the events.

Right now this test prints values in different ordering. 

``` java
    @Test
    public void testToIteratorObserveOn() {
        Observable<String> obs = Observable.from("one", "two", "three", "four");

        Iterable<String> it = obs.observeOn(Schedulers.threadPoolForComputation()).toIterable();

        for (String s : it) {
            System.out.println(s);
        }

    }
```,This is used as a pass-thru for `ObserveOn` to a `Scheduler` so why does this need to ensure ordering? That should be up to the scheduler implementation should it not?

For example, if I need to ensure ordering then I probably don't sent it to a thread-pool, but send it to a single thread (such as the UI thread).

If I choose to send something to a thread-pool for execution on multiple threads why should I expect the events to all be processed and returned in order when I am specifically injecting concurrency.

I can't find anything in the Rx Design Guidelines that dictates that order should be retained and it's not at all guaranteed by all operators (for example `merge` definitely does not retain order whereas `concat` does).
 =||= Quote from the  _4.2. Assume observer instances are called in a serialized fashion_

> Consumers of observables can safely assume that messages arrive in a serialized fashion.
> 
>    var count = 0;
>    xs.Subscribe(v =>
>    {
>    count++;
>    Console.WriteLine("OnNext has been called {0} times.", count); 
>    });
> 
> In this sample, no locking or interlocking is required to read and write to count as only one call to OnNext can be in-flight at any time.

If ordering is not guarantied we might observe `onComplete` event before `onNext`. In this case operators like `toIterator` doesn't work correctly.
 =||= But I don't read that to mean ordered. We must ensure the contract of onNext|onCompleted|onError but I don't see how we need to or should ensure that execution of onNext events arrive in the same order once they've been thrown off on a thread-pool and multiple threads.

Do you think otherwise?
 =||= You can take a look at an Observer wrapper we used in production in our internal version before open-sourcing that allows concurrent onNext executions but ensures the onCompleted/onError contract: https://gist.github.com/benjchristensen/5400653

We were more lenient in our internal version about allowing concurrent execution of onNext since we forced everything to be functional and without state (which I still actually prefer and think onNext should be allowed to be concurrent) but when we open sourced I removed this since it is against the contract of official Rx and do not allow concurrent onNext execution.

However, it shows the principle of how onNext calls could interleave (be out of order) but still be serialized while ensuring onCompleted/onError occur only at the end after all onNext calls are completed.
 =||= Thinking about this more ... the ordering still isn't the part that concerns me (though maybe it should) but the real issue here is that each onNext/onCompleted/onError could be triggered on a separate thread.

We need to not only ensure only one of those is running at a time but then we ensure visibility/memory consistency. This means we are basically forced into wrapping this in `SynchronizedObserver` so only a single onNext/onCompleted/onError call is happening at any given time, correct?

Without that I can't see `ObserveOn` complying with the Rx contract.
 =||= I thought if `onNext` calls are sequential it makes sense to make them sequencial in the order they have appeared. I've tried to implement non-blocking algorithm to make it work #234.
 =||= > We need to not only ensure only one of those is running at a time but then we ensure visibility/memory consistency. This means we are basically forced into wrapping this in SynchronizedObserver so only a single onNext/onCompleted/onError call is happening at any given time, correct?

Using only `SynchronizedObserver` itself wouldn't be helpful, since it doesn't guaranty the ordering of the events. `OnCompleted` could be called before `OnNext`.

It is a good question whether memory consistency/visibility should be responsibility of the library or of the observer.
 =||= It would guarantee ordering if the synchronization happens BEFORE putting the event on to the Scheduler since they would enter and leave the Scheduler in the same order they hit the SynchronizedObserver.

It should only be permitted to schedule one event at a time. It can't schedule more than one at a time because then you can no longer prevent them from running concurrently.
 =||= I believe this was fixed in https://github.com/Netflix/RxJava/commit/f1be5f4addf30f47b1d915ca708566bf49beb7f8 and https://github.com/Netflix/RxJava/commit/071b8943520dd8aa3b05c2b3c6c452a81778ebae
 =||= ,0
248,74,Operator: Sample,http://msdn.microsoft.com/en-us/library/hh211615(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211892(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229742(v=vs.103).aspx,Still have one overload to do:

``` c#
public static IObservable<TSource> Sample<TSource, TSample>(
    this IObservable<TSource> source,
    IObservable<TSample> sampler
)
```
 =||= I can take this.
 =||= Done.
 =||= ,0
249,93,Operator: Timestamp,http://msdn.microsoft.com/en-us/library/hh211605(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229003(v=vs.103).aspx,the scheduler overload has not done yet.
 =||= Can I take this?
 =||= Done.
 =||= ,0
250,17,Subject implementations,http://msdn.microsoft.com/en-us/library/hh242969(v=vs.103).aspx

This issue is intended to cover the implementation of various Subjects as part of Rx.Net intended for placement in rx.subjects.,The ReplaySubject was implemented in https://github.com/Netflix/RxJava/pull/218
 =||= Hey I noticed this issue is still open. Did I forget to implement a Subject?
 =||= Looks like they are now all done. Thank you @michaeldejong 
 =||= ,0
257,20,Operator: Aggregate,Add aggregate (or alias to reduce?)

http://msdn.microsoft.com/en-us/library/hh229154(v=vs.103).aspx,Done in pull request #257 
 =||= ,0
259,13,Operator: Switch,http://msdn.microsoft.com/en-us/library/hh229197(v=vs.103).aspx,nan,0
312,306,issue with onErrorResumeNextFunction and async Observable,This may be a problem with MapObserver or OnErrorResumeXXX and is probably related to https://github.com/Netflix/RxJava/issues/216

If the function returned by OnErrorResumeXXX returns an async Observable then there is some unpredictable behavior with operators (eg Map) that rely on the AtomicObserver to generate a valid event stream

I've created a UnitTest below to demonstrate the problem. 

``` java
@Test
public void testMapError() {
    Observable<String> observable = Observable.from("one","error","two","three");

    Observable<String> m = Observable.create(map(observable, new Func1<String,String>() {

        @Override
        public String call(String in) {
            if ("error".equals(in))
                throw new RuntimeException("Simulated error");
            return in;
        }

    }));

    // Add error handler
    m=m.onErrorResumeNext(new Func1<Exception,Observable<String>>() {
        public Observable<String> call(Exception e) {
            return createSlowSequence(new String[] {"II","III"}); 
        }
    });

    m.subscribe(stringObserver);

    verify(stringObserver, times(1)).onNext("one");
        // Should be caught be OnErrorResumeNext
    verify(stringObserver, never()).onError(any(Exception.class));
    verify(stringObserver, never()).onNext("error");
    verify(stringObserver, never()).onNext("two");
    verify(stringObserver, never()).onNext("three");
        // Resume output
    verify(stringObserver, times(1)).onNext("II");
    verify(stringObserver, times(1)).onNext("III");
    verify(stringObserver, times(1)).onCompleted();
}

private Observable<String> createSlowSequence(final String[] seq) {
    return Observable.create(new Func1<Observer<String>,Subscription>() {
        public Subscription call(final Observer<String> ob) {
            new Thread() {
                /** Delay for a given time */
                public void waitFor(int ms) {
                    try { 
                      Thread.sleep(ms);
                    }
                    catch (InterruptedException e) {
                    }
                }
                /** Slowly emit a sequence */
                public void run() {
                    for (int i=0;i<seq.length;i++) {
                        waitFor(100);
                        ob.onNext(seq[i]);
                    }
                    ob.onCompleted();
                }
            }.start();

            return Subscriptions.empty();
        }
    });
}
```

There are two issues I see causing the problem, so two potential fixes.
1. MapObserver continues to emit onNext/onCompleted even after it has emitted onError. This pushes the problem downstream.
2. OnErrorResumeNext continues to propogate onNext/onCompleted even after it has subscribed the Observer(s) to the resume Observable. 

This means that if the resume Observable is async OnErrorResumeNext will emit one/more onNext and potentially onCompleted from the source Observable unless the resume Observable completes.

It could also trigger multiple subscriptions if the MapObserver produced another onError.

_A side note here is that the AtomicObserver fixes this issue if the resume Observable is sync (because it ignores the source Observable events after the resume Observable has completed). This effectively masks the problem in the OnErrorResumeNext unit-test. Perhaps the unit-tests should disable this behavior, or detect it via a plugin?_,nan,0
323,204,Explore code generation for language adaptors,RxJava was written from the beginning to target the JVM, not any specific language.

As a side-effect of Java not having lambdas/clojures yet (and other considerations), Netflix used dynamic languages with it predominantly for the year of its existence prior to open sourcing.

To bridge the rxjava-core written in Java with the various languages a FunctionalLanguageAdaptor is registered at runtime for each language of interest.

To enable this language adaptors method overloads with `Object` exist in the API since `Object` is the only super-type that works across all languages for their various implementations of lambdas and closures.

This downside of this is that it breaks static typing for Java, Scala and other static-typed languages. More can be read on this issue and discussion of the subject here: https://groups.google.com/forum/#!topic/rxjava/bVZoKSsb1-o

I would like to pursue the following:
- remove all `Object` overload methods from rxjava-core so it remains statically typed
- modify FunctionalLanguageAdaptors to not register with a lookup map but instead to trigger a code generation process at registration time
- the code generation would create the overload methods on `rx.Observable` for the types needed by that languages (such as `groovy.lang.Closure` or `clojure.lang.IFn`).

The benefits of this are:

1) Everything is statically typed so compile-time checks for Java, Scala, etc work correctly
2) Method dispatch is now done via native Java bytecode using types rather than going via `Object` which then has to do a lookup in a map. Memoization helped with the performance but each method invocation still required looking in a map for the correct adaptor. With this approach the appropriate methods will be compiled into the `rx.Observable` class to correctly invoke the right adaptor without lookups. 

The byte code generation step would happen once the first time a LanguageAdaptor is registered which is normally only at the first point of access to RxJava.,Some background on why the current design was chosen rather than having each language with a separate version of Observable:

---

The approach of having language specific packages/classes was pursued but did not work well because Rx is a composable library. It means that every time an `Observable` is used it needs to be re-wrapped or un-wrapped by whichever language is using it.

For example ...

From Java a library is exposed that has a method like this:

``` java
rx.Observable getData()
```

From Groovy a library is exposed with a method like:

``` java
rx.groovy.GroovyObservable getOtherData()
```

Then from Scala you need to wrap them again:

``` java
rx.scala.ScalaObservable.from(getOtherData())
```

This means we have an `rx.Observable` wrapped as `rx.groovy.GroovyObservable` wrapped as `rx.scala.ScalaObservable`.

To compose the two we would have:

``` java
rx.scala.ScalaObservable.zip(rx.scala.ScalaObservable.from(
      getOtherData()), 
      rx.scala.ScalaObservable.from(getData()),
       ... scala closure here ...);
```

Now what does `ScalaObservable` return from its operators? `ScalaObservable` or `Observable`?

Should the above zip operator return `rx.scala.ScalaObservable` or `rx.Observable`? What happens if this library is consumed from another language?

If `Observable` each step along the way it must be wrapped yet again. If `ScalaObservable` it has now changed all of the return types of `rx.Observable` to a subtype.

In short, for interop between languages it very quickly becomes a mess and our primary polyglot goal was that `rx.Observable` was usable across all libraries as the single type and because the whole point of Rx is chained composition it's not as simple as just a single decoration at the beginning. It affects every single method in an API and step of the chaining.

For this reason we chose the current language-adaptor model where it is made to understand the closure/lambda types of each of the languages so `rx.Observable` can remain the sole interface across languages.

The reason we did not use an interface such as `FuntionalLanguageAdaptor` instead of `Object` is that not all languages automatically reify to "functional interfaces". Java8 does - but it's already type-safe and works fine with the Func/Action interfaces. Clojure, Groovy, JRuby and Scala all require awkward non-idiomatic java-interop or interface implementation syntax instead of their native lambda/closure syntax - thus `Object` is unfortunately the first super-type they all have in common - especially to handle the different arities (`Func1`, `Func2`, `Func3` etc) that can be passed in.
 =||= Playing with this the 3 approaches I can see are:

1) Java agent (can be loaded dynamically without manually injecting -javaagent at command line) to use the Java Attach API to intercept `rx.Observable` being loaded and do bytecode generation
2) Custom classloader to intercept `rx.Observable` being loaded and do bytecode generation
3) Compile time step to perform bytecode generation after compiling `rx.Observable` and replace Observable.class with the new typed methods for each language before packaging as a Jar

Options 1 and 2 are nice in that they only add the methods needed by the desired languages at runtime, but they are bad in that they both need an initialization hook - something that is a lot to ask for a plain library, not a full framework controlling entire lifecycle so I don't think they are appropriate here.

Option 3 would include at compile time all of the methods needed for each language. This means that all runtimes would have that bytecode but if they don't have a particular language runtime loaded those methods could never be invoked.

The benefit is that all languages would use static types for method dispatch. The downside is that all the overloads would always exist even if someone is using just one of the languages.

A possible solution would be to generate different versions of the binary for each language - which would work fine if an environment is using only one language, but if more than one is being used it would be very confusing because someone couldn't just load the two separate binaries, they'd collide in the same namespace. A single binary with support for each language would need to be used.

I think the drawbacks of having all overloads for all languages in a single binary are small enough that it's worth pursuing to see how it works. 

The only awkward drawback I know of that can't easily be overcome is that while working on the RxJava source itself in an IDE and running Groovy/Clojure/JRuby etc it would be hitting directly compiled classes, not the binaries put through bytecode generation so they would fail. It would mean that tests can only be run from the full build process, or by supporting option 1 or 2 for the development cycle while in an IDE. This impacts a limited number of people though so is not a big enough reason to avoid pursuing the bigger benefits of maintain static typing and avoiding use of instanceof for dynamically determining what language adaptor to use to execute a function.

This is very exploratory and something I'm researching as I go (I generally do not like code generation or bytecode manipulation so have not used this approach before) so feedback is much appreciated.
 =||= If you're going with option 3, why not directly add these methods in the source, instead of adding them after compilation? - Probably I'm missing something here.

Anyway, instead of overloading the method with a single one where closures are mapped to `java.lang.Object`, you could add a method for each supported JVM language closure type. Let's take `subscribe` as an example.

Instead of

``` java
public Subscription subscribe(final Object o)
```

for all dynamic languages, you could introduce

``` java
public Subscription subscribe(final groovy.lang.Closure<?> cls)
```

and

``` java
public Subscription subscribe(final org.jruby.RubyProc proc)
```

and

``` java
public Subscription subscribe(final clojure.lang.IFn cls)
```

for each dynamic language.

It wouldn't even be absolutely necessary to support Scala directly, as Scala can always hook itself in via implicits.

Now, undoubtedly that's a lot of work, but I don't think you can get around that anyway. - But probably I'm overlooking something which makes this impossible? - The only big drawback I can think of atm is that it's not possible in that way to add another JVM-based language without touching the core. This doesn't worry me much, but maybe that's just me.

Also, there would be another "easy way out". You probably already thought of that. It's not pretty, though: Keep the methods taking objects, but instead of overloading the typesafe methods, name those differently. For example, pair

``` java
public Subscription subscribe(final Object o)
```

with

``` java
public Subscription typedSubscribe(final Action1<T> onNext)
```

Though it's certainly not ideal, I could live with that...
 =||= We could add all of the overloads directly to the source - but we're talking about 48 methods already and eventually probably double that and then multiplying that by the number of languages.

It makes the javadoc, source code and maintenance rather ridiculous and it becomes very error prone that every time a method is added or touched the overload for every language must also be done. It would severely impede people getting involved and touching the Observable.java class.

For these reasons I feel it's not a great approach - though it is a valid one.

I also strongly want to avoid different names - as that breaks the API across languages and doesn't really solve the real problem as people now need to know the different naming conventions in order to stay "type safe".

The amount of code to generate the methods is actually quite small, here's a prototype of me playing with it:

``` java
public class LanguageAdaptorCodeGenerator {

    static ClassPool pool = ClassPool.getDefault();

    public static void addSupportFor(Class<?>[] types) {
        CtClass cc;
        try {
            cc = pool.get(rx.Observable.class.getName());
        } catch (NotFoundException e) {
            throw new RuntimeException("Failed to add language adaptor methods as could not find rx.Observable.", e);
        }
        try {
            for (CtMethod method : cc.getMethods()) {
                CtClass[] argTypes = method.getParameterTypes();
                boolean containsFunctionType = false;
                for (CtClass argType : argTypes) {
                    if (isRxFunctionType(argType)) {
                        containsFunctionType = true;
                    }
                }
                if (containsFunctionType) {
                    try {
                        addMethod(cc, method, types);
                    } catch (Exception e) {
                        e.printStackTrace();
                        throw new RuntimeException("Failed to add language adaptor method: " + method.getName(), e);
                    }
                }
            }

            // will need to output to filesystem here
            //cc.toClass();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Failed to add language adaptor methods.", e);
        }
    }

    private static boolean isRxFunctionType(CtClass type) throws Exception {
        // look for the Function argument
        if (type.getName().equals(Function.class.getName())) {
            return true;
        }
        // look for arguments implementing Function
        for (CtClass implementedInterface : type.getInterfaces()) {
            if (implementedInterface.getName().equals(Function.class.getName())) {
                return true;
            }
        }
        return false;
    }

    private static void addMethod(CtClass ctClass, CtMethod method, Class<?>[] types) throws Exception {
        for (Class<?> cls : types) {
            ArrayList<CtClass> parameters = new ArrayList<CtClass>();
            CtClass[] argTypes = method.getParameterTypes();

            System.out.print(">>>>>> method: " + method.getName() + " args: ");
            for (CtClass argType : argTypes) {
                System.out.print(argType.getName() + " ");
                if (isRxFunctionType(argType)) {
                    // needs conversion
                    parameters.add(pool.get(cls.getName()));
                } else {
                    // no conversion, copy through
                    parameters.add(argType);
                }
            }
            System.out.println("");

            CtClass[] newArgs = parameters.toArray(new CtClass[parameters.size()]);
            String params = "";
            for (CtClass a : newArgs) {
                params += a.getName() + " ";
            }
            System.out.println("Add method => " + method.getName() + " => " + params + "  --> with arg type converted to: " + cls.getName());
            CtMethod newMethod = new CtMethod(method.getReturnType(), method.getName(), newArgs, ctClass);
            newMethod.setModifiers(method.getModifiers());
            newMethod.setBody("{ System.out.println(\"hello world!\");return null; }");
            ctClass.addMethod(newMethod);
        }
    }
}
```

Here are the methods that get overloads (for just Groovy in this output):

```
Add method => create => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => defer => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => filter => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => filter => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => forEach => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => groupBy => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => groupBy => groovy.lang.Closure groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => groupBy => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => groupBy => rx.Observable groovy.lang.Closure groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => last => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => last => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => lastOrDefault => java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => lastOrDefault => rx.Observable java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => map => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => map => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => mapMany => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => mapMany => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => onErrorResumeNext => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => onErrorResumeNext => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => onErrorReturn => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => onErrorReturn => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => reduce => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => reduce => java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => reduce => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => reduce => rx.Observable java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => scan => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => scan => java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => scan => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => scan => rx.Observable java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => sequenceEqual => rx.Observable rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => single => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => single => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => singleOrDefault => java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => singleOrDefault => rx.Observable java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => subscribe => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => subscribe => groovy.lang.Closure groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => subscribe => groovy.lang.Closure groovy.lang.Closure groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => takeWhile => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => takeWhile => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => takeWhileWithIndex => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => takeWhileWithIndex => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => toSortedList => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => toSortedList => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => where => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => where => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => zip => rx.Observable rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => zip => rx.Observable rx.Observable rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
Add method => zip => rx.Observable rx.Observable rx.Observable rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure
```

I haven't yet made the method body do the right thing (it's printing hello world right now), but it's basically taking what is already in the language adaptors and just inlining it.

The part I haven't figured out yet is hooking into the Gradle build process - but it's just busy work I need to spend time on.
 =||= Awesome. - I expected a lot more work to be necessary to generate those additional methods. But this looks quite manageable. 

You're right, the code generation approach looks better in this case than manually adding all those methods.
 =||= Another option a colleague suggested is to generate the source code before compilation instead of doing bytecode manipulation after. Generating source code isn't as "clean" as using Javassist like that code above, but the benefit would be that source code is then shipped that matches the bytecode so that stacktraces and clicking through to source goes to the right place when debugging.

That may be a strong enough value to do source code generation rather than bytecode generation.
 =||= I've got some work-in-progress up on my fork at: https://github.com/mattrjacobs/RxJava/commit/f5f84a8de6e96005a42ee4164c753d2cda3ed460.  The commit log describes what's been done and what's left to do before I'll feel comfortable submitting it.
 =||= Would it be possible to use the @Deprecated annotation for the Object versions? This would cause java/scala to atleast warn when we are accidentally using the Object overload but might not translate out to the dynamic languages.
 =||= We are getting close to eliminating these methods (week or two more at most
I hope). I was planning on providing an update on it tonight or tomorrow to
give people a heads up.

On Tue, Jul 2, 2013 at 9:55 PM, samhendley notifications@github.com wrote:

> Would it be possible to use the @Deprecatedhttps://github.com/Deprecatedannotation for the Object versions? This would cause java/scala to atleast
> warn when we are accidentally using the Object overload but might not
> translate out to the dynamic languages.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/204#issuecomment-20395690
> .

## 

Ben Christensen - API Team
+1-310-781-5511  @benjchristensen
 =||= After implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities. 

Our goals are:
- support static typing for Java/Scala/Kotlin etc by removing the Object overloads
- support any JVM language, static or dynamically typed
- allow all languages to use the same `rx.Observable` class so that we don't divide libraries with helpers such as `GroovyObservable`, `ClojureObservable` etc that then need to be converted back and forth when doing interop
- do not require special classloaders or agents to enable runtime bytecode generation
- do not remove static operators to enable proxying
- small jars and limited or no dependencies

The solution we have arrived at will work as follows:
- The rxjava-core source code will delete all Object overload methods and be pure static java.
  - Any language that supports functional interfaces directly (such as Java 8 and XTend) can use the Java core version directly.
- Languages needing specific lambda/clojure type mapping to the Func_/Action_ types will have language specific Jars created via build-time bytecode generation.
  - Any method with a Func_/Action_ argument will be overloaded with a version supporting the language requirements.

For example:

The default Java version:

``` java
public static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> predicate)
```

A Groovy version:

``` java
public static <T> Observable<T> filter(Observable<T> that, groovy.lang.Closure predicate)
```
- A jar per language will be created as follows:
  - rxjava-x-y-z.jar 
  - rxjava-groovy-x-y-z.jar 
  - rxjava-clojure-x-y-z.jar 
  - rxjava-scala-x-y-z.jar 
  - rxjava-jruby-x-y-z.jar 
  - rxjava-kotlin-x-y-z.jar 

A project will include just the jar that meets their language needs, there will no longer be a "core" jar plus the language adaptor.

The drawback of this is that mixing two of these in a classpath will result in non-deterministic loading (whichever is loaded last wins) and that is the version that will be used. This means if a library depends on rxjava.jar but is using Groovy and needs rxjava-groovy.jar it is up to the developer of that project to make sure they have only the rxjava-groovy.jar version. This is not ideal but is a one-time pain setting up a build and is better than the constant pain of missing static typing or converting to/from different Observable implementations for different languages.
- At this time we are optimizing for projects using a single language or Java + another language. If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options:
  - include an rxjava-dynamic.jar version that re-adds the Object overloads
  - include build configs for common combinations of languages such as rxjava-groovy-clojure.jar
- Language adaptations (such as clojure which has preferred idioms that necessitate wrapping) will still be possible through the language-adaptor projects and be included in the appropriate language jars.

This should not break any code but will require a slight change to the build dependencies in your project when we release this. 

We hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages.
 =||= Byte code generation ended up not being used. We instead went with the solution in https://github.com/Netflix/RxJava/pull/323
 =||= ,0
323,208,More formal support for Scala ,I'm still in the middle of fleshing this out, but roughly:

1) Removal of all Object methods from rx-core
2) Scala RxJava usage doesn't depend on runtime class lookup - instead it uses some implicits from Scala function types to Rx Func1, Func2, ..., FuncN to assert type safety while using native Scala closures
3) Unit tests to demonstrate full coverage of Observable methods using Scala

Given the first point above, this will have to be combined with #204, so that support for dynamic languages continues.,Small addition.
For-comprehension for observable should be supported as well.
It means that `Observable` should have `flatMap`, `map` and `withFilter` methods.
 =||= Good idea.  At first glance, I think this could be accomplished by the introduction of an implicit class (`ScalaObservable`?) wrapping `Observable` that implements `flatMap`, `map`, and `withFilter` by delegating to `mapMany`, `map`, and `filter`, respectively.  As long as all the methods still return an `Observable`, then we should be OK.
 =||= ,0
330,327,Clojure doesn't build for me,For 0.11.1, `./gradlew clean build` leads to

```
:language-adaptors:rxjava-clojure:clojureTest
Exception in thread "main" java.lang.ClassNotFoundException: rx.lang.clojure.interop.DummyObservable
```

The class is there, however the build doesn't seem to pick it up.,That is odd considering it made it through our build and release cycle. 

@daveray any ideas?
 =||= I was able to reproduce this, but not consistently. I also found non-deterministic unit test failures during build. See #329 for the full report & link to a gist with transcripts.
 =||= I wrestled with DummyObservable a bit, but thought I had beaten it. Clearly not. I'll take a look. Sorry about that. 
 =||= @jmhofer Does it work for you now that https://github.com/Netflix/RxJava/pull/330 is merged? 
 =||= Yes, works for me now, thanks!
 =||= Great. Thanks for confirming.
 =||= ,0
331,326,Make Observable covariant (and Observer contravariant) etc,Now that RxJava is typesafe, there's one thing I'm still dearly missing: a covariant `Observable` (or generally, making everything in the library properly co-, contra- and invariant, which especially means functions and observers, too).

Rx.NET has this, for example see http://msdn.microsoft.com/en-us/library/dd990377.aspx and notice the `out` in `public interface IObservable<out T>`.

Unfortunately, variance can not be as easily defined in Java as in C# (or Scala). Instead, this will lead to an aweful lot of `super`/`extends` generics in method signatures. - This means that the longer we wait with this, the more it will hurt to introduce it everywhere.

So I'd like to try my hand at this if you agree that it's worthwhile at all.,I agree it is worth pursuing and would appreciate you tackling it.  
 =||= Like!

On Aug 31, 2013, at 1:05 AM, Ben Christensen notifications@github.com wrote:

> I agree it is worth pursuing and would appreciate you tackling it.
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= Started with `Func0` and `Func1`, see https://github.com/jmhofer/RxJava/tree/super-extends. I don't think it's worthy of a pull request yet, will work towards that.
 =||= ,0
374,39,Operator: DistinctUntilChanged,http://msdn.microsoft.com/en-us/library/hh229494(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229776(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229508(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229533(v=vs.103).aspx,nan,0
375,38,Operator: Distinct,http://msdn.microsoft.com/en-us/library/hh229764(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211630(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244310(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229050(v=vs.103).aspx,nan,0
379,55,Operator: Interval,http://msdn.microsoft.com/en-us/library/hh229027(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228911(v=vs.103).aspx,It seems like `Interval` shares logic with the `Timer` from issue #92.

`Interval` could be implemented as a [`Timer` call](http://msdn.microsoft.com/en-us/library/hh229652%28v=vs.103%29.aspx) with `dueTime == 0`.
 =||= Sure, as soon as Timer is implemented or schedulers can do periodic scheduling, the implementation of `Interval` will get a lot simpler.
 =||= Is the `interval` operator intended to work if there are several subscribers? It looks as if this was simply forgotten...
 =||= Actually, I'm not sure whether `interval` itself should or shouldn't support this. - However, you should always be able to use `publish`/`connect`. If that doesn't work, then there's definitely something wrong. I can go check that later. I probably didn't think of that when implementing it...
 =||= I just tried it out in C#. This code:

```
static void Main() {
    var oneNumberPerSecond = Observable.Interval(TimeSpan.FromSeconds(1)).Take(5);
    oneNumberPerSecond.Subscribe(
    x => Console.WriteLine("subscriber 1 got " + x)
    );
    oneNumberPerSecond.Subscribe(
    x => Console.WriteLine("subscriber 2 got " + x)
    );
    Console.ReadLine();
}
```

produces this output:

```
subscriber 2 got 0
subscriber 1 got 0
subscriber 2 got 1
subscriber 1 got 1
subscriber 2 got 2
subscriber 1 got 2
subscriber 2 got 3
subscriber 1 got 3
subscriber 2 got 4
subscriber 1 got 4
```

So I think we should update the RxJava version to support multiple subscribers.
 =||= Compare to Java. Code:

```
public static void main(String[] args) {
    Observable<Long> oneNumberPerSecond = Observable.interval(1, TimeUnit.SECONDS).take(5);
    oneNumberPerSecond.subscribe(new Action1<Long>() {
        public void call(Long x) {
            System.out.println("subscriber 1 got " + x);
        }           
    });
    oneNumberPerSecond.subscribe(new Action1<Long>() {
        public void call(Long x) {
            System.out.println("subscriber 2 got " + x);
        }           
    });     
}
```

Output:

```
subscriber 1 got 0
subscriber 2 got 1
subscriber 1 got 2
subscriber 2 got 3
subscriber 1 got 4
subscriber 2 got 5
subscriber 1 got 6
subscriber 2 got 7
subscriber 1 got 8
subscriber 2 got 9
```

I think this will be used a lot for small examples and so it should be fixed soon. @benjchristensen could you please reopen this issue?
 =||= What does Rx.NET do when you wait a bit before subscribing the second time?

Will it do this?

```
subscriber 1 got 0
subscriber 1 got 1
subscriber 1 got 2
subscriber 2 got 2
subscriber 1 got 3
subscriber 2 got 3
subscriber 1 got 4
subscriber 2 got 4
```

Or will it still start at 0 with subscriber 2?
 =||= I added a first test for that use case here: https://github.com/jmhofer/RxJava/commit/2fe6da751957b41dd1b89083ec3aaed940042065

It fails, as expected from your comment above.
 =||= The Rx Design Guidelines (5.10) say:

> As many observable sequences are cold (see cold vs. hot on Channel 9), each subscription will have a separate set of side-effects. Certain situations require that these side-effects occur only once. The Publish operator provides a mechanism to share subscriptions by broadcasting a single subscription to multiple subscribers.

So I guess it would be okay for the second subscriber to always start at 0 too when subscribing to the same observable later (and not using `publish`/`connect`)?
 =||= There are probably other operators that are affected by this, too, because multiple subscribers are currently normally not getting tested by the unit tests...
 =||= Here's another  example from C#:

```
    static void Main() {
        var oneNumberPerSecond = Observable.Interval(TimeSpan.FromSeconds(1)).Take(5);
        var watch = new Stopwatch();
        watch.Start();

        Thread.Sleep(2200);

        Console.WriteLine("subscriber 1 subscribes at t=" + watch.ElapsedMilliseconds);
        oneNumberPerSecond.Subscribe(
            x => Console.WriteLine("subscriber 1 got " + x + " at t=" + watch.ElapsedMilliseconds)
        );

        Thread.Sleep(1300);

        Console.WriteLine("subscriber 2 subscribes at t=" + watch.ElapsedMilliseconds);
        oneNumberPerSecond.Subscribe(
            x => Console.WriteLine("subscriber 2 got " + x + " at t=" + watch.ElapsedMilliseconds)
        );

        Console.ReadLine();
    }
```

outputs:

```
subscriber 1 subscribes at t=2200
subscriber 1 got 0 at t=3322
subscriber 2 subscribes at t=3615
subscriber 1 got 1 at t=4319
subscriber 2 got 0 at t=4642
subscriber 1 got 2 at t=5329
subscriber 2 got 1 at t=5643
subscriber 1 got 3 at t=6331
subscriber 2 got 2 at t=6643
subscriber 1 got 4 at t=7344
subscriber 2 got 3 at t=7655
subscriber 2 got 4 at t=8656
```

So each subscriber starts at 0.
 =||= Great, thanks. This means that my PR above should fix this.
 =||= Yes, every new subscriber should start the Observable from the beginning. I have tried to make sure that's the case everywhere but apparently missed this one.

If an Observable does not want that behavior that is what the various `multicast` options are for such as `publish`, `replay`, `cache` etc.
 =||= Merged in https://github.com/Netflix/RxJava/pull/379 so closing again.
 =||= ,0
381,372,Zip/Map/Select with index,I'm looking for a function corresponding to this Rx C# function:

http://msdn.microsoft.com/en-us/library/hh244311(v=vs.103).aspx

Do we already have this in RxJava? I'm asking this because I want to implement the `zipWithIndex` function in the Scala adaptor.,No we do not have that yet. Your naming convention will be what we need to use so we don't overload methods with functions of different arities as that causes issues.

So `mapWithIndex` and `zipWithIndex` make sense.
 =||= I'd be happy with `mapWithIndex` and `zipWithIndex`.
 =||= I don't think we have the arity problem with `map` (`mapWithIndex`), or do we? I think it should be specific to `zip`. So we could name it `map` instead of `mapWithIndex` if we wanted to. But probably we should be consistent and still call it `mapWithIndex`.
 =||= I take that back. I just experimented with this and noticed that at least Clojure does indeed have a problem with that. So `mapWithIndex` it is.
 =||= ,0
385,24,Operator: Any,http://msdn.microsoft.com/en-us/library/hh229905(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211993(v=vs.103).aspx,I think this issue can be closed.
 =||= ,0
390,41,Operator: ElementAt and ElementAtOrDefault,http://msdn.microsoft.com/en-us/library/hh229725(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229845(v=vs.103).aspx,I think this issue can be closed.
 =||= ,0
401,34,Operator: DefaultIfEmpty,http://msdn.microsoft.com/en-us/library/hh229332(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229624(v=vs.103).aspx,nan,0
403,26,Operator: Cast,http://msdn.microsoft.com/en-us/library/hh211842(v=vs.103).aspx,nan,0
403,67,Operator: OfType,http://msdn.microsoft.com/en-us/library/hh229380(v=vs.103).aspx,nan,0
409,84,Operator: Synchronize (overload),Another overload to the existing synchronize:

http://msdn.microsoft.com/en-us/library/hh229790(v=vs.103).aspx,nan,0
410,31,Operator: Contains,http://msdn.microsoft.com/en-us/library/hh228965(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229815(v=vs.103).aspx,nan,0
410,395,java.util.Comparator is not suitable for distinct and distinctUntilChanged,In C#, `distinct` and `distinctUntilChanged` take an `IEqualityComparer` (which provides `Equals` and `GetHashCode`).
That's not the same as `java.util.Comparator` (which provides `compare`).

Or mathematically speaking: There are two kinds of comparators:
-    Those which define a _total ordering_: `java.util.Comparator` and C#'s `IComparer`
-    Those which define an _equivalence relation_: C#'s `IEqualityComparer`, RxJava's `Func2<T, T, Boolean>`, and unfortunately no standard Java interface

The problem is that for `distinct` and `distinctUntilChanged`, we're not interested in an order on the elements, but only in equality.

So it would be better to use `Func2<? super T, ? super T, Boolean> equality` (just like `sequenceEqual`) instead of `Comparator<U> equalityComparator`.,The 'Func2' sounds fine unless 'getHashCode()' is necessary to make 'distinct()' fast. In that case I think making our own 'EqualComparator<T>' would be the way to go. 
 =||= A `Comparator` returning 0 means the two items are equal thus it will work for this use case.

``` java
int compare(T o1, T o2)
```

http://docs.oracle.com/javase/6/docs/api/java/util/Comparator.html#compare(T,%20T)

> returns a negative integer, **zero**, or a positive integer as the first argument is less than, **equal to**, or greater than the second.

Moving to `EqualityComparator` would limit the return type to boolean as opposed to -1, 0, 1 as possible return types, but `Comparator` can represent equality as well, and both approaches let the developer define equality (using object reference, `equals`, `hashCode`, deep comparison, etc) instead of automatically using just the `equals` method.

Supporting Comparator (and Comparable object types) makes it so people can just reuse the same logic as used for ordering. 

Checking for equality is simpler than checking for ordering (binary instead of trinary response), but if the Comparator returns 0 it means the objects are equal. 

So if we're not going to use `Comparator` it should be because we want a simpler return type, not because it doesn't work. That said, I can't remember ever seeing something other than `Comparator` used for this type of behavior in a Java library because if not using `Comparator` then the library can just call `equals` on each Object. Why would something else be needed?

For example, the `Set` implementations in Java ensure uniqueness and they use the `Object.equals` method on objects to determine equality. Why would we need to do anything different than the Java collections libraries that use either `equals` or `Comparator`?
 =||= A `Comparator` (per javadoc) is a 

> comparison function, which imposes a total ordering on some collection of objects.

We don't actually need the total ordering for our purposes in `distinct` or `distinctUntil`, only the fact that it incidentally defines equality as well. - But still, if someone defines a `Comparator` for equality, not making it define a total ordering, he or she is basically misusing it.

As an aside, `Comparator`s that are inconsistent with `equals` are dangerous beasts. It's way too easy to use them for collections like `TreeSet` which simply won't work in that case.

Also, at least for `distinct`, there is indeed an efficiency problem when (mis)using `Comparator` as we do now: There is no way to create an efficient set without either a total ordering or some kind of hash code. All the `Set` implementations in Java always depend on at least one of these two concepts afaik.

Imho, for doing this right, we actually need a real Java equivalent to `IEqualityComparer`, which defines both the concepts of equality and a hash code. - Or we could leave that whole thing out of the API and make people write their own wrapper classes for that use case, which is not very convenient, of course.
 =||= The `compare` method on a `Comparator` can use `hashcode` and `equals` just the same as a new interface would allow, but I accept that having a trinary response is confusing when only a binary boolean is needed.

My vote is for `Func2<? super T, ? super T, Boolean>`, not creating a new special type for this very limited use case.
 =||= The `compare` implementation can of course use whatever it likes internally. However, our code can't ever get a `hashCode` from a `Comparator`. It could get one from a new interface and use it to make `distinct` efficient, for example.

I agree, though, that it's probably a very limited use case. So I'm ok with `Func2`, too.
 =||= Or maybe `distinctUntilChanged` taking a `Func2<? super T, ? super T, Boolean>`, and no custom comparison for `distinct`, to keep it simple.
 =||= > use it to make distinct efficient, for example.

This is a valid concern, iterating the entire list is not good (though with a Comparator we could maintain a sorted list and do a binary search!).

Another consideration for API design, an interface with 2 methods like `IEqualityComparer` can not be implemented by lambdas as it is not a functional interface with a single method (lambda body).

Is this use case and performance issue strong enough to have a non-functional interface that requires an anonymous inner class to implement two methods? Also, implementing hashCode is far more obnoxious than implementing equals.

For performance reasons and avoiding hashCode implementations, would `Comparator` having ordering in mind actually be the right choice so we can test for equality using a binary search algorithm?

How about this change to use `TreeSet` and `Comparator` and not require iterating the full list?

``` java
            final Subscription sourceSub = source.subscribe(new Observer<T>() {

                // use TreeSet instead of ArrayList
                private final TreeSet<U> emittedKeys = new TreeSet<U>(equalityComparator);

                @Override
                public void onCompleted() {
                    observer.onCompleted();
                }

                @Override
                public void onError(Throwable e) {
                    observer.onError(e);
                }

                @Override
                public void onNext(T next) {
                    U nextKey = keySelector.call(next);
                    if(emittedKeys.add(nextKey)) {
                        observer.onNext(next);
                    }
                }
            });
```

Unit Test:

``` java
        @Test
        public void testDistinctOfObjectWithComparator() {
            Observer<? super RandomObject> observer = mock(Observer.class);
            RandomObject r1 = new RandomObject(1, "one");
            RandomObject r2 = new RandomObject(2, "two");
            RandomObject r2b = new RandomObject(2, "twoB");
            Observable<RandomObject> src = from(r1, r1, r2, r1, r2, r2b);
            create(distinct(src, new Comparator<RandomObject>() {

                @Override
                public int compare(RandomObject o1, RandomObject o2) {
                    int i = o1.i - o2.i;
                    if(i != 0) {
                        return i;
                    }

                    return o1.v.compareTo(o2.v);
                }
            })).subscribe(observer);

            InOrder inOrder = inOrder(observer); 
            inOrder.verify(observer, times(1)).onNext(r1);
            inOrder.verify(observer, times(1)).onNext(r2);
            inOrder.verify(observer, times(1)).onNext(r2b);
            inOrder.verify(observer, times(1)).onCompleted();
            verify(observer, never()).onError(any(Throwable.class));
            inOrder.verifyNoMoreInteractions();
        }
```
 =||= For `TreeSet` to work as expected, the `Comparator` has to be consistent with `equals`, and in that case, we don't even need it in the first place. 

It's not correct in Java to implement `equals` without implementing `hashCode`, too.
 =||= This method 'java.util.Objects.hash(Object...)' makes computing hash codes much easier.
 =||= @jmhofer Yes, if it's not consistent with equals it won't work, but if they have equals they don't need to use `Comparator` and why would they make them be different?

@abersnaze Yes it does, but I'd like to avoid an API that requires developers to do that and know about some obscure API if we don't need it.

Question about using `IEqualityComparer`, would it need to calculate the `hashCode` every time the object is touched since it can't cache it (as it doesn't know if mutation has occurred in an object)? 
 =||= If the observable objects already have an `equals`/`hashCode` implementation, then the `distinct` call without any additional parameters will do. Afaik the additional `distinct` signature using an explicit `IEqualityComparer` in Rx.NET is for cases where you want to use a different `equals` from the default one for distinguishing between the observable objects.

Java doesn't really support the concept of multiple equivalence relations per class. It would need something like the `IEqualityComparer` in its standard library for that, at least (and probably support that interface in the collections library, too). This was the reason why I initially left away the implementation for that specific `distinct` signature. I still don't think it's much of a use case...

My current implementation is a bit inconsistent: It takes a `Comparator` but doesn't care for or use the total ordering that should be defined by that `Comparator`. It just uses the equivalence relation defined by it, and has to live without being able to compute hash codes.

The more I think about it, the more I agree with @samuelgruetter that the `Comparator` is a bad choice for this. `distinct` has no need to impose a total ordering. It just needs an equivalence relation. Given a total ordering, we could make `distinct` efficient, of course, without using hash codes (just not via the Java default set implementations). But I don't see much value in that. It's also something completely different from what Rx.NET does here.

So basically, I'm for using a simple `Func2` for `distinctUntilChanged` and maybe leaving that away from `distinct` due to efficiency.

If we created an interface like `IEqualityComparer`, we'd have to impose the same restrictions and contracts on its `equals` and `hashCode` methods as `Object` does. Mutable fields used in hash code computations break the standard Java collection implementations based on hash codes. Therefore I see no strong need to make `distinct` work with that special case either.
 =||= We ended up removing `Comparator` for these operators ... so closing.
 =||= ,0
411,383,Flaky unit tests,It looks like there are some flaky unit tests:

On my machine, this test failed today (but only once):

```
rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext
```

On cloudbees, these tests seem to be flaky:

```
Build #278: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions
Build #276: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions
Build #237: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions
Build #185: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions
Build #251: rx.concurrency.TestSchedulers.testSchedulingWithDueTime
Build #277: rx.operators.OperationConcat$UnitTest.testConcatConcurrentWithInfinity
```

Edit: also

```
Build #290: rx.operators.OperationConcat$UnitTest.testConcatConcurrentWithInfinity 
```,Output of failed `rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext`:

```
java.lang.AssertionError: should not have received exception
    at org.junit.Assert.fail(Assert.java:93)
    at rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext(OperationNext.java:252)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)
    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)
    at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)
    at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)
    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:724)
```
 =||= > Build 278: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions
> Build 276: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions
> Build 237: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions
> Build 185: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions

The CurrentThreadScheduler tests that are testing delay functionality are very non-deterministic. The assertions either need to change to allow for that, or we need to change to using artificial time (though these particular tests are purposefully testing the real implementation, so using artificial time would someone defeat the purpose).

> Build 251: rx.concurrency.TestSchedulers.testSchedulingWithDueTime

This is similar, it's asserting something scheduled on a background thread. I haven't dug into what needs to change.

> Build 277: rx.operators.OperationConcat$UnitTest.testConcatConcurrentWithInfinity

Not sure at a quick glance what the issue here is.

---

I don't have time this morning to fix these but will do so at some point (their intermittent failures annoy me too).
 =||= Another here: https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/293/
 =||= another local failure:

```
rx.operators.OperationNext$UnitTest > testOnErrorViaHasNext FAILED
    java.lang.AssertionError at OperationNext.java:252
```
 =||= and yet another (in `rx.operators.SynchronizedObserver$UnitTest`):

```
java.lang.AssertionError: expected:<1> but was:<0>
    at org.junit.Assert.fail(Assert.java:93)
    at org.junit.Assert.failNotEquals(Assert.java:647)
    at org.junit.Assert.assertEquals(Assert.java:128)
    at org.junit.Assert.assertEquals(Assert.java:472)
    at org.junit.Assert.assertEquals(Assert.java:456)
    at rx.operators.SynchronizedObserver$UnitTest.testMultiThreadedWithNPEinMiddle(SynchronizedObserver.java:250)
...
```
 =||= `rx.concurrency.CurrentThreadScheduler$UnitTest` failed several times in my machine today:

<pre>
org.mockito.exceptions.verification.VerificationInOrderFailure: 
Verification in order failure
Wanted but not invoked:
action0.call();
-> at rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions(CurrentThreadScheduler.java:191)
Wanted anywhere AFTER following interaction:
action0.call();
-> at rx.Scheduler$4.call(Scheduler.java:184)
    at rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions(CurrentThreadScheduler.java:191)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)
    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)
    at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
    at $Proxy2.processTestClass(Unknown Source)
    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)
    at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)
    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
    at java.lang.Thread.run(Thread.java:662)
</pre>
 =||= again `rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext`
 =||= wrt

rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext

I don't think the test is necessarily flaky. rather that the Iterable returned by next() is inconsistent. if you trigger an exception during Iterable.next() then the Iterable.hasNext() will revert to returning 'true'. This can fail the test if the 

assertFalse(it.hasNext());

runs after the it.next() on the async thread. 

so you can't really fix the test, you can either make the test thread delay a little longer and definitely fail, or remove the assert and accept that the behavior of hasNext() is unreliable after next() completes (either with a value or exception) since its unusual that you'd be checking the Iterable from a different thread.

also might be worth noting that the wiki suggests the Iterable should return a single 'null' value if the Observable completes without any value (https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#next) but I can't see any test or implementation for this case - am I misunderstanding this?
 =||= Then the hasNext should block until either the onNext or onComplete has been called.
 =||= not sure in which case you mean? the hasNext() in the failing test is called after the onNext/onComplete has occurred (the async thread has called next() and it has thrown an exception)

or do you mean in the case where the Observable completes without an onNext?
 =||= The following error happened in my machine today:

<pre>
java.lang.AssertionError: expected:<39.0> but was:<100.0>
    at org.junit.Assert.fail(Assert.java:93)
    at org.junit.Assert.failNotEquals(Assert.java:647)
    at org.junit.Assert.assertEquals(Assert.java:443)
    at org.junit.Assert.assertEquals(Assert.java:512)
    at rx.operators.OperationGroupBy$UnitTest.testUnsubscribe(OperationGroupBy.java:546)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)
    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)
    at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)
    at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)
    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)
    at java.lang.Thread.run(Thread.java:695)
</pre>

I reviewed `rx.operators.OperationGroupBy.UnitTest.testUnsubscribe()` and found the following assumption was wrong:

``` java
// sentEvents will go until 'eventCounter' hits 20 and then unsubscribes
            // which means it will also send (but ignore) the 19/20 events for the other group
            // It will not however send all 100 events.
            assertEquals(39, sentEventCounter.get(), 10);
            // gave it a delta of 10 to account for the threading/unsubscription race condition which can vary depending on a machines performance, thread-scheduler, etc
```

Actually, since we can not control when to run a thread, `sentEventCounter` can be 100 in some scenario.
 =||= I fixed one flaky test by moving the decrement of the latch in to the observer.

``` java
                 .map(new Func1<String, String>() {
                     public String call(String arg0) {
+                        throw new IllegalArgumentException("any error");
-                        try {
-                            throw new IllegalArgumentException("any error");
-                        } finally {
-                            latch.countDown();
-                        }
                     }
                 });

+        // wait for the call to get to the observer before decrementing the latch
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                latch.countDown();
+                return null;
+            }
+        }).when(stringObserver).onError(any(Throwable.class));
         m.subscribe(stringObserver);
         latch.await();
```
 =||= @abersnaze Thanks. I added your patch to PR #461. Is it OK? Could you take a look?
 =||= Just had another instance of this:

```
java.lang.NullPointerException
    at rx.operators.OperationConcatTest.testConcatConcurrentWithInfinity(OperationConcatTest.java:324)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    ...
```
 =||= Another test which also seems to be flaky:

```
rx.schedulers.NewThreadSchedulerTest.testMixOfDelayedAndNonDelayedActions

org.mockito.exceptions.verification.VerificationInOrderFailure: 
Verification in order failure
Wanted but not invoked:
action0.call();
-> at rx.schedulers.AbstractSchedulerTests.testMixOfDelayedAndNonDelayedActions(AbstractSchedulerTests.java:317)
Wanted anywhere AFTER following interaction:
action0.call();
-> at rx.Scheduler$4.call(Scheduler.java:194)

    at rx.schedulers.AbstractSchedulerTests.testMixOfDelayedAndNonDelayedActions(AbstractSchedulerTests.java:317)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    ...
```

This was with version 0.16.0.
 =||= For the `rx.schedulers.NewThreadSchedulerTest.testMixOfDelayedAndNonDelayedActions`, as `AbstractSchedulerTests.testMixOfDelayedAndNonDelayedActions` uses the real time to schedule the actions, it's non-deterministic. When the CPUs are busy, the test may fail. Can we enlarge the time?

``` java
                scheduler.schedule(first);
                scheduler.schedule(second, 300, TimeUnit.MILLISECONDS);
                scheduler.schedule(third, 100, TimeUnit.MILLISECONDS);
                scheduler.schedule(fourth);
                scheduler.schedule(new Action0() {

                    @Override
                    public void call() {
                        latch.countDown();
                    }
                }, 400, TimeUnit.MILLISECONDS);
```
 =||= Closing as this has become an epic dumping ground ... most issues have been solved. The only one I'm still aware of is a new one, the `pivot` operator.
 =||= ,0
413,85,Operator: TakeLast,http://msdn.microsoft.com/en-us/library/hh212114(v=vs.103).aspx,nan,0
414,78,Operator: SkipLast,http://msdn.microsoft.com/en-us/library/hh211750(v=vs.103).aspx,nan,0
414,85,Operator: TakeLast,http://msdn.microsoft.com/en-us/library/hh212114(v=vs.103).aspx,nan,0
415,42,Operator: Empty with scheduler,http://msdn.microsoft.com/en-us/library/hh229066(v=vs.103).aspx,nan,0
416,89,Operator: Throw,http://msdn.microsoft.com/en-us/library/hh244299(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211711(v=vs.103).aspx,nan,0
422,320,JRuby examples don't work (JRuby picks the wrong overloaded method),The JRuby adapter doesn't work because JRuby can't figure out which overloaded `Observable#subscribe` method to pick. It ends up picking `Observable#subscribe(Map<String, Object>)`, which raises an error because the argument doesn't respond right:

``` ruby
require 'rxjava-core-0.10.0.jar'
require 'rxjava-jruby-0.10.0.jar'

observable = Java::Rx::Observable.toObservable(['one', 'two', 'three'])
observable.take(2).subscribe(lambda { |x| puts x })
```

the code above prints the following errors in JRuby 1.7.4:

```
% ruby rxjava.rb
rxjava.rb:6 warning: ambiguous Java methods found, using subscribe(java.util.Map)
onNext
Observable.java:278:in `subscribe': java.lang.RuntimeException: 'onNext' key must contain an implementation
    from NativeMethodAccessorImpl.java:-2:in `invoke0'
    from NativeMethodAccessorImpl.java:57:in `invoke'
    from DelegatingMethodAccessorImpl.java:43:in `invoke'
    from Method.java:601:in `invoke'
    from JavaMethod.java:455:in `invokeDirectWithExceptionHandling'
    from JavaMethod.java:316:in `invokeDirect'
    from InstanceMethodInvoker.java:61:in `call'
    from MethodHandle.java:599:in `invokeWithArguments'
    from InvocationLinker.java:153:in `invocationFallback'
    from rxjava.rb:5:in `__file__'
    from rxjava.rb:-1:in `load'
    from Ruby.java:807:in `runScript'
    from Ruby.java:800:in `runScript'
    from Ruby.java:669:in `runNormally'
    from Ruby.java:518:in `runFromMain'
    from Main.java:390:in `doRunFromMain'
    from Main.java:279:in `internalRun'
    from Main.java:221:in `run'
    from Main.java:201:in `main'
```

in JRuby 1.6.8 it prints a less verbose version of the same error.

Notice the line which reads "onNext". That's actually the `puts` from `lambda { |x| puts x }` in action. JRuby wraps the lambda in something that looks like a `Map`, and then when RxJava calls `get` on that map JRuby calls `call` on the lambda.

So if you modify the example code to read `lambda { |x| lambda { |y| puts y } }` this is what happens:

```
% ruby rxjava.rb
rxjava.rb:6 warning: ambiguous Java methods found, using subscribe(java.util.Map)
RxJava => Could not find function language adaptor: Groovy with path: rx.lang.groovy.GroovyAdaptor
RxJava => Successfully loaded function language adaptor: JRuby with path: rx.lang.jruby.JRubyAdaptor
RxJava => Could not find function language adaptor: Clojure with path: rx.lang.clojure.ClojureAdaptor
RxJava => Could not find function language adaptor: Scala with path: rx.lang.scala.ScalaAdaptor
one
two
```

Which kind of works, but it's not as smooth as the ideal API would be:

``` ruby
observable.subscribe { |x| puts x }
```

But that would probably require a real JRuby native extension (if I get the time I'll send you a pull request with one).,Glad to have you involved, we haven't had much use of JRuby (that I'm aware of) so I'm not surprised we have some issues. I would appreciate your involvement.

Can you check out code from this pull request (https://github.com/Netflix/RxJava/pull/319), build the rxjava-jruby jar and try it? We are working on a very different approach in this pull request for language adaptors that is statically typed.

As for the `subscribe(Map)` overload ... I'm not thrilled by that one and it has caused other issues. I've considered getting rid of it before we hit 1.0, but I know it's used in a variety of places so haven't pulled that trigger.
 =||= It works better, but not perfect. JRuby seems to pick a working overload, but it still warns about there being multiple overloads (which is hard to fix without adding JRuby-metadata to the `Observable` class).

An upside is that you can skip the `lambda { ... }` and use the more Ruby-ish: `obs.subscribe { |x| puts x }` (i.e. pass a block to `#subscribe`).

Since there will be a version generated to work specially for JRuby, how much can the code generation things add? Ideally it would add JRuby metadata to the class to make it work as a JRuby native extension. Can you give me any hints on how to dig into that? Where should I start to look in the code to understand the code generation?
 =||= If the generated `Observable` could be something like this (but lots more, obviously), it could integrate with JRuby even better:

``` ruby
@JRubyClass(name="Rx::Observable")
public class Observable<T> extends RubyObject {
    @JRubyMethod(meta = true, rest = true)
    public static <T> Observable<T> from(ThreadContext ctx, IRubyObject receiver, IRubyObject[] args) {
        // ...
    }

    @JRubyMethod(name = "subscribe")
    public IRubyObject subscribeRuby(ThreadContext ctx, Block block) {
        // ...
    }
```

There would be some more code needed that registered the class with the runtime, and created the `Rx` module, and some more things, but that wouldn't need to be generated.
 =||= Can you take a look at pull request https://github.com/Netflix/RxJava/pull/323 and suggest how to re-add JRuby support correctly? We have decided against doing byte-code generation.

We can not add anything (such as the annotations in your example) to rxjava-core, it needs to be in a separate submodule, similar to Groovy, Scala and Clojure. So this means using something like extension methods, implicits, or other such tools if JRuby supports them. 
 =||= I will have a look.
 =||= With some small patches at least some of the basics work:

``` ruby
require 'rxjava-core/build/libs/rxjava-0.10.1-SNAPSHOT.jar'

class Java::Rx::Observable
  java_alias :subscribe, :subscribe, [Java::RxUtilFunctions::Action1.java_class]
end

module Rx
  include_package 'rx'
end

o = Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

I haven't tested any more than that, but it looks like it could work.
 =||= #323 should be `0.11.0-SNAPSHOT` afaik, not `0.10.1-SNAPSHOT`. Are you sure you're using the correct version of RxJava?
 =||= Good catch, I'm not used to gradle, or even having to compile stuff, so I didn't clean up from the last build I did so the old jars were still around. 

The Ruby patch works with 0.11.0 too (which means that those small patches would have make the old version work too, so that's good to know). Without the patch it works as with #319, the code runs but it prints a warning about not finding the right overloaded method.

The boring part of doing it this way is that each method on Observable, and any other classes needed for interoperability will need to be annotated with `java_alias`. On the other hand I don't see any other way of doing it which wouldn't involve writing even more code.
 =||= Does JRuby have a way to apply these aliases programmatically? For example, in Groovy we use reflection to determine all methods that need extensions and then programmatically create all of the `MetaMethod` implementations to bridge Groovy and Java. You can see an example here: https://github.com/mattrjacobs/RxJava/blob/8c87c29bea5e076bdc4202af5626d474ab1c7117/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/RxGroovyExtensionModule.java#L103

Otherwise every time a new method is added to core someone will have to maintain the JRuby java_alias mappings.
 =||= Maybe, I'm not sure, I'll have to look into more about how JRuby's native extensions work. So far I've only done it by creating classes and adding metadata, but I guess that it should be possible to do it on existing classes to somehow.

If I understand the code you linked to correctly it's looking through the `Observable` and `BlockingObservable` classes for methods that take subclasses of `Function` and somehow makes the Groovy runtime prefer those over any other overloads. That's what would be needed for JRuby too, and since the Groovy version just uses Java reflection to do it I think it should be possible in JRuby too. 

All that the `java_alias` thing does is that it looks up a Java method by reflection and adds that method into a cache that JRuby will look in before it looks at the Java class, which is kind of similar to what the Groovy extension thing does, I think.

So, yes, probably, maybe, hopefully, but I'm not sure exactly how right now.
 =||= This isn't complete yet, but here's a first pass at an implementation I think will work. @benjchristensen can you take a look and let me know if this is the direction you're looking for? It's largely cribbed from the Groovy implementation.

https://github.com/ragalie/RxJava/commit/fc0a706faaa27d1d797cfb8c43080a3b68e1cb1f
 =||= I'm getting warnings about overloads.

This is my code:

``` ruby
require 'rxjava-core/build/libs/rxjava-core-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/build/libs/language-adaptors-0.14.2-SNAPSHOT-sources.jar'

module Rx
  include_package 'rx'
end

o = Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

and this is the output (JRuby 1.7.4):

```
rxjava.rb:14 warning: ambiguous Java methods found, using subscribe(rx.util.functions.Action1)
2
4
6
```
 =||= Just to be clear, the commit I posted doesn't work yet. I just want to make sure that the approach is sane before investing more time in it. 
 =||= Ok. Yeah, it might work.

Not sure how well the generated methods will work, though: they are added on the classes, but call `super` to call the original method, but I'm not sure that `super` is actually what you think it is (it might be, I assume you've run the code, and I have not, so I could be completely wrong). In other words, you're adding a method on `Observable`, and then you call `super` in that method to call the original method on `Observable`, but that should call a method on the superclass of `Observable`, not the original method -- unless JRuby tries to be clever and figures out that your added method is on the eigenclass and `super` should refer to `Observable`, but I don't think it does.

And either way, once you call `super` JRuby still has to look up the right Java method to call, and it doesn't have any more type information to do it, so it will pick one at random and print out the "ambiguous Java methods found" warning. Even if you've wrapped the proc in an `Action` I'm not sure that JRuby will pick the right overloaded method. In my experience it tries, but it doesn't always succeed in picking the right method.

I think a better way to solve the problem is to use `java_alias` as in one of my examples above. That way JRuby will always pick the right overload. I'm not sure all the wrapper classes would be needed in that case, because JRuby will wrap a proc in a proxy class that implements whatever interface is required (and since `Function` and `Action` interfaces only really have one method, that also just happens to map straight to interface of proc, I think letting JRuby do it makes sense). There might be a slight performance loss from letting JRuby generate proxies instead of having Java classes, but I think it's greatly outweighted by skipping a large part of the work that JRuby otherwise would have done in finding the right overload.
 =||= You're right, the `super` approach won't work.

I tried the `java_alias` approach first and the problem I ran into is that it didn't seem to work correctly when a method had multiple signatures with the same number of arguments. For instance, I tested it with RxJava 0.10 which has `subscribe(Hash)` and `subscribe(Action1)` (or something like that). I tried just running `java_alias` on the methods that had `Function` arguments and it threw an error when I tried to use the `Hash` argument. I tried running `java_alias` on all methods, but running it first on the non-function methods and second on the function methods and that didn't work either (threw an error with a `Hash` argument).

I'm a relative newbie at JRuby, so totally possible I'm doing something wrong. But from my basic understanding I don't understand how `java_alias` will be a solution if there are two signatures with the same number of arguments and we want to allow access to both of them.
 =||= I spent some more time researching this evening and I think the easiest path forward is to leverage the JRuby method dispatching as much as possible. Outside of the `Proc` => `Action`/`OnSubscribeFunc`/`Function` casts, which we can reliably do but which the JRuby dispatch logic is having trouble reliably doing, the default dispatch logic is likely to be far better at sussing out the method signature we want to invoke than we would be.

The first thing the dispatch logic checks for when trying to find a method signature match is whether the Java class of the argument provided is an exact match with the parameter type specified in the method signature (see: https://github.com/jruby/jruby/blob/master/core/src/main/java/org/jruby/java/dispatch/CallableSelector.java#L321). While it isn't guaranteed that this will always be true (JRuby could change the dispatch logic), I think it's a safe bet that it will continue to preference exact class matches when selecting overloads. I think that means that as long as we pass in arguments that implement the exact interfaces JRuby should have a much easier time finding the matching method signature.

Assuming that's true, I think we should implement an algorithm like the following on load:
- Select the methods that have any signatures that contain a parameter type that is a (sub)interface of `rx.util.functions.Function`
- Determine the (sub)interfaces of `Function` that are possibilities for each argument position for a given method.
- If any given argument position has more than one possibility (e.g. `Action1` or `Action0`), ignore.
- If any given argument position has only one possibility, then note that we should convert any `Proc` we see in that argument position into the `Function` subclass we've identified.

Then I think we should implement the following to occur at runtime:
- Upon invoking a method where we've noted that we should convert `Proc`s, replace the `Proc` arguments with wrappers that implements the noted interfaces, if applicable.
- Call the original Ruby method with the modified arguments.

We should be able to do this using `alias_method` to copy the original `subscribe`, for instance, to `subscribe_without_argument_wrapping` and then redefine `subscribe` to modify the arguments and call `subscribe_without_argument_wrapping` with the updated arguments.

Under this scenario most of the hard dispatch logic remains in Java: the only additional runtime things we're doing in Ruby are a) a check to see if the argument is a `Proc`, b) a Hash lookup to see whether we can replace the `Proc` with a wrapper and c) instantiating the Java wrapper. So I don't think it should significantly slow things down.

It's clear you've thought about this quite a bit @iconara; anything stick out to you as suspect here?
 =||= It isn't the cleanest thing in the world, but https://github.com/ragalie/RxJava/commit/957af11bb7e843e79e72a7559a7c0c8a24052e35 seems to be working correctly.

This code no longer causes an ambiguous method warning:

``` ruby
require 'rxjava-core/build/libs/rxjava-core-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/rxjava-jruby/build/libs/rxjava-jruby-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/rxjava-jruby/src/main/ruby/rx/lang/jruby/interop'

o = Java::Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

I'm going to clean it up as best as I can then open a PR. I'm pretty new to JRuby, though, and I'm sure there are some ways to simplify what I've done, so hopefully someone can help me out with that. In particular I'd love to be able to leverage the built-in JRuby proxying (telling it which interface to proxy) instead of the clunky ones in the commit.

I also don't know what to do with the Ruby code. Should that stay in the JAR and just need to be required manually? Or should it be pulled out to a gem? I'm not sure what's idiomatic.

Thanks!
 =||= @ragalie I'm sure it can be done more elegantly, but it would take a lot of time, and I don't know very much more about the details of JRuby's Java integration to say for sure how to do it. It's better to get something that works and improve it later than trying to find the optimal solution now.

There's a way to package a JAR that makes JRuby run code when it is require'd from Ruby code. You need to stick a special class at the root of the JAR (here's an example: https://github.com/iconara/msgpack-jruby/blob/master/ext/java/MsgpackJrubyService.java). It's used to load JRuby native extensions (i.e. Java code that creates JRuby modules and classes), but in this case it could be used to automatically run the interop code (which can be loaded from within the JAR).

Another option would be to make the the interop code the main entrypoint for Ruby, and for it to load `rxjava-core.jar` and `rxjava-jruby.jar`. Come to think of it, that would be the better solution.

The benefit of the former solution would be that you could ship it all as just the JAR, but the latter is simpler to maintain and is how many JRuby wrappers for Java libraries work.

If it's ever going to get any kind of adoption in the Ruby world the library must be packaged as a gem.
 =||= I implemented JRuby support in #422. Let me know what you all think and if there's anything that doesn't seem to be working correctly. Thanks!
 =||= Awesome @ragalie! I'm taking a look now and will merge it into master or iterate with you on it if there are changes needed.
 =||= ,0
424,54,Operator: IgnoreElements,http://msdn.microsoft.com/en-us/library/hh229242(v=vs.103).aspx,nan,0
430,428,buffer() using TimeAndSizeBasedChunks incorrectly forces thread into interrupted state,In TimeAndSizeBasedChunks.emitChunk, if emitChunk is called from the scheduled action in createChunk (i.e from the timeout thread), calling subscription.unsubscribe() ends up calling cancel() on the future which sets the thread's interrupted state to true.  This state has an adverse effect on any blocking call performed in that thread.  ,Can you provide a unit test to demonstrate the issue? Here are existing unit tests for buffer: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperationBuffer.java#L372

Also, what Future are you referring to? Are you using custom schedulers?
 =||= I'm unable to run the unit tests in eclipse for some reason.  Here's a unit test from my project.   While we're on the subject of buffer() it would be nice if the observer was not called with an empty list.  

```
    @Test
    public void testInterrupted() throws Exception {
        Observable.create(new OnSubscribeFunc<Integer>() {
            @Override
            public Subscription onSubscribe(final Observer<? super Integer> t1) {
                final Future<?> t = Executors.newSingleThreadExecutor().submit(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            Thread.sleep(10000);
                        } catch (InterruptedException e) {
                        }
                    }
                });

                return new Subscription() {
                    @Override
                    public void unsubscribe() {
                        t.cancel(true);
                    }
                };
            }
        })
        .buffer(1000, TimeUnit.MILLISECONDS, 10) 
        .subscribe(new Action1<List<Integer>>() {
            @Override
            public void call(List<Integer> t1) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // This should be called
                    e.printStackTrace();
                }
            }
        });

        Thread.sleep(10000);

    }
```
 =||= Regarding the Future, no, i'm not using a custom scheduler.   Subscriptions.create(final Future<?> f) calls cancel on the future when it is unsubscribed. 
 =||= Yes, that's what a Subscription of a Future is supposed to do. 
 =||= Thanks for submitting the unit test, I'll try it out.

> While we're on the subject of buffer() it would be nice if the observer was not called with an empty list.

You're using time, so it will emit every 1000ms whatever is buffered, even if it's empty.
 =||= ,0
441,417,Exception not properly propagated,Given

``` java
static Func1<Integer, Integer> f = new Func1<Integer, Integer>() {
    public Integer call(Integer arg0) {
        throw new RuntimeException("the error in f");
    }
};
```

when I run this:

``` java
public static void main(String[] args) {
    System.out.println("started");
    System.out.println(Observable.from(1)
        .map(f).toBlockingObservable().single());
    System.out.println("done");
}
```

I get (as expected) this output:

```
started
Exception in thread "main" java.lang.RuntimeException: the error in f
    at RxJavaHelloWorld$2.call(RxJavaHelloWorld.java:226)
    at [blah blah...]
    at RxJavaHelloWorld.main(RxJavaHelloWorld.java:240)
```

However, when I observe it on a different thread:

``` java
public static void main(String[] args) {
    System.out.println("started");
    System.out.println(Observable.from(1).observeOn(Schedulers.threadPoolForComputation())
        .map(f).toBlockingObservable().single());
    System.out.println("done");
}
```

then the output is this:

```
started
```

and the application does not terminate.
But I would expect that no matter on what thread I observe, errors are always propagated.,Here the error occurs even without `observeOn`:

``` java
System.out.println(Observable.from(1, 2, 3).take(1).map(f).toBlockingObservable().single());
```

This snippet also makes the app never terminate.

This prevents me from implementing the [head](https://github.com/samuelgruetter/RxJava/blob/2654f60e05a24fc910f73284e32290403d5bffcf/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala#L1565) operation in the Scala adaptor, and the original one with `observeOn` prevents me from implementing a [nice constructor](https://github.com/samuelgruetter/RxJava/blob/2654f60e05a24fc910f73284e32290403d5bffcf/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/package.scala#L141).
 =||= > Here the error occurs even without observeOn:
> 
> System.out.println(Observable.from(1, 2, 3).take(1).map(f).toBlockingObservable().single());
> This snippet also makes the app never terminate.

For `take(1)`, after the observer receives a value, any later value or error will be ignored, even if `onNext(the first value)` throws an exception. The related codes:

``` java
            @Override
            public void onError(Throwable e) {
                if (counter.getAndSet(num) < num) {
                    observer.onError(e);
                }
            }

            @Override
            public void onNext(T args) {
                final int count = counter.incrementAndGet();
                if (count <= num) {
                    observer.onNext(args);
                    if (count == num) {
                        observer.onCompleted();
                    }
                }
                if (count >= num) {
                    // this will work if the sequence is asynchronous, it will have no effect on a synchronous observable
                    subscription.unsubscribe();
                }
            }
```

For `take(1)`, it will increment `count` at first. Even if `observer.onNext(args);` throws an exception, as `count == num`, the exception is not propagated.
 =||= > public static void main(String[] args) {
>     System.out.println("started");
>     System.out.println(Observable.from(1).observeOn(Schedulers.threadPoolForComputation())
>         .map(f).toBlockingObservable().single());
>     System.out.println("done");
> }

This issue is because `rx.operators.ScheduledObserver.EventLoop` does not handle the exception threw from the `onNext` method of a observer. The related codes:

``` java
                    switch (notification.getKind()) {
                    case OnNext:
                        underlying.onNext(notification.getValue());
                        break;
                    case OnError:
                        underlying.onError(notification.getThrowable());
                        break;
                    case OnCompleted:
                        underlying.onCompleted();
                        break;
                    default:
                        throw new IllegalStateException("Unknown kind of notification " + notification);
                    }
```
 =||= @benjchristensen I encountered one problem which I had never realized before when I tried to solve this issue.

From  the Observable's perspective, it can guarantee that it calls `onCompleted` of an Observer after all `onNext` calls. However, from the Observer's perspective, if `onNext` and `onCompleted` run in different threads, some weird thing may happen.

For example, an Observable calls `onNext` in thread t1. After 5ms, it calls `onCompleted` in thread t2. If t1 is suspended at once after it enters the `onNext` method. At this moment, none statement in `onNext` is executed. So now the Observer does not know its `onNext` has been invoked. Suppose t1 is suspended in 100ms, and t2 is not be suspended. So the Observer will find that `onCompleted` is invoked first, and after 95ms, the `onNext` method is called.

I really think such case is weird for the Observer. Could you point out where I misunderstood? 
 =||= I read the article about concurrency in Rx: http://www.introtorx.com/Content/v1.0.10621.0/15_SchedulingAndThreading.html.
But I'm still confused. Here are my problems:
- Should an Observable call all onNext, onCompleted and onError in the same thread, if no scheduler is involved?
- What's the contract when an Observable encounters a thread pool scheduler?
 =||= @benjchristensen, one more question. If an Observer throws an exception in `onNext`, does its `onError` have to be called? If so, there may be complicated to fix the issue in `rx.operators.ScheduledObserver.EventLoop`.

For example, in @samuelgruetter 's example, 

``` java
public static void main(String[] args) {
    System.out.println("started");
    System.out.println(Observable.from(1).observeOn(Schedulers.threadPoolForComputation())
        .map(f).toBlockingObservable().single());
    System.out.println("done");
}
```

`EventLoop` will receive two notifications: `onNext(1)` and `onCompleted`. However, as they are out of order, `onCompleted` may arrive first. So the observer will be notified `onCompleted`. Then, when `onNext(1)` is called, the observer will need to be notified `onError` as `onNext` throws an exception. In such situation, the `onCompleted` and `onError` will be both called.

I'm trapped in here.

Due to `onCompleted` and `onError`, concurrency in RxJava is different from Rx.Net. Is there an wiki page about concurrency in RxJava?
 =||= You should read the "Rx Design Guidelines" => http://blogs.msdn.com/b/rxteam/archive/2010/10/28/rx-design-guidelines.aspx

> Should an Observable call all onNext, onCompleted and onError in the same thread, if no scheduler is involved?

There is nothing requiring it be the same thread necessarily, but it is required that it being sequential and synchronized so the Observer doesn't need to worry about memory visibility, interleaving calls etc.

See section 6.7 and 6.8 of the design guidelines.

> What's the contract when an Observable encounters a thread pool scheduler?

It's the same, a Scheduler is for moving location and time but does not change the contract. A single Observable must still be serialized. Anything in RxJava doing differently is a bug and needs to be fixed.

We iterated several times on `ObserveOn` to get it to hopefully behave correctly so that each event it receives is put on an event loop and processed sequentially on whatever Scheduler it is given.
 =||= > EventLoop will receive two notifications: onNext(1) and onCompleted. However, as they are out of order, onCompleted may arrive first.

If they are out-of-order then we still don't have `ObserveOn` working correctly and it's a bug.
 =||= Thanks for your help. "Rx Design Guidelines" is really helpful.
 =||= Now this issue should be fixed in PR #453 and #441. It can be closed.
 =||= ,0
450,90,Operator: TimeInterval,http://msdn.microsoft.com/en-us/library/hh212107(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229092(v=vs.103).aspx,nan,0
453,417,Exception not properly propagated,Given

``` java
static Func1<Integer, Integer> f = new Func1<Integer, Integer>() {
    public Integer call(Integer arg0) {
        throw new RuntimeException("the error in f");
    }
};
```

when I run this:

``` java
public static void main(String[] args) {
    System.out.println("started");
    System.out.println(Observable.from(1)
        .map(f).toBlockingObservable().single());
    System.out.println("done");
}
```

I get (as expected) this output:

```
started
Exception in thread "main" java.lang.RuntimeException: the error in f
    at RxJavaHelloWorld$2.call(RxJavaHelloWorld.java:226)
    at [blah blah...]
    at RxJavaHelloWorld.main(RxJavaHelloWorld.java:240)
```

However, when I observe it on a different thread:

``` java
public static void main(String[] args) {
    System.out.println("started");
    System.out.println(Observable.from(1).observeOn(Schedulers.threadPoolForComputation())
        .map(f).toBlockingObservable().single());
    System.out.println("done");
}
```

then the output is this:

```
started
```

and the application does not terminate.
But I would expect that no matter on what thread I observe, errors are always propagated.,Here the error occurs even without `observeOn`:

``` java
System.out.println(Observable.from(1, 2, 3).take(1).map(f).toBlockingObservable().single());
```

This snippet also makes the app never terminate.

This prevents me from implementing the [head](https://github.com/samuelgruetter/RxJava/blob/2654f60e05a24fc910f73284e32290403d5bffcf/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala#L1565) operation in the Scala adaptor, and the original one with `observeOn` prevents me from implementing a [nice constructor](https://github.com/samuelgruetter/RxJava/blob/2654f60e05a24fc910f73284e32290403d5bffcf/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/package.scala#L141).
 =||= > Here the error occurs even without observeOn:
> 
> System.out.println(Observable.from(1, 2, 3).take(1).map(f).toBlockingObservable().single());
> This snippet also makes the app never terminate.

For `take(1)`, after the observer receives a value, any later value or error will be ignored, even if `onNext(the first value)` throws an exception. The related codes:

``` java
            @Override
            public void onError(Throwable e) {
                if (counter.getAndSet(num) < num) {
                    observer.onError(e);
                }
            }

            @Override
            public void onNext(T args) {
                final int count = counter.incrementAndGet();
                if (count <= num) {
                    observer.onNext(args);
                    if (count == num) {
                        observer.onCompleted();
                    }
                }
                if (count >= num) {
                    // this will work if the sequence is asynchronous, it will have no effect on a synchronous observable
                    subscription.unsubscribe();
                }
            }
```

For `take(1)`, it will increment `count` at first. Even if `observer.onNext(args);` throws an exception, as `count == num`, the exception is not propagated.
 =||= > public static void main(String[] args) {
>     System.out.println("started");
>     System.out.println(Observable.from(1).observeOn(Schedulers.threadPoolForComputation())
>         .map(f).toBlockingObservable().single());
>     System.out.println("done");
> }

This issue is because `rx.operators.ScheduledObserver.EventLoop` does not handle the exception threw from the `onNext` method of a observer. The related codes:

``` java
                    switch (notification.getKind()) {
                    case OnNext:
                        underlying.onNext(notification.getValue());
                        break;
                    case OnError:
                        underlying.onError(notification.getThrowable());
                        break;
                    case OnCompleted:
                        underlying.onCompleted();
                        break;
                    default:
                        throw new IllegalStateException("Unknown kind of notification " + notification);
                    }
```
 =||= @benjchristensen I encountered one problem which I had never realized before when I tried to solve this issue.

From  the Observable's perspective, it can guarantee that it calls `onCompleted` of an Observer after all `onNext` calls. However, from the Observer's perspective, if `onNext` and `onCompleted` run in different threads, some weird thing may happen.

For example, an Observable calls `onNext` in thread t1. After 5ms, it calls `onCompleted` in thread t2. If t1 is suspended at once after it enters the `onNext` method. At this moment, none statement in `onNext` is executed. So now the Observer does not know its `onNext` has been invoked. Suppose t1 is suspended in 100ms, and t2 is not be suspended. So the Observer will find that `onCompleted` is invoked first, and after 95ms, the `onNext` method is called.

I really think such case is weird for the Observer. Could you point out where I misunderstood? 
 =||= I read the article about concurrency in Rx: http://www.introtorx.com/Content/v1.0.10621.0/15_SchedulingAndThreading.html.
But I'm still confused. Here are my problems:
- Should an Observable call all onNext, onCompleted and onError in the same thread, if no scheduler is involved?
- What's the contract when an Observable encounters a thread pool scheduler?
 =||= @benjchristensen, one more question. If an Observer throws an exception in `onNext`, does its `onError` have to be called? If so, there may be complicated to fix the issue in `rx.operators.ScheduledObserver.EventLoop`.

For example, in @samuelgruetter 's example, 

``` java
public static void main(String[] args) {
    System.out.println("started");
    System.out.println(Observable.from(1).observeOn(Schedulers.threadPoolForComputation())
        .map(f).toBlockingObservable().single());
    System.out.println("done");
}
```

`EventLoop` will receive two notifications: `onNext(1)` and `onCompleted`. However, as they are out of order, `onCompleted` may arrive first. So the observer will be notified `onCompleted`. Then, when `onNext(1)` is called, the observer will need to be notified `onError` as `onNext` throws an exception. In such situation, the `onCompleted` and `onError` will be both called.

I'm trapped in here.

Due to `onCompleted` and `onError`, concurrency in RxJava is different from Rx.Net. Is there an wiki page about concurrency in RxJava?
 =||= You should read the "Rx Design Guidelines" => http://blogs.msdn.com/b/rxteam/archive/2010/10/28/rx-design-guidelines.aspx

> Should an Observable call all onNext, onCompleted and onError in the same thread, if no scheduler is involved?

There is nothing requiring it be the same thread necessarily, but it is required that it being sequential and synchronized so the Observer doesn't need to worry about memory visibility, interleaving calls etc.

See section 6.7 and 6.8 of the design guidelines.

> What's the contract when an Observable encounters a thread pool scheduler?

It's the same, a Scheduler is for moving location and time but does not change the contract. A single Observable must still be serialized. Anything in RxJava doing differently is a bug and needs to be fixed.

We iterated several times on `ObserveOn` to get it to hopefully behave correctly so that each event it receives is put on an event loop and processed sequentially on whatever Scheduler it is given.
 =||= > EventLoop will receive two notifications: onNext(1) and onCompleted. However, as they are out of order, onCompleted may arrive first.

If they are out-of-order then we still don't have `ObserveOn` working correctly and it's a bug.
 =||= Thanks for your help. "Rx Design Guidelines" is really helpful.
 =||= Now this issue should be fixed in PR #453 and #441. It can be closed.
 =||= ,0
459,454,Unsubscribing multiple times,Quoting from an email by @headinthebox, to make sure we don't forget about this issue:

> Another bug in RxJava/Scala
> 
> When you create a new subscription it does not remember that is is already disposed
> 
> In scala (using trivial companion object)
> 
> Val  s = Subscription{ println(“hi”) }
> s.unsubscribe()
> s.unsubscribe()
> 
> prints “hi” twice, in .NET only once.
> 
> In the course I will tell the students it prints only once

The issue is already present in Java:

``` java
    public static void main(String[] args) {
        Subscription s = Subscriptions.create(new Action0() {
            public void call() {
                System.out.println("hi");
            }
        });
        s.unsubscribe();
        s.unsubscribe();
    }
```

also prints "hi" twice.

Let's fix this first in Java, and then add a companion object `Subscription` to RxScala.,nan,0
460,22,Operator: Amb,http://msdn.microsoft.com/en-us/library/hh229115(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229733(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211783(v=vs.103).aspx,nan,0
463,91,Operator: Timeout,http://msdn.microsoft.com/en-us/library/hh244331(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244283(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244232(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244293(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229512(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228946(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244303(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211676(v=vs.103).aspx,Think this can be closed now
 =||= ,0
478,63,Operator: Min and MinBy,http://msdn.microsoft.com/en-us/library/hh229286(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228994(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229117(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229224(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229230(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229859(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229084(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212002(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244289(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228951(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229715(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229095(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228970(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229505(v=vs.103).aspx,nan,0
478,61,Operator: Max and MaxBy,http://msdn.microsoft.com/en-us/library/hh211633(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228920(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211789(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229262(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229205(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211692(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229793(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229567(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229001(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211981(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211837(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211635(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229058(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244330(v=vs.103).aspx,nan,0
479,40,Operator: Do,http://msdn.microsoft.com/en-us/library/hh229804(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229307(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229659(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229539(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229830(v=vs.103).aspx,was trying to implement this. but since `do` is a java keyword we ca't have it as a method name. .net/js use `Do` with caps.
ReactiveCocoa uses `doNext`, `doError` and `doCompleted`. Should rxjava too use this naming standard?
 =||= I don't see how we would have all 3 of `doNext`, `doError` and `doCompleted` as method names as those are the various overload arguments being passed in. 

For the method name, I wish `forEach` wasn't used for the synchronous version as that is exactly what this is ... 

Options I can think of are:
- doForEach
- doOnEach
- for
- each
- onEach
- doTo

This should be easy to implement using `map` since it seems to basically be `map` except it always returns the same type `T` instead of allowing it to be transformed. Am I understanding it correctly?

I believe the method signatures will end up looking like this ... once we figure out the name:

``` java
Observable<T> nameOfFunction(Observable<T> source, Action1<T> onNext)
Observable<T> nameOfFunction(Observable<T> source, Observer<T> observer)
Observable<T> nameOfFunction(Observable<T> source, Action1<T> onNext, Action onCompleted)
Observable<T> nameOfFunction(Observable<T> source, Action1<T> onNext, Action1<Exception> onError)
Observable<T> nameOfFunction(Observable<T> source, Action1<T> onNext, Action1<Exception> onError, Action onCompleted)
```
 =||= Does this function allow modifying the values or does it always return the exact same Observable source? In other words, is this only for performing side-effects? 
 =||= I think a function name with `do` prefix might be better. Coming from a .net rx/rac I would expect a `do[...]` method.

Yes it can be easily implemented using `map` but this would only work for onNext. Migt have to use `mapMany` or `materialize`/`dematerialize` combination for others.

Some info on rx do: http://stackoverflow.com/q/8732001/157260
 =||= `OperationMap` creates a new `MapObserver` with every subscription.  As a consequence, `func` is evaluated for every `onNext` as many times as there are subscriptions.  While this might be ok for pure functions, it would be very inconvenient for a `do` observable that is only there for its side-effects, e.g. something that logs events.
 =||= Generally operators in a sequence do execute each time they are subscribed to - unless something like publish, multicast, replay etc caches the results of a subscription and becomes the source of a new sequence.

The documentation I've read is very unclear regarding `do` but I don't see anything implying that it would ignore subsequence `subscribe` invocations.

For example: 

``` groovy
def o = anObservable
      .take(5)
      .map({transformHere}}
      .merge(anotherObservable)
      .do({doSideEffectsHere})
// subscribe to it once
o.subscribe()
// then subscribe again with another transformation done
o.map({anotherTransformation}).subscribe()
```

With sequence `o` being subscribed to twice I don't see anything about it that says it should cache everything before it and only be invoked once. It seems to me that it will perform the side-effects twice unless the sequence has `publish`, `multicast`, `refCount`, etc put into:

```
def o = anObservable
      .take(5)
      .map({transformHere}}
      .merge(anotherObservable)
      .do({doSideEffectsHere})
      .publish().refCount()
```

The code above adds `.publish().refCount()` which will cause the previous operators to be executed only once and shared to all subsequent subscriptions (http://northhorizon.net/2011/sharing-in-rx/).

Here is the .Net code for `do`: https://rx.codeplex.com/SourceControl/changeset/view/332fa75ecdb1#Rx/NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/Do.cs

I'm not experienced with C# so can't guarantee I understand it but I see nothing in that code that automatically is caching the sequence.

Thus, I think the `do` operator will be executed each time just like other operators when subscribed to.

Am I misunderstanding something about the contract specified by Rx.Net?
 =||= @prabirshrestha It makes sense to keep the do\* prefix, so what do you prefer of these?
- doForEach
- doOnEach
- doTo

Is there a better option?

I lean towards `doOnEach` because `on` fits the `onNext\onError\onCompleted` naming convention.
 =||= @benjchristensen Even I preferred `doOnEach`. That was what I started to use.

> Thus, I think the do operator will be executed each time just like other operators when subscribed to.

Thats right. I will verify this with .net too.

@mva `do` operator can be used to follow divide and conquer pattern to.
Here is a c# sample code from http://www.codeproject.com/Articles/132966/Exploring-Reactive-Extensions-Rx-through-Twitter-a

``` c#
Observable.FromEvent<TextChangedEventArgs>(searchTextBox, "TextChanged")
          .Select(e => ((TextBox)e.Sender).Text)
          .Where(text => text.Length > 2)
          .Do(s => searchResults.Opacity = 0.5)       // reduce list opacity when typing   
          .Throttle(TimeSpan.FromMilliseconds(400))
          .ObserveOnDispatcher()
          .Do(s => LoadingIndicator.Visibility = Visibility.Visible)  // show the loading indicator 
          .SelectMany(txt => searchTwitter(txt))
          .Select(searchRes => ParseTwitterSearch(searchRes))
          .ObserveOnDispatcher()
          .Do(s => LoadingIndicator.Visibility = Visibility.Collapsed) // hide the loading indicator
          .Do(s => searchResults.Opacity = 1)                          // return the list opacity to one
          .Subscribe(tweets => searchResults.ItemsSource = tweets);
```

I found using `do` in mobile apps this way really useful.
 =||= @benjchristensen, I think I am starting to understand the distinction you are making.  The side-effect of a `do` is not "owned" by the single observable instance, but rather by its potentially many subscribers.

Using logging as an example: this makes perfect sense for a cold/passive observable because every value send to a subscriber is independent of all other values, and deserves its own log entry.

On the other hand, if I want to log the output of a hot/active observable irregardless of the (possibly zero) number of subscribers, I would put the `do` on the path from the observable to a Publish/Connect.  Here, exactly one log entry would be written for each value produced by the hot observable.

Thank you for your explanation!
 =||= ,0
480,423,Reduce an empty observable,Hi,

In RxJava, `reduce(Func2<T, T, T> accumulator)` may be not implemented correctly. Now `reduce` is implemented using `scan`. When reducing on empty observable,  it will invoke `onCompleted` and do nothing.  This is against my expectation. I suppose that reducing an empty observable should throw an exception.

Actually, `Scan` and `Aggregate`(I think this is `reduce` in C#) have different behaviors in C#. `Scan` an empty observable will do nothing, but `Aggregate` will throw a `System.InvalidOperationException`.

Here are my test codes in C#.
Scan:

``` c#
Observable.Empty<int>().Scan((x, y) => x + y).Subscribe(
                x => 
                    Console.WriteLine("subscriber got " + x)
            );
```

Aggregate:

``` c#
Observable.Empty<int>().Aggregate((x, y) => x + y).Subscribe(
                x => 
                    Console.WriteLine("subscriber got " + x)
            );

```

I also tried the `reduce` method in other languages.

`List[Int]().reduce(_ + _)` will throw 
`java.lang.UnsupportedOperationException: empty.reduceLeft` in scala.

`reduce(lambda x, y:  x + y, [])` will throw `reduce() of empty sequence with no initial value` in python.

If reducing an empty observable throws an exception, we can implement `min` and `max` by `reduce` directly.,@zsxwing, Thanks for diving into this.  

(aside: When you write snippets like this it is a good idea to also look at onCompleted and onError. Aggregate does not "throw" an exception, but sends out an onError with an exception. And return the empty sequence by immediately calling onCompleted, which is not the same as "do nothing". Subtle, but important to be super precise as we look at the edge cases)

var xs = new[]{ 1, 2 , 3}.ToObservable();
var ys = new int[]{}.ToObservable();

xs.Aggregate(accumulator: (x,y)=>x+y).Subscribe
( x => Console.WriteLine("[1, 2, 3].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [1, 2, 3].Aggregate((x,y)=>x+1) = 6
// Done

ys.Aggregate(accumulator: (x,y)=>x+y).Subscribe
( x => Console.WriteLine("[].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// Boom = System.InvalidOperationException: Sequence contains no elements.

xs.Aggregate(seed: 0, accumulator: (x,y)=>x+y).Subscribe
(x => Console.WriteLine("[1, 2, 3].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [1, 2, 3].Aggregate((x,y)=>x+1) = 6
// Done

ys.Aggregate(seed: 0, accumulator:(x,y)=>x+y).Subscribe
(x => Console.WriteLine("[].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [].Aggregate((x,y)=>x+1) = 0
// Done

xs.Aggregate(seed: 0, accumulator: (x,y)=>x+y, resultSelector: x => string.Format("[{0}]", x)).Subscribe
( x => Console.WriteLine("[1, 2, 3].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [1, 2, 3].Aggregate((x,y)=>x+1) = [6]
// Done

ys.Aggregate(seed: 0, accumulator:(x,y)=>x+y, resultSelector: x => string.Format("[{0}]", x)).Subscribe
( x => Console.WriteLine("[].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [].Aggregate((x,y)=>x+1) = [0]
// Done
 =||= No, looking at scan, I would say that scan in Rx.NET is broken.

In Haskell, the seed in a scan is sent out as well

Prelude> scanl (+) 0 []
[0]

Prelude> scanl (+) 0 [1,2,3]
[0,1,3,6]

With no seed, the results look like this

Prelude> scanl1 (+) [1,2,3]
[1,3,6]

Prelude> scanl1 (+) []
[]

But in C#, the seed is not send out.

var xs = new[]{ 1, 2 , 3}.ToObservable();
var ys = new int[]{}.ToObservable();

xs.Scan(accumulator: (x,y)=>x+y).Subscribe
( x => Console.WriteLine("[1, 2, 3].Scan((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [1, 2, 3].Scan((x,y)=>x+1) = 1
// [1, 2, 3].Scan((x,y)=>x+1) = 3
// [1, 2, 3].Scan((x,y)=>x+1) = 6
// Done

ys.Scan(accumulator: (x,y)=>x+y).Subscribe
( x => Console.WriteLine("[].Scan((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// Done

xs.Scan(seed: 0, accumulator: (x,y)=>x+y).Subscribe
(x => Console.WriteLine("[1, 2, 3].Scan((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [1, 2, 3].Scan((x,y)=>x+1) = 1
// [1, 2, 3].Scan((x,y)=>x+1) = 3
// [1, 2, 3].Scan((x,y)=>x+1) = 6
// Done

ys.Scan(seed: 0, accumulator:(x,y)=>x+y).Subscribe
(x => Console.WriteLine("[].Scan((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// Done
 =||= I'd say we define for once and for all that (see http://www.haskell.org/hoogle/?hoogle=scanl)

xs.aggregate(op) = xs.scan(op).lastasync()
xs.aggregate(e, op) = xs.scan(e, op).lastasync()
xs.aggregate(e, op, f) = xs.scan(e, op).lastasync().map(f)
 =||= RxJava misses .LastAsync() and instead uses takeLast(n), which behaves differently.

var xs = Observable.Empty<int>();
xs.TakeLast(1).Dump(); // onCompleted()
xs.LastAsync().Dump();// onError(... invalidOperation exception ...)
 =||= I found http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.aspx was out of date. Now Rx.Net has a blocking version of `Last` and `First`, and a unblocking version of `LastAsync` and `FirstAsync`.

Here is the document I copy from VS:

``` c#
        // Summary:
        //     Returns the first element of an observable sequence.
        //
        // Parameters:
        //   source:
        //     Source observable sequence.
        //
        // Type parameters:
        //   TSource:
        //     The type of the elements in the source sequence.
        //
        // Returns:
        //     Sequence containing the first element in the observable sequence.
        //
        // Exceptions:
        //   System.ArgumentNullException:
        //     source is null.
        //
        //   System.InvalidOperationException:
        //     (Asynchronous) The source sequence is empty.
        public static IObservable<TSource> FirstAsync<TSource>(this IObservable<TSource> source);
        //
        // Summary:
        //     Returns the first element of an observable sequence that satisfies the condition
        //     in the predicate.
        //
        // Parameters:
        //   source:
        //     Source observable sequence.
        //
        //   predicate:
        //     A predicate function to evaluate for elements in the source sequence.
        //
        // Type parameters:
        //   TSource:
        //     The type of the elements in the source sequence.
        //
        // Returns:
        //     Sequence containing the first element in the observable sequence that satisfies
        //     the condition in the predicate.
        //
        // Exceptions:
        //   System.ArgumentNullException:
        //     source or predicate is null.
        //
        //   System.InvalidOperationException:
        //     (Asynchronous) No element satisfies the condition in the predicate. -or-
        //     The source sequence is empty.
        public static IObservable<TSource> FirstAsync<TSource>(this IObservable<TSource> source, Func<TSource, bool> predicate);

        //
        // Summary:
        //     Returns the last element of an observable sequence.
        //
        // Parameters:
        //   source:
        //     Source observable sequence.
        //
        // Type parameters:
        //   TSource:
        //     The type of the elements in the source sequence.
        //
        // Returns:
        //     Sequence containing the last element in the observable sequence.
        //
        // Exceptions:
        //   System.ArgumentNullException:
        //     source is null.
        //
        //   System.InvalidOperationException:
        //     (Asynchronous) The source sequence is empty.
        public static IObservable<TSource> LastAsync<TSource>(this IObservable<TSource> source);
        //
        // Summary:
        //     Returns the last element of an observable sequence that satisfies the condition
        //     in the predicate.
        //
        // Parameters:
        //   source:
        //     Source observable sequence.
        //
        //   predicate:
        //     A predicate function to evaluate for elements in the source sequence.
        //
        // Type parameters:
        //   TSource:
        //     The type of the elements in the source sequence.
        //
        // Returns:
        //     Sequence containing the last element in the observable sequence that satisfies
        //     the condition in the predicate.
        //
        // Exceptions:
        //   System.ArgumentNullException:
        //     source or predicate is null.
        //
        //   System.InvalidOperationException:
        //     (Asynchronous) No element satisfies the condition in the predicate. -or-
        //     The source sequence is empty.
        public static IObservable<TSource> LastAsync<TSource>(this IObservable<TSource> source, Func<TSource, bool> predicate);

```
 =||= @benjchristensen do we need to add the new Rx.Net interfaces?
 =||= I have an implementation for this ready. This will fax the issue for reduce/scan. Did you see the comments.

Sent from my iPad

> On Nov 4, 2013, at 3:51 AM, Shixiong Zhu notifications@github.com wrote:
> 
> @benjchristensen do we need to add the new Rx.Net interfaces?
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= @headinthebox sorry, I mean that do we need to add these Rx.Net interfaces (lastAsync, firstAsync)  into RxJava.
 =||= @zsxwing Yes, that's what I meant. I have an implementation for them, but then recursively found some bugs in other operators.
 =||= @zsxwing @headinthebox 

We already have a `first` operator in `Observable` that is async: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L3919

We solved the problem of duplicate naming for blocking/non-blocking in RxJava by separating all blocking operators into the `BlockingObservable` class so it is explicit. Everything on `Observable` is non-blocking and returns an Observable except for `subscribe` which returns `Subscription`.

The `takeLast` operator could have a `last` method aliased to `takeLast(1)` in `Observable`.
 =||= > RxJava misses .LastAsync() and instead uses takeLast(n), which behaves differently.
> var xs = Observable.Empty();
> xs.TakeLast(1).Dump(); // onCompleted()
> xs.LastAsync().Dump();// onError(... invalidOperation exception ...)

That seems non-obvious why 2 variants of `last` should behave differently regarding error propagation. 

Why should `lastAsync` behave differently than `takeLast(1)` when `last` means "take the last value". Should `takeLast(1)` emit an error since you have asked for more than are available? Same with `takeLast(5)` if less than 5 are available? If wanted without errors, then `takeUpToLast(5)` would take 0-5 items, but `takeLast(5)` would only take 5 or error.
 =||= I just realized that the question "what should the operator do if the source observable does not have enough elements?" should be asked for some other operators as well:
-    elementAt
-    reduce(Func2<T, T, T>) and aggregate(Func2<T, T, T>)
-    average{Longs/Floats/Doubles}
-    min
-    max
-    skip
-    first (2 overloads) and takeFirst (2 overloads)
-    take
-    takeLast
-    skipLast

I'd prefer that onError be called, instead of ignoring that there were not enough elements. That's also what scala collections do.

And if takeLast on an empty observable calls onError, reduce can nicely be implemented using scan.
 =||= @headinthebox I am not aware of a rule that covers this, can you provide an answer for @samuelgruetter's question? We can then go build the unit tests and get code to match the rule.
 =||= elementAt ==> OnError("out of range")

reduce(Func2) and aggregate(Func2) ==> that's what started this discussion, see above.
average{Longs/Floats/Doubles} ==> same, defined as reduce.
min ==> ==> same, defined as reduce.
max ==> same, defined as reduce.
skip ==> onCompleted()
first (2 overloads) ==> throws for blocking observable, onError("empty sequence")
and takeFirst (2 overloads) ==> as many elements as it can get, ending with onCompleted.
take ==> I think this is an alias for takeFirst.

takeLast ==> as many elements as it can get, ending with onCompleted.
skipLast ==> onCompleted
 =||= The behavior in Rx.NET is the same as in Haskell, except for the bug in scan discussed up here.

Prelude> take 5 [1..3]
[1,2,3]

etc.
 =||= I reviewed these operators in RxJava. Here is my conclusion.
- `elementAt` is correct.
- `reduce` and `aggregate`  is wrong.
- `min` and `max` are not implemented. However, I have already finished it in my branch: https://github.com/zsxwing/RxJava/commits/min-max . Once the reduce issue is fixed, I'll send a PR.
- `average` uses `reduce`. For an empty observable, it will emit a DivisionByZero error. I think this error is not correct. It should be something like `UnsupportedOperationException`. In Rx.net, it's `System.InvalidOperationException: Sequence contains no elements.`
- `takeFirst`, `takeLast`, `skip` and `skipLast` is correct.
- blocking `last` is wrong. See #464
- non-blocking `last` is missing.
- blocking `first` is missing.
- non-blocking `first` is wrong.

Please correct me if I have misunderstood something. 
 =||= I have completed the blocking and non-blocking `last` impls in https://github.com/Netflix/RxJava/pull/470
 =||= @zsxwing Are you working on any of these others already so we don't duplicate effort?
 =||= Actually, seems like `reduce` is the only one needing fixing as `average` will fix itself once `reduce` is done.
 =||= The `reduce` operator is now fixed for the empty Observable case.

When the Observable is empty but a seed is passed in, it just emits the seed:

``` java
    /**
     * A reduce on an empty Observable and a seed should just pass the seed through.
     * 
     * This is confirmed at https://github.com/Netflix/RxJava/issues/423#issuecomment-27642456
     */
    @Test
    public void testReduceWithEmptyObservableAndSeed() {
        Observable<Integer> observable = Observable.range(1, 0);
        int value = observable.reduce(1, new Func2<Integer, Integer, Integer>() {

            @Override
            public Integer call(Integer t1, Integer t2) {
                return t1 + t2;
            }

        }).toBlockingObservable().last();

        assertEquals(1, value);
    }
```

Please confirm that current code and unit test match the expected behavior and then we can close this ... or we correct again.
 =||= There is still a difference between Average in RxJava and Rx.Net when the observable is empty.

This is a unit test for Average in RxJava.

``` Java
    @Test
    public void testEmptyAverage() throws Throwable {
        Observable<Integer> src = Observable.empty();
        average(src).subscribe(w);

        verify(w, never()).onNext(anyInt());
        verify(w, times(1)).onError(any(ArithmeticException.class));
        verify(w, never()).onCompleted();
    }
```

If the observable is empty, average emits an ArithmeticException.

Here is a sample for Average in Rx.Net.

``` c#
            IObservable<double> o = Observable.Empty<int>().Average();
            o.Subscribe(
                x => Console.WriteLine("OnNext: " + x),
                e => Console.WriteLine("OnError: " + e),
                () => Console.WriteLine("Done")
                );
```

It outputs "OnError: System.InvalidOperationException: Sequence contains no elements.".
 =||= @benjchristensen Now I'm only working on `min` and `max` operators.
 =||= I sent the PR #478 for `min` and `max`.
 =||= I fixed the `Average` issue for the empty Observable case in #480. Please help me confirm it.
 =||= Closed as it's fixed.
 =||= ,0
481,99,Operator: Using,http://msdn.microsoft.com/en-us/library/hh229585(v=vs.103).aspx,nan,0
492,68,Operator: Range,http://msdn.microsoft.com/en-us/library/hh229460(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211896(v=vs.103).aspx,The first (http://msdn.microsoft.com/en-us/library/hh229460(v=vs.103).aspx) is implemented in https://github.com/Netflix/RxJava/pull/137

The second is waiting on schedulers.
 =||= Leaving open for the schedulers implementation.
 =||= ,0
492,98,Operator: ToObservable with scheduler,http://msdn.microsoft.com/en-us/library/hh212140(v=vs.103).aspx,nan,0
492,82,Operator: StartWith,http://msdn.microsoft.com/en-us/library/hh229340(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229372(v=vs.103).aspx,nan,0
496,494,Operators without co- or contravariance,I'm looking at the operator definition and found a bunch of places where the "lambda" functions do not have wildcard bounds specified, e.g.,

reduce(Func2[T, T, T])
max(Comparator[T])

etc.
Is there a particular reason these are not:

reduce(Func2[? super T, ? super T, ? extends T])
max(Comparator[? super T])

?,reduce:

That's a long story, see https://github.com/Netflix/RxJava/pull/369 , https://github.com/Netflix/RxJava/issues/360 , and https://github.com/Netflix/RxJava/issues/336#issuecomment-24094254 . 
In short:
-    It's considered unnecessary (or not necessary enough to complicate the signature)
-    Note, though, that the signature of reduce is not entirely correct, because the covariant type parameter T appears in a contravariant position, so you can't use reduce on an `Observable<? extends XXX>` , but only on an `Observable<XXX>` . To fix this, one would need lower bounds for type parameters, but Java doesn't support this.

min/max:

IMHO it would be a good idea to add wildcards, what do others think?
 =||= For min/max, I agree with you. I'll fix it.
 =||= It seems we can close this issue now.
 =||= ,0
506,23,Operator: And,http://msdn.microsoft.com/en-us/library/hh229153(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229905(v=vs.103).aspx,This operation requires a join-pattern sub-framework to be created (rx.joins). Additionally, due to method arities, this might require Action4...Action9, ActionN classes (I have these in pull #505) if decided.
However, I don't quite understand the join patterns as most of the Rx.NET classes are internal and without documentation; I can convert it to java but no idea what tests to create for them.
 =||= ,0
506,88,Operator: Then,http://msdn.microsoft.com/en-us/library/hh211662(v=vs.103).aspx,nan,0
506,100,Operator: When,http://msdn.microsoft.com/en-us/library/hh229558(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229889(v=vs.103).aspx,nan,0
513,96,Operator: ToDictionary,http://msdn.microsoft.com/en-us/library/hh229137(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212046(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212075(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229073(v=vs.103).aspx,I believe the equivalent to IDictionary is a Map in Java, but there are a lot of map classes (Linked, Concurrent, etc.). Which one should be the default value type? Is it okay to call the methods Observable.toMap() ?
 =||= I vote for java.util.HashMap by default with an overload that lets you pass in a map class of any type you want.

```
public <K, V, M extends java.util.Map<K, V>> Observable<M> toMap(Class<M> mapClass, Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends V> elementSelector) {...}
```

PS: not sure if I got the co/contra-variance right on that.
PPS: I Think the consensus was to ignore EqualityComparators overloads because the idiomatic java way is to implement equals/hashCode on the class.
 =||= Two questions:
-    How many times will this operator call onNext? Just once, or every time it gets a new item?
-    Are users allowed to modify the returned map?
 =||= This is how I did it somewhere else (below):
- Takes a factory which returns a map instance on subscription
- emits the map once the source finishes
- no variance on the output observable's type

``` java
public class OperationToMap {
    public static class ToMap<T, K, V> implements OnSubscribeFunc<Map<K, V>> {
        private final Observable<T> source;
        private final Func1<? super T, ? extends K> keySelector;
        private final Func1<? super T, ? extends V> valueSelector;
        private final Func0<? extends Map<K, V>> mapFactory;
        public ToMap(
                Observable<T> source,
                Func1<? super T, ? extends K> keySelector,
                Func1<? super T, ? extends V> valueSelector,
                Func0<? extends Map<K, V>> mapFactory
                ) {
            this.source = source;
            this.keySelector = keySelector;
            this.valueSelector = valueSelector;
            this.mapFactory = mapFactory;
        }
        @Override
        public Subscription onSubscribe(Observer<? super Map<K, V>> t1) {
            return source.subscribe(new ToMapObserver(t1));
        }
        public class ToMapObserver implements Observer<T> {
            Map<K, V> map;
            private final Observer<? super Map<K, V>> t1;
            public ToMapObserver(Observer<? super Map<K, V>> t1) {
                map = mapFactory.call();
                this.t1 = t1;
            }
            @Override
            public void onCompleted() {
                Map<K, V> map0 = map;
                map = null;
                t1.onNext(map0);
                t1.onCompleted();
            }
            @Override
            public void onError(Throwable e) {
                map = null;
                t1.onError(e);
            }
            @Override
            public void onNext(T args) {
                K key = keySelector.call(args);
                V value = valueSelector.call(args);
                map.put(key, value);
            }
        }
    }
}
```
 =||= ,0
513,97,Operator: ToLookup,http://msdn.microsoft.com/en-us/library/hh212098(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211805(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229101(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211616(v=vs.103).aspx,nan,0
520,423,Reduce an empty observable,Hi,

In RxJava, `reduce(Func2<T, T, T> accumulator)` may be not implemented correctly. Now `reduce` is implemented using `scan`. When reducing on empty observable,  it will invoke `onCompleted` and do nothing.  This is against my expectation. I suppose that reducing an empty observable should throw an exception.

Actually, `Scan` and `Aggregate`(I think this is `reduce` in C#) have different behaviors in C#. `Scan` an empty observable will do nothing, but `Aggregate` will throw a `System.InvalidOperationException`.

Here are my test codes in C#.
Scan:

``` c#
Observable.Empty<int>().Scan((x, y) => x + y).Subscribe(
                x => 
                    Console.WriteLine("subscriber got " + x)
            );
```

Aggregate:

``` c#
Observable.Empty<int>().Aggregate((x, y) => x + y).Subscribe(
                x => 
                    Console.WriteLine("subscriber got " + x)
            );

```

I also tried the `reduce` method in other languages.

`List[Int]().reduce(_ + _)` will throw 
`java.lang.UnsupportedOperationException: empty.reduceLeft` in scala.

`reduce(lambda x, y:  x + y, [])` will throw `reduce() of empty sequence with no initial value` in python.

If reducing an empty observable throws an exception, we can implement `min` and `max` by `reduce` directly.,@zsxwing, Thanks for diving into this.  

(aside: When you write snippets like this it is a good idea to also look at onCompleted and onError. Aggregate does not "throw" an exception, but sends out an onError with an exception. And return the empty sequence by immediately calling onCompleted, which is not the same as "do nothing". Subtle, but important to be super precise as we look at the edge cases)

var xs = new[]{ 1, 2 , 3}.ToObservable();
var ys = new int[]{}.ToObservable();

xs.Aggregate(accumulator: (x,y)=>x+y).Subscribe
( x => Console.WriteLine("[1, 2, 3].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [1, 2, 3].Aggregate((x,y)=>x+1) = 6
// Done

ys.Aggregate(accumulator: (x,y)=>x+y).Subscribe
( x => Console.WriteLine("[].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// Boom = System.InvalidOperationException: Sequence contains no elements.

xs.Aggregate(seed: 0, accumulator: (x,y)=>x+y).Subscribe
(x => Console.WriteLine("[1, 2, 3].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [1, 2, 3].Aggregate((x,y)=>x+1) = 6
// Done

ys.Aggregate(seed: 0, accumulator:(x,y)=>x+y).Subscribe
(x => Console.WriteLine("[].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [].Aggregate((x,y)=>x+1) = 0
// Done

xs.Aggregate(seed: 0, accumulator: (x,y)=>x+y, resultSelector: x => string.Format("[{0}]", x)).Subscribe
( x => Console.WriteLine("[1, 2, 3].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [1, 2, 3].Aggregate((x,y)=>x+1) = [6]
// Done

ys.Aggregate(seed: 0, accumulator:(x,y)=>x+y, resultSelector: x => string.Format("[{0}]", x)).Subscribe
( x => Console.WriteLine("[].Aggregate((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [].Aggregate((x,y)=>x+1) = [0]
// Done
 =||= No, looking at scan, I would say that scan in Rx.NET is broken.

In Haskell, the seed in a scan is sent out as well

Prelude> scanl (+) 0 []
[0]

Prelude> scanl (+) 0 [1,2,3]
[0,1,3,6]

With no seed, the results look like this

Prelude> scanl1 (+) [1,2,3]
[1,3,6]

Prelude> scanl1 (+) []
[]

But in C#, the seed is not send out.

var xs = new[]{ 1, 2 , 3}.ToObservable();
var ys = new int[]{}.ToObservable();

xs.Scan(accumulator: (x,y)=>x+y).Subscribe
( x => Console.WriteLine("[1, 2, 3].Scan((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [1, 2, 3].Scan((x,y)=>x+1) = 1
// [1, 2, 3].Scan((x,y)=>x+1) = 3
// [1, 2, 3].Scan((x,y)=>x+1) = 6
// Done

ys.Scan(accumulator: (x,y)=>x+y).Subscribe
( x => Console.WriteLine("[].Scan((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// Done

xs.Scan(seed: 0, accumulator: (x,y)=>x+y).Subscribe
(x => Console.WriteLine("[1, 2, 3].Scan((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// [1, 2, 3].Scan((x,y)=>x+1) = 1
// [1, 2, 3].Scan((x,y)=>x+1) = 3
// [1, 2, 3].Scan((x,y)=>x+1) = 6
// Done

ys.Scan(seed: 0, accumulator:(x,y)=>x+y).Subscribe
(x => Console.WriteLine("[].Scan((x,y)=>x+1) = {0}", x)
, e => Console.WriteLine("Boom = {0}", e)
, () => Console.WriteLine("Done")
);

// Done
 =||= I'd say we define for once and for all that (see http://www.haskell.org/hoogle/?hoogle=scanl)

xs.aggregate(op) = xs.scan(op).lastasync()
xs.aggregate(e, op) = xs.scan(e, op).lastasync()
xs.aggregate(e, op, f) = xs.scan(e, op).lastasync().map(f)
 =||= RxJava misses .LastAsync() and instead uses takeLast(n), which behaves differently.

var xs = Observable.Empty<int>();
xs.TakeLast(1).Dump(); // onCompleted()
xs.LastAsync().Dump();// onError(... invalidOperation exception ...)
 =||= I found http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.aspx was out of date. Now Rx.Net has a blocking version of `Last` and `First`, and a unblocking version of `LastAsync` and `FirstAsync`.

Here is the document I copy from VS:

``` c#
        // Summary:
        //     Returns the first element of an observable sequence.
        //
        // Parameters:
        //   source:
        //     Source observable sequence.
        //
        // Type parameters:
        //   TSource:
        //     The type of the elements in the source sequence.
        //
        // Returns:
        //     Sequence containing the first element in the observable sequence.
        //
        // Exceptions:
        //   System.ArgumentNullException:
        //     source is null.
        //
        //   System.InvalidOperationException:
        //     (Asynchronous) The source sequence is empty.
        public static IObservable<TSource> FirstAsync<TSource>(this IObservable<TSource> source);
        //
        // Summary:
        //     Returns the first element of an observable sequence that satisfies the condition
        //     in the predicate.
        //
        // Parameters:
        //   source:
        //     Source observable sequence.
        //
        //   predicate:
        //     A predicate function to evaluate for elements in the source sequence.
        //
        // Type parameters:
        //   TSource:
        //     The type of the elements in the source sequence.
        //
        // Returns:
        //     Sequence containing the first element in the observable sequence that satisfies
        //     the condition in the predicate.
        //
        // Exceptions:
        //   System.ArgumentNullException:
        //     source or predicate is null.
        //
        //   System.InvalidOperationException:
        //     (Asynchronous) No element satisfies the condition in the predicate. -or-
        //     The source sequence is empty.
        public static IObservable<TSource> FirstAsync<TSource>(this IObservable<TSource> source, Func<TSource, bool> predicate);

        //
        // Summary:
        //     Returns the last element of an observable sequence.
        //
        // Parameters:
        //   source:
        //     Source observable sequence.
        //
        // Type parameters:
        //   TSource:
        //     The type of the elements in the source sequence.
        //
        // Returns:
        //     Sequence containing the last element in the observable sequence.
        //
        // Exceptions:
        //   System.ArgumentNullException:
        //     source is null.
        //
        //   System.InvalidOperationException:
        //     (Asynchronous) The source sequence is empty.
        public static IObservable<TSource> LastAsync<TSource>(this IObservable<TSource> source);
        //
        // Summary:
        //     Returns the last element of an observable sequence that satisfies the condition
        //     in the predicate.
        //
        // Parameters:
        //   source:
        //     Source observable sequence.
        //
        //   predicate:
        //     A predicate function to evaluate for elements in the source sequence.
        //
        // Type parameters:
        //   TSource:
        //     The type of the elements in the source sequence.
        //
        // Returns:
        //     Sequence containing the last element in the observable sequence that satisfies
        //     the condition in the predicate.
        //
        // Exceptions:
        //   System.ArgumentNullException:
        //     source or predicate is null.
        //
        //   System.InvalidOperationException:
        //     (Asynchronous) No element satisfies the condition in the predicate. -or-
        //     The source sequence is empty.
        public static IObservable<TSource> LastAsync<TSource>(this IObservable<TSource> source, Func<TSource, bool> predicate);

```
 =||= @benjchristensen do we need to add the new Rx.Net interfaces?
 =||= I have an implementation for this ready. This will fax the issue for reduce/scan. Did you see the comments.

Sent from my iPad

> On Nov 4, 2013, at 3:51 AM, Shixiong Zhu notifications@github.com wrote:
> 
> @benjchristensen do we need to add the new Rx.Net interfaces?
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= @headinthebox sorry, I mean that do we need to add these Rx.Net interfaces (lastAsync, firstAsync)  into RxJava.
 =||= @zsxwing Yes, that's what I meant. I have an implementation for them, but then recursively found some bugs in other operators.
 =||= @zsxwing @headinthebox 

We already have a `first` operator in `Observable` that is async: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L3919

We solved the problem of duplicate naming for blocking/non-blocking in RxJava by separating all blocking operators into the `BlockingObservable` class so it is explicit. Everything on `Observable` is non-blocking and returns an Observable except for `subscribe` which returns `Subscription`.

The `takeLast` operator could have a `last` method aliased to `takeLast(1)` in `Observable`.
 =||= > RxJava misses .LastAsync() and instead uses takeLast(n), which behaves differently.
> var xs = Observable.Empty();
> xs.TakeLast(1).Dump(); // onCompleted()
> xs.LastAsync().Dump();// onError(... invalidOperation exception ...)

That seems non-obvious why 2 variants of `last` should behave differently regarding error propagation. 

Why should `lastAsync` behave differently than `takeLast(1)` when `last` means "take the last value". Should `takeLast(1)` emit an error since you have asked for more than are available? Same with `takeLast(5)` if less than 5 are available? If wanted without errors, then `takeUpToLast(5)` would take 0-5 items, but `takeLast(5)` would only take 5 or error.
 =||= I just realized that the question "what should the operator do if the source observable does not have enough elements?" should be asked for some other operators as well:
-    elementAt
-    reduce(Func2<T, T, T>) and aggregate(Func2<T, T, T>)
-    average{Longs/Floats/Doubles}
-    min
-    max
-    skip
-    first (2 overloads) and takeFirst (2 overloads)
-    take
-    takeLast
-    skipLast

I'd prefer that onError be called, instead of ignoring that there were not enough elements. That's also what scala collections do.

And if takeLast on an empty observable calls onError, reduce can nicely be implemented using scan.
 =||= @headinthebox I am not aware of a rule that covers this, can you provide an answer for @samuelgruetter's question? We can then go build the unit tests and get code to match the rule.
 =||= elementAt ==> OnError("out of range")

reduce(Func2) and aggregate(Func2) ==> that's what started this discussion, see above.
average{Longs/Floats/Doubles} ==> same, defined as reduce.
min ==> ==> same, defined as reduce.
max ==> same, defined as reduce.
skip ==> onCompleted()
first (2 overloads) ==> throws for blocking observable, onError("empty sequence")
and takeFirst (2 overloads) ==> as many elements as it can get, ending with onCompleted.
take ==> I think this is an alias for takeFirst.

takeLast ==> as many elements as it can get, ending with onCompleted.
skipLast ==> onCompleted
 =||= The behavior in Rx.NET is the same as in Haskell, except for the bug in scan discussed up here.

Prelude> take 5 [1..3]
[1,2,3]

etc.
 =||= I reviewed these operators in RxJava. Here is my conclusion.
- `elementAt` is correct.
- `reduce` and `aggregate`  is wrong.
- `min` and `max` are not implemented. However, I have already finished it in my branch: https://github.com/zsxwing/RxJava/commits/min-max . Once the reduce issue is fixed, I'll send a PR.
- `average` uses `reduce`. For an empty observable, it will emit a DivisionByZero error. I think this error is not correct. It should be something like `UnsupportedOperationException`. In Rx.net, it's `System.InvalidOperationException: Sequence contains no elements.`
- `takeFirst`, `takeLast`, `skip` and `skipLast` is correct.
- blocking `last` is wrong. See #464
- non-blocking `last` is missing.
- blocking `first` is missing.
- non-blocking `first` is wrong.

Please correct me if I have misunderstood something. 
 =||= I have completed the blocking and non-blocking `last` impls in https://github.com/Netflix/RxJava/pull/470
 =||= @zsxwing Are you working on any of these others already so we don't duplicate effort?
 =||= Actually, seems like `reduce` is the only one needing fixing as `average` will fix itself once `reduce` is done.
 =||= The `reduce` operator is now fixed for the empty Observable case.

When the Observable is empty but a seed is passed in, it just emits the seed:

``` java
    /**
     * A reduce on an empty Observable and a seed should just pass the seed through.
     * 
     * This is confirmed at https://github.com/Netflix/RxJava/issues/423#issuecomment-27642456
     */
    @Test
    public void testReduceWithEmptyObservableAndSeed() {
        Observable<Integer> observable = Observable.range(1, 0);
        int value = observable.reduce(1, new Func2<Integer, Integer, Integer>() {

            @Override
            public Integer call(Integer t1, Integer t2) {
                return t1 + t2;
            }

        }).toBlockingObservable().last();

        assertEquals(1, value);
    }
```

Please confirm that current code and unit test match the expected behavior and then we can close this ... or we correct again.
 =||= There is still a difference between Average in RxJava and Rx.Net when the observable is empty.

This is a unit test for Average in RxJava.

``` Java
    @Test
    public void testEmptyAverage() throws Throwable {
        Observable<Integer> src = Observable.empty();
        average(src).subscribe(w);

        verify(w, never()).onNext(anyInt());
        verify(w, times(1)).onError(any(ArithmeticException.class));
        verify(w, never()).onCompleted();
    }
```

If the observable is empty, average emits an ArithmeticException.

Here is a sample for Average in Rx.Net.

``` c#
            IObservable<double> o = Observable.Empty<int>().Average();
            o.Subscribe(
                x => Console.WriteLine("OnNext: " + x),
                e => Console.WriteLine("OnError: " + e),
                () => Console.WriteLine("Done")
                );
```

It outputs "OnError: System.InvalidOperationException: Sequence contains no elements.".
 =||= @benjchristensen Now I'm only working on `min` and `max` operators.
 =||= I sent the PR #478 for `min` and `max`.
 =||= I fixed the `Average` issue for the empty Observable case in #480. Please help me confirm it.
 =||= Closed as it's fixed.
 =||= ,0
522,521,Unsubscribe from takeLast,When I unsubscribe from an Observable which emits the last value of an infinite stream, I expect to get no element. This is the case in C#:

``` cs
var o = Observable.Interval(TimeSpan.FromMilliseconds(200)).TakeLast(1);
var s = o.Subscribe(i => Console.WriteLine("Interesting: Infinity = " + i));
Thread.Sleep(1000);
s.Dispose();
Thread.Sleep(1000);
Console.WriteLine("Press any key...");
Console.ReadKey();
```

outputs

```
Press any key...
```

But with RxJava, it's different (note that Scala's takeRight calls Java's takeLast):

``` scala
val o = Observable.interval(200 millis).takeRight(1)
val s = o.subscribe(i => println(s"Interesting: Infinity = $i"))
Thread.sleep(1000)
s.unsubscribe()
Thread.sleep(1000)  
```

outputs

```
Interesting: Infinity = 4
```,It's an issue of `interval`. Here is the unit test to reveal it:

``` java
    @Test
    public void testIssue521() throws InterruptedException {
        Observable<Long> o = Observable.interval(200, TimeUnit.MILLISECONDS);
        Subscription s = o.subscribe(new Observer<Long>() {

            @Override
            public void onCompleted() {
                System.out.println("onCompleted");
            }

            @Override
            public void onError(Throwable e) {
            }

            @Override
            public void onNext(Long args) {
                System.out.println(args);
            }
        });
        Thread.sleep(1000);
        s.unsubscribe();
    }
```

Output:

<pre>
1
2
3
4
onCompleted
</pre>

I think `unsubscribe` should not call `onCompleted`.
 =||= Here is the case in Rx.Net:

``` c#
            var o = Observable.Interval(TimeSpan.FromMilliseconds(200));
            var s = o.Subscribe(
                i => Console.WriteLine("Interesting: Infinity = " + i),
                e =>  Console.WriteLine(e),
                () => Console.WriteLine("onCompleted")
                );
            Thread.Sleep(1000);
            s.Dispose();
            Console.WriteLine("Press any key...");
            Console.ReadKey();
```

Output is:

<pre>
Interesting: Infinity = 0
Interesting: Infinity = 1
Interesting: Infinity = 2
Interesting: Infinity = 3
Press any key...
</pre>
 =||= Fixed in https://github.com/Netflix/RxJava/pull/522
 =||= ,0
533,95,Operator: ToAsync,http://msdn.microsoft.com/en-us/library/hh229868(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229868(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229439(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229657(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229182(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229822(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211792(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229926(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212074(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211936(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229008(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229118(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244256(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229059(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229035(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212109(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229744(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229896(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229778(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229594(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229553(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211729(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229827(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211718(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212154(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228950(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211879(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228973(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211608(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211987(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229292(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244314(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229728(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229729(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229369(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229080(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229471(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211875(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229755(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229722(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229731(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229336(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229851(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211787(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229327(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229769(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229450(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229370(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229287(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229577(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229911(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212149(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229560(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211773(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229571(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212138(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229606(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211812(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229716(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229808(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229630(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228993(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229773(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229361(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229794(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211702(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229910(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229662(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228956(v=vs.103).aspx,API surface: This method in Rx.NET has about 48 overloads, do we need all of them (0-11 arg Action, 0-11 arg Funcion, x2 with scheduler overloads)?

Schedulers: In Rx.NET the scheduler-less overloads use the SchedulerDefaults.AsyncConversions which in turn is a DefaultScheduler. So do we use the Schedulers.threadPoolForComputation() directly or introduce a Schedulers.threadPoolForAsyncConversions()?
 =||= ,0
541,79,Operator: SkipUntil,http://msdn.microsoft.com/en-us/library/hh229358(v=vs.103).aspx,nan,0
560,532,doOnEach variance,Just to make sure we don't forget about this one: `doOnEach` & friends still need `? extends T` / `? super T`.,This is completed along with a refactoring to having `doOnEach`, `doOnNext`, `doOnCompleted` and `doOnError`.
 =||= ,0
563,52,Operator: GroupByUntil,http://msdn.microsoft.com/en-us/library/hh211932(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229872(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229433(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229392(v=vs.103).aspx,groupByUntil is implemented. If we need/want other overloads they can come via new issues.
 =||= ,0
565,53,Operator: GroupJoin,http://msdn.microsoft.com/en-us/library/hh244235(v=vs.103).aspx,Implemented.
 =||= ,0
571,74,Operator: Sample,http://msdn.microsoft.com/en-us/library/hh211615(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211892(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229742(v=vs.103).aspx,Still have one overload to do:

``` c#
public static IObservable<TSource> Sample<TSource, TSample>(
    this IObservable<TSource> source,
    IObservable<TSample> sampler
)
```
 =||= I can take this.
 =||= Done.
 =||= ,0
572,551,observeOn and multiple subscribers,Snippet 1:

``` scala
val o = Observable(1, 2, 3)
println("x0")
o.observeOn(Schedulers.threadPoolForComputation).subscribe(x=>println("a: " + x), t=>println(t), ()=>{println("a: done")})
println("x1")
o.observeOn(Schedulers.threadPoolForComputation).subscribe(x=>println("b: " + x), t=>println(t), ()=>{println("b: done")})
println("x2")
Thread.sleep(6000)
println("x3")
```

outputs, as expected, this:

```
x0
a: 1
a: 2
a: 3
a: done
x1
x2
b: 1
b: 2
b: 3
b: done
x3
```

Snippet 2:

``` scala
val o = Observable(1, 2, 3).observeOn(Schedulers.threadPoolForComputation)
println("x0")
o.subscribe(x=>println("a: " + x), t=>println(t), ()=>{println("a: done")})
println("x1")
o.subscribe(x=>println("b: " + x), t=>println(t), ()=>{println("b: done")})
println("x2")
Thread.sleep(6000)
println("x3")
```

sometimes outputs the same as snippet 1, but sometimes only outputs this:

```
x0
a: 1
a: 2
a: 3
x1
a: done
x2
x3
```

or this

```
x0
x1
a: 1
a: 2
x2
a: 3
a: done
x3
```

(order between x and a doesn't matter, but the problem is that there are no lines with b).

Snippet 3 (= snippet 2 translated to C#)

``` cs
var o = new[] { 1, 2, 3 }.ToObservable().ObserveOn(TaskPoolScheduler.Default);
Console.WriteLine("x0");
o.Subscribe(x => Console.WriteLine("a: " + x), t => Console.WriteLine(t), () => Console.WriteLine("a: done"));
Console.WriteLine("x1");
o.Subscribe(x => Console.WriteLine("b: " + x), t => Console.WriteLine(t), () => Console.WriteLine("b: done"));
Console.WriteLine("x2");
Thread.Sleep(6000);
Console.WriteLine("x3");
Console.ReadKey();
```

always prints something like

```
x0
x1
x2
b: 1
b: 2
b: 3
b: done
a: 1
a: 2
a: 3
a: done
x3
```

(order between a and b doesn't matter, but there are always lines with b)

So I guess that somehow `observeOn` does not properly support multiple subscribers, but I couldn't find any clue in the source supporting this claim. Would be nice if somehow could take look.,What I see is that ObserveOn uses a "global" queue. I'd rather move the queue inside the onSubscribe() method, so you have one queue per observer and no interference and perhaps parallel observations of independent observers (they don't get into each others queue).

One more thing. It appears the notifications only add to the "s" CompositeSubscription but never remove an item once done, which is a potential memory leak IMO.
 =||= Good catch. 
 =||= ,0
573,540,Purpose of rx.util.Opening and rx.util.Closing interfaces?,Is there a particular reason these two interfaces are used by the various buffer() and window() operators instead of allowing arbitrary generic types for opening and closing buffers/windows similar to the duration selectors in join() & groupByUntil()?,I think they are historical artifacts, less types == better IMHO.

On Thu, Nov 28, 2013 at 2:47 PM, akarnokd notifications@github.com wrote:

> Is there a particular reason these two interfaces are used by the various
> buffer() and window() operators instead of allowing arbitrary generic types
> for opening and closing buffers/windows similar to the duration selectors
> in join() & groupByUntil()?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/540
> .
 =||= On a related issue, we should move ObserverBase from rx.joins to rx right next to the Observer interface. Nobody should directly implement Observer. ObserverBase ensure that the Rx contract is enforced.

It is a bit ugly that you need to override XXXCore, so we should also add Observer.create or a constructor with overloads that take funcs, as well as one that takes an Observer itself (which can be unsafe).

You want to take this?

See

http://msdn.microsoft.com/en-us/library/hh211985(v=vs.103).aspx.
https://github.com/mono/rx/blob/master/Rx/NET/Source/System.Reactive.Core/Reactive/ObserverBase.cs (did I say already that the MSDN docs suck!)
 =||= @headinthebox Sure I would do the refactorings, but I think ObserverBase should be placed under rx.operators similar to the SafeObserver and SynchronizedObserver classes.
 =||= Probably yes, and there is a lot of duplication between all of these various observers, so you may want to have a look at that as well.
 =||= If its job is to ensure the contract is kept then that is what SafeObserver does. 
 =||= > but I think ObserverBase should be placed under rx.operators similar to the SafeObserver and SynchronizedObserver classes.

Yes, we have kept the rx package to only the most top-level things, so I agree this should be elsewhere. However, thus far the rx.operators package is not considered part of the public API and is excluded from Javadocs. If we are to have public Observers then it would be an rx.observers package like rx.observables. The rx.operators package is internal implementations and can be changed without breaking users. 
 =||= I did the refactorings but couldn't get the Observable.scala working with it: https://github.com/akarnokd/RxJava/commit/7f3628667ef4d5aa066fa9441b8b6d66f81f0b10

Could someone help with that part?

```
RxJava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\Observable.scala:307: error: type mismatch;
   found   : rx.lang.scala.Observable[Closing]
   required: rx.util.functions.Func0[_ <: rx.Observable[Closing]]
      val f: Func0[_ <: rx.Observable[Closing]] = closings().asJavaObservable
                                                                              ^
  RxJava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\Observable.scala:332: error: type mismatch;
   found   : Opening => rx.Observable[_ <: Closing]
   required: rx.util.functions.Func1[Opening, _ <: rx.Observable[Closing]]
      val closing: Func1[Opening, _ <: rx.Observable[Closing]] = (o: Opening) => closings(o).asJavaObservable
                                                                              ^
  RxJava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\Observable.scala:333: error: type mismatch;
   found   : rx.Observable[_$15] where type _$15 <: Opening
   required: rx.Observable[Opening]
  Note: _$15 <: Opening, but Java-defined class Observable is invariant in type T.
  You may wish to investigate a wildcard type such as `_ <: Opening`. (SLS 3.2.10)
      val jObs: rx.Observable[_ <: java.util.List[_]] = asJavaObservable.buffer[Opening, Closing](opening, closing)
                                                                                                  ^
  RxJava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\Observable.scala:545: error: overloaded method window needs result type
        asJavaObservable.window(openings.asJavaObservable, (op: Opening) => closings(op).asJavaObservable))
                               ^
  RxJava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\Observable.scala:519: error: overloaded method value window with alternatives:
    (x$1: Int)rx.Observable[rx.Observable[_$1]] <and>
    [TClosing](x$1: rx.util.functions.Func0[_ <: rx.Observable[TClosing]])rx.Observable[rx.Observable[_$1]]
   cannot be applied to (rx.util.functions.Func0[_$44])
      val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window(func)
```
 =||= Observable is covariant in its type parameter. In Scala, when you use a Scala type, scalac knows this automatically, because it's declared where the type is declared (using `trait Observable[+T]`, `+` means covariant, `-` means contravariant). So `rx.lang.scala.Observable[T]` actually means "an `rx.lang.scala.Observable` whose type parameter is `T` or any subclass of `T`. However, if you use a Java type, there's no `+` or `-` at declaration site, so **whenever** you use `rx.Observable` in Scala, you have to write `rx.Observable[_ <: T]`. **Never** write `rx.Observable[T]`.
 =||= ,0
575,76,Operator: SequenceEqual,http://msdn.microsoft.com/en-us/library/hh229024(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212108(v=vs.103).aspx,Looking at these implementations it seems that by using zip it will emit a sequence of true/false values rather than a single boolean specifying if the entire sequence is true/false.

I think it is supposed to emit only a single value based on reading the MSDN docs.

@mairbek If you re-read the docs, is it supposed to be a single value, or sequence of values emitted? If single, can you submit a fix? Probably a reduce type function that keeps going until it finds a false otherwise if it hits onComplete/onError the same on both sides it returns true. 
 =||= @benjchristensen okay, I'll submit the patch.
 =||= Reduce doesn't seems to be a good choice in this case since it would wait for all pairs of events, even if first two were different.

I will start by implementing All Operation #21 and applying it to a `zip` of two observables.
 =||= Okay, thanks.
 =||= This happens to be more complicated that I've expected.

I've come up with a test case that fails on `all` + `zip` implementation. Looks like `zip` operation completes the observation as fast as first observable completes which leads to wrong behaviour of `sequenceEqual` operation.

``` java

        @Test
        public void testSequenceEqual3() {
            Observable<Integer> first = Observable.toObservable(1, 2);
            Observable<Integer> second = Observable.toObservable(1, 2, 3);
            @SuppressWarnings("unchecked")
            Observer<Boolean> result = mock(Observer.class);
            sequenceEqual(first, second).subscribe(result);
            verify(result, times(1)).onNext(false);
            verify(result, times(1)).onCompleted();
            verifyNoMoreInteractions(result);
        }

```
 =||= Done.
 =||= ,0
575,564,Different behaviors of `SequenceEqual` in Rx.Net and RxJava,Looks `SequenceEqual` in Rxjava is not correct. 

In Rx.Net, `SequenceEqual` returns an Observable which only has one element indicating if these two sequences are same. For example,

``` c#
            var o = Observable.SequenceEqual(Observable.Range(1, 100), Observable.Range(1, 100));
            var s = o.Subscribe(
                v => Console.WriteLine("Equal = " + v),
                e =>  Console.WriteLine(e),
                () => Console.WriteLine("onCompleted")
                );
            Console.WriteLine("Press any key...");
            Console.ReadKey();
```

Outputs:

<pre>
Equal = True
onCompleted
Press any key...
</pre>


But in RxJava, the following codes:

``` java
        Observable
                .sequenceEqual(Observable.range(1, 100),
                        Observable.range(1, 100)).toBlockingObservable()
                .forEach(new Action1<Boolean>() {
                    @Override
                    public void call(Boolean t1) {
                        System.out.println(t1);
                    }
                });
```

Output 100 `true`s.,I've noticed that using `zip` to pair up values is not the same behavior as in Rx.NET. In Rx.NET, the operator checks if the length of the streams are the same or not. Even if we don't want to do that, one could add a simple `all` operator after the zip:

``` java
public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, 
        Observable<? extends T> second, Func2<? super T, ? super T, Boolean> equality) {
    return zip(first, second, equality).all(Functions.<Boolean>identity());
}
```

Using the materialized view is not an option as errors need to be propagated directly and not compared (and generally, equals doesn't work on Throwables).
 =||= I can take this this weekend.
 =||= fixed in #575
 =||= ,0
586,552,concat + concurrency + multiple subscribers,This C# snippet

``` cs
var o = Observable.Concat(
    Observable.Interval(TimeSpan.FromMilliseconds(500)).Take(2),
    Observable.Interval(TimeSpan.FromMilliseconds(500)).Take(2)
);
o.Subscribe(x => Console.WriteLine("a: " + x), t => Console.WriteLine(t), () => Console.WriteLine("a: done"));
o.Subscribe(x => Console.WriteLine("b: " + x), t => Console.WriteLine(t), () => Console.WriteLine("b: done"));
Console.WriteLine("all subscribed");
Thread.Sleep(5000);
```

outputs, as expected, this:

```
all subscribed
b: 0
a: 0
b: 1
a: 1
a: 0
b: 0
a: 1
a: done
b: 1
b: done
```

The same translated to Java:

``` java
Action1<Long> printNext(final String who) {
    return new Action1<Long>() {
        public void call(Long o) {
            System.out.println(who + o);
        }
    };
}
Action1<Throwable> printErr(final String who) {
    return new Action1<Throwable>() {
        public void call(Throwable o) {
            System.out.println(who + o);
        }
    };
}
Action0 printComplete(final String who) {
    return new Action0() {
        public void call() {
            System.out.println(who + "done");
        }
    };
}
@Test public void testConcat2() throws Exception {
    Observable<Long> o = Observable.concat(
        Observable.interval(500, TimeUnit.MILLISECONDS).take(2),
        Observable.interval(500, TimeUnit.MILLISECONDS).take(2)
    );        
    o.subscribe(printNext("a: "), printErr("a: "), printComplete("a: "));
    o.subscribe(printNext("b: "), printErr("b: "), printComplete("b: "));
    System.out.println("all subscribed");
    Thread.sleep(5000);
}
```

only outputs this:

```
all subscribed
a: 0
a: 1
a: 0
a: 1
a: done
```

If I replace the `Observable.interval` by an `Observable.from`, the problem disappears, so I think the problem only shows up if we have concat + concurrency + multiple subscribers.,The issue is in the Concat operation sharing its innerSubscription among observers. I'm about to fix that.
 =||= Fixed in #586
 =||= ,0
587,60,Operator: LongCount,http://msdn.microsoft.com/en-us/library/hh229120(v=vs.103).aspx

Do we really need Count and LongCount?

Perhaps Count should just use a long so we only need one of them?,nan,0
593,592,SerialSubscription and SingleAssignementSubscription naming, Subscriptions in general,SerialSubscription has

private static final Subscription UNSUBSCRIBED = new Subscription() {

SingleAssignmentSubscription has

private static final Subscription SENTINEL = new Subscription() {

for the same purpose.

Also, these use lockfree implementations, the other subscriptions use locks.

Perhaps someone can go over all subscriptions and implement them in the same style and using the same naming conventions.,I have to rebase my Subscription changes anyway, so I'll do the renaming to UNSUBSCRIBED_SENTINEL.
 =||= I may help again to use lock free strategy in other subscription implementations.
 =||= @akarnod 

You should be able to have serialsubscription inherit from multipleassignmentsubscription. The difference is that the latter unsubscribes when swapping in a new subscription. I think that would show the intent better and make the code more maintanable.

In fact, I think MultipleAssignmentSubscription itself can inherit from BooleanSubscription.
 =||= I don't know. I can create many PRs for all kinds of variants, but at the end @benjchristensen has to decide; I'd rather avoid look-and-feel development.
 =||= ,0
593,577,Deadlock in 0.15.x between MultipleAssignmentSubscription and CompositeSubscription,Here's the relevant thread dump:

"RxComputationThreadPool-8":
    at rx.subscriptions.CompositeSubscription.unsubscribe(CompositeSubscription.java:100)
    - waiting to lock <0x00007f2a2846be00> (a rx.subscriptions.CompositeSubscription)
    at rx.subscriptions.MultipleAssignmentSubscription.unsubscribe(MultipleAssignmentSubscription.java:43)
    - locked <0x00007f2a26de2a80> (a rx.subscriptions.MultipleAssignmentSubscription)
    at rx.subscriptions.CompositeSubscription.add(CompositeSubscription.java:92)
    - locked <0x00007f2a2846be60> (a rx.subscriptions.CompositeSubscription)
    at rx.concurrency.ExecutorScheduler$4.run(ExecutorScheduler.java:128)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)
    at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)
    at java.util.concurrent.FutureTask.run(FutureTask.java:166)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:724)
"RxComputationThreadPool-7":
    at rx.subscriptions.MultipleAssignmentSubscription.unsubscribe(MultipleAssignmentSubscription.java:40)
    - waiting to lock <0x00007f2a26de2a80> (a rx.subscriptions.MultipleAssignmentSubscription)
    at rx.subscriptions.CompositeSubscription.add(CompositeSubscription.java:92)
    - locked <0x00007f2a2846be00> (a rx.subscriptions.CompositeSubscription)
    at rx.concurrency.ExecutorScheduler$4.run(ExecutorScheduler.java:128)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)
    at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)
    at java.util.concurrent.FutureTask.run(FutureTask.java:166)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292),In English:

2 CompositeSubscriptions (denoted using last 2 letters of memory address): 00 and 60
1 MultipleAssignmentSubscription : 80

Thread 7:
Composite-00.add
MultipleAssignment-80.unsubscribe

Thread 8:
Composite-60.add
MultipleAssignment-80.unsubscribe
Composite-00.unsubscribe

So I believe there are 2 bugs here - a circular reference between subscriptions and a deadlock when unsubscribes happen on circular subscriptions
 =||= Also, based on our codebase, rolling back to 0.14.10 did not exhibit the problem (yet).  We also believe that the Scheduler.schedule(Action1) method is the one creating the MultipleAssignmentSubscription (The only other places are OperationRetry and OperationSwitch).
 =||= Generally, unsubscribing should not happen while holding locks, especially inside these subscription instances. I'll take a look at them.
 =||= Thanks for the really quick work, @akarnokd.  Once we've got the next release of RxJava into our codebase, we'll let you know if the issue is resolved.  
 =||= Should be fixed in https://github.com/Netflix/RxJava/pull/593
 =||= ,0
593,590,SerialSubscription is missing isUnsubscribed,public class SerialSubscription implements Subscription {
    @Override
    public void unsubscribe() {...}}
    public void setSubscription(final Subscription subscription) {...}  
    public Subscription getSubscription() {...}
}

http://msdn.microsoft.com/en-us/library/system.reactive.disposables.serialdisposable_properties(v=vs.103).aspx,Fixed in https://github.com/Netflix/RxJava/pull/593
 =||= ,0
594,81,Operator: Start,http://msdn.microsoft.com/en-us/library/hh229265(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211971(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229036(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211721(v=vs.103).aspx,It would be nice to have the `start` operator not only for `Action0`, but also for `Func0`. With this, we could use the Java Observable to simulate Futures:

``` java
Observable<Integer> future = Observable.start(new Func0<Integer>() {
    public Integer call() {
        return someExpensiveCalculation();
    }
}, Schedulers.threadPoolForComputation());
```
 =||= Implemented and then moved to async-util contrib module: https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-async-util/
 =||= ,0
612,71,Operator: Replay,http://msdn.microsoft.com/en-us/library/hh229288(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211976(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211699(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229232(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229814(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229874(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211811(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211759(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229653(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211675(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211644(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229526(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229928(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228952(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244327(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229404(v=vs.103).aspx,Good intro here: http://northhorizon.net/2011/sharing-in-rx/
 =||= We only have the single `replay` method implemented. Missing all of the overloads.
 =||= I'll take these.
 =||= Done.
 =||= ,0
616,613,CombineLatest incorrect?,I've looked into the `OperationCombineLatest` implementation and I think it is incorrectly implemented:
- Doesn't seem to allow multiple observers on the same combiner as the Aggregator is per source observable and not per subscribing observer.
- I think the contract requires that no onNext value is lost on any of the source observers yet since they are not synchronized with each other, a source observer might overwrite its current value while the collection is running in `Aggregator.next()`.

Thoughts?

Edit: I was wrong with case 2; if one is faster than the others, that is not a problem.,Fixed in https://github.com/Netflix/RxJava/pull/708
 =||= ,0
626,59,Operator: Latest,http://msdn.microsoft.com/en-us/library/hh212115(v=vs.103).aspx,Is `Latest` same as `Next` #66? I read http://rx.codeplex.com/SourceControl/latest#Rx.NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/Latest.cs and http://rx.codeplex.com/SourceControl/latest#Rx.NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/Next.cs in Rx.Net. But I can't find the difference.
 =||= I believe latest can return a value from the past but falls back the next value if one hasn't been received yet.
 =||= > I believe latest can return a value from the past but falls back the next value if one hasn't been received yet.

@abersnaze , Do you mean if the next value hasn't arrived, the latest will return the old cached value?

But there are the following codes in the TryMoveNext method of Latest.

``` c#
            public override bool TryMoveNext(out TSource current)
            {
                var kind = default(NotificationKind);
                var value = default(TSource);
                var error = default(Exception);

#if !NO_CDS
                _semaphore.Wait();
#else
                _semaphore.WaitOne();
#endif

```

So when `TryMoveNext` is called, it will block the thread and wait for the incoming value.

I tried the following codes in Rx.Next:

``` c#
            IObservable<int> ob =
                    Observable.Create<int>(o =>
                    {
                        Console.WriteLine("Subscribed: Before onNext");
                        o.OnNext(1);
                        Thread.Sleep(2000);
                        o.OnNext(2);
                        Console.WriteLine("Subscribed: After OnNext");
                        o.OnCompleted();
                        return Disposable.Empty;
                    }
                    );
            var iter = ob.SubscribeOn(Scheduler.NewThread).Latest().GetEnumerator();
            Console.WriteLine("Before MoveNext");
            while (iter.MoveNext())
            {
                Console.WriteLine("Find a value");
                Console.WriteLine("Got " + iter.Current);
            }
            Console.WriteLine("After MoveNext");
```

The output is:

<pre>
Before MoveNext
Subscribed: Before onNext
Find a value
Got 1
Subscribed: After OnNext
Find a value
Got 2
After MoveNext
</pre>
 =||= I did some tests on Rx.Net about `Latest` and `Next`.

I draw two Marble diagrams to summary the differences between `Latest` and `Next`.
- Latest

![latest](https://f.cloud.github.com/assets/1000778/1721588/2d63aadc-6228-11e3-8060-043cced5720e.png)

For `Latest`, the `next` of `Iterator` will check if there is a cached value, if so, returns the cached value, and deleted the cached value. If there is not a cached value, it will blocks until the next value is emitted from the Observable, and returns it.
- Next

![next](https://f.cloud.github.com/assets/1000778/1721592/3daf6160-6228-11e3-9580-4e135e106dc2.png)

For `Next`, the `next` method of `Iterator` always blocks until the next value is emitted from the Observable, and returns it.

Please let me know if you find any mistake.
 =||= So `next` will return every value emitted by source whereas `latest` only those which were observed just before the `hasNext()` call and only once?

Looking at `OperationNext`, I find it strange to have the `waiting` atomic boolean in L132, checked in L147 and set in L162. It appears if there is no one is using `takeNext()` the onNext skips an onNext-notification. L152 quotes some race condition which I don't really see as the observer ignores onError and onCompleted, and the materialized source should be race-free anyway.
 =||= Sorry that the next diagram is not clear. Here is a more clear diagram:
![next1](https://f.cloud.github.com/assets/1000778/1751622/04725f9e-65f5-11e3-818a-fcf1f86ff01a.png)

So for the `next` operator, items will be ignored if they are emitted between two `next` calls.
 =||= However, as the `Iterator` has two methods: `hasNext` and `next`. it's more complicated. Check the document here: https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#next and the discussion here: https://github.com/Netflix/RxJava/pull/433
 =||= @zsxwing Are you going to implement this? 

In addition, I've looked at the OperationMostRecent, and if I understand it correctly, it shares a single subscription to the source observable, i.e, if I try to iterate the same source twice, it won't work the second time:

``` java
BlockingObservable<Long> source = Observable.interval(100, TimeUnit.MILLISECONDS)
.take(10).toBlockingObservable();

Iterable<Long> it = source.mostRecent(-1L);

for (Long l : it) {
   System.out.println(l);
   Thread.sleep(50);
}

System.out.println("----------------------------------------");

for (Long l : it) {
    System.out.println(l);
    Thread.sleep(50);
}
```

Same goes for `OperationNext.next`.

I can fix both mostRecent and next and take latest.
 =||= You're right. The `subscribe` action should be created in the `Iterator` rather than the `Iterable`. As I'm busy at other work now, it would be appreciated if you can fix this issue and the `latest` operator.
 =||= I'm on it. Thanks.
 =||= Implemented.
 =||= ,0
633,595,NullPointerException in the 'toList' operator,The following code will throw a NullPointerException.

``` java
Observable.from((String) null).toList().toBlockingObservable().single();
```

<pre>

Exception in thread "main" java.lang.NullPointerException
at java.util.concurrent.ConcurrentLinkedQueue.checkNotNull(ConcurrentLinkedQueue.java:807)
at java.util.concurrent.ConcurrentLinkedQueue.offer(ConcurrentLinkedQueue.java:326)
at java.util.concurrent.ConcurrentLinkedQueue.add(ConcurrentLinkedQueue.java:296)
at rx.operators.OperationToObservableList$ToObservableList$1.onNext(OperationToObservableList.java:62)
at rx.operators.OperationToObservableIterable$ToObservableIterable.onSubscribe(OperationToObservableIterable.java:46)
at rx.Observable.subscribe(Observable.java:236)
at rx.operators.OperationToObservableList$ToObservableList.onSubscribe(OperationToObservableList.java:57)
at rx.Observable.subscribe(Observable.java:236)
at rx.operators.OperationMaterialize$MaterializeObservable.onSubscribe(OperationMaterialize.java:57)
at rx.Observable.subscribe(Observable.java:236)
at rx.operators.OperationToIterator.toIterator(OperationToIterator.java:47)
at rx.observables.BlockingObservable.getIterator(BlockingObservable.java:172)
at rx.observables.BlockingObservable$2.iterator(BlockingObservable.java:353)
at rx.observables.BlockingObservable._singleOrDefault(BlockingObservable.java:66)
at rx.observables.BlockingObservable.single(BlockingObservable.java:278)
at rx.Test.main(Test.java:25)
</pre>


The cause is `rx.operators.OperationToObservableList` https://github.com/Netflix/RxJava/blob/069ae42843822b846d450b38a4aa5039182e121f/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java#L58 uses `ConcurrentLinkedQueue` to cache the values but `ConcurrentLinkedQueue` rejects null value.

Is `ArrayList` or `LinkedList` enough here?,The comment says below that onNext is expected to run concurrently. The solution would be to use a null sentinel:

``` java
final ConcurrentLinkedQueue<Object> list = new ConcurrentLinkedQueue<Object>();
final Object NULL_SENTINEL = new Object();
public void onNext(T value) {
    // onNext can be concurrently executed so list must be thread-safe
    list.add(value != null ? value : NULL_SENTINEL);
}

public void onError(Throwable ex) {
    observer.onError(ex);
}

public void onCompleted() {
    try {
        // copy from LinkedQueue to List since ConcurrentLinkedQueue does not implement the List interface
        ArrayList<T> l = new ArrayList<T>(list.size());
        for (T t : list) {
            @SuppressWarnings("unchecked") T t0 = t != NULL_SENTINEL ? (T)t : (T)null;
            l.add(t0);
        }

        // benjchristensen => I want to make this list immutable but some clients are sorting this
        // instead of using toSortedList() and this change breaks them until we migrate their code.
        // observer.onNext(Collections.unmodifiableList(l));
        observer.onNext(l);
        observer.onCompleted();
    } catch (Throwable e) {
        onError(e);
    }
}
```
 =||= According to Rx contract, toList does not need to handle concurrency, doesn't it?
 =||= Closed as it's fixed in #633 
 =||= ,0
635,634,More operators in Rx.Net, I extracted the method names from RxJava and Rx.Net and compared them. I find some operators in Rx.Net(version 2.0.20823.0) do not appear in the MSDN. Do we need to implement them before 1.0? Here is the list:
- [x]  any (exist, isEmpty)
- [x]  **asobservable** (#641)
- [x]  **case** (#635)
- [ ]  ~~catch~~ (onErrorResumeNext is what we use, this was for F# computation expressions)
- [x]  **chunkify** (#636)
- [x]  **collect** (#636)
- [ ]  ~~deferasync~~ (not applicable as we don't have `Task` or async/await)
- [x]  **delaysubscription** (#638)
- [x]  do (doOnEach)
- [x]  **dowhile** (#635)
- [x]  finally (finallyDo)
- [x]  **firstasync** (#520)
- [x]  **firstordefaultasync** (firstOrDefault)
- [x]  **for** (#636)
- [x]  foreach (BlockingObservable.forEach)
- [ ]  ~~foreachasync~~ (BlockingObservable.forEach since we don't  have `Task` or async/await)
- [ ]  ~~fromasync~~ (from with Schedulers does this)
- [x]  ~~fromasyncpattern~~ (won't implement)
- [x]  ~~fromevent~~ (won't implement)
- [x]  ~~fromeventpattern~~ (won't implement)
- [x]  **generate** (#519)
- [x]  ~~getenumerator~~ (won't implement)
- [x]  **if** (#635)
- [x]  lastasync (last)
- [x]  lastordefault (BlockingObservable.lastOrDefault)
- [x]  **lastordefaultasync** (#520)
- [x]  **latest** (#626)
- [x]  mostrecent (BlockingObservable.mostRecent)
- [x]  next (BlockingObservable.next)
- [x]  refcount (ConnectableObservable.refCount)
- [x]  **repeat** (#518)
- [x]  return (from, just)
- [x]  select (map)
- [x]  selectmany (flatMap)
- [x]  single (BlockingObservable.single)
- [x]  **singleasync** (#520)
- [x]  singleordefault (BlockingObservable.singleOrDefault)
- [x]  **singleordefaultasync** (#520)
- [ ]  ~~startasync~~
- [x]  switch (switchOnNext)
- [x]  **takelastbuffer** (#638)
- [x]  throttle (debounce)
- [x]  throw (error)
- [x]  toarray (unnecessary)
- [x]  toasync (Async.toAsync)
- [x]  todictionary (toMap)
- [x]  toenumerable (BlockingObservable.toIterable)
- [x]  ~~toevent~~ (won't implement)
- [x]  ~~toeventpattern~~ (won't implement)
- [x]  tolookup (toMultimap)
- [x]  toobservable (from)
- [ ]  ~~wait~~ (BlockingObservable.last())
- [x]  **while** (#635)

**strong** means someone is working on it.
~~strikethrough~~ means it won't be implememted.,Nice list.

Catch -> onErrorResumeNext (?)
FromAsyncPattern: won't implement (#46)
Generate -> PR available (#519) still debating on return type
LastOrDefault -> BO.lastOrDefault (?)
MostRecent -> BO.mostRecent
Repeat -> PR available (#518)
StartAsync -> start  (?)
Switch -> switchOnNext (?)
Throttle -> debounce

I don't recognize the rest.
 =||= Updated.

StartAsync is not the `start` operator:

```
    //
    // Summary:
    //     Invokes the asynchronous function, surfacing the result through an observable
    //     sequence.  The CancellationToken is shared by all subscriptions on the resulting
    //     observable sequence. See the remarks section for more information.
    //
    // Parameters:
    //   functionAsync:
    //     Asynchronous function to run.
    //
    // Type parameters:
    //   TResult:
    //     The type of the result returned by the asynchronous function.
    //
    // Returns:
    //     An observable sequence exposing the function's result value, or an exception.
    //
    // Exceptions:
    //   System.ArgumentNullException:
    //     functionAsync is null.
    //
    // Remarks:
    //      The function is started immediately, not during the subscription of the
    //     resulting sequence.  Multiple subscriptions to the resulting sequence can
    //     observe the function's result.  If any subscription to the resulting sequence
    //     is disposed, the CancellationToken is set. The observer associated to the
    //     disposed subscription won't see the TaskCanceledException, but other observers
    //     will. You can protect against this using the Catch operator.  Be careful
    //     when handing out the resulting sequence because of this behavior. The most
    //     common use is to have a single subscription to the resulting sequence, which
    //     controls the CancellationToken state. Alternatively, you can control subscription
    //     behavior using multicast operators.
    public static IObservable<TResult> StartAsync<TResult>(Func<CancellationToken, Task<TResult>> functionAsync);
```
 =||= Here is what's missing and what they generally do:
- [x] **AsObservable**: "Hides the identity of an observable sequence."
- [x] **Case**: "Uses a selector to determine which source to return", i.e., in onSubscribe, a Func0 selector is called and an Observable looked up in a map, then subscribed to it.
- [x] **Chunkify**: "Produces an enumerable sequence of consecutive (possibly empty) chunks of the source sequence.", i.e., implemented as `source.collect(() -> new ArrayList, (lst, x) -> {lst.add(x); return lst;}, u -> new ArrayList)`.
- [x] **Collect**: "Produces an enumerable sequence that returns elements collected/aggregated from the source sequence between consecutive iterations.". For example, you start out with an empty list, and each onNext adds to the list. Once the `iterator.next()` takes the current list, it is replaced by a fresh list. Depending on the frequency of `next()` you might get lists with various sizes.
- [x] **DeferAsync**: "Returns an observable sequence that starts the specified asynchronous factory function whenever a new observer subscribes." Implemented as Defer(() -> StartAsync(factory).Merge()) where factory is a `Func0<Task<IObservable<TValue>>>`.
- [x] **DelaySubscription**: "Time shifts the observable sequence by delaying the subscription with the specified relative time duration.". Does not timeshift the unsubscribe.
- [x] **DoWhile**: "Repeats the given source as long as the specified condition holds, where the condition is evaluated after each repeated source completed.". I.e., repeat only if condition holds: `do { subscribe & run } while (condition)`
- [x] **For**: "Concatenates the observable sequences obtained by running the resultSelector for each element in the given enumerable source.". The difference from a plain concat is that the source iterable is consumed on demand rather than all at once.
- [x] **ForEachAsync**: "Invokes an action for each element in the observable sequence, and returns a Task object that will get signaled when the sequence terminates.", like making a whole sequence of observations into a big Future. Dual of fromFuture & toAsync in some sense.
- [x] **FromAsync**: "Converts to asynchronous function into an observable sequence. Each subscription to the resulting sequence causes the function to be started. The CancellationToken passed to the asynchronous function is tied to the observable sequence's subscription that triggered the function's invocation and can be used for best-effort cancellation.". Implemented as `Defer(() -> StartAsync(functionAsync))` where functionAsync is `Func<Task<TResult>>` or `Func<CancellationToken, Task<TResult>>`.
- [x] **If**: "If the specified condition evaluates true, select the thenSource sequence. Otherwise, select the elseSource sequence.". Condition is evaluated on subscription.
- [x] **GroupBy** with capacity overloads (v2.2)
- [x] **GroupByUntil** with capacity overloads (v2.2)
- [x] **SingleAsync**: "Returns the only element of an observable sequence, and reports an exception if there is not exactly one element in the observable sequence." Returns an observable with a single element or exception.
- [x] **SingleOrDefaultAsync**: "Returns the only element of an observable sequence, or a default value if the observable sequence is empty; this method reports an exception if there is more than one element in the observable sequence."
- [x] **StartAsync**: see [comment](https://github.com/Netflix/RxJava/issues/634#issuecomment-30827770) above.
- [x] **TakeLast** overload with time window (i.e., return the last 2 seconds worth of source values once it finishes).
- [x] **TakeLastBuffer**: "Returns a list with the specified number of contiguous elements from the end of an observable sequence." Has time based overloads. Almost like takeLast but emits a single list of elements. 
- [x] **Wait**: "Waits for the observable sequence to complete and returns the last element of the sequence. If the sequence terminates with an OnError notification, the exception is throw." Returns T. Looks like a `source.takeLast(1).toBlockingObservable().single()`.
- [x] **While**: "Repeats the given source as long as the specified condition holds, where the condition is evaluated before each repeated source is subscribed to." I.e., `while(condition) { subscribe }`.
 =||= @zsxwing or anyone else; do you want to do some of these? I'll do them in batches do I don't have to rebase and restart from master all the time. I'll start with `DoWhile`, `While`, `If`, `Case`.
 =||= Continuing with `Chunkify`, `Collect`, `Wait` and `For`.

Update: Wait is practically BO.last(). Since we don't usually do aliases, I'll skip Wait.
 =||= Next: `DeferSubscription`, `TakeLast`, `TakeLastBuffer`.
 =||= I can add SingleAsync and SingleOrDefaultAsync in PR #520 directly.
 =||= Do we really need DeferAsync, ForEachAsync, FromAsync, StartAsync? We have no CancellationToken in Java.
 =||= It appears to me that CancellationToken is used for cancelling tasks, basically a similar way you would use FutureTask and check its isCancelled(), but since these tokens come from the outside, you can signal cancellations to multiple tasks at once. Since we have the `Subscription` infrastructure for that, I'd vote for not implementing those variants.
 =||= Doing `AsObservable`, `GroupBy` and `GroupByUntil` variants.
 =||= Anyone want to implement all the TestSchedulers?

(CancellationToken is really only useful when you have async await).
 =||= A can take those as well, unless someone else beats me to it while I do the ops mentioned above.
 =||= Doing lastasync and lastordefaultasync
 =||= @headinthebox what features do you miss from the current `TestScheduler`? I'm looking at Rx.NET sources of VirtualScheduler, TestScheduler and HistoricalScheduler, but it is not apparent to me what the functional requirements are.

Never mind, I'll start doing it. Btw, I'm starting to require the enhancements of my PRs to avoid feature duplication...
 =||= These are done:

Switch -> switchOnNext (?)
Throttle -> debounce

The "async" ones don't use the async suffix in RxJava since the non-async ones are on `BlockingObservable` instead. Thus some of those in the list are already implemented just without the async suffix.
 =||= @zsxwing How is the `lastasync` operator you say you're doing different than `last` (https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L5740) that is already implemented? It is non-blocking.

We have `last` and `takeLast`.

```
last() 
          Returns an Observable that emits the last item emitted by the source or an IllegalArgumentException if the source Observable is empty.

takeLast(int count) 
          Returns an Observable that emits only the last count items emitted by the source Observable.
```

Difference between `takeLast(1)` and `last()` just being the `IllegalArgumentException` on `take`. You were involved in both of these I though so I'm confused why we're pursuing `lastasync`.
 =||= What is a use case for `asObservable` to "hide identity"?
 =||= Rx.NET uses it all around the place to hide subjects. @headinthebox might explain it better.
 =||= Interesting, though what value is there in "hiding" it? If it is returned as an `Observable`, not a `Subject` people will use it as an `Observable`. Is it to prevent people reflecting or inspecting a type and then interacting with the `Subject`?
 =||= Yup, as @benjchristensen says, it is to prevent downcasting etc. In .NET people are pretty paranoid about this. Say you have a method that returns an Iterable<T>, but really it is an Array<T>. Now that opens a potential (security) hole since the caller can use the Iterable as a an Array. 
 =||= > @zsxwing How is the lastasync operator you say you're doing different than last (https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L5740) that is already implemented? It is non-blocking.

Sorry. Forget it. We just need to add `LastOrDefaultAsync`. Hope this comment (https://github.com/Netflix/RxJava/pull/520#issuecomment-30936173) can make these operators clear. If no problem, I can add this table to the wiki.
 =||= Looking into `DeferAsync`, `StartAsync` and `SingleAsync`.
 =||= > Looking into DeferAsync, StartAsync and SingleAsync.

SingleAsync has already done in #520
 =||= Doing ForEachAsync and FromAsync and probably will amend PR #645.
 =||= The `fromAsync` behavior seems to be covered in `from` overloads that take a `Scheduler`, such as this: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L753
 =||= No, this FromAsync is a completely different operation: it uses a factory to get a future of a value which is then observed; per subscriber.
 =||= Already added the table to the wiki:
https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#appendix-similar-blocking-and-non-blocking-operators

On Thu, Dec 19, 2013 at 5:57 PM, Shixiong Zhu notifications@github.comwrote:

> @zsxwing https://github.com/zsxwing How is the lastasync operator you
> say you're doing different than last (
> https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L5740)
> that is already implemented? It is non-blocking.
> 
> Sorry. Forgot it. We just need to add LastOrDefaultAsync. Hope this
> comment (#520 (comment)https://github.com/Netflix/RxJava/pull/520#issuecomment-30936173)
> can make these operators clear. If no problem, I can add this table to the
> wiki.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/634#issuecomment-30983749
> .

## 

David M. Gross
PLP Consulting
 =||= @headinthebox and I reviewed the list. All remaining items have been struck out as they should not be implemented.

Great work getting all the others done!
 =||= ,0
652,649,Refactored BoundedReplaySubject, concurrency enhancements.,Refactored the formerly `rx.operators.OperationReplay.CustomReplaySubject` into `rx.subjects.BoundedReplaySubject` with all sorts of `create` factory methods.

Also mentioned in the [forum](https://groups.google.com/forum/#!topic/rxjava/SqwS5kz-lRA).

Changed to the concurrency logic:

The former `Lock` is now split into a `ReadWriteLock`. In write phase, the buffer is updated; in read phase, the observers are notified. New subscribers will enter the read phase so replaying can be run in-parallel with the already subscribed observers.

However, the source side of the subject is still blocked while replaying. I can't imagine any non-convoluted way to make this less blocking or lock free.,[RxJava-pull-requests #583](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/583/) SUCCESS
This pull request looks good
 =||= I found a concurrency bug in the read-write refactorings and PR #651 enhancements should appear in here as well.
 =||= ,0
657,653,More operators/overloads,Rx.NET 2.2.2
- [x] ~~Aggregate (PR #657)~~
  - `aggregate(seed, accumulator, resultselector)`
- [x] Average (PR #657, M)
  -  `average(Func1<T, Number> valueselector)`
- [x] Buffer (PR #733)
  - `Buffer(Observable<U> bufferBoundaries)`
- [x] ~~Create async~~
  - ~~`Create(Func1<Observer<R>, Task>)`~~
  - ~~`Create(Func1<Observer<R>, Task<Action>>)`~~
  - ~~`Create(Func1<Observer<R>, Task<IDisposable>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<Action>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<IDisposable>>)`~~
- [x] Delay (PR #734)
  - `Delay(Func1<T, Observable<TDelay>>)`
  - `Delay(Func0<Observable<D1>> subscriptionDelay, Func1<T, Observable<D2>> itemDelay)`
- [x] ~~Empty (PR #654)~~
  - ~~`Empty(T witness)`~~
  - ~~`Empty(Scheduler, T witness)`~~
- [x] ~~Never (PR #654)~~
  - ~~`Never(T witness)`~~
- [x] Publish (PR #738)
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel)`
  - `publish(TSource initialValue)`
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel, TSource initialValue)`
- [x] PublishLast (PR #738)
  - `publishLast(Func1<Observable<TSource>, Observable<TResult>> sel)`
- [x] SelectMany (flatMap) (PR #736)
  - `SelectMany(Func1<T, Observable<U>> collection, Func2<T, U, R> resultSel)`
  - `SelectMany(Func1<T, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`
  - `SelectMany(Func1<T, IEnumerable<R>>)`
  - `SelectMany(Func2<T, IEnumerable<U>>, Func2<T, U, R>)`
  - ~~----------------------------------~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>>)`~~
  - ~~`SelectMany(Func1<T, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, CancellationToken, Task<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, CancellationTokenk, Task<R>>)`~~
  - ~~`SelectMany(Func1<T, Integer, Observable<U>> collection, Func4<T, Integer,  U, Integr, R> resultSel)`~~
  - ~~`SelectMany(Func1<T, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, CT, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func3<T, Integer, CT, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`~~
  - ~~`SelectMany(Func2<T, Integer, IEnumerable<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, IEnumerable<U>>, Func4<T, Integer, U, Integer, R>)`~~
- [x] Skip (PR #655, M)
  - `Skip(Timespan)`
  - `Skip(Timespan, Scheduler)`
- [x] SkipLast  (PR #655, M)
  - `SkipLast(Timespan)`
  - `SkipLast(Timespan, Scheduler)`
- [x] Sum (PR #657 M)
  - `sum(Func1<T, Number> valueselector)`
- [x] Take  (PR #655, M)
  - `Take(Timespan)`
  - `Take(Timespan, Scheduler)`
- [x] TakeLast  (PR #655, M)
  - `TakeLast(Timespan)`
  - `TakeLast(Timespan, Scheduler)`
  - `TakeLast(Timespan, Scheduler duration, Scheduler drain)`
- [x] Throttle (debounce) (PR #739)
  - `Throttle(Func1<T, Observable<Void>>)`
- [x] Timeout (PR #740)
  - `Timeout(Func1<T, Observable<Void>>)`
  - `Timeout(Func1<T, Observable<Void>>, Observable<T> other)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>, Observable<T> other)`
- [x] ~~Throw (error) (PR #654)~~
  - ~~`error(Throwable t, T witness)`~~
  - ~~`error(Throwable t, Scheduler, T witness)`~~
- [x] ~~Using async~~
  - ~~`Using(Func1<CancellationToken, Task<TResource>>, Func2<TResource, CancellationToken, Task<Observable<T>>>)`~~
- [x] ~~Where~~
  - ~~`Where(Func2<T, Integer, Boolean>)`~~
- [x] Window (PR #735)
  - `Window(Observable<U> windowBoundaries)`
- [x] Zip (PR #741)
  - ~~`Zip(IEnumerable<Observable<S>> sources, Func1<IList<S>, R> selector)`~~ (already have with FuncN)
  - `Zip(Iterable<U> other, Func2<T, U, R> result)` (instance method)
  - `Zip(Observable<U> other, Func2<T, U, R> result)` (instance method)

Potential Java specific operators/overloads:
- [ ] `just(Func0<R> factory)` return the value of the factory for the subscriber.
- [x] ~~`lock(Lock lock)` or `synchronize(Lock lock)` to support j.u.c.Locks for synchronization.~~
- [x] ~~Using with java.io.Closeable~~
  - ~~`using(Func0<C>, Func1<C, Observable<T>>)`~~
  - ~~`usingFuture(Func1<BooleanSubscription, Future<C>>, Func2<C, BooleanSubscription, Future<Observable<T>>>)`~~,Reviewed by @headinthebox and I for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on.
 =||= > lock(Lock lock) or synchronize(Lock lock) to support j.u.c.Locks for synchronization.

What is a use case when this would ever be needed? @headinthebox mentioned that it's not really used in Rx.Net so likely not worth us adding. 
 =||= Okay, no worries. I won't start working on the remaining ones for at least a week.
 =||= Closing this and ignoring `just(Func0<R> factory)`.
 =||= ,0
667,666,PRs failing,Due to refactored subscriptions:
- OperationTakeLast - I'm about to submit a PR for this
- Scala override attempt of the now final class:

```
rxjava-scala\src\main\scala\rx\lang\scala\subscriptions\BooleanSubscription.scala:30: error: illegal inheritance from final class BooleanSubscription
override val asJavaSubscription: rx.subscriptions.BooleanSubscription = new rx.subscriptions.BooleanSubscription() {
```

Is someone working on this latter?,I'll fix the Scala one; previous there was no overload of BelleanSubscription.create that took an action.
 =||= Thanks @headinthebox . The Scala compiler isn't that nice with me as with you.
 =||= Fixed.
 =||= ,0
689,674,API Design Review: rx.join.ObserverBase,The `rx.join.ObserverBase` class should not be public as part of the rxjava-core API.

It needs to be deleted or made private. It replicates behavior of `SafeObserver` which is also kept private. 

/cc @headinthebox and @jhusain,nan,0
718,62,Operator: Merge (additional overloads),More overloads of merge such as with scheduler, enumerable (iterable?) and number of concurrent subscriptions:

http://msdn.microsoft.com/en-us/library/hh229590(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229740(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229923(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244336(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211914(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229330(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229061(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244329(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229656(v=vs.103).aspx,nan,0
733,653,More operators/overloads,Rx.NET 2.2.2
- [x] ~~Aggregate (PR #657)~~
  - `aggregate(seed, accumulator, resultselector)`
- [x] Average (PR #657, M)
  -  `average(Func1<T, Number> valueselector)`
- [x] Buffer (PR #733)
  - `Buffer(Observable<U> bufferBoundaries)`
- [x] ~~Create async~~
  - ~~`Create(Func1<Observer<R>, Task>)`~~
  - ~~`Create(Func1<Observer<R>, Task<Action>>)`~~
  - ~~`Create(Func1<Observer<R>, Task<IDisposable>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<Action>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<IDisposable>>)`~~
- [x] Delay (PR #734)
  - `Delay(Func1<T, Observable<TDelay>>)`
  - `Delay(Func0<Observable<D1>> subscriptionDelay, Func1<T, Observable<D2>> itemDelay)`
- [x] ~~Empty (PR #654)~~
  - ~~`Empty(T witness)`~~
  - ~~`Empty(Scheduler, T witness)`~~
- [x] ~~Never (PR #654)~~
  - ~~`Never(T witness)`~~
- [x] Publish (PR #738)
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel)`
  - `publish(TSource initialValue)`
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel, TSource initialValue)`
- [x] PublishLast (PR #738)
  - `publishLast(Func1<Observable<TSource>, Observable<TResult>> sel)`
- [x] SelectMany (flatMap) (PR #736)
  - `SelectMany(Func1<T, Observable<U>> collection, Func2<T, U, R> resultSel)`
  - `SelectMany(Func1<T, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`
  - `SelectMany(Func1<T, IEnumerable<R>>)`
  - `SelectMany(Func2<T, IEnumerable<U>>, Func2<T, U, R>)`
  - ~~----------------------------------~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>>)`~~
  - ~~`SelectMany(Func1<T, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, CancellationToken, Task<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, CancellationTokenk, Task<R>>)`~~
  - ~~`SelectMany(Func1<T, Integer, Observable<U>> collection, Func4<T, Integer,  U, Integr, R> resultSel)`~~
  - ~~`SelectMany(Func1<T, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, CT, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func3<T, Integer, CT, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`~~
  - ~~`SelectMany(Func2<T, Integer, IEnumerable<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, IEnumerable<U>>, Func4<T, Integer, U, Integer, R>)`~~
- [x] Skip (PR #655, M)
  - `Skip(Timespan)`
  - `Skip(Timespan, Scheduler)`
- [x] SkipLast  (PR #655, M)
  - `SkipLast(Timespan)`
  - `SkipLast(Timespan, Scheduler)`
- [x] Sum (PR #657 M)
  - `sum(Func1<T, Number> valueselector)`
- [x] Take  (PR #655, M)
  - `Take(Timespan)`
  - `Take(Timespan, Scheduler)`
- [x] TakeLast  (PR #655, M)
  - `TakeLast(Timespan)`
  - `TakeLast(Timespan, Scheduler)`
  - `TakeLast(Timespan, Scheduler duration, Scheduler drain)`
- [x] Throttle (debounce) (PR #739)
  - `Throttle(Func1<T, Observable<Void>>)`
- [x] Timeout (PR #740)
  - `Timeout(Func1<T, Observable<Void>>)`
  - `Timeout(Func1<T, Observable<Void>>, Observable<T> other)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>, Observable<T> other)`
- [x] ~~Throw (error) (PR #654)~~
  - ~~`error(Throwable t, T witness)`~~
  - ~~`error(Throwable t, Scheduler, T witness)`~~
- [x] ~~Using async~~
  - ~~`Using(Func1<CancellationToken, Task<TResource>>, Func2<TResource, CancellationToken, Task<Observable<T>>>)`~~
- [x] ~~Where~~
  - ~~`Where(Func2<T, Integer, Boolean>)`~~
- [x] Window (PR #735)
  - `Window(Observable<U> windowBoundaries)`
- [x] Zip (PR #741)
  - ~~`Zip(IEnumerable<Observable<S>> sources, Func1<IList<S>, R> selector)`~~ (already have with FuncN)
  - `Zip(Iterable<U> other, Func2<T, U, R> result)` (instance method)
  - `Zip(Observable<U> other, Func2<T, U, R> result)` (instance method)

Potential Java specific operators/overloads:
- [ ] `just(Func0<R> factory)` return the value of the factory for the subscriber.
- [x] ~~`lock(Lock lock)` or `synchronize(Lock lock)` to support j.u.c.Locks for synchronization.~~
- [x] ~~Using with java.io.Closeable~~
  - ~~`using(Func0<C>, Func1<C, Observable<T>>)`~~
  - ~~`usingFuture(Func1<BooleanSubscription, Future<C>>, Func2<C, BooleanSubscription, Future<Observable<T>>>)`~~,Reviewed by @headinthebox and I for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on.
 =||= > lock(Lock lock) or synchronize(Lock lock) to support j.u.c.Locks for synchronization.

What is a use case when this would ever be needed? @headinthebox mentioned that it's not really used in Rx.Net so likely not worth us adding. 
 =||= Okay, no worries. I won't start working on the remaining ones for at least a week.
 =||= Closing this and ignoring `just(Func0<R> factory)`.
 =||= ,0
734,653,More operators/overloads,Rx.NET 2.2.2
- [x] ~~Aggregate (PR #657)~~
  - `aggregate(seed, accumulator, resultselector)`
- [x] Average (PR #657, M)
  -  `average(Func1<T, Number> valueselector)`
- [x] Buffer (PR #733)
  - `Buffer(Observable<U> bufferBoundaries)`
- [x] ~~Create async~~
  - ~~`Create(Func1<Observer<R>, Task>)`~~
  - ~~`Create(Func1<Observer<R>, Task<Action>>)`~~
  - ~~`Create(Func1<Observer<R>, Task<IDisposable>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<Action>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<IDisposable>>)`~~
- [x] Delay (PR #734)
  - `Delay(Func1<T, Observable<TDelay>>)`
  - `Delay(Func0<Observable<D1>> subscriptionDelay, Func1<T, Observable<D2>> itemDelay)`
- [x] ~~Empty (PR #654)~~
  - ~~`Empty(T witness)`~~
  - ~~`Empty(Scheduler, T witness)`~~
- [x] ~~Never (PR #654)~~
  - ~~`Never(T witness)`~~
- [x] Publish (PR #738)
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel)`
  - `publish(TSource initialValue)`
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel, TSource initialValue)`
- [x] PublishLast (PR #738)
  - `publishLast(Func1<Observable<TSource>, Observable<TResult>> sel)`
- [x] SelectMany (flatMap) (PR #736)
  - `SelectMany(Func1<T, Observable<U>> collection, Func2<T, U, R> resultSel)`
  - `SelectMany(Func1<T, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`
  - `SelectMany(Func1<T, IEnumerable<R>>)`
  - `SelectMany(Func2<T, IEnumerable<U>>, Func2<T, U, R>)`
  - ~~----------------------------------~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>>)`~~
  - ~~`SelectMany(Func1<T, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, CancellationToken, Task<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, CancellationTokenk, Task<R>>)`~~
  - ~~`SelectMany(Func1<T, Integer, Observable<U>> collection, Func4<T, Integer,  U, Integr, R> resultSel)`~~
  - ~~`SelectMany(Func1<T, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, CT, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func3<T, Integer, CT, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`~~
  - ~~`SelectMany(Func2<T, Integer, IEnumerable<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, IEnumerable<U>>, Func4<T, Integer, U, Integer, R>)`~~
- [x] Skip (PR #655, M)
  - `Skip(Timespan)`
  - `Skip(Timespan, Scheduler)`
- [x] SkipLast  (PR #655, M)
  - `SkipLast(Timespan)`
  - `SkipLast(Timespan, Scheduler)`
- [x] Sum (PR #657 M)
  - `sum(Func1<T, Number> valueselector)`
- [x] Take  (PR #655, M)
  - `Take(Timespan)`
  - `Take(Timespan, Scheduler)`
- [x] TakeLast  (PR #655, M)
  - `TakeLast(Timespan)`
  - `TakeLast(Timespan, Scheduler)`
  - `TakeLast(Timespan, Scheduler duration, Scheduler drain)`
- [x] Throttle (debounce) (PR #739)
  - `Throttle(Func1<T, Observable<Void>>)`
- [x] Timeout (PR #740)
  - `Timeout(Func1<T, Observable<Void>>)`
  - `Timeout(Func1<T, Observable<Void>>, Observable<T> other)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>, Observable<T> other)`
- [x] ~~Throw (error) (PR #654)~~
  - ~~`error(Throwable t, T witness)`~~
  - ~~`error(Throwable t, Scheduler, T witness)`~~
- [x] ~~Using async~~
  - ~~`Using(Func1<CancellationToken, Task<TResource>>, Func2<TResource, CancellationToken, Task<Observable<T>>>)`~~
- [x] ~~Where~~
  - ~~`Where(Func2<T, Integer, Boolean>)`~~
- [x] Window (PR #735)
  - `Window(Observable<U> windowBoundaries)`
- [x] Zip (PR #741)
  - ~~`Zip(IEnumerable<Observable<S>> sources, Func1<IList<S>, R> selector)`~~ (already have with FuncN)
  - `Zip(Iterable<U> other, Func2<T, U, R> result)` (instance method)
  - `Zip(Observable<U> other, Func2<T, U, R> result)` (instance method)

Potential Java specific operators/overloads:
- [ ] `just(Func0<R> factory)` return the value of the factory for the subscriber.
- [x] ~~`lock(Lock lock)` or `synchronize(Lock lock)` to support j.u.c.Locks for synchronization.~~
- [x] ~~Using with java.io.Closeable~~
  - ~~`using(Func0<C>, Func1<C, Observable<T>>)`~~
  - ~~`usingFuture(Func1<BooleanSubscription, Future<C>>, Func2<C, BooleanSubscription, Future<Observable<T>>>)`~~,Reviewed by @headinthebox and I for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on.
 =||= > lock(Lock lock) or synchronize(Lock lock) to support j.u.c.Locks for synchronization.

What is a use case when this would ever be needed? @headinthebox mentioned that it's not really used in Rx.Net so likely not worth us adding. 
 =||= Okay, no worries. I won't start working on the remaining ones for at least a week.
 =||= Closing this and ignoring `just(Func0<R> factory)`.
 =||= ,0
735,653,More operators/overloads,Rx.NET 2.2.2
- [x] ~~Aggregate (PR #657)~~
  - `aggregate(seed, accumulator, resultselector)`
- [x] Average (PR #657, M)
  -  `average(Func1<T, Number> valueselector)`
- [x] Buffer (PR #733)
  - `Buffer(Observable<U> bufferBoundaries)`
- [x] ~~Create async~~
  - ~~`Create(Func1<Observer<R>, Task>)`~~
  - ~~`Create(Func1<Observer<R>, Task<Action>>)`~~
  - ~~`Create(Func1<Observer<R>, Task<IDisposable>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<Action>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<IDisposable>>)`~~
- [x] Delay (PR #734)
  - `Delay(Func1<T, Observable<TDelay>>)`
  - `Delay(Func0<Observable<D1>> subscriptionDelay, Func1<T, Observable<D2>> itemDelay)`
- [x] ~~Empty (PR #654)~~
  - ~~`Empty(T witness)`~~
  - ~~`Empty(Scheduler, T witness)`~~
- [x] ~~Never (PR #654)~~
  - ~~`Never(T witness)`~~
- [x] Publish (PR #738)
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel)`
  - `publish(TSource initialValue)`
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel, TSource initialValue)`
- [x] PublishLast (PR #738)
  - `publishLast(Func1<Observable<TSource>, Observable<TResult>> sel)`
- [x] SelectMany (flatMap) (PR #736)
  - `SelectMany(Func1<T, Observable<U>> collection, Func2<T, U, R> resultSel)`
  - `SelectMany(Func1<T, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`
  - `SelectMany(Func1<T, IEnumerable<R>>)`
  - `SelectMany(Func2<T, IEnumerable<U>>, Func2<T, U, R>)`
  - ~~----------------------------------~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>>)`~~
  - ~~`SelectMany(Func1<T, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, CancellationToken, Task<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, CancellationTokenk, Task<R>>)`~~
  - ~~`SelectMany(Func1<T, Integer, Observable<U>> collection, Func4<T, Integer,  U, Integr, R> resultSel)`~~
  - ~~`SelectMany(Func1<T, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, CT, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func3<T, Integer, CT, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`~~
  - ~~`SelectMany(Func2<T, Integer, IEnumerable<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, IEnumerable<U>>, Func4<T, Integer, U, Integer, R>)`~~
- [x] Skip (PR #655, M)
  - `Skip(Timespan)`
  - `Skip(Timespan, Scheduler)`
- [x] SkipLast  (PR #655, M)
  - `SkipLast(Timespan)`
  - `SkipLast(Timespan, Scheduler)`
- [x] Sum (PR #657 M)
  - `sum(Func1<T, Number> valueselector)`
- [x] Take  (PR #655, M)
  - `Take(Timespan)`
  - `Take(Timespan, Scheduler)`
- [x] TakeLast  (PR #655, M)
  - `TakeLast(Timespan)`
  - `TakeLast(Timespan, Scheduler)`
  - `TakeLast(Timespan, Scheduler duration, Scheduler drain)`
- [x] Throttle (debounce) (PR #739)
  - `Throttle(Func1<T, Observable<Void>>)`
- [x] Timeout (PR #740)
  - `Timeout(Func1<T, Observable<Void>>)`
  - `Timeout(Func1<T, Observable<Void>>, Observable<T> other)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>, Observable<T> other)`
- [x] ~~Throw (error) (PR #654)~~
  - ~~`error(Throwable t, T witness)`~~
  - ~~`error(Throwable t, Scheduler, T witness)`~~
- [x] ~~Using async~~
  - ~~`Using(Func1<CancellationToken, Task<TResource>>, Func2<TResource, CancellationToken, Task<Observable<T>>>)`~~
- [x] ~~Where~~
  - ~~`Where(Func2<T, Integer, Boolean>)`~~
- [x] Window (PR #735)
  - `Window(Observable<U> windowBoundaries)`
- [x] Zip (PR #741)
  - ~~`Zip(IEnumerable<Observable<S>> sources, Func1<IList<S>, R> selector)`~~ (already have with FuncN)
  - `Zip(Iterable<U> other, Func2<T, U, R> result)` (instance method)
  - `Zip(Observable<U> other, Func2<T, U, R> result)` (instance method)

Potential Java specific operators/overloads:
- [ ] `just(Func0<R> factory)` return the value of the factory for the subscriber.
- [x] ~~`lock(Lock lock)` or `synchronize(Lock lock)` to support j.u.c.Locks for synchronization.~~
- [x] ~~Using with java.io.Closeable~~
  - ~~`using(Func0<C>, Func1<C, Observable<T>>)`~~
  - ~~`usingFuture(Func1<BooleanSubscription, Future<C>>, Func2<C, BooleanSubscription, Future<Observable<T>>>)`~~,Reviewed by @headinthebox and I for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on.
 =||= > lock(Lock lock) or synchronize(Lock lock) to support j.u.c.Locks for synchronization.

What is a use case when this would ever be needed? @headinthebox mentioned that it's not really used in Rx.Net so likely not worth us adding. 
 =||= Okay, no worries. I won't start working on the remaining ones for at least a week.
 =||= Closing this and ignoring `just(Func0<R> factory)`.
 =||= ,0
736,653,More operators/overloads,Rx.NET 2.2.2
- [x] ~~Aggregate (PR #657)~~
  - `aggregate(seed, accumulator, resultselector)`
- [x] Average (PR #657, M)
  -  `average(Func1<T, Number> valueselector)`
- [x] Buffer (PR #733)
  - `Buffer(Observable<U> bufferBoundaries)`
- [x] ~~Create async~~
  - ~~`Create(Func1<Observer<R>, Task>)`~~
  - ~~`Create(Func1<Observer<R>, Task<Action>>)`~~
  - ~~`Create(Func1<Observer<R>, Task<IDisposable>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<Action>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<IDisposable>>)`~~
- [x] Delay (PR #734)
  - `Delay(Func1<T, Observable<TDelay>>)`
  - `Delay(Func0<Observable<D1>> subscriptionDelay, Func1<T, Observable<D2>> itemDelay)`
- [x] ~~Empty (PR #654)~~
  - ~~`Empty(T witness)`~~
  - ~~`Empty(Scheduler, T witness)`~~
- [x] ~~Never (PR #654)~~
  - ~~`Never(T witness)`~~
- [x] Publish (PR #738)
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel)`
  - `publish(TSource initialValue)`
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel, TSource initialValue)`
- [x] PublishLast (PR #738)
  - `publishLast(Func1<Observable<TSource>, Observable<TResult>> sel)`
- [x] SelectMany (flatMap) (PR #736)
  - `SelectMany(Func1<T, Observable<U>> collection, Func2<T, U, R> resultSel)`
  - `SelectMany(Func1<T, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`
  - `SelectMany(Func1<T, IEnumerable<R>>)`
  - `SelectMany(Func2<T, IEnumerable<U>>, Func2<T, U, R>)`
  - ~~----------------------------------~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>>)`~~
  - ~~`SelectMany(Func1<T, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, CancellationToken, Task<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, CancellationTokenk, Task<R>>)`~~
  - ~~`SelectMany(Func1<T, Integer, Observable<U>> collection, Func4<T, Integer,  U, Integr, R> resultSel)`~~
  - ~~`SelectMany(Func1<T, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, CT, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func3<T, Integer, CT, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`~~
  - ~~`SelectMany(Func2<T, Integer, IEnumerable<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, IEnumerable<U>>, Func4<T, Integer, U, Integer, R>)`~~
- [x] Skip (PR #655, M)
  - `Skip(Timespan)`
  - `Skip(Timespan, Scheduler)`
- [x] SkipLast  (PR #655, M)
  - `SkipLast(Timespan)`
  - `SkipLast(Timespan, Scheduler)`
- [x] Sum (PR #657 M)
  - `sum(Func1<T, Number> valueselector)`
- [x] Take  (PR #655, M)
  - `Take(Timespan)`
  - `Take(Timespan, Scheduler)`
- [x] TakeLast  (PR #655, M)
  - `TakeLast(Timespan)`
  - `TakeLast(Timespan, Scheduler)`
  - `TakeLast(Timespan, Scheduler duration, Scheduler drain)`
- [x] Throttle (debounce) (PR #739)
  - `Throttle(Func1<T, Observable<Void>>)`
- [x] Timeout (PR #740)
  - `Timeout(Func1<T, Observable<Void>>)`
  - `Timeout(Func1<T, Observable<Void>>, Observable<T> other)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>, Observable<T> other)`
- [x] ~~Throw (error) (PR #654)~~
  - ~~`error(Throwable t, T witness)`~~
  - ~~`error(Throwable t, Scheduler, T witness)`~~
- [x] ~~Using async~~
  - ~~`Using(Func1<CancellationToken, Task<TResource>>, Func2<TResource, CancellationToken, Task<Observable<T>>>)`~~
- [x] ~~Where~~
  - ~~`Where(Func2<T, Integer, Boolean>)`~~
- [x] Window (PR #735)
  - `Window(Observable<U> windowBoundaries)`
- [x] Zip (PR #741)
  - ~~`Zip(IEnumerable<Observable<S>> sources, Func1<IList<S>, R> selector)`~~ (already have with FuncN)
  - `Zip(Iterable<U> other, Func2<T, U, R> result)` (instance method)
  - `Zip(Observable<U> other, Func2<T, U, R> result)` (instance method)

Potential Java specific operators/overloads:
- [ ] `just(Func0<R> factory)` return the value of the factory for the subscriber.
- [x] ~~`lock(Lock lock)` or `synchronize(Lock lock)` to support j.u.c.Locks for synchronization.~~
- [x] ~~Using with java.io.Closeable~~
  - ~~`using(Func0<C>, Func1<C, Observable<T>>)`~~
  - ~~`usingFuture(Func1<BooleanSubscription, Future<C>>, Func2<C, BooleanSubscription, Future<Observable<T>>>)`~~,Reviewed by @headinthebox and I for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on.
 =||= > lock(Lock lock) or synchronize(Lock lock) to support j.u.c.Locks for synchronization.

What is a use case when this would ever be needed? @headinthebox mentioned that it's not really used in Rx.Net so likely not worth us adding. 
 =||= Okay, no worries. I won't start working on the remaining ones for at least a week.
 =||= Closing this and ignoring `just(Func0<R> factory)`.
 =||= ,0
738,653,More operators/overloads,Rx.NET 2.2.2
- [x] ~~Aggregate (PR #657)~~
  - `aggregate(seed, accumulator, resultselector)`
- [x] Average (PR #657, M)
  -  `average(Func1<T, Number> valueselector)`
- [x] Buffer (PR #733)
  - `Buffer(Observable<U> bufferBoundaries)`
- [x] ~~Create async~~
  - ~~`Create(Func1<Observer<R>, Task>)`~~
  - ~~`Create(Func1<Observer<R>, Task<Action>>)`~~
  - ~~`Create(Func1<Observer<R>, Task<IDisposable>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<Action>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<IDisposable>>)`~~
- [x] Delay (PR #734)
  - `Delay(Func1<T, Observable<TDelay>>)`
  - `Delay(Func0<Observable<D1>> subscriptionDelay, Func1<T, Observable<D2>> itemDelay)`
- [x] ~~Empty (PR #654)~~
  - ~~`Empty(T witness)`~~
  - ~~`Empty(Scheduler, T witness)`~~
- [x] ~~Never (PR #654)~~
  - ~~`Never(T witness)`~~
- [x] Publish (PR #738)
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel)`
  - `publish(TSource initialValue)`
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel, TSource initialValue)`
- [x] PublishLast (PR #738)
  - `publishLast(Func1<Observable<TSource>, Observable<TResult>> sel)`
- [x] SelectMany (flatMap) (PR #736)
  - `SelectMany(Func1<T, Observable<U>> collection, Func2<T, U, R> resultSel)`
  - `SelectMany(Func1<T, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`
  - `SelectMany(Func1<T, IEnumerable<R>>)`
  - `SelectMany(Func2<T, IEnumerable<U>>, Func2<T, U, R>)`
  - ~~----------------------------------~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>>)`~~
  - ~~`SelectMany(Func1<T, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, CancellationToken, Task<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, CancellationTokenk, Task<R>>)`~~
  - ~~`SelectMany(Func1<T, Integer, Observable<U>> collection, Func4<T, Integer,  U, Integr, R> resultSel)`~~
  - ~~`SelectMany(Func1<T, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, CT, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func3<T, Integer, CT, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`~~
  - ~~`SelectMany(Func2<T, Integer, IEnumerable<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, IEnumerable<U>>, Func4<T, Integer, U, Integer, R>)`~~
- [x] Skip (PR #655, M)
  - `Skip(Timespan)`
  - `Skip(Timespan, Scheduler)`
- [x] SkipLast  (PR #655, M)
  - `SkipLast(Timespan)`
  - `SkipLast(Timespan, Scheduler)`
- [x] Sum (PR #657 M)
  - `sum(Func1<T, Number> valueselector)`
- [x] Take  (PR #655, M)
  - `Take(Timespan)`
  - `Take(Timespan, Scheduler)`
- [x] TakeLast  (PR #655, M)
  - `TakeLast(Timespan)`
  - `TakeLast(Timespan, Scheduler)`
  - `TakeLast(Timespan, Scheduler duration, Scheduler drain)`
- [x] Throttle (debounce) (PR #739)
  - `Throttle(Func1<T, Observable<Void>>)`
- [x] Timeout (PR #740)
  - `Timeout(Func1<T, Observable<Void>>)`
  - `Timeout(Func1<T, Observable<Void>>, Observable<T> other)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>, Observable<T> other)`
- [x] ~~Throw (error) (PR #654)~~
  - ~~`error(Throwable t, T witness)`~~
  - ~~`error(Throwable t, Scheduler, T witness)`~~
- [x] ~~Using async~~
  - ~~`Using(Func1<CancellationToken, Task<TResource>>, Func2<TResource, CancellationToken, Task<Observable<T>>>)`~~
- [x] ~~Where~~
  - ~~`Where(Func2<T, Integer, Boolean>)`~~
- [x] Window (PR #735)
  - `Window(Observable<U> windowBoundaries)`
- [x] Zip (PR #741)
  - ~~`Zip(IEnumerable<Observable<S>> sources, Func1<IList<S>, R> selector)`~~ (already have with FuncN)
  - `Zip(Iterable<U> other, Func2<T, U, R> result)` (instance method)
  - `Zip(Observable<U> other, Func2<T, U, R> result)` (instance method)

Potential Java specific operators/overloads:
- [ ] `just(Func0<R> factory)` return the value of the factory for the subscriber.
- [x] ~~`lock(Lock lock)` or `synchronize(Lock lock)` to support j.u.c.Locks for synchronization.~~
- [x] ~~Using with java.io.Closeable~~
  - ~~`using(Func0<C>, Func1<C, Observable<T>>)`~~
  - ~~`usingFuture(Func1<BooleanSubscription, Future<C>>, Func2<C, BooleanSubscription, Future<Observable<T>>>)`~~,Reviewed by @headinthebox and I for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on.
 =||= > lock(Lock lock) or synchronize(Lock lock) to support j.u.c.Locks for synchronization.

What is a use case when this would ever be needed? @headinthebox mentioned that it's not really used in Rx.Net so likely not worth us adding. 
 =||= Okay, no worries. I won't start working on the remaining ones for at least a week.
 =||= Closing this and ignoring `just(Func0<R> factory)`.
 =||= ,0
740,653,More operators/overloads,Rx.NET 2.2.2
- [x] ~~Aggregate (PR #657)~~
  - `aggregate(seed, accumulator, resultselector)`
- [x] Average (PR #657, M)
  -  `average(Func1<T, Number> valueselector)`
- [x] Buffer (PR #733)
  - `Buffer(Observable<U> bufferBoundaries)`
- [x] ~~Create async~~
  - ~~`Create(Func1<Observer<R>, Task>)`~~
  - ~~`Create(Func1<Observer<R>, Task<Action>>)`~~
  - ~~`Create(Func1<Observer<R>, Task<IDisposable>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<Action>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<IDisposable>>)`~~
- [x] Delay (PR #734)
  - `Delay(Func1<T, Observable<TDelay>>)`
  - `Delay(Func0<Observable<D1>> subscriptionDelay, Func1<T, Observable<D2>> itemDelay)`
- [x] ~~Empty (PR #654)~~
  - ~~`Empty(T witness)`~~
  - ~~`Empty(Scheduler, T witness)`~~
- [x] ~~Never (PR #654)~~
  - ~~`Never(T witness)`~~
- [x] Publish (PR #738)
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel)`
  - `publish(TSource initialValue)`
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel, TSource initialValue)`
- [x] PublishLast (PR #738)
  - `publishLast(Func1<Observable<TSource>, Observable<TResult>> sel)`
- [x] SelectMany (flatMap) (PR #736)
  - `SelectMany(Func1<T, Observable<U>> collection, Func2<T, U, R> resultSel)`
  - `SelectMany(Func1<T, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`
  - `SelectMany(Func1<T, IEnumerable<R>>)`
  - `SelectMany(Func2<T, IEnumerable<U>>, Func2<T, U, R>)`
  - ~~----------------------------------~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>>)`~~
  - ~~`SelectMany(Func1<T, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, CancellationToken, Task<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, CancellationTokenk, Task<R>>)`~~
  - ~~`SelectMany(Func1<T, Integer, Observable<U>> collection, Func4<T, Integer,  U, Integr, R> resultSel)`~~
  - ~~`SelectMany(Func1<T, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, CT, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func3<T, Integer, CT, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`~~
  - ~~`SelectMany(Func2<T, Integer, IEnumerable<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, IEnumerable<U>>, Func4<T, Integer, U, Integer, R>)`~~
- [x] Skip (PR #655, M)
  - `Skip(Timespan)`
  - `Skip(Timespan, Scheduler)`
- [x] SkipLast  (PR #655, M)
  - `SkipLast(Timespan)`
  - `SkipLast(Timespan, Scheduler)`
- [x] Sum (PR #657 M)
  - `sum(Func1<T, Number> valueselector)`
- [x] Take  (PR #655, M)
  - `Take(Timespan)`
  - `Take(Timespan, Scheduler)`
- [x] TakeLast  (PR #655, M)
  - `TakeLast(Timespan)`
  - `TakeLast(Timespan, Scheduler)`
  - `TakeLast(Timespan, Scheduler duration, Scheduler drain)`
- [x] Throttle (debounce) (PR #739)
  - `Throttle(Func1<T, Observable<Void>>)`
- [x] Timeout (PR #740)
  - `Timeout(Func1<T, Observable<Void>>)`
  - `Timeout(Func1<T, Observable<Void>>, Observable<T> other)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>, Observable<T> other)`
- [x] ~~Throw (error) (PR #654)~~
  - ~~`error(Throwable t, T witness)`~~
  - ~~`error(Throwable t, Scheduler, T witness)`~~
- [x] ~~Using async~~
  - ~~`Using(Func1<CancellationToken, Task<TResource>>, Func2<TResource, CancellationToken, Task<Observable<T>>>)`~~
- [x] ~~Where~~
  - ~~`Where(Func2<T, Integer, Boolean>)`~~
- [x] Window (PR #735)
  - `Window(Observable<U> windowBoundaries)`
- [x] Zip (PR #741)
  - ~~`Zip(IEnumerable<Observable<S>> sources, Func1<IList<S>, R> selector)`~~ (already have with FuncN)
  - `Zip(Iterable<U> other, Func2<T, U, R> result)` (instance method)
  - `Zip(Observable<U> other, Func2<T, U, R> result)` (instance method)

Potential Java specific operators/overloads:
- [ ] `just(Func0<R> factory)` return the value of the factory for the subscriber.
- [x] ~~`lock(Lock lock)` or `synchronize(Lock lock)` to support j.u.c.Locks for synchronization.~~
- [x] ~~Using with java.io.Closeable~~
  - ~~`using(Func0<C>, Func1<C, Observable<T>>)`~~
  - ~~`usingFuture(Func1<BooleanSubscription, Future<C>>, Func2<C, BooleanSubscription, Future<Observable<T>>>)`~~,Reviewed by @headinthebox and I for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on.
 =||= > lock(Lock lock) or synchronize(Lock lock) to support j.u.c.Locks for synchronization.

What is a use case when this would ever be needed? @headinthebox mentioned that it's not really used in Rx.Net so likely not worth us adding. 
 =||= Okay, no worries. I won't start working on the remaining ones for at least a week.
 =||= Closing this and ignoring `just(Func0<R> factory)`.
 =||= ,0
741,653,More operators/overloads,Rx.NET 2.2.2
- [x] ~~Aggregate (PR #657)~~
  - `aggregate(seed, accumulator, resultselector)`
- [x] Average (PR #657, M)
  -  `average(Func1<T, Number> valueselector)`
- [x] Buffer (PR #733)
  - `Buffer(Observable<U> bufferBoundaries)`
- [x] ~~Create async~~
  - ~~`Create(Func1<Observer<R>, Task>)`~~
  - ~~`Create(Func1<Observer<R>, Task<Action>>)`~~
  - ~~`Create(Func1<Observer<R>, Task<IDisposable>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<Action>>)`~~
  - ~~`Create(Func2<Observer<R>, CancellationToken, Task<IDisposable>>)`~~
- [x] Delay (PR #734)
  - `Delay(Func1<T, Observable<TDelay>>)`
  - `Delay(Func0<Observable<D1>> subscriptionDelay, Func1<T, Observable<D2>> itemDelay)`
- [x] ~~Empty (PR #654)~~
  - ~~`Empty(T witness)`~~
  - ~~`Empty(Scheduler, T witness)`~~
- [x] ~~Never (PR #654)~~
  - ~~`Never(T witness)`~~
- [x] Publish (PR #738)
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel)`
  - `publish(TSource initialValue)`
  - `publish(Func1<Observable<TSource>, Observable<TResult>> sel, TSource initialValue)`
- [x] PublishLast (PR #738)
  - `publishLast(Func1<Observable<TSource>, Observable<TResult>> sel)`
- [x] SelectMany (flatMap) (PR #736)
  - `SelectMany(Func1<T, Observable<U>> collection, Func2<T, U, R> resultSel)`
  - `SelectMany(Func1<T, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`
  - `SelectMany(Func1<T, IEnumerable<R>>)`
  - `SelectMany(Func2<T, IEnumerable<U>>, Func2<T, U, R>)`
  - ~~----------------------------------~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>>)`~~
  - ~~`SelectMany(Func1<T, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<R>>)`~~
  - ~~`SelectMany(Func2<T, CancellationToken, Task<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, CancellationTokenk, Task<R>>)`~~
  - ~~`SelectMany(Func1<T, Integer, Observable<U>> collection, Func4<T, Integer,  U, Integr, R> resultSel)`~~
  - ~~`SelectMany(Func1<T, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, CT, Task<U>>, Func2<T, U, R>)`~~
  - ~~`SelectMany(Func3<T, Integer, CT, Task<U>>, Func2<T, Integer, U, R>)`~~
  - ~~`SelectMany(Func2<T, Integer, Observable<R>> onNext, Func1<Exception, Observable<R>> onError, Func0<Observable<R>> onCompleted)`~~
  - ~~`SelectMany(Func2<T, Integer, IEnumerable<R>>)`~~
  - ~~`SelectMany(Func3<T, Integer, IEnumerable<U>>, Func4<T, Integer, U, Integer, R>)`~~
- [x] Skip (PR #655, M)
  - `Skip(Timespan)`
  - `Skip(Timespan, Scheduler)`
- [x] SkipLast  (PR #655, M)
  - `SkipLast(Timespan)`
  - `SkipLast(Timespan, Scheduler)`
- [x] Sum (PR #657 M)
  - `sum(Func1<T, Number> valueselector)`
- [x] Take  (PR #655, M)
  - `Take(Timespan)`
  - `Take(Timespan, Scheduler)`
- [x] TakeLast  (PR #655, M)
  - `TakeLast(Timespan)`
  - `TakeLast(Timespan, Scheduler)`
  - `TakeLast(Timespan, Scheduler duration, Scheduler drain)`
- [x] Throttle (debounce) (PR #739)
  - `Throttle(Func1<T, Observable<Void>>)`
- [x] Timeout (PR #740)
  - `Timeout(Func1<T, Observable<Void>>)`
  - `Timeout(Func1<T, Observable<Void>>, Observable<T> other)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>)`
  - `Timeout(Func0<Observable<Void>>, Func1<T, Observable<Void>>, Observable<T> other)`
- [x] ~~Throw (error) (PR #654)~~
  - ~~`error(Throwable t, T witness)`~~
  - ~~`error(Throwable t, Scheduler, T witness)`~~
- [x] ~~Using async~~
  - ~~`Using(Func1<CancellationToken, Task<TResource>>, Func2<TResource, CancellationToken, Task<Observable<T>>>)`~~
- [x] ~~Where~~
  - ~~`Where(Func2<T, Integer, Boolean>)`~~
- [x] Window (PR #735)
  - `Window(Observable<U> windowBoundaries)`
- [x] Zip (PR #741)
  - ~~`Zip(IEnumerable<Observable<S>> sources, Func1<IList<S>, R> selector)`~~ (already have with FuncN)
  - `Zip(Iterable<U> other, Func2<T, U, R> result)` (instance method)
  - `Zip(Observable<U> other, Func2<T, U, R> result)` (instance method)

Potential Java specific operators/overloads:
- [ ] `just(Func0<R> factory)` return the value of the factory for the subscriber.
- [x] ~~`lock(Lock lock)` or `synchronize(Lock lock)` to support j.u.c.Locks for synchronization.~~
- [x] ~~Using with java.io.Closeable~~
  - ~~`using(Func0<C>, Func1<C, Observable<T>>)`~~
  - ~~`usingFuture(Func1<BooleanSubscription, Future<C>>, Func2<C, BooleanSubscription, Future<Observable<T>>>)`~~,Reviewed by @headinthebox and I for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on.
 =||= > lock(Lock lock) or synchronize(Lock lock) to support j.u.c.Locks for synchronization.

What is a use case when this would ever be needed? @headinthebox mentioned that it's not really used in Rx.Net so likely not worth us adding. 
 =||= Okay, no worries. I won't start working on the remaining ones for at least a week.
 =||= Closing this and ignoring `just(Func0<R> factory)`.
 =||= ,0
745,737,Weird behaviour of switch when the outer sequence completes but the last inner still has elements,Hi all,
I just ran into a behavior of switch (as of RxJava 0.16.0) that I don't think is correct. When the outer sequence completes, but the last inner sequence that the operator was subscribed to still has some elements, I'd expect the operator to either
- also complete immediately, or
- pass on the rest of the elements in the inner sequence and complete when the inner sequence completes.

However, the output of the code below makes me think that neither is the case with the current implementation. When I try to run

``` scala
      import rx.lang.scala.Observable
      import rx.lang.scala.schedulers.NewThreadScheduler
      import scala.concurrent.duration
      import duration._

      val source: Observable[Observable[String]] = Observable.items(
        Observable.interval(200.milli, NewThreadScheduler()).map("a " + _.toString).take(10),
        Observable.interval(200.milli, NewThreadScheduler()).map("b " + _.toString).take(10)
      ).zip(Observable.interval(500.milli, NewThreadScheduler())).map(_._1)

      val items = source.switch.toBlockingObservable.toList
      println(items)
```

it prints (at least for me) `List(a 0, a 1, b 0, b 1, b 2, b 3, b 4, b 5, b 6)`

That seems correct for the a's - two of them fit into the 500 milli window, but why there were 6 b's emitted I don't understand, and it seems to me as quite an arbitrary number. 

Thank you for any insights.
Best regards,
 Tomáš Dvořák,Confirm this is a bug in `switch`. Thanks, @dvtomas 
 =||= I see another issue. The op uses `MultipleAssignmentSubscription` to store the inner subscription. When the switch to the next occurs, it does not unsubscribe from the previous Observable which will keep running indefinitely. I think `child` should be `SerialSubscription` instead.

~~In addition, `latest` isn't volatile so checking the current index wouldn't be safe.~~ My mistake, accessed under gate.
 =||= `latest` does not need `volatile` as it's protected by `synchronized (gate)` and never used outside the lock.
 =||= Sorry, @akarnokd , you're right. The initial step is not thread-safe.
 =||= If latest is not volatile, latest can not be guaranteed to be 0.
 =||= I was wrong, didn't "see" the synchronized. Btw, instance initialization esures that the `latest` field is seen to be 0, no need for volatile.

While you are at it, could you move any `unsubscribe()` outside the synchronization blocks?
 =||= Just refreshed my java concurrency knowledge. `latest` is ensured to be 0 by `synchronized` rather than `instance initialization`. Right? 
 =||= When you call `new SourceObserver()`, the constructor is guaranteed to make fields visible.
 =||= From JSR-133 3.5 Final Fields, "a thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object’s `ﬁnal` ﬁelds."

http://download.oracle.com/otn-pub/jcp/memory_model-1.0-prd-oth-G-F/memory_model-1_0-prd-spec.pdf?AuthParam=1389609770_22e201e49d67d0a8ae6bcaccaedd8518

the constructor is only guaranteed to make `final` fields visible.
 =||= However, I don't know if the default value 0 of a non-final field will be guaranteed to be visible to other threads after the constructor is finished. Is it possible that other threads see a random uninitialized value?
 =||= If publication is not safe, then there is no happens-before relationship between the assignment of the instance's fields and its unsafe publication. If the instance contains final fields, then Java inserts a memory barrier at the end of the constructor and publication is ensured to be safe 
 =||= From [JLS 17.4.4. Synchronization Order](http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.4),

> The write of the default value (zero, false, or null) to each variable synchronizes-with the first action in every thread.
> Although it may seem a little strange to write a default value to a variable before the object containing the variable is allocated, **conceptually every object is created at the start of the program with its default initialized values**.

So if a field is the default value (zero, false, or null) and does not be assigned, the default value is always visible to every thread. 
 =||= The buffer operator has been rewritten with extra effort for making sure values don't fall between two windows if timespan == timeshift. Does it work for you?
 =||= Closing as no further comments in a long time. This is likely fixed with the recent fixes to `buffer`. 

@dvtomas Please re-open if there are still issues. 
 =||= ,0
788,776,Performance Testing,I would like to integrate performance testing as a first-class aspect of rxjava-core in https://github.com/Netflix/RxJava/tree/master/rxjava-core/src/perf

One option is Google Caliper: https://code.google.com/p/caliper/
Another is JMH: http://openjdk.java.net/projects/code-tools/jmh/

Of potential interest, Netty uses JMH: http://netty.io/wiki/microbench-module.html

I have placed some very simple, manual performance tests in the /src/perf folders for now but I'd like to establish the tooling and a few solid examples so we have a pattern to follow. ,/cc @abersnaze as you've been involved in these discussions and you're researching Google Caliper.
 =||= I would very much recommend using JMH, and not Caliper. The latter has lots and lots of issues, which are addressed in the former. Here's a great [presentation](http://shipilev.net/talks/devoxx-Nov2013-benchmarking.pdf) about it.
 =||= Thank you for weighing in and sharing that presentation, just read through it, very interesting. Can you  point to anything about the issues with Caliper?
 =||= @gvsmirnov JMH looks technically pretty impressive, but seems not to integrate as nicely as Caliper in an IDE workflow. I could only find some very brief comments about IntelliJ integration on the Web, do you know more. Also, as @benjchristensen says, the presentation is super interesting but does not answer the question why Caliper is not a good choice.

A side question about all his benchmarking stuff is how much it relates to performance in production. i.e. when running the benchmarks, you measure things in a very specific way, but in production it runs in a completely different environment. It sometimes feels to me like measuring calories using a http://en.wikipedia.org/wiki/Calorimeter, which does not really correspond to the actual digestion of food. To try to state it more formally, is benchmarking monotonic, in other words does Benchmark(A) < Benchmark(B) imply that InProduction(A) < InProduction(B)?
 =||= @benjchristensen Unfortunately, there is no article/presentation/whatever which explicitly points out all the pitfalls of Caliper that I know of. But for most of the common problems (outlined in the presentation), Caliper has no built-in means to work around (the last time I checked, at least). The most broken thing about Caliper is that it falls victim to loop unrolling. See [here](http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_11_Loops.java).

JMH is all about taking the trouble off our shoulders, especially the trouble we do not even suspect exists. Many things that are hard to implement in Caliper (like [this](http://hg.openjdk.java.net/code-tools/jmh/file/f2e982b7c51b/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_15_Asymmetric.java) and [that](http://hg.openjdk.java.net/code-tools/jmh/file/f2e982b7c51b/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_09_Blackholes.java) and [that](http://hg.openjdk.java.net/code-tools/jmh/file/f2e982b7c51b/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_08_DeadCode.java)) are easy to do in JMH.

@headinthebox Now, regarding IDE support, there is indeed next to no of it. But I personally hardly ever use IDE for things like running tests or working with VCSs. Command-line utilities work fine for me. And for JMH, they are much better that your average CLI tool.
 =||= I have just started a [mechanical-sympathy thread](https://groups.google.com/forum/#!topic/mechanical-sympathy/m4opvy4xq3U) that discusses this subject. There will probably be a lot of info there in a couple of days.
 =||= Thank you @gvsmirnov for the information. This is something I hope we'll make a first-class aspect of RxJava in the near future and your information will really help. 

Are you interested in helping us bootstrap RxJava with JMH? The rxjava-core/src/perf/ code is wide-open right now to setup correctly.
 =||= @benjchristensen I most definitely am. There are some spare time issues at the moment, though, so I don't think I will be able to contribute for a couple of weeks. Afterwards, I would be happy to.
 =||= I understand that problem! Once you have some time I'd appreciate your help to get us started down the right path.
 =||= Some observations on the difference now that I've actually used both of them:

Caliper
PROS
- It also measures object count+memory usage as well as time.
- Makes it clear that is monitoring JIT and GC events during the timing.
- parameter annotations makes easier to test different configurations without having to generate a method for each combination manually.

CONS
- Warm up is a bit a black box.  I've seen the warnings that it has detect JIT during measurement often enough that it makes me think that it isn't doing enough to warm up the code.
- It uploads the results!

P.S. I'm not an expert in either benchmarking tool.
 =||= @benjchristensen Sorry it took me so long, but I'm finally back. I've thrown together a sample gradle project with JMH support [here](https://github.com/gvsmirnov/jmh-gradle-sample). Hoping to integrate it with RxJava real soon.
 =||= Oh, finally! I have sent a pull request (https://github.com/Netflix/RxJava/pull/963) with the updated JMH benchmarking. It features changes both to the gradle setup, and to the benchmark itself.

The gradle set up us explained in [this blog post](http://gvsmirnov.ru/blog/tech/2014/03/10/keeping-your-benchmarks-separate.html).

The benchmark is changed in such a way that prevents most of the caveats (like DCE) from happening, while also ensuring that more accurate results are attained. Please consult [these samples](http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/) to gain deeper insight into how benchmarking should be done with JMH.

Here are the results that I got on my Haswell 2.6 GHz 16 GB RAM laptop with Java 8:

```
Benchmark                                  (size)   Mode   Samples         Mean   Mean error    Units
r.o.ObservableBenchmark.measureBaseline         1   avgt        10        0.003        0.000    us/op
r.o.ObservableBenchmark.measureBaseline      1024   avgt        10        2.764        0.051    us/op
r.o.ObservableBenchmark.measureBaseline   1048576   avgt        10     3104.088       49.586    us/op
r.o.ObservableBenchmark.measureMap              1   avgt        10        0.100        0.003    us/op
r.o.ObservableBenchmark.measureMap           1024   avgt        10        5.036        0.059    us/op
r.o.ObservableBenchmark.measureMap        1048576   avgt        10     6693.271      277.604    us/op
```

What we see here is that doing nothing RxJava introduces about a 2x overhead in latency compared to simply doing nothing. Pretty acceptable if you ask me.
 =||= This is great @gvsmirnov Thank you!

Is there a way to maintain historical snapshots over time for getting performance diffs? 
 =||= @benjchristensen you're very welcome.

Uh. I'm not exactly sure if there is an established practice with that. You can easily get JMH to output its results in csv, scsv or json. Should not be a long way from there.

What I'm doing is: before merging anything to master, run the benchmarks on master and on the branch. Works fine for me.
 =||= We have JMH integrated and being used so closing this. Thank you @gvsmirnov  for your help on this!
 =||= ,0
825,799,Error reporting can enter infinite loop,Relevant thread dump:

   java.lang.Thread.State: RUNNABLE
    at java.lang.Throwable.getCause(Throwable.java:415)
    - locked <0x00007f48cf6b4f20> (a java.lang.NullPointerException)
    at rx.util.CompositeException.attachCallingThreadStack(CompositeException.java:87)
    at rx.util.CompositeException.(CompositeException.java:42)
    at rx.util.CompositeException.(CompositeException.java:51)

This is an infinite loop caused by collapsing multiple throwables together.  In the presence of CompositeExceptions, we need to break out of the while-loop in CompositeException.attachCallingThreadStack on Throwables that have self-referential loops,I've got a unit test that duplicates this behavior and a fix.  PR coming shortly
 =||= After further review, I still don't have a complete handle on this.  The above Pull Request successfully limits the symptom of calling attachCallingThreadStack on a malformed exception, but the malformed exception is still getting created.  Since I can't eliminate the malformed exception (yet), I'm submitting a Pull Request that does not call attachCallingThreadStack.  This should eliminate the source of the malformed exception, with the loss of informative debugging of CompositeExceptions
 =||= ,0
832,831,Race condition in rx.operators.OperationJoin ,I just picked up RxJava for the first time, and was experimenting with Observable.join(). I discovered a race condition when both sides of the join are publishing in parallel - they will both emit each other's item.
e.g.
    1---2---**3**---4
    --a---b-**c**--d-

Could result in:
1,a
2,a
1,b
2,b
3,a
3,b
**3,c**
1,c
2,c
**3,c**
1,d
2,d
3,d
4,a
4,b
4,c
4,d

I have a patch for this on my fork - I'll submit a pull request.,I really appreciate you finding the fix for this. 
 =||= ,0
837,776,Performance Testing,I would like to integrate performance testing as a first-class aspect of rxjava-core in https://github.com/Netflix/RxJava/tree/master/rxjava-core/src/perf

One option is Google Caliper: https://code.google.com/p/caliper/
Another is JMH: http://openjdk.java.net/projects/code-tools/jmh/

Of potential interest, Netty uses JMH: http://netty.io/wiki/microbench-module.html

I have placed some very simple, manual performance tests in the /src/perf folders for now but I'd like to establish the tooling and a few solid examples so we have a pattern to follow. ,/cc @abersnaze as you've been involved in these discussions and you're researching Google Caliper.
 =||= I would very much recommend using JMH, and not Caliper. The latter has lots and lots of issues, which are addressed in the former. Here's a great [presentation](http://shipilev.net/talks/devoxx-Nov2013-benchmarking.pdf) about it.
 =||= Thank you for weighing in and sharing that presentation, just read through it, very interesting. Can you  point to anything about the issues with Caliper?
 =||= @gvsmirnov JMH looks technically pretty impressive, but seems not to integrate as nicely as Caliper in an IDE workflow. I could only find some very brief comments about IntelliJ integration on the Web, do you know more. Also, as @benjchristensen says, the presentation is super interesting but does not answer the question why Caliper is not a good choice.

A side question about all his benchmarking stuff is how much it relates to performance in production. i.e. when running the benchmarks, you measure things in a very specific way, but in production it runs in a completely different environment. It sometimes feels to me like measuring calories using a http://en.wikipedia.org/wiki/Calorimeter, which does not really correspond to the actual digestion of food. To try to state it more formally, is benchmarking monotonic, in other words does Benchmark(A) < Benchmark(B) imply that InProduction(A) < InProduction(B)?
 =||= @benjchristensen Unfortunately, there is no article/presentation/whatever which explicitly points out all the pitfalls of Caliper that I know of. But for most of the common problems (outlined in the presentation), Caliper has no built-in means to work around (the last time I checked, at least). The most broken thing about Caliper is that it falls victim to loop unrolling. See [here](http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_11_Loops.java).

JMH is all about taking the trouble off our shoulders, especially the trouble we do not even suspect exists. Many things that are hard to implement in Caliper (like [this](http://hg.openjdk.java.net/code-tools/jmh/file/f2e982b7c51b/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_15_Asymmetric.java) and [that](http://hg.openjdk.java.net/code-tools/jmh/file/f2e982b7c51b/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_09_Blackholes.java) and [that](http://hg.openjdk.java.net/code-tools/jmh/file/f2e982b7c51b/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_08_DeadCode.java)) are easy to do in JMH.

@headinthebox Now, regarding IDE support, there is indeed next to no of it. But I personally hardly ever use IDE for things like running tests or working with VCSs. Command-line utilities work fine for me. And for JMH, they are much better that your average CLI tool.
 =||= I have just started a [mechanical-sympathy thread](https://groups.google.com/forum/#!topic/mechanical-sympathy/m4opvy4xq3U) that discusses this subject. There will probably be a lot of info there in a couple of days.
 =||= Thank you @gvsmirnov for the information. This is something I hope we'll make a first-class aspect of RxJava in the near future and your information will really help. 

Are you interested in helping us bootstrap RxJava with JMH? The rxjava-core/src/perf/ code is wide-open right now to setup correctly.
 =||= @benjchristensen I most definitely am. There are some spare time issues at the moment, though, so I don't think I will be able to contribute for a couple of weeks. Afterwards, I would be happy to.
 =||= I understand that problem! Once you have some time I'd appreciate your help to get us started down the right path.
 =||= Some observations on the difference now that I've actually used both of them:

Caliper
PROS
- It also measures object count+memory usage as well as time.
- Makes it clear that is monitoring JIT and GC events during the timing.
- parameter annotations makes easier to test different configurations without having to generate a method for each combination manually.

CONS
- Warm up is a bit a black box.  I've seen the warnings that it has detect JIT during measurement often enough that it makes me think that it isn't doing enough to warm up the code.
- It uploads the results!

P.S. I'm not an expert in either benchmarking tool.
 =||= @benjchristensen Sorry it took me so long, but I'm finally back. I've thrown together a sample gradle project with JMH support [here](https://github.com/gvsmirnov/jmh-gradle-sample). Hoping to integrate it with RxJava real soon.
 =||= Oh, finally! I have sent a pull request (https://github.com/Netflix/RxJava/pull/963) with the updated JMH benchmarking. It features changes both to the gradle setup, and to the benchmark itself.

The gradle set up us explained in [this blog post](http://gvsmirnov.ru/blog/tech/2014/03/10/keeping-your-benchmarks-separate.html).

The benchmark is changed in such a way that prevents most of the caveats (like DCE) from happening, while also ensuring that more accurate results are attained. Please consult [these samples](http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/) to gain deeper insight into how benchmarking should be done with JMH.

Here are the results that I got on my Haswell 2.6 GHz 16 GB RAM laptop with Java 8:

```
Benchmark                                  (size)   Mode   Samples         Mean   Mean error    Units
r.o.ObservableBenchmark.measureBaseline         1   avgt        10        0.003        0.000    us/op
r.o.ObservableBenchmark.measureBaseline      1024   avgt        10        2.764        0.051    us/op
r.o.ObservableBenchmark.measureBaseline   1048576   avgt        10     3104.088       49.586    us/op
r.o.ObservableBenchmark.measureMap              1   avgt        10        0.100        0.003    us/op
r.o.ObservableBenchmark.measureMap           1024   avgt        10        5.036        0.059    us/op
r.o.ObservableBenchmark.measureMap        1048576   avgt        10     6693.271      277.604    us/op
```

What we see here is that doing nothing RxJava introduces about a 2x overhead in latency compared to simply doing nothing. Pretty acceptable if you ask me.
 =||= This is great @gvsmirnov Thank you!

Is there a way to maintain historical snapshots over time for getting performance diffs? 
 =||= @benjchristensen you're very welcome.

Uh. I'm not exactly sure if there is an established practice with that. You can easily get JMH to output its results in csv, scsv or json. Should not be a long way from there.

What I'm doing is: before merging anything to master, run the benchmarks on master and on the branch. Works fine for me.
 =||= We have JMH integrated and being used so closing this. Thank you @gvsmirnov  for your help on this!
 =||= ,0
860,858,Generics Help Please?,Generics have me stumped on the `merge` operator. The functionality is fine, but only if I leave it untyped.

All other operators I'm using `lift` with are okay, but I can't get this one.

``` java
// this doesn't compile
    public final static <T> Observable<T> merge(Observable<? extends Observable<? extends T>> source) {
        return source.lift(new OperatorMerge<T>()); 
    }

// this compiles with untyped warnings (no generic) and functions
    public final static <T> Observable<T> merge(Observable<? extends Observable<? extends T>> source) {
        return source.lift(new OperatorMerge()); 
    }

// this compiles (but is only merging itself so not very helpful)
    public Observable<T> mergeSelf() {
        return from(this).lift(new OperatorMerge<T>());
    }

// this doesn't compile
    public Observable<T> mergeSelfWithAnother(Observable<? extends T> other) {
        return from(this, other).lift(new OperatorMerge<T>());
    }
```

Here is the compilation error:

```
/Users/bechristensen/development/github/RxJavaFork/rxjava-core/src/main/java/rx/Observable.java:1780: error: method lift in class Observable<T#1> cannot be applied to given types;
        return source.lift(new OperatorMerge<T>());
                     ^
  required: Operator<R,CAP#1>
  found: OperatorMerge<T#2>
  reason: no instance(s) of type variable(s) R exist so that argument type OperatorMerge<T#2> conforms to formal parameter type Operator<R,CAP#1>
  where R,T#1,T#2 are type-variables:
    R extends Object declared in method <R>lift(Operator<R,T#1>)
    T#1 extends Object declared in class Observable
    T#2 extends Object declared in method <T#2>merge(Observable<? extends Observable<? extends T#2>>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Observable<? extends T#2> from capture of ? extends Observable<? extends T#2>
```,Thank you to @abersnaze for fixing the generics!
 =||= I am getting the same compilation error now.  Using `io.reactivex:rxjava:1.0.10`.  What is the solution?
 =||= @IgorGanapolsky what is the code exactly that doesn't compile?
 =||= @akarnokd I have this code:
`return plugshareService.getLocationInfo(locationId).
                map(new PlugshareResponseToLocation()).
                subscribeOn(Schedulers.io()).
                observeOn(AndroidSchedulers.mainThread());`

And I get this error:

> Error:(28, 60) error: method map in class Observable<T> cannot be applied to given types;
> required: Func1<? super EVgoLocation,? extends R>
> found: PlugshareResponseToLocation
> reason: cannot infer type-variable(s) R
> (argument mismatch; PlugshareResponseToLocation cannot be converted to Func1<? super EVgoLocation,? extends R>)
> where R,T are type-variables:
> R extends Object declared in method <R>map(Func1<? super T,? extends R>)
> T extends Object declared in class Observable
 =||= Nevermind, I solved it.  I have to use this in my Retrofit Observable interface:
`@POST("/locations/{id}")
    Observable<PlugshareResponse> getLocationInfo(@Path("id") String id);`

instead of 
`@POST("/locations/{id}")
    Observable<EVgoLocation> getLocationInfo(@Path("id") String id);`
 =||= ,0
955,939,ReplaySubject leaks subscribers even after unsubscribing?,On Android a common use case is to `cache` or `replay` an observable to UI components that might get temporarily destroyed due to e.g. screen rotations.

The biggest challenge on Android when using RxJava is therefore to make sure that no resource leaks occur; since subscribers, however, might be inner classes of an Android Activity or Fragment (if you're unfamiliar: think screen object), those will leak if strong references held within an operator are not released when unsubscribing from the sequence.

I just noticed that when using e.g. `cache` on a long running sequence, and subscribing and unsubscribing multiple times, the observer I subscribe to the sequence never seems to get finalized. Android's StrictMode indeed reports that the observer (and hence the entire screen) is being leaked:

```
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=2; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=2; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=3; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=3; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=4; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=4; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=5; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=5; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=6; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=6; limit=1
```

I quickly glanced over the `ReplaySubject` subscription handling code, and it looks as if on unsubscribe, it removes the observer from the internal map; maybe that's broken, however?,We're observing the leakage on replaying as well (using version 0.17.0-RC7). 

It seems that `ReplaySubject` uses some `replayState` map within its `ReplayState` that keeps references to the subscribers.

We currently work around the issue by avoiding (non-static) inner classes as subscribers and voiding references to activity/fragment-bound variables explicitly in `onComplete`. This of course only minimizes the impact of the leakage.

Any better suggestions of how to handle that?
 =||= I think this issue and some related problems with ReplaySubject are now fixed. Could you confirm & close this issue?
 =||= I can confirm this is fixed for us.
 =||= Thanks @mttkay for the confirmation.
 =||= ,0
964,961,Subject - subscribeOn not persisted? [0.17.0],This might be intentional change from 0.16. -> 0.17. But I have noticed a change in how subjects `onSubscribe` react.

I had the following setup:
Init:

``` java
mPaymentCodeSubject = BehaviorSubject.create((String) null);       
mPaymentCodeSubject.subscribeOn(Schedulers.io());
```

Then I would refresh via this means:

``` java
mPaymentCodeSubject
                .first()
                .flatMap(new rx.functions.Func1<String, Observable<PaymentCode>>() {
                    @Override
                    public Observable<PaymentCode> call(final String currentPaymentCode) {
                        Lg.w("Thread: %s", Thread.currentThread().getName());
                        return mCodeRequester.getPaymentCode(currentPaymentCode);
                    }
                })
                .subscribe(
                        new rx.functions.Action1<PaymentCode>() {
                            @Override
                            public void call(final PaymentCode paymentCode) {
                                Lg.w("Thread: %s", Thread.currentThread().getName());
                                updatePaymentCode(paymentCode.getCode());
                            }
                        }
                );
```

So what I expect to happen is that all subsequent subscriptions are on the `io` pool. But `first()` and all operators after are executed on the thread that called this method. In this case on Android the `Main` thread.

So when `first()` does not return anything, it blocks and waits (locking up the main thread).

I fixed it with the following change:

``` java
mPaymentCodeSubject
                .subscribeOn(Schedulers.io()) //explicitly define Scheduler.
                .first()
                .flatMap(new rx.functions.Func1<String, Observable<PaymentCode>>() {
                //.....
```

Not sure if its the `Subject` implementation or `first()` which has changed. I'm going to roll back to dig around a bit more.

_Edit_

It appears `first()`,`take()` etc are the cause here rolled back to 0.16 and first() is called on the main thread without locking up.

Doing the following also fixes the problem:

``` java
mPaymentCodeSubject
                //.first()
                .flatMap(new rx.functions.Func1<String, Observable<PaymentCode>>() {
                //.....
```

Hoping someone could shed some light?,```
mPaymentCodeSubject = BehaviorSubject.create((String) null);       
mPaymentCodeSubject.subscribeOn(Schedulers.io());
```

What this does, and always did (unless I'm missing something about subjects), is create the subject in line one, then invoke a method which returns a _new_ subject (scheduled on the IO scheduler) just to then discard it. All operators (and subscribeOn(..) simply applies an operator) do not mutate the sequence, but transform it into a new one.

What you want is:

```
mPaymentCodeSubject = BehaviorSubject.create((String) null);       
mPaymentCodeSubject = mPaymentCodeSubject.subscribeOn(Schedulers.io());
```

That said, I'm surprised this ever worked, since it shouldn't have ever even executed on that scheduler to begin with. ^^ Can't say if this is really causing the problem you're seeing, just something I noticed.
 =||= @mttkay Yeah your right, Rolled back to 0.16, the scheduler was never applied. 
Seems that some implementation of `first()` has changed. As removing that resolves the problem..
I updated the OP.
 =||= The `first` operator would have been impacted by `take` changing in 0.17.0. I have not yet spent the time to understand this code.
 =||= > So when first() does not return anything, it blocks and waits (locking up the main thread).

That is exactly what is expected for `take`/`first`. 

In your full code example are you trying to then call `mPaymentCodeSubject.onNext(something)` on the same thread as the subscription is occurring on?
 =||= @benjchristensen Yeah I would expect that too for `take`/`first`, but if i roll back to 0.16 it still blocks but other `Observables` that call `observeOn(MainThread..)` still return even tho that call is blocked.

`mPaymentCodeSubject.onNext()` would eventually get called inside the subscription. But thats not the issue I saw. A whole different observable called later in execution e.g.:

``` java
mSessionProvider.isLoggedInAndPinSet(true)
                .subscribeOn(Schedulers.io)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Observer<Void>() {
                    @Override
                    public void onCompleted() {
                        mNavigationController
                                .next(HomeActivity.createIntent(StartActivity.this))
                                .finish();
                    }

                    @Override
                    public void onError(Throwable e) {
                        //No login token
                        Lg.w("No user session/pin");
                        mNavigationController
                                .next(OnboardingActivity.createIntent(StartActivity.this))
                                .finish();
                    }

                    @Override
                    public void onNext(Void token) {
                    }
                });
```

This will never make it back to the Subscriber. I can only think that the changes to the `Subscribers` somewhere along the line have affected other observables using the same Thread. 

I may just however be a coincidence that this hasn't broken before and actually as 0.17 simplifies `Subscribers` it may not have been working 'correctly' before.
 =||= Hi. Could you do a thread dump to see where it blocks?

I don't see any operators that would block the current thread. Previously, operations such as `from` and `range` combined with `take` would not properly return until all elements were produced.

What kind of Observable does `mCodeRequester.getPaymentCode()` return?
 =||= TraceView file Android Specific, hopefully will help.
https://docs.google.com/file/d/0B1IgMJoZaONSX09FUzBZWUtYeEk/edit
 =||= @akarnokd also at first look of the trace, it seems to be going around in circles, as it doesn't just block it recursively calls. Very odd things going on.
 =||= Thanks.

This code demonstrates the issue on normal Java:

``` java
BehaviorSubject<String> src = BehaviorSubject.create((String)null);

for (int i = 0; i < 10; i++) {
    src.onNext("" + i);
    System.out.printf("Turn: %d%n", i);
    src.first()
            .flatMap(new Func1<String, Observable<String>>() {

        @Override
        public Observable<String> call(String t1) {
            return Observable.from(t1 + ", " + t1);
        }
    })
    .subscribe(new Observer<String>() {
        @Override
        public void onNext(String t) {
            System.out.println(t);
        }

        @Override
        public void onError(Throwable e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
        }
    });
}
```

It seems the code above ends up in an infinite loop within the SubjectSubscriptionManager L60-L99. L89 fights against L99 all the time. I'll post a PR to fix this.
 =||= Cool nice find. Glad the trace helped.
On 13 Mar 2014 21:31, "akarnokd" notifications@github.com wrote:

> Thanks.
> 
> This code demonstrates the issue on normal Java:
> 
> BehaviorSubject<String> src = BehaviorSubject.create((String)null);
> for (int i = 0; i < 10; i++) {
>     src.onNext("" + i);
>     System.out.printf("Turn: %d%n", i);
>     src.first()
>             .flatMap(new Func1<String, Observable<String>>() {
> 
> ```
>     @Override
>     public Observable<String> call(String t1) {
>         return Observable.from(t1 + ", " + t1);
>     }
> })
> .subscribe(new Observer<String>() {
>     @Override
>     public void onNext(String t) {
>         System.out.println(t);
>     }
> 
>     @Override
>     public void onError(Throwable e) {
>         e.printStackTrace();
>     }
> 
>     @Override
>     public void onCompleted() {
>     }
> });}
> ```
> 
> It seems the code above ends up in an infinite loop within the
> SubjectSubscriptionManager L60-L99. L89 fights against L99 all the time.
> I'll post a PR to fix this.
> 
> ## 
> 
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/961#issuecomment-37589426
> .
 =||= I think this issue has been resolved and can be closed.
 =||= Yes your right
 =||= ,0
965,951,OperatorTimeoutBase unsubscribe from source,If no other observable is supplied to the OperatorTimeout:

public final Observable<T> timeout(long timeout, java.util.concurrent.TimeUnit timeUnit)

then, it does not unsubscribe from the source in the event of a timeout.,[RxJava-pull-requests #886](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/886/) FAILURE
Looks like there's a problem with this pull request
 =||= @rbramw Can you please provide a unit test to demonstrate the issue this is fixing?
 =||= Here are 3 tests which can be added to OperatorTimeoutTests.java demonstrating the issue I see when using the timeout method. As @zsxwing pointed out I don't think my fix is providing anything extra, so please ignore it.

```
@Test
public void shouldUnsubscribeFromUnderlyingSubscriptionOnTimeout() {
    final Subscription s = mock(Subscription.class);

    // an observable which never emits anything
    Observable<String> never = Observable.create(new OnSubscribe<String>() {
        public void call(Subscriber<? super String> subscriber) {
            System.out.println("Never Observable subscribed to ...");
            subscriber.add(s);
        }
    });

    // ..when wrapped in a timeout observable 
    Observable<String> observableWithTimeout = never.timeout(1, TimeUnit.MILLISECONDS);

    try {
        observableWithTimeout.toBlockingObservable().forEach(new Action1<String>() {
            public void call(String t1) {
                fail("Never Observable should not have emited an item - "+t1);
            }
        });

        fail("Never Observable should not have completed");
    }
    catch(Throwable ex) {
        System.out.println("observableWithTimeout emitted error - "+ex.getMessage());

        // ..should unsubscribe
        verify(s, times(1)).unsubscribe();
    }
}

@Test
public void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyComplete() {
    final Subscription s = mock(Subscription.class);

    Observable<String> immediatelyComplete = Observable.create(new OnSubscribe<String>() {
        public void call(Subscriber<? super String> subscriber) {
            System.out.println("ImmediatelyComplete Observable subscribed to ...");
            subscriber.add(s);

            subscriber.onCompleted();
        }
    });

    Observable<String> observableWithTimeout = immediatelyComplete.timeout(1, TimeUnit.SECONDS);

    try {
        observableWithTimeout.toBlockingObservable().forEach(new Action1<String>() {
            public void call(String t1) {
                fail("ImmediatelyComplete Observable should not have emited an item - "+t1);
            }
        });

        System.out.println("ImmediatelyComplete completed");

        verify(s, times(1)).unsubscribe();
    }
    catch(Throwable ex) {
        fail("ImmediatelyComplete Observable should not emited an error - "+ex.getMessage());
    }
}

@Test
public void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyErrored() {
    final Subscription s = mock(Subscription.class);

    Observable<String> immediatelyError = Observable.create(new OnSubscribe<String>() {
        public void call(Subscriber<? super String> subscriber) {
            System.out.println("immediatelyErrored Observable subscribed to ...");
            subscriber.add(s);

            subscriber.onError(new RuntimeException("Error"));
        }
    });

    Observable<String> observableWithTimeout = immediatelyError.timeout(1, TimeUnit.SECONDS);

    try {
        observableWithTimeout.toBlockingObservable().forEach(new Action1<String>() {
            public void call(String t1) {
                fail("immediatelyErrored Observable should not have emited an item - "+t1);
            }
        });

        fail("immediatelyErrored Observable should not have completed");
    }
    catch(Throwable ex) {
        System.out.println("observableWithTimeout emitted error - "+ex.getMessage());

        verify(s, times(1)).unsubscribe();
    }
}
```
 =||= I sent a PR #965 to fix the issue. Thanks for your unit tests, @rbramw 
 =||= ,0
972,971,Subjects are not recognized as internal observer implementations,Based on an [issue report](https://groups.google.com/forum/#!topic/rxjava/6cgorYXy7B0), the following program prints the sequence twice instead of continuously:

``` java
public class RepeatCacheTest {
    public static void main(String[] args) throws Exception {
        Observable.from(1, 2, 3)
                .subscribeOn(Schedulers.io())
                .flatMap(i -> Observable.timer(i * 100, 
                      TimeUnit.MILLISECONDS).map(j -> i))
                .cache()
                .repeat()
                .zip(Observable.timer(0, 300, 
                       TimeUnit.MILLISECONDS, Schedulers.newThread()), 
                       (a, b) -> a)
                .subscribe(
        System.out::println, Throwable::printStackTrace, 
                () -> System.out.println("Done"));

        Thread.sleep(100000);
    }
}
```

The problem seems to be in `Observable.isInternalImplementation()` (L8661) not recognizing the ReplaySubject of the `cache()` operator wrapped by a anonymous Subscriber under Observable. 
- A logic is required on L7002 to preserve the safeness of the wrapped Observer somehow (private indicator interface?)
- Can we consider rx.subjects.\* classes as safe?

Alternatively, cache() could wrap the subject in a Subscriber so it will count as internal implementation, but this has to be repeated for multicast and other places.

Thoughts?

Edit:

I did some experimenting and found out the above changes are half solving the problem. The second issue is with the SubjectSubscriptionManager which deadlocks on the terminationLatch.await (L69) because after the second iteration, the terminationLatch.countDown (L140) is never called. The onTerminate call triggers a new subscription through the repeat operator which reenters the call on L50 and deadlock.,Would this be simplified if we eliminate the `isInternalImplementation` check (that I don't like) and use `unsafeSubscribe()` as discussed here: https://github.com/Netflix/RxJava/issues/676#issuecomment-37663897 ?
 =||= Sure.

To be clear, the real problem was something else I discovered soon after I posted this issue.
 =||= Closing as not relevant anymore.
 =||= ,0
1027,1024,possible problem with OperatorRetry and nested subscription,as reported on the [Group](https://groups.google.com/forum/#!topic/rxjava/Kz8NnlvRDkc) there is a problem with `OperatorRetry` in combination with other operators.

i _think_ the issue might be because `OperatorRetry` re-uses the child Subscriber inner CompositeSubscription causing it to be inadvertently completed (so re-subscribe fails). 

https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorRetry.java#L85

I've added a test and the suggested fix (just use a new Subscriber) which does address the problem.

https://github.com/petermd/RxJava/commit/d9fef71f51a261dbe1ad78c2a9a42d2c9b1acb8b

FYI Might also be related #1023.,Thank you. I think you are right. I added some comment on your commit. Could you send a RP?
 =||= Fixed in https://github.com/Netflix/RxJava/pull/1027 

Thanks @petermd 
 =||= ,0
1033,102,Operator: Window,http://msdn.microsoft.com/en-us/library/hh211907(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212125(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229686(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh228991(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244282(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229186(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244316(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212136(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229909(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211621(v=vs.103).aspx,That's enough issues I think. :)
 =||= Started work on window()
 =||= Thanks for getting involved @bcotton !
 =||= Trying to figure out what the behavior should be, for windows when onComplete() is never called on the observer.

This test fails, as there are "hanging" values, and I only get back the first window.

``` java
        public void testNonOverlappingWindowsNoComplete() {
            Observable<Observable<String>> subject = Observable.create(new Func1<Observer<String>, Subscription>() {
                @Override
                public Subscription call(Observer<String> observer) {
                    observer.onNext("one");
                    observer.onNext("two");
                    observer.onNext("three");
                    observer.onNext("four");
                    observer.onNext("five");
                    return Subscriptions.empty();
                }
            }).window(3);

            List<List<String>> windows = toLists(subject);

            assertEquals(2, windows.size());
            assertEquals(list("one", "two", "three"), windows.get(0));
            assertEquals(list("four", "five"), windows.get(1));
        }
```

Perhaps I'm missing something about the internals of Observables and what happens at "the end".
 =||= Each window Observable you emit will need to invoke `onCompleted` as that will not come from the origin.

As for the origin, it is possible for it to never emit an `onCompleted` if it is an infinite stream, in which case the Observable would continue emitting events and windows indefinitely.

However, in your example above, since you're not trying to do an infinite stream, you need to call `observer.onCompleted()` after `observer.onNext("five")` to comply with the `Observable` contract.

You can see some examples here: https://github.com/Netflix/RxJava/wiki/How-To-Use#implementing-an-observable

The contract for an `Observer` is that `onNext` can be called 0 or more times and then `onError` or `onCompleted` called once with nothing following. ([Javadoc](http://netflix.github.io/RxJava/javadoc/rx/Observer.html)) If it's an infinite stream then `onCompleted` may never be called.
 =||= ,0
1055,105,Performance optimizations.,- memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every execution
- use chained observable to reduce composition costs (execute list of functions rather than compositionally invoking onNext),This pull request is for https://github.com/Netflix/RxJava/issues/104.

I have NOT tried this on production code yet, but all unit tests are working.

I'd like to get code reviews and feedback on the approach before I merge.
 =||= NOTE: This is only taking effect on map calls right now. I want to prove it there and then apply to other functions.

It is more or less hacked in on this branch to allow discussion before I do the fairly substantial refactor to apply this pattern elsewhere.

There are also more complicated use cases still to deal with.
 =||= I removed the prototype of chaining. This is currently at a clean point that could merge over the dynamic function invocation optimizations.

I am playing more with chaining.
 =||= Cleaned up in new pull request with single commit with just function execution optimizations.

https://github.com/Netflix/RxJava/pull/106

Will not merge this pull request.
 =||= ,0
1057,104,Performance Optimizations,Very large compositions have a performance hit as they increase the size of the stack and call onNext at each level of composition.

Pursue an initial round of optimizations that collapses the composition into a sequence of functions that get applied at subscribe() rather than subsequent calls of onNext.

UPDATED: See the comments below for where this evolved to. Chaining was shown through testing to not be the issue.,Simple performance test to demonstrate performance issue:

``` java

package testing;

import java.util.concurrent.atomic.AtomicInteger;

import rx.observables.Observable;
import rx.observables.Observer;
import rx.util.Func1;

public class PerformanceTest {

    public static void main(String[] args) {
        PerformanceTest test = new PerformanceTest();
        Integer[] values = new Integer[100001];
        for (int i = 0; i < values.length; i++) {
            values[i] = i;
        }

        for (int i = 0; i < 100; i++) {
            System.out.println("-------------------------------");
            //            test.runFunctionExecutionTest(values);
            test.runCompositionTest(values);
            test.runNonCompositionalTestWithDirectLoop(values);
            test.runNonCompositionalTestWithArrayOfFunctions(values);
        }
    }

    public void runCompositionTest(Integer[] values) {
        System.out.println("runCompositionTest");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();
        // 50 levels of composition (same function so that's not the cost)
        Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .subscribe(new TestObserver(onNextSum, start));
    }

    public void runNonCompositionalTestWithDirectLoop(Integer[] values) {
        System.out.println("runNonCompositionalTestWithDirectLoop");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (int i = 0; i < 50; i++) {
                    t1 = m.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start));

    }

    public void runNonCompositionalTestWithArrayOfFunctions(Integer[] values) {
        System.out.println("runNonCompositionalTestWithArrayOfFunctions");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();
        final Func1[] functionCalls = new Func1<?, ?>[50];
        for (int i = 0; i < 50; i++) {
            functionCalls[i] = m;
        }

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (Func1<Integer, Integer> f : functionCalls) {
                    t1 = f.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start));

    }

    private static final class TestObserver implements Observer<Integer> {
        private final AtomicInteger onNextSum;
        private final long start;

        private TestObserver(AtomicInteger onNextSum, long start) {
            this.onNextSum = onNextSum;
            this.start = start;
        }

        @Override
        public void onNext(Integer i) {
            onNextSum.addAndGet(i);
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            System.out.println("Sum: " + onNextSum.get() + " Time: " + ((double) (end - start)) / 1000 / 1000 + "ms");
        }
    }

    private static class MathFunction implements Func1<Integer, Integer> {

        @Override
        public Integer call(Integer t1) {
            return t1 + 1;
        }

    }

}

```
 =||= On existing code the composition of 50 'map' calls takes ~370ms whereas a single call with a list of the same 50 functions takes ~23ms.

```
runCompositionTest
Sum: 710082754 Time: 371.601ms
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 23.814ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 23.925ms
-------------------------------
runCompositionTest
Sum: 710082754 Time: 383.391ms
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 24.577ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 24.65ms
-------------------------------
runCompositionTest
Sum: 710082754 Time: 376.443ms
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 24.587ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 26.131ms
```
 =||= Playing with different things I got the following numbers:

```

>>> Statically typed <<<

Without chaining:

Sum: 710082754 Time: 130.683ms
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 21.011ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 20.84ms


With chaining (composition collapsing):

Sum: 710082754 Time: 28.787ms
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 19.525ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 19.175ms


>>> Dynamically typed <<<

When going via generic Functions.execute even with chained sequence:

runCompositionTest
Sum: 710082754 Time: 577.3ms <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< very bad when dynamic
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 31.591ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 38.093ms
runCompositionTest


With Function memoization so we only pay dynamic price during sequence setup, not in onNext:


Using ArrayList

runCompositionTest
Sum: 710082754 Time: 27.078ms
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 18.911ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 18.852ms


Using LinkedBlockingQueue

runCompositionTest
Sum: 710082754 Time: 46.532ms
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 18.946ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 18.746ms

```
 =||= By adding chaining (to collapse composition into a single observable with chain of functions) and improving the handling of dynamic function calls through memoization I get this:

```
runCompositionTest
Sum: 710082754 Time: 47.184ms
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 17.869ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 26.528ms
-------------------------------
runCompositionTest
Sum: 710082754 Time: 47.578ms
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 21.692ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 18.177ms
-------------------------------
runCompositionTest
Sum: 710082754 Time: 47.93ms
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 18.821ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 20.064ms
```

I can get the composed version down to around 25-28ms if I use ArrayList but I need to be thread-safe in this case so am using ConcurrentLinkedQueue which adds a little time, but it's still far faster than before.

Same code now takes ~48ms instead of ~370ms.
 =||= Pretty significant performance improvements came from improved handling of function execution - in particular memoizing the logic for constructing a function, particularly dynamic ones.

The long if/then conditional block for handling the many different Func/Action/language functions was very expensive in sequence with lots of data.

This was fixed in https://github.com/Netflix/RxJava/pull/106

I'm still testing the potential gains from chaining.
 =||= While playing with chaining I found that the actual performance issues were the dynamic function construction/lookup and concurrency/synchronization costs - not the depth of stack.

Here is code that demonstrates that the stack depth is not a problem for performance. In fact, the composed version performs better than the loops:

``` java

package testing;

import java.util.ArrayList;
import java.util.concurrent.Callable;

import rx.util.Func1;

public class TestChainPerformance {

    public static void main(String[] args) {
        TestChainPerformance test = new TestChainPerformance();
        Integer[] values = new Integer[100001];
        for (int i = 0; i < values.length; i++) {
            values[i] = i;
        }

        try {
            for (int i = 0; i < 100; i++) {
                System.out.println("-------------------------------");
                test.runChained(values);
                test.runComposed(values);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public void runComposed(final Integer[] values) throws Exception {
        long start = System.nanoTime();

        Callable<Integer> c = null;
        for (int i = 0; i < 250; i++) {
            final Callable<Integer> previousC = c;
            c = new Callable<Integer>() {

                @Override
                public Integer call() throws Exception {
                    MathFunction f = new MathFunction();
                    int sum = 0;
                    for (int v : values) {
                        sum += f.call(v);
                    }
                    if (previousC != null) {
                        sum += previousC.call();
                    }
                    return sum;
                }

            };
        }

        int sum = c.call();

        long end = System.nanoTime();
        System.out.println("Composed => Sum: " + sum + " Time: " + ((double) (end - start)) / 1000 / 1000 + "ms");
    }

    public void runChained(Integer[] values) {
        long start = System.nanoTime();
        int sum = 0;

        ArrayList<Func1<Integer, Integer>> functions = new ArrayList<Func1<Integer, Integer>>();
        for (int i = 0; i < 250; i++) {
            functions.add(new MathFunction());
        }

        for (int v : values) {
            for (Func1<Integer, Integer> f : functions) {
                sum += f.call(v);
            }
        }

        long end = System.nanoTime();
        System.out.println("Iterative => Sum: " + sum + " Time: " + ((double) (end - start)) / 1000 / 1000 + "ms");
    }

    private static class MathFunction implements Func1<Integer, Integer> {

        @Override
        public Integer call(Integer t1) {
            return t1 + 1;
        }

    }
}
```

The performance numbers on my machine are

```
Iterative => Sum: 202017114 Time: 227.288ms
Composed => Sum: 202017114 Time: **172.856ms**
-------------------------------
Iterative => Sum: 202017114 Time: 230.235ms
Composed => Sum: 202017114 Time: **173.917ms**
-------------------------------
Iterative => Sum: 202017114 Time: 226.337ms
Composed => Sum: 202017114 Time: **172.932ms**
```

That is with JDK 7. JDK 6 is slower but similar difference between the two.

Due to this I'm abandoning pursuit of chaining as a performance enhancement and focusing on functions and synchronization.
 =||= In pull request https://github.com/Netflix/RxJava/pull/106 with function memoization we went from this:

```
Sum: 710082754 Time: 437.936ms
```

to this:

```
Sum: 710082754 Time: 60.605ms
```

By reducing the nested synchronization (eliminating most of it) it is now running at:

```
Sum: 710082754 Time: 22.429ms
```
 =||= Performance is now very close to what it is without Rx:

```
Sum: 710082754 Time: 22.429ms
```

vs

```
runNonCompositionalTestWithDirectLoop
Sum: 710082754 Time: 17.248ms
runNonCompositionalTestWithArrayOfFunctions
Sum: 710082754 Time: 17.311ms
```

I am considering this overhead acceptable right now and not spending further time on this issue.
 =||= ,0
1057,1044,Retry in Scala adaptor is ambiguous,The `retry` overload leads to ambiguities:

```
object Test extends App {
  import rx.scala.lang._
  (null: Observable[String]).retry(3)
}

both method retry in trait Observable of type => rx.lang.scala.Observable[String]
and  method retry in trait Observable of type (retryCount: Int)rx.lang.scala.Observable[String]
match argument types (Int)
   (null: Observable[String]).retry(3)
```,The problem is that there are two interpretations for `o.retry(3)`: `o.retry(retryCount: Int)` or `o.retry.apply(3)`.
 =||= Maybe we should remove `apply` method from `trait Observable`, considering it's likely to cause such ambiguities without careful attention.

/cc @samuelgruetter
 =||= Yes, I'd vote for removing `def apply(index: Int): Observable[T]`, since it's probably not used that often, and `elementAt` is a better, more explicit name.
 =||= Thanks @samuelgruetter for weighing in. Based on the two of you agreeing, I'll merge that change.
 =||= Agree with @samuelgruetter .
 =||= Closed as I believe the fix was merged.
 =||= ,0
1073,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1079,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1083,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1084,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1085,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1094,1075,OperatorDebounce,Operator Debounce

Issue #1060

Two notes:
- The behavior of the timed debounce has changed. In the original, if an onCompleted event arrived after an onNext event, that last value was lost. This new version emits the last value if it can then completes. This is consistent with the selector-based debounce operator from before and now.
- In both overloads, when the emission is run in parallel with the onCompleted of the main, the last event might or might not reach the client subscriber: one of the threads will grab the last value, but the call to the client.onCompleted might prevent the value delivery in the emission thread. This couldn't happen in the original as the event emissions where performed under the lock as well. We need to decide if we want to handle this corner case.,[RxJava-pull-requests #989](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/989/) SUCCESS
This pull request looks good
 =||= > when the emission is run in parallel with the onCompleted of the main

It seems to me we should ensure delivery and thus let the `onNext` emit `onCompleted` after it's done if there's a race.
 =||= Okay, I'll add the necessary queue-drain logic tomorrow to fix that case.
 =||= Closing due to merge conflicts. Will post a new PR.
 =||= ,0
1095,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1096,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1103,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1120,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1121,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1125,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1132,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1137,1136,Issues to be fixed with the latest operators,While merging the new operators from issue #1060, some open questions remained. This issue tracks the fixes for those.
- [ ] `OperatorMulticast` to not subscribe/unsubscribe while holding the lock.
- [ ] `OperatorRefCount` to not connect/disconnect while holding the lock 
- [ ] `OperatorSampleWithTime` to unsubscribe when onComplete is called so the periodic schedule can be stopped.,nan,0
1138,1060,Operations to rewrite,Core:
- [x] `All` (w/ lift) PR #1061 - _Merged_
- [x] `Any` (w/ lift) PR #1062 - _Merged_
  - `Exist` and `IsEmpty` are built upon `Any`
- [x] `AsObservable` (w/ ~~OnSubscribe~~ lift) PR #1064 - _Merged_
- [x] `Buffer` (w/ lift) PR #1073 - _Merged_
  - size, time window, skip, observable boundary, observable start-end
- [x] `CombineLatest` (w/ OnSubscribe) PR #1079 - _Merged_
- [x] `Concat` (w/ ~~OnSubscribe~~ lift) PR #1074 - _Merged_
- [x] `Debounce` (w/ lift) PR #1094
  - time window, another observable
- [x] `DefaultIfEmpty` (w/ lift) PR #1080 - _Merged_
- [x] `Defer` (w/ OnSubscribe) PR #1081 - _Merged_
- [x] `Delay` (w/ ~~lift~~ keep as is) ~~PR #1093~~ PR #1144
  - `DelaySubscribe` (w/ OnSubscribe)
  - `DelayViaObservable` (w/ OnSubscribe)
- [x] `Dematerialize` (w/ lift) PR #1083 - _Merged_
- [x] `Distinct` (w/ lift) PR #1084 - _Merged_
  - regular, ~~custom equality comparator~~
- [x] `DistinctUntilChanged` (w/ lift) PR #1085 - _Merged_
- [x] `FinallyDo` (w/ lift) PR #1086 - _Merged_
- [x] `FlatMap` (w/ lift) -> rename to `MergeMap` PR #1087 - _Merged_
  - ~~regular~~, with iterator as sub-collection (`MergeMapIterable`)
- [x] `GroupByUntil` (w/ lift) PR #1095
- [x] `GroupJoin` (w/ OnSubscribe) PR #1096
- [x] `Interval` replace with `Timer` PR #1098
- [x] `Join` (w/ OnSubscribe) PR #1103
- [x] `MergeDelayError` (w/ lift) PR #1104
- [x] `MergeMaxConcurrent`(w/ lift) PR #1106
- [x] `Multicast` (w/ OnSubscribe); PR #1108
  - regular, factory+selector
- [x] `OnErrorResumeNextViaObservable` (w/ lift) PR #1109
- [x] `OnErrorReturn`(w/ lift) PR #1110
- [x] `OnExceptionResumeNextViaObservable` (w/ lift) PR #1117
- [x] `ParallelMerge` -> just rename PR #1118
- [x] `RefCount` (w/ OnSubscribe) PR #1119
- [x] `Replay` (w/ OnSubscribe) PR #1108
- [x] `Sample` (w/ lift)  PR #1098
  - time (state-sharing bug!), another Observable
- [x] `SequenceEquals` -> just rename PR #1120
- [x] `Skip` (w/ lift) into `OperatorSkipTimed` PR #1121
- [x] `SkipUntil` (w/ lift) PR #1122
- [x] `Switch` (w/ lift) PR #1130
- [x] `Take` (w/ lift) PR #1131
  - count: already present, time
- [x] `TakeLast` (w/ lift) PR #1134
  - count, time
- [x] `TakeUntil` (w/ lift) PR #1135
- [x] `TakeWhile` (w/ lift); remove indexed variant? PR #1115
- [x] `ThrottleFirst` (w/ lift) PR #1112
- [x] `TimeInterval` (w/ lift) PR #1111
- [x] `Timer` (w/ OnSubscribe)  PR #1098
- [x] `ToMap` (w/ OnSubscribe) PR #1099
- [x] `ToMultimap` (w/ OnSubscribe) PR #1097
- [x] `ToObservableFuture` (w/ OnSubscribe) PR #1088 - _Merged_
- [x] `Using` (w/ OnSubscribe) PR #1100
- [x] `Window` (w/ lift) PR ~~#1123~~, PR #1138
  - size, time window, skip, observable boundary, observable start-end

contrib-string
- [x] Optionally: refactor operators into separate classes. No changes.

contrib-async-util, PR #1101
- [x] `StartFuture` -> just rename
- [x] `OperationFromFunctionals.InvokeAsync` (w/ OnSubscribe)
- [x] `ForEachFuture` -> just rename
- [x] `DeferFuture` -> just rename

contrib-math, PR #1125
- [x] `Average` (w/ lift); ~~may keep current op-composition~~
  - int, long, float, double; w/ extractor function
- [x] `Min`, `MinBy`, `Max`, `MaxBy` ~~(w/ lift)~~; may keep current op-composition
- [x] `Sum` ~~(w/ lift)~~; may keep current op-composition

contrib-computation-expressions, PR #1129
- [x] `IfThen` (w/ OnSubscribe)
- [x] `SwitchCase` (w/ OnSubscribe)
- [x] `DoWhile`, `WhileDo` (w/ OnSubscribe)

contrib-joins
- [x] `When` (w/ OnSubscribe) PR #1126,I'm working on Buffer but still have to hunt down some test failures.
 =||= Do we expect any of the following proposed operators to be revived?
- chunkify
- deferCancellableFuture (rxjava-async)
- doWhile
- forEachFuture (BlockingObservable)
- forIterable
- fromCancellableFuture (rxjava-async)
- fromFuture
- generate
- generateAbsoluteTime
- ifThen
- startCancellableFuture (rxjava-async)
- switchCase
- whileDo

On Tue, Apr 22, 2014 at 7:50 AM, akarnokd notifications@github.com wrote:

> I'm working on Buffer but still have to hunt down some test failures.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1060#issuecomment-41049048
> .

## 

David M. Gross
PLP Consulting
 =||= ifThen, switchCase, doWhile, whileDo are in contrib-computation-expressions

I'm not sure about the CancelableFuture variants as they conceptionally didn't really work in Java (i.e., attempt to mirror C# cancellation tokens)

chunkify, generate, generateAbsoluteTIme, forIterable - probably not.

While we are at it, I have some trouble with `buffer(Func0<Observable>)` variant. I would expect the returned Observable to supply multiple "absolute" boundary events, but the current implementation calls for a new Observable whenever a previous one fired an event, causing an exponential explosion [ChunkedOperation L515](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java#L515). The reason seems to be to produce a relative windowing in the associated [test method](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java#L272).
 =||= Before we proceed, please review what I wrote at https://github.com/Netflix/RxJava/issues/1001#issuecomment-40970098 and let's agree upon the coding principles.
 =||= > Do we expect any of the following proposed operators to be revived?

I doubt it. Let's get the current operators (as of 0.18) polished for 1.0. New operators, or matured ones from the contrib modules, can come over in 1.x releases if found to be commonly needed.

The only one not on the list I can think of needing to re-add is the `groupBy` overload that takes a selector. It was unceremoniously dropped a few releases ago when I did refactoring.
 =||= I skipped `combineLatest` as there was PR #1043 not long ago; I wonder if @vigdorchik still wants to implement it.
 =||= @akarnokd sorry, I'm out of context here.
 =||= @zsxwing I'll do Window
 =||= All done and merged.
 =||= ,0
1159,1151,RxScala: startWith,startWith bindings are missing, probably nicest to map to +,I'll take it.
 =||= Like!
 =||= Looks @samuelgruetter describe why there is not `startWith` in RxScala in `CompletenessTest.scala`.

``` Scala
"startWith(Iterable[T])" -> "[unnecessary because we can just use `++` instead]",

// all 9 overloads of startWith:
"startWith(" + _ + ")" -> "[unnecessary because we can just use `++` instead]"
```

But `startWith` is a very convenient way to avoid breaking method chaining, @samuelgruetter
 =||= ++ takes an Observable, startWith takes a value
 =||= What's about the following signatures?

``` Scala
  def +[U >: T](elem: U): Observable[U] = {
    val thisJava = this.asJavaObservable.asInstanceOf[rx.Observable[U]]
    toScalaObservable(thisJava.startWith(elem))
  }

  def startWith[U >: T](that: Observable[U]): Observable[U] = {
    val thisJava = this.asJavaObservable.asInstanceOf[rx.Observable[U]]
    val thatJava = that.asJavaObservable.asInstanceOf[rx.Observable[U]]
    toScalaObservable(thisJava.startWith(thatJava))
  }

  def startWith[U >: T](iterable: Iterable[U]): Observable[U] = {
    val thisJava = this.asJavaObservable.asInstanceOf[rx.Observable[U]]
    toScalaObservable(thisJava.startWith(iterable.asJava))
  }
```
 =||= Any better symbols for `startWith(Observable)` and `startWith(Iterable)`?
 =||= The one overload I am really interested in is the first one, and sorry, it seems that `::` is the best choice for naming that, as in `true :: some_stream_of_bools`.
 =||= For the overloads that take collections and or schedulers, `startWith` is probably fine as a name.
 =||= Sorry, I see. I can just replace "+" with "::"
 =||= By `we can just use ++ instead`, I meant that we can use `Observable.items(a, b, c) ++ myObservable` instead of `myObservable.startWith(a, b, c)`. I think this is better because
-    one method less in the API, which is already huge, and for new users it's hard to get an overview
-    more readable in the sense that the emission order of the elements is left to right, i.e. in the direction you read the code
-    more readable in the sense that you needn't lookup what startWith does when reading code

And using `::` on Observables is not a good idea, because it's really "reserved" for List cons, and it will confuse users a lot, since collections other than lists don't use it.
 =||= I agree that `startWith(Observable)` and `startWith(Iterable)` are unnecessary. But for the `::` version, I recommend that we use `+:`.
 =||= Yes, having `+:` and `:+` would be nice
 =||= Remove `startWith`, add `+:` and `:+` at #1165 
 =||= This can be closed.
 =||= ,0
1159,1153,RxScala: Publish overload,Overloads for  `public final <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector)` and `public final <TIntermediate, TResult> Observable<TResult> multicast(
            final Func0<? extends Subject<? super T, ? extends TIntermediate>> subjectFactory,
            final Func1<? super Observable<TIntermediate>, ? extends Observable<TResult>> selector)` are missing,I'll take it.
 =||= Like!
 =||= ,0
1160,1152,RxScala subjects,Several of the scala bindings for subjects still return ()=>subscription instead of a connectableobservable,I'll take it.
 =||= Like!
 =||= ,0
1160,1153,RxScala: Publish overload,Overloads for  `public final <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector)` and `public final <TIntermediate, TResult> Observable<TResult> multicast(
            final Func0<? extends Subject<? super T, ? extends TIntermediate>> subjectFactory,
            final Func1<? super Observable<TIntermediate>, ? extends Observable<TResult>> selector)` are missing,I'll take it.
 =||= Like!
 =||= ,0
1178,117,Aligning with internal infrastructure.,nan,I manually added the necessary changes along with a few others so closing this out instead of merging.
 =||= ,0
1178,1173,RxScala Bug,``` scala
def wrap[T](src: Observable[T]): Observable[T] = {
    Observable(subscriber => {
      println("subscribed")
      subscriber.add(src.subscribe(x => subscriber.onNext(x), e => subscriber.onError(e), () => subscriber.onCompleted()))
    })
  }
```

works but this crashes

``` scala
def wrap[T](src: Observable[T]): Observable[T] = {
    Observable(subscriber => {
      println("subscribed")
      subscriber.add(src.subscribe(subscriber))
    })
  }
```,To be sure, this works:

``` java
public class ComeCrash {
    public static <T> Observable<T> wrap(Observable<T> source) {
        return Observable.create((Subscriber<? super T> subscriber) -> {
            System.out.println("Subscribed");
            subscriber.add(source.subscribe(subscriber));
        });
    }
    public static void main(String[] args) {
        wrap(Observable.just(1)).subscribe(System.out::println, 
            Throwable::printStackTrace, () -> System.out.println("Done."));
    }
}
```
 =||= Closing as #1178 is merged.
 =||= ,0
1185,1181,Behavior subject time gap fix,This fix should make sure subscribing between two event emissions won't create a gap in the received events. I had to implement my own subscription management to ensure the required coordination behavior. 

Performance comparison for simple pass-through behavior:
PublishSubject (master) ~86 MOps/s
BehaviorSubject (master) ~47 MOps/s
BehaviorSubject (this) ~46 MOps/s

The relative slowness compared to PS is due the volatile write on each element and the additional ~1MOps/s is due to the subscription coordination.,[RxJava-pull-requests #1092](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/1092/) SUCCESS
This pull request looks good
 =||= > I had to implement my own subscription management to ensure the required coordination behavior.

Can this really not be done with `SubjectSubscriptionManager`? Having it be different makes an already complicated set of logic now be implemented in two different ways.

Why would the others not benefit from the same improvements?
 =||= Its more like an augmentation than an improvement over the existing subject subscription management. At first glance, I'd need to add 1-2 callback points to an already complicated SSM. I can't say for sure until I try to reimplement the other Subjects and see what are the common points.
 =||= I'd rather not proceed with this change until we know the implications across all of them. It's hard enough working with Subjects without 2 slightly different implementations of the same thing.
 =||= Closing this as outdated. See #1185 for the new proposal.
 =||= ,0
1185,658,BehaviorSubject Race Condition,Need to investigate the `BehaviorSubject` as it likely has the same problem as Rx.Net as reported here: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying

Note that `Subjects` were just re-implemented but kept the same behavior and for the `BehaviorSubject` the race between returning the current value and subscribing for subsequent values appears to be wrong.

Use case:

```
onNext: 1 2 3 4 5 6 7 8 9
Observer: subscribe between 3 & 4 ... should receive 3 4 5 6 7 8 9
```

The likely bug is that in a race it could receive `3 6 7 8 9`,There are a few missing suggestions that I didn't have in my PR which also involves BehaviorSubject. I'll take a look at this as well.

Edit: Yes, this can happen. If an observer subscribes, it immediately gets the current value, then it is eventually added to the state object via `addObserver`, which add could be delayed and values lost.

Edit 2: How to avoid it:
- One would need to block onNext while a subscription is happening, which would negate the improvements. 
- Include the lastNotification in the state so a new observed value triggers a state replace similar to when an observer subscribes. However, one would need 2 states: active and modifying: this avoids using a lock similar to how `AbstractAtomicSubscription` allows complex operations in the mutating state.

I thought about the queue/drain suggestion in the article, but I can't see it solving the value skip problem; (it surely acts against reordering if there happen to be concurrent onNext calls - but we don't allow / ignore those by contract).
 =||= The queue/drain approach can be adapted to also ensure you don't miss notifications. All you have to do is _queue the subscription as well_. (Queue/drain is a fully general synchronization mechanism akin to using an actor.)

Note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread, but it can be fixed by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribing.

So a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:

```
initialValueSent = false
missedDrainCount = 0
create drain queue Q for subscription
sync(this) {
    add observer to {
        enqueue new value onto Q
        sync(Q) {
            // other threads must not push initial value
            if (!initialValueSent) {
                missedDrainCount++
            }
        }
        tryDrain Q
    }

    enqueue current value onto Q
}
// forward value to caller before returning (and perhaps some later values too)
tryDrain Q

// --- allow other threads to forward future values ---
sync(Q) {
    initialValueSent = true;
}
// in case observers were enqueueing while we set the flag
// (pretty sure reading missedDrainCount is safe to touch without locking now...)
// (this can be done without the loop, but requires modifying the Q to drain N)
while (missedDrainCount-- > 0) {
    tryDrain Q
}
```

I think that's right... just off the top of my head, though.
 =||= If you're willing to allow the initial value to thread-hop, it's a lot simpler of course:

```
subscribe:
    enqueue {
        add observer
    }
    tryDrain
send:
    enqueue {
        send to all observers
    }
    tryDrain
```

(assuming you're using the queue as your only synchronization mechanism. If you're also using locks, you probably need to lock around the enqueues)

_edit_ fixed enqueueing inside add observer instead of inside send
 =||= I think this is still an unsolved problem. Do we still want to put effort into this?
 =||= I was thinking about trying to solve it similar to the `groupBy` solution but haven't spent the time to determine if it can be made to work.
 =||= I've implemented a potential fix [here](https://github.com/akarnokd/RxJava/blob/BehaviorSubjectTimeGapFix/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java) but can't create a PR right now due to a github 500 error.  A simple publish benchmark for PublishSubject is 83 MOps/s, BehaviorSubject (new) ~47MOps/s, BehaviorSubject (master) is ~48 MOps/sec.
 =||= Fix just merged.
 =||= ,0
1185,1184,BehaviorSubject concurrent subscription and sending is broken,BehaviorSubject should ensure that the last notification always reaches the subscriber. When the subscription and sending happens concurrently, there is a high probability that this property gets broken.

Test has been prepared that easily reproduces the error.
https://gist.github.com/andrask/fc06abfd70daa6f91edb#file-behaviorsubjectsubscribeandsendconcurrently-java

The test involves two threads: 1) trying to subscribe 2) trying to send next. These are carefully coordinated to allow real concurrent execution. The test is that the subscriber must receive the sent value. The issue almost certainly happens in a few hundred retries.

Note that with a [`Thread.sleep(1)`](https://gist.github.com/andrask/fc06abfd70daa6f91edb#file-behaviorsubjectsubscribeandsendconcurrently-java-L41) the issue goes away.

Note that the test is something I distilled from what I saw in my production code. There may be little issues with it but the concurrency problem certainly exists as it is reproducibly just by stepping through the code.,Thanks for the test case. I'm currently improving the BehaviorSubject and the new code passes this test.
 =||= @andrask  This has been merged to master if you can validate against that prior to release?
 =||= The tests in https://gist.github.com/andrask/fc06abfd70daa6f91edb#file-behaviorsubjectsubscribeandsendconcurrently-java are passing for me. Closing this out as it looks fixed.  Please re-open if it's not and can be demonstrated. I'd still appreciate confirmation if you can.
 =||= @benjchristensen thank you for the notice. I wanted to try today but got overwhelmed by other stuff. I cloned the repo and started installing with `gradlew install` but the process stopped at a lib it couldn't download and I didn't have more time to debug the reason. I'll try again tomorrow with different network settings. I'm sure the issue is with my setup. Fortunately, removing the current workaround from the code is quite easy so it will be simple to see whether this worked.

Sadly, I use hystrix as well which makes it hard to apply the new RxJava version even if it comes out some time in the near future.
 =||= Thanks @andrask. Hystrix 1.3.16+ and Hystrix 1.4.+ should both be fully compatible with the current set of changes, as both of those support RxJava 0.18+. Since I work on both projects I'm keeping Hystrix moving forward.

Is there anything specific about Hystrix + Rx that isn't working well that I can solve?
 =||= I confirm that the new version works.

The combo works well. I'll check again why I wasn't able to upgrade the last time. I think I only upgraded RX and this is why it failed.
 =||= Thanks for confirming. Yes, Hystrix had to be upgraded to work. It is no longer using any deprecated Rx code so should be safe as we're nearing the end of changes and almost to 1.0.
 =||= I'm still seeing some concurrency issue between the subscription and the emission of the first object.
When those 2 things happen at the very same time, the subscriber doesn't observe the initial emission...
Is there any remaining known issue?
 =||= This is expected behavior.

If you you write to the subject from multiple threads and need consistency of `on*()` events -> you can convert your subject to `SerializedSubject` via `subject.toSerialized()`.

Javadoc of `Subject.toSerialized()`:

``` java
/**
 * Wraps a {@link Subject} so that it is safe to call its various {@code on} methods from different threads.
 * <p>
 * When you use an ordinary {@link Subject} as a {@link Subscriber}, you must take care not to call its 
 * {@link Subscriber#onNext} method (or its other {@code on} methods) from multiple threads, as this could 
 * lead to non-serialized calls, which violates
 * <a href="http://reactivex.io/documentation/contract.html">the Observable contract</a> and creates an
 * ambiguity in the resulting Subject.
 * <p>
 * To protect a {@code Subject} from this danger, you can convert it into a {@code SerializedSubject} with
 * code like the following:
 * <p><pre>{@code
 * mySafeSubject = myUnsafeSubject.toSerialized();
 * }</pre>
 * 
 * @return SerializedSubject wrapping the current Subject
 */
```
 =||= Subscription is not an on\* method and therefore this is not expected.

On Tue, May 24, 2016 at 7:38 PM Artem Zinnatullin notifications@github.com
wrote:

> This is expected behavior.
> 
> If you you write to the subject from multiple threads and need consistency
> of on*() events -> you can convert your subject to SerializedSubject via
> subject.toSerialized().
> 
> Javadoc of Subject.toSerialized():
> 
> /*\* \* Wraps a {@link Subject} so that it is safe to call its various {@code on} methods from different threads. \* <p> \* When you use an ordinary {@link Subject} as a {@link Subscriber}, you must take care not to call its  \* {@link Subscriber#onNext} method (or its other {@code on} methods) from multiple threads, as this could  \* lead to non-serialized calls, which violates \* <a href="http://reactivex.io/documentation/contract.html">the Observable contract</a> and creates an \* ambiguity in the resulting Subject. \* <p> \* To protect a {@code Subject} from this danger, you can convert it into a {@code SerializedSubject} with \* code like the following: \* <p><pre>{@code \* mySafeSubject = myUnsafeSubject.toSerialized(); \* }</pre> \*  \* @return SerializedSubject wrapping the current Subject */
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1184#issuecomment-221433827
 =||= Well, it's hard to divide `subscribe()` and setting of initial value (which is `~onNext`) for me.

What I see at the moment:
1. Current implementation of `BehaviorSubject.create(defaultValue)` sets default value to `volatile Object latest` field of `SubjectSubscriptionManager`.
2. When you call `onNext()` it also sets new value to that `volatile` field without any synchronization. 
3. When you `subscribe()` it won't start with `defaultValue` that you've passed as initial but it will emit that `volatile latest` state instead -> that leads to the effect that @sregg sees.

And now I'm not sure that `toSerialized()` will help with initial value because even though it synchronizes `onNext`, emission of the default value goes trough different lock object and still may happen concurrently with `onNext`…

@sregg as temporary solution you can try to create `BehaviorSubject` **without** default value, convert it `toSerialized()` and set default value via `onNext` before giving reference to the subject to other threads, this should give you threading consistency you want to achieve.

Probably we need to define this behavior better either in javadoc or even change current impementation to emit `default` initial value first and only then emit `volatile latest`.

@akarnokd will be great to get your comment here!
 =||= I'm sorry, when I said "initial" value I wanted to say "first" value (first `onNext`) not the default value you pass in `create()`
 =||= Oh, that's better, then `toSerialized()` should be enough for you!

But the problem still remains: we need to define serialized behavior for initial value passed to `Subject.create()`. 

@akarnokd /other contributors: maybe create separate issue for that if you think it worth it?
 =||= also, I'm using `asObservable` on my `BehaviorSubject`. Not sure if that changes anything... (and I'm not sure why I'm using `asObservable` either...)
 =||= but I thought `toSerialized` was fixing concurrency issues between 2 `onNext/onError/onComplete` from 2 different threads, it doesn't say anything about concurrency issues between subscription and onNext...
 =||= That doesn't change anything significant, it simply _hides_ actual type of the `Observable` for consumers so they won't be able to simply cast your `Observable` to `BehaviorSubject`/etc.
 =||= > I'm still seeing some concurrency issue between the subscription and the emission of the first object.
> When those 2 things happen at the very same time, the subscriber doesn't observe the initial emission...
> Is there any remaining known issue?

Can you demonstrate this with an unit test?

Currently, there is a bug with `BehaviorSubject` that when started out empty, a concurrent subscription with an `onNext` may result in receiving the same value twice - but this doesn't sound like your case.

``` java
int n = 100000;
Scheduler.Worker w = Schedulers.computation().createWorker();

try {
    for (int i = 0; i < n; i++) {

        if ((i % 100) == 0) {
            System.out.println("Round " + i);
        }

        AtomicInteger cdl = new AtomicInteger(2);

        AtomicBoolean done = new AtomicBoolean();

        BehaviorSubject<Integer> bs = BehaviorSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<>();

        w.schedule(() -> {
            cdl.decrementAndGet();
            while (cdl.get() != 0) ;
            bs.onNext(1);
            done.set(true);
        });

        cdl.decrementAndGet();
        while (cdl.get() != 0) ;

        bs.subscribe(ts);

        while (!done.get()) ;

        int c = ts.getOnNextEvents().size();
        if (c == 0) {
            Assert.fail("The TestSubscriber didn't receive any values");
        }
    }
} finally {
    w.unsubscribe();
}
```

Note that if a `BehaviorSubject` is completed, the cached value, if any, won't be available anymore so you may end up with no values but a terminal event in the subscriber.
 =||= Right, that's probably what's happening. I'm calling `onComplete()` right after `onNext()`.

Here's my setup:
I wrapped a class that does asynchronous stuff with Rx java.
That class needs a callback listener in its constructor and has a method to trigger an action. 
If that method is called, it will do the action in a different thread, and send the result back to me via the callback listener.
I wrapped this asynchronous behavior using a `BehaviorSubject`. Here's the pseudo code:

```
public class Wrapper implements Wrapped.Listener {
  private Wrapped wrapped;
  private BehaviorSubject<Result> behaviorSubject;

  public Wrapper() {
    wrapped = new Wrapped(this);
    behaviorSubject = BehaviorSubject.create();
  }

  public Observable<Result> getWrappedObservable() {
    wrapped.doAction();
    return behaviorSubject.asObservable();
  }

  @Override
  public void callback(Result result) {
    behaviorSubject.onNext(result);
    behaviorSubject.onCompleted();
  }
}
```

The problem is that the async action can be so quick to execute, it will call the callback right away, and some times, before or during the subscription of the Observable.

I managed to fix this by delaying the call of the `doAction()` call in `doOnSubscribe()`:

```
  public Observable<Result> getWrappedObservable() {
    return behaviorSubject.asObservable()
        .doOnSubscribe(() -> {
            wrapped.doAction();
        });
  }
```

Is there a better way to do so?
 =||= If you have only one value to relay, use `AsyncSubject`.
 =||= Good to know. But would that fix my concurrency issue?
 =||= Seems that my idea of delaying the action in `doOnSubscribe` still doesn't fix the issue.
Now I'm thinking there's something wrong between `onNext` and `onComplete`. Sometimes only `onComplete` is received...
 =||= ,0
1188,1187,RxScala Schedulers,I think it is a mistake to use Unit => Unit instead of () => Unit. Any takers, or I'll fix it later this week.

```
trait Worker extends Subscription {
  private [scala] val asJavaWorker: rx.Scheduler.Worker

  /**
   * Schedules a cancelable action to be executed in delayTime.
   */
  def schedule(action: Unit => Unit, delayTime: Duration): Subscription =
    this.asJavaWorker.schedule(
      new Action0 {
        override def call(): Unit = action()
      },
      delayTime.length,
      delayTime.unit)

  /**
   * Schedules a cancelable action to be executed immediately.
   */
  def schedule(action: Unit => Unit): Subscription = this.asJavaWorker.schedule(
    new Action0 {
      override def call(): Unit = action()
    }
  )
```,The original implementation uses `(action: => Unit)`. Do you think which one is better? I prefer `(action: => Unit)`.
 =||= `=>Unit` would be even better. 
 =||= One caveat, to do recursive scheduling we might want to use  the same method as in Java; which does not seem to work with `=>Unit`. 

```
def random(seed: Int): Observable[Double] = {
    Observable(subscriber => {
      val r: Random = new Random(seed)
      val inner = rx.lang.scala.schedulers.NewThreadScheduler().createWorker
      subscriber.add(inner)

      inner.schedule(new Function[Unit, Unit]{
        override def apply(unit: Unit): Unit = {
          val n = r.nextDouble()
          subscriber.onNext(n)
          inner.schedule(apply)
        }
      })
    })
  }
```
 =||= OK. I'll take it and add some examples to test the signature.
 =||= Cool.
 =||= this is nice :)
 =||= @zsxwing Is this done after merging that PR?
 =||= Yes, already fixed.
 =||= ,0
1188,119,Javadoc refers to private document in "for more information",http://netflix.github.com/RxJava/javadoc/rx/Observer.html

"For more information" links to https://confluence.corp.netflix.com/display/API/Observers%2C+Observables%2C+and+the+Reactive+Pattern#Observers%2CObservables%2CandtheReactivePattern-SettingupObserversinGroovy,There is a comment in the onNext method:

See wx.synchronize() for information on how to enforce chronologically-ordered behavior.

wx.synchronize() links to https://confluence.corp.netflix.com/display/API/Observers%2C+Observables%2C+and+the+Reactive+Pattern#Observers%2CObservables%2CandtheReactivePattern-%7B%7Bwx.synchronize%28%26%238239%3B%29%7D%7D
 =||= I'll go fix these ... lost track of them on my TODOs while externalizing everything.

Thanks for the reminder.
 =||= I have updated the hosted Javadocs: http://netflix.github.com/RxJava/javadoc/
 =||= ,0
1188,1187,RxScala Schedulers,I think it is a mistake to use Unit => Unit instead of () => Unit. Any takers, or I'll fix it later this week.

```
trait Worker extends Subscription {
  private [scala] val asJavaWorker: rx.Scheduler.Worker

  /**
   * Schedules a cancelable action to be executed in delayTime.
   */
  def schedule(action: Unit => Unit, delayTime: Duration): Subscription =
    this.asJavaWorker.schedule(
      new Action0 {
        override def call(): Unit = action()
      },
      delayTime.length,
      delayTime.unit)

  /**
   * Schedules a cancelable action to be executed immediately.
   */
  def schedule(action: Unit => Unit): Subscription = this.asJavaWorker.schedule(
    new Action0 {
      override def call(): Unit = action()
    }
  )
```,The original implementation uses `(action: => Unit)`. Do you think which one is better? I prefer `(action: => Unit)`.
 =||= `=>Unit` would be even better. 
 =||= One caveat, to do recursive scheduling we might want to use  the same method as in Java; which does not seem to work with `=>Unit`. 

```
def random(seed: Int): Observable[Double] = {
    Observable(subscriber => {
      val r: Random = new Random(seed)
      val inner = rx.lang.scala.schedulers.NewThreadScheduler().createWorker
      subscriber.add(inner)

      inner.schedule(new Function[Unit, Unit]{
        override def apply(unit: Unit): Unit = {
          val n = r.nextDouble()
          subscriber.onNext(n)
          inner.schedule(apply)
        }
      })
    })
  }
```
 =||= OK. I'll take it and add some examples to test the signature.
 =||= Cool.
 =||= this is nice :)
 =||= @zsxwing Is this done after merging that PR?
 =||= Yes, already fixed.
 =||= ,0
1195,1193,IllegalArgException when using SwingScheduler,I occasionally get this exception when using rx for Swing tasks. I'm not specifically using the SwingScheduler, so I assume it's being used automatically? 

Not sure if it's relevant, but I currently have one observable using a delay of 20ms.

Exception in thread "AWT-EventQueue-0" java.lang.IllegalArgumentException: The swing timer only accepts non-negative delays up to 2147483647 milliseconds.
    at rx.schedulers.SwingScheduler.assertThatTheDelayIsValidForTheSwingTimer(SwingScheduler.java:139)
    at rx.schedulers.SwingScheduler.access$100(SwingScheduler.java:36)
    at rx.schedulers.SwingScheduler$InnerSwingScheduler.schedule(SwingScheduler.java:68)
    at rx.Scheduler$Worker$1.call(Scheduler.java:110)
    at rx.schedulers.SwingScheduler$InnerSwingScheduler$1ExecuteOnceAction.actionPerformed(SwingScheduler.java:83)
    at javax.swing.Timer.fireActionPerformed(Timer.java:313)
    at javax.swing.Timer$DoPostEvent.run(Timer.java:245)
    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:311)
    at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:744)
    at java.awt.EventQueue.access$400(EventQueue.java:97)
    at java.awt.EventQueue$3.run(EventQueue.java:697)
    at java.awt.EventQueue$3.run(EventQueue.java:691)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:75)
    at java.awt.EventQueue.dispatchEvent(EventQueue.java:714)
    at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:201)
    at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)
    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93)
    at java.awt.EventDispatchThread.run(EventDispatchThread.java:82),Do you have any periodic tasks, i.e., using `schedulePeriodic` somewhere?
 =||= I had a "delay" in there, but no periodic tasks.
 =||= I believe #1195 fixed this. Please re-open if it is still an issue.
 =||= ,0
1226,1189,RxScala zip,Why keep this `private`? I want it all the time. Perhaps we can call it `zipWith` to match the Haskell name to avoid bikeshedding that it is not in Scala (it should).

```
private def zip[U, R](that: Observable[U], selector: (T,U) => R): Observable[R] = {
    toScalaObservable[R](rx.Observable.zip[T, U, R](this.asJavaObservable, that.asJavaObservable, selector))
  }
```,@zsxwing and @headinthebox Want to discuss and finish this one?
 =||= @samuelgruetter explained the reason in this commit: https://github.com/Netflix/RxJava/commit/24e0bafacbaa7651fca3b4b2faffb0e78bd3c9e4

> Scala collections do not have such a function, and we want to be
> as close to Scala collections as possible
 =||= I want it in, we can have more operations than other collections have. In fact we should have the union of Scala collections and Rx operators. 

(Scala does not have combineLatest either).
 =||= ,0
1236,1204,Profiling Memory Usage and Object Creation,We need to spend time profiling memory and object allocation and finding places where we can improve. 

I would really appreciate help diving into this and finding problem areas. Even if you don't fix them, but just identity use cases, operators, etc that would be very valuable.

This is partly a result of the fact that in Netflix production we have seen an increase in YoungGen GCs since 0.17.x.

The areas to start should probably be:
- Observable.create
- Observable.lift
- Subscriber
- CompositeSubscription
- map
- flatMap

If you can or want to get involved in this please comment here so we all can collaborate together.,The most likely source of garbage is the `CompositeSubscription`: whenever a task is scheduled or a new merge-source appears, the state transition creates a new State object and copies the subscription array. PR #1145 reduces the amount of garbage by switching to HashSet on a larger composite. Since flatMap->mergeMap->merge needs to track the active inner subscriptions, it uses a composite as well and would gain the same benefits.
 =||= The `HashSet` change shouldn't kick in though because these aren't generally large lists (handful at most, not hundreds). I expect it's just far too many of them being created.
 =||= I'll also like to help out here, since its crucial for our uses as well. 
 =||= Thanks @daschl I'd appreciate your help. Profiling and identifying hot spots is what we need most right now.
 =||= I did some GC profiling of my test workloads and I'd also like to nominate:
- BlockingObservable (it seems that especially in the .single() case its not optimized)
- Observable.subscribe (for both Observer and Subscriber) - in my GC logs they take up 40% of the overall GC pressure.

The bad news is that i had to fall back out of Observables to plain execution on the hot code path (aside from the overall wrapping observable), because also using it in the path produces way too much garbage (moving away from Rx in the hot code path got my throughput from 20% to 80% according to the GC logs) and it correlates with my findings since I could not sustain constant IO throughput because of full GCs happening way too frequently.
 =||= > Observable.subscribe (for both Observer and Subscriber)

Not surprised on this. Were you able to identify what the garbage is? 
 =||= I did some changes in my code and will re-profile and post the results here so we get better measurements. 

Here is a slightly older profile run which might give you a hint or two.
![screen shot 2014-05-20 at 10 13 10](https://cloud.githubusercontent.com/assets/29086/3024320/a10a2a64-dff6-11e3-8f2c-3473bdfc7af7.png)
![screen shot 2014-05-20 at 10 13 00](https://cloud.githubusercontent.com/assets/29086/3024319/a1096bba-dff6-11e3-9c92-0177913e5c47.png)
 =||= We can definitely improve on the `AtomicReference` by using AtomicFieldUpdater. The others will require more effort to analyze along with sample code to see what's triggering them.
 =||= I think that many `AtomicReference` come from mostly the `CompositeSubscription` instances.
 =||= I went back in history to 0.16.1 to compare performance of the basic `map`/`flatMap` behavior and found that current master is faster. This fits what I had expected of the work of the past couple months, which means it's not an obvious glaring issue (unless my test is completely flawed).

Here is the code for the test:
- Branch 0.16 => https://github.com/benjchristensen/RxJava/blob/0.16-perf/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java
- Master => https://github.com/benjchristensen/RxJava/blob/performance/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java

### Results

#### 0.16

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  2421210.583    68845.966    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     1017.787       73.597    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  2398541.067    90703.197    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5      990.623      100.735    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  4020548.060   262841.500    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    16205.747      352.618    ops/s
```

#### Master

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3184873.133   172320.420    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9079.937      343.905    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3411785.677    73767.161    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10860.963      294.309    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  7208334.997   703327.745    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    18720.797      278.529    ops/s
```

### GC

On the master branch test I'm seeing GC results like this:

```
Iteration   5: 3189218.350 ops/s
          GC | wall time = 5.001 secs,  GC time = 0.047 secs, GC% = 0.94%, GC count = +98
Iteration   5: 9198.700 ops/s
          GC | wall time = 5.002 secs,  GC time = 0.048 secs, GC% = 0.96%, GC count = +98
```

versus 0.16

```
Iteration   5: 2420099.017 ops/s
          GC | wall time = 5.000 secs,  GC time = 0.046 secs, GC% = 0.92%, GC count = +96
Iteration   5: 993.867 ops/s
          GC | wall time = 5.001 secs,  GC time = 0.100 secs, GC% = 2.00%, GC count = +212
```

### Summary

Unless I'm mistaken, current code is better:
- similar GC behavior on `Observable` with 1 item, better GC behavior with 1024 items
- higher ops/second on all of the map/flatMap tests

I'll start profiling this and improve ... but this does not reveal the source of the problems seen. Possibly it's related to schedulers, or it's a specific operator. I exercised `map`, `flatMap` (and thus `merge`), `Observable` and `Subscribe` here to get the most fundamental ones.
 =||= The `observeOn` test shows the cost of scheduling ... particularly `Observable`s of a single item.

``` java
    @GenerateMicroBenchmark
    public void observeOn(UseCaseInput input) throws InterruptedException {
        input.observable.observeOn(Schedulers.computation()).subscribe(input.observer);
        input.awaitCompletion();
    }
```

```
r.u.PerfObserveOn.observeOn        1  thrpt         5   457830.180     9943.221    ops/s
r.u.PerfObserveOn.observeOn     1024  thrpt         5    14496.430      518.463    ops/s
```

Thus, with an `Observable` of 1 item we can do 457k onNext/second, with an `Observable` of 1024 items we can do 14.8million onNext/second (14.5k \* 1024).
 =||= By the way, all testing is just being done on my Mac laptop ... so these numbers are all relative and not representative of proper server hardware.
 =||= Converting from `AtomicReference` to `AtomicReferenceFieldUpdater` improved performance from this:

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3184873.133   172320.420    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9079.937      343.905    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3411785.677    73767.161    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10860.963      294.309    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  7208334.997   703327.745    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    18720.797      278.529    ops/s
```

to this:

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3459205.110   124790.906    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9225.037      604.720    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3639603.060   225599.038    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    11135.613      337.022    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  7264202.633   214787.109    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    18795.790      713.668    ops/s
```
 =||= @benjchristensen I suppose the `AtomicReferenceFieldUpdater` mostly comes from less GC pressure, is that why the raw throughput increases in your tests? How did the GC wall time change?
 =||= If you want me to run a specific workload/type of test let me know so we can compare results.
 =||= I've been experimenting with FieldUpdaters and Unsafe for the `SerializedObserver`. It seems that by using Unsafe directly and thus avoiding security checks and an indirection, I can get about 8-10% more throughput. The downsides are that it is scheduled to be removed/standardized in future Java versions and platform dependence in terms of availability. Should I pursue the Unsafe path?
 =||= @akarnokd since RxJava also runs on android, I'm not sure how good/standard the support is there.

I know that the netty folks are having the same issues and they are wrapping those Unsafe calles in a PlatformDependent util class.
 =||= > wrapping those Unsafe calles in a PlatformDependent util class.

This sounds like a valid approach for us. As we mature Rx we'll want to squeeze as much performance out of it as we can, while still remaining portable.
 =||= Testing with:

```
../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof GC .*PerfTransforms.*'
```

##### May 21st https://github.com/Netflix/RxJava/commit/0efda073f1068b105478145904d788b2206d7c4e

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4597237.797   227193.650    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    12334.190      214.479    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4522036.147   216489.787    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    12293.223      321.573    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  9133316.230   303274.438    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    19698.323      150.313    ops/s
```

##### May 26th https://github.com/Netflix/RxJava/commit/a34cba2bcd96f99e3a0d193009a7ce25775a4ad2

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4367166.623   145506.857    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    11382.233      425.976    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4468497.400    83649.115    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    11374.780      780.039    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  8851147.610   303583.393    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    19649.227     1134.279    ops/s
```

According to these results we got slower (though within mean error it appears, so if not slower, then no better).
 =||= Which Java version is this? Java 6 intrinsics isn't as good as the newer versions. Maybe the `wip` field in the merge operator causes more false sharing and needs padding.
 =||= /Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk
 =||= Master branch with /Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4378589.533   109056.155    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    10702.953      447.216    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4341206.933   184228.619    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10961.550      545.574    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  8996983.320   226242.030    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    19423.813      779.759    ops/s
```
 =||= Here is a [simple test](https://gist.github.com/benjchristensen/0e821794b0e510e0feed) without JMH (but using same coding pattern) that shows significant increases in throughput from 0.16 -> 0.17 -> 0.18 -> current master branch for this code:

``` java
    public void mapTransformation(UseCaseInput input) throws InterruptedException {
        input.observable.map(i -> {
            return String.valueOf(i);
        }).map(i -> {
            return Integer.parseInt(i);
        }).subscribe(input.observer);
        input.awaitCompletion();
    }
```

##### master

```
Run: 10 - 10,333,567 ops/sec 
Run: 11 - 10,235,100 ops/sec 
Run: 12 - 10,269,259 ops/sec 
Run: 13 - 10,170,560 ops/sec 
Run: 14 - 10,072,319 ops/sec 
```

##### Version 0.18.3

```
Run: 10 - 7,973,782 ops/sec 
Run: 11 - 8,695,425 ops/sec 
Run: 12 - 8,283,768 ops/sec 
Run: 13 - 8,283,562 ops/sec 
Run: 14 - 8,270,888 ops/sec 
```

##### Version 0.17.6 (using `OnSubscribe`)

```
Run: 10 - 7,812,927 ops/sec 
Run: 11 - 7,632,713 ops/sec 
Run: 12 - 7,488,673 ops/sec 
Run: 13 - 7,975,944 ops/sec 
Run: 14 - 7,882,146 ops/sec 
```

##### Version 0.17.6 (using `OnSubscribeFunc`)

```
Run: 10 - 7,049,700 ops/sec 
Run: 11 - 7,175,042 ops/sec 
Run: 12 - 7,173,240 ops/sec 
Run: 13 - 7,069,685 ops/sec 
Run: 14 - 7,248,320 ops/sec 
```

##### Version 0.16.1

```
Run: 10 - 4,765,899 ops/sec 
Run: 11 - 4,792,623 ops/sec 
Run: 12 - 4,709,982 ops/sec 
Run: 13 - 4,761,451 ops/sec 
Run: 14 - 4,769,627 ops/sec 
```
 =||= Very good progress! I'll get back to profiling from master next week.
 =||= I run some benchmarks with `AtomicInteger` and `volatile int` inside merge and it appears that JMH benchmark gives 10% more throughput with `AtomicInteger`.
 =||= Well that's odd and doesn't help much when two different ways of measuring are giving contradictory results :-(
 =||= We captured some profiling from a production instance and found evidence that suggests our atomic state machines are going to have to be changed or replaced.

---

The biggest allocation hotspot is creating `rx.Subscription[]` from `rx.subscriptions.CompositeSubscription$State.remove(Subscription)` and `rx.subscriptions.CompositeSubscription$State.add(Subscription)`.

This accounts for approximately 104GB of total allocations within the profile (~30% of total allocation).

There's also ~1.5GB allocated for rx.subjects.SubjectSubscriptionManager$State split pretty evenly from these 3 methods:

```
- rx.subjects.SubjectSubscriptionManager$State.createNewWith(SubjectSubscriptionManager$SubjectObserver[])
- rx.subjects.SubjectSubscriptionManager$State.terminate()
  - rx.subjects.SubjectSubscriptionManager.<init>()
```

Another ~1.2GB of allocations for `rx.subjects.SubjectSubscriptionManager$SubjectObserver[]` from 4 sources:

```
- rx.subjects.SubjectSubscriptionManager$State.<init>(boolean, CountDownLatch, SubjectSubscriptionManager$SubjectObserver[])
- rx.subjects.SubjectSubscriptionManager$State.<init>()
- java.util.Arrays.copyOf(Object[], int) called by rx.subjects.SubjectSubscriptionManager$State.addObserver(SubjectSubscriptionManager$SubjectObserver)
- rx.subjects.SubjectSubscriptionManager$State.removeObserver(SubjectSubscriptionManager$SubjectObserver)
```

Here's a list of top allocated rx.\* objects that exceed 100MB
(numbers are in bytes):

```
rx.Subscription[]                                           97,870,643,480
rx.subjects.SubjectSubscriptionManager$State                1,624,120,080
rx.subjects.SubjectSubscriptionManager$SubjectObserver[]    1,315,680,480
rx.subscriptions.Subscriptions$1                            849,212,800
rx.subscriptions.CompositeSubscription$State                837,518,872
rx.subscriptions.CompositeSubscription                      641,083,960
rx.observers.SafeSubscriber                                 637,599,560
rx.subjects.SubjectSubscriptionManager$SubjectObserver      618,721,656
rx.Observable$30                                            585,739,968
rx.operators.SafeObservableSubscription                     568,522,112
rx.subjects.SubjectSubscriptionManager$1                    545,755,280
rx.subjects.ReplaySubject$History                           528,269,104
rx.subjects.ReplaySubject                                   443,043,720
rx.Observable                                               395,292,296
rx.operators.OperatorMerge$1$InnerObserver                  370,883,064
rx.subjects.ReplaySubject$ReplayState                       340,267,192
rx.Observable$29                                            288,726,208
rx.operators.BlockingOperatorToFuture$2                     288,463,944
rx.subjects.SubjectSubscriptionManager                      281,230,064
rx.subjects.ReplaySubject$3                                 266,953,480
rx.subjects.ReplaySubject$2                                 260,071,464
rx.operators.BlockingOperatorToFuture$1                     256,919,568
rx.subjects.SubjectSubscriptionManager$1$1                  245,468,584
rx.subjects.ReplaySubject$1                                 238,637,944
rx.operators.OperatorCache                                  147,967,240
rx.observers.Subscribers$1                                  132,742,032
rx.subscriptions.BooleanSubscription                        107,733,248
rx.Observable$2                                             105,170,440
```
 =||= @benjchristensen Asked me to contribute a bit to this issue. We've been noticing some issues with RxJava 0.18.x through our use of Hystrix.

Let me setup our use case first to give you an idea of our usage pattern for this particular service. We have a pretty standard public API (think microservice, single-purpose) that does about 200/s incoming calls and fans that out into ~500-1000 command executions/s. This can burst to over 800/s incoming calls without warning.

The service is on a pretty modest deployment of c1.mediums, but it's also sitting at about 20% CPU normally. Since deploying Hystrix 1.3.16 w/ RxJava 0.18.2, our heaps that were previously steady sawtooths around 50-70mb have risen to over 150mb. Additionally, our CPU percentages really start to rise after a few days. This appears to be linked to our latencyTotal_mean times deviating far from our latencyExecute_mean. As you can see below, the command is decreasing in ops/s but the Hystrix overhead is rising. This rise continues for about 5 days to where it's taking anywhere from 20-30ms of Hystrix overhead and the boxes are running near 80-90% CPU.

![Command execution](https://lh3.googleusercontent.com/-rUdmvgGkn0k/U4ah34FBFdI/AAAAAAAAALE/amiC-VBzbV4/s1600/download+%282%29.png)

I took a heap dump of one of the production servers. I can provide it on request, but shown below is a piece I found interesting:

![Subscription objects](https://lh5.googleusercontent.com/-RoOTaW-h358/U4aohtaU4lI/AAAAAAAAALc/93tZ8ScAiG0/s1600/Screen+Shot+2014-05-28+at+9.23.36+PM.PNG)

Approximately 800K Subscriptions were present in the heap dump at the time, which really smells off to me. Even when I forced GCs they were sticking around. See the below, our heap usage was increasing over time:

![Heap usage](https://lh4.googleusercontent.com/-ZSx4hFVpVIg/U4af1dMwdeI/AAAAAAAAAK0/CXCMgBZM67I/s1600/Screen+Shot+2014-05-28+at+8.47.18+PM.PNG)

I started looking at the CompositeSubscription used by Hystrix, and really drilling into it, ran across this:

![CompositeSubscription array](https://dl.dropboxusercontent.com/u/11103618/Screenshots/rxjava-compositesubscription.png)

The subscription array on this has grown to 400K. Perhaps this is an edge case, but I believe that once it falls behind it really struggles to keep up. This would explain the non-linear jump in Hystrix overhead observed in the graph of the command execution time.

``` java
        State add(Subscription s) {
            int idx = subscriptions.length;
            Subscription[] newSubscriptions = new Subscription[idx + 1];
            System.arraycopy(subscriptions, 0, newSubscriptions, 0, idx);
            newSubscriptions[idx] = s;
            return new State(isUnsubscribed, newSubscriptions);
        }
```

For every addition, it's creating a brand new array and copying the new subscriptions into them? Is there a reason behind that? Removals then iterate the entire array and alloc a new array (usually  twice?):

``` java
        State remove(Subscription s) {
            if ((subscriptions.length == 1 && subscriptions[0].equals(s)) || subscriptions.length == 0) {
                return clear();
            }
            Subscription[] newSubscriptions = new Subscription[subscriptions.length - 1];
            int idx = 0;
            for (Subscription _s : subscriptions) {
                if (!_s.equals(s)) {
                    // was not in this composite
                    if (idx == newSubscriptions.length) {
                        return this;
                    }
                    newSubscriptions[idx] = _s;
                    idx++;
                }
            }
            if (idx == 0) {
                return clear();
            }
            // subscription appeared more than once
            if (idx < newSubscriptions.length) {
                Subscription[] newSub2 = new Subscription[idx];
                System.arraycopy(newSubscriptions, 0, newSub2, 0, idx);
                return new State(isUnsubscribed, newSub2);
            }
            return new State(isUnsubscribed, newSubscriptions);
        }
```

I don't have a misbehaving instance at the moment, but I'd wonder if profiling would show lots of CPU time spent in `remove()`

Unless I'm missing a key factor here, I'd think HashSet would be much more performant in this context for O(1) lookups & removals. I can't imagine that the overhead of the set entries would be more than memory copies. At the very least, an ArrayList would cut down on allocs & copies.

Let me know if I'm off base here. I'm very interested in helping resolve this issue.
 =||= Thanks for the details. CompositeSubscription becomes very slow when it grows over the size of the cache line in the CPU and constant add/remove is happening (see #1145).

Subscriptions$2 is perhaps the wrapper for Future, which keeps a final reference to the Future object, which generally shouldn't be a problem if its parent container is removing/clearing it.

What is worrying is that there is an unsubscribed `CompositeSubscription` with a non-empty array. When unsubscribed, `CompositeSubscription` should drop the entire array and don't accept any new additions. Could you tell where that `CompositeSubscription` is embedded?
 =||= Got it.

In our use case we're doing a `HystrixCommand#observe()` and passing the observable to 

``` java
    public static <T> ListenableFuture<T> toListenableFuture(Observable<T> observable) {
        final SettableFuture<T> listenableFuture = SettableFuture.create();
        final AtomicReference<Subscription> s = new AtomicReference<Subscription>();

        s.set(observable.subscribe(new Observer<T>() {
                                 @Override
                                 public void onCompleted() {
                                 }

                                 @Override
                                 public void onError(Throwable e) {
                                    listenableFuture.setException(e);
                                 }

                                 @Override
                                 public void onNext(T args) {
                                    if (listenableFuture.isDone()) {
                                        listenableFuture.setException(new IllegalStateException("Observable should only have a single value"));
                                    } else {
                                        listenableFuture.set(args);
                                    }
                                 }
                             }));

        return listenableFuture;
    }
```

This only happens ~50 times a second per server. `CompositeSubscription` is being used by `HystrixContextScheduler#ThreadPoolWorker` but from my investigation of the code it looks like these are recreated for each command invokation @benjchristensen, am I right about this?

In my heap dump, these 400,000-long arrays of Subscriptions seem to be actively being recycled and used, so somehow those CompositeSubscription instances are sticking around. I can't seem to identify where the ThreadPoolWorker instance might be getting reused though.
 =||= @Xorlev Thanks for the detailed post, very helpful to have another set of clues beyond what we've been seeing.

> I'd think HashSet would be much more performant in this context for O(1) lookups & removals. I can't imagine that the overhead of the set entries would be more than memory copies. At the very least, an ArrayList would cut down on allocs & copies.

For the use cases we appear to be triggering, definitely yes. This is partially what @akarnokd was seeking to solve in https://github.com/Netflix/RxJava/pull/1145. 

When we designed the current implementation of `CompositeSubscription` we used an atomic state machine as the expectation was that there should never be more than a handful of `Subscription`s added to it and we were trying to avoid mutable state needing to be protected by locks, and that the extra object allocations to allow use of compareAndSet was okay. 

Performance testing we've done has shown this to be a win (in the cases we've been testing) but obviously there are cases where this is breaking badly.

So, we can pivot to using a mutable data structure protected by locks to avoid the object allocation (such [as this](https://gist.github.com/benjchristensen/541c2dbb5fca94ee4155)), but right now I'm still trying to identify the use cases that are causing this.

> What is worrying is that there is an unsubscribed CompositeSubscription with a non-empty array. When unsubscribed, CompositeSubscription should drop the entire array and don't accept any new additions. Could you tell where that CompositeSubscription is embedded?

This is an open question. We see the same symptom in our production environment, though not sure if it's an actual leak, or just such high pressure that the GC can't keep up so it looks like they are leaking.

Researching further today ... 
 =||= > `HystrixContextScheduler#ThreadPoolWorker`

Yes, that is just a thin wrapper around a real `Scheduler` used by Hystrix to copy state across threads. It is allocated for each command.

>  these 400,000-long arrays of Subscriptions seem to be actively being recycled and used, so somehow those CompositeSubscription instances are sticking around

That is the key problem I'm trying to find today. I'm going to focus on the Hystrix use cases since it's the one that triggers it. Seems it is either a bug in how Hystrix is using Rx, or it's triggering a bug or unexpected use case in Rx that we need to handle.
 =||= If it's helpful, I also found this interesting, which lead me down the path of investigating `CompositeSubscription$State`

![Stack](https://dl.dropboxusercontent.com/u/11103618/Screenshots/rxjava-subremoval.png)

I can put the heap dump on Dropbox and email you a link if it'd be helpful, Ben.
 =||= That is helpful. It points to looking at the `EventLoopScheduler`.
 =||= This is creating lots of `ArrayList` instances unnecessarily: 
https://github.com/Netflix/RxJava/blob/0.18.2/rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java#L172

![screen shot 2014-05-29 at 10 35 48 am](https://cloud.githubusercontent.com/assets/813492/3120998/b281d270-e757-11e3-82f4-0c4fb645e6a7.png)
![screen shot 2014-05-29 at 10 37 45 am](https://cloud.githubusercontent.com/assets/813492/3121021/f843b5a8-e757-11e3-83c5-b18f251952d9.png)
 =||= ![replaystate-arraylist-object](https://cloud.githubusercontent.com/assets/813492/3121057/4f67c9dc-e758-11e3-8f4b-8e9e9c12372c.png)
 =||= ![hystrix rx-with-0 18 2](https://cloud.githubusercontent.com/assets/813492/3121117/ec086eae-e758-11e3-9d54-43bb8b647199.png)
 =||= Those were from 0.18.2 ... now with Master, plus a [modified](https://gist.github.com/benjchristensen/541c2dbb5fca94ee4155) `CompositeSubscription` we get this:

![hystrix rx-with-master new-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3121129/1ce1746c-e759-11e3-918c-4d6e97c92dc2.png)
 =||= Here is evidence for need of work on `ReplaySubject`:

![replaysubject-1](https://cloud.githubusercontent.com/assets/813492/3121171/8a1b7a6e-e759-11e3-85bc-270167719e34.png)

![replaysubject-2](https://cloud.githubusercontent.com/assets/813492/3121172/8cd26e02-e759-11e3-9544-70f900a80890.png)

![replaysubject-3](https://cloud.githubusercontent.com/assets/813492/3121174/8f90fa46-e759-11e3-8680-898da7e2b3a9.png)
 =||= ![0 18 2-map observeon](https://cloud.githubusercontent.com/assets/813492/3121261/76d1a61c-e75a-11e3-82c4-96e59ac1ddfa.png)

![master-map observeon](https://cloud.githubusercontent.com/assets/813492/3121263/7b1c9600-e75a-11e3-96a7-56e30df059cf.png)
 =||= The `Subscription[]` issue is definitely being caused by the use of a `Scheduler`. Here is some evidence:

![subscription-array-when-using-scheduler](https://cloud.githubusercontent.com/assets/813492/3121292/c1c39f54-e75a-11e3-97b9-5ba75cdb040b.png)

Then the master branch with `CompositeSubscription` change:

![screen shot 2014-05-29 at 10 58 09 am](https://cloud.githubusercontent.com/assets/813492/3121303/d65be0fc-e75a-11e3-8902-5f9ead818735.png)

The issue is definitely the `CompositeSubscription` as the following shows where it is master as it currently stands without my changes to `CompositeSubscription`:

![master-without-changing-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3121347/3f171634-e75b-11e3-9246-aff40bf88eeb.png)
 =||= I've added some logging to our production instances and discovered that the cause of large Subscription arrays we see in practice is caused by a prefetching operation which generates many (> 500) `HystrixCommand`s, calls `observe` on them, puts them in an ArrayList, and finally calls `Observable.merge` on this list to have a single place to listen for overall completion.

This seems like a valid case to support and any work which improves performance for large Subscription arrays would be a meaningful improvement.
 =||= I have submitted a pull request for this: https://github.com/Netflix/RxJava/pull/1281

We are testing the code in our environment shortly.
 =||= For anyone wanting to dig into this, Java Flight Recorder has been very helpful, and far better than the other profiling tools I've used and tried for this.
 =||= Backporting to 0.18.x in https://github.com/Netflix/RxJava/pull/1283
 =||= Superb work guys, I've held off on 18.x on Android as I noticed an increase in GC, really glad you guys take this seriously!
 =||= Thanks @chrisjenx ... it looks like the most glaring issues are resolved, and low hanging fruit taken care of. There are a few other things for us to improve on, but I think we'll release 0.19 early next week. I would appreciate your feedback on whether you see an improvement.

I have also opened https://github.com/Netflix/RxJava/issues/1299 to document our attempts on blocking vs non-blocking implementations and to seek input from anyone who can provide better solutions.
 =||= @akarnokd Is there anything else that stands out to you that we should fix before closing this issue? I'll continue doing some profiling but it seems the obvious ones are done.

We'll continue working on performance going forward and those can have their own issues and pull requests, so if nothing else obvious stands out let's close this issue and not leave it open-ended.
 =||= The history List in ReplaySubject; since ArrayList uses more memory then actual items, it might be worth compacting it on a terminal state (one time, but might be costly and run out of memory). Alternatively, it could use fixed increment expansion strategy. Third option is to have a cache() overload that passes in a capacity hint to reduce reallocation and wasted space.
 =||= I think that the object allocation penalty of resizing after a terminal event would be worse.

A cache() overload that takes a capacity hint may be valuable, particularly in the single item case where it could just a single volatile ref instead of an array.  
 =||= I have opened a new issue for the cache() overload: https://github.com/Netflix/RxJava/issues/1303
 =||= I'm closing this issue out as I believe we have handled the most glaring problems and don't want this to be a never-ending issue. We will of course continue seeking to improve performance, but let's use individual issues for each improvement/problem we find.

Thanks everyone for your involvement on this one as it was rather significant and important.

@Xorlev and @daschl I would appreciate feedback once you've had a chance to try the changes in the master branch (or the portion that was backported to 0.18.4) to know if you see the improvements or still have issues. @Xorlev In particular I'd like to know if the issue you had was only the GC pressure, or if you still see signs of a memory leak (which I have not seen yet).
 =||= @benjchristensen Hystrix 1.3.16 w/ RxJava 0.18.4 has been in prod for about a day now, I'm happy to report a decrease in garbage (and CPU usage in general). I believe the pressure & the suboptimal subscription removal was causing the leak-like behavior. @mattrjacobs's use case matches a few of our own (fan out commands, wait on all), which is likely the source of the large numbers of subscriptions.

I'll keep an eye out for any similar issues that might crop up.

Thanks a lot for all the help and dedication to improving RxJava.
 =||= Excellent. Thank you @Xorlev for the confirmation. I'll release Hystrix 1.3.17 in a few days hopefully with RxJava 0.19 as a dependency, and at least one performance optimization I found I can do in Hystrix directly.
 =||= ,0
1237,1204,Profiling Memory Usage and Object Creation,We need to spend time profiling memory and object allocation and finding places where we can improve. 

I would really appreciate help diving into this and finding problem areas. Even if you don't fix them, but just identity use cases, operators, etc that would be very valuable.

This is partly a result of the fact that in Netflix production we have seen an increase in YoungGen GCs since 0.17.x.

The areas to start should probably be:
- Observable.create
- Observable.lift
- Subscriber
- CompositeSubscription
- map
- flatMap

If you can or want to get involved in this please comment here so we all can collaborate together.,The most likely source of garbage is the `CompositeSubscription`: whenever a task is scheduled or a new merge-source appears, the state transition creates a new State object and copies the subscription array. PR #1145 reduces the amount of garbage by switching to HashSet on a larger composite. Since flatMap->mergeMap->merge needs to track the active inner subscriptions, it uses a composite as well and would gain the same benefits.
 =||= The `HashSet` change shouldn't kick in though because these aren't generally large lists (handful at most, not hundreds). I expect it's just far too many of them being created.
 =||= I'll also like to help out here, since its crucial for our uses as well. 
 =||= Thanks @daschl I'd appreciate your help. Profiling and identifying hot spots is what we need most right now.
 =||= I did some GC profiling of my test workloads and I'd also like to nominate:
- BlockingObservable (it seems that especially in the .single() case its not optimized)
- Observable.subscribe (for both Observer and Subscriber) - in my GC logs they take up 40% of the overall GC pressure.

The bad news is that i had to fall back out of Observables to plain execution on the hot code path (aside from the overall wrapping observable), because also using it in the path produces way too much garbage (moving away from Rx in the hot code path got my throughput from 20% to 80% according to the GC logs) and it correlates with my findings since I could not sustain constant IO throughput because of full GCs happening way too frequently.
 =||= > Observable.subscribe (for both Observer and Subscriber)

Not surprised on this. Were you able to identify what the garbage is? 
 =||= I did some changes in my code and will re-profile and post the results here so we get better measurements. 

Here is a slightly older profile run which might give you a hint or two.
![screen shot 2014-05-20 at 10 13 10](https://cloud.githubusercontent.com/assets/29086/3024320/a10a2a64-dff6-11e3-8f2c-3473bdfc7af7.png)
![screen shot 2014-05-20 at 10 13 00](https://cloud.githubusercontent.com/assets/29086/3024319/a1096bba-dff6-11e3-9c92-0177913e5c47.png)
 =||= We can definitely improve on the `AtomicReference` by using AtomicFieldUpdater. The others will require more effort to analyze along with sample code to see what's triggering them.
 =||= I think that many `AtomicReference` come from mostly the `CompositeSubscription` instances.
 =||= I went back in history to 0.16.1 to compare performance of the basic `map`/`flatMap` behavior and found that current master is faster. This fits what I had expected of the work of the past couple months, which means it's not an obvious glaring issue (unless my test is completely flawed).

Here is the code for the test:
- Branch 0.16 => https://github.com/benjchristensen/RxJava/blob/0.16-perf/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java
- Master => https://github.com/benjchristensen/RxJava/blob/performance/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java

### Results

#### 0.16

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  2421210.583    68845.966    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     1017.787       73.597    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  2398541.067    90703.197    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5      990.623      100.735    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  4020548.060   262841.500    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    16205.747      352.618    ops/s
```

#### Master

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3184873.133   172320.420    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9079.937      343.905    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3411785.677    73767.161    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10860.963      294.309    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  7208334.997   703327.745    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    18720.797      278.529    ops/s
```

### GC

On the master branch test I'm seeing GC results like this:

```
Iteration   5: 3189218.350 ops/s
          GC | wall time = 5.001 secs,  GC time = 0.047 secs, GC% = 0.94%, GC count = +98
Iteration   5: 9198.700 ops/s
          GC | wall time = 5.002 secs,  GC time = 0.048 secs, GC% = 0.96%, GC count = +98
```

versus 0.16

```
Iteration   5: 2420099.017 ops/s
          GC | wall time = 5.000 secs,  GC time = 0.046 secs, GC% = 0.92%, GC count = +96
Iteration   5: 993.867 ops/s
          GC | wall time = 5.001 secs,  GC time = 0.100 secs, GC% = 2.00%, GC count = +212
```

### Summary

Unless I'm mistaken, current code is better:
- similar GC behavior on `Observable` with 1 item, better GC behavior with 1024 items
- higher ops/second on all of the map/flatMap tests

I'll start profiling this and improve ... but this does not reveal the source of the problems seen. Possibly it's related to schedulers, or it's a specific operator. I exercised `map`, `flatMap` (and thus `merge`), `Observable` and `Subscribe` here to get the most fundamental ones.
 =||= The `observeOn` test shows the cost of scheduling ... particularly `Observable`s of a single item.

``` java
    @GenerateMicroBenchmark
    public void observeOn(UseCaseInput input) throws InterruptedException {
        input.observable.observeOn(Schedulers.computation()).subscribe(input.observer);
        input.awaitCompletion();
    }
```

```
r.u.PerfObserveOn.observeOn        1  thrpt         5   457830.180     9943.221    ops/s
r.u.PerfObserveOn.observeOn     1024  thrpt         5    14496.430      518.463    ops/s
```

Thus, with an `Observable` of 1 item we can do 457k onNext/second, with an `Observable` of 1024 items we can do 14.8million onNext/second (14.5k \* 1024).
 =||= By the way, all testing is just being done on my Mac laptop ... so these numbers are all relative and not representative of proper server hardware.
 =||= Converting from `AtomicReference` to `AtomicReferenceFieldUpdater` improved performance from this:

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3184873.133   172320.420    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9079.937      343.905    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3411785.677    73767.161    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10860.963      294.309    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  7208334.997   703327.745    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    18720.797      278.529    ops/s
```

to this:

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3459205.110   124790.906    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9225.037      604.720    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3639603.060   225599.038    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    11135.613      337.022    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  7264202.633   214787.109    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    18795.790      713.668    ops/s
```
 =||= @benjchristensen I suppose the `AtomicReferenceFieldUpdater` mostly comes from less GC pressure, is that why the raw throughput increases in your tests? How did the GC wall time change?
 =||= If you want me to run a specific workload/type of test let me know so we can compare results.
 =||= I've been experimenting with FieldUpdaters and Unsafe for the `SerializedObserver`. It seems that by using Unsafe directly and thus avoiding security checks and an indirection, I can get about 8-10% more throughput. The downsides are that it is scheduled to be removed/standardized in future Java versions and platform dependence in terms of availability. Should I pursue the Unsafe path?
 =||= @akarnokd since RxJava also runs on android, I'm not sure how good/standard the support is there.

I know that the netty folks are having the same issues and they are wrapping those Unsafe calles in a PlatformDependent util class.
 =||= > wrapping those Unsafe calles in a PlatformDependent util class.

This sounds like a valid approach for us. As we mature Rx we'll want to squeeze as much performance out of it as we can, while still remaining portable.
 =||= Testing with:

```
../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof GC .*PerfTransforms.*'
```

##### May 21st https://github.com/Netflix/RxJava/commit/0efda073f1068b105478145904d788b2206d7c4e

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4597237.797   227193.650    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    12334.190      214.479    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4522036.147   216489.787    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    12293.223      321.573    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  9133316.230   303274.438    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    19698.323      150.313    ops/s
```

##### May 26th https://github.com/Netflix/RxJava/commit/a34cba2bcd96f99e3a0d193009a7ce25775a4ad2

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4367166.623   145506.857    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    11382.233      425.976    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4468497.400    83649.115    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    11374.780      780.039    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  8851147.610   303583.393    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    19649.227     1134.279    ops/s
```

According to these results we got slower (though within mean error it appears, so if not slower, then no better).
 =||= Which Java version is this? Java 6 intrinsics isn't as good as the newer versions. Maybe the `wip` field in the merge operator causes more false sharing and needs padding.
 =||= /Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk
 =||= Master branch with /Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4378589.533   109056.155    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    10702.953      447.216    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4341206.933   184228.619    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10961.550      545.574    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  8996983.320   226242.030    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    19423.813      779.759    ops/s
```
 =||= Here is a [simple test](https://gist.github.com/benjchristensen/0e821794b0e510e0feed) without JMH (but using same coding pattern) that shows significant increases in throughput from 0.16 -> 0.17 -> 0.18 -> current master branch for this code:

``` java
    public void mapTransformation(UseCaseInput input) throws InterruptedException {
        input.observable.map(i -> {
            return String.valueOf(i);
        }).map(i -> {
            return Integer.parseInt(i);
        }).subscribe(input.observer);
        input.awaitCompletion();
    }
```

##### master

```
Run: 10 - 10,333,567 ops/sec 
Run: 11 - 10,235,100 ops/sec 
Run: 12 - 10,269,259 ops/sec 
Run: 13 - 10,170,560 ops/sec 
Run: 14 - 10,072,319 ops/sec 
```

##### Version 0.18.3

```
Run: 10 - 7,973,782 ops/sec 
Run: 11 - 8,695,425 ops/sec 
Run: 12 - 8,283,768 ops/sec 
Run: 13 - 8,283,562 ops/sec 
Run: 14 - 8,270,888 ops/sec 
```

##### Version 0.17.6 (using `OnSubscribe`)

```
Run: 10 - 7,812,927 ops/sec 
Run: 11 - 7,632,713 ops/sec 
Run: 12 - 7,488,673 ops/sec 
Run: 13 - 7,975,944 ops/sec 
Run: 14 - 7,882,146 ops/sec 
```

##### Version 0.17.6 (using `OnSubscribeFunc`)

```
Run: 10 - 7,049,700 ops/sec 
Run: 11 - 7,175,042 ops/sec 
Run: 12 - 7,173,240 ops/sec 
Run: 13 - 7,069,685 ops/sec 
Run: 14 - 7,248,320 ops/sec 
```

##### Version 0.16.1

```
Run: 10 - 4,765,899 ops/sec 
Run: 11 - 4,792,623 ops/sec 
Run: 12 - 4,709,982 ops/sec 
Run: 13 - 4,761,451 ops/sec 
Run: 14 - 4,769,627 ops/sec 
```
 =||= Very good progress! I'll get back to profiling from master next week.
 =||= I run some benchmarks with `AtomicInteger` and `volatile int` inside merge and it appears that JMH benchmark gives 10% more throughput with `AtomicInteger`.
 =||= Well that's odd and doesn't help much when two different ways of measuring are giving contradictory results :-(
 =||= We captured some profiling from a production instance and found evidence that suggests our atomic state machines are going to have to be changed or replaced.

---

The biggest allocation hotspot is creating `rx.Subscription[]` from `rx.subscriptions.CompositeSubscription$State.remove(Subscription)` and `rx.subscriptions.CompositeSubscription$State.add(Subscription)`.

This accounts for approximately 104GB of total allocations within the profile (~30% of total allocation).

There's also ~1.5GB allocated for rx.subjects.SubjectSubscriptionManager$State split pretty evenly from these 3 methods:

```
- rx.subjects.SubjectSubscriptionManager$State.createNewWith(SubjectSubscriptionManager$SubjectObserver[])
- rx.subjects.SubjectSubscriptionManager$State.terminate()
  - rx.subjects.SubjectSubscriptionManager.<init>()
```

Another ~1.2GB of allocations for `rx.subjects.SubjectSubscriptionManager$SubjectObserver[]` from 4 sources:

```
- rx.subjects.SubjectSubscriptionManager$State.<init>(boolean, CountDownLatch, SubjectSubscriptionManager$SubjectObserver[])
- rx.subjects.SubjectSubscriptionManager$State.<init>()
- java.util.Arrays.copyOf(Object[], int) called by rx.subjects.SubjectSubscriptionManager$State.addObserver(SubjectSubscriptionManager$SubjectObserver)
- rx.subjects.SubjectSubscriptionManager$State.removeObserver(SubjectSubscriptionManager$SubjectObserver)
```

Here's a list of top allocated rx.\* objects that exceed 100MB
(numbers are in bytes):

```
rx.Subscription[]                                           97,870,643,480
rx.subjects.SubjectSubscriptionManager$State                1,624,120,080
rx.subjects.SubjectSubscriptionManager$SubjectObserver[]    1,315,680,480
rx.subscriptions.Subscriptions$1                            849,212,800
rx.subscriptions.CompositeSubscription$State                837,518,872
rx.subscriptions.CompositeSubscription                      641,083,960
rx.observers.SafeSubscriber                                 637,599,560
rx.subjects.SubjectSubscriptionManager$SubjectObserver      618,721,656
rx.Observable$30                                            585,739,968
rx.operators.SafeObservableSubscription                     568,522,112
rx.subjects.SubjectSubscriptionManager$1                    545,755,280
rx.subjects.ReplaySubject$History                           528,269,104
rx.subjects.ReplaySubject                                   443,043,720
rx.Observable                                               395,292,296
rx.operators.OperatorMerge$1$InnerObserver                  370,883,064
rx.subjects.ReplaySubject$ReplayState                       340,267,192
rx.Observable$29                                            288,726,208
rx.operators.BlockingOperatorToFuture$2                     288,463,944
rx.subjects.SubjectSubscriptionManager                      281,230,064
rx.subjects.ReplaySubject$3                                 266,953,480
rx.subjects.ReplaySubject$2                                 260,071,464
rx.operators.BlockingOperatorToFuture$1                     256,919,568
rx.subjects.SubjectSubscriptionManager$1$1                  245,468,584
rx.subjects.ReplaySubject$1                                 238,637,944
rx.operators.OperatorCache                                  147,967,240
rx.observers.Subscribers$1                                  132,742,032
rx.subscriptions.BooleanSubscription                        107,733,248
rx.Observable$2                                             105,170,440
```
 =||= @benjchristensen Asked me to contribute a bit to this issue. We've been noticing some issues with RxJava 0.18.x through our use of Hystrix.

Let me setup our use case first to give you an idea of our usage pattern for this particular service. We have a pretty standard public API (think microservice, single-purpose) that does about 200/s incoming calls and fans that out into ~500-1000 command executions/s. This can burst to over 800/s incoming calls without warning.

The service is on a pretty modest deployment of c1.mediums, but it's also sitting at about 20% CPU normally. Since deploying Hystrix 1.3.16 w/ RxJava 0.18.2, our heaps that were previously steady sawtooths around 50-70mb have risen to over 150mb. Additionally, our CPU percentages really start to rise after a few days. This appears to be linked to our latencyTotal_mean times deviating far from our latencyExecute_mean. As you can see below, the command is decreasing in ops/s but the Hystrix overhead is rising. This rise continues for about 5 days to where it's taking anywhere from 20-30ms of Hystrix overhead and the boxes are running near 80-90% CPU.

![Command execution](https://lh3.googleusercontent.com/-rUdmvgGkn0k/U4ah34FBFdI/AAAAAAAAALE/amiC-VBzbV4/s1600/download+%282%29.png)

I took a heap dump of one of the production servers. I can provide it on request, but shown below is a piece I found interesting:

![Subscription objects](https://lh5.googleusercontent.com/-RoOTaW-h358/U4aohtaU4lI/AAAAAAAAALc/93tZ8ScAiG0/s1600/Screen+Shot+2014-05-28+at+9.23.36+PM.PNG)

Approximately 800K Subscriptions were present in the heap dump at the time, which really smells off to me. Even when I forced GCs they were sticking around. See the below, our heap usage was increasing over time:

![Heap usage](https://lh4.googleusercontent.com/-ZSx4hFVpVIg/U4af1dMwdeI/AAAAAAAAAK0/CXCMgBZM67I/s1600/Screen+Shot+2014-05-28+at+8.47.18+PM.PNG)

I started looking at the CompositeSubscription used by Hystrix, and really drilling into it, ran across this:

![CompositeSubscription array](https://dl.dropboxusercontent.com/u/11103618/Screenshots/rxjava-compositesubscription.png)

The subscription array on this has grown to 400K. Perhaps this is an edge case, but I believe that once it falls behind it really struggles to keep up. This would explain the non-linear jump in Hystrix overhead observed in the graph of the command execution time.

``` java
        State add(Subscription s) {
            int idx = subscriptions.length;
            Subscription[] newSubscriptions = new Subscription[idx + 1];
            System.arraycopy(subscriptions, 0, newSubscriptions, 0, idx);
            newSubscriptions[idx] = s;
            return new State(isUnsubscribed, newSubscriptions);
        }
```

For every addition, it's creating a brand new array and copying the new subscriptions into them? Is there a reason behind that? Removals then iterate the entire array and alloc a new array (usually  twice?):

``` java
        State remove(Subscription s) {
            if ((subscriptions.length == 1 && subscriptions[0].equals(s)) || subscriptions.length == 0) {
                return clear();
            }
            Subscription[] newSubscriptions = new Subscription[subscriptions.length - 1];
            int idx = 0;
            for (Subscription _s : subscriptions) {
                if (!_s.equals(s)) {
                    // was not in this composite
                    if (idx == newSubscriptions.length) {
                        return this;
                    }
                    newSubscriptions[idx] = _s;
                    idx++;
                }
            }
            if (idx == 0) {
                return clear();
            }
            // subscription appeared more than once
            if (idx < newSubscriptions.length) {
                Subscription[] newSub2 = new Subscription[idx];
                System.arraycopy(newSubscriptions, 0, newSub2, 0, idx);
                return new State(isUnsubscribed, newSub2);
            }
            return new State(isUnsubscribed, newSubscriptions);
        }
```

I don't have a misbehaving instance at the moment, but I'd wonder if profiling would show lots of CPU time spent in `remove()`

Unless I'm missing a key factor here, I'd think HashSet would be much more performant in this context for O(1) lookups & removals. I can't imagine that the overhead of the set entries would be more than memory copies. At the very least, an ArrayList would cut down on allocs & copies.

Let me know if I'm off base here. I'm very interested in helping resolve this issue.
 =||= Thanks for the details. CompositeSubscription becomes very slow when it grows over the size of the cache line in the CPU and constant add/remove is happening (see #1145).

Subscriptions$2 is perhaps the wrapper for Future, which keeps a final reference to the Future object, which generally shouldn't be a problem if its parent container is removing/clearing it.

What is worrying is that there is an unsubscribed `CompositeSubscription` with a non-empty array. When unsubscribed, `CompositeSubscription` should drop the entire array and don't accept any new additions. Could you tell where that `CompositeSubscription` is embedded?
 =||= Got it.

In our use case we're doing a `HystrixCommand#observe()` and passing the observable to 

``` java
    public static <T> ListenableFuture<T> toListenableFuture(Observable<T> observable) {
        final SettableFuture<T> listenableFuture = SettableFuture.create();
        final AtomicReference<Subscription> s = new AtomicReference<Subscription>();

        s.set(observable.subscribe(new Observer<T>() {
                                 @Override
                                 public void onCompleted() {
                                 }

                                 @Override
                                 public void onError(Throwable e) {
                                    listenableFuture.setException(e);
                                 }

                                 @Override
                                 public void onNext(T args) {
                                    if (listenableFuture.isDone()) {
                                        listenableFuture.setException(new IllegalStateException("Observable should only have a single value"));
                                    } else {
                                        listenableFuture.set(args);
                                    }
                                 }
                             }));

        return listenableFuture;
    }
```

This only happens ~50 times a second per server. `CompositeSubscription` is being used by `HystrixContextScheduler#ThreadPoolWorker` but from my investigation of the code it looks like these are recreated for each command invokation @benjchristensen, am I right about this?

In my heap dump, these 400,000-long arrays of Subscriptions seem to be actively being recycled and used, so somehow those CompositeSubscription instances are sticking around. I can't seem to identify where the ThreadPoolWorker instance might be getting reused though.
 =||= @Xorlev Thanks for the detailed post, very helpful to have another set of clues beyond what we've been seeing.

> I'd think HashSet would be much more performant in this context for O(1) lookups & removals. I can't imagine that the overhead of the set entries would be more than memory copies. At the very least, an ArrayList would cut down on allocs & copies.

For the use cases we appear to be triggering, definitely yes. This is partially what @akarnokd was seeking to solve in https://github.com/Netflix/RxJava/pull/1145. 

When we designed the current implementation of `CompositeSubscription` we used an atomic state machine as the expectation was that there should never be more than a handful of `Subscription`s added to it and we were trying to avoid mutable state needing to be protected by locks, and that the extra object allocations to allow use of compareAndSet was okay. 

Performance testing we've done has shown this to be a win (in the cases we've been testing) but obviously there are cases where this is breaking badly.

So, we can pivot to using a mutable data structure protected by locks to avoid the object allocation (such [as this](https://gist.github.com/benjchristensen/541c2dbb5fca94ee4155)), but right now I'm still trying to identify the use cases that are causing this.

> What is worrying is that there is an unsubscribed CompositeSubscription with a non-empty array. When unsubscribed, CompositeSubscription should drop the entire array and don't accept any new additions. Could you tell where that CompositeSubscription is embedded?

This is an open question. We see the same symptom in our production environment, though not sure if it's an actual leak, or just such high pressure that the GC can't keep up so it looks like they are leaking.

Researching further today ... 
 =||= > `HystrixContextScheduler#ThreadPoolWorker`

Yes, that is just a thin wrapper around a real `Scheduler` used by Hystrix to copy state across threads. It is allocated for each command.

>  these 400,000-long arrays of Subscriptions seem to be actively being recycled and used, so somehow those CompositeSubscription instances are sticking around

That is the key problem I'm trying to find today. I'm going to focus on the Hystrix use cases since it's the one that triggers it. Seems it is either a bug in how Hystrix is using Rx, or it's triggering a bug or unexpected use case in Rx that we need to handle.
 =||= If it's helpful, I also found this interesting, which lead me down the path of investigating `CompositeSubscription$State`

![Stack](https://dl.dropboxusercontent.com/u/11103618/Screenshots/rxjava-subremoval.png)

I can put the heap dump on Dropbox and email you a link if it'd be helpful, Ben.
 =||= That is helpful. It points to looking at the `EventLoopScheduler`.
 =||= This is creating lots of `ArrayList` instances unnecessarily: 
https://github.com/Netflix/RxJava/blob/0.18.2/rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java#L172

![screen shot 2014-05-29 at 10 35 48 am](https://cloud.githubusercontent.com/assets/813492/3120998/b281d270-e757-11e3-82f4-0c4fb645e6a7.png)
![screen shot 2014-05-29 at 10 37 45 am](https://cloud.githubusercontent.com/assets/813492/3121021/f843b5a8-e757-11e3-83c5-b18f251952d9.png)
 =||= ![replaystate-arraylist-object](https://cloud.githubusercontent.com/assets/813492/3121057/4f67c9dc-e758-11e3-8f4b-8e9e9c12372c.png)
 =||= ![hystrix rx-with-0 18 2](https://cloud.githubusercontent.com/assets/813492/3121117/ec086eae-e758-11e3-9d54-43bb8b647199.png)
 =||= Those were from 0.18.2 ... now with Master, plus a [modified](https://gist.github.com/benjchristensen/541c2dbb5fca94ee4155) `CompositeSubscription` we get this:

![hystrix rx-with-master new-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3121129/1ce1746c-e759-11e3-918c-4d6e97c92dc2.png)
 =||= Here is evidence for need of work on `ReplaySubject`:

![replaysubject-1](https://cloud.githubusercontent.com/assets/813492/3121171/8a1b7a6e-e759-11e3-85bc-270167719e34.png)

![replaysubject-2](https://cloud.githubusercontent.com/assets/813492/3121172/8cd26e02-e759-11e3-9544-70f900a80890.png)

![replaysubject-3](https://cloud.githubusercontent.com/assets/813492/3121174/8f90fa46-e759-11e3-8680-898da7e2b3a9.png)
 =||= ![0 18 2-map observeon](https://cloud.githubusercontent.com/assets/813492/3121261/76d1a61c-e75a-11e3-82c4-96e59ac1ddfa.png)

![master-map observeon](https://cloud.githubusercontent.com/assets/813492/3121263/7b1c9600-e75a-11e3-96a7-56e30df059cf.png)
 =||= The `Subscription[]` issue is definitely being caused by the use of a `Scheduler`. Here is some evidence:

![subscription-array-when-using-scheduler](https://cloud.githubusercontent.com/assets/813492/3121292/c1c39f54-e75a-11e3-97b9-5ba75cdb040b.png)

Then the master branch with `CompositeSubscription` change:

![screen shot 2014-05-29 at 10 58 09 am](https://cloud.githubusercontent.com/assets/813492/3121303/d65be0fc-e75a-11e3-8902-5f9ead818735.png)

The issue is definitely the `CompositeSubscription` as the following shows where it is master as it currently stands without my changes to `CompositeSubscription`:

![master-without-changing-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3121347/3f171634-e75b-11e3-9246-aff40bf88eeb.png)
 =||= I've added some logging to our production instances and discovered that the cause of large Subscription arrays we see in practice is caused by a prefetching operation which generates many (> 500) `HystrixCommand`s, calls `observe` on them, puts them in an ArrayList, and finally calls `Observable.merge` on this list to have a single place to listen for overall completion.

This seems like a valid case to support and any work which improves performance for large Subscription arrays would be a meaningful improvement.
 =||= I have submitted a pull request for this: https://github.com/Netflix/RxJava/pull/1281

We are testing the code in our environment shortly.
 =||= For anyone wanting to dig into this, Java Flight Recorder has been very helpful, and far better than the other profiling tools I've used and tried for this.
 =||= Backporting to 0.18.x in https://github.com/Netflix/RxJava/pull/1283
 =||= Superb work guys, I've held off on 18.x on Android as I noticed an increase in GC, really glad you guys take this seriously!
 =||= Thanks @chrisjenx ... it looks like the most glaring issues are resolved, and low hanging fruit taken care of. There are a few other things for us to improve on, but I think we'll release 0.19 early next week. I would appreciate your feedback on whether you see an improvement.

I have also opened https://github.com/Netflix/RxJava/issues/1299 to document our attempts on blocking vs non-blocking implementations and to seek input from anyone who can provide better solutions.
 =||= @akarnokd Is there anything else that stands out to you that we should fix before closing this issue? I'll continue doing some profiling but it seems the obvious ones are done.

We'll continue working on performance going forward and those can have their own issues and pull requests, so if nothing else obvious stands out let's close this issue and not leave it open-ended.
 =||= The history List in ReplaySubject; since ArrayList uses more memory then actual items, it might be worth compacting it on a terminal state (one time, but might be costly and run out of memory). Alternatively, it could use fixed increment expansion strategy. Third option is to have a cache() overload that passes in a capacity hint to reduce reallocation and wasted space.
 =||= I think that the object allocation penalty of resizing after a terminal event would be worse.

A cache() overload that takes a capacity hint may be valuable, particularly in the single item case where it could just a single volatile ref instead of an array.  
 =||= I have opened a new issue for the cache() overload: https://github.com/Netflix/RxJava/issues/1303
 =||= I'm closing this issue out as I believe we have handled the most glaring problems and don't want this to be a never-ending issue. We will of course continue seeking to improve performance, but let's use individual issues for each improvement/problem we find.

Thanks everyone for your involvement on this one as it was rather significant and important.

@Xorlev and @daschl I would appreciate feedback once you've had a chance to try the changes in the master branch (or the portion that was backported to 0.18.4) to know if you see the improvements or still have issues. @Xorlev In particular I'd like to know if the issue you had was only the GC pressure, or if you still see signs of a memory leak (which I have not seen yet).
 =||= @benjchristensen Hystrix 1.3.16 w/ RxJava 0.18.4 has been in prod for about a day now, I'm happy to report a decrease in garbage (and CPU usage in general). I believe the pressure & the suboptimal subscription removal was causing the leak-like behavior. @mattrjacobs's use case matches a few of our own (fan out commands, wait on all), which is likely the source of the large numbers of subscriptions.

I'll keep an eye out for any similar issues that might crop up.

Thanks a lot for all the help and dedication to improving RxJava.
 =||= Excellent. Thank you @Xorlev for the confirmation. I'll release Hystrix 1.3.17 in a few days hopefully with RxJava 0.19 as a dependency, and at least one performance optimization I found I can do in Hystrix directly.
 =||= ,0
1239,1076,It is impossible to provide unsubscribe action ,Observable.create is deprecated and instead comment advises to use Observable.apply:
https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala#L2589

The problem is, there is no way to supply unsubscribe action via "apply" function. 
For example: 

``` scala
val sub = Observable.apply[Int](observer => {
      println("created")
      Subscription({println("Unsubscribed")})
    }).subscribe(println(_), e => println("error"), () => println("complete1"))

    readLine()
    sub.unsubscribe()
    println("complete")
    readLine()
```

will never produce "Unsubscribed" string. To make it worse, replacing "create" with "apply" will compile and initialize subscription properly, it is only unsubscribe will stop work. 
If I have some resource created when subscribing (thread or socket), I'd like to be able to shutdown it. I do not see how it can be done if "create" is deprecated.

Also I could not find any unit test which would cover this use case. Subscription "unsubscribe' actions are tested without integration with observable, so possible error when "unsubscribe" is not called is missing.,In the new API, you need to use `Subscriber.add` to add a`Subscription`. E.g.,

``` scala
  val sub = Observable.apply[Int](subscriber => {
    println("created")
    subscriber.add(Subscription({println("Unsubscribed")}))
  }).subscribe(println(_), e => println("error"), () => println("complete1"))
```
 =||= Thanks @zsxwing, this works well. But I still think the comment in obsolete attribute should be corrected, because I could not locate any hint how to use new API anywhere.
 =||= @zsxwing Is there a comment somewhere for us to remove?
 =||= I will add an example for the Subscriber API and update the comment.
 =||= Thanks. Let me know when we can close this.
 =||= I thought we agreed to keep .create with the old signature.
 =||= > I thought we agreed to keep .create with the old signature.

Yes. I meant updating docs and more examples. Please help review #1239, thanks.
 =||= Docs and example added so closing.
 =||= ,0
1254,1253,OperatorZipIterable does not unsubscribe from source,`OperatorZipIterable` does not unsubscribe from its source, as illustrated by this example:

``` java
    Action1<String> printer = new Action1<String>() {
        @Override
        public void call(String t1) {
            System.out.println(t1);
        }
    };

    Func1<Integer, String> squareStr = new Func1<Integer, String>() {
        @Override
        public String call(Integer t1) {
            System.out.println("Omg I'm calculating so hard: " + t1 + "*" + t1 + "=" + (t1*t1));
            return " " + (t1*t1);
        }
    };

    @Test public void test() {
        Observable<Integer> o = Observable.from(1, 2, 3, 4, 5);
        Iterable<String> it = Arrays.asList("a", "b", "c", "d", "e");
        o.map(squareStr).zip(it, concat2Strings).take(2).subscribe(printer);
    }
```

which outputs

```
Omg I'm calculating so hard: 1*1=1
 1-a
Omg I'm calculating so hard: 2*2=4
 4-b
Omg I'm calculating so hard: 3*3=9
Omg I'm calculating so hard: 4*4=16
Omg I'm calculating so hard: 5*5=25
```

The last 3 lines should not be there.,The inner subscriber is not chained with the outer. I'll post a PR to fix the issue shortly.
 =||= That Pr is merged, so is this fixed?
 =||= Yes, closing.
 =||= ,0
1264,1241,Errors not being delivered in Android Scheduler,I'm running into intermittent cases when using `AndroidSchedulers.mainThread()` (which is just a wrapper around `AndroidSchedulers.handerThread()`) where the `onError` event is not being delivered to the main thread.

I have a gist showing my logs: https://gist.github.com/vinc3m1/dc9232653a22f8f2d900

It seems the onError event is propagated all the way up until `.observeOn(AndroidSchedulers.mainThread()`. After which in some (seemingly random) cases it's not delivered. And the cause appears to be that `innerSubscription` is reporting itself to be unsubscribed.

So my main questions are:
1. Should we even be doing the isUnsubscribed check on `innerSubscription` if we already have `handler.removeCallbacks(runnable)` to handle unsubscribe events?
2. Should `innerSubscription` be reporting `isUnsubscribed == true` when nothing else is unsubscribing from it?

Also, I'm using rather complex combination of `map`, `flatmap`, and `combineLatest` upstream, is it possible that some combinations of these are causing `innerSubscription` to be unsubscribed?,Ok, dug into it a bit further: looks like `unsubscribe()` is being called on the `Worker` immediately after the onError is posted to the Handler thread. This means if the `Handler` doesn't execute the `Runnable` fast enough, `innerSubscription.isUnsubscribed()` will be `true` and no message delivered.

I can see this being useful for delayed subscriptions where no further messages should be delivered  after unsubscribing, but technically all messages are delayed if the main thread gets blocked long enough.

I'm not sure how the non-Andorid schedulers handle this?
 =||= > looks like unsubscribe() is being called on the Worker immediately after the onError is posted to the Handler thread.

~~I feel there is some operator may handle `unsubscribe` incorrectly. Could you provide the operators you are using so that we can review them?~~

Just found you already provided them: `map`, `flatmap`, and `combineLatest`...
 =||= also `nest`, `doOnNext`, `subscribeOn`, but I think #1242 is the only place where unsubscribe is handled incorrectly, or do you think there's more to it than that?
 =||= Fixed in 0.19
 =||= ,0
1269,126,How to checkpoint a Observable returned in mapMany?,I have the following use case:
For each file in a FTP directory
  read file line by line
  filter comments
  parse line into a java object
  serialize that obj
  send each obj in batches to another component

I also want to make sure I don't process the same files over and over so I first filter all files based off a checkpoint mechanism, and after all the contents of a file have been sent, add that file to the checkpoint.

I have tried to replicate the logic in RxJava the following way:

``` java
Observable.from(client.list(basePath, true)) // recursively get all files under the path
          .filter(new Func1<FtpClient.FileStats, Boolean>() {
            @Override
            public Boolean call(final FtpClient.FileStats fileStats) {
              return fileStats == null || fileStats.getSize() <= 0 || !checkpointer.hasProcessed(fileStats.getPath());
            }
          })
          .mapMany(new Func1<FtpClient.FileStats, Observable<? extends byte[]>>() {
            @Override
            public Observable<? extends byte[]> call(final FtpClient.FileStats path) {
              final String location = path.getPath();
              final Observable<byte[]> obs = Observable.from(client.getIterable(location)) // opens the file and returns Iterable<String>
                  .filter(COMMENT_FILTER) // remove comment line
                  .map(PARSE_LINE) // convert from String to Event
                  .map(SERIALIZE_EVENT); // convert from Event to byte[]
              obs.subscribe(new CheckpointObserver(checkpointer, location)); // when done processing, checkpoint file
              return obs;
            }
          })
          .subscribe(new EventSender(cp));
```

The above code causes the following error to be passed to onError:

```
java.lang.IllegalStateException: Can not set subscription more than once.
    at rx.util.AtomicObservableSubscription.wrap(AtomicObservableSubscription.java:58) ~[rxjava-core-0.5.0.jar:na]
    at rx.operators.OperationFilter$Filter.call(OperationFilter.java:48) [rxjava-core-0.5.0.jar:na]
    at rx.operators.OperationFilter$Filter.call(OperationFilter.java:36) [rxjava-core-0.5.0.jar:na]
```

But this works:

``` java
Observable.from(client.list(basePath, true))
          .filter(new Func1<FtpClient.FileStats, Boolean>() {
            @Override
            public Boolean call(final FtpClient.FileStats fileStats) {
              return fileStats == null || fileStats.getSize() <= 0 || !checkpointer.hasProcessed(fileStats.getPath());
            }
          })
          .mapMany(new Func1<FtpClient.FileStats, Observable<? extends byte[]>>() {
            @Override
            public Observable<? extends byte[]> call(final FtpClient.FileStats path) {
              final String location = path.getPath();
              final Observable<byte[]> obs = Observable.from(client.getIterable(location))
                  .filter(COMMENT_FILTER) // remove comment line
                  .map(PARSE_LINE) // convert from String to Event
                  .map(SERIALIZE_EVENT); // convert from Event to byte[]
              obs.subscribe(new EventSender(cp));
              obs.subscribe(new CheckpointObserver(checkpointer, location)); // when done processing, checkpoint file
              return obs;
            }
          })
          .subscribe(new Observer<byte[]>() {
            @Override
            public void onCompleted() {
              // no-op, just trigger execution
            }

            @Override
            public void onError(final Exception e) {
              // no-op, just trigger execution
            }

            @Override
            public void onNext(final byte[] args) {
              // no-op, just trigger execution
            }
          });
```

Two things: is this a bug in rx? and whats the better way to handle this?  (https://github.com/Netflix/RxJava/issues/16 seems like it would really help to replace the EventSender since it really just buffers events before sending them),Hi, I'll review this and get back to you (probably tomorrow, not tonight).
 =||= I think you are trying to use CheckpointObserver and the filter before it to implement the distinct operator.
https://github.com/Netflix/RxJava/issues/38

Does that sound about right?
 =||= looking at http://msdn.microsoft.com/en-us/library/hh211630(v=vs.103).aspx and http://msdn.microsoft.com/en-us/library/hh244310(v=vs.103).aspx i can see how i can filter files that have been seen before, but I am unclear how distinct would aid in doing the checkpoint itself.  Could you explain a little bit more?
 =||= Closing out as this is very old ... reopen if you want to discuss again.
 =||= ,0
1271,1214,Retry with Predicate,Several people have expressed need for conditional retry behavior. I suggest a new `retry` overload that simply takes a predicate that receives the `Throwable`.

``` java
public final Observable<T> retry(Func1<Throwable, Boolean> predicate)
```

This would allow deciding whether to retry based on the `Throwable` and/or count which can be maintained by the `Func1`.

Or we could use a `Func2` and pass in the count:

``` java
public final Observable<T> retry(Func2<Integer, Throwable, Boolean> predicate)
```,Here is the type of thing that has to be done for conditional retries without this overload:

``` java
import java.util.concurrent.atomic.AtomicInteger;

import rx.Observable;
import rx.Subscriber;

public class ConditionalRetry {

    public static void main(String[] args) {

        final AtomicInteger c = new AtomicInteger();
        Observable<String> oWithRuntimeException = Observable.create((Subscriber<? super String> s) -> {
            System.out.println("Execution: " + c.get());
            if (c.incrementAndGet() < 3) {
                s.onError(new RuntimeException("retryable"));
            } else {
                s.onNext("hello");
                s.onCompleted();
            }
        });

        final AtomicInteger c2 = new AtomicInteger();
        Observable<String> oWithIllegalStateException = Observable.create((Subscriber<? super String> s) -> {
            System.out.println("Execution: " + c2.get());
            if (c2.incrementAndGet() < 3) {
                s.onError(new RuntimeException("retryable"));
            } else {
                s.onError(new IllegalStateException());
            }
        });

        subscribe(oWithRuntimeException);
        subscribe(oWithIllegalStateException);
    }

    public static void subscribe(Observable<String> o) {
        o = o.materialize().flatMap(n -> {
            if (n.isOnError()) {
                if (n.getThrowable() instanceof IllegalStateException) {
                    return Observable.just(n);
                } else {
                    return Observable.error(n.getThrowable());
                }
            } else {
                return Observable.just(n);
            }
        }).retry().dematerialize();

        o.subscribe(System.out::println, t -> t.printStackTrace());
    }
}
```
 =||= Completed.
 =||= ,0
1272,1219,New ExecutorScheduler Implementation,It turns out a lot of people used `ExecutorScheduler` despite its problems (#711 & #713). We need to bring it back, but in a way that is compliant with the contract.

This will mean that each `Worker` from the `ExecutorScheduler` will need to maintain it's own queue outside of the `Executor` (similar to `observeOn`) and then recurse on the `Executor`. Only a single task per `Worker` can be scheduled/enqueued on an `Executor`, and when it completes then it should recurse pulling items from the `Worker` queue. When the queue is empty it can stop processing. When a new task is enqueued on the `Worker` then it can schedule against for execution on the `Executor`.

We will be working against the default behavior of the `Executor` but need to do that to maintain the single-threaded contract of a `Scheduler.Worker`.,@benjchristensen you've probably already investigated but does any of the quasar work help or the backported `ForkJoin` for JRE6?
 =||= My understanding of `ForkJoin` is that it would still have the same need for us to manage a queue externally, otherwise it will process the items on multiple threads concurrently if we put them into the `ForkJoin` queue.
 =||= @benjchristensen your right....
So idea I have at present. Is you spawn a new `SerialExecutor` for each worker. 
- Pass in a Executor into the Scheduler.
- Create `Worker()` this creates a `SerialExecutor` that _sits on_ a Thread from the passed in Executor.
- Process through all the actions, blocking until the `Worker()` completes.
- Complete and return the Thread back to the pool.

Not sure if that would actually solve the problem, but from my understanding, is that we always need to serially execute queued up actions on any one worker.
 =||= That all sounds right except the "blocking until the Worker() completes" part. That would okay in Quasar, but not with native threads. It will need to behave like `observeOn` where it releases the thread (think of it as an event loop) and then reschedules back on a thread the next time it receives an `onNext`.

See observeOn here: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java#L98
 =||= @benjchristensen yeah OK that makes sense.
I still think it should be noted that people should try to avoid `Executors` where possible. It should be a "when you really have too".
 =||= I guess we need to make sure executing a tasks by the same worker shouldn't hop threads, right? I see a few problems:
- Generally, threads can die from executing non RxJava tasks and get replaced by fresh threads so thread "hopping" is more likely to occur than with the standard schedulers.
- Since most executors use a single work queue, work might be dequeued by any of the threads. Even if a work item can tell where it should run, one would need some mechanism to toss the work over to the target thread, at which point task reordering can happen. 
  - Maybe a write-cursor and read-cursor pairs may help; plus each worker thread needs dedicated queue with every instance of Scheduler.Worker assigned to it. These queues may then be processed round-robin.
  - Even if this worker thread affinity is established, one would need constantly running tasks that poll these queues or blocking ones that get unblocked by yet another queue. Since we don't know how many threads there are in the Executor, it becomes difficult to schedule such processing routines if necessary, and even so, they will block out other tasks submitted from elsewhere to the same Executor.

Bottom line is, in my opinion, that there aren't any good ways to ensure worker affinity on an Executor whose internal threads and queueing we can't control.
 =||= As far as I am concerned, the needs I have is:
- I have to serialize all my Bluetooth Low Energy communications on Android and requests can come from multiple threads, I'd like my observables to be scheduled one after the other.
- In [cgeo](https://github.com/cgeo/cgeo), I do not want more than 5 (or 10) concurrent HTTP download connections from Android, as I download large images and the memory pressure will be too high if I download more of them at the same time.

Is there a way to achieve those two goals easily without an executor?
 =||= @samueltardieu This high jacks the issue somewhat but, the `Computation` Scheduler only runs as many concurrent threads as there are cores on the device. (2-4) for most Android Devices.

The whole point of the new Schedulers is that they execute in order which Executors are not guaranteed to do.

I would use either an IO or Trampoline Scheduler for your BTLE Comms, (Also remember to Bind the `Observable` if you're passing it off to the UI thread @mattias provided that one). 
As for HTTP; Either use Computation Scheduler or Your own Scheduler, we solved the problem in Retrofit by using the Executor in the `onSubscribe()` method. See [RxSupport](https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/RxSupport.java).
 =||= There have been a few PRs proposing a Scheduler with fixed thread count and another with thread-caching support. The latter can be extended to put an upper limit on the active thread count if necessary. But unfortunately, these efforts are blocked on the enhancement quest to add load-balancing to the base computation scheduler and the usual concerns about API size and features to expose. I've been fiddling with an idea for some time to ask for a contrib-experimental module where all these "outcasts" and other stuff may be put.
 =||= @akarnokd I quite like that idea, keep the main lib lean. I'm sure a _contrib-concurrency_ would not be overkill.
I mean I always use Proguard so bloat isn't so much of an issue for me, but it's great you guys are thinking about it.
 =||= All interested in this, please try out the new implementation via `Schedulers.newExecutor` as implemented by @akarnokd in https://github.com/Netflix/RxJava/pull/1272. 
 =||= Should we rename `Schedulers.newExecutor` to something else? Reason I'm asking is that it doesn't actually create a new `Executor` like `newThread` does. It is a new `Scheduler` around a given `Executor`. Perhaps it is instead `Schedulers.fromExecutor(Executor e)` or just `Schedulers.executor(Executor e)`?
 =||= I like `Schedulers.from(Executor e)`
 =||= @headinthebox +1 very consistent!
 =||= I believe this is done so closing out. 
 =||= -keep class rx.internal.util.*\* { *; }
 add it in proguard to resolve few problems
 =||= ,0
1272,1206,What should i use for thread pool execution in new api?,What should i use for thread pool execution in new api?

For example all http request in android recommended to be executed on cached thread pool.,Take a look at https://github.com/Netflix/RxJava/issues/713#issuecomment-43292434 and https://github.com/Netflix/RxJava/issues/1219.

Another item of interest is https://github.com/Netflix/RxJava/pull/1143
 =||= @lexer Please try out the implemented just merged in @1272 and let us know if it gives you what you need.

We are also still going to proceed with an improved IO Scheduler as per https://github.com/Netflix/RxJava/issues/1140
 =||= The `Schedulers.io()` scheduler will now cache threads again due to the work in #1140. There is also a new `ExecutorScheduler`  that you can access using `Schedulers.from(Executor)`.
 =||= ,0
1282,1199,rxjava-string: StringObservable.from(InputStream) does not close InputStream,Would be nice if `StringObservable.from(InputStream,size)` closed the `InputStream` once finished with it. Are there any obstacles to this being incorporated?

The same again for the `StringObservable.from(Reader, size)`.

line 62:
https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java ,I think it's better that leaving the user to close it. Sometimes, the user may need to reuse the stream. And if the user wants to close it once the Observable finishes, he can use `using` operator. E.g.,

``` Java
    public void foo(final InputStream i) {
        Observable.using(new Func0<Subscription>() {

                             @Override
                             public Subscription call() {
                                 return Subscriptions.create(new Action0() {

                                     @Override
                                     public void call() {
                                         try {
                                             i.close();
                                         } catch (IOException e) {
                                             throw new RuntimeException(e);
                                         }
                                     }
                                 });
                             }
                         }, new Func1<Subscription, Observable<byte[]>>() {

                             @Override
                             public Observable<byte[]> call(Subscription subscription) {
                                 return StringObservable.from(i);
                             }
                         }
        );
    }
```
 =||= I think this is best served by the practice of "whoever opened it should close it".

The `from(InputStream)` approach means the `Observable` didn't open it and therefore shouldn't close it.

If it was `from(File)` then it is the `Observable` who opens it and should close it.
 =||= Thanks @zsxwing  for the explicit example, that's very helpful. I expect that the use case where the user wants it closed will be common so for the convenience of the user I might make a pull request with additional methods like `fromAndClose(InputStream)` so that users don't need to implement all that using code.
 =||= >  I might make a pull request with additional methods like fromAndClose(InputStream) so that users don't need to implement all that using code.

I suppose we also miss some document about `StringObservable.from(InputStream,size)` or `StringObservable.from(Reader, size)`. Observables returned by them can only be subscribed once. They can not be used directly with `repeat`, `retry`...
 =||= Thanks for the answers, looks fine to close.
 =||= ,0
1286,1270,Rename OperatorMulticast and OperatorMulticastSelector?,Was looking at the source of [OperatorMulticast](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java) and  [OperatorMulticastSelector](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorMulticastSelector.java) and neither implements `Operator`. Is a rename in order here or are they going to be made into `Operator`s soonish?,They can't be operators because they need to be `ConnectableObservable`s. I think the naming is just stuck so they don't stand out of the other OperatorXYZ classes. Btw, there are a bunch of OperatorXYZ which implement OnSubscribe only yet they are called Operator.
 =||= Yep you're quite right, of the 93 Operator\* classes in the `operator` package, roughly 22 do not implement `Operator`. This is a lot of hiding though perhaps some are candidates to implement `Operator` in the near future. Why not rename everything that is not an `Operator` (and not a candidate for conversion to `Operator`)?  Might prompt a new package or two to contain these beasts.  In the case of the classes above I'd prefer to see them as `ConnectableObservableMulticast` and `ConnectableObservableMulticastSelector`.
 =||= Here's a quick list, might have missed some:

```
OperatorAmb.java:public final class OperatorAmb<T> implements OnSubscribe<T>{
OperatorCache.java:public final class OperatorCache<T> implements OnSubscribe<T> {
OperatorCombineLatest.java:public final class OperatorCombineLatest<T, R> implements OnSubscribe<R> {
OperatorDefer.java:public final class OperatorDefer<T> implements OnSubscribe<T> {
OperatorDelay.java:public final class OperatorDelay<T> implements OnSubscribe<T> {
OperatorDelay.java:    public static final class Emitter<T> implements OnSubscribe<T>, Action0 {
OperatorDelaySubscription.java:public final class OperatorDelaySubscription<T> implements OnSubscribe<T> {
OperatorDelayWithSelector.java:public final class OperatorDelayWithSelector<T, U, V> implements OnSubscribe<T> {
OperatorGroupJoin.java:public final class OperatorGroupJoin<T1, T2, D1, D2, R> implements OnSubscribe<R> {
OperatorJoin.java:public final class OperatorJoin<TLeft, TRight, TLeftDuration, TRightDuration, R> implements OnSubscribe<R> {
OperatorMulticast.java:public final class OperatorMulticast<T, R> extends ConnectableObservable<R> {
OperatorMulticastSelector.java:public final class OperatorMulticastSelector<TInput, TIntermediate, TResult> implements OnSubscribe<TResult> {
OperatorParallelMerge.java:public final class OperatorParallelMerge {
OperatorRefCount.java:public final class OperatorRefCount<T> implements OnSubscribe<T> {
OperatorReplay.java:public final class OperatorReplay {
OperatorSequenceEqual.java:public final class OperatorSequenceEqual {
OperatorSkip.java:public final class OperatorSkip<T> implements Observable.Operator<T, T> {
OperatorTakeUntil.java:public final class OperatorTakeUntil {
OperatorTimerOnce.java:public final class OperatorTimerOnce implements OnSubscribe<Long> {
OperatorTimerPeriodically.java:public final class OperatorTimerPeriodically implements OnSubscribe<Long> {
OperatorToMap.java:    public static final class DefaultToMapFactory<K, V> implements Func0<Map<K, V>> {
OperatorToMultimap.java:    public static final class DefaultToMultimapFactory<K, V> implements Func0<Map<K, Collection<V>>> {
OperatorToMultimap.java:    public static final class DefaultMultimapCollectionFactory<K, V>
OperatorToObservableFuture.java:public class OperatorToObservableFuture {
OperatorUsing.java:public final class OperatorUsing<T, Resource extends Subscription> implements OnSubscribe<T> {

```
 =||= These operators are considered internal implementation and unless you are a hard-core rxjava-core developer, you don't need to worry about what is in `rx.operators`. Many of these operators don't implement Operator because the behavior they need to perform can only be done while in OnSubscribe.call(); there is no one to pass a Subscriber further up since they behave basically as sources.
 =||= The ones that implement `OnSubscribe` could be renamed from `Operator*` to `OnSubscribe*`.

More importantly though, these should never be relied upon publicly. They are not part of the public API and can change at any time, even once we hit 1.0.
 =||= So I don't have hard core understanding of the rxjava code base but I'm using it on a a lot of projects at work and to develop with rxjava I very frequently dig small holes into the source code to understand what I'm using and I use the source as a cookbook. I can't imagine developing with the library without the source code. Given that I'd like to see those spades called spades to minimize a bit of possible confusion (e.g. why is `Observable.create` being called with an `Operator`, what overload is that?). 

Happy to knock up a pull request if this has support.
 =||= I'm okay with a change that makes the `OnSubscribe` implementations start with `OnSubscribe`.

So that this is clean, please do not mix any other changes with it, just renaming those ~20 files that should start with `OnSubscribe` instead of `Operator`.

Example `OperatorAmb` -> `OnSubscribeAmb`

@akarnokd Do you have an issue with this? It seems to be clearer, and matches the intent of of classes such as `OnSubscribeRange` and `OnSubscribeFromIterable` already there.
 =||= LGTM
 =||= For me, using Operator as prefix is simpler so no need to remember the base interface for each operator. I'd even drop the prefix but I guess that would just complicate auto-complete in IDEs.
 =||= These classes are internal and referenced from a single place, `Observable` so I'm fine either way. I think we should either give them a completely generic prefix (I can't think of one right now) or make the `OnSubscribe*` and `Operator*` prefix consistent as suggested in this issue.
 =||= The generic prefix idea is not attractive to me because I lose visibility at a glance of what types the classes are. I end up in the same place as I am now. Dropping the prefix would do the job if we moved non-operators out of the operator package to an onsubscribe package. My preference at the moment is Operator -> OnSubscribe.
 =||= I'm fine with you changing the prefixes if you want to contribute that.
 =||= Sounds good.
 =||= Now that we have `rx.internal` should we move `rx.operators` to `rx.internal.operators` alongside `rx.internal.util`? This way it is very clear that these are internal and not part of the public API?
 =||= Fine with me.
 =||= Sounds good.
 =||= Sounds good
On 31 May 2014 03:33, "headinthebox" notifications@github.com wrote:

> Sounds good.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/Netflix/RxJava/issues/1270#issuecomment-44677574.
 =||= I'll make this change.
 =||= ,0
1287,1204,Profiling Memory Usage and Object Creation,We need to spend time profiling memory and object allocation and finding places where we can improve. 

I would really appreciate help diving into this and finding problem areas. Even if you don't fix them, but just identity use cases, operators, etc that would be very valuable.

This is partly a result of the fact that in Netflix production we have seen an increase in YoungGen GCs since 0.17.x.

The areas to start should probably be:
- Observable.create
- Observable.lift
- Subscriber
- CompositeSubscription
- map
- flatMap

If you can or want to get involved in this please comment here so we all can collaborate together.,The most likely source of garbage is the `CompositeSubscription`: whenever a task is scheduled or a new merge-source appears, the state transition creates a new State object and copies the subscription array. PR #1145 reduces the amount of garbage by switching to HashSet on a larger composite. Since flatMap->mergeMap->merge needs to track the active inner subscriptions, it uses a composite as well and would gain the same benefits.
 =||= The `HashSet` change shouldn't kick in though because these aren't generally large lists (handful at most, not hundreds). I expect it's just far too many of them being created.
 =||= I'll also like to help out here, since its crucial for our uses as well. 
 =||= Thanks @daschl I'd appreciate your help. Profiling and identifying hot spots is what we need most right now.
 =||= I did some GC profiling of my test workloads and I'd also like to nominate:
- BlockingObservable (it seems that especially in the .single() case its not optimized)
- Observable.subscribe (for both Observer and Subscriber) - in my GC logs they take up 40% of the overall GC pressure.

The bad news is that i had to fall back out of Observables to plain execution on the hot code path (aside from the overall wrapping observable), because also using it in the path produces way too much garbage (moving away from Rx in the hot code path got my throughput from 20% to 80% according to the GC logs) and it correlates with my findings since I could not sustain constant IO throughput because of full GCs happening way too frequently.
 =||= > Observable.subscribe (for both Observer and Subscriber)

Not surprised on this. Were you able to identify what the garbage is? 
 =||= I did some changes in my code and will re-profile and post the results here so we get better measurements. 

Here is a slightly older profile run which might give you a hint or two.
![screen shot 2014-05-20 at 10 13 10](https://cloud.githubusercontent.com/assets/29086/3024320/a10a2a64-dff6-11e3-8f2c-3473bdfc7af7.png)
![screen shot 2014-05-20 at 10 13 00](https://cloud.githubusercontent.com/assets/29086/3024319/a1096bba-dff6-11e3-9c92-0177913e5c47.png)
 =||= We can definitely improve on the `AtomicReference` by using AtomicFieldUpdater. The others will require more effort to analyze along with sample code to see what's triggering them.
 =||= I think that many `AtomicReference` come from mostly the `CompositeSubscription` instances.
 =||= I went back in history to 0.16.1 to compare performance of the basic `map`/`flatMap` behavior and found that current master is faster. This fits what I had expected of the work of the past couple months, which means it's not an obvious glaring issue (unless my test is completely flawed).

Here is the code for the test:
- Branch 0.16 => https://github.com/benjchristensen/RxJava/blob/0.16-perf/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java
- Master => https://github.com/benjchristensen/RxJava/blob/performance/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java

### Results

#### 0.16

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  2421210.583    68845.966    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     1017.787       73.597    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  2398541.067    90703.197    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5      990.623      100.735    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  4020548.060   262841.500    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    16205.747      352.618    ops/s
```

#### Master

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3184873.133   172320.420    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9079.937      343.905    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3411785.677    73767.161    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10860.963      294.309    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  7208334.997   703327.745    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    18720.797      278.529    ops/s
```

### GC

On the master branch test I'm seeing GC results like this:

```
Iteration   5: 3189218.350 ops/s
          GC | wall time = 5.001 secs,  GC time = 0.047 secs, GC% = 0.94%, GC count = +98
Iteration   5: 9198.700 ops/s
          GC | wall time = 5.002 secs,  GC time = 0.048 secs, GC% = 0.96%, GC count = +98
```

versus 0.16

```
Iteration   5: 2420099.017 ops/s
          GC | wall time = 5.000 secs,  GC time = 0.046 secs, GC% = 0.92%, GC count = +96
Iteration   5: 993.867 ops/s
          GC | wall time = 5.001 secs,  GC time = 0.100 secs, GC% = 2.00%, GC count = +212
```

### Summary

Unless I'm mistaken, current code is better:
- similar GC behavior on `Observable` with 1 item, better GC behavior with 1024 items
- higher ops/second on all of the map/flatMap tests

I'll start profiling this and improve ... but this does not reveal the source of the problems seen. Possibly it's related to schedulers, or it's a specific operator. I exercised `map`, `flatMap` (and thus `merge`), `Observable` and `Subscribe` here to get the most fundamental ones.
 =||= The `observeOn` test shows the cost of scheduling ... particularly `Observable`s of a single item.

``` java
    @GenerateMicroBenchmark
    public void observeOn(UseCaseInput input) throws InterruptedException {
        input.observable.observeOn(Schedulers.computation()).subscribe(input.observer);
        input.awaitCompletion();
    }
```

```
r.u.PerfObserveOn.observeOn        1  thrpt         5   457830.180     9943.221    ops/s
r.u.PerfObserveOn.observeOn     1024  thrpt         5    14496.430      518.463    ops/s
```

Thus, with an `Observable` of 1 item we can do 457k onNext/second, with an `Observable` of 1024 items we can do 14.8million onNext/second (14.5k \* 1024).
 =||= By the way, all testing is just being done on my Mac laptop ... so these numbers are all relative and not representative of proper server hardware.
 =||= Converting from `AtomicReference` to `AtomicReferenceFieldUpdater` improved performance from this:

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3184873.133   172320.420    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9079.937      343.905    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3411785.677    73767.161    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10860.963      294.309    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  7208334.997   703327.745    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    18720.797      278.529    ops/s
```

to this:

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3459205.110   124790.906    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9225.037      604.720    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3639603.060   225599.038    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    11135.613      337.022    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  7264202.633   214787.109    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    18795.790      713.668    ops/s
```
 =||= @benjchristensen I suppose the `AtomicReferenceFieldUpdater` mostly comes from less GC pressure, is that why the raw throughput increases in your tests? How did the GC wall time change?
 =||= If you want me to run a specific workload/type of test let me know so we can compare results.
 =||= I've been experimenting with FieldUpdaters and Unsafe for the `SerializedObserver`. It seems that by using Unsafe directly and thus avoiding security checks and an indirection, I can get about 8-10% more throughput. The downsides are that it is scheduled to be removed/standardized in future Java versions and platform dependence in terms of availability. Should I pursue the Unsafe path?
 =||= @akarnokd since RxJava also runs on android, I'm not sure how good/standard the support is there.

I know that the netty folks are having the same issues and they are wrapping those Unsafe calles in a PlatformDependent util class.
 =||= > wrapping those Unsafe calles in a PlatformDependent util class.

This sounds like a valid approach for us. As we mature Rx we'll want to squeeze as much performance out of it as we can, while still remaining portable.
 =||= Testing with:

```
../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof GC .*PerfTransforms.*'
```

##### May 21st https://github.com/Netflix/RxJava/commit/0efda073f1068b105478145904d788b2206d7c4e

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4597237.797   227193.650    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    12334.190      214.479    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4522036.147   216489.787    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    12293.223      321.573    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  9133316.230   303274.438    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    19698.323      150.313    ops/s
```

##### May 26th https://github.com/Netflix/RxJava/commit/a34cba2bcd96f99e3a0d193009a7ce25775a4ad2

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4367166.623   145506.857    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    11382.233      425.976    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4468497.400    83649.115    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    11374.780      780.039    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  8851147.610   303583.393    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    19649.227     1134.279    ops/s
```

According to these results we got slower (though within mean error it appears, so if not slower, then no better).
 =||= Which Java version is this? Java 6 intrinsics isn't as good as the newer versions. Maybe the `wip` field in the merge operator causes more false sharing and needs padding.
 =||= /Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk
 =||= Master branch with /Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4378589.533   109056.155    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    10702.953      447.216    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4341206.933   184228.619    ops/s
r.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10961.550      545.574    ops/s
r.u.PerfTransforms.mapTransformation                 1  thrpt         5  8996983.320   226242.030    ops/s
r.u.PerfTransforms.mapTransformation              1024  thrpt         5    19423.813      779.759    ops/s
```
 =||= Here is a [simple test](https://gist.github.com/benjchristensen/0e821794b0e510e0feed) without JMH (but using same coding pattern) that shows significant increases in throughput from 0.16 -> 0.17 -> 0.18 -> current master branch for this code:

``` java
    public void mapTransformation(UseCaseInput input) throws InterruptedException {
        input.observable.map(i -> {
            return String.valueOf(i);
        }).map(i -> {
            return Integer.parseInt(i);
        }).subscribe(input.observer);
        input.awaitCompletion();
    }
```

##### master

```
Run: 10 - 10,333,567 ops/sec 
Run: 11 - 10,235,100 ops/sec 
Run: 12 - 10,269,259 ops/sec 
Run: 13 - 10,170,560 ops/sec 
Run: 14 - 10,072,319 ops/sec 
```

##### Version 0.18.3

```
Run: 10 - 7,973,782 ops/sec 
Run: 11 - 8,695,425 ops/sec 
Run: 12 - 8,283,768 ops/sec 
Run: 13 - 8,283,562 ops/sec 
Run: 14 - 8,270,888 ops/sec 
```

##### Version 0.17.6 (using `OnSubscribe`)

```
Run: 10 - 7,812,927 ops/sec 
Run: 11 - 7,632,713 ops/sec 
Run: 12 - 7,488,673 ops/sec 
Run: 13 - 7,975,944 ops/sec 
Run: 14 - 7,882,146 ops/sec 
```

##### Version 0.17.6 (using `OnSubscribeFunc`)

```
Run: 10 - 7,049,700 ops/sec 
Run: 11 - 7,175,042 ops/sec 
Run: 12 - 7,173,240 ops/sec 
Run: 13 - 7,069,685 ops/sec 
Run: 14 - 7,248,320 ops/sec 
```

##### Version 0.16.1

```
Run: 10 - 4,765,899 ops/sec 
Run: 11 - 4,792,623 ops/sec 
Run: 12 - 4,709,982 ops/sec 
Run: 13 - 4,761,451 ops/sec 
Run: 14 - 4,769,627 ops/sec 
```
 =||= Very good progress! I'll get back to profiling from master next week.
 =||= I run some benchmarks with `AtomicInteger` and `volatile int` inside merge and it appears that JMH benchmark gives 10% more throughput with `AtomicInteger`.
 =||= Well that's odd and doesn't help much when two different ways of measuring are giving contradictory results :-(
 =||= We captured some profiling from a production instance and found evidence that suggests our atomic state machines are going to have to be changed or replaced.

---

The biggest allocation hotspot is creating `rx.Subscription[]` from `rx.subscriptions.CompositeSubscription$State.remove(Subscription)` and `rx.subscriptions.CompositeSubscription$State.add(Subscription)`.

This accounts for approximately 104GB of total allocations within the profile (~30% of total allocation).

There's also ~1.5GB allocated for rx.subjects.SubjectSubscriptionManager$State split pretty evenly from these 3 methods:

```
- rx.subjects.SubjectSubscriptionManager$State.createNewWith(SubjectSubscriptionManager$SubjectObserver[])
- rx.subjects.SubjectSubscriptionManager$State.terminate()
  - rx.subjects.SubjectSubscriptionManager.<init>()
```

Another ~1.2GB of allocations for `rx.subjects.SubjectSubscriptionManager$SubjectObserver[]` from 4 sources:

```
- rx.subjects.SubjectSubscriptionManager$State.<init>(boolean, CountDownLatch, SubjectSubscriptionManager$SubjectObserver[])
- rx.subjects.SubjectSubscriptionManager$State.<init>()
- java.util.Arrays.copyOf(Object[], int) called by rx.subjects.SubjectSubscriptionManager$State.addObserver(SubjectSubscriptionManager$SubjectObserver)
- rx.subjects.SubjectSubscriptionManager$State.removeObserver(SubjectSubscriptionManager$SubjectObserver)
```

Here's a list of top allocated rx.\* objects that exceed 100MB
(numbers are in bytes):

```
rx.Subscription[]                                           97,870,643,480
rx.subjects.SubjectSubscriptionManager$State                1,624,120,080
rx.subjects.SubjectSubscriptionManager$SubjectObserver[]    1,315,680,480
rx.subscriptions.Subscriptions$1                            849,212,800
rx.subscriptions.CompositeSubscription$State                837,518,872
rx.subscriptions.CompositeSubscription                      641,083,960
rx.observers.SafeSubscriber                                 637,599,560
rx.subjects.SubjectSubscriptionManager$SubjectObserver      618,721,656
rx.Observable$30                                            585,739,968
rx.operators.SafeObservableSubscription                     568,522,112
rx.subjects.SubjectSubscriptionManager$1                    545,755,280
rx.subjects.ReplaySubject$History                           528,269,104
rx.subjects.ReplaySubject                                   443,043,720
rx.Observable                                               395,292,296
rx.operators.OperatorMerge$1$InnerObserver                  370,883,064
rx.subjects.ReplaySubject$ReplayState                       340,267,192
rx.Observable$29                                            288,726,208
rx.operators.BlockingOperatorToFuture$2                     288,463,944
rx.subjects.SubjectSubscriptionManager                      281,230,064
rx.subjects.ReplaySubject$3                                 266,953,480
rx.subjects.ReplaySubject$2                                 260,071,464
rx.operators.BlockingOperatorToFuture$1                     256,919,568
rx.subjects.SubjectSubscriptionManager$1$1                  245,468,584
rx.subjects.ReplaySubject$1                                 238,637,944
rx.operators.OperatorCache                                  147,967,240
rx.observers.Subscribers$1                                  132,742,032
rx.subscriptions.BooleanSubscription                        107,733,248
rx.Observable$2                                             105,170,440
```
 =||= @benjchristensen Asked me to contribute a bit to this issue. We've been noticing some issues with RxJava 0.18.x through our use of Hystrix.

Let me setup our use case first to give you an idea of our usage pattern for this particular service. We have a pretty standard public API (think microservice, single-purpose) that does about 200/s incoming calls and fans that out into ~500-1000 command executions/s. This can burst to over 800/s incoming calls without warning.

The service is on a pretty modest deployment of c1.mediums, but it's also sitting at about 20% CPU normally. Since deploying Hystrix 1.3.16 w/ RxJava 0.18.2, our heaps that were previously steady sawtooths around 50-70mb have risen to over 150mb. Additionally, our CPU percentages really start to rise after a few days. This appears to be linked to our latencyTotal_mean times deviating far from our latencyExecute_mean. As you can see below, the command is decreasing in ops/s but the Hystrix overhead is rising. This rise continues for about 5 days to where it's taking anywhere from 20-30ms of Hystrix overhead and the boxes are running near 80-90% CPU.

![Command execution](https://lh3.googleusercontent.com/-rUdmvgGkn0k/U4ah34FBFdI/AAAAAAAAALE/amiC-VBzbV4/s1600/download+%282%29.png)

I took a heap dump of one of the production servers. I can provide it on request, but shown below is a piece I found interesting:

![Subscription objects](https://lh5.googleusercontent.com/-RoOTaW-h358/U4aohtaU4lI/AAAAAAAAALc/93tZ8ScAiG0/s1600/Screen+Shot+2014-05-28+at+9.23.36+PM.PNG)

Approximately 800K Subscriptions were present in the heap dump at the time, which really smells off to me. Even when I forced GCs they were sticking around. See the below, our heap usage was increasing over time:

![Heap usage](https://lh4.googleusercontent.com/-ZSx4hFVpVIg/U4af1dMwdeI/AAAAAAAAAK0/CXCMgBZM67I/s1600/Screen+Shot+2014-05-28+at+8.47.18+PM.PNG)

I started looking at the CompositeSubscription used by Hystrix, and really drilling into it, ran across this:

![CompositeSubscription array](https://dl.dropboxusercontent.com/u/11103618/Screenshots/rxjava-compositesubscription.png)

The subscription array on this has grown to 400K. Perhaps this is an edge case, but I believe that once it falls behind it really struggles to keep up. This would explain the non-linear jump in Hystrix overhead observed in the graph of the command execution time.

``` java
        State add(Subscription s) {
            int idx = subscriptions.length;
            Subscription[] newSubscriptions = new Subscription[idx + 1];
            System.arraycopy(subscriptions, 0, newSubscriptions, 0, idx);
            newSubscriptions[idx] = s;
            return new State(isUnsubscribed, newSubscriptions);
        }
```

For every addition, it's creating a brand new array and copying the new subscriptions into them? Is there a reason behind that? Removals then iterate the entire array and alloc a new array (usually  twice?):

``` java
        State remove(Subscription s) {
            if ((subscriptions.length == 1 && subscriptions[0].equals(s)) || subscriptions.length == 0) {
                return clear();
            }
            Subscription[] newSubscriptions = new Subscription[subscriptions.length - 1];
            int idx = 0;
            for (Subscription _s : subscriptions) {
                if (!_s.equals(s)) {
                    // was not in this composite
                    if (idx == newSubscriptions.length) {
                        return this;
                    }
                    newSubscriptions[idx] = _s;
                    idx++;
                }
            }
            if (idx == 0) {
                return clear();
            }
            // subscription appeared more than once
            if (idx < newSubscriptions.length) {
                Subscription[] newSub2 = new Subscription[idx];
                System.arraycopy(newSubscriptions, 0, newSub2, 0, idx);
                return new State(isUnsubscribed, newSub2);
            }
            return new State(isUnsubscribed, newSubscriptions);
        }
```

I don't have a misbehaving instance at the moment, but I'd wonder if profiling would show lots of CPU time spent in `remove()`

Unless I'm missing a key factor here, I'd think HashSet would be much more performant in this context for O(1) lookups & removals. I can't imagine that the overhead of the set entries would be more than memory copies. At the very least, an ArrayList would cut down on allocs & copies.

Let me know if I'm off base here. I'm very interested in helping resolve this issue.
 =||= Thanks for the details. CompositeSubscription becomes very slow when it grows over the size of the cache line in the CPU and constant add/remove is happening (see #1145).

Subscriptions$2 is perhaps the wrapper for Future, which keeps a final reference to the Future object, which generally shouldn't be a problem if its parent container is removing/clearing it.

What is worrying is that there is an unsubscribed `CompositeSubscription` with a non-empty array. When unsubscribed, `CompositeSubscription` should drop the entire array and don't accept any new additions. Could you tell where that `CompositeSubscription` is embedded?
 =||= Got it.

In our use case we're doing a `HystrixCommand#observe()` and passing the observable to 

``` java
    public static <T> ListenableFuture<T> toListenableFuture(Observable<T> observable) {
        final SettableFuture<T> listenableFuture = SettableFuture.create();
        final AtomicReference<Subscription> s = new AtomicReference<Subscription>();

        s.set(observable.subscribe(new Observer<T>() {
                                 @Override
                                 public void onCompleted() {
                                 }

                                 @Override
                                 public void onError(Throwable e) {
                                    listenableFuture.setException(e);
                                 }

                                 @Override
                                 public void onNext(T args) {
                                    if (listenableFuture.isDone()) {
                                        listenableFuture.setException(new IllegalStateException("Observable should only have a single value"));
                                    } else {
                                        listenableFuture.set(args);
                                    }
                                 }
                             }));

        return listenableFuture;
    }
```

This only happens ~50 times a second per server. `CompositeSubscription` is being used by `HystrixContextScheduler#ThreadPoolWorker` but from my investigation of the code it looks like these are recreated for each command invokation @benjchristensen, am I right about this?

In my heap dump, these 400,000-long arrays of Subscriptions seem to be actively being recycled and used, so somehow those CompositeSubscription instances are sticking around. I can't seem to identify where the ThreadPoolWorker instance might be getting reused though.
 =||= @Xorlev Thanks for the detailed post, very helpful to have another set of clues beyond what we've been seeing.

> I'd think HashSet would be much more performant in this context for O(1) lookups & removals. I can't imagine that the overhead of the set entries would be more than memory copies. At the very least, an ArrayList would cut down on allocs & copies.

For the use cases we appear to be triggering, definitely yes. This is partially what @akarnokd was seeking to solve in https://github.com/Netflix/RxJava/pull/1145. 

When we designed the current implementation of `CompositeSubscription` we used an atomic state machine as the expectation was that there should never be more than a handful of `Subscription`s added to it and we were trying to avoid mutable state needing to be protected by locks, and that the extra object allocations to allow use of compareAndSet was okay. 

Performance testing we've done has shown this to be a win (in the cases we've been testing) but obviously there are cases where this is breaking badly.

So, we can pivot to using a mutable data structure protected by locks to avoid the object allocation (such [as this](https://gist.github.com/benjchristensen/541c2dbb5fca94ee4155)), but right now I'm still trying to identify the use cases that are causing this.

> What is worrying is that there is an unsubscribed CompositeSubscription with a non-empty array. When unsubscribed, CompositeSubscription should drop the entire array and don't accept any new additions. Could you tell where that CompositeSubscription is embedded?

This is an open question. We see the same symptom in our production environment, though not sure if it's an actual leak, or just such high pressure that the GC can't keep up so it looks like they are leaking.

Researching further today ... 
 =||= > `HystrixContextScheduler#ThreadPoolWorker`

Yes, that is just a thin wrapper around a real `Scheduler` used by Hystrix to copy state across threads. It is allocated for each command.

>  these 400,000-long arrays of Subscriptions seem to be actively being recycled and used, so somehow those CompositeSubscription instances are sticking around

That is the key problem I'm trying to find today. I'm going to focus on the Hystrix use cases since it's the one that triggers it. Seems it is either a bug in how Hystrix is using Rx, or it's triggering a bug or unexpected use case in Rx that we need to handle.
 =||= If it's helpful, I also found this interesting, which lead me down the path of investigating `CompositeSubscription$State`

![Stack](https://dl.dropboxusercontent.com/u/11103618/Screenshots/rxjava-subremoval.png)

I can put the heap dump on Dropbox and email you a link if it'd be helpful, Ben.
 =||= That is helpful. It points to looking at the `EventLoopScheduler`.
 =||= This is creating lots of `ArrayList` instances unnecessarily: 
https://github.com/Netflix/RxJava/blob/0.18.2/rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java#L172

![screen shot 2014-05-29 at 10 35 48 am](https://cloud.githubusercontent.com/assets/813492/3120998/b281d270-e757-11e3-82f4-0c4fb645e6a7.png)
![screen shot 2014-05-29 at 10 37 45 am](https://cloud.githubusercontent.com/assets/813492/3121021/f843b5a8-e757-11e3-83c5-b18f251952d9.png)
 =||= ![replaystate-arraylist-object](https://cloud.githubusercontent.com/assets/813492/3121057/4f67c9dc-e758-11e3-8f4b-8e9e9c12372c.png)
 =||= ![hystrix rx-with-0 18 2](https://cloud.githubusercontent.com/assets/813492/3121117/ec086eae-e758-11e3-9d54-43bb8b647199.png)
 =||= Those were from 0.18.2 ... now with Master, plus a [modified](https://gist.github.com/benjchristensen/541c2dbb5fca94ee4155) `CompositeSubscription` we get this:

![hystrix rx-with-master new-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3121129/1ce1746c-e759-11e3-918c-4d6e97c92dc2.png)
 =||= Here is evidence for need of work on `ReplaySubject`:

![replaysubject-1](https://cloud.githubusercontent.com/assets/813492/3121171/8a1b7a6e-e759-11e3-85bc-270167719e34.png)

![replaysubject-2](https://cloud.githubusercontent.com/assets/813492/3121172/8cd26e02-e759-11e3-9544-70f900a80890.png)

![replaysubject-3](https://cloud.githubusercontent.com/assets/813492/3121174/8f90fa46-e759-11e3-8680-898da7e2b3a9.png)
 =||= ![0 18 2-map observeon](https://cloud.githubusercontent.com/assets/813492/3121261/76d1a61c-e75a-11e3-82c4-96e59ac1ddfa.png)

![master-map observeon](https://cloud.githubusercontent.com/assets/813492/3121263/7b1c9600-e75a-11e3-96a7-56e30df059cf.png)
 =||= The `Subscription[]` issue is definitely being caused by the use of a `Scheduler`. Here is some evidence:

![subscription-array-when-using-scheduler](https://cloud.githubusercontent.com/assets/813492/3121292/c1c39f54-e75a-11e3-97b9-5ba75cdb040b.png)

Then the master branch with `CompositeSubscription` change:

![screen shot 2014-05-29 at 10 58 09 am](https://cloud.githubusercontent.com/assets/813492/3121303/d65be0fc-e75a-11e3-8902-5f9ead818735.png)

The issue is definitely the `CompositeSubscription` as the following shows where it is master as it currently stands without my changes to `CompositeSubscription`:

![master-without-changing-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3121347/3f171634-e75b-11e3-9246-aff40bf88eeb.png)
 =||= I've added some logging to our production instances and discovered that the cause of large Subscription arrays we see in practice is caused by a prefetching operation which generates many (> 500) `HystrixCommand`s, calls `observe` on them, puts them in an ArrayList, and finally calls `Observable.merge` on this list to have a single place to listen for overall completion.

This seems like a valid case to support and any work which improves performance for large Subscription arrays would be a meaningful improvement.
 =||= I have submitted a pull request for this: https://github.com/Netflix/RxJava/pull/1281

We are testing the code in our environment shortly.
 =||= For anyone wanting to dig into this, Java Flight Recorder has been very helpful, and far better than the other profiling tools I've used and tried for this.
 =||= Backporting to 0.18.x in https://github.com/Netflix/RxJava/pull/1283
 =||= Superb work guys, I've held off on 18.x on Android as I noticed an increase in GC, really glad you guys take this seriously!
 =||= Thanks @chrisjenx ... it looks like the most glaring issues are resolved, and low hanging fruit taken care of. There are a few other things for us to improve on, but I think we'll release 0.19 early next week. I would appreciate your feedback on whether you see an improvement.

I have also opened https://github.com/Netflix/RxJava/issues/1299 to document our attempts on blocking vs non-blocking implementations and to seek input from anyone who can provide better solutions.
 =||= @akarnokd Is there anything else that stands out to you that we should fix before closing this issue? I'll continue doing some profiling but it seems the obvious ones are done.

We'll continue working on performance going forward and those can have their own issues and pull requests, so if nothing else obvious stands out let's close this issue and not leave it open-ended.
 =||= The history List in ReplaySubject; since ArrayList uses more memory then actual items, it might be worth compacting it on a terminal state (one time, but might be costly and run out of memory). Alternatively, it could use fixed increment expansion strategy. Third option is to have a cache() overload that passes in a capacity hint to reduce reallocation and wasted space.
 =||= I think that the object allocation penalty of resizing after a terminal event would be worse.

A cache() overload that takes a capacity hint may be valuable, particularly in the single item case where it could just a single volatile ref instead of an array.  
 =||= I have opened a new issue for the cache() overload: https://github.com/Netflix/RxJava/issues/1303
 =||= I'm closing this issue out as I believe we have handled the most glaring problems and don't want this to be a never-ending issue. We will of course continue seeking to improve performance, but let's use individual issues for each improvement/problem we find.

Thanks everyone for your involvement on this one as it was rather significant and important.

@Xorlev and @daschl I would appreciate feedback once you've had a chance to try the changes in the master branch (or the portion that was backported to 0.18.4) to know if you see the improvements or still have issues. @Xorlev In particular I'd like to know if the issue you had was only the GC pressure, or if you still see signs of a memory leak (which I have not seen yet).
 =||= @benjchristensen Hystrix 1.3.16 w/ RxJava 0.18.4 has been in prod for about a day now, I'm happy to report a decrease in garbage (and CPU usage in general). I believe the pressure & the suboptimal subscription removal was causing the leak-like behavior. @mattrjacobs's use case matches a few of our own (fan out commands, wait on all), which is likely the source of the large numbers of subscriptions.

I'll keep an eye out for any similar issues that might crop up.

Thanks a lot for all the help and dedication to improving RxJava.
 =||= Excellent. Thank you @Xorlev for the confirmation. I'll release Hystrix 1.3.17 in a few days hopefully with RxJava 0.19 as a dependency, and at least one performance optimization I found I can do in Hystrix directly.
 =||= ,0
1297,1167,RxScala: Let's add Monad and Applicative instance,Hi folks,

As I showed in my repo [everpeace/observable-canbe-monad](https://github.com/everpeace/observable-canbe-monad),  `Observable` can be monad(List like) and applicative functor(ZipList like).

As functional programming community proved, monadic computation gives us really powerful syntax for composing, transforming them.  I know `Observable` already provides many useful combinators.  However, providing monad/applicative instance could provide more powerful and intuitive syntax about composing/transforming `Observable` to users like below.   And, some useful operators provided by scalaz can be used (e.g. `^` operator).

``` scala
// The case evaluated as List like monad
// this is equivalent with Observable(3,4,6,8)
for { v <- Observable(1,2);
      w <- Observable(3,4)} yield v*w  
=== ^(Observable(1,2),Observable(3,4)){_*_}

// The case evaluated as ZipList like applicative
// this is equivalent with Observable(3,8)
for { v <- Observable(1,2);
      w <- Observable(3,4)} yield v*w  
=== ^(Observable(1,2),Observable(3,4)){_*_}
```

Then, I would be happy if I could hear opinions from RxScala contributors.
- Would it be really useful if RxScala includes some functional typeclass instances?
- If so, what is the best way to contribute??  I think it would be better that we introduce
  - `rx.lang.scala.scalaz` package in `language-adaptors/rxjava-scala`, or
  - new contrib project like `rxjava-scalaz` in `rxjava-contrib` directory.,I also find `foreach` is missing.

/cc @headinthebox @samuelgruetter
 =||= @zsxwing Yeah, Thanks for pointing out what is missing.
I recognize that some type class instances are missing, for example, `traversable`, `foldable`, and so on.  I am pleased to contribute these instances as well. 

Let's list them! 
 =||= Regarding foreach: It is blocking, so it's not in Observable, but in BlockingObservable. Theoretically, it would also be possible to make a non-blocking foreach, but in C# and Java, it's blocking, and I think it wouldn't be a good idea to change the semantics.
And @everpeace your contributions are welcome, just make sure that the main `rxjava-scala` package has no dependency on scalaz.
 =||= @samuelgruetter Thanks for pointing out semantic gap issue.   I agree with your opinion.  I will add type class instances which preserve `Observable`'s semantics.

So, which is better do you think??  May I add a dependency to `scalaz` to `rxjava-scala`?  Or, another project in `rxjava-contrib` is better?
 =||= I'd say do another project, the goal is to try tokeepthe core of Rx (all flavored) lean and mean, and let people to chose if they want additional stuff.and no depend cries on Scalaz. KISS.
 =||= @headinthebox 
Thanks for leading a direction I should follow.  OK. I will create a project, 'rx-scalaz' or something, in `rxjava-contrib` folder.  I will take a week off in the next week. So, I will make PR around the end of this month.

Thanks!
 =||= ,0
1301,1258,RxScala: Subscription add with block expression,```
final def add(s: Subscription): Unit = {
    asJavaSubscriber.add(s.asJavaSubscription)
  }
```

add

```
final def add(s: =>Unit): Unit = ...
```

So you can write `s.add{ blah; blah }`,I'll take a stab at this issue.
 =||= cool
 =||= ,0
1304,1251,RxScala mergeMap and concatMap bindings missing,Bindings for `mergeMap` and `concatMap` are missing in RxScala.

My proposal is to merge `mergeMap` and `flatMap`.,@zsxwing Can you get these in soon before 0.19? Otherwise we can pick them up in 0.19.1.

By the way, `mergeMap` was created as an alias after discussion with you when we created `concatMap` and `switchMap`. The idea was to have "map" functions for each of `merge`, `concat`, and `switch`, but that `flatMap` is the term everyone uses for `mergeMap` so both would exist.

It seems you feel differently now? Should we deprecate `mergeMap` in rxjava-core and remove it when we hit 1.0RC?
 =||= Totally inconsistent I know, but I like to have all the aliases in RxJava core, but for the Scala bindings it feels more natural to only have `flatMap` and drop the `mergeMap` alias. But as I say, this is totally irrational ;-) and I would be OK to have all. 
 =||= > @zsxwing Can you get these in soon before 0.19? Otherwise we can pick them up in 0.19.1.

@benjchristensen this one will not be a breaking change in RxScala. So both are good to me.
 =||= @zsxwing Any preference? We can always add `mergeMap` later, but once we put it in as an alias for `flatMap` it is in forever.
 =||= Speaking as a user of RxScala and Scala, I would say just to have flatMap, since that's what a Scala user would expect. Anything inherit in the missing mergeMap functions that would make that confusing?
 =||= @headinthebox I mean now there is only a `flatMap` method in RxScala, so we can add other methods to RxScala at any time without breaking anything. Never mind. Already sent a PR to add them, #1304
 =||= ,0
1327,1318,Joins - Only plan upto 3 implemented in RxJava but Rx has 16,Is it possible to have larger plans for joins.

(Also besace it is not is the core concerned about how optimised the implementation is.),That 3 was tedious to implement and there was no one at the time who needed it or understood its use case.
 =||= If you try to zip together about 16 streams in different combinations like DAG you will see how useful this is. Ideally there should a lot more than 16 as you will be dealing with a large number of streams to coordinate between in some cases.
 =||= One problem is that the operator requires a function callback with that arity, but we have only up to Func9. I didn't understand the operator enough so I could try with FuncN: there might be no good way to generalize to any arity with FuncN. Adding the remaining 4-9 arity version is mostly mechanical; one could always use Rx.NET as cheat-sheet, but writing tests is cumbersome.
 =||= I'b be really surprised any human can patterns over more than 3 streams by hand because of the combinatorial explosion. Are you generating the code?
 =||= I certainly didn't. I saw Rx.NET use code generators on this. I'm not sure if we have anything similar available with Gradle and/or annotation processing.
 =||= Then stop at 9 and N. When you have more function arity then add accordingly.
 =||= Up to 9 was added ... closing out.
 =||= ,0
1347,1344,schedulePeriodically cannot be unsubscribed from,The subscription returned by `schedulePeriodically()` is automatically marked as unsubscribed when the first run terminates, after queuing the next event. As a result, the periodic event cannot be unsubscribed from once the first `call()` happens, as `unsubscribe()` will now be a no-op (as `isUnsubscribed` is true).

Example in the Scala REPL (with the Java bindings for RxJava 0.19):

``` scala
import rx._
import rx.functions._
import rx.schedulers.Schedulers
import java.util.concurrent.TimeUnit
val s = Schedulers.io().createWorker.schedulePeriodically(new Action0 { override def call = println("In call") }, 1, 1, TimeUnit.SECONDS)
s.isUnsubscribed
```

Here, `s.isUnsubscribed()` returns `false`. However, if you wait one second, it will return `true` and `s.unsubscribe()` will not do anything and the constant display will continue every second.,nan,0
1359,1310,MpscPaddedQueue does not pad correctly,The padding should be done with a 3 class hierarchy like I explained in this issue:
https://github.com/netty/netty/pull/2529

Also you may want to use 128 bytes for padding as some newer HW use 128 bytes cache-lines,@normanmaurer you mean to avoid DCE?
 =||= @daschl DCE ?
 =||= Dead Code Elimination
 =||= @daschl nope reordering fields ... Check https://github.com/netty/netty/pull/2529#commitcomment-6535582
 =||= A PR is welcome.
 =||= @akarnokd sure will do later today :)
 =||= Would be nice to get the iterator() implementation as well, so we can completly replace ConcurrentLinkedQueue with this class.
 =||= Our Mpsc queue was not meant to be a replacement for CLQ, just to be a simple offer/poll for serializing between threads (i.e., observeOn, SerializedObserver, custom Scheduler).
 =||= Ah, wasn't aware of that.
 =||= Completed in https://github.com/Netflix/RxJava/pull/1359
 =||= Anyone have opinions of the code from https://github.com/JCTools/JCTools/tree/master/jctools-core/src/main/java/org/jctools/queues ?

I've been playing with them on another branch and they seem good. I ask here as it relates to the same type of issues.
 =||= @benjchristensen I can really recommend @nitsanw's queues :)
 =||= Would be very interested in being added as a dependency, code should be on maven in the next few week in version 0.1.
 =||= @nitsanw I hope we can keep RxJava without dependencies :)
 =||= @daschl @normanmaurer @benjchristensen 
I appreciate we all want to make user's life easier, which is why a <my-lib-name>-all.jar is a nice way to publish your artifact. It's easy enough to support via maven build.
The current practice of copying and pasting randomly old versions of dependencies seems worse IMHO (imagine a bug in version X fixed in version Y, which version did RxJava use?). 
Ultimately there is nothing I can (or wish to) do to stop people, you are always welcome to copy my code if that's how you roll ;-)
 =||= @daschl @normanmaurer @benjchristensen
JCTools now includes an unbounded MPSC:
https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/MpscLinkedQueue.java
The algorithm is the same as the one followed by Rx/Netty. The class layout is different as both head/tail node references are fields of the main data structure.
From re-reading the code in Rx/Netty I believe you suffer from false sharing as the writes to the tail field invalidate the cache line holding the reference to the PaddedReference to head.
Also note the queue class fields are themselves not padded leading to potential false sharing between the queue and it's neighbors. 
 =||= Thanks for submitting a fix for this @nitsanw in https://github.com/Netflix/RxJava/pull/1374
 =||= ,0
1361,1354,NPE in pollQueue,Since using 0.19 I see some sporadic NPEs where the complete stack trace contains only rx methods. Therefore I cannot really say what conditions in our code trigger that NPE.

```
06-11 23:18:24.060: E/AndroidRuntime(15279): java.lang.NullPointerException
06-11 23:18:24.060: E/AndroidRuntime(15279):    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:135)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:61)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$1.call(OperatorObserveOn.java:121)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at rx.android.schedulers.HandlerThreadScheduler$InnerHandlerThreadScheduler$1.run(HandlerThreadScheduler.java:77)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at android.os.Handler.handleCallback(Handler.java:733)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at android.os.Handler.dispatchMessage(Handler.java:95)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at android.os.Looper.loop(Looper.java:136)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at android.app.ActivityThread.main(ActivityThread.java:5144)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at java.lang.reflect.Method.invokeNative(Native Method)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at java.lang.reflect.Method.invoke(Method.java:515)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:795)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:611)
06-11 23:18:24.060: E/AndroidRuntime(15279):    at dalvik.system.NativeStart.main(Native Method)
´´´
```,Hi. I can't see anything obviously wrong with the ObserveOn; it appears either vs is null or the vs.array is null, which both should be impossible since vs is never set to null and vs.array should contain an object array with at least a single value because the pollQueue is executed only after it has gained its first item. So either the AtomicLongFieldUpdater on Android doesn't behave correctly or JIT compilation generates incorrect code or memory fences.
 =||= @akarnokd : what if `onNext` is called twice at the same time? Wouldn't that cause a race condition, where both could execute their `queue.add` (successively since this part of code is synchronized), one of them would execute its `schedule` which calls `pollQueue` which empties the list, then the other does the same while the list is now empty?

If Murphy's law kicks in and one of the `onNext` is stopped for some time right before `schedule`, I don't immediately see anything to prevent this.
 =||= (I'm not sure this can happen though, as `COUNTER_UPDATER` would have gone to -1 at this time and a new `pollQueue` should not be scheduled as the initial state of the counter is not 0)
 =||= You're right. The queue is of length 2 and the counter is decremented to -1 by pollQueue and then incremented to 0 by onNext without scheduling another pollQueue. Due to -1 and the == after addAndGet, it doesn't quit and now reads a FastList with null array. Changing the == 0 to > 0 should fix the problem. I can't do a PR until Monday.
 =||= I can do one in order to get some reviews (and I think you mean `<= 0`, or you want to put the test in the `while` part which also makes sense and seems even more readable to me).

Edit: putting it in the `while` would force to widen the scope of `vs` which is not elegant.
 =||= ,0
1362,1340,RxScala,I thought we agreed to keep `create` to avoid confusion (i.e. for those that watch the Coursera course) and all. So let's remove the annotation.

```
@deprecated("Use `apply[T](Subscriber[T] => Unit)` instead", "0.17.0")
```,Looks RxJava will remove `create(final OnSubscribeFunc<T> f)` in 1.0. So implement it in RxScala?
 =||= Yes, let's do that. Let's leverage the fact that Scala has `apply` so we can use `create` for unconfusing the students.
 =||= +1
 =||= It's now two years, later, and things might have changed since then, so maybe we should revisit this decision? That is, I suggest to deprecate and then remove the method

```
def create[T](f: Observer[T] => Subscription): Observable[T]
```

Is this cousera course still being taught?
I'm suggesting this because it seems that nowadays, people are not confused by the _absence_ of this method, but by its _presence_, see [this issue](https://github.com/ReactiveX/RxScala/issues/195).
 =||= Wrong project? RxJava no longer has such a create() factory method but one that takes `OnSubscribe<T>`:

https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Observable.java#L93

although the `SyncOnSubscribe` and `AsyncOnSubscribe` overloads may pose some problems.
 =||= Oh, sorry, of course I meant RxScala. I just wrote it here because it belongs to this thread, and this thread was started when RxScala was in the same repo as RxJava.
 =||= ,0
1362,1340,RxScala,I thought we agreed to keep `create` to avoid confusion (i.e. for those that watch the Coursera course) and all. So let's remove the annotation.

```
@deprecated("Use `apply[T](Subscriber[T] => Unit)` instead", "0.17.0")
```,Looks RxJava will remove `create(final OnSubscribeFunc<T> f)` in 1.0. So implement it in RxScala?
 =||= Yes, let's do that. Let's leverage the fact that Scala has `apply` so we can use `create` for unconfusing the students.
 =||= +1
 =||= It's now two years, later, and things might have changed since then, so maybe we should revisit this decision? That is, I suggest to deprecate and then remove the method

```
def create[T](f: Observer[T] => Subscription): Observable[T]
```

Is this cousera course still being taught?
I'm suggesting this because it seems that nowadays, people are not confused by the _absence_ of this method, but by its _presence_, see [this issue](https://github.com/ReactiveX/RxScala/issues/195).
 =||= Wrong project? RxJava no longer has such a create() factory method but one that takes `OnSubscribe<T>`:

https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Observable.java#L93

although the `SyncOnSubscribe` and `AsyncOnSubscribe` overloads may pose some problems.
 =||= Oh, sorry, of course I meant RxScala. I just wrote it here because it belongs to this thread, and this thread was started when RxScala was in the same repo as RxJava.
 =||= ,0
1362,1343,RxScala: mysterious comment in source,The source has a few occurrences of `/*XXX*/`. Are they there for a reason, i.e. magic trick to make the Scala compiler run twice as fast, or just leftovers.,I believe they are from @DavidMGross as placeholder for where Javadocs need work.
 =||= That's what I thought. I'm not going to jinx @DavidMGross ...
 =||= Nope; not my doing. The placeholders I've been adding lately are taking the form:

`* @warn some work needs done right about here`

I haven't added anything like "XXX"
 =||= And I haven't been doing much of anything with the source inside of RxScala
 =||= (of course I could have used GIT powers to check that).

OK, I'll eliminate them.
 =||= ,0
1367,1365,Exception in the inner observable of flatMap not rethrown,Hi all,
I'm trying to figure out, how errors are handled in RxJava (0.19.1). Basically, I'd expect the fundamental rule to be something like: _Any exception thrown within an operator is either handed to the onError handler of subscribe if one is provided, or rethrown if none is provided._

This works for the map operator: 

``` scala
def throwOnB2(prefix: String) = Observable.from(List(1, 2, 3))
  .map(x ⇒ prefix + x.toString)
  .map(s ⇒ if (s == "b2") throw new Exception("Bang!") else s)

throwOnB2("b").subscribe(next ⇒ println(next))
```

throws a `rx.exceptions.OnErrorNotImplementedException: Bang!` as expected.

``` scala
throwOnB2("b").subscribe(
  next ⇒ println(next),
  err ⇒ println(s"error: ${err}"),
  () ⇒ println("completed")
)
```

prints `error: java.lang.Exception: Bang!` as expected.

For nested observables joined using `flatMap`

``` scala
def nested = Observable
  .from(List("a", "b", "c"))
  .flatMap(prefix ⇒ throwOnB2(prefix))

nested
  .subscribe(
    next ⇒ println(next),
    err ⇒ println(s"error: ${err}"),
    () ⇒ println("completed")
  )
```

prints `error: java.lang.Exception: Bang!` as expected,

**But:**

``` scala
nested.subscribe(next ⇒ println(next))
```

prints

```
a1
a2
a3
b1
```

and finishes without throwing any exception. 

Is this the intended behavior? For me it is quite unfortunate, since bugs in my code can easily slip away unnoticed, but perhaps there is something I don't see.

Thank you, best regards,@dvtomas Good catch.
 =||= ,0
1374,1310,MpscPaddedQueue does not pad correctly,The padding should be done with a 3 class hierarchy like I explained in this issue:
https://github.com/netty/netty/pull/2529

Also you may want to use 128 bytes for padding as some newer HW use 128 bytes cache-lines,@normanmaurer you mean to avoid DCE?
 =||= @daschl DCE ?
 =||= Dead Code Elimination
 =||= @daschl nope reordering fields ... Check https://github.com/netty/netty/pull/2529#commitcomment-6535582
 =||= A PR is welcome.
 =||= @akarnokd sure will do later today :)
 =||= Would be nice to get the iterator() implementation as well, so we can completly replace ConcurrentLinkedQueue with this class.
 =||= Our Mpsc queue was not meant to be a replacement for CLQ, just to be a simple offer/poll for serializing between threads (i.e., observeOn, SerializedObserver, custom Scheduler).
 =||= Ah, wasn't aware of that.
 =||= Completed in https://github.com/Netflix/RxJava/pull/1359
 =||= Anyone have opinions of the code from https://github.com/JCTools/JCTools/tree/master/jctools-core/src/main/java/org/jctools/queues ?

I've been playing with them on another branch and they seem good. I ask here as it relates to the same type of issues.
 =||= @benjchristensen I can really recommend @nitsanw's queues :)
 =||= Would be very interested in being added as a dependency, code should be on maven in the next few week in version 0.1.
 =||= @nitsanw I hope we can keep RxJava without dependencies :)
 =||= @daschl @normanmaurer @benjchristensen 
I appreciate we all want to make user's life easier, which is why a <my-lib-name>-all.jar is a nice way to publish your artifact. It's easy enough to support via maven build.
The current practice of copying and pasting randomly old versions of dependencies seems worse IMHO (imagine a bug in version X fixed in version Y, which version did RxJava use?). 
Ultimately there is nothing I can (or wish to) do to stop people, you are always welcome to copy my code if that's how you roll ;-)
 =||= @daschl @normanmaurer @benjchristensen
JCTools now includes an unbounded MPSC:
https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/MpscLinkedQueue.java
The algorithm is the same as the one followed by Rx/Netty. The class layout is different as both head/tail node references are fields of the main data structure.
From re-reading the code in Rx/Netty I believe you suffer from false sharing as the writes to the tail field invalidate the cache line holding the reference to the PaddedReference to head.
Also note the queue class fields are themselves not padded leading to potential false sharing between the queue and it's neighbors. 
 =||= Thanks for submitting a fix for this @nitsanw in https://github.com/Netflix/RxJava/pull/1374
 =||= ,0
1393,130,Compatibility Test Suite via port of Rx.Net Unit Tests,To get to 1.0 and claim equivalence to Rx.Net it would be very beneficial to have an automated way of converting the Rx.Net code from C# to Java (if realistic) and running them as a compatibility test suite - for functionality but also for feature completion.

https://rx.codeplex.com/SourceControl/changeset/view/5526a6f490db#README.md

It is not intended to attempt automated conversion of C# code for the actual code - that has been looked at and isn't realistic. The unit tests may be possible (scripting, search/replace from C# to Java/Groovy or something similar)

Some of the tricks will be:
- naming idioms will be different for some things
- we will need to do it in such a way that compilation errors are handled as "test failures" rather than preventing the entire suite from running (perhaps a dynamic language would be easier for this?)
- we need the ability to update the test suite whenever needed in a fully automated way so that as Rx.Net code changes we can easily update the RxJava compatibility test suite
- schedulers will be based on Java ExecutorService and java.util.concurrent so this may affect unit tests from .Net

These tests are also not intended to replace unit tests written manually in Java/Groovy/Clojure etc as already doing as part of the core code - these are intended to supplement and be used primarily to track completeness and demonstrate compatibility (if it can even be done).,Not going to happen ... may reincarnate as part of https://github.com/ReactiveX but not going to keep it open here.
 =||= ,0
1398,1392,RxScala: more opportunities for better type inference,Some other function that we might look at (amongst others)

```
def window[Opening](openings: Observable[Opening], closings: Opening => Observable[Any]) = ???
def buffer[Opening](openings: Observable[Opening], closings: Opening => Observable[Any]): Observable[Seq[T]] = ???
def flatMap[U, R](collectionSelector: T => Observable[U], resultSelector: (T, U) => R): Observable[R] = ???
def flatMapIterable[U, R](collectionSelector: T => Iterable[U], resultSelector: (T, U) => R): Observable[R] = ???
def groupByUntil[K](f: T => K, closings: (K, Observable[T])=>Observable[Any]): Observable[(K, Observable[T])] = ???
def groupByUntil[K, V](keySelector: T => K, valueSelector: T => V, closings: (K, Observable[V]) => Observable[Any]): Observable[(K, Observable[V])] = ???
def groupJoin[S, R](other: Observable[S], leftDuration: T => Observable[Any], rightDuration: S => Observable[Any], resultSelector: (T, Observable[S]) => R): Observable[R] = ???
def sequenceEqual[U >: T](that: Observable[U], equality: (U, U) => Boolean): Observable[Boolean] = ???
```

to

```
def window[Opening](openings: Observable[Opening])(closings: Opening => Observable[Any]) = ???
def buffer[Opening](openings: Observable[Opening])(closings: Opening => Observable[Any]): Observable[Seq[T]] = ???
 def flatMap[U, R](collectionSelector: T => Observable[U])(resultSelector: (T, U) => R): Observable[R] = ???
def flatMapIterable[U, R](collectionSelector: T => Iterable[U])(resultSelector: (T, U) => R): Observable[R] = ???
def groupByUntil[K](f: T => K)(closings: (K, Observable[T])=>Observable[Any]): Observable[(K, Observable[T])] = ???
def groupByUntil[K, V](keySelector: T => K)(valueSelector: T => V)(closings: (K, Observable[V]) => Observable[Any]): Observable[(K, Observable[V])] = ???
def groupJoin[S, R](other: Observable[S])(leftDuration: T => Observable[Any], rightDuration: S => Observable[Any], resultSelector: (T, Observable[S]) => R): Observable[R] = ???
def sequenceEqual[U >: T](that: Observable[U])(equality: (U, U) => Boolean): Observable[Boolean] = ???
```

This is more in-line with `scan` and `fold` as well.,See this post for more info http://pchiusano.blogspot.in/2011/05/making-most-of-scalas-extremely-limited.html. 

I have to confess that coming from C# where the uncurried signatures just work, having to write types in Scala all the time, and worse fighting the compiler to fix type errors, was always annoying but I did not know that currying would fix a lot of the pain until Martin Odersky told me when I complained about it to him.

I will go through all RxScala signatures and curry them as much as possible for the 0.20 release. This will be a lot of breaking changes, but it will make using Rx in Scala orders of magnitude more pleasant, and this is our last opportunity to do that.

So speak now or forever hold your peace.
 =||= Nice post. +1 for using currying.
 =||= There are conflicts in the following methods if using currying

``` scala
def flatMap[R](f: T => Observable[R]): Observable[R]
def flatMap[U, R](collectionSelector: T => Observable[U])(resultSelector: (T, U) => R): Observable[R]

def flatMapIterable[R](collectionSelector: T => Iterable[R]): Observable[R]
def flatMapIterable[U, R](collectionSelector: T => Iterable[U])(resultSelector: (T, U) => R): Observable[R]

def buffer(boundary: => Observable[Any]): Observable[Seq[T]]
def buffer[Opening](openings: Observable[Opening])(closings: Opening => Observable[Any]): Observable[Seq[T]]

def window(boundary: => Observable[Any]): Observable[Observable[T]]
def window[Opening](openings: Observable[Opening], closings: Opening => Observable[Any])

def sequenceEqual[U >: T](that: Observable[U]): Observable[Boolean]
def sequenceEqual[U >: T](that: Observable[U])(equality: (U, U) => Boolean): Observable[Boolean]
```

E.g.,
The compiler will report "error: missing parameter type" for the following code:

``` scala
    val o = Observable.items(10, 100)
    o.flatMap(n => Observable.interval(200 millis).map(_ * n))
      .take(20)
      .toBlocking.foreach(println)
```

I need to add `Int` to resolve it:

``` scala
    val o = Observable.items(10, 100)
    o.flatMap[Int](n => Observable.interval(200 millis).map(_ * n))
      .take(20)
      .toBlocking.foreach(println)
```

This is quite inconvenient since `flatMap` is a very common operator.

Renaming the currying methods to `xxxWith` can solve the conflicts. @headinthebox thoughts?
 =||= > Renaming the currying methods to `xxxWith` can solve the conflicts

Yes, that was I was thinking as well for `flatMap`. We do that for `zipWith` already, and in case of `flatMap` it is the same pattern as `zip` where we pass in an additional result selector.

That will work for `sequenceEqual` as well. So those are OK.

For `window` and `buffer` I need to sleep over it, there the second function is not a result selector like the previous ones.
 =||= For window and buffer we may use `tumblingWindow` and `tumblingBuffer` for the overloads that only take boundaries, and the ones that take opening and closing `slidingWindow` and `slidingBuffer` (that's what the CEP people call them). I actually like that because it makes the difference clear in the name. How does that sound @zsxwing ?
 =||= Also, Scala has `sliding` (http://www.scala-lang.org/api/current/index.html#scala.collection.Seq) but they use `sliding` for both tumbling (non-overlapping) as well as for properly sliding windows.

Maybe we should `sliding` and `tumbling` as shorthands for `tumblingWindow` and `slidingWindow` and then use the appropriate long names for buffer, since that more "dangerous" because it buffers.
 =||= And another option is something like this

``` scala
def flatMap[S, R](f: T => Observable[S]): Observable[S] with Object {
          def finish[R](g: (T, S) => R): Observable[R]
    } = new Observable[S] {
        override private [scala] val asJavaObservable: rx.Observable[_ <: S] = src.flatMap(f).asJavaObservable
        def finish[R](g: (T,S)=>R) = src.flatMap(f, g)
    }
```

which allows you to write `xs.flatMap(f).finish(g).map(h)` as well as `xs.flatMap(f).map(h)`.

Would like to use `with` but that is a Scala keyword.

This is a trick of returning a subtype with a few additional methods is something we do in .NET a lot, for example for writing `xs.orderby(f).thenBy(g).map(h)`.
 =||= > xs.flatMap(f).finish(g).map(h)

This does not work because the return type is not a part of method signature. E.g., `val ys = xs.flatMap(f)`, what's the type of `ys`? `flatMap` should be `def flatMap[R](f: T => Observable[R]): Observable[R]` or `def flatMap[S, R](f: T => Observable[S]): Observable[S] with Object {...`?
 =||= The latter, you return a subtype that has additional methods, which is the static type of ys.
 =||= Oh, I see. Sorry that I misunderstood your idea. So you mean combining the two methods:

``` scala
def flatMap[R](f: T => Observable[R]): Observable[R]
def flatMap[U, R](collectionSelector: T => Observable[U])(resultSelector: (T, U) => R): Observable[R]
```

to only one method?

However, I prefer the renaming idea. I like less Observables and less concepts.
 =||= In addition, for `sequenceEqual`, Scala `Seq` has `sameElements`. Do you think which one is better, renaming `sequenceEqual` to `sameElements`, or add `sameElements` as an alias to `sequenceEqual`?
 =||= > Maybe we should sliding and tumbling as shorthands for tumblingWindow and slidingWindow and then use the appropriate long names for buffer, since that more "dangerous" because it buffers.

Sounds great to me.
 =||= Is this issue done now?
 =||= ,0
1422,1420,Merge Missing Emission Bug - Causes Hangs,Doing a canary test of the current 0.20 code in master branch with real workloads, it runs fine for several hours and then non-deterministically fails over a couple hours.

Threads end up in this state:

```
204 WAITING
    at sun.misc.Unsafe.park(Native Method)
    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)
    at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
    at rx.internal.operators.BlockingOperatorToIterator$2.take(BlockingOperatorToIterator.java:92)
```

Here is a screenshot showing 3 instances over 9 hours how they perform well until something triggers the bug at different times on each box:

![screen shot 2014-07-09 at 9 42 09 am](https://cloud.githubusercontent.com/assets/813492/3527738/0968e970-0788-11e4-9de8-2d43aff51c8e.png),@benjchristensen Would you be able to provide some information regarding what does the source observable and the chain of operators look like? I guess can can say the after materialize() the complete notification never made it though the internal subscriber in BlockingOperatorToIterator?
 =||= Does it use backpressure?
 =||= > what does the source observable and the chain of operators look like

It is a list of Observables that each return a single item being merged together.

```
   java.lang.Thread.State: WAITING (parking)
    at sun.misc.Unsafe.park(Native Method)
    - parking to wait for  <0x00007f69fe0c6798> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)
    at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
    at rx.internal.operators.BlockingOperatorToIterator$2.take(BlockingOperatorToIterator.java:92)
    at rx.internal.operators.BlockingOperatorToIterator$2.hasNext(BlockingOperatorToIterator.java:72)
    at rx.internal.operators.BlockingOperatorToIterator$2.next(BlockingOperatorToIterator.java:82)
    at rx.observables.BlockingObservable.single(BlockingObservable.java:348)
    at com.netflix.api.service....
    at rx.Observable$2.call(Observable.java:163)
    at rx.Observable$2.call(Observable.java:156)
    at rx.Observable.unsafeSubscribe(Observable.java:6846)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.handleNewSource(OperatorMerge.java:127)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:110)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:49)
    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)
```

> Does it use backpressure?

Nothing is explicitly using backpressure except for changes in RxJava itself. The codebase is currently running RxJvaa 0.19.2 and I'm dropping in 0.20.0-SNAPSHOT.

Debugging as I have time ... 
 =||= Pretty certain this is yet another concurrency bug in `merge`.
 =||= See my zip pr for a candidate. If I have time, I'll look at merge.
 =||= I had some time but the current merge is so complicated I can't make anything out of it.
 =||= I really don't like the `merge` code, but everything I try to simplify it (such as simple "add to queue then drain") kills the performance significantly.
 =||= The changes in #1422 did not solve this. I ran a new canary and have the same issue. Digging ...
 =||= That is a scary stack trace. Does the simplification kill perf for the non-backpressure case as well? 
 =||= No, the simplification in #1422 didn't kill perf.

The stack trace itself is pretty normal (`merge` does `unsafeSubscribe`) except for the ugliness of how `toBlocking` is being used by the Observables being merged :-(

Thus far I still have no idea what causes this to fail. I can't replicate it anywhere except for production and that's making it very hard to track down.
 =||= I confirmed over the weekend with a production canary that the issue is related to `merge`. I took the code in master branch and reverted `OperatorMerge` to 0.19.x code but left everything else as is. The issue did not occur. Continuing to dig ... I have an idea as to where the issue might be.
 =||= Code changes I've committed seem to have fixed this issue. I've had the code running in production for 12 hours and the score is good and thread dumps look clean. 
 =||= @benjchristensen great news!
 =||= Looks like this isn't completely solved, as I'm seeing it still, just far less often.

I'm going to commit a change that I know solves it, but it uses synchronization in a bad way. I don't yet understand the actual issue, just the symptoms and the hammer that removes the symptoms.
 =||= Could you help me understand how `merge(Observable<Observable<T>>)` works? If the downstream requests 10 elements, how is that translated to requests to the outer and inner observables? Even if any requests are transformed into one-by-one requests, that can't be held in a fixed buffer because either one requests 1 from N observables, which might not deliver or requests 1 from all observables where there could be a buffer overrun if all produce?
 =||= The outer is unbounded (except in the optimized case with `ScalarSynchronousObservable`). The `merge(Observable<Observable<T>>)` case is an odd one, and basically the user is asking for unbounded horizontal buffering.

We can achieve backpressure vertically (how many items queued per Observable) but not horizontally (number of Observables being merged). The reasoning is:
- A user can't control how many onNext per Observable flow, but they can generally control the number of Observables they are merging.
- We can't restrict how many Observables are merged unless the user asks for it (such as `merge(Observable o, int maxConcurrent)` because it may only be the very last Observable that emits, so if we sit waiting on the first ones we may never receive any values and never move on to the final Observable that has the data.

This is different in the `ScalarSynchronousObservable` case as we treat those as `onNext` and don't even subscribe to them. This is why the `request(1)` behavior occurs in the current `merge` implementation at these two locations:
- every Observable we receive we automatically request more: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java#L191
- on `ScalarSynchronousObservable`s we only request more once we have been able to emit their values: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java#L230
 =||= I've solved this for now with synchronization so am closing. I'll work more on this over time for performance and efficiency reasons, but as of 0.20.0-RC3 the issue is not showing itself and I have successfully passed a 20-hour production canary test in Netflix API production.
 =||= ,0
1431,1405,CompositeException issue,I'm using RxJava on Android and I've encountered issues with CompositeException. Because it collects throwables as `Collection<Throwable> errors` the exceptions are not logged to the logcat output if there is an unhandled Exception in onError callback. 

Here is a sample output:

```
2739:E/AndroidRuntime(14639): FATAL EXCEPTION: main
2740:E/AndroidRuntime(14639): rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError
2741:E/AndroidRuntime(14639):   at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:182)
2742:E/AndroidRuntime(14639):   at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:103)
2743:E/AndroidRuntime(14639):   at rx.internal.operators.NotificationLite.accept(NotificationLite.java:144)
2744:E/AndroidRuntime(14639):   at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:139)
2745:E/AndroidRuntime(14639):   at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:61)
2746:E/AndroidRuntime(14639):   at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$1.call(OperatorObserveOn.java:121)
2747:E/AndroidRuntime(14639):   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)
2748:E/AndroidRuntime(14639):   at android.os.Handler.handleCallback(Handler.java:730)
2749:E/AndroidRuntime(14639):   at android.os.Handler.dispatchMessage(Handler.java:92)
2750:E/AndroidRuntime(14639):   at android.os.Looper.loop(Looper.java:137)
2751:E/AndroidRuntime(14639):   at android.app.ActivityThread.main(ActivityThread.java:5103)
2752:E/AndroidRuntime(14639):   at java.lang.reflect.Method.invokeNative(Native Method)
2753:E/AndroidRuntime(14639):   at java.lang.reflect.Method.invoke(Method.java:525)
2754:E/AndroidRuntime(14639):   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:737)
2755:E/AndroidRuntime(14639):   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553)
2756:E/AndroidRuntime(14639):   at dalvik.system.NativeStart.main(Native Method)
2757:E/AndroidRuntime(14639): Caused by: rx.exceptions.CompositeException: 2 exceptions occurred. See them in causal chain below.
2758:E/AndroidRuntime(14639):   ... 16 more
```

That's it. No logs about real cause. I can wrap my onError code in try catch block and log the real cause, but I think this can be handled better by RxJava. What do you guys think?,How do you recommend doing it differently? 
 =||= What about using `initCause` (API 1) or I'm sure `addSuppressed` is dedicated for this case but as far as I remember it was introduced in java 7, so it's available in KitKat (API 19)
 =||= We print them out when `printStackTrace()` is called, but we no longer add them as part of the actual causal chain as it could end up causing circular loops under odd edge-cases. This was just barely changed in the last release: https://github.com/Netflix/RxJava/pull/1388

Here is the code: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/exceptions/CompositeException.java

Note how it will print all causes: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/exceptions/CompositeException.java#L111

What version of RxJava are you running to get that stack trace?

In the example you give, it looks like the chain is being cropped when it had more to display (2 causes).

I'm wondering if Android does something different than normal Java and doesn't actually invoke the `printStackTrace()` method and thus won't see the causal chain?
 =||= I'm using 0.19.2. I've also encountered problems with the previous version when unhandled exception in onError ended up in circular loop and crash of a StringBuilder but current implementation doesn't provide any useful information for debugging. If you are using error logging service like Bugsense or Crashlytics the only information you see is the stacktrace I've pasted above - it's useless.

Solution with `initCause` works perfect for me. What do you think about it?
 =||= As I said above, we used to use `initCause`, but because this is a composite of many exceptions, we are creating an artificial causal chain and it could result in infinite loops, hence it being removed in 0.19.2.

I can't speak to Bugsense or Crashlytics, but if something printing a stack trace calls `printStackTrace` then it would work and print out the full list of causes.

For historical information, here is the version that used `initCause`: https://github.com/Netflix/RxJava/blob/ea2249afecbf4d1380f2d7b0775fec60e37e3369/rxjava-core/src/main/java/rx/exceptions/CompositeException.java#L108 and the current one without it: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/exceptions/CompositeException.java#L111

We need a solution that either does not use `initCause` due to the circular-reference problem, or solves the circular-reference problem. The change done in https://github.com/Netflix/RxJava/pull/1388 was based on the assumption that anything printing a stack trace would do it correctly via the `printStackTrace()` method and thus we can override the printing of the causes so the causal chain is shown, but not actually mutate the chain by using `initCause` which is what causes the issues.
 =||= Ok I've dive deeper into the implementation and it turns out that none of the `printStackTrace` methods are called when an `OnErrorFailedException` is thrown. Only `getMessage` and `getCause` methods are called so the real cause is not printed to the output. Here is my simple test with logged methods of the `CompositeException` class.

```
        AndroidRuntime  D  Shutting down VM
              dalvikvm  W  threadid=1: thread exiting with uncaught exception (group=0x4195e700)
 gt_CompositeException  I  CompositeException.getMessage
                        I  CompositeException.getCause
              dalvikvm  D  GC_FOR_ALLOC freed 453K, 5% free 11287K/11776K, paused 29ms, total 30ms
 gt_CompositeException  I  CompositeException.getCause
                        I  CompositeException.getMessage
                        I  CompositeException.getCause
        AndroidRuntime  E  FATAL EXCEPTION: main
                        E  rx.exceptions.OnErrorFailedException: a
                        E   at test.MainActivity.refreshTasksLists(MainActivity.java:267)
                        E   at test.MainActivity.onCreateOptionsMenu(MainActivity.java:156)
                        E   at android.app.Activity.onCreatePanelMenu(Activity.java:2504)
                        E   at com.android.internal.policy.impl.PhoneWindow.preparePanel(PhoneWindow.java:413)
                        E   at com.android.internal.policy.impl.PhoneWindow.doInvalidatePanelMenu(PhoneWindow.java:775)
                        E   at com.android.internal.policy.impl.PhoneWindow$1.run(PhoneWindow.java:198)
                        E   at android.view.Choreographer$CallbackRecord.run(Choreographer.java:749)
                        E   at android.view.Choreographer.doCallbacks(Choreographer.java:562)
                        E   at android.view.Choreographer.doFrame(Choreographer.java:531)
                        E   at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:735)
                        E   at android.os.Handler.handleCallback(Handler.java:730)
                        E   at android.os.Handler.dispatchMessage(Handler.java:92)
                        E   at android.os.Looper.loop(Looper.java:137)
                        E   at android.app.ActivityThread.main(ActivityThread.java:5103)
                        E   at java.lang.reflect.Method.invokeNative(Native Method)
                        E   at java.lang.reflect.Method.invoke(Method.java:525)
                        E   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:737)
                        E   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553)
                        E   at dalvik.system.NativeStart.main(Native Method)
                        E  Caused by: test.CompositeException: 2 exceptions occurred. See them in causal chain below.
                        E   ... 19 more
 gt_CompositeException  I  CompositeException.getMessage
                        I  CompositeException.getCause
                        I  CompositeException.getMessage
                        I  CompositeException.getCause

                           Process 28215 ended
```

It turns out Android has its own implementation of a `Throwable` with uses `private void private void printStackTrace(Appendable err, String indent, StackTraceElement[] parentStack)` to print the stacktrace. If the `cause` is `null` nothing is printed to the output.

I don't see any solution for this issue. For KitKat and above the `addSuppressed` is an easy fix, but what about older versions?
 =||= What about appending the stack trace to the message of a `CompositeException`? This is some kind of a dirty hack but it will work on any platform regardless of `printStackTrace` implementation.
 =||= Appending the stacktrace to the message is bad practice and would be despised in non-Android environments.

It's very annoying that Android does the wrong thing for this. 

If we do anything, it would need to special-case behavior just for Android (such as appending the whole stack trace as a message).
 =||= I think any working solution would be appreciated by the Android developers society. I ended up wrapping the whole implementation of `onError` in try-catch block so I'm able to log the cause. So far this is a simple workaround but better error logging by the RxJava should be really addressed in the future release.
 =||= @mttkay What do you suggest be done for Android and `CompositeException` since it doesn't behave correctly with `Throwable.printStackTrace()`?

@tomrozb According to the code I see for Android, this should work if the logger is calling `printStackTrace()` as it looks exactly like the Java one: https://android.googlesource.com/platform/libcore.git/+/android-4.2.2_r1/luni/src/main/java/java/lang/Throwable.java

How are the logs being generated? Is this default Android logging that bypasses `printStackTrace()` or a 3rd party logging library?
 =||= Thanks for flagging this. We're still on 0.19.1 so haven't had this problem yet. I'll have a look as well. 
 =||= @benjchristensen 
I'm not using any 3rd party logging library. The logs I've attached are from the standard logging tool called logcat. Logs are generated by Android system. The second posted log is slightly different because I'm using tool to present it in a user-friendly way, but the log is still being generated by Android OS.

Crash reporting tools like Crashlytics or Bugsense utilize the `Thread.UncaughtExceptionHandler` to obtain the stack trace and send it to the server. As I wrote above, stack traces obtained this way are exactly the same as printed by the system.

The `Throwable` implementation is different for Android and plain Java. If they are using the private `printStackTrace` method with 3 arguments to print the stack trace, other public `printStackTrace` methods, which are overridden by RxJava, will not be called when a crash occurred.

I can confirm this bug on:
Galaxy Nexus 4.3 (stock Android)
G900F 4.4.2
GT-I9506 4.4.2
GT-I9195 4.4.2
GT-N7100 4.4.2
SM-T335 4.4.2
SM-T320 4.4.2

I've not tested this on non-samsung devices but I'm sure this apply to all Android devices.
 =||= It is very easy to understand what is going under the hood even without writing a line of code.

The simplest test case:

```
throw new RuntimeException(new CompositeException(Arrays.asList(new RuntimeException("the real cause"))));
```

No matter which one of the `printStackTrace` methods is called in the first place it end up calling the  `printStackTrace(err, "", null)` on a first `RuntimeException`. 

Now take a look at the Throwable implementation (Android 4.2.2)

```
    private void printStackTrace(Appendable err, String indent, StackTraceElement[] parentStack)
            throws IOException {
        err.append(toString());
        err.append("\n");
        StackTraceElement[] stack = getInternalStackTrace();
        if (stack != null) {
            int duplicates = parentStack != null ? countDuplicates(stack, parentStack) : 0;
            for (int i = 0; i < stack.length - duplicates; i++) {
                err.append(indent);
                err.append("\tat ");
                err.append(stack[i].toString());
                err.append("\n");
            }
            if (duplicates > 0) {
                err.append(indent);
                err.append("\t... ");
                err.append(Integer.toString(duplicates));
                err.append(" more\n");
            }
        }
        // Print suppressed exceptions indented one level deeper.
        if (suppressedExceptions != null) {
            for (Throwable throwable : suppressedExceptions) {
                err.append(indent);
                err.append("\tSuppressed: ");
                throwable.printStackTrace(err, indent + "\t", stack);
            }
        }
        Throwable cause = getCause();
        if (cause != null) {
            err.append(indent);
            err.append("Caused by: ");
            cause.printStackTrace(err, indent, stack);
        }
    }
```

What is important the only method used on a `cause` is `printStackTrace` with 3 arguments. Our cause is the `CompositeException` which doesn't have a cause and there is no way to override private `printStackTrace` method so that's why it doesn't work this way.
 =||= Just wondering, if the problem is that Android's `Throwable` refuses to print the stack trace when the cause is null, why not simply return `this` from `CompositeException.getCause`? That way we still don't have to `initCause` on the wrapped exceptions and make Android forward to `CompositeException`'s custom printStackTrace impl.

This is just by reading the discussion mind you, so sorry if I'm not making any sense. I still haven't had time to bump RxJava to a newer version in our app .
 =||= We see more threads getting stuck in infinite loops in `removeDuplicatedCauses`.  Re-opening as we will need to re-fix this.
 =||= So should we revert to what it was when we fixed it last time and special case Android? Or does someone have a legit fix for this?

I'm planning on reverting to what was a known fix for non-Android, and then following up with a special case for Android.
 =||= Closing out again as I believe this is solved in https://github.com/ReactiveX/RxJava/pull/1632

As per comment https://github.com/ReactiveX/RxJava/pull/1632#issuecomment-53595353:

> This passed the Netflix production canary over night. There are no threads spinning on circular references.
> 
> This pull request should work for both Android and Oracle JVMs as it supports both `printStackTrace` and `getCause` mechanisms. The `printStackTrace` approach is better, but the `getCause` one should work normally and then bail if it sees a circular reference.
 =||= There are still issues with stack trace printing on Android with RxJava 0.20.3. For example when `UnknownHostException`  is thrown from `OnSubscribe` implementation nothing is printed to the logcat output. I've tested it on S5 4.4.2, S4 4.4.2, Galaxy Nexus 4.3.

Simple example to reproduce:

```
        Observable.create(new OnSubscribe<Object>() {
            @Override
            public void call(Subscriber<? super Object> subscriber) {
                subscriber.onError(new UnknownHostException());
            }
        }).subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Action1<Object>() {
                    @Override
                    public void call(Object o) {
                        // Does nothing intentionally.
                    }
                }, new Action1<Throwable>() {
                    @Override
                    public void call(Throwable e) {
                        throw new RuntimeException(e);
                    }
                });
```

Logcat output:

```
        AndroidRuntime  D  Shutting down VM
              dalvikvm  W  threadid=1: thread exiting with uncaught exception (group=0x417a7da0)
        AndroidRuntime  E  FATAL EXCEPTION: main
                        E  Process: pl.example.test, PID: 25099
```

Change `UnknownHostException` to `IOException`, now logcat output looks like below:

```
        AndroidRuntime  D  Shutting down VM
              dalvikvm  W  threadid=1: thread exiting with uncaught exception (group=0x417a7da0)
        AndroidRuntime  E  FATAL EXCEPTION: main
                        E  Process: pl.example.test, PID: 9153
                        E  rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError
                        E      at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:175)
                        E      at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)
                        E      at rx.internal.operators.NotificationLite.accept(NotificationLite.java:144)
                        E      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:169)
                        E      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:66)
                        E      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:151)
                        E      at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)
                        E      at android.os.Handler.handleCallback(Handler.java:733)
                        E      at android.os.Handler.dispatchMessage(Handler.java:95)
                        E      at android.os.Looper.loop(Looper.java:136)
                        E      at android.app.ActivityThread.main(ActivityThread.java:5586)
                        E      at java.lang.reflect.Method.invokeNative(Native Method)
                        E      at java.lang.reflect.Method.invoke(Method.java:515)
                        E      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1268)
                        E      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1084)
                        E      at dalvik.system.NativeStart.main(Native Method)
                        E  Caused by: rx.exceptions.CompositeException: 2 exceptions occurred.
                        E      ... 16 more
                        E  Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>
                        E      at android.util.Log.getStackTraceString(Log.java:421)
                        E      at android.util.Slog.e(Slog.java:151)
                        E      at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)
                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)
                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)
                        E      ... 1 more
                        E  Caused by: java.io.IOException
                        E      at pl.example.test.MyActivity$3.call(MyActivity.java:48)IOException
                        E      at pl.example.test.MyActivity$3.call(MyActivity.java:45)
                        E      at rx.Observable.unsafeSubscribe(Observable.java:8587)
                        E      at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
                        E      at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)
                        E      at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)
                        E      at java.util.concurrent.FutureTask.run(FutureTask.java:237)
                        E      at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)
                        E      at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)
                        E      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
                        E      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
                        E      at java.lang.Thread.run(Thread.java:841)
                        E  Caused by: java.lang.RuntimeException: Duplicate found in causal chain so cropping to prevent loop ...
                        E      at android.util.Log.getStackTraceString(Log.java:421)
                        E      at android.util.Slog.e(Slog.java:151)
                        E      at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)
                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)
                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)
                        E      at dalvik.system.NativeStart.main(Native Method)
```

Can anyone confirm this issue with the code I've attached?
 =||= I can't help to test this as I don't do Android development or have an environment to test with.

The current implementation uses `getCause()` to provide the causes, so as long as Android calls `getCause()` then it should work. If however it even bypasses that (as it bypasses `printStackTrace`) and reaches into the internal super field, then it won't work, as we don't wire up the causal chain unless `getCause()` is invoked (instead of construction time as non-Android platforms don't need or want that). If Android is doing that ... then apparently it doesn't obey any APIs.

If Android is completely ignoring even `getCause()` then the only way I can think of fixing this is having two different implementations and an Android specific check that delegates to a different solution. 

/cc @mttkay 
 =||= Maybe there's something wrong with my code. I've put the code above in onResume of a totally empty Activity to nail down where's the issue. If somebody can test this on other devices it would be very helpful. I don't have any non-Samsung devices at the moment.
 =||= I'll put some time aside either tomorrow or Thursday to work through a backlog of Rx specific things. I can try to reproduce then.

I haven't personally seen this issue yet (we're on 0.20.3) but I'll double check the crash logs.
 =||= Just a quick heads up that I can confirm this issue.

Not sure yet _why_ it's happening, but swapping out the exception type does appear to fix it. Which is odd, since `UnknownHostException` _is_ an `IOException`? I also looked at `Exceptions.throwIfFatal` if it had to do with rethrowing exceptions or not, but it does not mention either type.
 =||= `UnknownHostException` is not the only one that is not logged. I'm sure I've found at least 3 different exceptions that do not produce any output to the logcat. I'll post these exceptions here once I figure out which one causing problems. Good to hear that this issue is confirmed and easy to reproduce.
 =||= It's really hard to debug, unfortunately. I was able to pour your example in an automated test and run it on a Genymotion 4.3 instance -- that's the easy part. What I'm not able to do is debug into Android's stack trace methods (parts of it are native code, too, but the problem might exist on the Java layer). This might be an issue with the new project setup, I'm usually able to debug platform classes.

I'll poke around some more.
 =||= Sorry I'm still fighting the tools :-/ I might have to pick this up again another day...
 =||= Moving Android specific discussion to https://github.com/ReactiveX/RxAndroid/issues/21
 =||= ,0
1448,523,Feature Request: Add filterNot to scala language adapter for Observable,Scala has the syntax filter/filterNot as being pretty standard, it would nice to embed the filterNot directly into the language adapter for Observable,@headinthebox has accepted this and while doing so will review other Scala collection methods as well.
 =||= @headinthebox @zsxwing  Do either of you want to do this?
 =||= OK. I will take it.
 =||= ,0
1523,152,Implemented Next Operation,Fixes issue #66,Implemented #58 using next operation.
 =||= @mairbek thank you for submitting these, they look great based on a quick glance. I've been crushed on some production work so have been delayed in reviewing these. I will get to this and your other pull request definitely this week.
 =||= I merged https://github.com/Netflix/RxJava/pull/156 which provides the toIterable functionality.

Closing this one due to the issues discussed above.
 =||= ,0
1537,1348,RxScala: Recursive scheduling ...,Should we add support for recursive scheduling in RxScala? The signature `def schedule(action: => Unit): Subscription` is very elegant for single shot work, but recursive scheduling (https://github.com/Netflix/RxJava/wiki/Scheduler) is less nice.,Moved to https://github.com/ReactiveX/RxScala/issues/33
 =||= ,0
1552,1542,mostRecent returning NotificationLite#ON_NEXT_NULL_SENTINEL,This can return  NotificationLite#ON_NEXT_NULL_SENTINEL or NotificationLite#ON_COMPLETED_SENTINEL.

``` java
Observable<Foo> observable = .... ;
Foo foo = observable.toBlocking().mostRecent(null).iterator().next()
```

which will cause a ClassCastException.... 

This seems inconsistent with the docs and it didn't used to do this ( in 0.17.5 )
https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#mostrecent

Looks like the fix will probably relate to BlockingOperatorMostRecent.MostRecentObserver,Thanks for reporting this. I think I know what caused this.
 =||= @abersnaze Do you have time to take a look at this?
 =||= Sure, I'll take look.
 =||= Fixed in #1552 
 =||= ,0
1557,148,Confusing Javadoc for `toObservable(Future)` methods,The Javadoc for the `Observable.toObservable(Future)` methods are messed up. In particular the sentence: "The subscribe method on this synchronously so the Subscription returned doesn't nothing."

I'd fix it, but I have no idea what it's trying to say :),That makes all kind of sense!

I have no idea how that sentence ever came to be written but it definitely needs to be thrown away and redone :-)

Thanks for bringing this to my attention.
 =||= ,0
1559,1514,Provide a facility for decorating a Runnable before submission to ExecutorService via Scheduler,For Issue #1279

This provides another method of hooking into the Scheduler process.  Rather than forcing the plugin writer to write all 3 Schedulers (computation/io/newThread) from scratch, it allows the plugin writer to have access to the Runnable before it gets submitted to the ExecutorService.

In my implementation which needs to decorate Runnables, this reduced the effort from a copy-n-paste of the entire Scheduler codebase to a 1-liner.

Happy to debate names or any other aspect of this proposal,[RxJava-pull-requests #1435](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/1435/) SUCCESS
This pull request looks good
 =||= Replaced by https://github.com/Netflix/RxJava/pull/1559
 =||= ,0
1562,1488,Backpressure: takeLastTimed,The emission of values after the time has passed can be made to support backpressure.,Done in https://github.com/ReactiveX/RxJava/pull/1562
 =||= ,0
1602,158,Travis CI Configuration,The project would benefit by having Continuous Integration configured.

I've configured travis-ci for my fork, it could be found at https://travis-ci.org/mairbek/RxJava,I definitely agree that a CI build system is beneficial - in fact we (at Netflix) have been working on a solution for all of the NetflixOSS projects and are very close to having it up.

We are going to be using CloudBees (http://www.cloudbees.com/jenkins-enterprise-by-cloudbees-overview.cb) and I've been working with @garethbowles the past few days to get it working. It should be up shortly and allow for builds and unit tests triggered on commits and pull requests.
 =||= Awesome. CloudBees seems to be more powerful than travis ci.
Let's close this one.
 =||= ,0
1609,1603,RxScala: Backpressure,Should add `Producer` and other new APIs related to `Backpressure` in RxScala.,I'll take it.
 =||= When do you expect to have this in? We should probably have this before releasing 0.20 and I'd like to release soon.
 =||= Thanks @zsxwing.
 =||= I think we should have this in before I release 0.20, so can this be done today?
 =||= I don't think it will be done today. I'm working on a PR but it's not a trivial change. I want it gets reviewed and definitely there will be some discussions about it. It may take some days. So can we release this one in 0.20.1?
 =||= Yes it can go in 0.20.1. 

What makes it non-trivial? Shouldn't it just be adding to the wrappers?

I'll move forward with 0.20 to unblock 1.0 and splitting the projects.
 =||= > What makes it non-trivial? Shouldn't it just be adding to the wrappers?

Because the `request` method is protected and the wrapper cannot access it directly.
 =||= Thanks @zsxwing for the quick response on this. It has been merged.
 =||= ,0
1637,163,Implemented Next Operation,New implementation of #66.,[RxJava-pull-requests #2](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/2/) SUCCESS
This pull request looks good
 =||= @mairbek Take a look at the changes I made in https://github.com/Netflix/RxJava/pull/166 to make hasNext() not throw an exception (I also added another unit test while reviewing).

If you're happy with the changes I made I will merge that request which adds on top of your commits. Or if you want to do things differently and update this pull request that works as well (though please copy/paste in my new unit test).
 =||= yeah, I'll close this one.
 =||= ,0
1657,163,Implemented Next Operation,New implementation of #66.,[RxJava-pull-requests #2](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/2/) SUCCESS
This pull request looks good
 =||= @mairbek Take a look at the changes I made in https://github.com/Netflix/RxJava/pull/166 to make hasNext() not throw an exception (I also added another unit test while reviewing).

If you're happy with the changes I made I will merge that request which adds on top of your commits. Or if you want to do things differently and update this pull request that works as well (though please copy/paste in my new unit test).
 =||= yeah, I'll close this one.
 =||= ,0
1695,1688,RefCount unsubscribe never happens for infinite synchronous source,Given `o.publish().refCount()` on an infinite synchronous source `o`, [line 93](https://github.com/ReactiveX/RxJava/blob/0.20.x/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRefCount.java#L93) in `OnSubscribeRefCount` never completes thus `emitting` is never false and disconnect cannot happen.

Here's a unit test failing on 0.20.4:

``` java
package au.gov.amsa.ais.rx;

import static org.junit.Assert.assertTrue;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import org.junit.Test;

import rx.Observable;
import rx.Observable.OnSubscribe;
import rx.Observable.Operator;
import rx.Subscriber;
import rx.observers.Subscribers;
import rx.schedulers.Schedulers;

public class RefCountTest {

    @Test(timeout=3000)
    public void testRefCountUnsubscribeForSynchronousSource() throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(1);
        Observable<Long> o = synchronousInterval().lift(detectUnsubscription(latch));
        Subscriber<Long> sub = Subscribers.empty();
        o.publish().refCount().subscribeOn(Schedulers.computation()).subscribe(sub);
        sub.unsubscribe();
        assertTrue(latch.await(3, TimeUnit.SECONDS));
    }

    private Operator<Long, Long> detectUnsubscription(final CountDownLatch latch) {
        return new Operator<Long,Long>(){
            @Override
            public Subscriber<? super Long> call(Subscriber<? super Long> subscriber) {
                latch.countDown();
                return Subscribers.from(subscriber);
            }};
    }

    private Observable<Long> synchronousInterval() {
        return Observable.create(new OnSubscribe<Long>() {

            @Override
            public void call(Subscriber<? super Long> subscriber) {
                while (!subscriber.isUnsubscribed()) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                    }
                    subscriber.onNext(1L);
                }
            }});
    }
}

```,I think I see what to do to fix. I'll make a PR. If someone is already working on it let me know and I'll stop.
 =||= Pull request is merged.
 =||= ,0
1705,1642,OnSubscribeCombineLatest not unwrapping ON_NEXT_NULL_SENTINEL,I am using a combineLatest method which when outputting a null value the combiner Func causes a ON_NEXT_NULL_SENTINEL to be passed into the subscription's onNext, which is causing a class cast exception.

``` java
        registrationObservable = Observable.combineLatest(registrationObservable, connectionStateObservable,
                new Func2<Registration, Boolean, Registration>() {
                    @Override
                    public Registration call(Registration registration, Boolean connected) { 
                        if (connected) {
                            return registration;
                        }
                        return null; //Passing null here
                    }
                })
                .filter(Functions.notNull);
```

`notNull` is defined as:

``` java
    public static final Func1<? super Object,Boolean> notNull = new Func1<Object, Boolean>() {
        @Override
        public Boolean call(Object o) {
            return o != null;
        }
    };
```

if that is relevant.

I have determined that it is due to the RxRingBuffer used by OnSubscribeCombineLatest's onNext method:

``` java
public void onNext(Object o) throws MissingBackpressureException {
        if (queue == null) {
            throw new IllegalStateException("This instance has been unsubscribed and the queue is no longer usable.");
        }
        if (!queue.offer(on.next(o))) { //IF o is null here, this will add the ON_NEXT_NULL_SENTINEL to the queue
            throw new MissingBackpressureException();
        }
    }
```

but `tick` does not "unwrap" the NotificationLite when passing it along

``` java
                        Object o = buffer.poll();
                        if (o != null) {
                            if (buffer.isCompleted(o)) {
                                child.onCompleted();
                            } else {
                                child.onNext((R) o); //Passing NotificationLite sentinel in here... should this unwrap it?
                                emitted++;
                                requested.decrementAndGet();
                            }
                        }
```

It seems like either `buffer.poll()` should return the unwrapped null, or tick should be checking for the null sentinel and passing null instead of that into onNext (after checking `o != null`).

EG,

``` java
                        Object o = buffer.poll();
                        if (o != null) {
                            if (buffer.isCompleted(o)) {
                                child.onCompleted();
                            } else {
                                if(o == ON_NEXT_NULL_SENTINEL) {
                                      o = null;
                                }
                                child.onNext((R) o); //Passing NotificationLite sentinel in here... should this unwrap it?
                                emitted++;
                                requested.decrementAndGet();
                            }
                        }
```

I don't understand why casting the ON_NEXT_NULL_SENTINEL to an R is not causing the ClassCastException (it happens later on in the Subscriber's onNext call). ,I have also encountered this issue with RxJava 0.20.4. Here is a minimal test method that exhibits the issue:

``` java
@Test
public void combineLatestNullCombinerFailureTest() {

    // Create source subjects. Types don't matter, Integer arbitrarily chosen.
    PublishSubject<Integer> subject0 = PublishSubject.create();
    PublishSubject<Integer> subject1 = PublishSubject.create();

    // Create a function that ignores inputs and always returns a null Integer
    Func2<Integer, Integer, Integer> nullIntegerReturningCombiner = new Func2<Integer, Integer, Integer>() {
        @Override
        public Integer call(Integer i0, Integer i1) {
            return null;
        }
    };

    // Create the combine-latest observable
    Observable<Integer> combineLatestObservable = Observable.combineLatest(
            subject0, subject1, nullIntegerReturningCombiner);

    // Create an observer that simply asserts that any emission is null on any emission
    Observer<Integer> combineLatestObserver = Observers.create(new Action1<Integer>() {
        @Override
        public void call(Integer shouldBeNull) {
            Assert.assertNull(shouldBeNull);
        }
    });

    // Subscribe the observer to the combine-latest observable
    combineLatestObservable.subscribe(combineLatestObserver);

    // Produce a single emission from each subject. Emission values don't matter, arbitrarily chosen.
    subject0.onNext(0);
    subject1.onNext(1);

    // The second emission above results in a ClassCastException, with the following (abbreviated) stack trace,
    // as of RxJava 0.20.4:
    //
    // rx.exceptions.OnErrorNotImplementedException: rx.internal.operators.NotificationLite$2 cannot be cast to java.lang.Integer
    //     at rx.Observable$36.onError(Observable.java:8416)
    //     at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:128)
    //     at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)
    //     ...
    // Caused by: java.lang.ClassCastException: rx.internal.operators.NotificationLite$2 cannot be cast to java.lang.Integer
    //     at RxJavaCombineLatestTest$2.call(RxJavaCombineLatestTest.java:28)
    //     at rx.Observable$36.onNext(Observable.java:8421)
    //     at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:105)
    //     ...
}
```

I agree with @DylanSale that there may be a problem in the OnSubscribeCombineLatest tick() operation, but my proposed fix is slightly different.

NotificationLite.ON_NEXT_NULL_SENTINEL is private and should not be publicly exposed. However, NotificationLite includes a getValue(Object n) operation which does the check for the ON_NEXT_NULL_SENTINEL instance and returns properly typed null if it is encountered.

My suggestion is to replace:

``` java
child.onNext((R) o)
```

with:

``` java
child.onNext(NotificationLite.<R> instance().getValue(o))
```

in the tick() operation.
 =||= I have a proposed workaround while we await review of this issue. Change the return type of the combiner Func2 to Object to avoid the ClassCastException, and introduce a mapping function that uses the NotificationLite getValue() method to handle the null sentinel value if encountered.

In my test case above, the changed blocks would be:

``` java
...
Func2<Integer, Integer, Object> nullIntegerReturningCombiner = new Func2<Integer, Integer, Object>() {
    @Override
    public Object call(Integer i0, Integer i1) {
        return null;
    }
};
...
combineLatestObservable
    .map(new Func1<Object, Integer>() {
        @Override
        public Integer call(Object o) {
            return NotificationLite.<Integer> instance().getValue(o);
        }
    })
    .subscribe(combineLatestObserver);
...
```

I have created a generic function to encapsulate the mapping part of this workaround, as follows:

``` java
public static <T> Func1<Object, T> combineLatestWorkaround() {
    return new Func1<Object, T>() {
        @Override
        public T call(Object o) {
            return NotificationLite.<T> instance().getValue(o);
        }
    };
}
```

Wherever I have a combineLatest observable with a combiner function that may (validly) emit null values, I have applied this workaround for the time being.
 =||= I put together a PR that fixes this issue with @gfee's suggested fix and adds a test to confirm the breakage/fix: 
https://github.com/ReactiveX/RxJava/pull/1705
 =||= Thank you!
On 30 Sep 2014 03:31, "edenman" notifications@github.com wrote:

> I put together a PR that fixes this issue with @gfee
> https://github.com/gfee's suggested fix and adds a test to confirm the
> breakage/fix:
> #1705 https://github.com/ReactiveX/RxJava/pull/1705
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1642#issuecomment-57202005.
 =||= My thanks @edenman for taking the time to create a pull request. Here's hoping it makes it into the RxJava 1.0.0 release.
 =||= @benjchristensen thanks for merging the PR! can probably close this issue now.
 =||= ,0
1742,1741,Observer.empty() vs EmptyObserver,The behavior between Observer.empty() and `EmptyObserver` is different. This seems confusing.

`EmptyObserver` swallows errors whereas `Observer.empty()` will throw `OnErrorNotImplementedException` if `onError` is invoked.

Thoughts on what we should do?,I think deleting `EmptyObserver` is the best approach. It serves no value.
 =||= I deleted `EmptyObserver` and updated the `Observers.empty()` javadocs to be clear that it throws `OnErrorNotImplementedException`. 

If someone wants to swallow errors they need to actively code for that. RxJava will not swallow errors itself.
 =||= Like!
 =||= ,0
1742,1571,TestObserver always delegates to EMPTY, throws exception,I noticed that TestObserver was changed to always delegate calls, by default to the `EMPTY` Observer.

However, the EMPTY Observer does not define `onError`, so any attempt to use TestObserver with an observable that's supposed to fail in a unit test crashes the test with a `OnErrorNotImplementedException`

I wonder why this change was done? It adds complexity and surprise to something that should be void of behavior (mocks should record things, not perform logic IMHO),I had a problem with this to when using the `TestObserver` to test errors.
I'm using mockito so I worked this around creating my TestObservers like this:

```
    @SuppressWarnings("unchecked")
    public static <T> TestObserver<T> createTestObserver()
    {
        Observer<T> delegate = mock(Observer.class);
        return new TestObserver<T>(delegate);
    }
```
 =||= Opening discussion about confusion between `EmptyObserver` and `Observers.empty()`: https://github.com/ReactiveX/RxJava/issues/1741
 =||= It will no longer throw an exception when a delegate is not provided. That was a mistake.
 =||= :+1: 
 =||= ,0
1750,1676,NPE in OnSubscribeFromIterable,A report from RxJava 0.19.x:

```
Caused by: java.lang.NullPointerException
        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:39)
        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:29)
        at rx.Observable$2.call(Observable.java:159)
```,In 0.19 an NPE could happen if the Iterable was null: https://github.com/ReactiveX/RxJava/blob/0.19.x/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java#L39

This is fixed in 1.0: https://github.com/ReactiveX/RxJava/blob/v1.0.0-rc.5/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java#L43
 =||= I feel a null `Iterable` is usually a programming error.I think throwing an NullPointerException in the constructor of `OnSubscribeFromIterable` is better. RxJava should not hide such error, so that people can find their mistake quickly.
 =||= ,0
1761,1642,OnSubscribeCombineLatest not unwrapping ON_NEXT_NULL_SENTINEL,I am using a combineLatest method which when outputting a null value the combiner Func causes a ON_NEXT_NULL_SENTINEL to be passed into the subscription's onNext, which is causing a class cast exception.

``` java
        registrationObservable = Observable.combineLatest(registrationObservable, connectionStateObservable,
                new Func2<Registration, Boolean, Registration>() {
                    @Override
                    public Registration call(Registration registration, Boolean connected) { 
                        if (connected) {
                            return registration;
                        }
                        return null; //Passing null here
                    }
                })
                .filter(Functions.notNull);
```

`notNull` is defined as:

``` java
    public static final Func1<? super Object,Boolean> notNull = new Func1<Object, Boolean>() {
        @Override
        public Boolean call(Object o) {
            return o != null;
        }
    };
```

if that is relevant.

I have determined that it is due to the RxRingBuffer used by OnSubscribeCombineLatest's onNext method:

``` java
public void onNext(Object o) throws MissingBackpressureException {
        if (queue == null) {
            throw new IllegalStateException("This instance has been unsubscribed and the queue is no longer usable.");
        }
        if (!queue.offer(on.next(o))) { //IF o is null here, this will add the ON_NEXT_NULL_SENTINEL to the queue
            throw new MissingBackpressureException();
        }
    }
```

but `tick` does not "unwrap" the NotificationLite when passing it along

``` java
                        Object o = buffer.poll();
                        if (o != null) {
                            if (buffer.isCompleted(o)) {
                                child.onCompleted();
                            } else {
                                child.onNext((R) o); //Passing NotificationLite sentinel in here... should this unwrap it?
                                emitted++;
                                requested.decrementAndGet();
                            }
                        }
```

It seems like either `buffer.poll()` should return the unwrapped null, or tick should be checking for the null sentinel and passing null instead of that into onNext (after checking `o != null`).

EG,

``` java
                        Object o = buffer.poll();
                        if (o != null) {
                            if (buffer.isCompleted(o)) {
                                child.onCompleted();
                            } else {
                                if(o == ON_NEXT_NULL_SENTINEL) {
                                      o = null;
                                }
                                child.onNext((R) o); //Passing NotificationLite sentinel in here... should this unwrap it?
                                emitted++;
                                requested.decrementAndGet();
                            }
                        }
```

I don't understand why casting the ON_NEXT_NULL_SENTINEL to an R is not causing the ClassCastException (it happens later on in the Subscriber's onNext call). ,I have also encountered this issue with RxJava 0.20.4. Here is a minimal test method that exhibits the issue:

``` java
@Test
public void combineLatestNullCombinerFailureTest() {

    // Create source subjects. Types don't matter, Integer arbitrarily chosen.
    PublishSubject<Integer> subject0 = PublishSubject.create();
    PublishSubject<Integer> subject1 = PublishSubject.create();

    // Create a function that ignores inputs and always returns a null Integer
    Func2<Integer, Integer, Integer> nullIntegerReturningCombiner = new Func2<Integer, Integer, Integer>() {
        @Override
        public Integer call(Integer i0, Integer i1) {
            return null;
        }
    };

    // Create the combine-latest observable
    Observable<Integer> combineLatestObservable = Observable.combineLatest(
            subject0, subject1, nullIntegerReturningCombiner);

    // Create an observer that simply asserts that any emission is null on any emission
    Observer<Integer> combineLatestObserver = Observers.create(new Action1<Integer>() {
        @Override
        public void call(Integer shouldBeNull) {
            Assert.assertNull(shouldBeNull);
        }
    });

    // Subscribe the observer to the combine-latest observable
    combineLatestObservable.subscribe(combineLatestObserver);

    // Produce a single emission from each subject. Emission values don't matter, arbitrarily chosen.
    subject0.onNext(0);
    subject1.onNext(1);

    // The second emission above results in a ClassCastException, with the following (abbreviated) stack trace,
    // as of RxJava 0.20.4:
    //
    // rx.exceptions.OnErrorNotImplementedException: rx.internal.operators.NotificationLite$2 cannot be cast to java.lang.Integer
    //     at rx.Observable$36.onError(Observable.java:8416)
    //     at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:128)
    //     at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)
    //     ...
    // Caused by: java.lang.ClassCastException: rx.internal.operators.NotificationLite$2 cannot be cast to java.lang.Integer
    //     at RxJavaCombineLatestTest$2.call(RxJavaCombineLatestTest.java:28)
    //     at rx.Observable$36.onNext(Observable.java:8421)
    //     at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:105)
    //     ...
}
```

I agree with @DylanSale that there may be a problem in the OnSubscribeCombineLatest tick() operation, but my proposed fix is slightly different.

NotificationLite.ON_NEXT_NULL_SENTINEL is private and should not be publicly exposed. However, NotificationLite includes a getValue(Object n) operation which does the check for the ON_NEXT_NULL_SENTINEL instance and returns properly typed null if it is encountered.

My suggestion is to replace:

``` java
child.onNext((R) o)
```

with:

``` java
child.onNext(NotificationLite.<R> instance().getValue(o))
```

in the tick() operation.
 =||= I have a proposed workaround while we await review of this issue. Change the return type of the combiner Func2 to Object to avoid the ClassCastException, and introduce a mapping function that uses the NotificationLite getValue() method to handle the null sentinel value if encountered.

In my test case above, the changed blocks would be:

``` java
...
Func2<Integer, Integer, Object> nullIntegerReturningCombiner = new Func2<Integer, Integer, Object>() {
    @Override
    public Object call(Integer i0, Integer i1) {
        return null;
    }
};
...
combineLatestObservable
    .map(new Func1<Object, Integer>() {
        @Override
        public Integer call(Object o) {
            return NotificationLite.<Integer> instance().getValue(o);
        }
    })
    .subscribe(combineLatestObserver);
...
```

I have created a generic function to encapsulate the mapping part of this workaround, as follows:

``` java
public static <T> Func1<Object, T> combineLatestWorkaround() {
    return new Func1<Object, T>() {
        @Override
        public T call(Object o) {
            return NotificationLite.<T> instance().getValue(o);
        }
    };
}
```

Wherever I have a combineLatest observable with a combiner function that may (validly) emit null values, I have applied this workaround for the time being.
 =||= I put together a PR that fixes this issue with @gfee's suggested fix and adds a test to confirm the breakage/fix: 
https://github.com/ReactiveX/RxJava/pull/1705
 =||= Thank you!
On 30 Sep 2014 03:31, "edenman" notifications@github.com wrote:

> I put together a PR that fixes this issue with @gfee
> https://github.com/gfee's suggested fix and adds a test to confirm the
> breakage/fix:
> #1705 https://github.com/ReactiveX/RxJava/pull/1705
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1642#issuecomment-57202005.
 =||= My thanks @edenman for taking the time to create a pull request. Here's hoping it makes it into the RxJava 1.0.0 release.
 =||= @benjchristensen thanks for merging the PR! can probably close this issue now.
 =||= ,0
1767,1682,ScheduledAction Swallows Errors,ScheduledAction (used by `observeOn` and other things doing scheduling) swallows errors because `FutureTask.run()` swallows errors inside a `Future`.

This means something like `OnErrorNotImplemented` on the `Subscriber` side of an `observeOn` will throw and be swallowed and everything will fail silently.

The following code fails silently:

``` java
Observable.error(new RuntimeException()).observeOn(Schedulers.computation()).subscribe();
```,I've been researching this and there isn't a whole lot of choice in what to do when an Exception is thrown on a random `Scheduler.Worker` thread beyond catching and printing the error using `System.err`.

I can't throw the exception anywhere else as the whole issue here is an unhandled exception being thrown.

Thus, I'm going to catch the exceptions in `ScheduledAction` and `e.printStackTrace()` them with a warning about exceptions being thrown.

This is an edge case that an app should not allow ... and the reason why Observables propagate errors as events ... to avoid this very case, so seeing these types of messages in log output signals a "bad thing" that should be resolved. 

This would NOT be good for system performance to allow these types of errors to be logged, but I feel this is far better to yell and scream about bad code rather than silently swallowing errors as it does now.
 =||= An error such as this will be printed:

```
java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:46)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Caused by: rx.exceptions.OnErrorNotImplementedException
    at rx.Observable$36.onError(Observable.java:7387)
    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:128)
    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:144)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:177)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$0(OperatorObserveOn.java:161)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:153)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)
    ... 7 more
Caused by: java.lang.RuntimeException
    at rx.exceptions.ErrorsOverAsyncBoundaries.testSubscriberOnErrorFails(ErrorsOverAsyncBoundaries.java:43)
```
 =||= I have merged the change. If anyone can suggest a better approach that would be great, please let me know here.
 =||= Best of the worst.
 =||= The added logging is nice, but why not continue throwing the error if it's fatal (like `OnErrorNotImplemented`)? Minus `observeOn` your program would crash because you aren't handling the exception - it wouldn't just log the exception.
 =||= @dlew how would you solve this differently? The error is occurring on a separate thread, so the most violent death that can occur is killing that thread inside the ThreadPoolExecutor. The error can not propagate to the `main` thread and thus does not kill the JVM.

The `Throwable` gets caught inside `java.util.concurrent.FutureTask`:

``` java
    public void run() {
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex); //  <------------- THIS IS WHERE THE EXCEPTION GOES
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }
```

One can use `ThreadPoolExecutor.afterExecute` to extract the caught error, but rethrowing only causes the `ThreadPoolExecutor` to kill the thread, not the JVM since it can't propagate to the `main` thread (the nature of async): http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable,%20java.lang.Throwable)

The only alternative I can think of is to reverse schedule events up the Observable chain, like having an `onError` on the `Observable.OnSubscribe` and having a `Scheduler` on the producing side, not just the consuming side. That however is a crazy amount of overhead and infrastructure for a degenerate case. 

If you can submit a pull request that offers a better solution I'd appreciate that.
 =||= Thanks, I understand the problem a lot better now. I'll have to think on it; not sure there is a good solution.
 =||= I know this isn't possible for even 1.0 but could `Subscription schedule(Action0 action)` be changed to
`Observable<Void> schedule(Action0 action)`. That way the caller can get both the ability to subscribe to get the subscription and notification of completion or failure.
 =||= A calling thread could not get a reference, as `void onNext` is the signature the caller invokes. It is on the wrong side of the thread where the exception is caught, scheduled from inside the `onNext`. The calling (parent) thread has already left by the time the child thread throws the exception. 

There is no issue catching the exception on the child thread, it's what to do with it that is the question. 
 =||= There is a related discussion here: https://github.com/ReactiveX/RxJava/issues/969

I haven't checked in a while, but IIRC part of the issue was that some operators like ObserveOn weren't forwarding errors?
 =||= ObserveOn propagates errors downstream. We just can't send them upstream across thread boundaries. 
 =||= It would be great if we could add another plugin that gets called in place of the `printStackTrace`.  Similar to `RxJavaErrorHandler`, but only for otherwise unhandled errors.
 =||= Would you prefer that over this:

> Thread.getDefaultUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);

I've never that so have no idea how it behaves especially with thread pools. 
 =||= No, you're right, we can just use the built-in handler mechanism directly.

We go directly `Thread.getDefaultUncaughtExceptionHandler()` today, but that's probably wrong.  That handler is the global last-resort handler for all threads.  It looks like what we really want is `Thread.currentThread().getUncaughtExceptionHandler()`.

I'll get a PR together.
 =||= That sounds good, since then we are free to add listeners at any of the 3 levels, but just registering the default global listener (most likely) will still work and it will propagate to it.

http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html

> When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler's uncaughtException method, passing the thread and the exception as arguments. If a thread has not had its UncaughtExceptionHandler explicitly set, then its ThreadGroup object acts as its UncaughtExceptionHandler. If the ThreadGroup object has no special requirements for dealing with the exception, it can forward the invocation to the default uncaught exception handler.

Thanks for bringing this to my attention @loganj I honestly wasn't even aware of this capability in the JVM and my use cases don't generally result in uncaught exceptions so I hadn't ever gone looking for it.
 =||= No problem, we're really good at making exceptions happen.

I'm basically done, but not sure if I should I apply the same handling to Schedulers that don't use ScheduledAction.  ExecutorScheduler _seems_ to need it.  What about ImmediateScheduler and TrampolineScheduler?  Do people rely on their current throwing behavior?  Is that behavior contractual?
 =||= I have not tried this issue on TrampolineScheduler but that may be okay as it's all on the same thread. ExecutorScheduler probably does need this, but let's get it solved for `ScheduledAction` first and then we can go fix that one in a separate PR.
 =||= I have confirmed this fix is working nicely after the changes by @loganj in #1766 
 =||= ,0
1777,1502,Javadocs: Disable or Make Work,The generation of Javadocs from the Gradle config is mostly broken and unusable.
- formatting is default/bad
- it doesn't exclude internal packages
- it breaks on different versions of the JVM

Right now I generate the hosted docs (http://netflix.github.io/RxJava/javadoc/rx/Observable.html) using a bash script on my local machine.

I want this automated ... but correctly to at least match what is hosted at http://netflix.github.io/RxJava/javadoc/ and so it works regardless of Java 7 or 8 being used.,+1 I'll buy a beer for the person who fixes this.
 =||= @abersnaze Want to help with this?
 =||= @abersnaze, we have a bounty on this one.
 =||= > - formatting is default/bad
> - it breaks on different versions of the JVM

The example link was broken so I wasn't sure what you wanted it to look like.
I tried in java home set to 1.8 but didn't see an issue.
 =||= This is kind of outdated. I have only a brief look at the javadocs from a browser but didn't notice anything broken (just missing package descriptions). Is there still a problem with this?
 =||= I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.
 =||= ,0
1784,1732,Backpressure: Publish,Is it possible in limited cases to support reactive pull backpressure on multicast use cases such as `.publish()`?

In the general case of a `ConnectableObservable` it wouldn't be, as those are "hot". I'm interested in exploring if there are cases when it will work, such as when using `refCount` to address use cases such as discussed in https://github.com/ReactiveX/RxJava/issues/1649#issuecomment-58058704

As per the example from @headinthebox 

``` scala
import rx.lang.scala._

object MainScala {
  def main(args: Array[String]): Unit = {
  val xs = Observable.items(0, 1, 2, 3, 4)
  val zs = xs.publish[Int]((xs: Observable[Int]) => xs.takeUntil(xs.dropWhile(x => x < 3).tail))
  zs.subscribe(z => println(z)) // 0,1,2,3
  readLine()
}
```,+1

I have especially good hopes for `xs.publish(_xs->ys).zs` since the sharing of `xs` is all encapsulated.
 =||= I don't think this should try to generically solve for use of Subjects, but for use of the `multicast` operator. 

In that case I propose we adopt a similar strategy as `groupBy` employs which is that the flow goes at the rate of the slowest subscriber. It is the most obvious and expected result and if someone needs to speed things up then users opt in to sampling/throttling/etc whereas right now it very non-obviously breaks composition of backpressure and will cause backpressure exceptions and require buffering or dropping data.
 =||= The main difficulty I see is how to manage the dynamic combining of request(n) calls of client subscribers as they may come and go at will. 

For example, given a multicast source, a subscriber S1 enters and calls request(10), soon after a different subscriber S2 enters and calls request(5). Since the first request started to execute, the S2 shouldn't receive more than 5 and the multicast somehow needs to buffer the remaining 5 until the subscriber S2 asks for more or S1 doesn't receive more elements until S2 asks for more. In addition, if S2 unsubscribes, S1 may now receive its remaining requested elements.
 =||= I agree that it's a challenge. I wonder though if we can solve this in a similar way as `groupBy` works, as it's a similar challenge. `groupBy` is effectively multicasting a single source into `n` sources where each can come and go and request different sizes at different rates. 

It maintains a single buffer where it puts notifications if it can't emit and ensures it never requests more upstream than its buffer. 

The nuance of this is that `publish` will have some `replay` type behavior when it has slow consumers, but I think that's correct considering the expected behavior of composing reactive pull backpressure. If someone wants truly unbounded emission they can opt into that by using terminal operators or `onBackpressure*` strategies. 

This approach has worked well for `groupBy` this past week in our stream processing system we're doing. The `publish`/`share` use case is I believe the last blocker we have.
 =||= After reviewing this with @neerajrj it seems to not make sense and try and make `multicast` support backpressure as it allows passing any `Subject` into it. A `Subject` is by definition "hot" and not appropriate for trying to compose backpressure. 

The `publish` (and `cache`/`share`) operator however has no specific reliance on the use of a `Subject` even though it currently leverages `multicast` and the `Subject` implementations (`PublishSubject` and `ReplaySubject`).

We can achieve the multicast behavior of `publish()` without a `PublishSubject` and then be able to compose the backpressure from all subscribers very similar to how `groupBy` works without needing to modify how subjects work.
 =||= Implemented and merged in #1784 
 =||= Is there a non-trivial or non-contrived use case for this code to help me understand its applicability? I'm having a hard time conceptualizing what it would be used for when the example can be rewritten as `.takeWhile(Predicates.not(x => x > 3))` (or, of course, simply `.takeWhile(x => x <= 3)`).
 =||= ,0
1792,1791,Observable#first causes retryWhen to trigger retry without an exception,Noticed this behavior using rx-netty as internally it does a take(1) internally:

```
    AtomicLong inc = new AtomicLong(0);
    Observable.OnSubscribe<Long> onSubscribe = subscriber -> {
        final long emit = inc.getAndIncrement();
        LOGGER.info("Emitting: {}", emit);
        subscriber.onNext(emit);
        subscriber.onCompleted();
    };

    LOGGER.info("DONE: {}", Observable.create(onSubscribe)
                    .retryWhen(attempt -> attempt.zipWith(Observable.range(1, 4), (n, i) -> i))
                    .toBlocking()
                    .first()
    );
```

The test output is:
    Emitting: 0
    Emitting: 1
    DONE: 0

As you can see the observable is subscribed to twice. This is because take, in combination with single, causes the retryWhen producer to request another item.,Manually merged in https://github.com/ReactiveX/RxJava/pull/1793

Thank you @alexwen for submitting a bug report and then this fix!
 =||= ,0
1793,1791,Observable#first causes retryWhen to trigger retry without an exception,Noticed this behavior using rx-netty as internally it does a take(1) internally:

```
    AtomicLong inc = new AtomicLong(0);
    Observable.OnSubscribe<Long> onSubscribe = subscriber -> {
        final long emit = inc.getAndIncrement();
        LOGGER.info("Emitting: {}", emit);
        subscriber.onNext(emit);
        subscriber.onCompleted();
    };

    LOGGER.info("DONE: {}", Observable.create(onSubscribe)
                    .retryWhen(attempt -> attempt.zipWith(Observable.range(1, 4), (n, i) -> i))
                    .toBlocking()
                    .first()
    );
```

The test output is:
    Emitting: 0
    Emitting: 1
    DONE: 0

As you can see the observable is subscribed to twice. This is because take, in combination with single, causes the retryWhen producer to request another item.,Manually merged in https://github.com/ReactiveX/RxJava/pull/1793

Thank you @alexwen for submitting a bug report and then this fix!
 =||= ,0
1802,1772,Add hasObservers to Subject,Other implementations of Rx have a hasObservers method on Subject. It would be nice to have this in RxJava.

RxJS:
https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/subject.md#rxsubjectprototypehasobservers

Rx.NET
https://rx.codeplex.com/SourceControl/latest#Rx.NET/Source/System.Reactive.Linq/Reactive/Subjects/Subject.cs,I'm open to that. Want to submit a pull request?
 =||= went ahead and implemented the method (see pull request)
 =||= Merged.
 =||= ,0
1813,1812,Multiple Zipped Observers never complete,The following code never executes the onComplete if the number is greater than 1025. I think it has to due with back pressure which uses a default request of 1024. I am using Java 8 

```
    Observable merged1 = Observable.zip(Observable.range(0, 1026), Observable.range(0, 1026),
            (o, e) -> new int[]{o, e});
    Observable merged2 = Observable.<int[], Integer, int[]>zip(merged1, Observable.range(0, 1026),
            (o, e) -> new int[]{o[0], o[1], e}).serialize();
    merged2.subscribe(
            (o) -> System.out.println(o),
            e -> {},
            () -> {
                System.out.println("This never prints");
            }
    );
```

I am using the following version of Java.

java version "1.8.0_05"
Java(TM) SE Runtime Environment (build 1.8.0_05-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode),Thanks for reporting it.
 =||= ,0
1827,1826,Race with CachedThreadScheduler Eviction,Although I have not been able to find a way to reproduce the issue reliably, I have seen the following stack several times now:

```
 ! java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@328cda0 rejected from java.util.concurrent.ScheduledThreadPoolExecutor@2200705d[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 3]
 ! at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) ~[na:1.8.0_20]
 ! at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) [na:1.8.0_20]
 ! at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:326) ~[na:1.8.0_20]
 ! at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:533) ~[na:1.8.0_20]
 ! at java.util.concurrent.ScheduledThreadPoolExecutor.submit(ScheduledThreadPoolExecutor.java:632) ~[na:1.8.0_20]
 ! at rx.internal.schedulers.NewThreadWorker.scheduleActual(NewThreadWorker.java:66) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]
 ! at rx.schedulers.CachedThreadScheduler$EventLoopWorker.schedule(CachedThreadScheduler.java:149) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]
 ! at rx.schedulers.CachedThreadScheduler$EventLoopWorker.schedule(CachedThreadScheduler.java:139) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]
```

While auditing the CachedThreadScheduler, I noticed a potential race condition when evicting workers from the eviction queue, from CachedThreadScheduler:

```
        void evictExpiredWorkers() {
            if (!expiringWorkerQueue.isEmpty()) {
                long currentTimestamp = now();

                Iterator<ThreadWorker> threadWorkerIterator = expiringWorkerQueue.iterator();
                while (threadWorkerIterator.hasNext()) {
                    ThreadWorker threadWorker = threadWorkerIterator.next();
                    if (threadWorker.getExpirationTime() <= currentTimestamp) {
                        threadWorkerIterator.remove();
                        threadWorker.unsubscribe();
                    } else {
                        // Queue is ordered with the worker that will expire first in the beginning, so when we
                        // find a non-expired worker we can stop evicting.
                        break;
                    }
                }
            }
        }
```

The evictor, uses an `iterator#remove` in order to remove the work from the queue, but it does not check that this operation actually occurred. The iterator, though thread safe, is not atomic for .next and .remove, so, the worker could be pulled from the cache by another thread between the .next and the .remove.

If this occurs then the the NewThreadWorker will be unsubscribed, its executor shutdown, and the next action that executes on that worker would cause the exception above.

In order to fix this race I believe the evictor would need to check that it removed the worker from the queue, before attempting to unsubscribe the worker.,Thanks for the report.
 =||= ,0
1832,1804,"Interrupted while waiting for subscription to complete." in 1.0.0-rc8,Doesn't happen on rc7.  I can repro 100% of the time.  Happens on both KitKat and Lollipop so I don't think it's specific to any particular Android version.

```
FATAL EXCEPTION: RxCachedThreadScheduler-4
Process: com.mycompany.myapp.development, PID: 4413
java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.
        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:50)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)
        at java.util.concurrent.FutureTask.run(FutureTask.java:237)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
        at java.lang.Thread.run(Thread.java:818)
Caused by: rx.exceptions.OnErrorNotImplementedException: Interrupted while waiting for subscription to complete. 
        at rx.Observable$30.onError(Observable.java:7252)
        at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:127)
        at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:96)
        at rx.internal.operators.OperatorMap$1.onError(OperatorMap.java:48)
        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)
        at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)
        at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitNext(SubjectSubscriptionManager.java:254)
        at rx.subjects.BehaviorSubject.onNext(BehaviorSubject.java:166)
        at rx.Observable$34.onNext(Observable.java:7437)
        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:104)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:610)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:536)
        at rx.internal.operators.OperatorSingle$1.onCompleted(OperatorSingle.java:75)
        at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:72)
        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)
        at com.mycompany.servercall.ServerCall$1$1.call(ServerCall.java:56)
        at com.mycompany.servercall.ServerCall$1$1.call(ServerCall.java:47)
        at rx.Observable.unsafeSubscribe(Observable.java:7464)
        at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)
        ... 7 more 
Caused by: java.lang.RuntimeException: Interrupted while waiting for subscription to complete. 
        at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:474)
        at rx.observables.BlockingObservable.single(BlockingObservable.java:348)
        at com.mycompany.myapp.data.CachedThing.buildCachedThing(CachedThing.java:66)
        at com.mycompany.myapp.data.CachedThing.<init>(CachedThing.java:28)
        at com.mycompany.myapp.data.FilterFunc.call(FilterFunc.java:189)
        at com.mycompany.myapp.data.FilterFunc.call(FilterFunc.java:175)
        at com.mycompany.myapp.data.CachedThing.merge(CachedThing.java:60)
        at com.mycompany.myapp.data.ResponseCache.update(ResponseCache.java:80)
        at com.mycompany.myapp.data.TransformFunc.call(TransformFunc.java:105)
        at com.mycompany.myapp.data.TransformFunc.call(TransformFunc.java:99)
        at com.mycompany.servercall.CallState$3.map(CallState.java:79)
        at com.mycompany.servercall.CallState$9.call(CallState.java:195)
        at com.mycompany.servercall.CallState$9.call(CallState.java:193)
        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)
        ... 22 more
Caused by: java.lang.InterruptedException
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1279)
        at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:202)
        at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:471)
        ... 35 more
Caused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: .class 
        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)
        ... 22 more
```

`CachedThing.buildCachedThing` has this block of code that I think is the culprit:

```
List<SubThing> subThings = Observable.from(things) //
        .map(transformFunction) //
        .filter(not(isNullFunction)) //
        .distinct() //
        .toList() //
        .toBlocking() //
        .single();
```

I tried writing a testcase to repro but couldn't get it to fail.  I'm guessing there's something broken between the android runtime and rxjava's thread management, but I couldn't get any further than that.,The only thing in rc8 that seems related is this: https://github.com/ReactiveX/RxJava/pull/1793
 =||= I can not replicate with this code:

``` java
import java.util.List;

import rx.functions.Func1;

public class Testing {

    public static void main(String... args) {
        List<String> subThings = Observable.range(0, 1000)
                .map(new Func1<Integer, String>() {

                    @Override
                    public String call(Integer i) {
                        return String.valueOf(i + 1);
                    }

                })
                .filter(new Func1<String, Boolean>() {

                    @Override
                    public Boolean call(String t) {
                        return t != null;
                    }

                }) //
                .distinct() //
                .toList() //
                .toBlocking() //
                .single();

        System.out.println(subThings);
    }
}
```
 =||= The code that is being interrupted is this: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/observables/BlockingObservable.java#L473

``` java
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);
        }
```

This means the thread was blocked on the latch waiting for a result but while it was waiting it got interrupted. 

I don't know what thread you are doing this on, nor do I know much about Android. If Android is using pools of threads it could perhaps retain the right to interrupt and reclaim threads? I know event loops in some frameworks do that kind of thing if something is blocked in them and new work is scheduled. 

RxJava itself does not interrupt threads anywhere (that I'm aware of ... and I can't think of any reason we would) so I'm inclined to suggest looking at what thread you are blocking in and see if Android itself could be interrupting it?

Also, could you move to a model where you don't block and instead compose it all together reactively?
 =||= Moving to 1.0.x as it's not obvious yet what is going on here.
 =||= Encountered this on Jellybean. Code in my Application subclass:

``` java
Observable<SomeSharedPreferencesWrapper> prefsPrefetch = Async.start(this::prefetchPrefs);
```

And later in same class:

``` java
return prefsPrefetch.toBlocking().single();
```

I can't grasp exact circumstances, when issue reproduces itself. At first glance they seem to be random, but happens often enough to make prefetching stuff with RxJava pretty much impossible.
 =||= I'm gonna work on putting together a minimal test Android app to try and isolate the issue.
 =||= https://dl.dropboxusercontent.com/u/7829307/RxJavaBlockingBug.zip

I wasn't able to repro until I added the PublishSubject layer...maybe the issue is the nested toBlocking() calls?
 =||= Does Android ever interrupt a thread based on user or system activity? If so then the `toBlocking()` will always be vulnerable to interruption since anytime a thread is blocked/waiting it can be interrupted. 

Is request.onNext ever being called concurrently, or is it sequentially? I can't tell for sure but it looks okay as it looks like it's only ever the single UI thread that would trigger an onNext. If you intend on calling it concurrently wrap it in a SerializedSubject.

If the UI event listener triggers before `ObserveThings.start` completes then `request` may not yet be initialized, or the pipeline may not yet be initialized. It looks like that could be race condition ... but I don't understand how `MainActivity` works well enough. Is that all on the UI thread, or does a background thread do that and then the `setOnClickListener` register with the UI thread?

I don't particularly see anything wrong in this code ... though to be more idiomatic I would suggest using the Observable sequence to manipulate the data instead of doing it inside the `subscribe`. You really should never need to use `toBlocking`. The only 3 times that is ever intended are:

1) Example code in a main method
2) Unit tests (and even then you should probably use TestSubscribe.awaitTerminalEvent instead)
3) Bridging between a blocking and non-blocking system, such as a Servlet 

In this case, instead of doing flatMap.subscribe(all logic here) do something like this instead:

``` java
request.flatMap(mapResult)
.map(transformFunction)
.filter(notNull())
.distinct()
.toList()
.subscribe(yourListHere)
```

This is more idiomatic, doesn't involve creating another Observable and never requires doing the `toBlocking` stuff.... which is kind of the point of Rx. You should only ever have 1 subscribe at the very end of your flow and it should just be the side-effect, no actual processing in it.
 =||= MainActivity all happens on the main thread, as does the onClickHandler.

I've worked around the problem in our app by no longer using `toBlocking` in our subscribe method, but I still think there might be an Rx bug here.  Android shouldn't interrupt unless there's a deadlock of some sort, and I'm afraid the nested toBlocking calls (discouraged though they may be) are causing the thread to stall.  Regardless, the workaround is easy, so I don't think this should be a 1.0 blocker.  Thanks for looking into it!
 =||= You should really only ever call to blocking in command line test scripts but never in production code.

If you really need to end up blocking, you may as well push all the blocking backwardsvand write regular synchrounius code. 
 =||= Maybe we should mark toblocking as depricated (forever) such that you get a warning every time you use it. 
 =||= Deprecated seems wrong to me since it's never actually going to be removed.  I'm all in favor of updating the docs to reflect the recommended uses of toBlocking, though.  

Or maybe deprecate `toBlocking()` and delegate to a new method called `areYouReallySureYouNeedToBlocking()` or something obnoxious like that?
 =||= > You should really only ever call to blocking in command line test scripts but never in production code.

Not everyone have their entire codebase under their control. Also in Android there are already plenty of ways to move tasks to background threads: all those legacy `Loader`s, `AsyncTask`s and `AbstractThreadedSyncAdapter`s requires certain data to be available directly without Observable shenanigans.

> Does Android ever interrupt a thread based on user or system activity?

I am not sure about this one, but FutureTask/ExecutorService combo was working just fine before migrating to RxJava (so was the previous version of RxJava, before updating to rc8).
 =||= @edenman

> Android shouldn't interrupt unless there's a deadlock of some sort, and I'm afraid the nested toBlocking calls (discouraged though they may be) are causing the thread to stall.

Can you provide a reference to documentation about how Android does this? That would be helpful. If it does this then any sort of blocking would be vulnerable to interruption. 

> Not everyone have their entire codebase under their control.

Understood, though I still suggest putting most of the processing into the Observable chain and not even having a `subscribe` step and just going direct to `toBlocking()` if you actually are just using it as an Iterable with higher-order functions. 
 =||= If this doesn't happen on rc7 but does on rc8 then let's binary search what is causing it. Here is what changed: https://github.com/ReactiveX/RxJava/releases/tag/v1.0.0-rc.8

This is the only change that may be related: https://github.com/ReactiveX/RxJava/pull/1793/files

Note how it now triggers the unsubscribe upwards before the onNext is emitted whereas before it was after.

This could theoretically result in work upstream canceling a Future which interrupts a thread if everything is happening on the same thread. 
 =||= Can't find any Android docs that describe what we're seeing.  [Here](http://developer.android.com/training/articles/perf-anr.html)'s the docs on ANR (Application Not Responding) but we're seeing an actual crash.  

Maybe worth seeing if it's rxjava itself that is interrupting the thread?
 =||= > Maybe worth seeing if it's rxjava itself that is interrupting the thread?

Yup, I pointed to a change in rc8 above that could potentially cause this. I'm trying to hunt down options. 
 =||= Here are the two places I can see that may result in an interrupt:
- https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/subscriptions/Subscriptions.java#L102
- https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OnSubscribeToObservableFuture.java#L65

The first one is used by virtually all use of Schedulers to allow canceling work on a Scheduler. 

I still can't replicate an interrupt with `take` but conceptually I can see how an interrupt could happen.
 =||= I can replicate:

``` java
    @Test
    public void testInterrupt() throws InterruptedException {
        final AtomicReference<Object> exception = new AtomicReference<Object>();
        final CountDownLatch latch = new CountDownLatch(1);
        Observable.just(1).subscribeOn(Schedulers.computation()).take(1).subscribe(new Action1<Integer>() {

            @Override
            public void call(Integer t1) {
                try {
                    Observable.just(t1).toBlocking().single();
                } catch (Exception e) {
                    exception.set(e);
                    e.printStackTrace();
                } finally {
                    latch.countDown();
                }
            }

        });

        latch.await();
        assertNull(exception.get());
    }
```

```
cancelling ... and can interrupt
java.lang.RuntimeException: Interrupted while waiting for subscription to complete.
    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:475)
    at rx.observables.BlockingObservable.single(BlockingObservable.java:349)
    at rx.internal.operators.OperatorTakeTest$12.call(OperatorTakeTest.java:376)
    at rx.internal.operators.OperatorTakeTest$12.call(OperatorTakeTest.java:1)
    at rx.Observable$31.onNext(Observable.java:7209)
    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:104)
    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:70)
    at rx.internal.operators.OnSubscribeRedo$2$1.onNext(OnSubscribeRedo.java:229)
    at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:41)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:1)
    at rx.Observable.unsafeSubscribe(Observable.java:7374)
    at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.InterruptedException
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1302)
    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:472)
    ... 20 more
```

Reverting https://github.com/ReactiveX/RxJava/pull/1793 does fix this.

So now to figure out if https://github.com/ReactiveX/RxJava/pull/1793 can be achieved in a different way, or if we need to solve the interruption issue.
 =||= Here is a simpler test:

``` java
    @Test
    public void testInterrupt() throws InterruptedException {
        final AtomicReference<Object> exception = new AtomicReference<Object>();
        final CountDownLatch latch = new CountDownLatch(1);
        Observable.just(1).subscribeOn(Schedulers.computation()).take(1).subscribe(new Action1<Integer>() {

            @Override
            public void call(Integer t1) {
                try {
                    Thread.sleep(100);
                } catch (Exception e) {
                    exception.set(e);
                    e.printStackTrace();
                } finally {
                    latch.countDown();
                }
            }

        });

        latch.await();
        assertNull(exception.get());
    }
```
 =||= Ugh ... choosing whether to default to interrupting or not is a difficult one. It seems that perhaps we should not. Any insights on this?
 =||= I have submitted a possible fix but want to think about this more.

I can't find an authoritative answer on whether we should default to interrupting or not when the scheduled future is canceled. I think we should change to not interrupting but want to be sure that's correct as we've had it set to interrupt all along.
 =||= > but want to think about this more. 

same here.
 =||= A quick note about `Thread` interruptions on Android. AFAIK application process is killed in case of ANRs (either automatically or after a user confirmation). So ANRs do not lead to thread interruptions.

However, there is a case when I use `toBlocking` and get an interruption: sync adapter thread. 

On Android we can create a component that will be plugged to the sync part of the framework. Basically Android framework spawns a new thread for you and invokes your code in that thread. Application sync is supposed to be finished when this thread finishes. In our sync adapter code we build a chain of observables that can perform some operations concurrently using other threads. So the sync adapter code invoked in the sync thread looks like `buildChainOfObservables().toBlocking().single();`.
Sync can be canceled (e.g. by user request, unchecking a checkbox in system settings, or when it takes too long). And a default implementation of cancelation request is this sync thread interruption.
 =||= @headinthebox A consideration here is that the place we are interrupting the threads is really just for unscheduling any scheduled actions from a Scheduler. I think we intend `subscription.isUnsubscribed()` to be the mechanism for something to gracefully stop. 

It seems to me that we should not interrupt a thread automatically and that if a developer needs to do that their `Observable` should register a `Subscription` via `subscriber.add` that chooses to do so.

We can work around this particular `take` issue, but it makes me wonder if we would trigger this type of issue anywhere else. It seems that interrupting threads is a very nuanced thing that most code doesn't handle well and that we shouldn't be interrupting threads "under the covers".

Therefore I suggest we change from `future.cancel(true)` to `future.cancel(false)` for the 2 places we capture a `Future` and cancel it when unsubscribing. 
 =||= @roman-mazur Thanks for that information, it is useful information. If I understand correctly you are saying there are normal cases when Android can and will interrupt a thread and thus application code must account for this. Is this what you're saying?

As far as RxJava is concerned, I'm suggesting we eliminate the two places where RxJava is the culprit for interrupting the thread (despite #1832 working around the particular issue of using `single` that triggers the issue).
 =||= > It seems to me that we should not interrupt a thread automatically

Wait, so you DO interrupt threads right now, don't you? Does that mean, that unsubscribing from Observale (in currently released version), during interruptable operation will interrupt it? Will operations, created with `async-utils` (e.g. via `Async.fromCallable()`) be interrupted? Or is it some internal mechanic for disposing of Schedulers only?

If former, it would be really cool to leave it be.

> If I understand correctly you are saying there are normal cases when Android can and will interrupt a thread and thus application code must account for this. Is this what you're saying?

I wouldn't call `AbstractThreadedSyncAdpter` a normal case. Interrupting worker thread is just an implementation detail, which can be changed by overriding single method. Also Sync Framework in general is rather special and restrictive environment, and interrupting threads isn't worst thing awaiting developer there (for example, failure to intercept any exceptions may result in Sync Adapter being completely banned from execution by OS).
 =||= @benjchristensen I would rather say that Android framework is unlikely to interrupt an application thread. The sync worker is the only known example. And interruption is a default behaviour that can be changed.

But note that I'm forced to use `toBlocking` within this thread because there is no other way to indicate that sync is finished.
I wonder what happens when `toBlocking().single()` is interrupted. As far as I understand an error is propagated. Does it lead to un-subscriptions?
 =||= @roman-mazur 

> I wonder what happens when toBlocking().single() is interrupted. As far as I understand an error is propagated. Does it lead to un-subscriptions?

If it is interrupted while waiting on the single item we just fail right now. I suppose we could call `unsubscribe` upwards before throwing. 

This is what currently happens:

``` java
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);
        }
```
 =||= @Alexander-- 

> Or is it some internal mechanic for disposing of Schedulers only?

RxJava core libraries only interrupt when unsubscribing a scheduled action on a `Scheduler` that is still running. This is in turn just leveraging the `Future.cancel` semantics of Java. RxJava does not actually ever call `Thread.interrupt`.

The async-utils are just utility methods on top of Schedulers so unless there is some effort to specifically prevent interrupt (nothing I can see while browsing the code) they will also be interrupted if they are still executing when unsubscribe is invoked. 

> unsubscribing from Observale (in currently released version), during interruptable operation will interrupt it?

If a Scheduler is not involved RxJava itself does nothing other than invoke `Subscription.unSubscribe` which flips a boolean and calls any registered callbacks. Thus, an `Observable` implementation can choose to register a `Subscription` that then interrupts and interruptible unit of work. 

I'm wondering if that is better for an Observable implementation (via `Observable.create`) to opt-in to interrupts rather than the current `Scheduler` interrupt mechanism which seems like it could be surprising. 
 =||= ,0
1840,1804,"Interrupted while waiting for subscription to complete." in 1.0.0-rc8,Doesn't happen on rc7.  I can repro 100% of the time.  Happens on both KitKat and Lollipop so I don't think it's specific to any particular Android version.

```
FATAL EXCEPTION: RxCachedThreadScheduler-4
Process: com.mycompany.myapp.development, PID: 4413
java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.
        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:50)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)
        at java.util.concurrent.FutureTask.run(FutureTask.java:237)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
        at java.lang.Thread.run(Thread.java:818)
Caused by: rx.exceptions.OnErrorNotImplementedException: Interrupted while waiting for subscription to complete. 
        at rx.Observable$30.onError(Observable.java:7252)
        at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:127)
        at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:96)
        at rx.internal.operators.OperatorMap$1.onError(OperatorMap.java:48)
        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)
        at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)
        at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitNext(SubjectSubscriptionManager.java:254)
        at rx.subjects.BehaviorSubject.onNext(BehaviorSubject.java:166)
        at rx.Observable$34.onNext(Observable.java:7437)
        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:104)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:610)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:536)
        at rx.internal.operators.OperatorSingle$1.onCompleted(OperatorSingle.java:75)
        at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:72)
        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)
        at com.mycompany.servercall.ServerCall$1$1.call(ServerCall.java:56)
        at com.mycompany.servercall.ServerCall$1$1.call(ServerCall.java:47)
        at rx.Observable.unsafeSubscribe(Observable.java:7464)
        at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)
        ... 7 more 
Caused by: java.lang.RuntimeException: Interrupted while waiting for subscription to complete. 
        at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:474)
        at rx.observables.BlockingObservable.single(BlockingObservable.java:348)
        at com.mycompany.myapp.data.CachedThing.buildCachedThing(CachedThing.java:66)
        at com.mycompany.myapp.data.CachedThing.<init>(CachedThing.java:28)
        at com.mycompany.myapp.data.FilterFunc.call(FilterFunc.java:189)
        at com.mycompany.myapp.data.FilterFunc.call(FilterFunc.java:175)
        at com.mycompany.myapp.data.CachedThing.merge(CachedThing.java:60)
        at com.mycompany.myapp.data.ResponseCache.update(ResponseCache.java:80)
        at com.mycompany.myapp.data.TransformFunc.call(TransformFunc.java:105)
        at com.mycompany.myapp.data.TransformFunc.call(TransformFunc.java:99)
        at com.mycompany.servercall.CallState$3.map(CallState.java:79)
        at com.mycompany.servercall.CallState$9.call(CallState.java:195)
        at com.mycompany.servercall.CallState$9.call(CallState.java:193)
        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)
        ... 22 more
Caused by: java.lang.InterruptedException
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1279)
        at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:202)
        at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:471)
        ... 35 more
Caused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: .class 
        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)
        ... 22 more
```

`CachedThing.buildCachedThing` has this block of code that I think is the culprit:

```
List<SubThing> subThings = Observable.from(things) //
        .map(transformFunction) //
        .filter(not(isNullFunction)) //
        .distinct() //
        .toList() //
        .toBlocking() //
        .single();
```

I tried writing a testcase to repro but couldn't get it to fail.  I'm guessing there's something broken between the android runtime and rxjava's thread management, but I couldn't get any further than that.,The only thing in rc8 that seems related is this: https://github.com/ReactiveX/RxJava/pull/1793
 =||= I can not replicate with this code:

``` java
import java.util.List;

import rx.functions.Func1;

public class Testing {

    public static void main(String... args) {
        List<String> subThings = Observable.range(0, 1000)
                .map(new Func1<Integer, String>() {

                    @Override
                    public String call(Integer i) {
                        return String.valueOf(i + 1);
                    }

                })
                .filter(new Func1<String, Boolean>() {

                    @Override
                    public Boolean call(String t) {
                        return t != null;
                    }

                }) //
                .distinct() //
                .toList() //
                .toBlocking() //
                .single();

        System.out.println(subThings);
    }
}
```
 =||= The code that is being interrupted is this: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/observables/BlockingObservable.java#L473

``` java
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);
        }
```

This means the thread was blocked on the latch waiting for a result but while it was waiting it got interrupted. 

I don't know what thread you are doing this on, nor do I know much about Android. If Android is using pools of threads it could perhaps retain the right to interrupt and reclaim threads? I know event loops in some frameworks do that kind of thing if something is blocked in them and new work is scheduled. 

RxJava itself does not interrupt threads anywhere (that I'm aware of ... and I can't think of any reason we would) so I'm inclined to suggest looking at what thread you are blocking in and see if Android itself could be interrupting it?

Also, could you move to a model where you don't block and instead compose it all together reactively?
 =||= Moving to 1.0.x as it's not obvious yet what is going on here.
 =||= Encountered this on Jellybean. Code in my Application subclass:

``` java
Observable<SomeSharedPreferencesWrapper> prefsPrefetch = Async.start(this::prefetchPrefs);
```

And later in same class:

``` java
return prefsPrefetch.toBlocking().single();
```

I can't grasp exact circumstances, when issue reproduces itself. At first glance they seem to be random, but happens often enough to make prefetching stuff with RxJava pretty much impossible.
 =||= I'm gonna work on putting together a minimal test Android app to try and isolate the issue.
 =||= https://dl.dropboxusercontent.com/u/7829307/RxJavaBlockingBug.zip

I wasn't able to repro until I added the PublishSubject layer...maybe the issue is the nested toBlocking() calls?
 =||= Does Android ever interrupt a thread based on user or system activity? If so then the `toBlocking()` will always be vulnerable to interruption since anytime a thread is blocked/waiting it can be interrupted. 

Is request.onNext ever being called concurrently, or is it sequentially? I can't tell for sure but it looks okay as it looks like it's only ever the single UI thread that would trigger an onNext. If you intend on calling it concurrently wrap it in a SerializedSubject.

If the UI event listener triggers before `ObserveThings.start` completes then `request` may not yet be initialized, or the pipeline may not yet be initialized. It looks like that could be race condition ... but I don't understand how `MainActivity` works well enough. Is that all on the UI thread, or does a background thread do that and then the `setOnClickListener` register with the UI thread?

I don't particularly see anything wrong in this code ... though to be more idiomatic I would suggest using the Observable sequence to manipulate the data instead of doing it inside the `subscribe`. You really should never need to use `toBlocking`. The only 3 times that is ever intended are:

1) Example code in a main method
2) Unit tests (and even then you should probably use TestSubscribe.awaitTerminalEvent instead)
3) Bridging between a blocking and non-blocking system, such as a Servlet 

In this case, instead of doing flatMap.subscribe(all logic here) do something like this instead:

``` java
request.flatMap(mapResult)
.map(transformFunction)
.filter(notNull())
.distinct()
.toList()
.subscribe(yourListHere)
```

This is more idiomatic, doesn't involve creating another Observable and never requires doing the `toBlocking` stuff.... which is kind of the point of Rx. You should only ever have 1 subscribe at the very end of your flow and it should just be the side-effect, no actual processing in it.
 =||= MainActivity all happens on the main thread, as does the onClickHandler.

I've worked around the problem in our app by no longer using `toBlocking` in our subscribe method, but I still think there might be an Rx bug here.  Android shouldn't interrupt unless there's a deadlock of some sort, and I'm afraid the nested toBlocking calls (discouraged though they may be) are causing the thread to stall.  Regardless, the workaround is easy, so I don't think this should be a 1.0 blocker.  Thanks for looking into it!
 =||= You should really only ever call to blocking in command line test scripts but never in production code.

If you really need to end up blocking, you may as well push all the blocking backwardsvand write regular synchrounius code. 
 =||= Maybe we should mark toblocking as depricated (forever) such that you get a warning every time you use it. 
 =||= Deprecated seems wrong to me since it's never actually going to be removed.  I'm all in favor of updating the docs to reflect the recommended uses of toBlocking, though.  

Or maybe deprecate `toBlocking()` and delegate to a new method called `areYouReallySureYouNeedToBlocking()` or something obnoxious like that?
 =||= > You should really only ever call to blocking in command line test scripts but never in production code.

Not everyone have their entire codebase under their control. Also in Android there are already plenty of ways to move tasks to background threads: all those legacy `Loader`s, `AsyncTask`s and `AbstractThreadedSyncAdapter`s requires certain data to be available directly without Observable shenanigans.

> Does Android ever interrupt a thread based on user or system activity?

I am not sure about this one, but FutureTask/ExecutorService combo was working just fine before migrating to RxJava (so was the previous version of RxJava, before updating to rc8).
 =||= @edenman

> Android shouldn't interrupt unless there's a deadlock of some sort, and I'm afraid the nested toBlocking calls (discouraged though they may be) are causing the thread to stall.

Can you provide a reference to documentation about how Android does this? That would be helpful. If it does this then any sort of blocking would be vulnerable to interruption. 

> Not everyone have their entire codebase under their control.

Understood, though I still suggest putting most of the processing into the Observable chain and not even having a `subscribe` step and just going direct to `toBlocking()` if you actually are just using it as an Iterable with higher-order functions. 
 =||= If this doesn't happen on rc7 but does on rc8 then let's binary search what is causing it. Here is what changed: https://github.com/ReactiveX/RxJava/releases/tag/v1.0.0-rc.8

This is the only change that may be related: https://github.com/ReactiveX/RxJava/pull/1793/files

Note how it now triggers the unsubscribe upwards before the onNext is emitted whereas before it was after.

This could theoretically result in work upstream canceling a Future which interrupts a thread if everything is happening on the same thread. 
 =||= Can't find any Android docs that describe what we're seeing.  [Here](http://developer.android.com/training/articles/perf-anr.html)'s the docs on ANR (Application Not Responding) but we're seeing an actual crash.  

Maybe worth seeing if it's rxjava itself that is interrupting the thread?
 =||= > Maybe worth seeing if it's rxjava itself that is interrupting the thread?

Yup, I pointed to a change in rc8 above that could potentially cause this. I'm trying to hunt down options. 
 =||= Here are the two places I can see that may result in an interrupt:
- https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/subscriptions/Subscriptions.java#L102
- https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OnSubscribeToObservableFuture.java#L65

The first one is used by virtually all use of Schedulers to allow canceling work on a Scheduler. 

I still can't replicate an interrupt with `take` but conceptually I can see how an interrupt could happen.
 =||= I can replicate:

``` java
    @Test
    public void testInterrupt() throws InterruptedException {
        final AtomicReference<Object> exception = new AtomicReference<Object>();
        final CountDownLatch latch = new CountDownLatch(1);
        Observable.just(1).subscribeOn(Schedulers.computation()).take(1).subscribe(new Action1<Integer>() {

            @Override
            public void call(Integer t1) {
                try {
                    Observable.just(t1).toBlocking().single();
                } catch (Exception e) {
                    exception.set(e);
                    e.printStackTrace();
                } finally {
                    latch.countDown();
                }
            }

        });

        latch.await();
        assertNull(exception.get());
    }
```

```
cancelling ... and can interrupt
java.lang.RuntimeException: Interrupted while waiting for subscription to complete.
    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:475)
    at rx.observables.BlockingObservable.single(BlockingObservable.java:349)
    at rx.internal.operators.OperatorTakeTest$12.call(OperatorTakeTest.java:376)
    at rx.internal.operators.OperatorTakeTest$12.call(OperatorTakeTest.java:1)
    at rx.Observable$31.onNext(Observable.java:7209)
    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:104)
    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:70)
    at rx.internal.operators.OnSubscribeRedo$2$1.onNext(OnSubscribeRedo.java:229)
    at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:41)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:1)
    at rx.Observable.unsafeSubscribe(Observable.java:7374)
    at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.InterruptedException
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1302)
    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:472)
    ... 20 more
```

Reverting https://github.com/ReactiveX/RxJava/pull/1793 does fix this.

So now to figure out if https://github.com/ReactiveX/RxJava/pull/1793 can be achieved in a different way, or if we need to solve the interruption issue.
 =||= Here is a simpler test:

``` java
    @Test
    public void testInterrupt() throws InterruptedException {
        final AtomicReference<Object> exception = new AtomicReference<Object>();
        final CountDownLatch latch = new CountDownLatch(1);
        Observable.just(1).subscribeOn(Schedulers.computation()).take(1).subscribe(new Action1<Integer>() {

            @Override
            public void call(Integer t1) {
                try {
                    Thread.sleep(100);
                } catch (Exception e) {
                    exception.set(e);
                    e.printStackTrace();
                } finally {
                    latch.countDown();
                }
            }

        });

        latch.await();
        assertNull(exception.get());
    }
```
 =||= Ugh ... choosing whether to default to interrupting or not is a difficult one. It seems that perhaps we should not. Any insights on this?
 =||= I have submitted a possible fix but want to think about this more.

I can't find an authoritative answer on whether we should default to interrupting or not when the scheduled future is canceled. I think we should change to not interrupting but want to be sure that's correct as we've had it set to interrupt all along.
 =||= > but want to think about this more. 

same here.
 =||= A quick note about `Thread` interruptions on Android. AFAIK application process is killed in case of ANRs (either automatically or after a user confirmation). So ANRs do not lead to thread interruptions.

However, there is a case when I use `toBlocking` and get an interruption: sync adapter thread. 

On Android we can create a component that will be plugged to the sync part of the framework. Basically Android framework spawns a new thread for you and invokes your code in that thread. Application sync is supposed to be finished when this thread finishes. In our sync adapter code we build a chain of observables that can perform some operations concurrently using other threads. So the sync adapter code invoked in the sync thread looks like `buildChainOfObservables().toBlocking().single();`.
Sync can be canceled (e.g. by user request, unchecking a checkbox in system settings, or when it takes too long). And a default implementation of cancelation request is this sync thread interruption.
 =||= @headinthebox A consideration here is that the place we are interrupting the threads is really just for unscheduling any scheduled actions from a Scheduler. I think we intend `subscription.isUnsubscribed()` to be the mechanism for something to gracefully stop. 

It seems to me that we should not interrupt a thread automatically and that if a developer needs to do that their `Observable` should register a `Subscription` via `subscriber.add` that chooses to do so.

We can work around this particular `take` issue, but it makes me wonder if we would trigger this type of issue anywhere else. It seems that interrupting threads is a very nuanced thing that most code doesn't handle well and that we shouldn't be interrupting threads "under the covers".

Therefore I suggest we change from `future.cancel(true)` to `future.cancel(false)` for the 2 places we capture a `Future` and cancel it when unsubscribing. 
 =||= @roman-mazur Thanks for that information, it is useful information. If I understand correctly you are saying there are normal cases when Android can and will interrupt a thread and thus application code must account for this. Is this what you're saying?

As far as RxJava is concerned, I'm suggesting we eliminate the two places where RxJava is the culprit for interrupting the thread (despite #1832 working around the particular issue of using `single` that triggers the issue).
 =||= > It seems to me that we should not interrupt a thread automatically

Wait, so you DO interrupt threads right now, don't you? Does that mean, that unsubscribing from Observale (in currently released version), during interruptable operation will interrupt it? Will operations, created with `async-utils` (e.g. via `Async.fromCallable()`) be interrupted? Or is it some internal mechanic for disposing of Schedulers only?

If former, it would be really cool to leave it be.

> If I understand correctly you are saying there are normal cases when Android can and will interrupt a thread and thus application code must account for this. Is this what you're saying?

I wouldn't call `AbstractThreadedSyncAdpter` a normal case. Interrupting worker thread is just an implementation detail, which can be changed by overriding single method. Also Sync Framework in general is rather special and restrictive environment, and interrupting threads isn't worst thing awaiting developer there (for example, failure to intercept any exceptions may result in Sync Adapter being completely banned from execution by OS).
 =||= @benjchristensen I would rather say that Android framework is unlikely to interrupt an application thread. The sync worker is the only known example. And interruption is a default behaviour that can be changed.

But note that I'm forced to use `toBlocking` within this thread because there is no other way to indicate that sync is finished.
I wonder what happens when `toBlocking().single()` is interrupted. As far as I understand an error is propagated. Does it lead to un-subscriptions?
 =||= @roman-mazur 

> I wonder what happens when toBlocking().single() is interrupted. As far as I understand an error is propagated. Does it lead to un-subscriptions?

If it is interrupted while waiting on the single item we just fail right now. I suppose we could call `unsubscribe` upwards before throwing. 

This is what currently happens:

``` java
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);
        }
```
 =||= @Alexander-- 

> Or is it some internal mechanic for disposing of Schedulers only?

RxJava core libraries only interrupt when unsubscribing a scheduled action on a `Scheduler` that is still running. This is in turn just leveraging the `Future.cancel` semantics of Java. RxJava does not actually ever call `Thread.interrupt`.

The async-utils are just utility methods on top of Schedulers so unless there is some effort to specifically prevent interrupt (nothing I can see while browsing the code) they will also be interrupted if they are still executing when unsubscribe is invoked. 

> unsubscribing from Observale (in currently released version), during interruptable operation will interrupt it?

If a Scheduler is not involved RxJava itself does nothing other than invoke `Subscription.unSubscribe` which flips a boolean and calls any registered callbacks. Thus, an `Observable` implementation can choose to register a `Subscription` that then interrupts and interruptible unit of work. 

I'm wondering if that is better for an Observable implementation (via `Observable.create`) to opt-in to interrupts rather than the current `Scheduler` interrupt mechanism which seems like it could be surprising. 
 =||= ,0
1866,1865,ReplaySubject memory leak,This little baby will grind to a halt do due never letting go of the events:

``` java
import rx.subjects.ReplaySubject;

public class Application {
  public static void main(String[] args) {
    ReplaySubject<Integer> subject = ReplaySubject.createWithSize(10);
    subject.subscribe(x -> {});
    int ii = 0;
    while(true) {
      subject.onNext(ii);
      ii++;
    }
  }
}
```,tested on 1.0.0-rc.10
 =||= I merged the fix.
 =||= ,0
1884,1881,Scan/Reduce Overloads & Type Erasure,I think the recent additions to `scan`/`reduce` may cause issues

``` java
scan(R, Func2<R, ? super T, R>)
scan(Func0<R>, Func2<R, ? super T, R>)
```

The `Func0` passed in looks like it can be treated like an `Object` and considered ambiguous and match with `R` instead of `Func0`.

Here is a compilation error:

```
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project learnrxjava: Compilation failure: Compilation failure:
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[10,32] reference to reduce is ambiguous
[ERROR] both method <R>reduce(R,rx.functions.Func2<R,? super T,R>) in rx.Observable and method <R>reduce(rx.functions.Func0<R>,rx.functions.Func2<R,? super T,R>) in rx.Observable match
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[10,39] incompatible types: cannot infer type-variable(s) R
[ERROR] (argument mismatch; java.lang.Object is not a functional interface)
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[17,32] reference to scan is ambiguous
[ERROR] both method <R>scan(R,rx.functions.Func2<R,? super T,R>) in rx.Observable and method <R>scan(rx.functions.Func0<R>,rx.functions.Func2<R,? super T,R>) in rx.Observable match
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[17,37] incompatible types: cannot infer type-variable(s) R
[ERROR] (argument mismatch; java.lang.Object is not a functional interface)
[ERROR] -> [Help 1]
```

Here is example code: https://github.com/jhusain/learnrxjava/blob/master/src/main/java/learnrxjava/examples/ScanVsReduceExample.java

``` java
package learnrxjava.examples;

import java.util.ArrayList;

import rx.Observable;

public class ScanVsReduceExample {

    public static void main(String... args) {
        Observable.range(0, 10).reduce(() -> new ArrayList<Integer>(), (list, i) -> {
            list.add(i);
            return list;
        }).forEach(System.out::println);

        System.out.println("... vs ...");

        Observable.range(0, 10).scan(() -> new ArrayList<Integer>(), (list, i) -> {
            list.add(i);
            return list;
        }).forEach(System.out::println);
    }
}
```

It looks like we need to do one of 3 things:

1) Remove one of several things:

``` java
scan(R, Func2<R, ? super T, R>)
scan(Func0<R>, Func2<R, ? super T, R>)
```

2) Rename one of them

3) Add an extra argument so arity solves it.

I actually think the most correct thing to do is remove `scan(R, Func2<R, ? super T, R>)` since an initial value is most often intended for mutable state in `scan`/`reduce`. 

cc @headinthebox as this is a last minute API fix we need prior to Monday for 1.0,I'd be happy with `Func<0>` as the only way, but then we have to do the same for `reduce` and anything else that takes a seed.
 =||= BTW, if we do this, then we should consider generalizing to returning `S` since we are side-effecting `R`, so it does not matter to return return the mutable state variable since that is passed in by the implementation.

`scan(Func0<R>, Func2<R, ? super T, S>)`
 =||= I have submitted #1883 to fix the ambiguity that happens with lambdas. 

I have changed `scan`, `reduce` and `collect`. I don't see anywhere else that needs to change.
 =||= I'm going to pull the factory overload until 1.1 so we make sure we get this right. 
 =||= Fixed in #1884 by deleting the ambiguous new factory overloads for `scan` and `reduce` and modifying `collect` to support the mutable case with a seed factory and side-affection action.
 =||= ,0
1886,1867,usage of 2 buffers with both a timespan and a count,The usage of 2 RxJava buffers with both a timespan and a count will eventually make the events be emitted at a very slow rate to the subscriber.
The observed rate will be as slow as 1 item per whatever is the second buffer timespan.

Please see the following Gist for the JUnit code demonstrating the issue.
https://gist.github.com/YannRobert/32921e8e88c62c5af1f9,Putting on 1.0.x though we might be able to get this in for 1.0.

Thank you for the report and sample code. 
 =||= fixed in 1.0.0-RC12
 =||= ,0
1901,1900,retry() hangs when it is followed by a group by with >= 1024 items,For an operator chain like o.retry().groupBy().... if the source Observable has >= 1024 items the JVM seems to hang. Repeated unsubscribe calls seem to be sent by retry() upwards
https://gist.github.com/neerajrj/8bb9106ca1b81e08a40f,Fixed in #1901
 =||= ,0
1922,1919,(Updated): timeout() operator leaking ScheduledFutureTasks on Scheduler,Hi folks,

(update, see below, looks like it's the timeout operator) 

I'm raising a ticket earlier than later, because I suspect we have a leak somewhere in the Scheduler logic. It could by in my code too, but from the characteristics it looks more like something rx internal.

I've been able to generate some OOM scenarios where GC takes all the time to clean things up and it's not able to, which pointed me to a leak. A heap dump showed the leak suspect is the ScheduledFutureTask as part of the computation scheduler:

![screen shot 2014-12-02 at 10 40 28](https://cloud.githubusercontent.com/assets/29086/5260491/b9420760-7a0f-11e4-874f-e8e9ad22a918.png)

You can see a full GC kicking in without actually making old gen smaller:

![screen shot 2014-12-02 at 10 42 50](https://cloud.githubusercontent.com/assets/29086/5260509/044a317e-7a10-11e4-8cc3-b3a17bd1d1f6.png)

The code path uses both .observeOn() once to move it onto a scheduler and also blocks .single() at the very end. So I'll start looking in those places. But maybe @akarnokd or @benjchristensen you have an idea where I can start debugging?,One thing that is suspicious is that my rx computation pools should be very silent, because I'm using observeOn my own scheduler (a spinoff of the computation one because it does not allow thread naming manually).

So while they are quiet (see threads) they have lots in their work queue.

![screen shot 2014-12-02 at 10 51 47](https://cloud.githubusercontent.com/assets/29086/5260636/5943b24e-7a11-11e4-95a5-724906cbac32.png)

![screen shot 2014-12-02 at 10 53 38](https://cloud.githubusercontent.com/assets/29086/5260654/800ab062-7a11-11e4-9e6a-c900956aa2e7.png)
 =||= @akarnokd any idea what a ScheduledAction "null" is?

![screen shot 2014-12-02 at 11 01 45](https://cloud.githubusercontent.com/assets/29086/5260757/ab261a42-7a12-11e4-8d14-8c5a64493091.png)

Looks like it's carrying a Timeout operation which makes sense to be done on the Rx one because I forgot to move it to our computation scheduler. Probably the leak is in the timeout operator?

Quick update: yup that looks like to be the cause, when I remove the timeout operator and do a manual full GC it goes back to steady, nothing leaking there.
 =||= ScheduledAction extends AtomicReference<Thread> so unless it has run already, it contains a null value. I did this for the free atomic operator(s).

In addition, there is a shortcoming in Java 6 ScheduledThreadPool where cancelled far-future tasks remain in the pool's queue until their time has actually passed, at when they get just evicted. Java 7 introduced a `setRemoveOnCancelPolicy()` method to get rid of them ASAP (defaults to false for compatibility reasons). (Historical note: in my RxJava predecessor, I had this method called reflectively when a scheduled pool was instantiated.)
 =||= @akarnokd see my last update, it seems to be in timeout() .. when I remove it, no leak.
 =||= Here is with the timeout operator removed:

![screen shot 2014-12-02 at 11 16 36](https://cloud.githubusercontent.com/assets/29086/5260941/bb104be2-7a14-11e4-82c4-ce67a6362bd6.png)
 =||= Is the use case able to be represented in a simple unit test so we can reproduce and fix?

If not then is it a high volume of timeouts (that don't trigger) causing it?
 =||= I'm trying to get it into something testable, although since I'm not familiar with the low level internals I don't know how we can prove that it is not leaking. I'll try to get something that at least shows it in a profiler when running it.

Btw note the code that triggers it is very simple: https://github.com/couchbase/couchbase-java-client/blob/master/src/main/java/com/couchbase/client/java/CouchbaseBucket.java#L288

Could it also be interplay between `timeout()` and the blocking observable conversion that is not doing something that the timeout operator expects?
 =||= Okay with something simple like

``` java
while(true) {
   Observable
        .timer(5, TimeUnit.MICROSECONDS)
        .timeout(1, TimeUnit.SECONDS)
        .toBlocking()
        .single();
}
```

Or chaining in a different scheduler before the timeout its not reproducible, no leaks there. One difference as well is that the code is observing a `AsyncSubject`, I don't know if that makes a difference in this case though.
 =||= @akarnokd  @benjchristensen Wow, actually **it is** reproducible with that code. It shows up when you increase the timeout a lot. Could it be that with the current code the task only vanishes once the timeout is over and the actual onComplete does not cancel it?

``` java
while(true) {
   Observable
        .timer(5, TimeUnit.MICROSECONDS)
        .timeout(1, TimeUnit.SECONDS)
        .toBlocking()
        .single();
}
```

![screen shot 2014-12-02 at 13 18 07](https://cloud.githubusercontent.com/assets/29086/5262415/d97f260a-7a25-11e4-96e7-45294248b8bc.png)

``` java
while(true) {
   Observable
        .timer(5, TimeUnit.MICROSECONDS)
        .timeout(100, TimeUnit.SECONDS)
        .toBlocking()
        .single();
}
```

![screen shot 2014-12-02 at 13 19 04](https://cloud.githubusercontent.com/assets/29086/5262426/e47505b6-7a25-11e4-8926-8520881c1a24.png)
 =||= We've fixed the task retention problem for JDK 6 in 1.0.5. Does the problem still happen for you?
 =||= @akarnokd oh you did? which changeset was that? :)
 =||= @daschl with #2465. I must add, it only works with `ScheduledThreadPoolExecutor` that the JDK is using because the `ScheduledExecutorService` interface doesn't have a `purge` method.
 =||= I'm closing this due to inactivity. If you have further problems, please don't hesitate to reopen this issue or post a new one.
 =||= ,0
1938,1935,OperatorAny unsubscribe issue,OperatorAny (eg used in Observable.isEmpty) does an unsubscribe after seeing that there are any items in the Observable it's subscribing to, to avoid needing to generate un-needed items. 

Unfortunately it seems to be unsubscribing subscribing Observables as well, which can cause it to break.

Here is an example, this code:

```
object OperatorAnyIssue extends App {

  def debug(message: String, value: Any): Unit = printf(s"%30s %-14s $value\n", "[" + Thread.currentThread().getName + "]", message)

  def sleepThenGenerateInverse(n: Boolean)() = {
    debug("Generating", !n)
    Thread.sleep(800)
    debug("Sending", !n)
    n
  }

  Observable.from(1 to 5)
    .doOnNext(debug("Generated", _))
    .doOnUnsubscribe(debug("Unsubscribed generator", ""))
    .isEmpty // to fix change this line to: .toSeq.map(_.isEmpty)
    .doOnNext(debug("Is empty", _))
    .flatMap(i => Observable.defer { Observable.just(sleepThenGenerateInverse(i)) }.subscribeOn(IOScheduler()))
    .doOnUnsubscribe(debug("Unsubscribed", ""))
    .subscribe(debug("Received", _))

  Thread.sleep(10000)
}
```

outputs the following - the sleepThenGenerateInverse function gets cut off half way through:

```
                        [main] Generated      1
                        [main] Is empty       false
                        [main] Unsubscribed   
   [RxCachedThreadScheduler-1] Generating     true
                        [main] Unsubscribed generator 
```

Changing the .isEmpty line to .toSeq.map(_.isEmpty) results in the following, which is the expected behaviour:

```
                        [main] Generated      1
                        [main] Generated      2
                        [main] Generated      3
                        [main] Generated      4
                        [main] Generated      5
                        [main] Is empty       false
   [RxCachedThreadScheduler-1] Generating     true
   [RxCachedThreadScheduler-1] Sending        true
   [RxCachedThreadScheduler-1] Received       true
   [RxCachedThreadScheduler-1] Unsubscribed   
   [RxCachedThreadScheduler-1] Unsubscribed generator 


```,Hi and thanks for the report. If you can, try the fixes in PR #1938 and see if it works for you as well.
 =||= With the PR I get:

```
                        [main] Generated      1
                        [main] Is empty       false
                        [main] Unsubscribed generator 
   [RxCachedThreadScheduler-1] Generating     true
   [RxCachedThreadScheduler-1] Sending        true
   [RxCachedThreadScheduler-1] Received       false
   [RxCachedThreadScheduler-1] Unsubscribed   
```

Which is correct. It would be great if this can be included in 1.0.3
 =||= The fix should be in 1.0.4+. Thanks for reporting.
 =||= ,0
1946,1931,AbstractOnSubscribe to help implement backpressure-respecting,observables.

Proposed implementation for #1930. See tests for use cases.,Great stuff! I knocked up some backpressure support a couple of days ago for RxJavaString and was quite bothered by the DRY aspect. This will make implementing `OnSubscribe` way easier let alone getting backpressure support for free. Thanks!
 =||= Just so I remember, an unrelated test failure:

rx.schedulers.TrampolineSchedulerTest > testSequenceOfDelayedActions FAILED
    org.mockito.exceptions.verification.VerificationInOrderFailure: 
    Verification in order failure
    Wanted but not invoked:
    action0.call();
    -> at rx.schedulers.AbstractSchedulerTests.testSequenceOfDelayedActions(AbstractSchedulerTests.java:220)
    Wanted anywhere AFTER following interaction:
    action0.call();
    -> at rx.schedulers.SleepingAction.call(SleepingAction.java:53)

I wonder if this is the queue capacity bug of the JCTools queues we adapted.
 =||= Few enhancement options:
- SubscriptionState could be a producer as well, no need for separate class.
- there is no point in refcounting a null custom state and thus overhead could be reduced.

In addition, there is a potential bug when a next call doesn't produce an event nor does it unsubscribe. With backpressure present, this may stop producing altogether; without backpressure, it may loop indefinitely. This comes up whne phasing is needed by the state machine the programmer implements. So either we detect phase change but no events, we just loop again; or we throw an exception stating the lack of event emissions or explicit unsubscription.
 =||= Can you give an example for the method

`AbstractOnSubscribe.onSubscribe(Subscriber<? super T> subscriber)`

where an overriding implementation uses the subscriber?
 =||= The subscriber is not accessible in next by default to make sure developers only interact with the abstraction, but there might be a case you somehow need the Subscriber, or you need to add some things to unsubscribe if downstream unsubscribes. That might be a Scheduler.Worker, another Subscriber to another Observable. Now with the lambda convenience cases, I just forgot about this by accident. I'll make the fixes in a day.
 =||= Re the potential bug, what about making `next` even simpler by not including a reference to the subscriber (or the abstraction) at all:

``` java
Optional<T> next(S state);
```

The `Iterable<T>` use case would look like:

``` java
@Override
public Optional<T> next(Iterator<T> state) {
    if (state.hasNext())
        return Optional.of(state.next());
    else 
       return Optional.absent();
}
```
 =||= Had another look at your use cases and I see that we would have less flexibility like with calling `onComplete` straight after the `it.next` call in your `Iterator<T>` example. Nevertheless it might be an attractive simplification in a class like `AbstractOnSubscribeSimple`.
 =||= AbstractIterable doesn't seem to give the possibility to have custom state per iterator() calls, so I wanted to work around that. Your iterator example has some limitations, namely you can only produce one response per call and you need to wrap/unwrap things which leads to really unnecessary GC.

What I've said about free backpressure with AbstractIterable is still true. If you can express your iterative computation with it, then there is no need to use AOS.
 =||= This looks really useful, and the docs in the code are great. 

Would you mind rebasing the commits since this is brand new stuff and could be cleanly committed as a single commit?

Thank you for marking it as Experimental as it would be good to get feedback and allow changes before we commit to it.

Is there anything we can learn from generators? (see https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/generators.md)

/cc @headinthebox as I think it would be good to have your input on this. 
 =||= On my TODO!
 =||= Please ignore my previous comments. I just misunderstood the meaning of `phase`.
 =||= > Is there anything we can learn from generators?

Without language support, you are at a loss.
 =||= Seems like a useful addition; I agree about making it available as experimental so we can evolve it.
 =||= > Without language support, you are at a loss.

I know we can't do what real generator implementations do with `yield`. Are the signatures of generators completely affected by the use of `yield` and thus not at all useful to this exploration?
 =||= > Seems like a useful addition; I agree about making it available as experimental so we can evolve it.

Good, glad there is alignment. I'm going to merge #1946 so we can start using and iterating. 
 =||= ,0
1965,195,Unwrap AtomicObservableSubscription?,As far as I can tell, any custom subscription that is passed to `subscribe` gets `wrap`ped in an AtomicObservableSubscription unless `trusted` is true, a flag which can't be controlled from outside.

Since AOS doesn't have an `unwrap` method, how can I pass custom subscriptions in a type safe manner?

Rationale is being able to maintain extra state about a subscription _in_ the subscription.,An Observable by design doesn't expose state so that it can be composed (wrapped) exactly as this is doing. For example, Observable.synchronize() could be used to wrap an Observable before vending it out for use if the Observable was thought to not be thread-safe. This is part of the principles of being functional and monadic.

All state within the Func1 implementation that gets converted into an Observable should be self-contained.

So what is your use case that is causing you to want to reach back into the Observable implementation itself and how are you trying to do that?
 =||= Not sure if it makes a difference, but small correction: we don't want to track state in the Observable, we want to track state in the subscription, which is what the client holds on to.

The reason we want to do this is that on Android we need to deal with component life cycles and need to attach/detach observers to prevent resource leaks, or terminate observable sequence midway through.

I see there is a `BooleanSubscription` which helps terminating loops by checking the subscription for `isUnsubscribed`, which is similar to what we want to do. How would you even use this? Anything I get in return from `subscribe` is wrapped away in an AtomicObservableSubscription.
 =||= The state is always hidden behind the Observable or Subscription interfaces - not leaked out. 

Thus, your Func1 implementation (that becomes and Observable) would return an implementation of Subscription that works with your function correctly to signal an unsubscribe. This is important because the sequences of Observables can be composed n-levels and an unsubscribe will be propagated up the sequence and each Observable then does with it what its implementation dictates - but nothing external ever knows the implementation or tries to reach inside it.

Here's an example of how BooleanSubscription is used:
 https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/VideoExample.groovy#L110

``` groovy
Observable<VideoList> getListOfLists(userId) {
    return Observable.create({ observer -> 
        BooleanSubscription subscription = new BooleanSubscription();
        try {
            // this will happen on a separate thread as it requires a network call
            executor.execute({
                    // simulate network latency
                    Thread.sleep(180);
                    for(i in 0..15) {
                        if(subscription.isUnsubscribed()) {
                            break;
                        }
                        try {
                            //println("****** emitting list: " + i)
                            observer.onNext(new VideoList(i))
                        }catch(Exception e) {
                            observer.onError(e);
                        }
                    }
                    observer.onCompleted();
            })
        }catch(Exception e) {
            observer.onError(e);
        }
        return subscription;
    })
}
```

As for multiple observers subscribing/unsubscribing, that is definitely what Multicast/Publish is all about (https://github.com/Netflix/RxJava/issues/15 and https://github.com/Netflix/RxJava/issues/65) as discussed on Twitter: https://twitter.com/mttkay/status/310819293166178304

It's near the top of the todo list but if you need this functionality sooner than I or someone else is getting to it, perhaps you can try tackling them as they are the right way to handle these issues of state.
 =||= Thanks for clarifying! Have to admit that I'm still getting into the whole mindset of functional programming in Java (the lack of supportive language constructs doesn't help), and it's hard to do it in a clean way when introducing something like Rx into a grown code base. But we're getting there. No rush on the implementation of Multicast, but sure, I'll give it a shot when you guys are too busy!
 =||= Yes, it took myself and my teammates a month or two to adapt our thinking to it and several times we tried breaking the model before we starting thinking functionally. Also the lack of lambdas/closures in Java (until Java8 which I eagerly await) is why we predominantly use RxJava in other languages that support them.
 =||= ,0
1973,1972,Non-deterministic test failure: ReplaySubjectConcurrencyTest.testReplaySubjectEmissionSubscriptionRace,This test randomly failed on my local machine. This was just recently added: https://github.com/ReactiveX/RxJava/pull/1947/files#diff-fe6df6db9fa6e69287f256960599708bR338

/cc @akarnokd ,Where did it fail and with what message?

Edit: never mind, found the issue.
 =||= I failed to capture it, sorry. I copy/pasted the failure from my IDE and then re-ran it and it passed. When I pasted it all it had copied was the name of the test, not the stacktrace. 
 =||= Should be fixed now.
 =||= ,0
2091,1878,defaultIfEmpty(Observable<T> t),Went to use `defaultIfEmpty` and found it only accepts a single value .... instead of an `Observable` which means I can't pass in an `Observable.error`.

It would be very helpful to have `defaultIfEmpty(Observable<T> t)`,+1. Then `tail` in RxScala can be implemented by `o.defaultIfEmpty(Observable.error(new UnsupportedOperationException("tail of empty list"))).drop(1)`
 =||= Maybe `switchIfEmpty` would be a better name.
 =||= ,0
2237,2189,RxRingBuffer with Inline Release,Since previous tests have shown that pooling does still make a big difference, I'm trying to find a way to do pooling without the concurrency issue. I've tried with work-in-progress counters, ReadWrite locks and other variants and all of them impact performance far too much. 

This one makes different trade-offs:

It will release automatically when a ... 
- terminal event is emitted
- unsubscribe/release occurs and queue is empty
- unsubscribe/release has occurred and poll/peek occurs

This can result in a queue not being put back in the pool if an early unsubscribe occurs from a different thread and causes the poll/peek to not trigger the release. In this case GC will reclaim the pool so it still functions, it just misses the pooling optimization.

There is a commented out test of using finalize(). It works as a safety net for the edge case, but at the cost of increased GC time.

Here are performance numbers of the various tests, this one being "Inline Volatile":

```
Benchmark                                          (size)   Mode   Samples          1.x   Inline Volatile    + finalize       RW Lock          WIP
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4757888.048       5264594.520   4956256.323   5288310.755  5032942.628
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    44877.618         42845.758     39209.439     25742.696    29025.955
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       42.366            40.979        37.036        24.769       27.260
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    99981.127         99910.070     94307.080    103112.286   103176.289
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.675             4.620         4.670         4.374        4.313
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4751265.583       4706441.452   4376983.062   4739418.557  4673633.614
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   458704.984        480075.261    427165.143    483313.588   476318.407
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    42493.290         42178.254     39640.240     42728.480    42542.171
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5406448.872       5375090.752   5066264.570   5628401.294  4974892.417
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       44.528            40.990        41.106        24.974       28.212
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76898.222         72655.377     69748.305     78283.565    78987.646
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3172.653          2955.854      3064.749      1858.361     2204.948
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5157134.576       5163837.644   4846336.744   5290961.536  5139893.848
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    39961.491         39341.526     37312.117     40418.492    39163.267
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.925            35.730        33.948        35.526       35.611
```

The memory allocation amounts look good, though I don't understand the shape of the red graph at the top. That is making me question this. 

![screen shot 2014-12-22 at 9 05 06 pm](https://cloud.githubusercontent.com/assets/813492/5534740/3c346190-8a1e-11e4-8a57-5ced2954eb8c.png)

With `finalize()` (as an experiment, aware of all the reasons to not use `finalize()` from Effective Java, 2nd Edition) this is what it looks like:

![screen shot 2014-12-22 at 9 05 56 pm](https://cloud.githubusercontent.com/assets/813492/5534748/657c3140-8a1e-11e4-8459-3dd92571c0a7.png)

The GC times on this one are higher than without `finalize()`:

![screen shot 2014-12-22 at 9 06 33 pm](https://cloud.githubusercontent.com/assets/813492/5534751/6e91e86a-8a1e-11e4-9cb6-2689edc5a143.png)

compared with:

![screen shot 2014-12-22 at 9 07 10 pm](https://cloud.githubusercontent.com/assets/813492/5534754/850f38e0-8a1e-11e4-9e8a-4fc230df8013.png),@benjchristensen interesting! Btw if you want to understand the different shapes you can go there and "mark the range" so you only see allocations in that time area. You can then do it for the other area as well and maybe the difference in allocations gives you a hint when and where things are happening.

And maybe you know that anyways and I'm just trying to be helpful ;)
 =||= Thanks @daschl I'll use that to dig in. 

@akarnokd Is there any reason to not pursue this path? Are the trade-offs appropriate? And are my changes to `publish` safe? (I made them while holding my baby so not 100% confident with them yet!)
 =||= I see a few troubling points:
- read queue into a local variable first because it can turn into null between uses
- catch (NullPointerException ) really?
- publish.connect is not atomic and let's concurrent callers connect to the source multiple times
- spmc is unnecessary
- drainqueue if isComplete(o) same code on both then and else
- drainqueue WIP.set(1) I'm not convinced this doesn't end up quitting the emission loop prematurely and causing hangs due to undelivered but expected events; I have to think about it some more.
 =||= > read queue into a local variable first because it can turn into null between uses

Doing this is problematic and exactly what we need to avoid. If we retain a reference to it and continue working with it after it is released then it can be concurrently used by 2 RxRingBuffer instances because the pool will be able to hand it out to someone else. 

> publish.connect is not atomic and let's concurrent callers connect to the source multiple times

If so then it's been like that for a while and it can be fixed independent of this PR. 

> spmc is unnecessary

We need to get the SPSC queue fixed. It has had issues, hence the reason why it is still on SPMC. This has not changed. 

> drainqueue if isComplete(o) same code on both then and else

I don't understand what you're referring to. 

>  I have to think about it some more.

Please do. That code has not been changed in this PR. 

> catch (NullPointerException ) really?

See the first point above. This is a matter of trade-offs. If we ensure we don't get a NullPointerException we then end up synchronizing everything and kill the performance. We are optimizing here for the fact that almost all the time we will terminate serially, or unsubscribe serially. It is very rare we will receive a concurrent unsubscribe. In those cases we can not hold a reference to queue. An `if(queue != null)` check is insufficient to protect against this, but using a mutex, WIP, RW lock etc all pay too high a cost for an edge case like this. In the occasional time we run into it, we catch the NPE and move on. 

If there is a functional problem with it then let's look at that. If it's just a dislike for the pattern, then please propose an alternative that achieves the performance of this. 

As an aside, please do not use sarcasm in code reviews. The "really?" comment is unhelpful and condescending. I am very much aware of the ugliness of this approach. If elegance had succeeded in the many attempts we've made thus far we wouldn't still be discussing this issue. 

> Are the trade-offs appropriate

Back to the trade offs that are driving this.
- All attempts at removing the object pool have resulted in performance degradation via significant increases in object allocation and GC time. 
- The current approach to removing the object pool occasionally results in concurrency issues because concurrent emission/unsubscribe can result in 2 instances of RxRingBuffer holding a single queue.
- Use of WIP, mutex, RW lock etc make it thread-safe but at significant performance penalty in the normal happy-path
- Attempts with using WeakReference have failed so far. Every attempt I've made suggests that ReferenceQueue has non-trivial overhead and unfortunately it's the only way to get the "callback" via polling that something is released. It doesn't help much that it was written in Java 1.2 and is heavily synchronized. 
- Most use cases have serial emission/unsubscribe via terminal emission or unsubscribe on the same thread. For example, `take` will unsubscribe on the same thread serially. However, if `take` is on another thread after `observeOn` then it could be concurrent and that will be one of the edge cases we have to deal with. 

Considering all of this, what is your recommended approach that is better than the option proposed in this pull request?
 =||= I apologize for the unprofessional comment.

OperatorPublish L360: the if statement has identical sub-blocks, perhaps a break is missing?

The compiler will likely lift the member queue access into register so the queue value will be accessible during the run of the method.

A possible solution is to use a WriterReaderPhaser to mutually exclude the enqueue and unsubscribe calls:

Volatile long ingress;
Volatile long egress;
Volatile Queue queue;
Static final AtomicReferenceFieldUpdater QUEUE;

In onXXX methods:
    if (queue == NOP_QUEUE) throw ...;
    ingress++; // single reader and writer, no need for getAndIncrement
    queue.offer(value);
    egress++; // might get away with lazySet on the counters.

In unsubscribe:
    Queue q = QUEUE.getAndSet(NOP_QUEUE); // flip
    if (q == NOP_QUEUE) return; // idempotence
    while (ingress != egress) Thread.yield(); // wait for the onXXX to finish
    q.clear();
    pool.putBack(q);

This adds two uncontended volatile writes to each onNext costing few dozen cycles. I cant test this right now, but the lazy version might cost only a few cycles. I'd consider both as reasonable tradeoffs for correctness.
 =||= That's an interesting approach. I look forward to seeing that impl and perf. 

Whichever route we take for RxRingBuffer we will also need to fix the Publish issues. Should I open a separate PR to start that or have you already started on a better publish fix?=
 =||= Those issues aren't really related to RxRingBuffer in publish so it can be an independent PR.
 =||= I merged in the changes to `publish` so that it is not a factor in changes to `RxRingBuffer`. 

We can open a separate PR/issue for improving `publish`. 
 =||= This code is somehow getting non-determistic failures such as these:

```
rx.internal.operators.OperatorRetryTest > testRetryWithBackpressure FAILED
    java.lang.Exception: test timed out after 10000 milliseconds
```

```
rx.internal.operators.OnSubscribeCombineLatestTest > testWithCombineLatestIssue1717 FAILED
    java.lang.AssertionError: expected:<2000> but was:<2002>
        at org.junit.Assert.fail(Assert.java:93)
        at org.junit.Assert.failNotEquals(Assert.java:647)
        at org.junit.Assert.assertEquals(Assert.java:128)
        at org.junit.Assert.assertEquals(Assert.java:472)
        at org.junit.Assert.assertEquals(Assert.java:456)
        at rx.internal.operators.OnSubscribeCombineLatestTest.testWithCombineLatestIssue1717(OnSubscribeCombineLatestTest.java:845)
```
 =||= Quick update on the algorithm: it doesn't work in this form. The ingress counter has to convey the flip info, not the queue. 

volatile long ingress;
static final AtomicLongFieldUpdater INGRESS;
volatile long egress;
static final AtomicL ongFieldUpdater EGRESS;
final Queue queue;
// --------
long start = INGRESS.getAndIncrement();
if (start >= 0) queue.offer(value);
EGRESS.lazySet(start);
// --------
long old = INGRESS.getAndSet(Long.MIN_VALUE);
if (old < 0) return;
while (egress != old) Thread.yield();
queue.clear();
pool.putBack(queue);
 =||= I see a couple of problems in 1717:
- it doesn't seem to cleanup after the latch times out or succeeds by unsubscribing, letting the source tick until the end of the app.
- there is a race between the incrementandget and the get test; if the main thread wakes up too late, the 1ms source might call doOnNext a couple of times more and thus the count check fails.

As for the retry, Mockito's InOrder construct is O(n^2) which makes the verification slow. It is possible the test core run 200 times just runs out of time.
 =||= > A possible solution is to use a WriterReaderPhaser to mutually exclude the enqueue and unsubscribe calls

While thinking about this approach it seemed to be exactly the same as the WIP approach I tried, and after implementing and testing it, that is exactly how it behaves. It is effectively the same thing, just instead of 1 counter it has 2 that get touched in the line of emission (in the try/finally). 

To explore this further I studied the `WriterReaderPhaser` uses by Gil Tene at:
- http://stuff-gil-says.blogspot.com/2014/11/writerreaderphaser-story-about-new.html
- https://github.com/HdrHistogram/HdrHistogram/blob/HdrHistogram-2.0.3/src/main/java/org/HdrHistogram/IntervalHistogramRecorder.java

Here are the performance numbers, the phaser being the last column:

```
Benchmark                                          (size)   Mode   Samples          1.x   Inline Volatile    + finalize       RW Lock          WIP     WRPhaser
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4757888.048       5264594.520   4956256.323   5288310.755  5032942.628  5147447.030
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    44877.618         42845.758     39209.439     25742.696    29025.955    27779.876
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       42.366            40.979        37.036        24.769       27.260       27.694
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    99981.127         99910.070     94307.080    103112.286   103176.289   100516.101
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.675             4.620         4.670         4.374        4.313        4.413
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4751265.583       4706441.452   4376983.062   4739418.557  4673633.614  4510099.724
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   458704.984        480075.261    427165.143    483313.588   476318.407   462373.555
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    42493.290         42178.254     39640.240     42728.480    42542.171    41354.668
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5406448.872       5375090.752   5066264.570   5628401.294  4974892.417  4986054.668
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       44.528            40.990        41.106        24.974       28.212       27.755
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76898.222         72655.377     69748.305     78283.565    78987.646    78550.912
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3172.653          2955.854      3064.749      1858.361     2204.948     2310.804
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5157134.576       5163837.644   4846336.744   5290961.536  5139893.848  4486879.415
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    39961.491         39341.526     37312.117     40418.492    39163.267    37424.146
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.925            35.730        33.948        35.526       35.611       32.287
```
 =||= ,0
2238,2191,Observable.cache() creates indefinite number of Threads with Schedulers.io(),Hi,

It would appear to me that there's an issue with using when using Observable.cache() and Schedulers.io().  The issue is that an indefinite amount of threads are created as opposed to having thread re-use.  

This can eventually lead the following fatal scenario: "java.lang.OutOfMemoryError: Unable to create new native thread".

I did notice that when using Observable.cache() and Schedulers.from(Executors.newCachedThreadPool()) Rx is able to re-use threads.  

Other than thread-caching configuration, it's not clear to me why these 2 implementations produce wildly different thread caching results and behavior.  I can only assume that this behavior is not intended.  It would be great to hear whether that's the case.

Here's a sample program I've put together that demonstrates the 2 different results.  It's a very simple example that creates multiple observables and ensures that they are subscribed to and that result is read.  I'm using SettableFuture to mock a lag between calls.

Result with Schedulers.from(Executors.newCachedThreadPool()) (last few items displayed, notice the re-use in threads):
Thread[pool-1-thread-18,5,main]
Thread[pool-1-thread-15,5,main]
Thread[pool-1-thread-20,5,main]
Thread[pool-1-thread-7,5,main]
Thread[pool-1-thread-6,5,main]
Thread[pool-1-thread-11,5,main]
Thread[pool-1-thread-17,5,main]
Thread[pool-1-thread-4,5,main]
Thread[pool-1-thread-21,5,main]
Thread[pool-1-thread-1,5,main]
Thread[pool-1-thread-18,5,main]
Thread[pool-1-thread-10,5,main]
Thread[pool-1-thread-7,5,main]
Thread[pool-1-thread-11,5,main]
Thread[pool-1-thread-20,5,main]

Result with Schedulers.io() (last few items displayed, notice that the number is incremental, no re-use):
Thread[RxCachedThreadScheduler-187,5,main]
Thread[RxCachedThreadScheduler-196,5,main]
Thread[RxCachedThreadScheduler-189,5,main]
Thread[RxCachedThreadScheduler-198,5,main]
Thread[RxCachedThreadScheduler-191,5,main]
Thread[RxCachedThreadScheduler-200,5,main]
Thread[RxCachedThreadScheduler-193,5,main]
Thread[RxCachedThreadScheduler-195,5,main]
Thread[RxCachedThreadScheduler-197,5,main]
Thread[RxCachedThreadScheduler-199,5,main]

public class RxIndefiniateThreads {

```
static final Scheduler scheduler = Schedulers.from(Executors.newCachedThreadPool());

// static final Scheduler scheduler = Schedulers.io();
public static void main(String[] args) throws Exception {

    int i = 0;
    final AtomicInteger counter = new AtomicInteger(0);
    while (true) {
        final SettableFuture<Object> first = SettableFuture.create();
        final SettableFuture<Object> second = SettableFuture.create();
        Observable<Object> observe = Async.fromCallable(new Callable<Object>() {

            @Override
            public Object call() throws Exception {
                System.out.println(Thread.currentThread());
                return first.get();
            }

        }, scheduler).observeOn(scheduler).flatMap(new Func1<Object, Observable<Object>>() {

            @Override
            public Observable<Object> call(Object t1) {
                System.out.println(Thread.currentThread());
                try {
                    return Observable.just((Object) (t1.toString() + " :: " + second.get()));
                } catch (Exception e) {
                    throw new IllegalStateException("Mock exception for second");
                }
            }
        }).cache();

        final Future<Object> future = observe.toBlocking().toFuture();
        // Thread.sleep(2);
        i++;
        new Thread(new Runnable(){

            @Override
            public void run() {
                int count = counter.incrementAndGet();
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                first.set("done");
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                second.set("done");
                try {
                    future.get();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                // System.out.println("doneWith=" + count);
            }

        }).start();
        if (i == 100) {
            break;
        }
    }
    System.out.println("done");
}
```

}

dependencies:
<dependency>
        <groupId>com.google.guava</groupId>
        <artifactId>guava</artifactId>
        <version>18.0</version>
    </dependency>
    <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava</artifactId>
            <version>1.0.3</version>
        </dependency>
        <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava-async-util</artifactId>
            <version>0.21.0</version>
            <exclusions>
                <exclusion>
                    <groupId>io.reactivex</groupId>
                    <artifactId>rxjava</artifactId>
                </exclusion>
            </exclusions>
        </dependency>,You seem to create 100 caches and wait for it asynchronously in a tight loop and the observable elements wait on blocking gets. This delays their actions and the IO scheduler has less opportunity to reuse its pools. Schedulers.from is a weaker construct and allows thread hopping so it is more likely an idle worker can pick up more work.

@zsxwing can you check if we leak workers because of Async?
 =||= Hi @akarnokd .. I appreciate the quick response.  I can certainly agree that this example is a bit contrived.  I've been trying to reproduce an issue I found with real code in a much simpler form and this is the best I can do in short notice.  It would certainly be great to hear back on the potential leak.

Btw, in case it helps, it seems like the issue is exclusive to Schedulers.io()

For example, if I use Schedulers.computational() I get thread re-use, sample result of program (last few entries like before):
Thread[RxComputationThreadPool-7,5,main]
Thread[RxComputationThreadPool-2,5,main]
Thread[RxComputationThreadPool-1,5,main]
Thread[RxComputationThreadPool-7,5,main]
Thread[RxComputationThreadPool-5,5,main]
Thread[RxComputationThreadPool-3,5,main]
Thread[RxComputationThreadPool-1,5,main]
Thread[RxComputationThreadPool-3,5,main]
Thread[RxComputationThreadPool-1,5,main]
Thread[RxComputationThreadPool-5,5,main]
Thread[RxComputationThreadPool-7,5,main]
 =||= Schedulers.computation() uses a fixed set of worker threads in a round-robin fashion. I saw you commented out a sleep in the main loop. Could you place it after the thread.start call with 10ms to give that thread some chance?
 =||= I attempted to use the computational scheduler to test out the theory that perhaps a leak at a higher level would cause the program to block.  The program worked as expected though, and had a similar outcome to the Cached-Thread Executor Scheduler -- showing signs of obvious thread re-use.

I tried doing the sleep with the Schedulers.io() setup, but I get the same result as before -- no obvious signs of thread re-use.  I tried increasing from 10ms to 100-1000ms and still no luck.  Very similar outcome as before:
...
Thread[RxCachedThreadScheduler-189,5,main]
Thread[RxCachedThreadScheduler-192,5,main]
Thread[RxCachedThreadScheduler-191,5,main]
Thread[RxCachedThreadScheduler-194,5,main]
Thread[RxCachedThreadScheduler-193,5,main]
Thread[RxCachedThreadScheduler-196,5,main]
Thread[RxCachedThreadScheduler-195,5,main]
Thread[RxCachedThreadScheduler-198,5,main]
Thread[RxCachedThreadScheduler-197,5,main]
Thread[RxCachedThreadScheduler-200,5,main]
Thread[RxCachedThreadScheduler-199,5,main]
done
 =||= A bug in `cache`. See #2238
 =||= Hi @zsxwing , is the fix ready for testing?
 =||= @michelbetancourt sure, you can test pr #2238 by yourself. I think it will be fixed in the next release once @benjchristensen merges it.
 =||= I've been looking at this problem as well - I found it in both OnSubscribeCache and OperatorMulticast so far.  I fixed it by adding unsubscribe logic to the Subscribers.from/create factories, and using .from on the Subject in OperatorMulticast instead of the anonymous inner class (which then corrects the OnSubscribeCache case as well). 7c45286 is the right commit - the previous one was missing an import statement.
 =||= @duncani To fix `OperatorMulticast`, you can simply change the line https://github.com/ReactiveX/RxJava/blob/3cecb9037aaf11c131451fef962d749487420798/src/main/java/rx/internal/operators/OperatorMulticast.java#L146 to `source.subscribe(subscription);`

Could you also write a test and send a PR?
 =||= @zsxwing, I have confirmed that your fix addresses the original issue -- use of cache operator with Schedulers.io leaking threads.
 =||= @zsxwing, fair enough, I've submitted PR: https://github.com/ReactiveX/RxJava/pull/2455
Oh, and I don't the travis build failure is related to the PR itself
 =||= ,0
2455,2191,Observable.cache() creates indefinite number of Threads with Schedulers.io(),Hi,

It would appear to me that there's an issue with using when using Observable.cache() and Schedulers.io().  The issue is that an indefinite amount of threads are created as opposed to having thread re-use.  

This can eventually lead the following fatal scenario: "java.lang.OutOfMemoryError: Unable to create new native thread".

I did notice that when using Observable.cache() and Schedulers.from(Executors.newCachedThreadPool()) Rx is able to re-use threads.  

Other than thread-caching configuration, it's not clear to me why these 2 implementations produce wildly different thread caching results and behavior.  I can only assume that this behavior is not intended.  It would be great to hear whether that's the case.

Here's a sample program I've put together that demonstrates the 2 different results.  It's a very simple example that creates multiple observables and ensures that they are subscribed to and that result is read.  I'm using SettableFuture to mock a lag between calls.

Result with Schedulers.from(Executors.newCachedThreadPool()) (last few items displayed, notice the re-use in threads):
Thread[pool-1-thread-18,5,main]
Thread[pool-1-thread-15,5,main]
Thread[pool-1-thread-20,5,main]
Thread[pool-1-thread-7,5,main]
Thread[pool-1-thread-6,5,main]
Thread[pool-1-thread-11,5,main]
Thread[pool-1-thread-17,5,main]
Thread[pool-1-thread-4,5,main]
Thread[pool-1-thread-21,5,main]
Thread[pool-1-thread-1,5,main]
Thread[pool-1-thread-18,5,main]
Thread[pool-1-thread-10,5,main]
Thread[pool-1-thread-7,5,main]
Thread[pool-1-thread-11,5,main]
Thread[pool-1-thread-20,5,main]

Result with Schedulers.io() (last few items displayed, notice that the number is incremental, no re-use):
Thread[RxCachedThreadScheduler-187,5,main]
Thread[RxCachedThreadScheduler-196,5,main]
Thread[RxCachedThreadScheduler-189,5,main]
Thread[RxCachedThreadScheduler-198,5,main]
Thread[RxCachedThreadScheduler-191,5,main]
Thread[RxCachedThreadScheduler-200,5,main]
Thread[RxCachedThreadScheduler-193,5,main]
Thread[RxCachedThreadScheduler-195,5,main]
Thread[RxCachedThreadScheduler-197,5,main]
Thread[RxCachedThreadScheduler-199,5,main]

public class RxIndefiniateThreads {

```
static final Scheduler scheduler = Schedulers.from(Executors.newCachedThreadPool());

// static final Scheduler scheduler = Schedulers.io();
public static void main(String[] args) throws Exception {

    int i = 0;
    final AtomicInteger counter = new AtomicInteger(0);
    while (true) {
        final SettableFuture<Object> first = SettableFuture.create();
        final SettableFuture<Object> second = SettableFuture.create();
        Observable<Object> observe = Async.fromCallable(new Callable<Object>() {

            @Override
            public Object call() throws Exception {
                System.out.println(Thread.currentThread());
                return first.get();
            }

        }, scheduler).observeOn(scheduler).flatMap(new Func1<Object, Observable<Object>>() {

            @Override
            public Observable<Object> call(Object t1) {
                System.out.println(Thread.currentThread());
                try {
                    return Observable.just((Object) (t1.toString() + " :: " + second.get()));
                } catch (Exception e) {
                    throw new IllegalStateException("Mock exception for second");
                }
            }
        }).cache();

        final Future<Object> future = observe.toBlocking().toFuture();
        // Thread.sleep(2);
        i++;
        new Thread(new Runnable(){

            @Override
            public void run() {
                int count = counter.incrementAndGet();
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                first.set("done");
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                second.set("done");
                try {
                    future.get();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                // System.out.println("doneWith=" + count);
            }

        }).start();
        if (i == 100) {
            break;
        }
    }
    System.out.println("done");
}
```

}

dependencies:
<dependency>
        <groupId>com.google.guava</groupId>
        <artifactId>guava</artifactId>
        <version>18.0</version>
    </dependency>
    <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava</artifactId>
            <version>1.0.3</version>
        </dependency>
        <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava-async-util</artifactId>
            <version>0.21.0</version>
            <exclusions>
                <exclusion>
                    <groupId>io.reactivex</groupId>
                    <artifactId>rxjava</artifactId>
                </exclusion>
            </exclusions>
        </dependency>,You seem to create 100 caches and wait for it asynchronously in a tight loop and the observable elements wait on blocking gets. This delays their actions and the IO scheduler has less opportunity to reuse its pools. Schedulers.from is a weaker construct and allows thread hopping so it is more likely an idle worker can pick up more work.

@zsxwing can you check if we leak workers because of Async?
 =||= Hi @akarnokd .. I appreciate the quick response.  I can certainly agree that this example is a bit contrived.  I've been trying to reproduce an issue I found with real code in a much simpler form and this is the best I can do in short notice.  It would certainly be great to hear back on the potential leak.

Btw, in case it helps, it seems like the issue is exclusive to Schedulers.io()

For example, if I use Schedulers.computational() I get thread re-use, sample result of program (last few entries like before):
Thread[RxComputationThreadPool-7,5,main]
Thread[RxComputationThreadPool-2,5,main]
Thread[RxComputationThreadPool-1,5,main]
Thread[RxComputationThreadPool-7,5,main]
Thread[RxComputationThreadPool-5,5,main]
Thread[RxComputationThreadPool-3,5,main]
Thread[RxComputationThreadPool-1,5,main]
Thread[RxComputationThreadPool-3,5,main]
Thread[RxComputationThreadPool-1,5,main]
Thread[RxComputationThreadPool-5,5,main]
Thread[RxComputationThreadPool-7,5,main]
 =||= Schedulers.computation() uses a fixed set of worker threads in a round-robin fashion. I saw you commented out a sleep in the main loop. Could you place it after the thread.start call with 10ms to give that thread some chance?
 =||= I attempted to use the computational scheduler to test out the theory that perhaps a leak at a higher level would cause the program to block.  The program worked as expected though, and had a similar outcome to the Cached-Thread Executor Scheduler -- showing signs of obvious thread re-use.

I tried doing the sleep with the Schedulers.io() setup, but I get the same result as before -- no obvious signs of thread re-use.  I tried increasing from 10ms to 100-1000ms and still no luck.  Very similar outcome as before:
...
Thread[RxCachedThreadScheduler-189,5,main]
Thread[RxCachedThreadScheduler-192,5,main]
Thread[RxCachedThreadScheduler-191,5,main]
Thread[RxCachedThreadScheduler-194,5,main]
Thread[RxCachedThreadScheduler-193,5,main]
Thread[RxCachedThreadScheduler-196,5,main]
Thread[RxCachedThreadScheduler-195,5,main]
Thread[RxCachedThreadScheduler-198,5,main]
Thread[RxCachedThreadScheduler-197,5,main]
Thread[RxCachedThreadScheduler-200,5,main]
Thread[RxCachedThreadScheduler-199,5,main]
done
 =||= A bug in `cache`. See #2238
 =||= Hi @zsxwing , is the fix ready for testing?
 =||= @michelbetancourt sure, you can test pr #2238 by yourself. I think it will be fixed in the next release once @benjchristensen merges it.
 =||= I've been looking at this problem as well - I found it in both OnSubscribeCache and OperatorMulticast so far.  I fixed it by adding unsubscribe logic to the Subscribers.from/create factories, and using .from on the Subject in OperatorMulticast instead of the anonymous inner class (which then corrects the OnSubscribeCache case as well). 7c45286 is the right commit - the previous one was missing an import statement.
 =||= @duncani To fix `OperatorMulticast`, you can simply change the line https://github.com/ReactiveX/RxJava/blob/3cecb9037aaf11c131451fef962d749487420798/src/main/java/rx/internal/operators/OperatorMulticast.java#L146 to `source.subscribe(subscription);`

Could you also write a test and send a PR?
 =||= @zsxwing, I have confirmed that your fix addresses the original issue -- use of cache operator with Schedulers.io leaking threads.
 =||= @zsxwing, fair enough, I've submitted PR: https://github.com/ReactiveX/RxJava/pull/2455
Oh, and I don't the travis build failure is related to the PR itself
 =||= ,0
2465,1919,(Updated): timeout() operator leaking ScheduledFutureTasks on Scheduler,Hi folks,

(update, see below, looks like it's the timeout operator) 

I'm raising a ticket earlier than later, because I suspect we have a leak somewhere in the Scheduler logic. It could by in my code too, but from the characteristics it looks more like something rx internal.

I've been able to generate some OOM scenarios where GC takes all the time to clean things up and it's not able to, which pointed me to a leak. A heap dump showed the leak suspect is the ScheduledFutureTask as part of the computation scheduler:

![screen shot 2014-12-02 at 10 40 28](https://cloud.githubusercontent.com/assets/29086/5260491/b9420760-7a0f-11e4-874f-e8e9ad22a918.png)

You can see a full GC kicking in without actually making old gen smaller:

![screen shot 2014-12-02 at 10 42 50](https://cloud.githubusercontent.com/assets/29086/5260509/044a317e-7a10-11e4-8cc3-b3a17bd1d1f6.png)

The code path uses both .observeOn() once to move it onto a scheduler and also blocks .single() at the very end. So I'll start looking in those places. But maybe @akarnokd or @benjchristensen you have an idea where I can start debugging?,One thing that is suspicious is that my rx computation pools should be very silent, because I'm using observeOn my own scheduler (a spinoff of the computation one because it does not allow thread naming manually).

So while they are quiet (see threads) they have lots in their work queue.

![screen shot 2014-12-02 at 10 51 47](https://cloud.githubusercontent.com/assets/29086/5260636/5943b24e-7a11-11e4-95a5-724906cbac32.png)

![screen shot 2014-12-02 at 10 53 38](https://cloud.githubusercontent.com/assets/29086/5260654/800ab062-7a11-11e4-9e6a-c900956aa2e7.png)
 =||= @akarnokd any idea what a ScheduledAction "null" is?

![screen shot 2014-12-02 at 11 01 45](https://cloud.githubusercontent.com/assets/29086/5260757/ab261a42-7a12-11e4-8d14-8c5a64493091.png)

Looks like it's carrying a Timeout operation which makes sense to be done on the Rx one because I forgot to move it to our computation scheduler. Probably the leak is in the timeout operator?

Quick update: yup that looks like to be the cause, when I remove the timeout operator and do a manual full GC it goes back to steady, nothing leaking there.
 =||= ScheduledAction extends AtomicReference<Thread> so unless it has run already, it contains a null value. I did this for the free atomic operator(s).

In addition, there is a shortcoming in Java 6 ScheduledThreadPool where cancelled far-future tasks remain in the pool's queue until their time has actually passed, at when they get just evicted. Java 7 introduced a `setRemoveOnCancelPolicy()` method to get rid of them ASAP (defaults to false for compatibility reasons). (Historical note: in my RxJava predecessor, I had this method called reflectively when a scheduled pool was instantiated.)
 =||= @akarnokd see my last update, it seems to be in timeout() .. when I remove it, no leak.
 =||= Here is with the timeout operator removed:

![screen shot 2014-12-02 at 11 16 36](https://cloud.githubusercontent.com/assets/29086/5260941/bb104be2-7a14-11e4-82c4-ce67a6362bd6.png)
 =||= Is the use case able to be represented in a simple unit test so we can reproduce and fix?

If not then is it a high volume of timeouts (that don't trigger) causing it?
 =||= I'm trying to get it into something testable, although since I'm not familiar with the low level internals I don't know how we can prove that it is not leaking. I'll try to get something that at least shows it in a profiler when running it.

Btw note the code that triggers it is very simple: https://github.com/couchbase/couchbase-java-client/blob/master/src/main/java/com/couchbase/client/java/CouchbaseBucket.java#L288

Could it also be interplay between `timeout()` and the blocking observable conversion that is not doing something that the timeout operator expects?
 =||= Okay with something simple like

``` java
while(true) {
   Observable
        .timer(5, TimeUnit.MICROSECONDS)
        .timeout(1, TimeUnit.SECONDS)
        .toBlocking()
        .single();
}
```

Or chaining in a different scheduler before the timeout its not reproducible, no leaks there. One difference as well is that the code is observing a `AsyncSubject`, I don't know if that makes a difference in this case though.
 =||= @akarnokd  @benjchristensen Wow, actually **it is** reproducible with that code. It shows up when you increase the timeout a lot. Could it be that with the current code the task only vanishes once the timeout is over and the actual onComplete does not cancel it?

``` java
while(true) {
   Observable
        .timer(5, TimeUnit.MICROSECONDS)
        .timeout(1, TimeUnit.SECONDS)
        .toBlocking()
        .single();
}
```

![screen shot 2014-12-02 at 13 18 07](https://cloud.githubusercontent.com/assets/29086/5262415/d97f260a-7a25-11e4-96e7-45294248b8bc.png)

``` java
while(true) {
   Observable
        .timer(5, TimeUnit.MICROSECONDS)
        .timeout(100, TimeUnit.SECONDS)
        .toBlocking()
        .single();
}
```

![screen shot 2014-12-02 at 13 19 04](https://cloud.githubusercontent.com/assets/29086/5262426/e47505b6-7a25-11e4-8926-8520881c1a24.png)
 =||= We've fixed the task retention problem for JDK 6 in 1.0.5. Does the problem still happen for you?
 =||= @akarnokd oh you did? which changeset was that? :)
 =||= @daschl with #2465. I must add, it only works with `ScheduledThreadPoolExecutor` that the JDK is using because the `ScheduledExecutorService` interface doesn't have a `purge` method.
 =||= I'm closing this due to inactivity. If you have further problems, please don't hesitate to reopen this issue or post a new one.
 =||= ,0
2470,2331,Adds a isInitialised call to check if the BehaviorSubject is initialised,Since the BehaviorSubject can be created without a default value, it could be interesting to be able to know if the subject is initialised (if it holds a value).
Adding this check allows for lazy initialisation of the behavior's value.,Is there a particular use case you try to solve?
 =||= I was looking at the BehaviorSubject to represent the value of some remote objects, since it caches the last value it is perfect to act as a local cache and if a refresh is triggered any observer would get the update.

Having this check would allow to use the empty construction and trigger the remote fetch only if the subject is uninitialised (first access) .
 =||= Please check out #2470 for a set of Subject API changes that includes your is initialized check by the name hasValue.
 =||= Closing this since it is addressed in a more complete way in https://github.com/ReactiveX/RxJava/pull/2470
 =||= ,0
2470,1897,Add current value property to BehaviorSubject,Rx 2.2 added a current value property that would come in handy. See discussion here: https://rx.codeplex.com/workitem/8,Hello! A PR is welcome, but note the following:
- Unlike Rx.NET, BehaviorSubject doesn't remember the very last onNext value before an onCompleted: completed subject emits only onCompleted to subscribers.
- The last known value is a NotificationLite object which might be null indicating a BehaviorSubject without default initial value.
- What should the method be called? value(), getValue(), current(), getCurrent() ?
- How should it propagate the various states: (empty, has value, has exception, terminated)? Perhaps via Notification<T>?
- If it returns the last value directly, what exceptions should indicate empty and terminated states? NoSuchElementException?
 =||= Please check out #2470 for a set of Subject API changes that includes your current value.
 =||= Subjects have been enhanced in 1.0.5 with methods that get you their current state.
 =||= ,0
2471,1702,TrampolineScheduler NullPointerException,There is an issue in TrampolineScheduler on 0.20.4 where it can  throw a NullPointerException in InnerCurrentThreadScheduler `enqueue(Action0 action, long execTime)`

``` java
        private Subscription enqueue(Action0 action, long execTime) {
            if (innerSubscription.isUnsubscribed()) {
                return Subscriptions.empty();
            }
            PriorityQueue<TimedAction> queue = QUEUE.get();
            final TimedAction timedAction = new TimedAction(action, execTime, COUNTER_UPDATER.incrementAndGet(TrampolineScheduler.this));
            queue.add(timedAction);

            if (wip.getAndIncrement() == 0) {
                do {
                    queue.poll().action.call();
                } while (wip.decrementAndGet() > 0);
                return Subscriptions.empty();
            } else {
                // queue wasn't empty, a parent is already processing so we just add to the end of the queue
                return Subscriptions.create(new Action0() {

                    @Override
                    public void call() {
                        PriorityQueue<TimedAction> _q = QUEUE.get();
                        if (_q != null) {
                            _q.remove(timedAction);
                        }
                    }

                });
            }
        }
```

The Exception happens on `queue.poll().action.call();`.
From what I can tell, the queue is empty, and poll is returning null.

This is happening inside a nested `observable.redo().timeout().redo()` chain (the `redo().timeout()` happens earlier in the application, it isn't just one after the other like that), if that helps. I'm not in a position to create a simple replication example however.

My current theory is: One of the redos could be unsubscribing, calling `_q.remove`, while the `wip` loop is running (perhaps unsubscribe is happening on another thread?), causing the queue to become empty, and the next loop of the `wip` loop returns `null`. I think the `queue.poll()` call should check for null. ,Thanks for the report. I'll take a look.
 =||= Fixed (I hope) in #1736 
 =||= Hi. Fixed in 1.x branch via #2471. Can you verify the fix works for your case?
 =||= ,0
2475,1756,SynchronizedQueue.clone may cause ClassCastException,While cleaning up, I found a bug caused by too eager delegation:

```
    public synchronized Object clone() {
        return list.clone();
    }
```

Adding a copy constructor and using that in clone should solve the problem. I'd do it but would conflict with the cleanup changes in the class.,nan,0
2476,2290,window time+size emits only 1 window,This code only emits 1 window. 

``` java
        Observable.range(0, 10000).window(1, TimeUnit.SECONDS, 20).flatMap(o -> {
            System.out.println("window");
           return o.count(); 
        }).toBlocking().forEach(System.out::println);
```

There are 2 issues I have with it:

1) Why are there 21 instead of 20 elements in it?
2) Why does this only emit 1 window? Why does this not just behave like `window(20)` since the time never triggers?,It has an off-by-one error on L211 and the clear() in L212 clears the consumer and thus not emitting anything further unless the timer fires. This seems to be an odd behavior but conforms the javadoc spec.
 =||= Pretty sure the Javadoc is just documenting how it was implemented. This can't be right as what is the point of the max count if it still waits for the time to fire? The only thing it can then do is drop data. 

cc @headinthebox
 =||= Yes one could use take() on a timed window to achieve the same effect. The buffer() operator does an _or_ between the size and time conditions. I can't remember why I implemented window() this way after implementing buffer() the other way. The fix is simple:

``` java
void emitValue(T t) {
    State<T> s = state;
    if (s.consumer == null) {
        replaceSubject();
        s = state;
    }
    s.consumer.onNext(t);
    if (s.count == size - 1) {
        s.consumer.onCompleted();
        s = s.clear();
    } else {
        s = s.next();
    }
    state = s;
}
```
 =||= Fixed.
 =||= ,0
2482,2480,Non deterministic test: OperatorMergeTest.testBackpressureUpstream2,`OperatorMergeTest.testBackpressureUpstream2` fails 2 out of 3 times when running the whole suite in Eclipse on an old 2 core laptop. The test passes every time if run singly. 

See also discussion about test isolation #1624,I usually put a loop around such test methods and get the failure consistently. I'll investigate `OperatorMergeTest.testBackpressureUpstream2`.

Edit: it is most likely the RxRingBuffer reuse bug. If I put in a 10ms sleep between iterations, a 1000 tests pass.

Edit 2: Not related to RxRingBuffer. It seems if `just(-99)` gets in first, the test passes, otherwise, after merging 256 from the first source, merge doesn't resume with `just(-99)`.
 =||= Could you verify #2482 does work for you?
 =||= I'm closing this due to inactivity. If you have further problems, please don't hesitate to reopen this issue or post a new one.
 =||= ,0
2482,2466,Out of requests in merge,Below test, when run, quickly goes out of requests, merge operator is quite complex and it is difficult to say what exactly causes the problem but it looks like race condition, because each run gives different results.

This may be related to #1941 but scenario is different.

``` java
    private final class OnSubscribeImpl implements OnSubscribe<String> {
        private final int id;
        private final Semaphore requested = new Semaphore(0); // back pressure control

        public OnSubscribeImpl(int id) {
            this.id = id;
        }

        @Override
        public void call(Subscriber<? super String> s) {
            s.setProducer(new Producer() {
                @Override
                public void request(long n) {
                    System.out.println(id + " - REQUESTED: " + n);
                    requested.release((int) n);
                }
            });

            try {
                long counter = 0;
                while (true) {
                    requested.acquire();
                    System.out.println(id + " - REMAININIG: " + requested.availablePermits());

                    s.onNext(id + " - " + (counter++));
                }
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }

    @Test
    public void testX() throws InterruptedException {

        Observable<String> obs0 = Observable.create(new OnSubscribeImpl(0)).subscribeOn(Schedulers.io());
        Observable<String> obs1 = Observable.create(new OnSubscribeImpl(1)).subscribeOn(Schedulers.io());

        Observable.merge(obs0, obs1).observeOn(Schedulers.computation()).forEach(s -> System.out.println(s));

        Thread.sleep(Long.MAX_VALUE);
    }
```,This will require some time to dig into.
 =||= Thanks,

I found a workaround for this, which solves the problem for low and medium load.
- remove backpressure control from producer
- add onBackpressureBlock() after subscribeOn()

``` java
    private final class OnSubscribeImpl implements OnSubscribe<String> {
        private final int id;

        public OnSubscribeImpl(int id) {
            this.id = id;
        }

        @Override
        public void call(Subscriber<? super String> s) {
            try {
                long counter = 0;
                while (true) {
                    s.onNext(id + " - " + (counter++));
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }

    @Test
    public void testX() throws InterruptedException {

        Observable<?> obs0 = Observable.create(new OnSubscribeImpl(0)).subscribeOn(Schedulers.io())
                .onBackpressureBlock();
        Observable<?> obs1 = Observable.create(new OnSubscribeImpl(1)).subscribeOn(Schedulers.io())
                .onBackpressureBlock();

        Observable.merge(obs0, obs1).observeOn(Schedulers.computation()).forEach(s -> System.out.println(s));

        Thread.sleep(Long.MAX_VALUE);
    }
```

but still under heavy load when consumers are slow I see increasing number of events buffered somewhere inside merge() and/or onBackpressureBuffer() - I will expect buffering around hundreds of messages (ring buffers) but I observe tens of thousands of messages being buffered  - but this is just a quick observation and I need to dig more to understand where the events are buffered.
 =||= Hi, I'm looking at this issue right now (great test btw, fails all the time as required by debugging :).
 =||= It seems some downstream requests don't get executed on the SubscribeOn's worker because the same worker is blocked on an acquire. onBackpressureBlock works because it disregards the upstream's backpressure capability. So blocking and backpressure awareness doesn't work well on the same subscribeOn worker.
 =||= I'believe downstream request must be pushed from consuming thread(s) when buffers slots become available. SubscribeOn thread must block to slow down producer ?
 =||= SubscribeOn schedules a request onto the same thread as the emission took place. The reason is to be consistent with pre-backpressure behavior where all of the values would be emitted from this single thread.
 =||= Thanks, that explains the problem - quick test shows that as you pointed, the same thread is scheduled for request.

But, I do not see elegant workaround/solution for this yet...
    - e.g. when to release subscribeOn thread having the guarantee that request will be called from downstream (when requests == 0?)
 =||= The whole backpressure logic is based on continuations so you don't need to block/unblock a thread (and avoid a same-pool deadlock). You could rewriter your Observable with the help of AbstractOnSubscribe which takes care of the backpressure or use onBackpressureBlock.
 =||= Thanks, that works well:

``` java
    Observable<String> create(int id, long limit) {
        AtomicLong counter = new AtomicLong();
        return AbstractOnSubscribe.<String, Void> create(s -> {
            if (counter.get() < limit) {
                s.onNext(id + " - " + counter.incrementAndGet());
            } else {
                s.onCompleted();
            }
        }).toObservable();
    }

    @Test
    public void testX() throws InterruptedException {
        Semaphore end = new Semaphore(0);

        Observable<String> obs0 = create(0, 100000).subscribeOn(Schedulers.io());
        Observable<String> obs1 = create(1, 100000).subscribeOn(Schedulers.io());

        Observable.merge(obs0, obs1).observeOn(Schedulers.computation())
                .subscribe(System.out::println, System.out::println, () -> end.release());

        end.acquire();
    }
```
 =||= ,0
2482,1941,OperatorMerge does not request enough,Merging of async sources using the backpressure path can result in a stalled stream because not enough items are requested of the InnerSubscribers.

The test below fails 6 out of 10 runs.

The situation is this:

Given a merge of two slowish (1/ms) asynchronous sources that downstream has a take(N) where N >256, then 6 out 10 runs `OperatorMerge` requests 128 (`RxRingBuffer.SIZE`) emissions from each source but the operator fails to request more than 256 and the stream stalls.

``` java
        @Test
    public void testMergeKeepsRequesting() throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(1);
        Observable.range(1, 2)
        // produce many integers per second
                .flatMap(new Func1<Integer, Observable<Integer>>() {
                    @Override
                    public Observable<Integer> call(final Integer number) {
                        return Observable.range(1, Integer.MAX_VALUE)
                        // pause a bit
                                .doOnNext(pauseForMs(1))
                                // buffer on backpressure
                                .onBackpressureBuffer()
                                // do in parallel
                                .subscribeOn(Schedulers.computation());
                    }

                })
                // take a number bigger than 2* RxRingBuffer.SIZE (used by
                // OperatorMerge)
                .take(RxRingBuffer.SIZE * 2 + 1)
                // log count
                .doOnNext(printCount())
                // release latch
                .doOnCompleted(new Action0() {
                    @Override
                    public void call() {
                        latch.countDown();
                    }
                }).subscribe();
        assertTrue(latch.await(1, TimeUnit.SECONDS));
    }

        private static Action1<Integer> printCount() {
        return new Action1<Integer>() {
            long count;

            @Override
            public void call(Integer t1) {
                count++;
                System.out.println("count=" + count);
            }
        };
    }

    private static Action1<Integer> pauseForMs(final long time) {
        return new Action1<Integer>() {
            @Override
            public void call(Integer s) {
                try {
                    Thread.sleep(time);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        };
    }

```,updated example with a couple of missing static methods
 =||= I chucked the PR because I hadn't understood the merge code enough. 

What is interesting in the test above is that if you take the `pauseForMs(1)` out I don't get failures and if I synchronize the pause then I also don't get failures.  This suggests to me that it's a problem that presents itself when items are queued due to concurrent emission to OperatorMerge in combination with items that are emitted to OperatorMerge non-concurrently. It looks like DRAIN_ACTION does not request enough in those circumstances.
 =||= This merge problem is a problem for me at the moment as I encounter it 19 out of 20 times when concurrently reading and processing large text files concurrently. The timings seem to hit the merge problem spot nearly every time so I'm forced to use concatMap instead of flatMap and endure much longer run times until this problem gets sorted.
 =||= I'm hitting this bug too, flatMap is requesting 128 items and never requesting the rest.
 =||= @davidmoten We're temporarily working around it by setting a high value for the rx.ring-buffer.size system property - you may be able to do that and continue using flatMap.
 =||= What version did this bug start happening for you?
 =||= I just tried this while going back in time on version and this has been failing since at least 0.20 so has been a bug for a long time. 

Digging into it ... 
 =||= @benjchristensen 1.0.2, but haven't been doing this sort of task for three months (and probably was using a pre-backpressure release at the time for the task when it was working) so unfortunately didn't give the release candidates a workout.

@myinsiders I bumped up rx.ring-buffer.size to 131072 and I notice that I stall when I hit >numProcessors\* ringBufferSize items merged (I flatmap over `Schedulers.computation()`). As I read and merge hundreds of millions of items the workaround won't fly but thanks for the suggestion.
 =||= I think I found the issue. It's going to require some thought to figure out a solution that doesn't kill performance but I'm working on it. 

Surprising this bug wasn't found sometime in the past couple months as this has existed since 0.20.0.
 =||= Delighted you're making progress. I just discovered another of our applications was eating up our container heap because it used onBackpressureBuffer for a slowish stream (100msgs/second) and the merge had stalled.  
 =||= I thought I had it fixed but further stress testing still reveals it ... just less often. It's not going to get fixed tonight as there is something going on that I'm not yet understanding. 
 =||= @myinsiders are you by chance also using `onBackpressureBuffer()` in your code?
 =||= If I comment out `.onBackpressureBuffer()` I can not replicate the test failure, even if I put the test in a loop and let it run for several minutes. This could explain why my "fixes" to `merge` made it less likely to happen by changing the timing of whatever is happening but didn't actually fix it. I'm looking now at `.onBackpressureBuffer()` to see what is wrong there. 

Of course ... absence of a failure is not helpful in concurrency bugs so I'm not certain about anything yet. 

@myinsiders This is the reason for my previous question. If you are experiencing this without the use of any `onBackpressure*` operators then that means there is something else at fault. 
 =||= We are using onBackpressureBuffer, but I also tried implementing backpressure myself (as otherwise we'd get the odd exception that our Observable didn't support backpressure), and in the breaking cases the producer I created would get a single request for 128 items and no further requests.
 =||= (however in the case where we didn't have onBackPressureBuffer and we didn't have a producer, we didn't get these particular symptoms)
 =||= > in the breaking cases the producer I created would get a single request for 128 items and no further requests.

Do you have a unit test for this showing what operators were composed together that caused it when you weren't using `onBackpressureBuffer`?
 =||= To me, the while loop inside the pollQueue looks suspicious. My code in the backpressure-supporting [ReplaySubject seems to be working](https://github.com/akarnokd/RxJava/blob/SubjectBackpressure/src/main/java/rx/subjects/ReplaySubject.java#L399) there.
 =||= Thanks @akarnokd for the tip. I'll try porting that impl to `onBackpressureBuffer` instead of trying to fix what's there. 
 =||= Well ... it won't be a port as looking at the code shows it's solving something different, so I'll seek inspiration from it :-)
 =||= Not a problem, I just found a bug in it. It has to re-read n after the while loop inside the sinchronized block because it is possible 1 is requested just after the loop but just before entering the sync block. Correctly:

``` java
synchronized (observer) {
    boolean atEnd = idx == index;
    n = observer.requested();
    if (n == 0 || atEnd) {
        observer.index(idx);
        runFinal = false;
        observer.emitting = false;
        break;
    }
}
```

But perhaps [OnBackpressureBlock.drain()](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java#L96) does a better job.

Edit: no it doesn't. It has a similar race condition.

The correct behavior would be from L138:

``` java
// decrement and get
requestedCount -= emitted;
n = requestedCount;
// if either run out of requests or no new data arrived since last poll, quit
if (n == 0 || queue.peek() == null) {
     skipFinal = true;
     emitting = false;
     return;
}
```

`requestedCount` can't change while we are in this synchronized block. If a queue.put succeeded just after the null test, we will quit anyway and since put is followed by drain call, that drain call is blocked out until our sync-block quits as well. Then that drain may enter, find the emitting false and resume emitting.
 =||= I tried replacing the `onBackpressureBuffer()` with a simplified less performant etc version via `.lift(new OnBackpressureBuffer2())` and test still fails.

Another bit of trivia is that if in L653 in OperatorMerge.java I replace 

``` java
if (emitted > THRESHOLD) 
```

with 

``` java
if (emitted > 0)
```

then test passes. So my uneducated guesses are suggesting the problem is in  `OperatorMerge`.

``` java
package rx.internal.operators;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable.Operator;
import rx.Producer;
import rx.Subscriber;

public class OperatorOnBackpressureBuffer2<T> implements Operator<T, T> {

    private final NotificationLite<T> on = NotificationLite.instance();

    @Override
    public Subscriber<? super T> call(final Subscriber<? super T> child) {
        final ConcurrentLinkedQueue<Object> queue = new ConcurrentLinkedQueue<Object>();
        final AtomicLong requested = new AtomicLong();

        child.setProducer(new Producer() {

            @Override
            public void request(long n) {
                if (requested.getAndAdd(n) == 0) {
                    pollQueue(requested, queue, child);
                }
            }

        });
        // don't pass through subscriber as we are async and doing queue
        // draining
        // a parent being unsubscribed should not affect the children
        Subscriber<T> parent = new Subscriber<T>() {
            @Override
            public void onStart() {
                request(Long.MAX_VALUE);
            }

            @Override
            public void onCompleted() {
                queue.offer(on.completed());
                pollQueue(requested, queue, child);
            }

            @Override
            public void onError(Throwable e) {
                queue.offer(on.error(e));
                pollQueue(requested, queue, child);
            }

            @Override
            public void onNext(T t) {
                queue.offer(on.next(t));
                pollQueue(requested, queue, child);
            }

        };

        // if child unsubscribes it should unsubscribe the parent, but not the
        // other way around
        child.add(parent);

        return parent;
    }

    private synchronized void pollQueue(AtomicLong requested, ConcurrentLinkedQueue<Object> queue,
            Subscriber<? super T> child) {
        if (requested.get() > 0) {
            while (true) {
                Object o = queue.poll();
                if (o != null) {
                    if (!on.isCompleted(o) && !on.isError(o)) {
                        requested.decrementAndGet();
                        on.accept(child, o);
                    } else {
                        queue.clear();
                        on.accept(child, o);
                        return;
                    }
                } else
                    return;
            }
        }
    }

}
```
 =||= Thanks for your research and help on this!

> if (emitted > THRESHOLD) 

That's the part of code I too have been playing with. I'm trying to convince myself that it actually fixes it and understand why. 

I have re-written the batching 3 different ways in increasingly simpler and slower approaches, and even in implementations I think are indeed thread-safe, I still see the issue (but less often). I don't yet understand what it is about the batching that causes the problem. 

I'm close to admitting defeat for right now and releasing 1.0.3 without the batching and accepting the performance hit to achieve correctness. 

What do you think we should do? Do you have any ideas on how to fix the batching?
 =||= By the way, both your implementation and that of @akarnokd for `onBackpressureBuffer` doesn't fix this issue so I agree that's not the problem and that it is indeed `merge`.
 =||= Well, if you release without batching I did a test and it's the same speed roughly as `concatMap`, zero benefit of multiple processors if anyone tries to do stuff in parallel. Correctness is better to have though so probably a good idea to release 1.0.3 as you're suggesting. Perhaps those smart cookies @akarnokd  and @zsxwing might spot something while you sleep on it. Haven't seen anything stymie you guys for long.

I'll see if I can come up with some more trivia to add to our knowledge over the weekend (kids permitting).
 =||= I'd be interested to know what techniques people are using to debug these concurrency issues (beyond studying the code). My tool of choice is `System.out.println` (and studying the code) and I wonder if anyone has had a win with something more sophisticated (and less tedious).
 =||= #1961 is a pull request that removes request batching. It seems to make the test case work correctly. I tested it in a loop of thousands of invocations and couldn't get it to fail.

It does have a performance hit as shown on the pull request but I agree we need to fix the correctness and then continue working on the performance. 

> Perhaps those smart cookies @akarnokd and @zsxwing might spot something while you sleep on it. 

I sure hope so! :-) It's pretty awesome how collaboration on this project makes it so much better than any one person.

> I'd be interested to know what techniques people are using to debug these concurrency issues 

I still use `println` a lot, but on this particular issue I found that some places I'd put a `println` would actually make the issue go away, so I had to instead do "async logging" by putting messages in a queue and only printing them out if the issue happened. You can see that code in the modified unit test of the pull request. 

I've also been exploring the RxJavaDebug hooks that @abersnaze is continuing to mature. We still need some work on that though as a single failed test run of this generated 20MB of output :-) That made it difficult to find anything of value. 

On this particular issue with the async debugging approach I was able to see when requests were being made from merge on successful runs and not being made on failed runs. I added the `doOnRequest` operator to enable that. 

> anyone has had a win with something more sophisticated

This is still an area we need to improve, but concurrency is still hard and that isn't going away :-)

I'm hopeful on what RxJavaDebug will eventually be able to do for us once we we take the raw output and visualize or summarize it. 
 =||= I have chosen to move forward with #1961 and remove the batching so we get correctness at the cost of some performance in certain use cases. We can continue pursuing more performant solutions in future releases, but we need to fix the correctness and I don't deem the performance hit significant enough to hold off the fix. 
 =||= @davidmoten @myinsiders Can each of you try building a jar from the master branch and running it in your application to determine if we have indeed fixed this issue? If you can do it today that would be ideal as I would like to release 1.0.3 today or tomorrow to get this batch of fixes released. 
 =||= Hi,

I'm already running with a custom build with the two PRs concerned for a couple of days and no issues so far ...
 =||= Ben, I can run the test tomorrow morning Tues Australian time. Will let you know.
 =||= Thanks @davidmoten and thank you @myinsiders for the confirmation. 
 =||= @benjchristensen 

Righto I've run my use case and I'm a bit concerned. I'm not getting stalls nor errors but I am getting exponentially slowing performance. Below are log lines from a run with `flatMap` over `Schedulers.computation()` vs `concatMap` also over `Schedulers.computation()` (though it would not give concurrent computation).

Let me describe the use case. Each flatmapped task is to read <120 character lines from gzipped text files with about 11 million lines in each using `StringObservable` and to map those (actually flatmap in case parsing fails) to objects. These streams are then merged and processed a little bit (some simple filtering). I have hundreds of files and because the flatmap is occuring over `Schedulers.computation()` I see six files being processed at a time. Each file should take about 2 mins to process being read from SSD.

So that's way more detail than you require no doubt but I hope that someone will knock up a test to duplicate this problem. I might be able to move my exact code to github later today with a bit of luck (I clearly don't need to make available all of my input data as the problem is visible after hundreds of thousands of lines rather than millions).

```
flatMap - exponential slowdown of emissions from the merge

2014-12-16 10:34:34.692  [RxComputationThreadPool-4] - count=200000
2014-12-16 10:34:43.779  [RxComputationThreadPool-4] - count=300000
2014-12-16 10:34:59.645  [RxComputationThreadPool-4] - count=400000
2014-12-16 10:35:11.019  [RxComputationThreadPool-4] - count=500000
2014-12-16 10:36:10.976  [RxComputationThreadPool-4] - count=600000
2014-12-16 10:40:23.606  [RxComputationThreadPool-4] - count=700000


concatMap - roughly constant emission rate
2014-12-16 10:42:08.513  [RxComputationThreadPool-1] - count=100000
2014-12-16 10:42:15.260  [RxComputationThreadPool-1] - count=200000
2014-12-16 10:42:19.817  [RxComputationThreadPool-1] - count=300000
2014-12-16 10:42:26.797  [RxComputationThreadPool-1] - count=400000
2014-12-16 10:42:31.482  [RxComputationThreadPool-1] - count=500000
2014-12-16 10:42:38.093  [RxComputationThreadPool-1] - count=600000
2014-12-16 10:42:43.359  [RxComputationThreadPool-1] - count=700000
2014-12-16 10:42:49.655  [RxComputationThreadPool-1] - count=800000
2014-12-16 10:42:55.845  [RxComputationThreadPool-1] - count=900000
```
 =||= I think I've confused the issue because the above stats though of concern to me are not properly isolated to merge. Downstream of merge is a distinct and that confuses things. 

I've run it again trimmed down and I get good performance from the merge only.

If rxjava is spinning its wheels madly at the distinct point because of the fast feed from a merge of async sources then I'll  try and make a test and report it separately.
 =||= The distinct operator will remember every event it sees so can be a major memory bloat or leak on an infinite stream. 
 =||= Since merge seems to have worked for you are you okay with me releasing 1.0.3 with current fixes?
 =||= yep, not very performant I should add but works. I read 4.36m records in 3:40 using flatmap with 6 processors tapped out and the same in 4:00 with concatmap with 1 processor.  I'm happy for 1.0.3, thanks.
 =||= > I'm happy for 1.0.3, thanks.

Great, I'm releasing what's currently in master and the other items we're working on can get into the next release. 

> not very performant

I'm wondering if the chunking of work is too granular and thus the overhead of copying between threads outweighs the benefit of parallel processing. This is a key reason why we removed the `parallel` operator which naively did round-robin across threads. Is it possible this is the performance hit you're seeing? Also I imagine it's just queueing all that work since `merge` does not limit the number of async tasks it allows so it will suck in that file as fast as it can and bloat memory horizontally while each small chunk of work is only 120 lines. 

Here are simple examples of using either `buffer` or `window` to batch:

``` java
    /**
     * If a single stream needs to be split across multiple CPUs it is generally more efficient to do it in batches.
     * 
     * The `buffer` operator can be used to batch into chunks that are then each processed on a separate thread.
     */
    private static void flatMapBufferedExampleAsync() {
        Observable.range(0, 5000).buffer(500).flatMap(i -> {
            return Observable.from(i).subscribeOn(Schedulers.computation()).map(item -> {
                // simulate computational work
                    try {
                        Thread.sleep(1);
                    } catch (Exception e) {
                    }
                    return item + " processed " + Thread.currentThread();
                });
        }).toBlocking().forEach(System.out::println);
    }

    /**
     * Or the `window` operator can be used instead of buffer to process them as a stream instead of buffered list.
     */
    private static void flatMapWindowedExampleAsync() {
        Observable.range(0, 5000).window(500).flatMap(work -> {
            return work.observeOn(Schedulers.computation()).map(item -> {
                // simulate computational work
                    try {
                        Thread.sleep(1);
                    } catch (Exception e) {
                    }
                    return item + " processed " + Thread.currentThread();
                });
        }).toBlocking().forEach(System.out::println);
    }
```

Do either of those improve things? They won't solve the backpressure requirement though as `merge` allows unbounded horizontal growth of the number of async items being merged. 
 =||= Thanks for the detailed info Ben, I'll give it a try.
 =||= Merge has been fixed in 1.0.5 so I'm closing this.
 =||= ,0
2493,1649,Need inclusive predicate variant of takeUntil/takeWhile,It has been two times I've been missing a `takeUntil(filter)` operator on observables. The last time was in cgeo while implementing a low-power mode: I want to receive location updates through an observable and stop as soon as a location arrives with a precision of 20m or less, but I want this location to be returned. Using `takeWhile(!filter)` would drop the matching item.

Of course, this can be worked around, but I was surprised not to get this operator which is the dual of `takeWhile`. Would you consider a contribution adding it?,Good question. I'd like to find out from @headinthebox what the canonical solution is to this as Haskell, various Rx flavors and others either must have or need this solution as well.

The `takeUntil(filter)` solution seems like it is a reasonable approach. My only question is about the semantics as I could interpret "until" either way (inclusive or exclusive). 
 =||= /cc @spodila who also needs a solution to this
 =||= Nice. I could use that. Thank you.
 =||= We cannot add every possible operator that people need in the library. Instead we must make sure you can achieve waht you want by composing a set of orthogonal primitive operators. In this case the solution is as follows:

``` scala
object MainScala {

  def main(args: Array[String]): Unit = {

    val xs = Observable.items(0,1,2,3,4)

    val ys = xs.takeWhile(x => x < 3)
    ys.subscribe(y => println(y)) // 0,1,2

    val zs = xs.publish[Int]((xs: Observable[Int]) => xs.takeUntil(xs.dropWhile(x => x < 3)))
    zs.subscribe(z => println(z)) // 0,1,2,3
    readLine()
  }
}
```
 =||= Maybe I am missing something...
I don't see dropWhile() in 0.20.3. Is it already being added? 
That makes it look a bit convoluted, but looks like my use case can work with it.
 =||= @headinthebox Is there a guarantee that your example will work in every case? I may be missing something, but where in the documentation is it described that the `xs.dropWhile(…)` observable will consider the respective elements of `xs` before or after `xs.takeUntil(…)` one? Isn't there a race condition here? Is it guaranteed on every scheduler?

In your example, couldn't `xs.dropWhile(x => x < 3)` emit "4" only after `xs.takeUntil(…)` have already let the "4" pass?
 =||= > I don't see dropWhile() in 0.20.3. Is it already being added?

dropWhile is here: https://github.com/ReactiveX/RxScala/blob/0.x/src/main/scala/rx/lang/scala/Observable.scala#L1981
 =||= @headinthebox Your example with RxJava 0.20.4 gives to me "0 1 2 0 1 2", not "0 1 2 0 1 2 3" as shown in your comments. Your code seems to be the strict equivalent to `takeWhile` (drop as soon as the negation of the condition is met), which does not do what is requested.

The proposed `takeUntil(_ >= 3)` would properly give "0 1 2 3".
 =||= I'm without a proper computer right now, but did you run exactly the same snippet using RxScala?
 =||= Yup, I only added the import:

``` scala
import rx.lang.scala._

object MainScala {

  def main(args: Array[String]): Unit = {

  val xs = Observable.items(0, 1, 2, 3, 4)

    val ys = xs.takeWhile(x => x < 3)
    ys.subscribe(y => println(y)) // 0,1,2

    val zs = xs.publish[Int]((xs: Observable[Int]) => xs.takeUntil(xs.dropWhile(x => x < 3)))
    zs.subscribe(z => println(z)) // 0,1,2,3
    readLine()
  }
```

build.sbt:

```
scalaVersion := "2.11.2"

libraryDependencies += "com.netflix.rxjava" % "rxjava-scala" % "0.20.4"
```

And run:

```
% sbt
[info] Set current project to x (in build file:/tmp/x/)
> run
[info] Updating {file:/tmp/x/}x...
[info] Resolving jline#jline;2.12 ...
[info] Done updating.
[info] Running MainScala 
0
1
2
0
1
2

[success] Total time: 34 s, completed Sep 16, 2014 7:41:26 PM
>
```

But from what I read, this is expected, as `takeUntil` will stop as soon as the `dropWhile` fires, while we want to keep one more element. Maybe adding a `tail` after `dropWhile` would get the right one, but then comes my former question about ordering guarantees, and the code becomes convoluted.
 =||= @headinthebox Any news on this one?
 =||= Was blocked because of broken scala build.
 =||= Yup, the `tail` is missing. There is no issue with reordering. Using `.publish` and `takeUntil` on yourself is a very common pattern that more people should use. For example you can also define `switch` that same way.

``` scala
import rx.lang.scala._

object MainScala {
  def main(args: Array[String]): Unit = {
  val xs = Observable.items(0, 1, 2, 3, 4)
  val zs = xs.publish[Int]((xs: Observable[Int]) => xs.takeUntil(xs.dropWhile(x => x < 3).tail))
  zs.subscribe(z => println(z)) // 0,1,2,3
  readLine()
}
```
 =||= Ok. But `switch` is defined nevertheless because it is _convenient_, not because it is _needed_, as do many other operators, `publishLast` comes to mind. I still think an inclusive `takeUntil` would be convenient in common situations (such as the one I described originally, which is stopping right after you get a matching value), and is quite contrived to define (especially when you are writing Java 7 code, which is the case for Android developers at this time).

I can live without it (and do at this time), but I still think RxJava would be better with those inclusive versions.
 =||= The point of Rx is to be composable. We cannot anticipate every single operator that people want to use (_). There are already *__way too many_*\* operators in the library, so the default answer is "no" until we seen a pattern appearing in a majority of code (and conversely, we should deprecate operators that can be defined in terms of other and are seldomly used).
 =||= So let's start with a count of 1 for `takeUntil` :) https://github.com/cgeo/cgeo/blob/master/main/src/cgeo/geocaching/utils/RxUtils.java#L108
 =||= One problem with using publish is it does break backpressure as it introduces multicasting. It is a fine solution for hot streams but not desirable for cold ones. 

I use it for example on a buffered denounce, but backpressure is not relevant in that case. Take operators on the other hand should be usable without breaking backpressure. 
 =||= Putting on 1.0.x as this is not a blocker for 1.0 but I want to continue considering and discussing this. Also opened #1732 related to this.
 =||= What about `takeWhileInclusive` as a name for this?

The issue is that `takeUntil(predicate)` is the same signature as `takeWhile(predicate)` and the only difference would be inclusive vs exclusive but the names are ambiguous.

@headinthebox and I are good for adding this as it is a common need, but we're struggling with naming.

The API would look like this:
- `takeUntil(Observable)`
- `takeWhile(predicate)`
- `takeWhileInclusive(predicate)`

What better names (starting with `take`) exist for this?
 =||= What about `skipAfter`, or `terminateAfter`? This (Scala syntax) does not look too strange to me:

``` scala
    observable.terminateAfter(_ > 3).subscribe(…)
```

does not look that strange to me. `terminateAfter` carries the notion that the observable will be terminated right after the matching value, while `skipAfter` would rather mean that we skip the `onNext` events and propagate the `onTerminated` and `onError`.
 =||= `takeWhileInclusive` may be confusing, because it would take the first _non-matching_ value. Being positive about the termination clause might be clearer, since it is it that we want to be inclusive.
 =||= So what are you proposing? takeUntil is also confusing.
 =||= I am proposing `terminateAfter` (see above).
 =||= `terminateAfter` is non-discoverable since almost everyone will be looking at `take`, `takeUntil` and `takeWhile` alphabetically next to each other. It is preferable to have a name starting with `take*`.

And the `skipAfter` operator implies it does not unsubscribe but just drops the values.
 =||= `takeUntilInclusive` may be less confusing than `takeWhileInclusive`, since you really want to _take_ the values _until_ a condition matches _including_ the matching value (or `takeUntilIncluding`).
 =||= There is no "exclusive" `takeUntil` ... I do agree however than "until" is the right word, not "while".

Here is usage:

``` java
[start, a, b, c, stop, d, e].takeUntilXXX(x -> x == stop)
// return [start, a, b, c, stop]
[1, 2, 3, 4, 5].takeUntilXXX(x -> x == 3)
// return [1, 2, 3]
[1, 2, 3, 4, 5].takeUntilXXX(x -> x > 3)
// return [1, 2, 3, 4]
```
 =||= Going back to the `takeUntil(predicate)` signature it could be like this:

``` java
takeUntil(Observable) // unsubscribe when observable emits
takeUntil(T -> Boolean) // unsubscribe when predicate returns true (inclusive)
takeWhile(T -> Boolean) // unsubscribe when predicate returns false (exclusive)
```

I'm concerned with the arbitrary difference of inclusive/exclusive and similarity of signatures. The "until" suffix feels like it could be either inclusive or exclusive. `takeWhile` however seems to behave as expected... drops and unsubscribes once it becomes `false`.
 =||= How about `takeWithUntil` for `takeUntilXXX`?  I'm not familiar with RxJava enough to know how much or if the inclusive sense of 'with' conflicts with its other usage here but it seems sensible enough (and short).  The reason for putting 'with' in the middle is to keep the 'until' closer to the condition.
 =||= Note that this operator is not present in any collection library I know of, hence we cannot steal an existing name. 

I guess Haskell developers would use `takeWhileAndThenOne = (\(x,y:_) -> x ++ [y]).span p` which does not work for us ;-)
 =||= I hit another use case today where I'd really like to have this. 
 =||= An experimental `takeUntil()` is now available in 1.0.5.
 =||= One way to distinguish the two versions would be `takeUntil` (forwards, then checks) versus `untilTake` (checks, the forwards). Like `do-while` and `while`.
 =||= I second the idea of needing this operator. 

I'd argue this is a basic primitive stream operation that ought not to be composed. Not including it is like Java designers arguing that you don't need a <= operator on integers because you already have < and == operators. =||= @mxklabs how urgently do you need this operator? =||= @akarnokd I need it now but can probably work around it. I just wanted to agree with the sentiment that it makes sense to have this operator. =||= @akarnokd Also, take until (from what I understand from [here](http://reactivex.io/documentation/operators/takeuntil.html)) is not exactly what's requested. It takes two observables and terminates as soon as the second observable emits an item as opposed to an observable and a condition and keep emitting upto and including the first emit where the condition holds.

(Not sure if I am looking at the right documentation, sorry) =||= ,0
2548,1956,request(0) is supposed to work?,The docs about `request` doesn't say anything requirement about `n`

``` Java
public interface Producer {

    /**
     * Request a certain maximum number of items from this Producer. This is a way of requesting backpressure.
     * To disable backpressure, pass {@code Long.MAX_VALUE} to this method.
     *
     * @param n the maximum number of items you want this Producer to produce, or {@code Long.MAX_VALUE} if you
     *          want the Producer to produce items at its own pace
     */
    public void request(long n);

}
```

``` Java
    /**
     * Request a certain maximum number of emitted items from the Observable this Subscriber is subscribed to.
     * This is a way of requesting backpressure. To disable backpressure, pass {@code Long.MAX_VALUE} to this
     * method.
     *
     * @param n the maximum number of items you want the Observable to emit to the Subscriber at this time, or
     *           {@code Long.MAX_VALUE} if you want the Observable to emit items at its own pace
     */
    protected final void request(long n) {
```

I assume `n` must be greater than 0. But I also notice I may write something like this occasionally:

```
long getTheNextRequestNumber() {
  if (...) {
       ...
       return x; // x>0
  } else {
        ...
       return 0;
   }
}

long n = getTheNextRequestNumber();
request(n);
```

So `request(0)` is fine? If not, I think it's better to document it.,`request(0)` should do nothing, be a no-op.
 =||= I concur yet some places, a request(0) may trigger a loop and decrement the request counter below zero on the exit edge or do some other sideeffects. (Search for `.getAndAdd(` in the code)
- OnSubscribeCombineLatest: will subscribe to sources and fill the internal buffers but not emit anything
- OnSubscribeRedo: will trigger a reschedule and clears the boundary indicator
- OperatorConcat: will deliver oncompleted
- OperatorGroupBy: does an atomic increment and atomic decrement
- OperatorObserveOn: does schedule a thread and may decrement request below 0 for a short amount of time
- OnBackpressureBlock: is incorrect anyway, but triggers an empty emission loop
- OnBackpressureBuffer: triggers a drain loop and may decrement request below 0 for a short time
 =||= Then it looks like we should better document that `request(0)` should do nothing, and fix these places in code so they really do nothing. 

Do we want to ignore a negative number as well (like 0), or throw an IllegalArgumentException? As a data point the Reactive Streams spec throws an IAE. 
 =||= > Do we want to ignore a negative number as well (like 0), or throw an IllegalArgumentException? As a data point the Reactive Streams spec throws an IAE.

Usually a negative number is not intentional, usually means a bug in some place. So I like IAE rather than ignoring them.
 =||= I'm okay with IAE. 
 =||= I'm using request(0) some places/tests to suppress the default behavior of requesting unlimited amount. 
Negative, I think, is rather a bug than a convenience for no-op.
 =||= ,0
2548,2545,Subscriber.request add ignore for negative requests,So that negative requests don't need to be checked by every `Operator` that supports backpressure why don't we add a check at the start of `Subscriber.request`:

``` java
protected final void request(long n) {
        // ignore zero or negative requests
        if (n <=0) return;
        Producer shouldRequest = null;
        synchronized (this) {
            if (p != null) {
                shouldRequest = p;
            } else {
                requested = n;
            }
        }
        // after releasing lock
        if (shouldRequest != null) {
            shouldRequest.request(n);
        }
    }
```

Happy to submit PR if has support.,Looks a good place to add it. Just a bit comment: Ignore zero but IAE for negative numbers, as per #1956
 =||= I did wonder about that, and makes sense. I'll make a PR.
 =||= Looks to me that n = 0 should be allowed through because it may override a default of Long.MAX_VALUE sometimes (asking an upstream producer to produce nothing as opposed to whatever a default might be). I'll make a PR with the n < 0 check only.
 =||= ,0
2550,2544,Subscriber.OnStart requests should be additive?,For a `Subscriber` without a `Producer`, calling 

``` java
@Override
public void onStart() {
    request(2);
    request(3);
}
```

does not give 5 requests but 3 only. Shouldn't this be additive? (or at least documented that it is not).,It should be additive and check for overflow. Do you want to submit a new PR or amend #2548?

Edit: However, as [your commented](https://github.com/ReactiveX/RxJava/issues/2545#issuecomment-71782178), an additive request(0) would never override a max long.
 =||= I'll submit a new PR, thanks.

Override was probably misleading. A better term would be probably be _prevents_ `requested` being set to `Long.MAX_VALUE`.  I was referring to the code below from `Subscriber` where if a `request(0)` does nothing but return (doesn't set `requested` to 0) then `requested` can end up as Long.MAX_VALUE. 

``` java
 public void setProducer(Producer producer) {
        long toRequest;
        boolean setProducer = false;
        synchronized (this) {
            toRequest = requested;
            p = producer;
            if (op != null) {
                // middle operator ... we pass thru unless a request has been made
                if (toRequest == Long.MIN_VALUE) {
                    // we pass-thru to the next producer as nothing has been requested
                    setProducer = true;
                }

            }
        }
        // do after releasing lock
        if (setProducer) {
            op.setProducer(p);
        } else {
            // we execute the request with whatever has been requested (or Long.MAX_VALUE)
            if (toRequest == Long.MIN_VALUE) {
                p.request(Long.MAX_VALUE);
            } else {
                p.request(toRequest);
            }
        }
    }
```
 =||= ,0
2553,2333,RxRingBuffer fixes and improvements,This PR contains the fixes and improvements on the RxRingBuffer and its single-consumer-single-producer queue.
- Added `SWSRPhaser` which is a variant of Gil Tene's WriterReaderPhaser that uses cheaper atomic operations because the single reader and single writer use case. Note that pre Java 8 Unsafe doesn't support atomic addAndGetLong operation. The simplified phaser costs only a single atomic increment per use.
- Updated `SpscArrayQueue` to match JCTools' current version: the queue now can be fully utilized to its capacity.
- The `RxRingBuffer` now uses two phasers: one for the offer side and one for the poll/peek side. The benefits: reduced interference between readers and writers; allows using the simplified phaser because each side is now single threaded (a shared phaser implies up to 2 threads at once).

Benchmark results:

```
Benchmark              (size)        1.x   |      this   
1SyncStreamOfN              1  3779678,748 | 3767936,028 
1SyncStreamOfN           1000    21250,675 |   18530,542 
1SyncStreamOfN        1000000       20,406 |      17,712 
NAsyncStreamsOfN            1   115390,116 |  115629,480 
NAsyncStreamsOfN         1000        2,579 |       2,546 
NSyncStreamsOf1             1  3543551,254 | 3602242,709 
NSyncStreamsOf1           100   299166,910 |  301703,721 
NSyncStreamsOf1          1000    28404,751 |   28420,833 
NSyncStreamsOfN             1  4054571,577 | 4003156,953 
NSyncStreamsOfN          1000       24,324 |      20,601 
TwoAsyncStreamsOfN          1    85846,727 |   85682,983 
TwoAsyncStreamsOfN       1000     1823,137 |    1889,458 
reamOfNthatMergesIn1        1  3724179,351 | 3725068,220 
reamOfNthatMergesIn1     1000    19051,928 |   19392,595 
reamOfNthatMergesIn1  1000000       18,265 |      18,069
```,@akarnokd is that ops/s? Why is it slower in some cases too?

edit: it seems that it's slower in most of the cases? if it is really ops/s
 =||= Yes, ops per second. These are the most noticeably slower ones:

```
1SyncStreamOfN           1000    21250,675 |   18530,542
1SyncStreamOfN        1000000       20,406 |      17,712
NSyncStreamsOfN          1000       24,324 |      20,601
```

I haven't dig into it but my guess is that the atomic increment-and-get on the peek() and poll(). Some queue users first call peek() and if it returns something, then they do a full poll(). This is 2 increments per value instead of none in 1.x. I've been thinking about the option to remove the phaser from peek() since it doesn't change any queue state. (Alternatively, the two might be merged into a `pollIf(Predicate consume)` where the callback would tell to remove the value or not.)

Edit: correction, the only place peek() is used is in zip tick, so it is one atomic increment per poll instead of 0.
 =||= @akarnokd you can click "Restart build" in Travis CI. 
 =||= @zsxwing Thanks, I never logged into Travis so did not see the button.
 =||= @akarnokd Is this the one you think is ready for merge? If so I'll do my tests with Flight Recorder to appease my concern on memory and GC behavior. 
 =||= Yes it is.
 =||= Here is the outcome of my perf testing on this:

```
 ./gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*OperatorMergePerf.*'

Benchmark                                          (size)   Mode   Samples          1.x           PR
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5052690.265  4989944.158 
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    43229.405    34265.533 --
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       41.317       30.750 --
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5   101442.051    95688.061 
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.776        4.768
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4640498.106  4525502.795
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   446840.647   448934.827
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    39857.078    39870.866
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  4837426.647  5174591.967
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       39.182       29.531 --
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76236.959    76523.262 
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3073.535     2556.523 -
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  4984161.207  4745798.100 
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    37588.942    35720.766
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       34.425       31.146
```

Flight Recorder testing against first minute of "Iteration" stage of this JMH run:

```
./gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 20 .*OperatorMergePerf.merge1SyncStreamOfN.*'
```

1.x Baseline Overview

![baseline-overview](https://cloud.githubusercontent.com/assets/813492/5863848/76eb71b8-a231-11e4-962d-b002dce1a145.png)

This PR Overview
![pr-overview](https://cloud.githubusercontent.com/assets/813492/5863854/815fd63e-a231-11e4-8f17-6dfd229a7bba.png)

1.x Baseline Allocations

![baseline-allocations](https://cloud.githubusercontent.com/assets/813492/5863852/7f45fe78-a231-11e4-93b5-882d0bd77879.png)

This PR Allocations
![pr-allocations](https://cloud.githubusercontent.com/assets/813492/5863858/892891f8-a231-11e4-95b5-a94560af462c.png)
 =||= The CPU usage appears to be higher on this PR (the average is 19 versus 17). Not sure if there are other changes in 1.x that could affect this as this PR is 17 days old. 

As per previous comments there are 3 perf tests that take a noticeable performance hit. 
 =||= I suggest that we merge the JCTools SpscArrayQueue fixes in via another PR since we want those regardless of what else we do and so comparisons across approaches are equivalent. 

I'm not yet ready to accept the performance hit this PR gives. 
 =||= Here is comparing #2189 and this PR to 1.x. I rebased both PRs onto the current 1.x branch to try and be as accurate as possible:

```
1.x == current 1.x branch
PR2333 == PR #2333 after rebasing onto 1.x
PR2189 == PR #2189 after rebasing onto 1.x

Benchmark                                          (size)   Mode   Samples          1.x        PR2189        PR2333
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4879535.663   4773501.735   4807008.476
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    43295.567     37341.214     34950.819
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       41.255        40.202        32.236
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    99885.768    101321.745     97689.264
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.846         4.715         4.973
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4684222.432   4747380.010   4751592.996
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   456736.726    468609.567    467310.110
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    40504.652     41472.463     41146.594
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  4993477.475   5268523.818   5414652.857
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       44.460        42.820        32.926
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    79546.448     76853.391     73846.697
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3138.932      3140.582      2672.720
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5248113.569   5136570.967   5225289.115
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    39001.895     39254.876     39235.506
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.039        35.282        33.375
```
 =||= ,0
2563,2560,Non-deterministic test: BackpressureTest.testFlatMapAsync,Failed 2 out of 3 times when running full suite in Eclipse on slow 2 core laptop. Passes every time when run on its own.

```
java.lang.AssertionError
    at org.junit.Assert.fail(Assert.java:92)
    at org.junit.Assert.assertTrue(Assert.java:43)
    at org.junit.Assert.assertTrue(Assert.java:54)
    at rx.BackpressureTests.testFlatMapAsync(BackpressureTests.java:185)
```,That test annoys me as well because a slight threading delay makes it fail. You could post a PR which puts an @Ignore on it.
 =||= Can do. I haven't looked at the test yet but might it benefit by starting with a `Schedulers.reset()` (revive #1769?) . I like the addition of reset() to the API for test isolation.
 =||= The problem is not the schedulers, but the non-deterministic thread stalls. On my Windows machine, a looped test fails 5% of the time. On travis, the same test fails 35% of the time. I was thinking about calling GC and sleeping for some milliseconds, but then the same issue might come back because processor C-states and threadpool spinups can still stall execution.
 =||= Interesting, I love how educational this project is. Tis for me anyway.

Erk, added @Ignore, ran the suite on slow laptop and 

```
java.lang.AssertionError: expected:<0> but was:<3>
    at org.junit.Assert.fail(Assert.java:93)
    at org.junit.Assert.failNotEquals(Assert.java:647)
    at org.junit.Assert.assertEquals(Assert.java:128)
    at org.junit.Assert.assertEquals(Assert.java:472)
    at org.junit.Assert.assertEquals(Assert.java:456)
    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:759)
```
 =||= And 

```
java.lang.Exception: test timed out after 10000 milliseconds
    at java.lang.Thread.interrupted(Thread.java:944)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedNanos(AbstractQueuedSynchronizer.java:1038)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(AbstractQueuedSynchronizer.java:1328)
    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:277)
    at rx.observers.TestSubscriber.awaitTerminalEvent(TestSubscriber.java:229)
    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressure(OperatorRetryTest.java:705)
```
 =||= For the first failure, could you check PR #2563 and see what is the exact cause of failure.
 =||= Running  PR got  these for the record. I'll try again for flatmap async failure

```
java.lang.RuntimeException: Unexpected onError events: 1
    at rx.observers.TestSubscriber.assertNoErrors(TestSubscriber.java:195)
    at rx.internal.operators.OnSubscribeCombineLatestTest.testBackpressure(OnSubscribeCombineLatestTest.java:803)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:483)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
Caused by: java.lang.IllegalArgumentException: number requested cannot be negative: -1
    at rx.Subscriber.request(Subscriber.java:100)
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceRequestableSubscriber.requestUpTo(OnSubscribeCombineLatest.java:234)
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.tick(OnSubscribeCombineLatest.java:161)
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.onNext(OnSubscribeCombineLatest.java:209)
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceRequestableSubscriber.onNext(OnSubscribeCombineLatest.java:252)
    at rx.internal.operators.OnSubscribeRange$RangeProducer.request(OnSubscribeRange.java:93)
    at rx.Subscriber.setProducer(Subscriber.java:152)
    at rx.internal.operators.OnSubscribeRange.call(OnSubscribeRange.java:39)
    at rx.internal.operators.OnSubscribeRange.call(OnSubscribeRange.java:1)
    at rx.Observable.unsafeSubscribe(Observable.java:7306)
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.request(OnSubscribeCombineLatest.java:131)
    at rx.Subscriber.setProducer(Subscriber.java:152)
    at rx.internal.operators.OnSubscribeCombineLatest.call(OnSubscribeCombineLatest.java:68)
    at rx.internal.operators.OnSubscribeCombineLatest.call(OnSubscribeCombineLatest.java:1)
    at rx.Observable$1.call(Observable.java:146)
    at rx.Observable$1.call(Observable.java:1)
    at rx.Observable.subscribe(Observable.java:7396)
    at rx.internal.operators.OnSubscribeCombineLatestTest.testBackpressure(OnSubscribeCombineLatestTest.java:800)
    ... 23 more
```

and 

```
java.lang.AssertionError
    at org.junit.Assert.fail(Assert.java:92)
    at org.junit.Assert.assertTrue(Assert.java:43)
    at org.junit.Assert.assertTrue(Assert.java:54)
    at rx.internal.operators.OperatorSerializeTest.testMultiThreadedWithNPEinMiddle(OperatorSerializeTest.java:134)
```
 =||= `testMultiThreadedWithNPEinMiddle` fails because sometimes instantiating an exception class takes longer and thus all regular events rush ahead.

```
Caused by: java.lang.IllegalArgumentException: number requested cannot be negative: -1
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceRequestableSubscriber.requestUpTo(OnSubscribeCombineLatest.java:234)
```

in `rx.internal.operators.OnSubscribeCombineLatestTest.testBackpressure` looks like a genuine backpressure bug. I'll take a look at it.
 =||= The wind has changed and after ten suite runs in Eclipse with one Eclipse restart in the middle just for fun I can't repeat the `flatMapAsync` issue (although 3 suites failed with already mentioned problems).
 =||= I managed to get `rx.internal.operators.OnSubscribeCombineLatestTest.testBackpressure` fail once per 200k runs so I can't be sure fix #2566 works. Could you verify it?
 =||= Haven't seen it fail lately
 =||= Yep, because it has been `@Ignore`d.
 =||= Closing due to age ... seems fixed.
 =||= Oh, it's ignored.
 =||= Still closing.
 =||= Okay, reopening, but put in 1.x backlog :-)
 =||= It is ignored and I don't think the test can be fixed.
 =||= ,0
2566,2560,Non-deterministic test: BackpressureTest.testFlatMapAsync,Failed 2 out of 3 times when running full suite in Eclipse on slow 2 core laptop. Passes every time when run on its own.

```
java.lang.AssertionError
    at org.junit.Assert.fail(Assert.java:92)
    at org.junit.Assert.assertTrue(Assert.java:43)
    at org.junit.Assert.assertTrue(Assert.java:54)
    at rx.BackpressureTests.testFlatMapAsync(BackpressureTests.java:185)
```,That test annoys me as well because a slight threading delay makes it fail. You could post a PR which puts an @Ignore on it.
 =||= Can do. I haven't looked at the test yet but might it benefit by starting with a `Schedulers.reset()` (revive #1769?) . I like the addition of reset() to the API for test isolation.
 =||= The problem is not the schedulers, but the non-deterministic thread stalls. On my Windows machine, a looped test fails 5% of the time. On travis, the same test fails 35% of the time. I was thinking about calling GC and sleeping for some milliseconds, but then the same issue might come back because processor C-states and threadpool spinups can still stall execution.
 =||= Interesting, I love how educational this project is. Tis for me anyway.

Erk, added @Ignore, ran the suite on slow laptop and 

```
java.lang.AssertionError: expected:<0> but was:<3>
    at org.junit.Assert.fail(Assert.java:93)
    at org.junit.Assert.failNotEquals(Assert.java:647)
    at org.junit.Assert.assertEquals(Assert.java:128)
    at org.junit.Assert.assertEquals(Assert.java:472)
    at org.junit.Assert.assertEquals(Assert.java:456)
    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:759)
```
 =||= And 

```
java.lang.Exception: test timed out after 10000 milliseconds
    at java.lang.Thread.interrupted(Thread.java:944)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedNanos(AbstractQueuedSynchronizer.java:1038)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(AbstractQueuedSynchronizer.java:1328)
    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:277)
    at rx.observers.TestSubscriber.awaitTerminalEvent(TestSubscriber.java:229)
    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressure(OperatorRetryTest.java:705)
```
 =||= For the first failure, could you check PR #2563 and see what is the exact cause of failure.
 =||= Running  PR got  these for the record. I'll try again for flatmap async failure

```
java.lang.RuntimeException: Unexpected onError events: 1
    at rx.observers.TestSubscriber.assertNoErrors(TestSubscriber.java:195)
    at rx.internal.operators.OnSubscribeCombineLatestTest.testBackpressure(OnSubscribeCombineLatestTest.java:803)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:483)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
Caused by: java.lang.IllegalArgumentException: number requested cannot be negative: -1
    at rx.Subscriber.request(Subscriber.java:100)
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceRequestableSubscriber.requestUpTo(OnSubscribeCombineLatest.java:234)
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.tick(OnSubscribeCombineLatest.java:161)
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.onNext(OnSubscribeCombineLatest.java:209)
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceRequestableSubscriber.onNext(OnSubscribeCombineLatest.java:252)
    at rx.internal.operators.OnSubscribeRange$RangeProducer.request(OnSubscribeRange.java:93)
    at rx.Subscriber.setProducer(Subscriber.java:152)
    at rx.internal.operators.OnSubscribeRange.call(OnSubscribeRange.java:39)
    at rx.internal.operators.OnSubscribeRange.call(OnSubscribeRange.java:1)
    at rx.Observable.unsafeSubscribe(Observable.java:7306)
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.request(OnSubscribeCombineLatest.java:131)
    at rx.Subscriber.setProducer(Subscriber.java:152)
    at rx.internal.operators.OnSubscribeCombineLatest.call(OnSubscribeCombineLatest.java:68)
    at rx.internal.operators.OnSubscribeCombineLatest.call(OnSubscribeCombineLatest.java:1)
    at rx.Observable$1.call(Observable.java:146)
    at rx.Observable$1.call(Observable.java:1)
    at rx.Observable.subscribe(Observable.java:7396)
    at rx.internal.operators.OnSubscribeCombineLatestTest.testBackpressure(OnSubscribeCombineLatestTest.java:800)
    ... 23 more
```

and 

```
java.lang.AssertionError
    at org.junit.Assert.fail(Assert.java:92)
    at org.junit.Assert.assertTrue(Assert.java:43)
    at org.junit.Assert.assertTrue(Assert.java:54)
    at rx.internal.operators.OperatorSerializeTest.testMultiThreadedWithNPEinMiddle(OperatorSerializeTest.java:134)
```
 =||= `testMultiThreadedWithNPEinMiddle` fails because sometimes instantiating an exception class takes longer and thus all regular events rush ahead.

```
Caused by: java.lang.IllegalArgumentException: number requested cannot be negative: -1
    at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceRequestableSubscriber.requestUpTo(OnSubscribeCombineLatest.java:234)
```

in `rx.internal.operators.OnSubscribeCombineLatestTest.testBackpressure` looks like a genuine backpressure bug. I'll take a look at it.
 =||= The wind has changed and after ten suite runs in Eclipse with one Eclipse restart in the middle just for fun I can't repeat the `flatMapAsync` issue (although 3 suites failed with already mentioned problems).
 =||= I managed to get `rx.internal.operators.OnSubscribeCombineLatestTest.testBackpressure` fail once per 200k runs so I can't be sure fix #2566 works. Could you verify it?
 =||= Haven't seen it fail lately
 =||= Yep, because it has been `@Ignore`d.
 =||= Closing due to age ... seems fixed.
 =||= Oh, it's ignored.
 =||= Still closing.
 =||= Okay, reopening, but put in 1.x backlog :-)
 =||= It is ignored and I don't think the test can be fixed.
 =||= ,0
2567,2564,onErrorResumeNext, refCount and retry,Hi, I noticed some behavior I don't fully understand.

When I run this:

``` java
Observable<String> interval =
        Observable.interval(1,TimeUnit.SECONDS)
                .doOnSubscribe(() -> System.out.println("subscribe interval"))
                .doOnUnsubscribe(() -> System.out.println("unsubscribe interval"))
                .flatMap(onClickEvent -> Observable.defer(() -> Observable.<String>error(new Exception("Some exception"))))
                .onErrorResumeNext(Observable::error)
                .publish()
                .refCount()
                .doOnSubscribe(() -> System.out.println("subscribe refCount"))
                .doOnUnsubscribe(() -> System.out.println("unsubscribe refCount"));

interval
        .doOnError(throwable -> System.out.println("subscriber 1 error: " + throwable.getMessage()))
        .retry()
        .subscribe(s -> System.out.println("subscriber 1: " + s));
```

I get:

```
subscribe refCount
subscribe interval
unsubscribe interval
subscriber 1 error: Some exception
unsubscribe refCount
subscribe refCount
subscribe interval
unsubscribe interval
subscriber 1 error: Some exception
unsubscribe refCount
...
```

The three dots indicate that it continues infinitely.
Now when I add a second subscriber:

``` java
interval
        .doOnError(throwable -> System.out.println("subscriber 2 error: " + throwable.getMessage()))
        .retry()
        .subscribe(s -> System.out.println("subscriber 2: " + s));
```

I get:

```
subscribe refCount
subscribe interval
subscribe refCount
unsubscribe interval
subscriber 1 error: Some exception
unsubscribe refCount
subscribe refCount
subscriber 2 error: Some exception
unsubscribe refCount
subscribe refCount
```

and that's it, it doesn't retry. More specifically, it unsubscribes from interval and does not resubscribe. When I remove the `onErrorResumeNext` it's working fine like this:

```
subscribe refCount
subscribe interval
subscribe refCount
subscriber 1 error: Some exception
unsubscribe refCount
subscribe refCount
subscriber 2 error: Some exception
unsubscribe refCount
subscribe refCount
subscriber 1 error: Some exception
unsubscribe refCount
subscribe refCount
subscriber 2 error: Some exception
unsubscribe refCount
subscribe refCount
...
```

Where the three dots indicate it goes on infinitely. As you notice it doesn't unsubscribe from interval. I'm using `onErrorResumeNext` to "map" the error (in this example it's a trivial mapping), maybe I shouldn't use it like this. Still, I don't understand what's going on..,Hi. This is most likely the manifestation of the publish() bug. Could you check if #2552 works for you?
 =||= Checked it, exactly the same behavior.
 =||= The problem happens because retry only retries the refCount which never unsubscribes from the upstream due to two subscribers (they both unsubscribe and resubscribe immediately thus the refCount never reaches zero). The upstream keeps sending timer events which the turn into onError events. onErrorResumeNext stops accepting events after the first error and unsubscribes from the upstream but because refCount never re-subscribes, the whole process stops.
 =||= I think I fixed the problem. Your example above works with it. Could you also check if #2567 works for you?
 =||= I think it fixes it!
I'm getting now for (the second example with two subscribers and `onErrorResumeNext`):

``` java
Observable<String> interval =
        Observable.interval(1,TimeUnit.SECONDS)
                .doOnSubscribe(() -> System.out.println("subscribe interval"))
                .doOnUnsubscribe(() -> System.out.println("unsubscribe interval"))
                .flatMap(onClickEvent -> Observable.defer(() -> Observable.<String>error(new Exception("Some exception"))))
                .onErrorResumeNext(Observable::error)
                .publish()
                .refCount()
                .doOnSubscribe(() -> System.out.println("subscribe refCount"))
                .doOnUnsubscribe(() -> System.out.println("unsubscribe refCount"));

interval
        .doOnError(throwable -> System.out.println("subscriber 1 error: " + throwable.getMessage()))
        .retry()
        .subscribe(s -> System.out.println("subscriber 1: " + s));

interval
        .doOnError(throwable -> System.out.println("subscriber 2 error: " + throwable.getMessage()))
        .retry()
        .subscribe(s -> System.out.println("subscriber 2: " + s));
```

This result:

```
subscribe refCount
subscribe interval
subscribe refCount
unsubscribe interval
subscriber 1 error: Some exception
unsubscribe refCount
subscribe refCount
subscribe interval
subscriber 2 error: Some exception
unsubscribe refCount
subscribe refCount
unsubscribe interval
subscriber 1 error: Some exception
unsubscribe refCount
subscribe refCount
subscribe interval
subscriber 2 error: Some exception
unsubscribe refCount
subscribe refCount
unsubscribe interval
...
```

Three dots say it continues infinitely. Notice that it does resubscribe to interval now.
 =||= Thanks for confirming. I'm still waiting for @davidmoten's review before merging in the fix.
 =||= No problem
 =||= The fix is available in 1.0.5. Thanks for reporting.
 =||= Great
 =||= ,0
2585,209,Implement cache operator,Returns an Observable that repeats the original Observable sequence to all subscribers.
The source Observable is subscribed to at most once.

When looking into integrating Hystrix and RxJava, the need for this operator became apparent. It appears to be of general use, so should be considered for RxJava core.,[RxJava-pull-requests #50](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/50/) FAILURE
Looks like there's a problem with this pull request
 =||= How does this relate to Publish (https://github.com/Netflix/RxJava/issues/15) and Multicast (https://github.com/Netflix/RxJava/issues/65)?
 =||= [RxJava-pull-requests #51](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/51/) SUCCESS
This pull request looks good
 =||= My understanding is that Publish and Multicast don't remember or replay events that the source Observable generated before a given subscriber subscribed. 
 =||= I think you're right. How about Replay (https://github.com/Netflix/RxJava/issues/71)?

Reading through your code submission now ...
 =||= I really like how many unit tests there are ... very nice.

I need to think through the implications of this compared with Replay/RefCount/Publish/Multicast etc. In other words, if Rx.Net doesn't have this operator for such a common case it seems that it should already be covered by one of the ones we have not yet implemented. 
 =||= Replay could be what this is, modulo Replay's connect() semantics (which I can't quite decipher from the documentation). 
 =||= That part is still somewhat confusing to me as well as I haven't yet spent the time to fully grok these operators and what it will take to implement.

Perhaps though a `cache` operator would be a good cover method for the "typical usecase" that underneath is using `replay` and takes care of connections etc ... perhaps similar to how `RefCount` does the connection/disconnect by counting subscriptions?

What I'm trying to accomplish is first achieve the functionality provided by Rx and only then add new functionality if it's not already accounted for. 

Rx.Net has years of thought into the API design and functionality and there is value in common knowledge across implementations if we can maintain the same behavior.
 =||= I can see why one would need a connect() method for Publish: one would want to be able to subscribe multiple observers to a Publish before having the Publish subscribe to its source. If the Publish subscribed to its source upon the first subscription it got, its second subscriber wouldn't get the initial set of notifications.

The connect() method makes a lot less sense for Replay, as the second and later subscribers would get the initial set of notifications either way. The only things I can think of are:
- A desire to have the initial set of notification calls interleaved across the initial set of observers. But I see nothing in the contract preventing an implementation from sending a batch of notifications to one observer before sending any of them to another.
- A roundabout way of allowing the Replay to be forcibly unsubscribed from its source. But this is not nearly as useful as a way to inform the Replay that it will have no new subscribers, allowing it to unsubscribe from its source when its last current subscriber unsubscribes.
- Some useful semantic around multiple connections. The Microsoft documentation does not specify what happens if connect() is called a second time, either with or without the first connection being disposed.
 =||= I believe cache is a wrapper around Replay that calls the Replay's connect() upon the first subscription.
 =||= Are you interested in exploring what an implementation of Replay would look like (not necessarily all of the overloads that we eventually want but whatever is necessary for this use case) and perhaps submitting that implementation to accomplish `cache` functionality while retaining our goal of complying to the Rx.Net API?
 =||= I think so. I would need to know what the behavior of a second call to connect() is supposed to be, both with and without the first call being unsubscribed.
 =||= If you can play with Rx.Net or RxJS that would be the best way to determine the correct behavior. You can also take a look at the Rx.Net source: 

ReplaySubject: https://rx.codeplex.com/SourceControl/changeset/view/1174cce8e949bfe00879c437cab7ac3ef728042b#Rx/NET/Source/System.Reactive.Linq/Reactive/Subjects/ReplaySubject.cs

RefCount: https://rx.codeplex.com/SourceControl/changeset/view/1174cce8e949bfe00879c437cab7ac3ef728042b#Rx/NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/RefCount.cs
 =||= - Connecting without previous disconnect is idempotent.
- Disconnecting is idempotent and generates no events.
- Connecting after a disconnect re-subscribes to the source.
 =||= Is this going away because of https://github.com/Netflix/RxJava/pull/218 or does this still make sense?
 =||= A variant of Replay that connects on first subscription could make sense, but might not meet the threshold for adding a new operator. In any case, it wouldn't use the commit in this request.
 =||= I think I figured out when the ConnectableObservable would come into play with Replay in a cache scenario.
- source emits 10 values
- subscriberA subscribes and receives the 10 values
- source emits 5 values (and subscriberA receives them)
- subscribeB subscribes and receives the 15 values
- subscriberA unsubscribes

Now what do we do? We can't unsubscribe from source because subscriberB still expects to receive values.
- source emits 5 new values and subscriberB receives them
- subscriberB unsubscribes

Do we unsubscribe from source now? That's how the `refcount` operator works.
- subscriberC subscribes and receives 20 values
- subscriberC unsubscribes
- source keeps emitting values that keep getting cached and it never goes away

In other words, the `cache` operator we're discussing here would ONLY work if the source sequence correctly completed at some point. If it was an infinite (or very long running) observable it would keep filling up the ReplaySubject in the background and likely become a memory leak.

Thus the ConnectableObservable is a way to unsubscribe.

I still think a `cache` operator is useful, but it can be misused easily ... but so can `toList` which has the exact same problem on an infinite sequence.
 =||= I was thinking about adding a method to the Cache operator to notify it when it gets evicted and can rely on having no additional subscribers. That way, it could unsubscribe from its source when all of the existing subscribers unsubscribed.

As gravy, it could even drop references to events that have been sent to all existing subscribers, but that's less important.
 =||= Unsubscribing once all subscribers are unsubscribed is what the `refCount` operator does and I can't see how to make that work for the use cases where `cache` is intended. 

Here is an example timeline using `cache`:
- origin starts
- onNext(1)
- A subscribes - receives (1)
- onNext(2)
- A receives (2)
- B subscribes - receives (1, 2)
- origin onCompleted - A & B receives (onCompleted)
- C subscribes - receives (1, 2, onCompleted)

Using a refCount system that unsubscribes from the origin would result in re-executing the origin which is exactly what this operator is there to prevent.

Same problem with dropping references to events that have been sent to all existing subscribers, C wouldn't receive anything in that case.

Here is the same timeline with `refCount` or something else that unsubscribes when all subscribers leave (or the origin completes which is the same):
- origin starts
- onNext(1)
- A subscribes - receives (1)
- onNext(2)
- A receives (2)
- B subscribes - receives (1, 2)
- origin onCompleted - A & B receives (onCompleted)
- C subscribes - origin is subscribed to again
- onNext(1)
- C receives (1)
- onNext(2)
- C receives (2)
- origin onCompleted - C receives (onCompleted)

Both of the use cases you suggest seem like they are exactly what `refCount` is intended for and its many overloads for max number of events to store, time windows, etc. `refCount` works great for hot-observables (infinite sequences) or very long running ones from what I can tell, but it's not very good for a sequence that emits 1 or a handful of responses and completes.

Am I misunderstanding your meaning?
 =||= A `Cache` would differ from a `refCount` in that it would stay subscribed until after it is explicitly notified by this new method that it has been evicted and there will be no more subscribers. So in your example timeline C would get (1, 2, Completed) as there was no eviction notification call.

The use case is that the creator of the Cache (e.g. Hystrix) would place the Cache Observable into some sort of data structure (e.g. HystrixRequestCache) from which the Cache Observable can gain new subscribers. When the data structure expires or otherwise evicts the Cache Observable, it would use this new method to notify the Cache Observable that it will receive no more subscribers. At that point, the Cache Observable can unsubscribe from its source when its reference count reaches zero.

This is only worth doing if subscribers are likely to unsubscribe before the sequence completes or if it is worth discarding early history while existing subscribers remain post-eviction.
 =||= I think the key line you said is this:

> This is only worth doing if subscribers are likely to unsubscribe before the sequence completes or if it is worth discarding early history while existing subscribers remain post-eviction.

Since Hystrix will always complete (onError or onCompleted) it doesn't really matter (nor is there a reliable hook to know when to cause eviction since even HystrixRequestContext is not a required thing).

Thus, it seems that an object being dereferenced and then garbage collected is sufficient for the Hystrix case, since the Observable would have terminated and have no resources to clean up.

Of note, it was my working on Hystrix to support RxJava that drove me to add `cache`.

How would your proposed changes modify the method signature of `cache` in case we want to add the behavior you're describing? Would it need to return a `CachedObservable` with the eviction hook?
 =||= > How would your proposed changes modify the method signature of cache in case we want to add the behavior you're describing? Would it need to return a CachedObservable with the eviction hook?

Pretty much. Also, the code maintaining the data structure would have to control subscriptions to the Cache so that it would be able to know when there are no more subscribers.

I had decided this embellishment probably wasn't worth doing, but it was relevant to your question about sequences that never complete.
 =||= I'm going to stick with `cache` as a simple thing without the eviction support and if needed we can evolve over time (since returning a CachedObservable instead of Observable would be a non-breaking change ... I think).

I also want to better understand how combinations of things like `replay().refCount()` may provide similar functionality to what we were discussing before inventing a new type of Observable.

Thanks for the feedback.
 =||= ,0
2589,2587,take + repeat + distinct not completing,Hi all
I'm having a hard time trying to figure this out:

``` java
Observable<AppInfo> sequence = Observable.from(apps)
                .take(3)
                .repeat(3);

        sequence.subscribe(new Observer<AppInfo>() {
            @Override
            public void onCompleted() {
                Log.d("RXJAVA1", "Completed");
            }

            @Override
            public void onError(Throwable e) {
                Log.e("RXJAVA1", "Error");
            }

            @Override
            public void onNext(AppInfo appInfo) {
                Log.d("RXJAVA1", appInfo.getName());
            }
        });

        sequence.distinct()
                .subscribe(new Observer<AppInfo>() {
                    @Override
                    public void onCompleted() {
                        Log.d("RXJAVA2", "Completed");
                    }

                    @Override
                    public void onError(Throwable e) {
                        Log.e("RXJAVA2", "Error");
                    }

                    @Override
                    public void onNext(AppInfo appInfo) {
                        Log.d("RXJAVA2", appInfo.getName());
                    }
                });
```

gives me

```
D/RXJAVA1﹕ 9GAG
D/RXJAVA1﹕ AdSense
D/RXJAVA1﹕ AirDroid
D/RXJAVA1﹕ 9GAG
D/RXJAVA1﹕ AdSense
D/RXJAVA1﹕ AirDroid
D/RXJAVA1﹕ 9GAG
D/RXJAVA1﹕ AdSense
D/RXJAVA1﹕ AirDroid
D/RXJAVA1﹕ Completed
D/RXJAVA2﹕ 9GAG
D/RXJAVA2﹕ AdSense
D/RXJAVA2﹕ AirDroid
```

and the sequence never completes. If I only repeat it twice:

``` java
Observable<AppInfo> sequence = Observable.from(apps)
                .take(3)
                .repeat(2);

        sequence.subscribe(new Observer<AppInfo>() {
            @Override
            public void onCompleted() {
                Log.d("RXJAVA1", "Completed");
            }

            @Override
            public void onError(Throwable e) {
                Log.e("RXJAVA1", "Error");
            }

            @Override
            public void onNext(AppInfo appInfo) {
                Log.d("RXJAVA1", appInfo.getName());
            }
        });

        sequence.distinct()
                .subscribe(new Observer<AppInfo>() {
                    @Override
                    public void onCompleted() {
                        Log.d("RXJAVA2", "Completed");
                    }

                    @Override
                    public void onError(Throwable e) {
                        Log.e("RXJAVA2", "Error");
                    }

                    @Override
                    public void onNext(AppInfo appInfo) {
                        Log.d("RXJAVA2", appInfo.getName());
                    }
                });
```

I get

```
D/RXJAVA1﹕ 9GAG
D/RXJAVA1﹕ AdSense
D/RXJAVA1﹕ AirDroid
D/RXJAVA1﹕ 9GAG
D/RXJAVA1﹕ AdSense
D/RXJAVA1﹕ AirDroid
D/RXJAVA1﹕ Completed
D/RXJAVA2﹕ 9GAG
D/RXJAVA2﹕ AdSense
D/RXJAVA2﹕ AirDroid
D/RXJAVA2﹕ Completed
```

and everything is fine.
I'm working on some examples and I spotted this weird scenario and it's driving me crazy. Am I missing something or there is actually something wrong with this?
Thanks,Hello. It is quite odd. The following program works for me on master:

``` java
public class Issue2587 {
    static void logD(String key, Object msg) {
        System.out.print(key);
        System.out.print(" ");
        System.out.println(msg);
    }
    public static void main(String[] args) {
        Observable<Integer> sequence = Observable.from(Arrays.asList(1, 2, 3, 4, 5))
                .take(3)
                .repeat(3);

        sequence.subscribe(new Observer<Integer>() {
            @Override
            public void onCompleted() {
                logD("RXJAVA1", "Completed");
            }

            @Override
            public void onError(Throwable e) {
                logD("RXJAVA1", "Error");
            }

            @Override
            public void onNext(Integer appInfo) {
                logD("RXJAVA1", appInfo);
            }
        });
    }
}
```

Prints:

```
RXJAVA1 1
RXJAVA1 2
RXJAVA1 3
RXJAVA1 1
RXJAVA1 2
RXJAVA1 3
RXJAVA1 1
RXJAVA1 2
RXJAVA1 3
RXJAVA1 Completed
```
 =||= Could you try to apply `distinct()` to get rid of the duplicates please?
 =||= Hmm. If I apply distinct(), I don't get the Completed message either. I'm going to investigate this.
 =||= It is a bug with repeat. I'll post the fix soon.
 =||= Could you verify #2589 works for you?
 =||= The fix is available in 1.0.5. Thanks for reporting.
 =||= Sorry for the delay due to the timezone.
I checked the `1.0.5`: everything is working fine.
Thank you for the awesome response!
 =||= ,0
2590,2588,Questions about Zip operator,I have an issue with zip operator, I have few observables which execute asynchronously. And finally I am zipping all the results from each observable. It works fine, but sometime zip operator is waiting for long time to get the value from one of the observable.

```
 List<Observable<Set<Item>>> observableList = new ArrayList<Observable<Set<Item>>>();
for (ItemProvider ep : itemList) {
          ItemStrategy strategey = (ItemStrategy) ep.strategy();
          observableList.add(strategey.determineItems(message).subscribeOn(Schedulers.io()));
      }
 }

Set<Item> items = Observable.zip(observableList, new FuncN<Set<Item>>() {
  Set<Item> returnSet = new HashSet<Item>();

  @SuppressWarnings("unchecked")
  @Override
  public Set<Item> call(Object... args) {
      for (int i = 0; i < args.length; i++) {
        Set<Item> items = (Set<Item>) args[i];
          returnSet.addAll(items);
      }
      return returnSet;
  }
}).toBlocking().singleOrDefault(Collections.<Item> emptySet());

This is the code to get the items in Strategy class
@Override
    public Observable<Set<Item>> determineItems(final ItemsMessageExchange message) {
      return Observable.create(new OnSubscribe<Set<Item>>() {

            @Override
            public void call(Subscriber<? super Set<Item>> subscriber) {
                checkPreconditions(message);
                Set<Record> records = getRecordsOfQuery(message.toRecordQuery());
                Set<Item> items = new HashSet<Item>();
                for (Record record : records) {
                    try {
                        items.addAll(record.determineItems());
                    } catch (Exception ex) {
                        subscriber.onError(ex);
                    }
                }
                subscriber.onNext(items);
                subscriber.onCompleted();
            }

        });
    }
```

Can anyone help me to fix this.,Did you measure how long the `getRecordsOfQuery` takes?
 =||= Yes, it is taking 95ms.
 =||= Does zip ever complete or just hangs?
 =||= sometimes zip completes without any issue, sometime it is hanging.
 =||= Could you test something out? Put a return after `subscriber.onError(ex);` and see if it still hangs?
 =||= Yes, I tried it still it hangs.
 =||= Found the bug and posted a fix. Could you verify if #2590 works for you?
 =||= Sure, thanks Akarnokd. I will check and let you know.
 =||= I have tried with that build, but still it hangs. 
 =||= Could you post a unit test which demonstrates the problem?
 =||= Hi Akarnokd,
I think the problem is with the determineItems method. Earlier it just returned Set<Item> but i changed to Observable<Set<Item>> ( Because I wanted to execute that in asynchronous and finally zip all the results). I just debugged using debug mode of eclipse the method getRecordsOfQuery() is gets hangs sometimes, not sure why. Most of the times it works fine. But sometimes it gets hangs there. 
Anything I did wrong in the above code?

Note : Without observable changes it works fine.  
 =||= There is nothing wrong with the code above.
 =||= When I Checked the Thread dump. One thread is waiting in Running state always . This happens after i used Scheduler.io()

``````
"RxCachedThreadScheduler-1" daemon prio=5 tid=0x00007fb1ec9bb800 nid=0xa103 runnable [0x0000000115eee000]
   java.lang.Thread.State: RUNNABLE
  at java.net.SocketInputStream.socketRead0(Native Method)
  at java.net.SocketInputStream.read(SocketInputStream.java:152)
  at java.net.SocketInputStream.read(SocketInputStream.java:122)
  at oracle.net.ns.Packet.receive(Unknown Source)
  at oracle.net.ns.DataPacket.receive(Unknown Source)
  at oracle.net.ns.NetInputStream.getNextPacket(Unknown Source)
  at oracle.net.ns.NetInputStream.read(Unknown Source)
  at oracle.net.ns.NetInputStream.read(Unknown Source)
  at oracle.net.ns.NetInputStream.read(Unknown Source)
  at oracle.jdbc.driver.T4CMAREngine.unmarshalUB1(T4CMAREngine.java:1104)
  at oracle.jdbc.driver.T4CMAREngine.unmarshalSB1(T4CMAREngine.java:1075)
  at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:480)
  at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:219)
  at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:970)
  at oracle.jdbc.driver.OraclePreparedStatement.executeBatch(OraclePreparedStatement.java:10690)
  - locked <0x00000007b13c0988> (a oracle.jdbc.driver.T4CPreparedStatement)
  - locked <0x00000007b13147b0> (a oracle.jdbc.driver.T4CConnection)
  at org.hibernate.jdbc.BatchingBatcher.doExecuteBatch(BatchingBatcher.java:70)
  at org.hibernate.jdbc.AbstractBatcher.executeBatch(AbstractBatcher.java:268)
  at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:266)
  at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:168)
  at org.hibernate.event.def.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:321)
  at org.hibernate.event.def.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:50)
  at org.hibernate.impl.SessionImpl.flush(SessionImpl.java:1027)
  at org.hibernate.impl.SessionImpl.managedFlush(SessionImpl.java:365)
  at org.hibernate.transaction.JDBCTransaction.commit(JDBCTransaction.java:137)
  at org.springframework.orm.hibernate3.HibernateTransactionManager.doCommit(HibernateTransactionManager.java:657)
  at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:755)
  at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:724)
  at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:387)
  at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:120)
  at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
  at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
  at com.sun.proxy.$Proxy114.entitlementRecordsOfQuery(Unknown Source)
  at com.umapranesh.service.DefaultEntitlementStrategy.getRecordsOfQuery(DefaultEntitlementStrategy.java:153)
  at com.umapranesh.service.DefaultEntitlementStrategy$1.call(DefaultEntitlementStrategy.java:71)
  at com.umapranesh.service.DefaultEntitlementStrategy$1.call(DefaultEntitlementStrategy.java:1)
  at rx.Observable.unsafeSubscribe(Observable.java:7326)
  at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
  at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:47)
  at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)
  at java.util.concurrent.FutureTask.run(FutureTask.java:262)
  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)
  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)
  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
  at java.lang.Thread.run(Thread.java:745)```
``````
 =||= ,0
2593,2588,Questions about Zip operator,I have an issue with zip operator, I have few observables which execute asynchronously. And finally I am zipping all the results from each observable. It works fine, but sometime zip operator is waiting for long time to get the value from one of the observable.

```
 List<Observable<Set<Item>>> observableList = new ArrayList<Observable<Set<Item>>>();
for (ItemProvider ep : itemList) {
          ItemStrategy strategey = (ItemStrategy) ep.strategy();
          observableList.add(strategey.determineItems(message).subscribeOn(Schedulers.io()));
      }
 }

Set<Item> items = Observable.zip(observableList, new FuncN<Set<Item>>() {
  Set<Item> returnSet = new HashSet<Item>();

  @SuppressWarnings("unchecked")
  @Override
  public Set<Item> call(Object... args) {
      for (int i = 0; i < args.length; i++) {
        Set<Item> items = (Set<Item>) args[i];
          returnSet.addAll(items);
      }
      return returnSet;
  }
}).toBlocking().singleOrDefault(Collections.<Item> emptySet());

This is the code to get the items in Strategy class
@Override
    public Observable<Set<Item>> determineItems(final ItemsMessageExchange message) {
      return Observable.create(new OnSubscribe<Set<Item>>() {

            @Override
            public void call(Subscriber<? super Set<Item>> subscriber) {
                checkPreconditions(message);
                Set<Record> records = getRecordsOfQuery(message.toRecordQuery());
                Set<Item> items = new HashSet<Item>();
                for (Record record : records) {
                    try {
                        items.addAll(record.determineItems());
                    } catch (Exception ex) {
                        subscriber.onError(ex);
                    }
                }
                subscriber.onNext(items);
                subscriber.onCompleted();
            }

        });
    }
```

Can anyone help me to fix this.,Did you measure how long the `getRecordsOfQuery` takes?
 =||= Yes, it is taking 95ms.
 =||= Does zip ever complete or just hangs?
 =||= sometimes zip completes without any issue, sometime it is hanging.
 =||= Could you test something out? Put a return after `subscriber.onError(ex);` and see if it still hangs?
 =||= Yes, I tried it still it hangs.
 =||= Found the bug and posted a fix. Could you verify if #2590 works for you?
 =||= Sure, thanks Akarnokd. I will check and let you know.
 =||= I have tried with that build, but still it hangs. 
 =||= Could you post a unit test which demonstrates the problem?
 =||= Hi Akarnokd,
I think the problem is with the determineItems method. Earlier it just returned Set<Item> but i changed to Observable<Set<Item>> ( Because I wanted to execute that in asynchronous and finally zip all the results). I just debugged using debug mode of eclipse the method getRecordsOfQuery() is gets hangs sometimes, not sure why. Most of the times it works fine. But sometimes it gets hangs there. 
Anything I did wrong in the above code?

Note : Without observable changes it works fine.  
 =||= There is nothing wrong with the code above.
 =||= When I Checked the Thread dump. One thread is waiting in Running state always . This happens after i used Scheduler.io()

``````
"RxCachedThreadScheduler-1" daemon prio=5 tid=0x00007fb1ec9bb800 nid=0xa103 runnable [0x0000000115eee000]
   java.lang.Thread.State: RUNNABLE
  at java.net.SocketInputStream.socketRead0(Native Method)
  at java.net.SocketInputStream.read(SocketInputStream.java:152)
  at java.net.SocketInputStream.read(SocketInputStream.java:122)
  at oracle.net.ns.Packet.receive(Unknown Source)
  at oracle.net.ns.DataPacket.receive(Unknown Source)
  at oracle.net.ns.NetInputStream.getNextPacket(Unknown Source)
  at oracle.net.ns.NetInputStream.read(Unknown Source)
  at oracle.net.ns.NetInputStream.read(Unknown Source)
  at oracle.net.ns.NetInputStream.read(Unknown Source)
  at oracle.jdbc.driver.T4CMAREngine.unmarshalUB1(T4CMAREngine.java:1104)
  at oracle.jdbc.driver.T4CMAREngine.unmarshalSB1(T4CMAREngine.java:1075)
  at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:480)
  at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:219)
  at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:970)
  at oracle.jdbc.driver.OraclePreparedStatement.executeBatch(OraclePreparedStatement.java:10690)
  - locked <0x00000007b13c0988> (a oracle.jdbc.driver.T4CPreparedStatement)
  - locked <0x00000007b13147b0> (a oracle.jdbc.driver.T4CConnection)
  at org.hibernate.jdbc.BatchingBatcher.doExecuteBatch(BatchingBatcher.java:70)
  at org.hibernate.jdbc.AbstractBatcher.executeBatch(AbstractBatcher.java:268)
  at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:266)
  at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:168)
  at org.hibernate.event.def.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:321)
  at org.hibernate.event.def.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:50)
  at org.hibernate.impl.SessionImpl.flush(SessionImpl.java:1027)
  at org.hibernate.impl.SessionImpl.managedFlush(SessionImpl.java:365)
  at org.hibernate.transaction.JDBCTransaction.commit(JDBCTransaction.java:137)
  at org.springframework.orm.hibernate3.HibernateTransactionManager.doCommit(HibernateTransactionManager.java:657)
  at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:755)
  at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:724)
  at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:387)
  at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:120)
  at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
  at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
  at com.sun.proxy.$Proxy114.entitlementRecordsOfQuery(Unknown Source)
  at com.umapranesh.service.DefaultEntitlementStrategy.getRecordsOfQuery(DefaultEntitlementStrategy.java:153)
  at com.umapranesh.service.DefaultEntitlementStrategy$1.call(DefaultEntitlementStrategy.java:71)
  at com.umapranesh.service.DefaultEntitlementStrategy$1.call(DefaultEntitlementStrategy.java:1)
  at rx.Observable.unsafeSubscribe(Observable.java:7326)
  at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
  at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:47)
  at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)
  at java.util.concurrent.FutureTask.run(FutureTask.java:262)
  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)
  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)
  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
  at java.lang.Thread.run(Thread.java:745)```
``````
 =||= ,0
2622,1653,Optimisations with Observable.empty(),I notice that calling `observable.concat(Observable.empty())` invokes back-pressure. I'd find it useful if when I used `Observable.empty()` that optimisations came into play such as ensuring that `observable.concat(Observable.empty())` simply returned `observable`.

To achieve this I'd make a private constant `EMPTY = from(new ArrayList())`  in `Observable` so that calling `Observable.empty()` always returned this object cast into the appropriate generic type. Then I'd use a simple object reference equality test to determine if an optimisation could be made.

Do you think this proposal has legs? If so, I'll knock up a PR. I would seek to optimise more than just the `concat` operator , it would include `merge` and possibly others which I can think about if the time comes.,In this vein might be good to get `from(List)` return EMPTY whenever the list is empty. That would enable the optimisations more often.
 =||= This is inaccurate "I notice that calling observable.concat(Observable.empty()) invokes back-pressure". It was actually a combination of operators including concat. Regardless I think the optimisations would be useful.
 =||= I stumbled upon your report while also looking at `Observable.empty()`. I wonder why it instantiates a new `ArrayList` every single time instead of using `Collections.emptyList()`? It's the canonical way to represent the list "null object" in Java and it's more memory efficient too, since it doesn't allocate an empty array of capacity 16 that will never end up having items.
 =||= No idea why we aren't using `Collections.emptyList()` ... we should be. Just a simple oversight by my or someone else who has contributed. 
 =||= Thanks @mttkay, that looks good. @benjchristensen what about more optimisations that would
- collapse the call stack
- avoid unnecessary invocations of backpressure slow path

For example, `concat` is now:

```
public final static <T> Observable<T> concat(Observable<? extends T> t1, Observable<? extends T> t2) {
    return concat(just(t1, t2));
}
```

but could be:

```
public final static <T> Observable<T> concat(Observable<? extends T> t1, Observable<? extends T> t2) {
    if (t1 == EMPTY) 
        return t2;
    else if (t2 == EMPTY)
        return t1;
    else 
        return concat(just(t1, t2));
}
```
 =||= @davidmoten `merge` can benefit from it, too.
 =||= @davidmoten what about adding the empty check here, too: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorConcat.java#L126

```
        @Override
        public void onNext(Observable<? extends T> t) {
            if(t==EMPTY) return; // check EMPTY
            queue.add(nl.next(t));
            if (WIP_UPDATER.getAndIncrement(this) == 0) {
                subscribeNext();
            }
        }
```
 =||= there are a LOT of operators that can benefit from this. I would hazard a guess that most can use this optimisation at the high level within the `Observable` class and yes good point @zsxwing we could dig into operators for more optimisations. I'll proceed with the PR if @benjchristensen gives it the tick.
 =||= If you want to submit a PR with this work done I'll accept it. If we can use `Collections.emptyList()` somewhere that we are currently allocating that will always be better.
 =||= Put on 1.0.x as this is not a blocker for 1.0, but whenever you submit the PR I'll do it.
 =||= I'm starting work on this PR now and I'd like to get the ok on some detail.

I'd propose adding this to `Observable` just after the init of the hook:

``` java
private static final Observable<?> EMPTY = from(Collections.emptyList());
```

`Observable.empty()` would be changed to:

``` java
    @SuppressWarnings("unchecked")
    public final static <T> Observable<T> empty() {
        return (Observable<T>) EMPTY;
    }
```

As an example of how it would be used the static method `Observable.merge` would be changed to:

``` java
    @SuppressWarnings("unchecked")
    public final static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? extends T> t2) {
        if (t1 == EMPTY) 
            return (Observable<T>) t2;
        else if (t2 == EMPTY)
            return (Observable<T>) t1;
        else 
            return merge(from(Arrays.asList(t1, t2)));
    }
```

Note that I've confirmed in the debugger that this optimisation avoids triggering backpressure if say `o.mergeWith(Observable.empty())` is called. ~~I'll get a unit test going for this as well.~~

A large number of methods will use this optimisation so I'd like to get my exact approach approved before submitting.

The final thing to note is that optimisations outside of the `Observable` class would do a reference equality check against `Observable.empty()`. So in the example from `OperatorConcat` by @zsxwing above:

``` java
        @Override
        public void onNext(Observable<? extends T> t) {
            if(t==Observable.empty()) return; // check EMPTY
            queue.add(nl.next(t));
            if (WIP_UPDATER.getAndIncrement(this) == 0) {
                subscribeNext();
            }
        }
```

I'd like to limit the scope of my PR to optimisations in Observable.java only. Optimisations in Operators would wait for this base PR to be accepted.

How does that sound?
 =||= Why do you have so many `empty()` to merge?

Edit: At least I looked at the implementation and improved it in #2622.
 =||= Ta for improvement. The reason I have `empty()`s to merge is that this is a common pattern for me:

``` java
o.flatMap(t -> {
   if (cond(t)) 
       return someObservable(t);
  else 
       return Observable.empty(); 
  });
```

I'm experimenting now with substituting the special case where the flatMap function returns either 0 or 1 by doing 

``` java
o.map(toOptional).filter(isPresent).map(toValue);
```

I'd hope it would be faster but not sure.
 =||= This PR is quite old. Can you create a reasonable benchmark to see how concatMap and flatMap behaves? In addition, I suggest we tackle this after both #2928 and #2960 are merged.
 =||= Yep I'll do benchmarks after those PRs have been merged.
 =||= This may be part of the operator-fusion optimizations in 2.x but I don't see this in 1.x due to non-technical reasons.
 =||= For a start: here is the baseline perf: #3754. I'm going to merge it so subsequent PRs can be benchmarked with it.
 =||= See #3759 for the optimized `concat`s.
 =||= See #3761 for the optimized `merge`s
 =||= Optimizations have been added and released with 1.1.4. Closing the issue. If you have more ideas where it's worth adding extra checks for empty, don't hesitate to open a new issue.
 =||= ,0
2627,2626,Add flatMap variant with maxConcurrent,To allow use of `merge(Observables..., maxConcurrent)` via flatMap we should consider adding a `flatMap(Func, int maxConcurrent)` overload. ,Example usage:

``` java
        Observable.range(0, Integer.MAX_VALUE).map(i -> "lineOfData-" + i) // simulate the file with many lines
                .buffer(100) // buffer up chunks of work before processing them
                .flatMap(chunk -> {
                    return Observable.just(chunk).subscribeOn(Schedulers.io()) // put each group on a new thread (io scheduler for blocking IO) 
                            .doOnNext(t -> {
                                // do work here
                                try {
                                    Thread.sleep(1000);
                                } catch (Exception e) {
                                }
                                // write out on blocking IO as a side-effect
                                System.out.println("Emitting to IO: " + t);
                            });
                }, maxConcurrentValueHere).toBlocking().forEach(System.out::println);
```
 =||= The related PR has been merged. Closing.
 =||= ,0
2630,2600,Make sure we keep a Subscriber’s subscription when passed as Observer,Fixes https://github.com/ReactiveX/RxJava/issues/2599,Thanks. Once the master build is fixed, I'm going to merge this.
 =||= :+1: 
 =||= Redone in #2630 because of merge conflicts.
 =||= ,0
2632,2468,Proposed improvement on OnNextValue stacktrace rendition,Hi,
I was looking at a stacktrace with `OnNextValue` in it and saw that the last emitted item, causing the Exception, was indeed logged in the stacktrace as just a `className`, as per #1401. (see also [the rendering code](https://github.com/ReactiveX/RxJava/blob/7924a3e919d408baf95de253f2dbcca1bfcd573d/src/main/java/rx/exceptions/OnErrorThrowable.java#L140)).

But in some contexts, like for the Couchbase SDK or some other framework using Rx, I think it is acceptable to say that we can identify more types that it makes sense to stringify. We can check that these types have a sufficiently performant, safe and slim `toString()` implementation to be fully rendered by `OnNextValue`.

Offering a mean to let RxJava know about such types would allow the String rendering to be activated in a cross-cutting manner, without reworking every single stream produced by the framework/library to induce additional logging behavior.

I see two broad ways of achieving such a thing:
- via an _interface_ in RxJava
  - either a marker interface (implementing classes would then be rendered by calling their `toString()`)
  - or a functional interface (implementing classes would have to define some sort of short, performant and safe `toString()`, `toShortString()`?, to be used by `OnNextValue` for rendering)
- achieve the same via a _RxJava Plugin_: providing a hook to decide or not if a value should be fully rendered (additional method on `RxJavaErrorHandler`?)

What do you think about this idea? If we can agree on a way of doing this, I'd be happy to contribute it!,I'm okay with exploring improvements to this (and anything else to improve debugging).

The marker interface could work, but it is intrusive to the public API and the types being used by libraries. It seems the plugin model would be the most powerful and would work on any types without forcing them to conform to the RxJava marker interface, which is important if the types are 3rd party and can't be changed, or they live somewhere that should not have dependency on RxJava.

One drawback of how the plugin registration works right now is that it assumes and enforces only 1 registration at startup, so if 2 libraries both tried, one would fail. Perhaps for this use case we want to allow many plugin registrations? 

It could be that `RxJavaErrorHandler` should support a chain of implementations?

@ReactiveX/rxjava-committers Do you have preferences on how this is pursued? 
 =||= I don't want another `Serializable` so I'd go for the plugin-based callbacks. I'd extend `RxJavaErrorHandler` with a 

``` java
public <T> Subscription registerErrorValueRenderer(
    Class<T> clazz, Func1<? super T, String> tostring);
public <T> boolean hasErrorValueRenderer(Class<T> clazz);
```

But what should happen if the same class was registered multiple times? I'd throw an `IllegalArgumentException` so libraries don't try to register for common types such as `Integer` but only their own types.
 =||= I was thinking about doing it the plugin way on the existing plugin but that breaks a committed interface doesn't it? So thinking about doing a separate plugin, and one that supports chaining (composite pattern?) :)
 =||= `RxJavaErrorHandler` is an abstract class so adding a regular method has only the risk if there is someone implementing this class with a method having the same name. 

Chaining has some issues: in worst case it would take N steps to reach a value renderer. You'd need some cooperation mechanisms to see who is interested in giving an answer and not ask anyone else (such as Swing's KeyEvent.consume() or something).
 =||= Ah right it's abstract!
What I was going for was one-in-all renderer, something like:

```
public interface ErrorRenderer {
    String attemptRender(Object item);
}
```

The renderer internally checks for relevant types and return a string value if it can manage the object, `null` if not. Chaining would involve having a composite root renderer and going to next renderer in chain if previous one had returned null. So one renderer per "client layer", not per type.

The stack rendering code would then check for primitive types (as it does now), then call `renderer.attemptRender(item)`, then if result is null fallback to printing the class name.

Example renderer implementation:

```
public MyErrorRenderer implements ErrorRenderer {
    public String attemptRender(Object item) {
        if (item == null) return null;
        if (item instanceof MyTypeWithShortToString) {
            //this one we know has a safe short toString()
            return item.toString();
        } else if (item instanceof MyOtherType) {
            //this one has a long toString but another safe short string representation method
            return ((MyOtherType) item).asShortString();
        }
        return null;
    }
}
```

what do you think?
 =||= I suggest you post a PR so we have a more complete picture how things can work.
 =||= sure, I think I may be able to find time tomorrow (CET) :+1: 
 =||= submitted a PR, had some problems during CI that seem unrelated to my work, any clue?

> No such property: release.scope for class: org.gradle.api.internal.project.DefaultProject_Decorated

edit: nevermind the issue has disappeared
 =||= Looks completed in #2632
 =||= ,0
2648,2647,flatMap doesn't propagate onComplete with unsubscribe of child,The following code hangs forever as it doesn't emit a terminal event:

``` java
import java.util.concurrent.TimeUnit;

import rx.Observable;

public class IntervalTakeWhileExample {

    public static void main(String... args) {
        Observable
                .interval(1, TimeUnit.MILLISECONDS)
                .doOnEach(a -> System.out.println("A ==> " + a))
                .takeWhile(aLong -> aLong < 1)
                .doOnEach(b -> System.out.println("B ==> " + b))
                .flatMap(aLong -> {
                    return Observable
                            .timer(30, TimeUnit.MILLISECONDS)
                            .doOnUnsubscribe(() -> System.out.println("unsubscribed timer?"))
                            .doOnEach(c -> System.out.println("C ==> " + c))
                            .map(aLong1 -> aLong1 + aLong);
                })
                .doOnEach(d -> System.out.println("D ==> " + d))
                .toBlocking().forEach(System.out::println);
    }
}
```

This emits:

```
A ==> [rx.Notification@f6adcf11 OnNext 0]
B ==> [rx.Notification@f6adcf11 OnNext 0]
A ==> [rx.Notification@f6adcf12 OnNext 1]
B ==> [rx.Notification@5b2cf4de OnCompleted]
unsubscribed timer?
```,/cc @abersnaze This may be related to the issue you're hunting.
 =||= It is not related to `interval` as I can replicate without it:

``` java
import java.util.concurrent.TimeUnit;

import rx.Observable;

public class IntervalTakeWhileExample {

    public static void main(String... args) {
        Observable
                .<Integer>create(s -> {
                    s.onNext(0);
                    try {
                        Thread.sleep(5);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    s.onNext(1);
                    s.onCompleted();
                })
                .doOnEach(a -> System.out.println("A ==> " + a))
                .takeWhile(aLong -> aLong < 1)
                .doOnEach(b -> System.out.println("B ==> " + b))
                .flatMap(aLong -> {
                    return Observable
                            .timer(30, TimeUnit.MILLISECONDS)
                            .doOnUnsubscribe(() -> System.out.println("unsubscribed timer?"))
                            .doOnEach(c -> System.out.println("C ==> " + c))
                            .map(aLong1 -> aLong1 + aLong);
                })
                .doOnEach(d -> System.out.println("D ==> " + d))
                .toBlocking().forEach(System.out::println);
    }
}
```

However, if I change `takeWhile` to `take(1)` it works fine, so it may be related to `takeWhile`. But `merge` is always a candidate for this and my first thought. 
 =||= It's not just takeWhile.  It also fails if replace:
.takeWhile(aLong -> aLong < 1)
with:
flatMap(aLong -> (aLong < 1) ? Observable.just(i) : Observable.empty)
 =||= The `takeWhile` issue was fixed in 1.0.6.
 =||= > flatMap(aLong -> (aLong < 1) ? Observable.just(i) : Observable.empty)

I don't understand this one. In the code example, what is variable `i`?

This works in 1.0.6:

``` java
import java.util.concurrent.TimeUnit;

import rx.Observable;

public class IntervalTakeWhileExample {

    public static void main(String... args) {
        Observable
                .<Integer> create(s -> {
                    s.onNext(0);
                    try {
                        Thread.sleep(5);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    s.onNext(1);
                    s.onCompleted();
                })
                .doOnEach(a -> System.out.println("A ==> " + a))
                //                .takeWhile(aLong -> aLong < 1)
                .flatMap(aLong -> (aLong < 1) ? Observable.just(aLong) : Observable.empty())
                .doOnEach(b -> System.out.println("B ==> " + b))
                .flatMap(aLong -> {
                    return Observable
                            .timer(30, TimeUnit.MILLISECONDS)
                            .doOnUnsubscribe(() -> System.out.println("unsubscribed timer?"))
                            .doOnEach(c -> System.out.println("C ==> " + c))
                            .map(aLong1 -> aLong1 + aLong);
                })
                .doOnEach(d -> System.out.println("D ==> " + d))
                .toBlocking().forEach(System.out::println);
    }
}
```
 =||= Is this issue still outstanding with `flatMap()`? I'm seeing a similar behavior where I never get a terminal event after a flatMap
 =||= @felipecsl Could you post a small code example?
 =||= I'll try to write a small sample to reproduce the issue
 =||= Never mind, can't reproduce anymore. Was probably doing something stupid :)
 =||= ,0
2655,2654,sharing a switchMap which produces its result via merge, will stop producing after 128 events,The first example uses switchMap and fails with the exception below after 128 events, whereas the second example uses flatMap and does not fail. The third example shows that switchMap does not fail if the nested observable is not a product of of the merge operator. 

However the other variable is the share() on the mainObservable. _Without this, Example 1 works_ (I have called this case Example 4). So you might wonder if it has anything to do with switchMap at all - maybe just sharing a merged observable will also fail (Example 5) - however, this case works fine.

So we're left with "sharing a switchMap which produces its result via merge, will stop producing after 128 events". But why?

_(using rxjava 1.0.4, rxscala 0.23.1, scala 2.11.4)_

<pre>
rx.exceptions.MissingBackpressureException: null
    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:338) ~[rxjava-1.0.4.jar:1.0.4]
    at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:680) [rxjava-1.0.4.jar:1.0.4]
    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:657) [rxjava-1.0.4.jar:1.0.4]
    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:545) [rxjava-1.0.4.jar:1.0.4]
    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55) [rxjava-1.0.4.jar:1.0.4]
</pre>

_Example 1 : This Fails After 128 events_

``` scala
def main(args:Array[String]) = {
    val oneItemOnly = (Observable.just("Hello").merge(Observable.never))
    val mainObservable = oneItemOnly.switchMap {
      v => 
        val a = Observable.just(v)
        val b = Observable.interval(20 milliseconds).map(i => s"$v $i")
        a.merge(b)
    }
    .share

    val sub = mainObservable.subscribe( 
      (v) => LOG.info(s"Value: $v"),
      (e) => LOG.info(s"Error",e),
      () => LOG.info(s"Done")
    )
    Observable.never.toBlocking.first
}
```

_Example 2 : This Works Fine_
Note this is precisely the same code as Example 1, except I've changed  switchMap to flatMap

``` scala
def main(args:Array[String]) = {
    val oneItemOnly = (Observable.just("Hello").merge(Observable.never))
    val mainObservable = oneItemOnly.flatMap {
      v => 
        val a = Observable.just(v)
        val b = Observable.interval(20 milliseconds).map(i => s"$v $i")
        a.merge(b)
    }
    .share

    val sub = mainObservable.subscribe( 
      (v) => LOG.info(s"Value: $v"),
      (e) => LOG.info(s"Error",e),
      () => LOG.info(s"Done")
    )
    Observable.never.toBlocking.first
}
```

_Example 3 : This also works fine_
Changing example 1 again but this time not using merge within the switchMap.

``` scala
def main(args:Array[String]) = {
    val oneItemOnly = (Observable.just("Hello").merge(Observable.never))
    val mainObservable = oneItemOnly.switchMap {
      v => 
        Observable.interval(20 milliseconds).map(i => s"$v $i")
    }
    .share

    val sub = mainObservable.subscribe( 
      (v) => LOG.info(s"Value: $v"),
      (e) => LOG.info(s"Error",e),
      () => LOG.info(s"Done")
    )
    Observable.never.toBlocking.first
}
```

_Example 4 : This also works fine_
Changing example 1 again but this time not share()ing the mainObservable

``` scala
def main(args:Array[String]) = {
    val oneItemOnly = (Observable.just("Hello").merge(Observable.never))
    val mainObservable = oneItemOnly.switchMap {
      v => 
        val a = Observable.just(v)
        val b = Observable.interval(20 milliseconds).map(i => s"$v $i")
        a.merge(b)
    }

    val sub = mainObservable.subscribe( 
      (v) => LOG.info(s"Value: $v"),
      (e) => LOG.info(s"Error",e),
      () => LOG.info(s"Done")
    )
    Observable.never.toBlocking.first
}
```

_Example 5 : This also works fine_
Experiment to find out if the problem is simply sharing a merged observable.... seems not

``` scala
def main(args:Array[String]) = {
    val mainObservable = Observable.just(1).merge(Observable.interval(20 milliseconds))
        .share
    val sub = mainObservable.subscribe( 
      (v) => LOG.info(s"Value: $v"),
      (e) => LOG.info(s"Error",e),
      () => LOG.info(s"Done")
    )
    Observable.never.toBlocking.first
}
```,Could you check these with RxJava 1.0.6? We've fixed a bunch of share- and merge-related bugs since 1.0.4.
 =||= Done, no change

<pre>
18:22:07.723 [RxComputationThreadPool-2] INFO  MinimalRepro - Value: Hello 125
18:22:07.744 [RxComputationThreadPool-2] INFO  MinimalRepro - Value: Hello 126
18:22:10.343 [RxComputationThreadPool-2] INFO  MinimalRepro - Error
rx.exceptions.MissingBackpressureException: null
    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:349) ~[rxjava-1.0.6.jar:1.0.6]
    at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:721) [rxjava-1.0.6.jar:1.0.6]
    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:698) [rxjava-1.0.6.jar:1.0.6]
    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:586) [rxjava-1.0.6.jar:1.0.6]
    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55) [rxjava-1.0.6.jar:1.0.6]
</pre>

_(rxjava 1.0.6, rxscala 0.23.1, scala 2.11.4)_
 =||= It's a bug in switch. Could you check if #2655 works for you?
 =||= Yes - it works for me. Nice work!
 =||= ,0
2759,2604,OperatorMerge - RxRingBuffer throws IllegalStateException again,With 1.0.5, I'm getting an `IllegalStateException` from `OperatorMerge`. This is repeatable for me but involves a big input data set being processed in chunks using flatMap/onSubscribe so I can't give you a quick test case yet. Hopefully just this description is enough otherwise I'll try and distill a test. I think it is happening close to completion.

```
java.lang.IllegalStateException: This instance has been unsubscribed and the queue is no longer usable.
        at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:346)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:721)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:698)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:586)
        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservableWithRequestLimits(OperatorMerge.java:280)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservable(OperatorMerge.java:243)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:176)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120)
        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservableWithRequestLimits(OperatorMerge.java:280)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.handleScalarSynchronousObservable(OperatorMerge.java:243)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:176)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:120)
        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)
        at rx.internal.operators.NotificationLite.accept(NotificationLite.java:150)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainScalarValueQueue(OperatorMerge.java:396)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:343)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$500(OperatorMerge.java:120)
        at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:549)
        at rx.Subscriber.request(Subscriber.java:130)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:350)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$500(OperatorMerge.java:120)
        at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:549)
        at rx.Subscriber.request(Subscriber.java:130)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:350)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$500(OperatorMerge.java:120)
        at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:549)
        at rx.internal.operators.OperatorSubscribeOn$1$1$1$1$1.call(OperatorSubscribeOn.java:94)
        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:47)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)
Caused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: au.gov.amsa.ais.Timestamped.class
        at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:98)
        at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:58)
        ... 27 more
```,Did this happen with version 1.0.5? 
 =||= yes 1.0.5
 =||= I've updated this issue. No error is occuring in upstream. The only error occuring is the IllegalStateException.
 =||= _sigh_ I had hoped we'd fixed this issue in 1.0.5. 
 =||= not sure what fixes went through for that. i see that  #1963 was closed but didn't notice record of the resolution (like a PR number).
 =||= In #2584 @akarnokd mentions that there is still a small window where this can happen. I imagine he'll enlighten us.
 =||= The only fix would be not to throw but just exit. We can't distinguish between an upstream ignoring unsubscription and an upstream pushing just after an unsubscription happened.
 =||= So in my case, I wouldn't expect what you describe because the operators should be consuming all of the input stream. None of the observables should be interrupted by unsubscription before completion. Do you have an alternative theory? 
 =||= Something is unsubscribing because otherwise the queue wouldn't be null.
 =||= righto, I'll have a close look tomorrow
 =||= Got it. I think its an `OperatorMerge` bug. The unsubscribe is originating from upstream due to the use of `using`. Here is a failing unit test for your debugging pleasure. 

``` java
    @Test(timeout = 3000)
    public void testMergeEagerUnsubscribeFromUpstream() {
        Func0<Object> resourceFactory = new Func0<Object>() {
            @Override
            public Object call() {
                return new Object();
            }
        };
        Func1<Object, Observable<Integer>> observableFactory = new Func1<Object, Observable<Integer>>() {
            @Override
            public Observable<Integer> call(Object o) {
                return Observable.range(1, 1000000);
            }
        };
        Action1<Object> disposeAction = new Action1<Object>() {
            @Override
            public void call(Object t) {
                // do nothing
            }
        };
        Observable.using(resourceFactory, observableFactory, disposeAction)
                .toList()
                .flatMap(new Func1<List<Integer>, Observable<Integer>>() {
                    @Override
                    public Observable<Integer> call(List<Integer> list) {
                        return Observable.from(list).subscribeOn(
                                Schedulers.computation());
                    }
                }).count().toBlocking().single();
    }
```
 =||= Thanks. This is a nasty one. `using` does `subscribe()` on the source which then wraps the downstream into a `SafeSubscriber` which then cancels all work stared by merge immediately after toList sends onCompleted(). So either `using` should do `unsafeSubscribe` or `toList()` should break the chaining of subscribers via the Subscriber constructor.
This may affect other operators that do something async after an onError and onCompleted.

``` java
return new Subscriber<T>(child) { .. }
```

should become something like this:

``` java
class InnerSubscriber<T> extends Subscriber<T> {
    void requestMore(long n) {
        request(n);
    }
    // ...
}
InnerSubscriber<T> s = new InnerSubscriber<T>();
child.setProducer(s::requestMore);
child.add(s);
return s;
```
 =||= `unsafeSubscribe` in `using` sounds alright to me. Any reasons preventing us doing that?
 =||= I've rewritten `OnSubscribeUsing` for my applications use so this problem doesn't happen.  I use `unsafeSubscribe` and optional dispose on termination event (which I always set to true) in addition to unsubscription dispose though there is protection to ensure that disposal only occurs once. This sorts the problem for me.  If people are happy with this direction as opposed to handling things downstream instead I'll put in a PR (and write the as yet unwritten unit tests).

``` java
public final class OnSubscribeUsing2<T, Resource> implements OnSubscribe<T> {

    private final Func0<Resource> resourceFactory;
    private final Func1<? super Resource, ? extends Observable<? extends T>> observableFactory;
    private final Action1<? super Resource> dispose;
    private final boolean disposeEagerly;

    public OnSubscribeUsing2(
            Func0<Resource> resourceFactory,
            Func1<? super Resource, ? extends Observable<? extends T>> observableFactory,
            Action1<? super Resource> dispose, boolean disposeEagerly) {
        this.resourceFactory = resourceFactory;
        this.observableFactory = observableFactory;
        this.dispose = dispose;
        this.disposeEagerly = disposeEagerly;
    }

    @Override
    public void call(Subscriber<? super T> subscriber) {

        try {
            // create the resource
            final Resource resource = resourceFactory.call();
            // create an action that disposes only once
            final Action0 disposeOnceOnly = createOnceOnlyDisposeAction(resource);
            // dispose on unsubscription
            subscriber.add(Subscriptions.create(disposeOnceOnly));
            // create the observable
            final Observable<? extends T> source = observableFactory
            // create the observable
                    .call(resource);
            final Observable<? extends T> observable;
            // supplement with on termination disposal if requested
            if (disposeEagerly)
                observable = source
                // dispose on completion or error
                        .doOnTerminate(disposeOnceOnly);
            else
                observable = source;
            try {
                // start
                observable.unsafeSubscribe(subscriber);
            } catch (Throwable e) {
                Throwable disposeError = disposeEagerlyIfRequested(disposeOnceOnly);
                if (disposeError != null)
                    subscriber.onError(new CompositeException(Arrays.asList(e,
                            disposeError)));
                else
                    // propagate error
                    subscriber.onError(e);
            }
        } catch (Throwable e) {
            // then propagate error
            subscriber.onError(e);
        }
    }

    private Throwable disposeEagerlyIfRequested(final Action0 disposeOnceOnly) {
        if (disposeEagerly)
            try {
                disposeOnceOnly.call();
                return null;
            } catch (Throwable e) {
                return e;
            }
        else
            return null;
    }

    private Action0 createOnceOnlyDisposeAction(final Resource resource) {
        return new Action0() {

            final AtomicBoolean disposed = new AtomicBoolean(false);

            @Override
            public void call() {
                // only want dispose called once
                if (disposed.compareAndSet(false, true))
                    dispose.call(resource);
            }
        };
    }
}
```
 =||= I'm closing this as the related PR has been merged some days ago.
 =||= ,0
2762,2603,Optimized observeOn/subscribeOn,Doing observeOn/subscribeOn on these is essentially the same operation.

Benchmark results: (i7 4770k, Java 1.8u31, Windows 7 x64)

```
gradlew benchmarks "-Pjmh=-f 1 -tu s -bm thrpt -wi 10 -i 10 -r 5 .*ComputationSchedulerPerf.*"

Benchmark                        (size)    1.x Score  Score error   PR  Score  Score error
CompSchedulerPerf.observeOn           1   182479,416    11686,648  210536,292     9760,937  
CompSchedulerPerf.observeOn          10   174911,567    13659,846  179245,342    12725,807  
CompSchedulerPerf.observeOn         100    30997,516      958,587   27000,106      623,127  
CompSchedulerPerf.observeOn        1000     6701,672      314,471    8623,296      703,255  
CompSchedulerPerf.observeOn       10000      927,207       98,571     985,409       32,412  
CompSchedulerPerf.observeOn      100000      111,968        1,176     110,597        2,883  
CompSchedulerPerf.observeOn     1000000       11,790        0,195      11,512        0,146  
CompSchedulerPerf.subscribeOn         1   202557,014    13692,298  204616,231    11272,351  
CompSchedulerPerf.subscribeOn        10   180090,498    14058,995  190338,591     1822,349  
CompSchedulerPerf.subscribeOn       100   113625,737    32012,148  114659,399    50494,246  
CompSchedulerPerf.subscribeOn      1000    35600,359     2975,926   36856,078     1770,347  
CompSchedulerPerf.subscribeOn     10000     4220,548      311,551    3942,293      368,052  
CompSchedulerPerf.subscribeOn    100000      487,187       18,150     472,594       22,474  
CompSchedulerPerf.subscribeOn   1000000       52,191        0,349      50,250        0,510  
```

Unfortunately, the benchmark results were quite hectic even with more warmup and iteration. I'd say the changes give +10% for the size = 1 case, but running the same code twice (observeOn 1, subscribeOn 1) gives inconsistent values. I suspect the main cause is the GC.,New benchmark results (i7 920, Java 1.8u31, Windows 7 x64)

```
Benchmark      (size)    Score 1.x            v2     v2 error   Diff %   Diff x
observeOn           1    145464,015   164994,196     3694,358    13,43     1,13
observeOn          10    132737,962   137155,992     1012,799     3,33     1,03
observeOn         100     25681,480    45319,683      514,267    76,47     1,76
observeOn        1000      3422,822    12182,024      460,586   255,91     3,55
observeOn       10000       498,887     1582,275       18,479   217,16     3,17
observeOn      100000        85,889      155,932        2,873    81,55     1,81
observeOn     1000000         8,661       15,959        1,313    84,26     1,84
subscribeOn         1    155442,402   162559,432     1046,801     4,58     1,04
subscribeOn        10    144919,758   152370,842      753,133     5,14     1,05
subscribeOn       100    107249,189   138655,111      836,759    29,28     1,29
subscribeOn      1000     27860,564    57548,020    11424,426   106,56     2,06
subscribeOn     10000      3481,585     9069,788      229,033   160,51     2,60
subscribeOn    100000       362,142      980,154       28,928   170,65     2,70
subscribeOn   1000000        35,890       92,740        1,033   158,40     2,58
```

There are 2x-3x througput improvements. I've verified there aren't any exceptions thrown and the last emitted value is always the size - 1 (all values should have been delivered). Note that these improvements are due to overhead reduction. With `Blackhole.consumeCPU(5)`, the numbers look like this:

```
Benchmark      (size)           1.x    1.x error           v2     v2 error
observeOn           1    140296,417      441,165   160466,648    18522,034
observeOn          10    133460,788     2365,310   135523,349     1877,668
observeOn         100     25786,907     1948,696    47624,460      925,317
observeOn        1000      3559,582       81,327    11185,990      988,573
observeOn       10000       552,615       93,469     1370,051      321,379
observeOn      100000        79,281        2,550      141,401        4,252
observeOn     1000000         8,083        0,922       13,593        1,866
subscribeOn         1    155594,824     1630,359   159551,161     2583,546
subscribeOn        10    142827,468     2120,922   146452,153     1323,202
subscribeOn       100     93820,703    21969,555   102171,399    51531,245
subscribeOn      1000     23061,551     2348,392    37658,325     3900,619
subscribeOn     10000      2798,071      144,547     5128,935      331,227
subscribeOn    100000       278,345       11,796      523,751       50,789
subscribeOn   1000000        28,944        1,060       54,256        1,252
```

Most likely, the improvement comes from the change to isUnusubscribed reading a volatile field instead of always entering the unbiasable synchronized blocks.
 =||= @akarnokd great stuff, I'll try it out early next week and report some numbers :)
 =||= Now on: i7 4770k, Java 1.8u31, Windows 7 x64

```
Benchmark      (size)    1.x Score  Score error        Score  Score error
observeOn           1   182479,416    11686,648   206216,641     4097,849  
observeOn          10   174911,567    13659,846   183143,285     6557,560  
observeOn         100    30997,516      958,587    71018,915     2110,252  
observeOn        1000     6701,672      314,471    13325,539     1940,749  
observeOn       10000      927,207       98,571     1648,631      250,874  
observeOn      100000      111,968        1,176      200,704        7,900  
observeOn     1000000       11,790        0,195       19,285        0,630  
subscribeOn         1   202557,014    13692,298   205876,054     9574,248  
subscribeOn        10   180090,498    14058,995   194964,365     7460,966  
subscribeOn       100   113625,737    32012,148   149761,195   104683,280  
subscribeOn      1000    35600,359     2975,926    87861,668    17543,179  
subscribeOn     10000     4220,548      311,551    13208,973     2794,952  
subscribeOn    100000      487,187       18,150     1695,555      226,512  
subscribeOn   1000000       52,191        0,349      180,335       30,122
```
 =||= I see these improvements ... still reviewing the code:

```
Benchmark                                   (size)   Mode   Samples          1.x        2603    
r.s.ComputationSchedulerPerf.observeOn           1  thrpt         5   104110.926  115707.286
r.s.ComputationSchedulerPerf.observeOn          10  thrpt         5   100723.402  105825.148
r.s.ComputationSchedulerPerf.observeOn         100  thrpt         5    24609.763   65571.461
r.s.ComputationSchedulerPerf.observeOn        1000  thrpt         5     3212.434   13020.027
r.s.ComputationSchedulerPerf.observeOn        2000  thrpt         5     2057.133    
r.s.ComputationSchedulerPerf.observeOn        3000  thrpt         5     1807.644    
r.s.ComputationSchedulerPerf.observeOn        4000  thrpt         5     2000.223    
r.s.ComputationSchedulerPerf.observeOn       10000  thrpt         5      955.002    1555.493  
r.s.ComputationSchedulerPerf.observeOn      100000  thrpt         5       96.628     160.218  
r.s.ComputationSchedulerPerf.observeOn     1000000  thrpt         5        9.508      16.559  
r.s.ComputationSchedulerPerf.subscribeOn         1  thrpt         5   114212.000  118885.516  
r.s.ComputationSchedulerPerf.subscribeOn        10  thrpt         5   112376.809  112270.024  
r.s.ComputationSchedulerPerf.subscribeOn       100  thrpt         5    88433.002  104240.739  
r.s.ComputationSchedulerPerf.subscribeOn      1000  thrpt         5    31503.640   64446.984  
r.s.ComputationSchedulerPerf.subscribeOn      2000  thrpt         5    16292.135    
r.s.ComputationSchedulerPerf.subscribeOn      3000  thrpt         5    11372.297    
r.s.ComputationSchedulerPerf.subscribeOn      4000  thrpt         5     9927.774    
r.s.ComputationSchedulerPerf.subscribeOn     10000  thrpt         5     3932.988    8200.048
r.s.ComputationSchedulerPerf.subscribeOn    100000  thrpt         5      437.626    1439.069
r.s.ComputationSchedulerPerf.subscribeOn   1000000  thrpt         5       43.104     146.385
```
 =||= @benjchristensen what is the verdict on this PR?
 =||= I think it's only the discussion about exposing `EventLoopScheduler` publicly which I don't think should happen. 
 =||= The optimization is built upon the direct access which is not possible if the class is package private. I could create a Schedulers.scheduleSingle(Scheduler, Action0) that calls schedule direct and since they are both in the same package, no need to expose EventLoopScheduler.
 =||= So why don't you just move it to the rx.internal packages as you suggested before?
 =||= Can you please rebase this, and move that file to rx.internal so it is not made part of the public API?
 =||= Okay.
 =||= ,0
2767,2603,Optimized observeOn/subscribeOn,Doing observeOn/subscribeOn on these is essentially the same operation.

Benchmark results: (i7 4770k, Java 1.8u31, Windows 7 x64)

```
gradlew benchmarks "-Pjmh=-f 1 -tu s -bm thrpt -wi 10 -i 10 -r 5 .*ComputationSchedulerPerf.*"

Benchmark                        (size)    1.x Score  Score error   PR  Score  Score error
CompSchedulerPerf.observeOn           1   182479,416    11686,648  210536,292     9760,937  
CompSchedulerPerf.observeOn          10   174911,567    13659,846  179245,342    12725,807  
CompSchedulerPerf.observeOn         100    30997,516      958,587   27000,106      623,127  
CompSchedulerPerf.observeOn        1000     6701,672      314,471    8623,296      703,255  
CompSchedulerPerf.observeOn       10000      927,207       98,571     985,409       32,412  
CompSchedulerPerf.observeOn      100000      111,968        1,176     110,597        2,883  
CompSchedulerPerf.observeOn     1000000       11,790        0,195      11,512        0,146  
CompSchedulerPerf.subscribeOn         1   202557,014    13692,298  204616,231    11272,351  
CompSchedulerPerf.subscribeOn        10   180090,498    14058,995  190338,591     1822,349  
CompSchedulerPerf.subscribeOn       100   113625,737    32012,148  114659,399    50494,246  
CompSchedulerPerf.subscribeOn      1000    35600,359     2975,926   36856,078     1770,347  
CompSchedulerPerf.subscribeOn     10000     4220,548      311,551    3942,293      368,052  
CompSchedulerPerf.subscribeOn    100000      487,187       18,150     472,594       22,474  
CompSchedulerPerf.subscribeOn   1000000       52,191        0,349      50,250        0,510  
```

Unfortunately, the benchmark results were quite hectic even with more warmup and iteration. I'd say the changes give +10% for the size = 1 case, but running the same code twice (observeOn 1, subscribeOn 1) gives inconsistent values. I suspect the main cause is the GC.,New benchmark results (i7 920, Java 1.8u31, Windows 7 x64)

```
Benchmark      (size)    Score 1.x            v2     v2 error   Diff %   Diff x
observeOn           1    145464,015   164994,196     3694,358    13,43     1,13
observeOn          10    132737,962   137155,992     1012,799     3,33     1,03
observeOn         100     25681,480    45319,683      514,267    76,47     1,76
observeOn        1000      3422,822    12182,024      460,586   255,91     3,55
observeOn       10000       498,887     1582,275       18,479   217,16     3,17
observeOn      100000        85,889      155,932        2,873    81,55     1,81
observeOn     1000000         8,661       15,959        1,313    84,26     1,84
subscribeOn         1    155442,402   162559,432     1046,801     4,58     1,04
subscribeOn        10    144919,758   152370,842      753,133     5,14     1,05
subscribeOn       100    107249,189   138655,111      836,759    29,28     1,29
subscribeOn      1000     27860,564    57548,020    11424,426   106,56     2,06
subscribeOn     10000      3481,585     9069,788      229,033   160,51     2,60
subscribeOn    100000       362,142      980,154       28,928   170,65     2,70
subscribeOn   1000000        35,890       92,740        1,033   158,40     2,58
```

There are 2x-3x througput improvements. I've verified there aren't any exceptions thrown and the last emitted value is always the size - 1 (all values should have been delivered). Note that these improvements are due to overhead reduction. With `Blackhole.consumeCPU(5)`, the numbers look like this:

```
Benchmark      (size)           1.x    1.x error           v2     v2 error
observeOn           1    140296,417      441,165   160466,648    18522,034
observeOn          10    133460,788     2365,310   135523,349     1877,668
observeOn         100     25786,907     1948,696    47624,460      925,317
observeOn        1000      3559,582       81,327    11185,990      988,573
observeOn       10000       552,615       93,469     1370,051      321,379
observeOn      100000        79,281        2,550      141,401        4,252
observeOn     1000000         8,083        0,922       13,593        1,866
subscribeOn         1    155594,824     1630,359   159551,161     2583,546
subscribeOn        10    142827,468     2120,922   146452,153     1323,202
subscribeOn       100     93820,703    21969,555   102171,399    51531,245
subscribeOn      1000     23061,551     2348,392    37658,325     3900,619
subscribeOn     10000      2798,071      144,547     5128,935      331,227
subscribeOn    100000       278,345       11,796      523,751       50,789
subscribeOn   1000000        28,944        1,060       54,256        1,252
```

Most likely, the improvement comes from the change to isUnusubscribed reading a volatile field instead of always entering the unbiasable synchronized blocks.
 =||= @akarnokd great stuff, I'll try it out early next week and report some numbers :)
 =||= Now on: i7 4770k, Java 1.8u31, Windows 7 x64

```
Benchmark      (size)    1.x Score  Score error        Score  Score error
observeOn           1   182479,416    11686,648   206216,641     4097,849  
observeOn          10   174911,567    13659,846   183143,285     6557,560  
observeOn         100    30997,516      958,587    71018,915     2110,252  
observeOn        1000     6701,672      314,471    13325,539     1940,749  
observeOn       10000      927,207       98,571     1648,631      250,874  
observeOn      100000      111,968        1,176      200,704        7,900  
observeOn     1000000       11,790        0,195       19,285        0,630  
subscribeOn         1   202557,014    13692,298   205876,054     9574,248  
subscribeOn        10   180090,498    14058,995   194964,365     7460,966  
subscribeOn       100   113625,737    32012,148   149761,195   104683,280  
subscribeOn      1000    35600,359     2975,926    87861,668    17543,179  
subscribeOn     10000     4220,548      311,551    13208,973     2794,952  
subscribeOn    100000      487,187       18,150     1695,555      226,512  
subscribeOn   1000000       52,191        0,349      180,335       30,122
```
 =||= I see these improvements ... still reviewing the code:

```
Benchmark                                   (size)   Mode   Samples          1.x        2603    
r.s.ComputationSchedulerPerf.observeOn           1  thrpt         5   104110.926  115707.286
r.s.ComputationSchedulerPerf.observeOn          10  thrpt         5   100723.402  105825.148
r.s.ComputationSchedulerPerf.observeOn         100  thrpt         5    24609.763   65571.461
r.s.ComputationSchedulerPerf.observeOn        1000  thrpt         5     3212.434   13020.027
r.s.ComputationSchedulerPerf.observeOn        2000  thrpt         5     2057.133    
r.s.ComputationSchedulerPerf.observeOn        3000  thrpt         5     1807.644    
r.s.ComputationSchedulerPerf.observeOn        4000  thrpt         5     2000.223    
r.s.ComputationSchedulerPerf.observeOn       10000  thrpt         5      955.002    1555.493  
r.s.ComputationSchedulerPerf.observeOn      100000  thrpt         5       96.628     160.218  
r.s.ComputationSchedulerPerf.observeOn     1000000  thrpt         5        9.508      16.559  
r.s.ComputationSchedulerPerf.subscribeOn         1  thrpt         5   114212.000  118885.516  
r.s.ComputationSchedulerPerf.subscribeOn        10  thrpt         5   112376.809  112270.024  
r.s.ComputationSchedulerPerf.subscribeOn       100  thrpt         5    88433.002  104240.739  
r.s.ComputationSchedulerPerf.subscribeOn      1000  thrpt         5    31503.640   64446.984  
r.s.ComputationSchedulerPerf.subscribeOn      2000  thrpt         5    16292.135    
r.s.ComputationSchedulerPerf.subscribeOn      3000  thrpt         5    11372.297    
r.s.ComputationSchedulerPerf.subscribeOn      4000  thrpt         5     9927.774    
r.s.ComputationSchedulerPerf.subscribeOn     10000  thrpt         5     3932.988    8200.048
r.s.ComputationSchedulerPerf.subscribeOn    100000  thrpt         5      437.626    1439.069
r.s.ComputationSchedulerPerf.subscribeOn   1000000  thrpt         5       43.104     146.385
```
 =||= @benjchristensen what is the verdict on this PR?
 =||= I think it's only the discussion about exposing `EventLoopScheduler` publicly which I don't think should happen. 
 =||= The optimization is built upon the direct access which is not possible if the class is package private. I could create a Schedulers.scheduleSingle(Scheduler, Action0) that calls schedule direct and since they are both in the same package, no need to expose EventLoopScheduler.
 =||= So why don't you just move it to the rx.internal packages as you suggested before?
 =||= Can you please rebase this, and move that file to rx.internal so it is not made part of the public API?
 =||= Okay.
 =||= ,0
2779,2774,ConnectableObservable.connect() returns a null subscription if already connected,Any posterior `connect()` calls to an already connected `ConnectableObservable` return `null`, but I believe the expected behaviour would be for it to return the subscription created for the first connection,I suspect that this is a documentation issue on the method because the source code seems to be quite deliberate in its treatment of this case (can code be deliberate?). No doubt an API expert will comment soon.
 =||= I think it should return a subscription every time, but all places where `connect(Action1)` is implemented, the action is only called on the first subscription: see `OperatorMulticast` and `OperatorPublish`.
 =||= I can have a look at making this happen if someone isn't working on it already.
 =||= @davidmoten I'm working on something else so you can go ahead.
 =||= Was merged in https://github.com/ReactiveX/RxJava/pull/2779
 =||= `OperatorPublish` has not been done yet, I'll open up a new issue.
 =||= ,0
2788,2775,Confused by behavior of publish+flatten,RxScala 0.23.1 (that means RxJava 1.0.4)

``` scala
import rx.lang.scala.Observable

val o1 = Observable.just(1, 2, 3)
val o2 = Observable.just(10, 20, 30)
val o3 = Observable.just(100, 200, 300)

val roundRobinSource = o1.publish(po1 ⇒ o2.publish(po2 ⇒ o3.publish(po3 ⇒ {
  def oneRound: Observable[Int] = po1.take(1) ++ po2.take(1) ++ po3.take(1)
  Observable.just(oneRound, oneRound, oneRound, oneRound, oneRound).flatten
})))
roundRobinSource.subscribe(println, println)
```

gives me

```
1
10
100
1
20
200
1
30
300
1
1
```

That just bemuses me. Why am I getting an infinite stream of ones for the first observable, but for the others it seems OK. And I'm not even sure that the behavior of others is what I'd expect according to the documentation stating that `publish` _Returns a rx.lang.scala.observables.ConnectableObservable, which waits until the connect function is called before it begins emitting items from this rx.lang.scala.Observable to those rx.lang.scala.Observers that have subscribed to_. It probably is OK, it is just that I'm not able to deduce from that documentation that `publish` is somehow internally keeping track of which items from the published observable have already been emitted and which not even in case of resubscribing to it multiple times...

Can someone enlighten me on this, please?,I think it's because #2596: When zero subscriber, publish will cache values.
 =||= ,0
2804,2773,ObserveOn performance improvements,Further optimizations to `observeOn`.
- Using SpscArrayQueue directly in observeOn instead of `RingBuffer` to avoid the synchronization block
- Split tracking structure to serial (SubscriptionList) and timed (CompositeSubscription) in `EventLoopsScheduler` which improves the sequential scheduling performance because a completing task's subscription will be most likely the first item in the underlying LinkedList.

Benchmark: (i7 920, Window 7 x64, Java 1.8u31, 5x1s warmup, 5x5s iteration)

```
Benchmark      (size)         1.x    1.x error      this PR   this error
observeOn           1  162326,012     2458,085   166536,559     3154,174
observeOn          10  132471,205     1857,434   142517,407     3734,424 ++
observeOn         100   43282,527     2145,910   112238,179     2270,103 ++
observeOn        1000   11779,482      173,370    25726,564      309,193 ++
observeOn        2000    6756,211       89,196    12123,276      276,470 ++
observeOn        3000    4736,893      253,796     9342,673      263,667 ++
observeOn        4000    3661,874       51,359     7346,015      123,049 ++
observeOn       10000    1519,282      108,503     1546,547       21,885
observeOn      100000     151,193        2,569      156,160        1,974
observeOn     1000000      15,373        1,310       15,660        0,153
subscribeOn         1  161290,037     2867,882   164952,259      797,408
subscribeOn        10  151842,821     2448,734   147906,491     4373,682
subscribeOn       100  136418,065     1773,558   136889,052     2362,203
subscribeOn      1000   58389,066     4559,030    59482,225     1372,692
subscribeOn      2000   34089,152     9318,205    36581,203     1264,100
subscribeOn      3000   26712,331     1265,442    26519,320     1319,293
subscribeOn      4000   20118,326     2018,439    20163,395      839,709
subscribeOn     10000    8914,213      677,164     9059,934      200,158
subscribeOn    100000     958,038       43,349      965,663       60,708
subscribeOn   1000000      91,849        2,148       92,706        1,202
```

Notes:
- At `size = 1`, the throughput varies in a +/- 3000 range on each run, and since the changes don't touch the scalar optimization, there is no real improvement there.
- At `size = 10.000` my system reached either the cache capacity or the OS scheduler's time resolution so there no improvement there on.
- At `size = 100.000` and `size = 1.000.000` the throughput doubles if I introduce some extra delay (i.e., via sleep(1) or some extra work).
- The benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput `subscribeOn(1.000.000)` from 91 to 136. 

Since it conflicts with #2772 anyway, this is PR is to let others verify the optimizations actually work on other OSes, because on my Windows, I sometimes get significant variance in the throughput during iterations. Increased iteration time may be required as well.,Benchmark (i7 4770K, Windows 7 x64, Java 1.8u31) PR up to 366598a

```
Benchmark      (size)         1.x      1.x error      this PR    this error
observeOn           1    204372,986    45147,750    207462,343     3348,429
observeOn          10    170321,219    30519,528    180349,729     9635,029
observeOn         100     66150,820     3911,887    151773,980     8819,016
observeOn        1000     11387,782     3620,545     28427,477     8108,015
observeOn        2000      7180,268      899,369     15044,075     2107,491
observeOn        3000      4458,529     1949,745     10050,448     1945,057
observeOn        4000      3294,942     2865,810      4627,753      369,396
observeOn       10000      1509,448      646,732      3331,416      302,650
observeOn      100000       184,213       21,344       385,208        4,621
observeOn     1000000        18,447        1,594        21,572        0,221
subscribeOn         1    198566,731    26191,145    204882,731     7505,171
subscribeOn        10    194194,868     7907,757    193459,202     8645,835
subscribeOn       100    160472,849    75535,431    147738,528    61057,919
subscribeOn      1000     69123,783    51116,790     88955,619    25329,057
subscribeOn      2000     41765,423    58779,642     54281,820    25307,480
subscribeOn      3000     42094,519    14935,575     46571,429     3136,216
subscribeOn      4000     28593,237    31337,648     35484,209     5793,749
subscribeOn     10000     11492,688     7818,150     13295,895     5687,375
subscribeOn    100000       911,157      311,834       973,503       33,258
subscribeOn   1000000       169,743       37,696       176,479       22,568
```

Strangely, adding an innocent isUnsubscribed check breaks 4 tests, don't know why yet.
 =||= Switching to j.u.c.Lock in SubscriptionList benefits the observeOn because its spinning behavior (less likely to park/unpark a thread which may take 3ms on Windows). But unfortunately, it introduces higher variance on small subscribeOn runs.

```
Benchmark      (size)         1.x      1.x error      this PR    this error
observeOn           1    204372,986    45147,750    202173,732    12320,313
observeOn          10    170321,219    30519,528    182154,095    11144,205
observeOn         100     66150,820     3911,887    153120,079    10437,195
observeOn        1000     11387,782     3620,545     29951,053     3853,397
observeOn        2000      7180,268      899,369     13866,119     4136,655
observeOn        3000      4458,529     1949,745      9109,964     2767,763
observeOn        4000      3294,942     2865,810      7439,672      781,102
observeOn       10000      1509,448      646,732      1893,761      165,063
observeOn      100000       184,213       21,344       221,382        7,028
observeOn     1000000        18,447        1,594        43,000        0,351
subscribeOn         1    198566,731    26191,145    204402,609     4919,448
subscribeOn        10    194194,868     7907,757    183619,836    28797,890
subscribeOn       100    160472,849    75535,431    147244,447   101925,905
subscribeOn      1000     69123,783    51116,790     84392,086    55782,068
subscribeOn      2000     41765,423    58779,642     60341,991    17596,950
subscribeOn      3000     42094,519    14935,575     42439,368    11841,639
subscribeOn      4000     28593,237    31337,648     35660,124     5625,456
subscribeOn     10000     11492,688     7818,150     13021,675     1460,180
subscribeOn    100000       911,157      311,834      1664,599      332,131
subscribeOn   1000000       169,743       37,696       180,759       21,844
```
 =||= These are the results if the range is replaced by a [value repeater](https://gist.github.com/akarnokd/fdac1948f34c0a0b991d):

```
Benchmark      (size)         1.x      1.x error    1.x no box       error    this no box     error
observeOn           1    204372,986    45147,750    188819,849    15431,568    181595,983    14377,740
observeOn          10    170321,219    30519,528    177593,605    12877,222    175087,705    18256,765
observeOn         100     66150,820     3911,887     68652,045     1711,296    144814,588    20151,322
observeOn        1000     11387,782     3620,545     14779,159      989,993     19994,914     2982,607
observeOn        2000      7180,268      899,369      8075,593      929,669      9877,035      560,081
observeOn        3000      4458,529     1949,745      5235,137      463,936      6393,597      605,021
observeOn        4000      3294,942     2865,810      4017,062      247,366      5045,878      133,408
observeOn       10000      1509,448      646,732      1644,436      301,704      3714,585      270,400
observeOn      100000       184,213       21,344       185,625        7,409       235,961       18,194
observeOn     1000000        18,447        1,594        20,052        1,631        24,297        0,232
subscribeOn         1    198566,731    26191,145    190542,030    87491,106    194069,237    13380,697
subscribeOn        10    194194,868     7907,757    192794,548    30258,019    183716,766    22495,251
subscribeOn       100    160472,849    75535,431    148739,487    47300,117    154242,613    63197,068
subscribeOn      1000     69123,783    51116,790     98292,952    34497,158     90132,783    54405,704
subscribeOn      2000     41765,423    58779,642     72655,350     9218,318     72559,922    14591,547
subscribeOn      3000     42094,519    14935,575     55371,153    11954,736     53789,237    12727,973
subscribeOn      4000     28593,237    31337,648     46864,543     3127,864     45835,097     4896,779
subscribeOn     10000     11492,688     7818,150     19685,490     9422,445     18831,519     7730,286
subscribeOn    100000       911,157      311,834      2225,610      154,474      2201,344      318,462
subscribeOn   1000000       169,743       37,696       257,446        7,753       257,803       11,236
```

Note that size = 1 doesn't run the optimized scalar scheduling code.
 =||= Do you mind rebasing this so we don't have the development path in the log?
 =||= I see significant performance testing on my machine:

```
1.x

Benchmark                                         (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5   113223.051     9007.330    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5    13108.671      740.532    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       15.414        0.988    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 10813751.080   943281.316    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   227083.165     9356.767    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      193.273       21.516    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    16307.144     1100.723    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     8365.615      235.292    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       16.573        0.892    ops/s


This PR

Benchmark                                         (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5   113905.358    32165.659    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5    28618.423      507.627    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       32.166        2.736    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5  8402487.179   456209.469    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   217228.990     9486.298    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      198.274       13.425    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    16996.020     2524.557    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5    11612.989      487.775    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       34.498        1.914    ops/s
```
 =||= Sure.
 =||= @akarnokd great work on all those enhancements!
 =||= ,0
2804,2772,Helper methods to schedule tasks (non-)interruptibly on an,ExecutorService. Replaces #2761.

By default, io() and newThread() schedules interruptible tasks, computation() schedules non-interruptible tasks.,I think this looks good ... but I'm trying to decouple in my head the API changes versus functional related to interrupt, as those are complicated and nuanced.

Before we proceed with this I'd like to have a clear description somewhere about our logic and thinking around interruption. 

Additionally, let's mark the API additions as Experimental.
 =||= Okay.
 =||= I'm closing this, let's revisit the problem later.
 =||= ,0
2814,2810,OperatorPublish bugs,##### Reconnect issue

The following test fails because in OperatorPublish, the `state.getOrigin()` still holds the subscriber of a previous connection:

``` java
@Test
public void testSubscribeAfterDisconnectThenConnect() {
    ConnectableObservable<Integer> source = Observable.just(1).publish();

    TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();

    source.subscribe(ts1);

    Subscription s = source.connect();

    ts1.assertReceivedOnNext(Arrays.asList(1));
    ts1.assertNoErrors();
    ts1.assertTerminalEvent();

    TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>();

    source.subscribe(ts2);

    Subscription s2 = source.connect();

    ts2.assertReceivedOnNext(Arrays.asList(1));
    ts2.assertNoErrors();
    ts2.assertTerminalEvent();

    System.out.println(s);
    System.out.println(s2);
}
```

However, it works with `share()`:

``` java
@Test
public void testShareReconnect() {
    Observable<Integer> source = Observable.just(1).share();

    TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();

    source.subscribe(ts1);

    TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>();

    source.subscribe(ts2);

    ts1.assertNoErrors();
    ts1.assertTerminalEvent();
    ts1.assertReceivedOnNext(Arrays.asList(1));

    ts2.assertNoErrors();
    ts2.assertTerminalEvent();
    ts2.assertReceivedOnNext(Arrays.asList(1));
}
```
##### connect() is racy

In addition, the `OperatorPublish.connect()` method is inherently racy: two concurrent connect calls may succeed, one kicking out the upstream subscriber of the other.
##### OriginSubscriber.requestMore may overflow

`originOutstanding.addAndGet()` may turn negative
##### Retention of subscribers after completion event.

After making all relevant fields and classes package-private, the following test fails:

``` java
@Test
public void testNoSubscriberRetentionOnCompleted() {
    OperatorPublish<Integer> source = (OperatorPublish<Integer>)Observable.just(1).publish();

    TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();

    source.unsafeSubscribe(ts1);

    source.connect();

    ts1.assertReceivedOnNext(Arrays.asList(1));
    ts1.assertNoErrors();
    ts1.assertTerminalEvent();

    assertTrue(source.requestHandler.state.subscribers.length == 0 
            && source.requestHandler.state.ss.isEmpty());
}
```

Note that blindly evicting values from ss while completing in drainQueues() is wrong too, because if there is a concurrent subscription in the works, its tracking recod in state.ss and subscribers may get deleted as well, instead of letting it wait for the next connect().

/cc @davidmoten: please look at these issues while you fix OperatorPublish for #2803.,The operator has been fixed. Closing.
 =||= ,0
2814,2803,OperatorPublish connect(connection) should not return null,This is outstanding work from #2774.  I can have a go at it next week if no-one in a rush.,If you don't mind some Reactive-Streams style code, you can look at my [OperatorPublish](https://github.com/akarnokd/RxJavaFlow/blob/master/src/main/java/rx/internal/operators/OperatorPublish.java) which definitely doesn't return null on connec, but due to the half-finished project, I can't run all tests relying on it. 
 =||= Looks to me that `OperatorPublish` needs a good chunk of rework (#2810) and that the ReactiveStreams code could be basis for a rewrite. I'd be happy to have a go at this but haven't much time on my hands this week and anyway it might make more sense for @akarnokd to do it as he's so familiar with the subject already (and would probably do it in the blink of an eye).
 =||= I'll add this to my todo list for this week.
 =||= The operator has been rewritten so it never returns null. Closing.
 =||= ,0
2845,2844,ConcatMap combined with Delay causes a hang,The following code:

``` java
public class Test {
    public static void main(final String[] arg) throws Exception {
        Observable.just(1)
                .repeat()
                .concatMap(x -> {
                    System.out.println(x);
                    return Observable.empty()
                            .delay(1, TimeUnit.SECONDS);
                })
                .subscribe();

        Thread.sleep(Long.MAX_VALUE);
    }
}
```

Prints out two "1"s quickly, and then another "1" every second afterward.

If you change that code just slightly two use the two argument form of `just()` as in:

``` java
public class Test {
    public static void main(final String[] arg) throws Exception {
        Observable.just(1, 2)
                .repeat()
                .concatMap(x -> {
                    System.out.println(x);
                    return Observable.empty()
                            .delay(1, TimeUnit.SECONDS);
                })
                .subscribe();

        Thread.sleep(Long.MAX_VALUE);
    }
}
```

Then, it prints "1", then "2", and then hangs and doesn't do anything afterward.

I have no idea whats going on, but, I don't think that the 2nd piece of code should hang if the first one doesn't.

I tested with 1.0.8 and didn't find any similar looking issue with a quick look.,Thanks. This is a bug with `repeat()` and the fix is in #2845.
 =||= ,0
2851,2850,Using merge() with throttleWithTimeout() leads to MissingBackpressureException,Repro: https://bitbucket.org/marshallpierce/rxjava-merge-backpressure

In text, here's what I'm doing: I have two observables: `Observable.never()`, and another that emits every 200ms. I `merge()` those two and `throttleWithTimeout()` the result with a long timeout. In a few seconds, I'll get this:

```
rx.exceptions.MissingBackpressureException
    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:349)
    at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:721)
    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:698)
    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:586)
    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.onNext(SubjectSubscriptionManager.java:224)
    at rx.subjects.PublishSubject.onNext(PublishSubject.java:114)
    at org.mpierce.rxjava.merge.ExperimentMain.lambda$main$0(ExperimentMain.java:25)
    at org.mpierce.rxjava.merge.ExperimentMain$$Lambda$1/1685538367.call(Unknown Source)
    at rx.Scheduler$Worker$1.call(Scheduler.java:120)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
```

Instead, I would expect that the combo of merge & throttle should simply result in throttle working as expected (never emitting, in this case).,Inserting a PublishSubject between the merge and throttle calls leads to normal operation (no backpressure exception).
 =||= I've been looking into this with Marshall, here's some more oddities:

```
Observable.interval(200, MILLISECONDS)
    .mergeWith(Observable.just(500L))
    .debounce(500, MILLISECONDS)
    .observeOn(Schedulers.newThread())
    .subscribe(
        (i) -> System.out.println("Got " + i),
        (t) -> {
            t.printStackTrace();
        }
    );
```

If you remove mergeWith, debounce, or observeOn, it works fine. All three are needed to create a failure situation.

What's weirder is that, given the 200ms interval but 500ms debounce, the subscriber should basically never get onNext (by my understanding). Yet it actually does start to emit items (before the backpressure error kicks in).
 =||= Oh, and one other thing: I tried using an `DebugHook` from RxJavaDebug to look into the situation, but with the hook attached it worked fine, which mystifies me further.
 =||= Could you test #2851?
 =||= The change in #2851 prevents the error I'm seeing.
 =||= @marshallpierce thanks for confirming it.
 =||= @benjchristensen can we get #2851  into v 1.0.9 . :) 
 =||= @yogurtearl merged.
 =||= ,0
2852,2826,Why retry method with predicate only retries 2 times?,Hi, can somebody explain me why following piece of code printing only two times message "Retrying"? And not 5 times as specified in predicate?
BTW if i uncomment doOnError line in this sample - i got 5 times message "Retrying".
Any ideas what's going on here?

```
Observable.just(1)
                .map(value -> { throw new RuntimeException("You shall not pass"); })
//                .doOnError(t -> System.out.println("Handling error"))
                .retry((counter, throwable) -> {
                    System.out.println("Retrying");
                    return counter < 5;
                })
                .toBlocking()
                .single();
```,The bug has been fixed through #2852. Closing.
 =||= ,0
2854,2853,AbstractOnSubscribe throws exception when onNext contains a request for more ,`AbstractOnSubscribe` improperly throws an exception when the `onNext` method in a subscriber makes a call to `request` (all calls synchronous). The error thrown is this:

```
java.lang.IllegalStateException: This is not reentrant nor threadsafe!
    at rx.observables.AbstractOnSubscribe$SubscriptionState.use(AbstractOnSubscribe.java:590)
    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:360)
    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:345)
    at rx.Subscriber.request(Subscriber.java:145)
    at rx.observables.AbstractOnSubscribeTest$20.onNext(AbstractOnSubscribeTest.java:541)
    at rx.observables.AbstractOnSubscribeTest$20.onNext(AbstractOnSubscribeTest.java:1)
    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:130)
    at rx.observables.AbstractOnSubscribe$SubscriptionState.accept(AbstractOnSubscribe.java:533)
    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:367)
    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:337)
    at rx.Subscriber.setProducer(Subscriber.java:175)
    at rx.Subscriber.setProducer(Subscriber.java:171)
    at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:191)
    at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:1)
    at rx.Observable.subscribe(Observable.java:7585)
    at rx.observables.AbstractOnSubscribeTest.testCanRequestInOnNext(AbstractOnSubscribeTest.java:527)
```

Here's a failing unit test:

``` java
    @Test
    public void testCanRequestInOnNext() {
        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
            @Override
            protected void next(SubscriptionState<Integer, Void> state) {
                state.onNext(1);
                state.onCompleted();
            }
        };
        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
        aos.toObservable().subscribe(new Subscriber<Integer>() {

            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {
                exception.set(e);
            }

            @Override
            public void onNext(Integer t) {
                request(1);
            }
        });
        if (exception.get()!=null)
            exception.get().printStackTrace();
        assertNull(exception.get());
    }
```,nan,0
2875,2874,concatMap + observeOn throws a NullPointerException sometimes,It is difficult to produce this one. It occurs in our production service, which has a code almost like this:

``` java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import rx.Observable;
import rx.functions.Action1;
import rx.functions.Func1;
import rx.schedulers.Schedulers;
import rx.subjects.PublishSubject;
import rx.subjects.Subject;

/**
 * @author Ashish.Tyagi
 */
public class Test {
    public static void main(String[] args) throws InterruptedException {
        Subject<Integer, Integer> subject = PublishSubject.create();
        ExecutorService executor = Executors.newFixedThreadPool(1);

        subject.concatMap(new Func1<Integer, Observable<? extends Integer>>() {
            @Override
            public Observable<? extends Integer> call(Integer t) {
                return Observable.just(t);
            }
        }).observeOn(Schedulers.from(executor)).subscribe(new Action1<Integer>() {
            @Override
            public void call(Integer t) {
                if (t % 1000 == 0) {
                    System.out.println(t);
                }
            }
        });

        for (int i = 0; i < 10000000; i++) {
            subject.onNext(i);
        }
        subject.onCompleted();

        executor.shutdown();
        executor.awaitTermination(5, TimeUnit.MINUTES);
    }
}

```

```
Foolowing is the exception thrown:
Exception in thread "serviceExecutor-1" java.lang.NullPointerException
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.requestFromChild(OperatorConcat.java:129)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.access$100(OperatorConcat.java:78)
    at rx.internal.operators.OperatorConcat$ConcatProducer.request(OperatorConcat.java:73)
    at rx.Subscriber.request(Subscriber.java:141)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:207)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:65)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:155)
    at rx.schedulers.ExecutorScheduler$ExecutorAction.run(ExecutorScheduler.java:173)
    at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:99)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:745)
```,Thanks. The issue is with the volatile variable `currentSubscriber` being read several times and it can become null  if the request and completion happen at the same time.
 =||= Closed via #2875 
 =||= Thanks! The issue does not produce any longer.
 =||= ,0
2883,2458,Lifting into a Subject,Mildly interesting idea to see if there would be any interest.

```
public class Subject<T, R> extends Observable<R> implements Observer<T> {
    ...
    public <X> Subject<X, R> liftHead(final Operator<? extends T, ? super X> op) { ... }
    public <X> Subject<T, X> liftTail(final Operator<? extends X, ? super R> op) { ... }

    @Override
    public <X> Subject<T, X> lift(final Operator<? extends X, ? super R> op) { return liftTail(op); }
}
```,What do you want to achieve with this change?
 =||= Up till now all the APIs that want to delegate part of the observable change chain to another piece of code has had to pass in the head as an argument.  With these methods the delegate could return a subject the represents the some segment of the chain without any arguments.

For example `retryWhen()` takes a notification handler `Func1<Observable<Exception>, Observable<?>>`.  With this it would have been possible for `retryWhen` to take a notification handler `Func0<Subject<Exception, ?>`
 =||= If I understand correctly, a chain of Subject<Integer, String> -> Subject<String, Date> -> Subject<Date, Long>, I can hand out each to different parties and observe them at any point?
 =||= Yes.  The `Subject` returned could be reused to `subscribe()` different source observables.  The `Subject` would just be an capsulation of some computation without defining where the data comes from or where it is going to.
 =||= The encapsulation of computation sounds like the Transformer with Observable.compose. 
 =||= Do you still want to pursue this?
 =||= Punting to 2.0 for bikeshedding.
 =||= See #3975.
 =||= I'm closing this as the PR implementing the proposed feature was not really endorsed by the OP after all. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.
 =||= ,0
2894,2890,Stack overflow with a combination of BufferTillSubscriber, subscribeOn and concatMap,The following test code eventually fails with a StackOverFlowException, provided a sufficient large value of n.

``` java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import rx.Observable;
import rx.Subscriber;
import rx.functions.Func1;
import rx.internal.operators.BufferUntilSubscriber;
import rx.schedulers.Schedulers;
import rx.subjects.Subject;


/**
 * @author Ashish.Tyagi
 */
public class Test {
    public static void main(String[] args) throws InterruptedException {
        final ExecutorService executor = Executors.newFixedThreadPool(2);

        Func1<Integer, Observable<Integer>> func = new Func1<Integer, Observable<Integer>>() {
            @Override
            public Observable<Integer> call(Integer t) {
                Observable<Integer> observable = Observable.just(t).subscribeOn(Schedulers.from(executor));
                Subject<Integer, Integer> subject = BufferUntilSubscriber.create();
                observable.subscribe(subject);
                return subject;
            }
        };

        int n = 10000;

        Observable.range(1, n).concatMap(func).subscribe(new Subscriber<Integer>() {
            @Override
            public void onNext(Integer t) {
                // Consume after sleep for 1 ms
                sleep();
                System.out.println(t);
            }

            @Override
            public void onCompleted() {
                executor.shutdown();
            }

            @Override
            public void onError(Throwable e) {
                executor.shutdown();
            }
        });

        executor.awaitTermination(1, TimeUnit.MINUTES);
    }

    private static void sleep() {
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            // Ignore
        }
    }
}
```,Printing a portion of the stack trace.

```
Exception in thread "pool-1-thread-2" java.lang.StackOverflowError
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetTail(AbstractQueuedSynchronizer.java:2309)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.enq(AbstractQueuedSynchronizer.java:591)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.transferForSignal(AbstractQueuedSynchronizer.java:1682)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.doSignal(AbstractQueuedSynchronizer.java:1877)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.signal(AbstractQueuedSynchronizer.java:1944)
    at java.util.concurrent.LinkedBlockingQueue.signalNotEmpty(LinkedBlockingQueue.java:172)
    at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue.java:429)
    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1364)
    at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.schedule(ExecutorScheduler.java:81)
    at rx.internal.util.ScalarSynchronousObservable$NormalScheduledEmission.call(ScalarSynchronousObservable.java:95)
    at rx.internal.util.ScalarSynchronousObservable$NormalScheduledEmission.call(ScalarSynchronousObservable.java:82)
    at rx.Observable.subscribe(Observable.java:7585)
    at rx.Observable.subscribe(Observable.java:7454)
    at Test$1.call(Test.java:25)
    at Test$1.call(Test.java:1)
    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)
    at rx.internal.operators.OnSubscribeRange$RangeProducer.request(OnSubscribeRange.java:93)
    at rx.Subscriber.request(Subscriber.java:145)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:160)
    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)
    at rx.Observable.unsafeSubscribe(Observable.java:7495)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)
    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)
    at rx.Observable.unsafeSubscribe(Observable.java:7495)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)
    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)
    at rx.Observable.unsafeSubscribe(Observable.java:7495)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)
    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)
    at rx.Observable.unsafeSubscribe(Observable.java:7495)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)
    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)
    at rx.Observable.unsafeSubscribe(Observable.java:7495)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)
    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)
    at rx.Observable.unsafeSubscribe(Observable.java:7495)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)
    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)
    at rx.Observable.unsafeSubscribe(Observable.java:7495)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)
    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)
    at rx.Observable.unsafeSubscribe(Observable.java:7495)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)
    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:110)
    at rx.internal.operators.BufferUntilSubscriber$OnSubscribeAction.call(BufferUntilSubscriber.java:81)
    at rx.Observable.unsafeSubscribe(Observable.java:7495)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.subscribeNext(OperatorConcat.java:176)
    at rx.internal.operators.OperatorConcat$ConcatSubscriber.completeInner(OperatorConcat.java:163)
    at rx.internal.operators.OperatorConcat$ConcatInnerSubscriber.onCompleted(OperatorConcat.java:225)
```
 =||= Thanks for reporting. Can you try if PR #2894 fixes the problem for you as well?
 =||= Hi, I think it worked. I do not see the exception any longer, even with very large n. Thanks.
 =||= Thanks for confirming. Closing via #2894.
 =||= ,0
2897,289,Fixes on #284 (groupBy),See my previous [comment](https://github.com/Netflix/RxJava/issues/282#issuecomment-19013992).,[RxJava-pull-requests #163](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/163/) SUCCESS
This pull request looks good
 =||= I apologize for not being able to act on this right now, I've been swamped with other work but I will definitely return to this once I get through my other work!
 =||= squash into a single commit then check with @benjchristensen.  LGTM
 =||= [RxJava-pull-requests #170](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/170/) SUCCESS
This pull request looks good
 =||= Hi Ben et alii,

Regarding the issues at the end of the [previous discussion](https://github.com/Netflix/RxJava/issues/282#issuecomment-19013992), I mentioned the quirks I found to Erik, who actually considered the current terminating behaviour of `groupBy` in Rx.Net (which is similar to RxJava's) to be undesirable. His opinion was that when one unsubscribes from the GroupBy observable, one should still be able to subscribe to the GroupedObservables that were emitted before, because otherwise seemingly unrelated actions can cause unexpected changes in behaviour. His example was like this:

```
source.groupBy(x -> x%2)
    .take(2)
    .subscribe(group -> {
        new Thread(() -> {
            group.subscribe(someObserver);
        }).start();
    };
```

In this example, the take(2) may cause termination of the groupBy's upstream subscription because the GroupedObservables still have no subscribers. It actually creates a race between the spawned and spawning thread.

I guess the solution to this would be to not automatically terminate the upstream subscription when one might still connect to a GroupedObservable. This would lead to some memory pollution if the stream is infinite and not terminated manually (for example using `takeWhile`).
A nice solution could perhaps be to do some juggling with weak references in order to detect when all emitted GroupedObservables have been forgotten about by the rest of the program, in which case the upstream subscription may be ended too (if the primary observer already unsubscribed, of course).
 =||= I tried looking at this again this morning but again ran out of time trying to understand what the issue is and what is being fixed ... it's still on my list for a more focused review at some point.
 =||= Here's another problem with groupBy:

This code

``` scala
val firstOnly = false
val numbersByModulo3 = Observable.interval(1000 millis).take(9).groupBy(_ % 3)

(for ((modulo, numbers) <- numbersByModulo3) yield {
  println("Observable for modulo" + modulo + " started")

  if (firstOnly) numbers.take(1) else numbers
}).merge.toBlockingObservable.foreach(println(_)) 
```

outputs if `val firstOnly = false` this (expected):

```
Observable for modulo0 started
0
Observable for modulo1 started
1
Observable for modulo2 started
2
3
4
5
6
7
8
```

and if `val firstOnly = true`, it outputs this (unexpected):

```
Observable for modulo0 started
0
```

But I would expect that it takes the first element of each modulo class:

```
Observable for modulo0 started
0
Observable for modulo1 started
1
Observable for modulo2 started
2
```
 =||= Can anyone start from scratch on reviewing this and providing feedback?

@headinthebox Can you also provide input on what the behavior should be compared to Rx.Net? You've mentioned to both @Treora and myself that you feel something is wrong with the Rx.Net implementation, so I'd like to know what unit tests we should have so we can change RxJava to match the correct functionality.
 =||= Hi,
As @headinthebox appears to not have replied yet I will try to answer. From what I know, the only issue is that it is impossible to subscribe to `GroupedObservables` after their producer has terminated. I think I explained the whole issue earlier in this thread: https://github.com/Netflix/RxJava/pull/289#issuecomment-20248743

The reason why it is like this in Rx.Net is because there seems to be no elegant solution to this issue. The point is that the `GroupBy` observable cannot know whether or not, at some point in the future, somebody will subscribe to one of the `GroupedObservable`s that it has emitted. Therefore it cannot know whether or not it can unsubscribe from its source. The easy solution would be to simply not unsubscribe at all, but with the drawback that unused streams will also stay alive for eternity, if not terminated further upstream.

Let me know if you would like me to explain more. My work involving RxJava finished, but it would be nice if this issue will be fixed. Also, it seems these fixes I wrote (#289) have still not been merged, so doing that could already fix some bugs. If then the small issue mentioned in point 2 in https://github.com/Netflix/RxJava/issues/282#issuecomment-19013992 is also fixed, the RxJava implementation should be at least as good as the current Rx.Net implementation (or probably a bit better, as their code looks somewhat buggy too, as mentioned before).
 =||= @zsxwing Since you have become familiar with a lot of the codebase, if you want to help tackle this I'd appreciate it.
 =||= @benjchristensen I'll try to solve it.
 =||= Thanks @zsxwing 
 =||= I've implemented GroupByUntil (#528) which can be turned into GroupBy by using `Observable.never()` as its group duration selector. With the recent PublishSubject fixes, any "escaped" group will either onCompleted() or onError()'d if the main source has been terminated. So given the example:

```
source.groupBy(x -> x%2)
    .take(2)
    .subscribe(group -> {
        new Thread(() -> {
            group.subscribe(someObserver);
        }).start();
    };
```

someObserver will likely get just an onCompleted().

If I understand the problem correctly, you'd want to receive Xs for the first two groups until they cancel, even if there won't be any new groups due to take(2). How about:

```
source.groupBy(x -> x % 2).take(2)
   .subscribe(group -> 
     new Thread(() ->
        source.where(a -> a % 2 == group.getKey())
        .subscribe(someObserver)))
```

This way we'll know what the first two group keys would be, then filter the source based on that in each group. However, lets assume source emits `System.currentTimeMillis()` in which case the someObserver receives different Xs that were used in creating the groups. To fix that, we would need source to be replayable:

```
ConnectableObservable co = source.replay();
co.groupBy(x -> x % 2).take(2)
   .subscribe(group -> 
     new Thread(() ->
        co.where(a -> a % 2 == group.getKey())
        .subscribe(someObserver)))

Subscription s0 = co.connect();
Thread.sleep(1000); // or other wait mechanism
s0.unsubscribe();
```
 =||= Closing this and it will be addressed via https://github.com/Netflix/RxJava/issues/570
 =||= ,0
2898,2884,Backpressure and onComplete from an empty observable,What is the _preferred_ behaviour for an observable that supports backpressure but emits nothing when it has been subscribed to with an initial request of 0? Should it report completion as soon as it knows it is empty or wait for a positive request? 

I notice that reactive-streams-jvm 2.9 says

> A Subscriber MUST be prepared to receive an onComplete signal with or without a preceding Subscription.request(long n) call.

This allows us to go either way when developing an `Operator` for instance but perhaps RxJava wants to proffer a preferred or mandated direction for it's internal operators? @benjchristensen 

FYI @viktorklang ,`from` and `range` already emit `onCompleted` if they are essentially empty or just after the last item so I think that should stay as the behavior.
 =||= I don't thinks that's the case for `from`. Its `Producer` does nothing at all if request is 0.
 =||= Same for `range`.
 =||= @davidmoten you're right, I just checked the code.
 =||= Hi @davidmoten,

since `request` is for `elements` and `complete` and `error` are not elements,
it is intended for these signals to be propagated as soon as they are known.

Let me know if you have any follow-on questions!
 =||= Thanks @viktorklang. Do you think that intention should be a SHOULD addition to the Publisher rules in reactive-streams-jvm?
 =||= Given that 2.9 already provisions for this I think a good compromise (I am not a fan of SHOULDs in general) to include this explanation as a part of https://github.com/reactive-streams/reactive-streams-jvm/issues/177

Would that cover it?
 =||= Sounds fine, thanks. 
 =||= @davidmoten Great. I'd like to take the opportunity to encourage you to assist with that Issue, if you have any cycles to spare. :)
 =||= @akarnokd as you suspected originally `range` does emit `onCompleted` eagerly from an empty range. `from` does not emit `onCompleted` eagerly from an empty iterable so I submitted #2899.
 =||= Seems to be fixed. Closing.
 =||= ,0
2899,2884,Backpressure and onComplete from an empty observable,What is the _preferred_ behaviour for an observable that supports backpressure but emits nothing when it has been subscribed to with an initial request of 0? Should it report completion as soon as it knows it is empty or wait for a positive request? 

I notice that reactive-streams-jvm 2.9 says

> A Subscriber MUST be prepared to receive an onComplete signal with or without a preceding Subscription.request(long n) call.

This allows us to go either way when developing an `Operator` for instance but perhaps RxJava wants to proffer a preferred or mandated direction for it's internal operators? @benjchristensen 

FYI @viktorklang ,`from` and `range` already emit `onCompleted` if they are essentially empty or just after the last item so I think that should stay as the behavior.
 =||= I don't thinks that's the case for `from`. Its `Producer` does nothing at all if request is 0.
 =||= Same for `range`.
 =||= @davidmoten you're right, I just checked the code.
 =||= Hi @davidmoten,

since `request` is for `elements` and `complete` and `error` are not elements,
it is intended for these signals to be propagated as soon as they are known.

Let me know if you have any follow-on questions!
 =||= Thanks @viktorklang. Do you think that intention should be a SHOULD addition to the Publisher rules in reactive-streams-jvm?
 =||= Given that 2.9 already provisions for this I think a good compromise (I am not a fan of SHOULDs in general) to include this explanation as a part of https://github.com/reactive-streams/reactive-streams-jvm/issues/177

Would that cover it?
 =||= Sounds fine, thanks. 
 =||= @davidmoten Great. I'd like to take the opportunity to encourage you to assist with that Issue, if you have any cycles to spare. :)
 =||= @akarnokd as you suspected originally `range` does emit `onCompleted` eagerly from an empty range. `from` does not emit `onCompleted` eagerly from an empty iterable so I submitted #2899.
 =||= Seems to be fixed. Closing.
 =||= ,0
2909,2908,Non-deterministic test: RxRingBufferWithoutUnsafeTest.testConcurrency,Concurrency failure on RxRingBuffer doesn't look good. Hopefully a problem with the test only!

```
rx.internal.util.RxRingBufferWithoutUnsafeTest > testConcurrency FAILED
    java.lang.AssertionError: expected:<6920> but was:<6808>
        at org.junit.Assert.fail(Assert.java:93)
        at org.junit.Assert.failNotEquals(Assert.java:647)
        at org.junit.Assert.assertEquals(Assert.java:128)
        at org.junit.Assert.assertEquals(Assert.java:472)
        at org.junit.Assert.assertEquals(Assert.java:456)
        at rx.internal.util.RxRingBufferWithoutUnsafeTest.testConcurrency(RxRingBufferWithoutUnsafeTest.java:139)
```,Found the bug, see PR #2909.
 =||= Closed via #2909
 =||= ,0
2912,2857,Performance issues after upgrading from 1.0.4 -> 1.0.8,Hello,

We are seeing high levels of lock contention after our upgrade to RxJava 108

Apologize for not having a unit test to reproduce this we have a fairly complex system and we are having trouble figuring out which areas to dig deeper to find a reproducible case.

This is a paste from a JMC view. As far as we know nothing should be getting unsubscribed in our application. 
We would appreciate if anyone can shed some light on what kind of behavior would trigger the stack below.

```
Stack Trace Sample Count    Percentage(%)
java.util.concurrent.locks.LockSupport.unpark(Thread)   1,113   76.233
 java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor(AbstractQueuedSynchronizer$Node) 1,113   76.233
      java.util.concurrent.locks.AbstractQueuedSynchronizer.release(int)    1,113   76.233
         java.util.concurrent.locks.ReentrantLock.unlock()  1,113   76.233
            rx.internal.util.SubscriptionList.remove(Subscription)  1,113   76.233
               rx.internal.schedulers.ScheduledAction$Remover2.unsubscribe()    1,113   76.233
                  rx.internal.util.SubscriptionList.unsubscribeFromAll(Collection)  1,113   76.233
                     rx.internal.util.SubscriptionList.unsubscribe()    1,113   76.233
                        rx.internal.schedulers.ScheduledAction.unsubscribe()    1,113   76.233
                           rx.internal.schedulers.ScheduledAction.run() 1,113   76.233
                              java.util.concurrent.Executors$RunnableAdapter.call() 1,113   76.233
                                 java.util.concurrent.FutureTask.run()  1,113   76.233
                                    java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor$ScheduledFutureTask)    1,113   76.233
                                       java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run()   1,113   76.233
                                          java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor$Worker)  1,113   76.233
                                             java.util.concurrent.ThreadPoolExecutor$Worker.run()   1,113   76.233
                                                java.lang.Thread.run()  1,113   76.233

```,I guess you are scheduling a lot of work on the computation scheduler. We changed the tracking of tasks from using synchronized to j.u.c.Lock because it gives better throughput according to our JMH benchmarks. It appears task addition takes longer while holding the lock and the unsubscribe part spins and parks; most of the time, spin should be enough. Do you measure performance degradation?
 =||= We do not have formal performance benchmarks on our jobs. We autoscale our cluster based on resource utilization and we saw our cluster size go up by about 30% - 100% depending on the workload. 
To give you a bit more context we have built a reactive stream processing system that basically reads data items as they flow in and processes them on a computation threadpool using observeOn. In terms of scale the jobs seeing the most impact process  <= 10k messages/sec  of size a few kBs each
 =||= Sounds like your data rate reaches a critical frequency where the submission of new values in observeOn overlaps its drain and thus causes extra contention. The change from 1.0.4 to 1.0.8 consists of two parts: lock in SubscriptionList and the use of SubscriptionList instead of CompositeSubscription for non-timed tasks inside the computation scheduler. What is the java version you are running and can you name the virtualization environment?
 =||= Hey David,

We are on Java 8 and we running in a Mesos container inside an AWS instance
(m3-2xl series)

Thanks
Neeraj

On Mon, Apr 6, 2015 at 11:56 AM, David Karnok notifications@github.com
wrote:

> Sounds like your data rate reaches a critical frequency where the
> submission of new values in observeOn overlaps its drain and thus causes
> extra contention. The change from 1.0.4 to 1.0.8 consists of two parts:
> lock in SubscriptionList and the use of SubscriptionList instead of
> CompositeSubscription for non-timed tasks inside the computation scheduler.
> What is the java version you are running and can you name the
> virtualization environment?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/2857#issuecomment-90197209.
 =||= Thanks. Not sure what's the cause, but you could try shifting the contention by using batching before the observeOn and unbatch after it;

``` java
source.batch(4).observeOn(Scheduler.computation()).concatMap(v -> Observable.from(v))
```
 =||= That would be buffer rather than batch, right? I was going to suggest the
same thing, sounds like a fast round robin on a scheduler.

Thanks. Not sure what's the cause, but you could try shifting the
contention by using batching before the observeOn and unbatch after it;

source.batch(4).observeOn(Scheduler.computation()).concatMap(v ->
Observable.from(v))

—
Reply to this email directly or view it on GitHub
https://github.com/ReactiveX/RxJava/issues/2857#issuecomment-90212342.
 =||= @davidmoten Sure.
 =||= Hey David,
Batching is a good suggestion however that would be a breaking change

On Mon, Apr 6, 2015 at 1:02 PM, David Karnok notifications@github.com
wrote:

> @davidmoten https://github.com/davidmoten Sure.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/2857#issuecomment-90224646.
 =||= This is why I suggested using concatMap to flatten the batches again after the observeOn so your subsequent computation chain doesn't need to change.
 =||= Oops hit the send button too soon.

As I was saying adding a batch or buffer would change our public API from T
to a List<T>.

You mentioned earlier you saw significant throughput improvement in the JMH
tests can you provide more details, I am curious why the JMH tests do not
reflect the performance we see in production.
Were there any other benefits (did it resolve the issue of the NPE in merge
as well ?)

Thanks
Neeraj

On Mon, Apr 6, 2015 at 1:04 PM, Neeraj Joshi njoshi@netflix.com wrote:

> Hey David,
> Batching is a good suggestion however that would be a breaking change
> 
> On Mon, Apr 6, 2015 at 1:02 PM, David Karnok notifications@github.com
> wrote:
> 
> > @davidmoten https://github.com/davidmoten Sure.
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/ReactiveX/RxJava/issues/2857#issuecomment-90224646.
 =||= Ah ok, I see now, let me try out your suggestion. Thanks!
 =||= There are 2 PRs that did perf enhancements:

#2603, #2773

```
Benchmark                                   (size)     1.0.4      PR 2603    PR 2773
r.s.ComputationSchedulerPerf.observeOn           1  104110.926  115707.286  113905.358
r.s.ComputationSchedulerPerf.observeOn        1000    3212.434   13020.027   28618.423
r.s.ComputationSchedulerPerf.observeOn     1000000       9.508      16.559      32.166
```
 =||= I've run into this performance degradation and indeed, for some concurrency level (4+ in my case) the degradation was enormous. Could you check if PR #2912 fixes your case?
 =||= Hey David,
Our current setup doesn't lend itself to trying out a jar at scale (I can
only do local tests). I will try it out but the results may not be the same
at production scale.
Thanks for the fix.
-Neeraj

On Thu, Apr 23, 2015 at 8:56 AM, David Karnok notifications@github.com
wrote:

> I've run into this performance degradation and indeed, for some
> concurrency level (4+ in my case) the degradation was enormous. Could you
> check if PR #2912 https://github.com/ReactiveX/RxJava/pull/2912 fixes
> your case?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/2857#issuecomment-95632398.
 =||= Hey David,

Looks like the performance is back to what it used to be with release 1.0.4 after we upgraded to RxJava 1.0.10! Looks like your fixes worked
Thanks!
 =||= @neerajrj Hi and thanks for confirming.
 =||= ,0
2934,2933,Non-deterministic test - OperatorPublishTest.testObserveOn,Occurred in Travis build https://travis-ci.org/ReactiveX/RxJava/builds/61414126

```
rx.internal.operators.OperatorPublishTest > testObserveOn FAILED
    java.lang.AssertionError: expected:<1000> but was:<994>
        at org.junit.Assert.fail(Assert.java:93)
        at org.junit.Assert.failNotEquals(Assert.java:647)
        at org.junit.Assert.assertEquals(Assert.java:128)
        at org.junit.Assert.assertEquals(Assert.java:472)
        at org.junit.Assert.assertEquals(Assert.java:456)
        at rx.internal.operators.OperatorPublishTest.testObserveOn(OperatorPublishTest.java:412)
```,Will be fixed with #2928: it's the classical case when I read some state before I read the terminal indicator which opens up a window where more values may come in between the two rendering the completion check incorrect.
 =||= Fixed via #2934.
 =||= ,0
2969,1483,Backpressure: cache,The `cache` operator should support downstream backpressure. It should `request(Long.MAX_VALUE)` up but be capable of correctly responding to downstream (similar to `from(Iterable)`).

This will mean we either have to stop using `ReplaySubject` or be able to handle it with `ReplaySubject` in the mix.

The idea here is that once data is cached, it should behave as an `Iterable`. Therefore, the cache really should behave like `onBackpressureBuffer`.,See #2969
 =||= Cache officially supports backpressure from relelase 1.0.14.
 =||= ,0
2970,2799,onBackpressureBlock() causes hangs,Given this piece of code:

```
        Observable.create(subscriber -> {
            long counter = 0;

            while (counter++ < Long.MAX_VALUE) {
                System.out.println("onNext(" + counter + ")");

                if (!subscriber.isUnsubscribed()) {
                    subscriber.onNext(counter);
                } else {
                    break;
                }

                System.out.println("Subscribe.onNext(" + value + ")");
            }
        })
        .onBackpressureBlock(2)
        .subscribeOn(Schedulers.newThread())
        .observeOn(Schedulers.computation())
        .subscribe(System.out::println);
```

On version 1.0.7 above code will hang on producing element on position RxRingBuffer.SIZE + 2 (maxQueueLength):

```
...
afterOnNext(127)
onNext(128)
afterOnNext(128)
Subscribe.onNext(128)
onNext(129)
afterOnNext(129)
onNext(130)
afterOnNext(130)
onNext(131)
```

If we switch order of subscribe/observeOn (observeOn before subscribeOn) - it will work as expected :)

Also it will throw _MissingBackpressureException_ without onBackpressure\* (as expected).,One of us will take a look. Did this just start happening in 1.0.7?
 =||= I have came across this behaviour when .onBackpressureBlock() was introduced but I was not able to reproduce it nor fully understand under which circumstances  it can be observed. Now it seems that this minimal use case demonstrates this bug.
 =||= Note: lock happens on ArrayBlockingQueue in OperatorOnBackpressureBlock:58:

```
queue.put(nl.next(t));
```

queue contains maxQueueSize last produced elements just before it hangs.
 =||= Next trail: BackpressureDrainManager was requested for n = RxRingBuffer.size elements. When manager.drain() is called n+1 time requestedCount is equal to 0 in this and subsequent calls. No more request() calls were made.
 =||= The problem is `.subscribeOn(Schedulers.newThread())`. Because the new thread is blocked, the new request (https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorSubscribeOn.java#L90) won't be scheduled to run.
 =||= If I use any other scheduler I will get exactly same behaviour. Also I don't understand why order of .observeOn/.subscribeOn solves this problem.
 =||= See #2653 

>  You need to move the subscribeOn before the onBackpressureBlock.
 =||= `onBackpressureBlock` still feels so wrong. Perhaps it is too easy to break an app with it and is a failed experiment?

@zsxwing @akarnokd Is there something we can do to make this less likely to break an app, or is the addition of `onBackpressureBlock` fundamentally a bad idea?
 =||= Blocking and backpressure-continuations don't play well together: the same issue happened in #2466 with a different kind of blocking implementation. The solution is to move the subscribeOn before the blocking part (which can't be done if the very first source is the blocking one). We can put an emphasis on this fact in the javadoc of `onBackpressureBuffer` but if one isn't in control of the downstream, such downstream can introduce subscribeOn and the trouble is back. I'd say lets drop the operator for now.
 =||= +1 removing it, since it's too easy to hang an app.
 =||= Added PR #2970 which deprecates this operator, plus a javadoc update warning about the issue.
 =||= We deprecated this method. 
 =||= ,0
2972,1880,JVM Doesn't Exit On This Window Example,Something about this doesn't let the JVM exit.

``` java
package learnrxjava.examples;

import java.util.concurrent.TimeUnit;

import rx.Observable;
import rx.Subscriber;
import rx.schedulers.Schedulers;

public class FlowControlWindowExample {

    public static void main(String args[]) {
        // buffer every 500ms (using 999999999 to mark start of output)
        hotStream().window(500, TimeUnit.MILLISECONDS).take(10).flatMap(w -> w.startWith(999999999)).toBlocking().forEach(System.out::println);

        // buffer 10 items at a time (using 999999999 to mark start of output)
        hotStream().window(10).take(2).flatMap(w -> w.startWith(999999999)).toBlocking().forEach(System.out::println);

        System.out.println("Done");
    }

    /**
     * This is an artificial source to demonstrate an infinite stream that bursts intermittently
     */
    public static Observable<Integer> hotStream() {
        return Observable.create((Subscriber<? super Integer> s) -> {
            while (!s.isUnsubscribed()) {
                // burst some number of items
                for (int i = 0; i < Math.random() * 20; i++) {
                    s.onNext(i);
                }
                try {
                    // sleep for a random amount of time
                    // NOTE: Only using Thread.sleep here as an artificial demo.
                    Thread.sleep((long) (Math.random() * 1000));
                } catch (Exception e) {
                    // do nothing
                }
            }
        }).subscribeOn(Schedulers.newThread()); // use newThread since we are using sleep to block
    }

}
```

Yet this one does so it's not about the use of `Scheduler`s:

``` java
package learnrxjava.examples;
import java.util.concurrent.TimeUnit;

import rx.Observable;
import rx.Subscriber;
import rx.schedulers.Schedulers;

public class FlowControlThrottleExample {

    public static void main(String args[]) {
        // first item emitted in each time window
        hotStream().throttleFirst(500, TimeUnit.MILLISECONDS).take(10).toBlocking().forEach(System.out::println);

        // last item emitted in each time window
        hotStream().throttleLast(500, TimeUnit.MILLISECONDS).take(10).toBlocking().forEach(System.out::println);
    }

    /**
     * This is an artificial source to demonstrate an infinite stream that emits randomly
     */
    public static Observable<Integer> hotStream() {
        return Observable.create((Subscriber<? super Integer> s) -> {
            int i = 0;
            while (!s.isUnsubscribed()) {
                s.onNext(i++);
                try {
                    // sleep for a random amount of time
                    // NOTE: Only using Thread.sleep here as an artificial demo.
                    Thread.sleep((long) (Math.random() * 100));
                } catch (Exception e) {
                    // do nothing
                }
            }
        }).subscribeOn(Schedulers.newThread());
    }

}
```,The hang is caused by the interplay between the source, take and flatMap. Take terminates the window just after receiving the last observable and terminates the source which never emits an onCompleted required by the flatMap to terminate as well. Adding an s.onCompleted() after the while loop makes the app terminate properly.
 =||= If it unsubscribe though it shouldn't need an `onComplete`. This suggests to me there is an issue inside `window`. 
 =||= flatMap  hangs because there is no one to call onCompleted on the last BufferUntilSubscriber being merged by flatMap. So if window is unsubscribed, it has to send out onCompleted events to all of the open windows just in case.
 =||= Do we still want to pursue this?
 =||= I think I found the problem: window(time) didn't defer the child unsubscription properly. See #2972 for the resolution.
 =||= Should be fixed.
 =||= ,0
2983,2979,Subscriber.onStart is called twice on nested unsafeSubscription,This test shows the onStart called twice problem. It is a clone of SubscriberTest.testOnStartCalledOnceViaUnsafeSubscribe but adding the defer operator which calls unsafeSubscribe resulting in a nested call to unsafeSubscribe, the one from the test and the second one from OnSubscribeDefer.

``` java
@Test
public void testOnStartCalledOnceViaNestedUnsafeSubscribe() {
    final AtomicInteger c = new AtomicInteger();
    Observable.defer(new Func0<Observable<Integer>>() {
        @Override public Observable<Integer> call() {
            return Observable.just(1, 2, 3, 4).take(2);
        }
    }).unsafeSubscribe(new Subscriber<Integer>() {
        @Override public void onStart() {
            c.incrementAndGet();
            request(1);
        }

        @Override public void onCompleted() { }

        @Override public void onError(Throwable e) { }

        @Override public void onNext(Integer t) {
            request(1);
        }
    });

    assertEquals(1, c.get());
}
```

Two proposed solutions (first one looks ugly, second one adds more code to Subscriber)
1. Add a parameter to subscription calls to transfer the 'onStart called' state.
2. Modify Subscriber so .subscribe() .unsafeSubscribe() calls Subscriber.start() which delegates to the  actual .onStart() protecting for duplicate calls.,Thanks for discovering this.

With a little overhead, it is possible to suppress the second `onStart` call in defer by wrapping the subscriber with another subscriber that does nothing in its `onStart`. Would you like to submit a PR?
 =||= In fact, many other operators suffer from the same issue. You can discover them by altering Subscriber and running the standard tests:

``` java
final AtomicInteger once = new AtomicInteger();
// ...
public void onStart() {
    if (once.getAndIncrement() > 0) {
        throw new IllegalStateException();
    }
}
```
 =||= Closing because has been solved by #2983. Thanks!
 =||= ,0
2985,2870,Non-deterministic test: OperatorSerializeTest.testMultiThreadedWithNPEinMiddle,Took ~5 loops of `./gradlew clean test` to show itself:

```
java.lang.AssertionError
    at org.junit.Assert.fail(Assert.java:92)
    at org.junit.Assert.assertTrue(Assert.java:43)
    at org.junit.Assert.assertTrue(Assert.java:54)
    at rx.internal.operators.OperatorSerializeTest.testMultiThreadedWithNPEinMiddle(OperatorSerializeTest.java:134)
```,Looks fixed in merged PRs.
 =||= ,0
2997,2930,OnSubscribeRedo - fix race conditions,While searching for the cause of #2863 I bumped into this race condition (which doesn't fix #2863):

If a request is made between L238 and L239 then `consumerCapacity` may become `Long.MAX_VALUE` on arriving at L239 in which case we don't wish to decrement it. To fix, used `compareAndSet`.

What is interesting about this fix is that in the test loop of 5000 in `OperatorRetryTest` I see many more occurrences of the failure on average (3 -> 50) presumably because the extra time to perform the  `compareAndSet` action has expanded the window for the race condition causing the failures.,Awesome, for once I'm happy to see a CI failure! Tilll now #2863  hasn't been repeatable except on my laptop but now has reappeared in the Travis build.
 =||= If I put in this, I get the missing emission problem:

``` java
long cc = consumerCapacity.get();
if (cc < Long.MAX_VALUE) {
    consumerCapacity.compareAndSet(cc, cc - 1);
}

if (rnd.nextDouble() < 0.25) {
    try {
        Thread.sleep(1);
    } catch (InterruptedException ex) {
        ex.printStackTrace();
    }
}

child.onNext(v);
```

If I swap the operations, the test passes for me again.

Could you also update the helper method in the test?

``` java
static <T> StringBuilder sequenceFrequency(Iterable<T> it) {
        StringBuilder sb = new StringBuilder();

        Object prev = null;
        int cnt = 0;

        for (Object curr : it) {
            if (sb.length() > 0) {
                if (!curr.equals(prev)) {
                    if (cnt > 1) {
                        sb.append(" x ").append(cnt);
                        cnt = 1;
                    }
                    sb.append(", ");
                    sb.append(curr);
                } else {
                    cnt++;
                }
            } else {
                sb.append(curr);
                cnt++;
            }
            prev = curr;
        }
        if (cnt > 1) {
            sb.append(" x ").append(cnt);
        }

        return sb;
    }
```
 =||= @akarnokd while you were putting your last comment up I synchronized the reads and writes of consumerCapacity as in the attached commit and the failures have stopped. Doesn't explain it yet but seems like consumerCapacity is important to this.

I'll add your changes and revert the synchronization once you've had a quick look.
 =||= I thought as much given our previous conversations and figured that if this is the solution you'd have suggestions for doing it properly. Anyway probably need to figure out the why still I suppose.
 =||= I'm confused by this `resumeBoundary` business, I hope you fare better, off to bed for me.
 =||= I've committed the CAS loop. We can drop it as an optimization later based on perfs if we want or of course now if you think
 =||= Can you devise a benchmark that checks the throughput on a non-throwing source?

If I remember correctly, the resumeBoundary is there because an exception can happen just after the capacity reached zero but we don't immediately resubscribe until an actual request comes in.
 =||= I've added some more comments to the code as my understanding improves. I also have marked three places with //TODO, two of which I think are potential race conditions and the third is just a marker for some of the usual optimizations done in the `request`. 

Another addition in the last commit is a check to ensure that the `consumerCapacity` decrement doesn't go below zero which now provokes a `MissingBackpressureException`.

I'm sure @akarnokd will have the red pen out on this stuff then if any of the race conditions stand scrutiny I'll fix them.
 =||= unrelated test failure `OperatorPublishTest.testObserveOn`. I've raised #2933.
 =||= I've ruled out one race condition (and left comments explaining why all is ok)
 =||= I'd say if the change makes your test failure go away, that should be enough for now. I'd defer the full rewrite to 2.0.
 =||= Righto, I'll concentrate on the fix for the #2863 test failure.  Part of that is probably ruling out surprises like decrementing `consumerCapacity` when it is already 0. My approach in that was to throw a `MissingBackpressureException` because in backpressure mode an operator should not emit more than requested. I would be concerned that this might appear as a breaking change to some though because previously it happily passed them through (with who knows what consequences in the operator). A compromise might be to not decrement when 0 but also not emit an error and then revisit this part of the contract in 2.0. Which way do you think we should go?
 =||= Hmm I just realized that if not emitting MissingBackpressureException then I should decrement otherwise the accounting is stuffed when more requests come through. I'll avoid the MissingBackpressureException for now but it should probably be part of some future milestone (2.0?).
 =||= Sorry to say, no progress made. I've protected all reads and writes to `currentProducer` and `consumerCapacity` by a single guard object (without holding a lock on emission or on request or on `worker.schedule` which could be run synchronously using `Schedulers.immediate()` or `Schedulers.trampoline()`) and still get the `OperatorRetryTest.testRetryWithBackpressureParallel` failure on my laptop. I give up for the moment. I'm leaning towards there being something fundamentally wrong that will probably only be fixed by a rewrite.
 =||= I've pared this PR right down (after the unsuccessful hunt for the cause of #2863) so that it addresses just the race conditions that I can see and can confirm.

The changes are:
- The original code to decrement `consumerCapacity` had a race condition, now we use a CAS loop to update
- the `c == 0` check at [L342](https://github.com/ReactiveX/RxJava/blob/0a6e26de73c3707dbd9903c166b7be0f6499b6b7/src/main/java/rx/internal/operators/OnSubscribeRedo.java#L342) can cause a stall in the stream because if `request` gets called just before [L320](https://github.com/ReactiveX/RxJava/blob/0a6e26de73c3707dbd9903c166b7be0f6499b6b7/src/main/java/rx/internal/operators/OnSubscribeRedo.java#L320) then no restart will occur in that call and it is possible that no further calls to request will be made after L320 has been performed (a common pattern is a request followed by another request only once emissions have occurred).
- update `sequenceFrequency` helper method in the test as per @akarnokd  request

#2863 is NOT fixed by these changes.
 =||= I applied some random sleep around the resumeBoundary and these changes worked for me (on top of your changes):
In the method with the locked check:

``` java
if (!isLocked.get() && !child.isUnsubscribed()) {
    if (consumerCapacity.get() > 0) {
        worker.schedule(subscribeToSource);
    }
}
```

and in the child's producer:

``` java
long c = BackpressureUtils.getAndAddRequest(consumerCapacity, n);
Producer producer = currentProducer.get();
if (producer != null) {
    producer.request(n);
} else
if (c == 0) {
    worker.schedule(subscribeToSource);
}
```

So if there is capacity available, the source will be restarted. If there is no capacity remaining, the first 0 -> n transition will restart the source.
 =||= I'll try it out, thanks! I'll also include a `n>0` check in the producer so that calls of request(0) are no-ops.
 =||= Nice simplification. Still getting `testRetryWithBackpressureParallel` failure on my laptop (first time).
 =||= 3 out of 3 failures on laptop, 1 out of 25 failures on fast desktop running all tests in `OperatorRetryTest`. I just run this in a loop:

`./gradlew -q   -Dtest.single=OperatorRetry cleanTest test`
 =||= Apparently, the `resumeBoundary` served to prevent unwanted resubscription.
One final try:
wrap the above places into `synchronized (consumerCapacity)` plus the contents of `terminalDelegatingSubscriber.setProducer` and see if it still fails. If not, start moving out operations from this synchronized block and see which one triggers the failure.

Edit: forgot to mention: readd resumeBoundary as well.
 =||= This is as far as I got. No failures when everything in the synch blocks.  Then started moving out the baddies for synchronization being calls to `producer.request` and `worker.schedule` (because could be a synchronous worker). Everything ok till I pulled `worker.schedule` out of `onNext` synch block. 

``` java
                    @Override
                    public void onNext(Object t) {
                        if (!isLocked.get() && !child.isUnsubscribed()) {
                            final boolean scheduleNow;
                            synchronized (consumerCapacity) {
                                if (consumerCapacity.get() > 0) {
                                    scheduleNow = true;
                                } else {
                                    scheduleNow = false;
                                    resumeBoundary.compareAndSet(false, true);
                                }
                            }
                            if (scheduleNow)
                                worker.schedule(subscribeToSource);
                        }
                    }

                    @Override
                    public void setProducer(Producer producer) {
                        producer.request(Long.MAX_VALUE);
                    }
                });
            }
        });

        child.setProducer(new Producer() {

            @Override
            public void request(final long n) {
                final Producer producer;
                final boolean requestNow;
                final boolean scheduleNow;
                synchronized (consumerCapacity) {
                    BackpressureUtils.getAndAddRequest(consumerCapacity, n);
                    producer = currentProducer.get();
                    if (producer != null) {
                        requestNow = true;
                        scheduleNow = false;
                    } else {
                        requestNow = false;
                        scheduleNow = resumeBoundary.compareAndSet(true, false);
                    }
                }
                if (requestNow)
                    producer.request(n);
                else if (scheduleNow)
                    worker.schedule(subscribeToSource);
            }
        })
```
 =||= When the test fails, how many elements are missing from the output. Does it print beginningEveryTime x 256 ?
 =||= Yep:

`java.lang.AssertionError: Data content mismatch: 2315={beginningEveryTime x 256}
        at org.junit.Assert.fail(Assert.java:93)
        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:763)
`
 =||= I'm rewriting just the retry(n) variant and see if there is a general logical error with request accounting or just the OnSubscribeRedo has problems.
 =||= [Here is a retry implementation](https://gist.github.com/akarnokd/3b110055414a44d320b9) that serializes out the changing of producers and accounting the capacity. Could you try this implementation?
(Dont forget to change both factory methods in OnSubscribeRedo:

``` java
    public static <T> Observable<T> retry(Observable<T> source) {
//        return retry(source, REDO_INIFINITE);
        return retry(source, Long.MAX_VALUE);
    }

    public static <T> Observable<T> retry(Observable<T> source, final long count) {
        if (count < 0)
            throw new IllegalArgumentException("count >= 0 expected");
        if (count == 0)
            return source;
//        return retry(source, new RedoFinite(count));
        return create(new OnSubscribeRetry<T>(source, count));
    }
```

**Edit:**
[Here is an alternative](https://gist.github.com/akarnokd/5cb99c6062cea0b23d8b) which doesn't use List as the work queue but instead accounts the changes separately and is a bit faster.
 =||= Cool, thanks. Got this exception:

```
rx.internal.operators.OperatorRetryWithPredicateTest > testJustAndRetry FAILED
    java.util.NoSuchElementException: Sequence contains no elements
        at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:131)
        at rx.internal.operators.OnSubscribeRetry$1$1.onCompleted(OnSubscribeRetry.java:66)
        at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:44)
        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:44)
        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:32)
        at rx.Observable$1.call(Observable.java:144)
        at rx.Observable$1.call(Observable.java:136)
        at rx.Observable.unsafeSubscribe(Observable.java:7507)
        at rx.internal.operators.OnSubscribeRetry$1.call(OnSubscribeRetry.java:75)
        at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:80)
        at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:59)
        at rx.internal.operators.OnSubscribeRetry.call(OnSubscribeRetry.java:86)
        at rx.internal.operators.OnSubscribeRetry.call(OnSubscribeRetry.java:28)
        at rx.Observable$1.call(Observable.java:144)
        at rx.Observable$1.call(Observable.java:136)
        at rx.Observable.subscribe(Observable.java:7597)
        at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:442)
        at rx.observables.BlockingObservable.single(BlockingObservable.java:341)
        at rx.internal.operators.OperatorRetryWithPredicateTest.testJustAndRetry(OperatorRetryWithPredicateTest.java:296)
```
 =||= I went a bit light on the safeguards in OnSubscribeRetry (i.e., not bouncing back any exceptions thrown when calling currentProducer.request()). How does the code work with testRetryWithBackpressureParallel?
 =||= I've [updated the gist](https://gist.github.com/akarnokd/5cb99c6062cea0b23d8b) so it passes the unit tests.
 =||= Good so far. I'll stick the test in a loop for ten minutes or so on the laptop.
 =||= 3rd time through:

```
rx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel FAILED
    java.lang.AssertionError: Data content mismatch: 3628={beginningEveryTime x 256}
        at org.junit.Assert.fail(Assert.java:93)
        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:763)
```
 =||= For your info I tried using `SynchronizedQueue` instead of `SpscArrayQueue` in `OperatorObserveOn` and got the failure on 30th run on fast desktop (so I'm glad to rule out `SpscArrayQueue` as being the cause):

```
java.lang.AssertionError: Data content mismatch: 1940={beginningEveryTime x 254}
    at org.junit.Assert.fail(Assert.java:93)
    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:763)
```
 =||= There is a race in observeOn in main being fixed by #2929 that might attribute to lost onNexts but can't be sure from the AssertionError.
The simple fix for observeOn is to replace

``` java
Object o = queue.poll();
if (o == null) {
    if (completed) {
```

with

``` java
boolean c = completed;
Object o = queue.poll();
if (o == null) {
    if (c) {
```

This updated test method should print out any additional onCompleted events if they are there:

``` java
@Test//(timeout = 15000)
public void testRetryWithBackpressureParallel() throws InterruptedException {
    final int NUM_RETRIES = RxRingBuffer.SIZE * 2;
    int ncpu = Runtime.getRuntime().availableProcessors();
    ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));
    try {
        for (int r = 0; r < 1000; r++) {
            if (r % 10 == 0) {
                System.out.println("testRetryWithBackpressureParallelLoop -> " + r);
            }

            final AtomicInteger timeouts = new AtomicInteger();
            final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();

            int m = 5000;
            final CountDownLatch cdl = new CountDownLatch(m);
            for (int i = 0; i < m; i++) {
                final int j = i;
                exec.execute(new Runnable() {
                    @Override
                    public void run() {
                        final AtomicInteger nexts = new AtomicInteger();
                        try {
                            Observable<String> origin = Observable.create(new FuncWithErrors(NUM_RETRIES));
                            TestSubscriber<String> ts = new TestSubscriber<String>();
                            origin.retry()
                            .observeOn(Schedulers.computation()).unsafeSubscribe(ts);
                            ts.awaitTerminalEvent(2500, TimeUnit.MILLISECONDS);

                            List<String> onNextEvents = new ArrayList<String>(ts.getOnNextEvents());
                            List<Throwable> onErrorEvents = new ArrayList<Throwable>(ts.getOnErrorEvents());
                            List<Notification<String>> onCompletedEvents = new ArrayList<Notification<String>>(ts.getOnCompletedEvents());

                            if (onNextEvents.size() != NUM_RETRIES + 2
                                    || !onErrorEvents.isEmpty() || onCompletedEvents.isEmpty()) {
                                for (Throwable t : onErrorEvents) {
                                    onNextEvents.add(t.toString());
                                }
                                for (Object o : onCompletedEvents) {
                                    onNextEvents.add("onCompleted");
                                }
                                data.put(j, onNextEvents);
                            }
                        } catch (Throwable t) {
                            timeouts.incrementAndGet();
                            System.out.println(j + " | " + cdl.getCount() + " !!! " + nexts.get());
                        }
                        cdl.countDown();
                    }
                });
            }
            cdl.await();
            assertEquals(0, timeouts.get());
            if (data.size() > 0) {
                fail("Data content mismatch: " + allSequenceFrequency(data));
            }
        }
    } finally {
        exec.shutdown();
    }
}
```
 =||= I've added the suggested changes to this commit but should have mentioned that I tried the fixes from #2929 with your OperatorRetry and had no effect (still get failures).
 =||= What does the failure report as the received events? Could you also check whether replacing the TrampolineScheduler with io scheduler still exhibits the failure?
 =||= 29th run on desktop:

```
java.lang.AssertionError: Data content mismatch: 1828={beginningEveryTime x 109}
    at org.junit.Assert.fail(Assert.java:93)
    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:759)
```
 =||= I'm running the test on a virtualized ubuntu without CPU virtualization support to emulate a slow machine but it is working so far. What are the specs of your machine which fails the test so often?
 =||= My laptop is Ubuntu 12.04 64-bit i5-430m 1.2GHz java 1.8u45 but the wind has changed this evening and is not failing that test. My desktop Ubuntu 14.04 64-bit Intel® Core™ i7 CPU 920 @ 2.67GHz × 8, java 1.8u40  is where it's failing at the moment and my best bet for failure is running the whole OperatorRetryTest suite using gradle command mentioned previously.
 =||= The quick fix for observeOn that you mention above still has the race condition that #2929 was reported on so I might paste in #2929 version of OperatorObserveOn and continue testing with that.
 =||= Might #2907 have any bearing on this?
 =||= No, because it is a completely separate scheduler.

I'm running the test on some real debian linux and I the test fails within the first run:

```
4882={}, 4871={}, 4860={}, 4838={beginningEveryTime x 51}, 4849={}
```
 =||= David I don't understand the quick fix in OperatorObserveOn you mentioned above. Is that something new to be added to #2929?  Can you explain it if so?
 =||= Never mind, I didn't notice the queue.isEmpty() check after it.
 =||= I've put in doOnNext() between the operators. In case of a test failure, the emission count after the source and retry() match but are less after observeOn() which makes me think observeOn doesn't pick up the values emitted (and it doesn't request for replacements either).
 =||= The latest commit including #2929 doesn't fail for me on three different machines including the old laptop. 200 runs on i7, 100 runs on laptop and 200 runs on another i7. Did you use the last commit for the failures on the debian machine?
 =||= With #2929 the test fails after 15 runs:

Data: 
- 4875={Loops:128, Request:0, B/A:[128, 128, 0, 637676, 0]}, 4842={Loops:128, Request:0, B/A:[128, 128, 0, 664205, 0]}, 
- 4831={beginningEveryTime x 139, Loops:258, Request:10, B/A:[258, 258, 139, 2491693, 1720371]}, 
- 4853={Loops:128, Request:0, B/A:[128, 128, 0, 670982, 0]}, 4864={Loops:128, Request:0, B/A:[128, 128, 0, 664584, 0]}

Where B/A means [after source count, after retry count, after observeOn count, latest emission after retry in nanoseconds, latest emission after observeOn in nanoseconds]. Both time values are relative to when the entire stream started.

I've completely rewritten the emission loop in observeOn but the test still fails on my linux machine. 
 =||= I've increased the timeout and added `timeInterval` to the source data and it seems there is a large, seconds-scale hiccup in the stream. Since I'm using SSH, I can't use flight recorder or jvisualvm to see how the threads behave.
 =||= I've lost the ability to induce failures. Tests ran all night without inducing failure. I might try reverting to an earlier version of the test method.
 =||= May as well give the latest commit from here a spin again @akarnokd now that it incorporates the request overflow fix from #2929 I just added. I still can't induce failure so the baton is passed to you!
 =||= So the observeOn changes + my ProducerArbiter works. Great! Now it would be better to remove OnSubscribeRetry and apply its logic on OnSubscribeRedo directly.
 =||= Super news.  So you mean you'll rewrite Redo now? One thing I was worried
about with the original is the possibility of requests getting missed and
the new one accounts for that.

On Sat, 9 May 2015 18:23 David Karnok notifications@github.com wrote:

> So the observeOn changes + my ProducerArbiter works. Great. Now it would
> be better to remove OnSubscribeRetry and apply its logic on OnSubscribeRedo
> directly.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/pull/2930#issuecomment-100447523.
 =||= I meant you apply the ProducerArbiter and the calls to OnSubscribeRedo.
 =||= No worries, can do

On Sat, 9 May 2015 19:33 David Karnok notifications@github.com wrote:

> I meant you apply the ProducerArbiter and the calls to OnSubscribeRedo.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/pull/2930#issuecomment-100455254.
 =||= Hmm not quite out of the woods. I've adjusted the code to use `ProducerArbiter` (please look it over) but saw our old friend on  the first run on my i7 desktop which also seemed to lock the machine up for me for a minute. Subsequent runs did not fail (150 runs). The latest commit includes the latest version of `OperatorObserveOn` from #2929.

```
java.lang.AssertionError: Data content mismatch: 1763={beginningEveryTime x 128, onCompleted}, 1767={beginningEveryTime x 21, onCompleted}, 1756={beginningEveryTime x 10, onCompleted}
    at org.junit.Assert.fail(Assert.java:93)
    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:759)
```
 =||= I forgot to mention that the last failure also included a timeout failure of `OperatorRetryTest. testIssue1900`. 
 =||= Can you monitor the test with JVisualVM and see if there are thread stalls or excess GC?
 =||= Yeah I'll try that. 28th run on laptop gave 

```
rx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel FAILED
    java.lang.AssertionError: Data content mismatch: 3724={onCompleted}, 3720={beginningEveryTime x 17, onCompleted}
        at org.junit.Assert.fail(Assert.java:93)
        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:759)
```
 =||= I can see another race condition in `OnSubscribeRedo`. `restarts` must be subscribed to before the first request subscribes to source. I don't think it affects our current test because the `worker` is synchronous but if it was async we would be exposed to it. To fix this in a non-blocking way would require `terminals` to be a slightly different beast than a `PublishSubject` in that it would buffer events till the first subscriber (there should be only one subscriber for `terminals` though the `notificationHandler` could do something weird in theory) and then play all the buffered events to the subscriber. `ReplaySubject` might help out here but I'm not sure what idiom we could use yet. A custom `Subject` would probably be straightforward to build but I'd like to see what ideas you have @akarnokd.

I tried a blocking fix for this using a latch just to play with it but as expected still get our normal failure.

Incidentally I can't seem to break `testRetryWithBackpressureParallel` but just looping it in Eclipse. It only fails looping the gradle command line call. This makes monitoring difficult but I could enable gc logging I suppose.
 =||= I think I have addressed the race condition mentioned in the previous comment. By using a `BehaviorSubject` instead of a `PublishSubject` and subscribing with a dummy subscriber immediately after creating then an emission between subscribing to source and subscribing to `restarts` will be replayed on subscribe to `restarts` so it is not lost.
 =||= Failed on run 111 on desktop i7:

```
java.lang.AssertionError: Data content mismatch: 237={beginningEveryTime x 128}
    at org.junit.Assert.fail(Assert.java:93)
    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:759)
```
 =||= The race condition I thought had found was what `isLocked` was to prevent. I'm not sure that ignoring a restart instruction because `isLocked` is true is the way to go so I'm going to remove the `isLocked` checks and retest using only the `BehaviorSubject` logic.
 =||= Three hours without failure on three machines (i7,i7 and i5 laptop). Can you try this commit @akarnokd?
 =||= Took 5 hours but got failure on laptop only:

```
java.lang.AssertionError: Data content mismatch: 883={beginningEveryTime x 138}
        at org.junit.Assert.fail(Assert.java:93)
        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRet
```

This is going to make testing difficult!
 =||= Using jacoco as per #2937 I noticed that the subscriber to `restarts` never completes so never unsubscribes (though `child` does). To achieve this  (and to simplify `OnSubscribeRedo` a little bit) I ensured that all events are routed through to `filteredTerminals` instead of just the `onNext` events.
 =||= I've added the fix to `ProducerArbiter` to not reduce the request if already `Long.MAX_VALUE`. Before applying this fix I ran the test which failed on run 207 but in this test I confirmed that count upstream of  `observeOn` was same as downstream so I think the problem is not with `OperatorSubscribeOn` anymore. I'll rerun now we have a fix in `ProducerArbiter`.
 =||= The fix to `ProducerArbiter` could help the failure because concurrent requests to `FuncWithErrors` one of `Long.MAX_VALUE` and one of less than `Long.MAX_VALUE` could initiate the fast path and the backpressure path simultaneously. 
 =||= Added more concurrency protection to `FuncWithErrors` to prevent fast path and backpressure path from running concurrently
 =||= Got this 74th run on laptop:

```
org.mockito.exceptions.verification.VerificationInOrderFailure: 
Verification in order failure:
observer.onNext("beginningEveryTime");
Wanted 257 times:
-> at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressure(OperatorRetryTest.java:702)
But was 240 times:
-> at rx.observers.TestObserver.onNext(TestObserver.java:78)

    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressure(OperatorRetryTest.java:702)
```
 =||= Added another race condition fix for `FuncWithErrors` that prevents the subscriber `o` being passed more signals after a terminal signal has been sent to it.
 =||= 54th run on desktop:

```
java.lang.AssertionError: Data content mismatch: 2408={beginningEveryTime x 128}
    at org.junit.Assert.fail(Assert.java:93)
    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:764)
```
 =||= despite last commit, 22nd run on desktop:

```
java.lang.AssertionError: Data content mismatch: 4501={beginningEveryTime x 128}
    at org.junit.Assert.fail(Assert.java:93)
    at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:768)
```
 =||= Try disabling transparent hugepages.
 =||= With the purpose of making the test fail more often?
 =||= In the contrary. Linux transparent hugepages (default: on) is known to introduce latency spikes, maybe so extreme our test times out just by that.
 =||= The catch is that we have a low probability (for the test as it stands) race condition somewhere. If I make the test fail less often then we lose the ability to find that race condition. Which timeout are you thinking  of? The individual timeouts for the tests are commented out, are there scheduler timeouts?
 =||= I think there is no race condition but your linux system gets overwhelmed by the test and it simply times out. This is why I suggested looking at JVisualVM's thread graph to detect some gaps in the execution that can be attributed to the system.
 =||= Inspecting with jvisualvm is  tricky because I have only got failures to happen using the gradle command line which means jvm restarts every thirty seconds or so.  I've dug around pretty much everywhere now and may dig around a bit more in the future but perhaps we have achieved enough with this operator for it to be accepted back into the code base. The hunt certainly unearthed a few race conditions in `retry`, its tests, and in `observeOn` so was pretty useful and the original very frequent failure (for me) is now very infrequent.

I can rebase the commits and remove the updates to OperatorObserveOn from this commit so that it's ready for merge once you and Ben and whoever else has reviewed it. It will be good to get the fixes in #2929 merged as well of course as otherwise there will be some test flakiness on this commit. 

Is that a reasonable plan or would you like to keep digging?
 =||= I've rebased commits. Ready for a hopefully final review.
 =||= I'm quite a bit lost; don't know what worked and what not or did the changes work on your system or not. If the test fails with the outer pool of 1 thread, which should pose the least amount of work, then my suspect is that there is something wrong with Java on Linux or with Linux itself. Perhaps this is just another case of the [recent futex bug](https://groups.google.com/forum/#!topic/mechanical-sympathy/QbmpZxp6C64).
 =||= The futex stuff is interesting, I'll have a close look at that soon. One thing I'm wondering is should we break the retries when a `java.lang.Error` is signalled? At the moment I assume if one occurs it will be suppressed and may have the side effects we see.
 =||= I did a little test and see that the sort of `Error`s that we care about do stop the retries, so that's not it.

The futex stuff shouldn't be an issue because it turned up in linux kernel 3.14 and I'm running 3.2.0-80 on my laptop and 3.13.0-49 on my desktop. I'll turn off transparent hugepages on my home desktop and see if the error happens.
 =||= Turned off transparent hugepages and failed on 18th run of this command:

```
./gradlew -i -Dtest.single=OperatorRetry cleanTest test
```

The run times are below. You'll notice that the runtime is not significantly larger for the final failing test which may rule out some types of OS behaviour being involved. 

I think we can rule out the futex bug because I run either Ubuntu 12.04 or 14.04:

> Ubuntu 14.04/Debian 8: have the fix for a long time [0] [1]
> Ubuntu 12.04/Debian 7: was never affected [3] [2]. Newer enablement stack kernels for Ubuntu has the same fix as [1].
> [0] http://kernel.ubuntu.com/git/ubuntu/linux.git/log/?showmsg=1&qt=grep&q=Avoid+taking+the+hb-%3Elock&h=linux-3.13.y
> [1] http://kernel.ubuntu.com/git/ubuntu/linux.git/log/?showmsg=1&qt=grep&q=Avoid+taking+the+hb-%3Elock&h=linux-3.16.y
> [2] https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/kernel/futex.c?h=linux-3.2.y&id=refs/tags/v3.2.69
> [3] http://kernel.ubuntu.com/git/ubuntu/ubuntu-precise.git/tree/kernel/futex.c#n186

```
Total time: 33.624 secs
Total time: 25.215 secs
Total time: 25.204 secs
Total time: 27.108 secs
Total time: 25.532 secs
Total time: 27.042 secs
Total time: 26.061 secs
Total time: 26.199 secs
Total time: 26.177 secs
Total time: 26.294 secs
Total time: 25.974 secs
Total time: 26.123 secs
Total time: 25.983 secs
Total time: 26.475 secs
Total time: 26.321 secs
Total time: 26.268 secs
Total time: 26.459 secs
Total time: 27.076 secs
```

```
rx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel FAILED
    java.lang.AssertionError: Data content mismatch: 118={beginningEveryTime x 128}
        at org.junit.Assert.fail(Assert.java:93)
        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:768)
```
 =||= I suggest closing this PR and start with a fresh new PR and perhaps a new discussion.
 =||= Continuing issue in #2997.
 =||= ,0
3009,300,Type-safety in rxjava-core, dynamic language support via compile-time code generation, and Scala support via implicits,Implementation of ideas here: https://groups.google.com/forum/#!topic/rxjava/g6Z9KyMM8zs

This addresses #204 and #208 .,[RxJava-pull-requests #171](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/171/) ABORTED
 =||= Manually merging in https://github.com/Netflix/RxJava/pull/304 since it had conflicts with 0.9.1 changes.
 =||= ,0
3009,3006,Bug in OnSubscribeFromIterable unsubscribed child logic,Hello

The code is missing an additional check for child unsubscription after calling the iterator next method. This is needed when using in conjunction with operators like take, that unsubscribes itself in the onNext method.

Regards,Sorry, can't see the issue with `take`, can you elaborate? If the child has unsubscribed during the `onNext` then the next loop will check for unsubscription and exit. 

The iterator `next` method could take enough time for unsubscription to have happened in the meantime so we could insert another check for unsubscription before emitting. I'll see what the others think of this as I imagine it would compromise performance a bit for common use cases like using java Collections as sources because each emission would require two volatile reads of `unsubscribed`.

``` java
if (o.isUnsubscribed())
    return;
T val = it.next();
if (o.isUnsubscribed()) 
    return;
o.onNext(val);
```

Is this what you were meaning?
 =||= The problem arised when using an `Iterable` which produces iterators with a blocking `hasNext`.
Imagine the case where the `hasNext` call would block after retrieving 10 elements (so, in the eleventh call). Chaining a `take`/`limit` of 10 would still block, even after emiting 10 elements.

We did a quick patch:

```
while (it.hasNext() && --numToEmit >= 0) {
                            if (o.isUnsubscribed()) {
                                return;
                            }
                            o.onNext(it.next());
                            if (o.isUnsubscribed()) {
                                return;
                            }

                        }
```
 =||= How about checking `isUnsubscribed` before `hasNext`, such as:

```
                        while (!o.isUnsubscribed() && it.hasNext() && --numToEmit >= 0) {
                            o.onNext(it.next());
                        }
                        if (o.isUnsubscribed()) {
                            return;
                        }
```
 =||= @pelecomepibe yep that does look something to avoid
@zsxwing LGTM
 =||= Thanks for reporting. Fix released in 1.0.12.
 =||= ,0
3045,3014,ElementAt backpressure improvements,The operator `elementAt` could be improved in several ways:
- It could request `index` amount upfront so it doesn't have to request(1) at every skipped value
  - this could be achieved with unconditional requesting in `onStart()` + `SingleDelayedProducer` or conditionally when the child subscriber actually requests a positive value(i.e., `if (n > 0 && once.compareAndSet(false, true)) request(index)`)
- Once the required element arrives, one should call `this.unsubscribe()` in `onNext()`.
  - Note that the parent subscriber can't directly wrap the child subscriber anymore.
- I'd also do a `currentIndex < index` check in `onError` in case an error happens after the indexth element and it slips through.,Closed via #3045
 =||= ,0
3047,148,Confusing Javadoc for `toObservable(Future)` methods,The Javadoc for the `Observable.toObservable(Future)` methods are messed up. In particular the sentence: "The subscribe method on this synchronously so the Subscription returned doesn't nothing."

I'd fix it, but I have no idea what it's trying to say :),That makes all kind of sense!

I have no idea how that sentence ever came to be written but it definitely needs to be thrown away and redone :-)

Thanks for bringing this to my attention.
 =||= ,0
3048,3046,NullPointerException at rx.exceptions.CompositeException.getListOfCauses(CompositeException.java:245),I use RxAndroid library in my project and I have next exception :

E/AndroidRuntime(27849): Error reporting crash
E/AndroidRuntime(27849): java.lang.NullPointerException
E/AndroidRuntime(27849): at rx.exceptions.CompositeException.getListOfCauses(CompositeException.java:245)
E/AndroidRuntime(27849): at rx.exceptions.CompositeException.getCause(CompositeException.java:100)
E/AndroidRuntime(27849): at android.util.Log.getStackTraceString(Log.java:454)
E/AndroidRuntime(27849): at android.util.Slog.e(Slog.java:151)
E/AndroidRuntime(27849): at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)
E/AndroidRuntime(27849): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)
E/AndroidRuntime(27849): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)
E/AndroidRuntime(27849): at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:66)
E/AndroidRuntime(27849): at android.os.Handler.handleCallback(Handler.java:733)
E/AndroidRuntime(27849): at android.os.Handler.dispatchMessage(Handler.java:95)
E/AndroidRuntime(27849): at android.os.Looper.loop(Looper.java:146)
E/AndroidRuntime(27849): at android.app.ActivityThread.main(ActivityThread.java:5653)
E/AndroidRuntime(27849): at java.lang.reflect.Method.invokeNative(Native Method)
E/AndroidRuntime(27849): at java.lang.reflect.Method.invoke(Method.java:515)
E/AndroidRuntime(27849): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1291)
E/AndroidRuntime(27849): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1107)
E/AndroidRuntime(27849): at dalvik.system.NativeStart.main(Native Method)

Somebody know how can I fix it ?
Thank you,It appears you have a `null` exception added to a composite somewhere. What operators are you using. Do you call `onError(null)` somewhere by accident? 
 =||= I try to get throwable.getMessage callback and have this null pointer.
I already find the reason. I make mistake at URL and try to connect to non-existent URL. I changed it and all is fine.
I think you need handle this null pointer in other way, because currently I can't normally find the reason of exception.
Thank you
 =||= Fix already delivered. Thank you for reporting.
 =||= ,0
3049,3038,Variants of first, single etc. which return Single,Now that we have the concept of a "Single", I think it would make sense that any operator which returns an observable which is guaranteed to return exactly one item or fail would be a Single. Examples would be operators like single, first, toList, takeFirst, takeLast etc.

I understand that to maintain source and binary compatibility, the existing definitions of these would need to be unchanged so would it be possible to create some sort of conversion mechanism to turn an observable into a Single?

If this would be acceptable I would be happy to try my hand in writing such a conversion mechanism depending on how complex it would have to be. I have been using Rx for a while now but as of yet have not actually written something which interacts with low level Rx stuff (e.g. a custom operator)

Thanks!,Yes we will want something to convert, such as `Single.from(Observable o)` or `Observable.toSingle()`.

The `toSingle()` method should behave similarly to `single()` except return a `Single`. 

Awkward, but all we can do during 1.x.

It would be great if you want to contribute this and start the design discussion. Note that public APIs contributions can often go through a lot of back and forth as we discuss them since we are stuck with them forever once we let them in.
 =||= ,0
3065,3057,New Subscribers helper method?,This sort of code is in a lot of places in the RxJava codebase:

``` java
    new Subscriber<T>(s) {
            @Override
            public void onNext(T t) {
                s.onNext(t);
            }
            @Override
            public void onError(Throwable e) {
                s.onError(e);
            }
            @Override
            public void onCompleted() {
                s.onCompleted();
            }
        }
```

I'd like to add a utility method in `Subscribers` that does this. Any suggestions for a name to squeeze into the static namespace of this class? `from` would have been nice but is used by `Subscribers.from(Observer)` and this would be a breaking change if I added `Subscribers.from(Subscriber)` because they do different things and a `Subscriber` is an `Observer`.

Perhaps:
- `Subscribers.fromChained(Subscriber)`
- `Subscribers.passThrough(Subscriber)`
- `Subscribers.chained(Subscriber)`

I'm sure someone will have a nicer suggestion than these.,`Subscribers.wrap(s)`?
 =||= I like `wrap`, thanks @wujek-srujek 
 =||= This has been merged
 =||= ,0
3078,3073,switchOnNext() can lose requests,There is a race condition in `OperatorSwitch` that may cause requests to be lost:
1. `onNext` proceeds to just before [L137](https://github.com/ReactiveX/RxJava/blob/d32a1b0ea7ee455a23082cd1a7db80b3adef6d2b/src/main/java/rx/internal/operators/OperatorSwitch.java#L137) 
2. on a different thread `request` proceeds to just before [L112](https://github.com/ReactiveX/RxJava/blob/d32a1b0ea7ee455a23082cd1a7db80b3adef6d2b/src/main/java/rx/internal/operators/OperatorSwitch.java#L112)
3. `onNext` continues and exits method
4. `request` continues and requests from unsubscribed subscriber
5. At this point stream could stall because requests were lost 

Looks like a candidate for `ProducerArbiter` help. I'll work on a PR if no-one else has started on this issue yet (let me know if you have). There may be other race conditions as well that turn up which I'll document in the PR.,Fixed and released with 1.0.14.
 =||= ,0
3081,3076,1.0.13 Release Candidate,Update: After production canary testing on the Netflix API we have gained confidence with `merge` and are now ready to release 1.0.13. We did however choose to rollback changes to `replay()` and `cache()` and will pursue them in the next release. The discussion in the comments below shares the details.

---

This is a pretty significant release as it has major changes to `merge` ~~and `replay`~~, along with the new `rx.Single` type. 

The `merge` changes are the most sensitive, as they affect almost all applications (either through `merge` directly, or the ubiquitous use of `flatMap`). 

I'm going to wait a few days before releasing to give people a chance to use the [SNAPSHOT](https://github.com/ReactiveX/RxJava/blob/1.x/README.md#binaries). Use the snapshot from a Gradle build like this:

``` groovy
repositories {
    maven { url 'https://oss.jfrog.org/libs-snapshot' }
}

dependencies {
    compile 'io.reactivex:rxjava:1.0.13-SNAPSHOT'
}
```

---

This release has quite a few bug fixes and some new functionality. Items of note are detailed here with the list of changes at the bottom.
##### merge

The `merge` operator went through a major rewrite to fix some edge case bugs in the previous version. This has been sitting for months going through review and performance testing due to the importance and ubiquity of its usage. It is believed this rewrite is now production ready and achieves the goal of being more correct (no known edge cases at this time) while retaining comparable performance and memory usage. 

Special thanks to @akarnokd for this as `merge` is a challenging one to implement. 
##### window fix and behavior change

Unsubscription bugs were fixed in `window`. Along the way it also resulted in a fix to one of the `window` overloads that had a functional discrepancy.

``` java
window(Func0<? extends Observable<? extends TClosing>> closingSelector)
```

This is a small behavior change that corrects it. If you use this overload, please review the change to ensure your application is not affected by an assumption of the previously buggy behavior: https://github.com/ReactiveX/RxJava/pull/3039

Note that this behavior change only affects that particular overload while the broader bug fixes affect all `window` overloads. 
##### rx.Single

After [much discussion](https://github.com/ReactiveX/RxJava/issues/1594) it was decided to add a new type to represent an `Observable` that emits a single item. Much bike-shedding led to the name `Single`. This was chosen because `Future`, `Promise` and `Task` are overused and already have nuanced connotations that differ from `rx.Single`, and we didn't want long, obnoxious names with `Observable` as a prefix or suffix. Read the issue thread if you want to dig into the long debates.

If you want to understand the reasoning behind adding this type, you can read about it [in this comment](https://github.com/ReactiveX/RxJava/issues/1594#issuecomment-101300655).

In short, request/response semantics are so common that it was decided worth creating a type that composes well with an `Observable` but only exposes request/response. The difference in behavior and comparability was also deemed worth having an alternative to `Future`. In particular, a `Single` is lazy whereas `Future` is eager. Additionally, merging of `Single`s becomes an `Observable`, whereas combining `Future`s always emits another `Future`. 

Note that the API is added in an `@Experimental` state. We are fairly confident this will stick around, but are holding final judgement until it is used more broadly. We will promote to a stable API in v1.1 or v1.2. 

Examples below demonstrate use of `Single`.

``` java
// Hello World
Single<String> hello = Single.just("Hello World!");
hello.subscribe(System.out::println);

// Async request/response
Single<String> one = getData(1);
Single<String> two = getOtherData(2);

// merge request/responses into an Observable of multiple values (not possible with Futures)
Observable<String> merged = one.mergeWith(two);

// zip request/responses into another Single (similar to combining 2 Futures)
Single<String> zipped = one.zipWith(two, (a, b) -> a + b);

// flatMap to a Single
Single<String> flatMapSingle = one.flatMap(v -> {
    return getOtherData(5);
});

// flatMap to an Observable
Observable<Integer> flatMapObservable = one.flatMapObservable(v -> {
    return Observable.just(1, 2, 3);
});

// toObservable
Observable<String> toObservable = one.toObservable();

// toSingle
Single<Integer> toSingle = Observable.just(1).toSingle();

public static Single<String> getData(int id) {
    return Single.<String> create(s -> {
        // do blocking IO
        s.onSuccess("data_" + id);
    }).subscribeOn(Schedulers.io());
}

public static Single<String> getOtherData(int id) {
    return Single.<String> create(s -> {
        // simulate non-blocking IO
        new Thread(() -> {
            try {
                s.onSuccess("other_" + id);
            } catch (Exception e) {
                s.onError(e);
            }
        }).start();
    });
}
```
##### ConnectableObservable.autoConnect

A new feature was added to `ConnectableObservable` similar in behavior to `refCount()`, except that it doesn't disconnect when subscribers are lost. This is useful in triggering an "auto connect" once a certain number of subscribers have subscribed. 

The [JavaDocs](https://github.com/ReactiveX/RxJava/blob/1877fa7bbc176029bcb5af00d8a7715dfbb6d373/src/main/java/rx/observables/ConnectableObservable.java#L96) and [unit tests](https://github.com/ReactiveX/RxJava/blob/1.x/src/test/java/rx/observables/ConnectableObservableTest.java) are good places to understand the feature.
##### Deprecated onBackpressureBlock

The `onBackpressureBlock` operator has been deprecated. It will not ever be removed during the 1.x lifecycle, but it is recommended to not use it. It has proven to be a common source of deadlocks and is difficult to debug. It is instead recommended to use non-blocking approaches to backpressure, rather than callstack blocking. Approaches to backpressure and flow control are [discussed on the wiki](https://github.com/ReactiveX/RxJava/wiki/Backpressure).
#### Changes
- [Pull 3012](https://github.com/ReactiveX/RxJava/pull/3012) rx.Single
- [Pull 2983](https://github.com/ReactiveX/RxJava/pull/2983) Fixed multiple calls to onStart.
- [Pull 2970](https://github.com/ReactiveX/RxJava/pull/2970) Deprecated onBackpressureBlock
- [Pull 2997](https://github.com/ReactiveX/RxJava/pull/2997) Fix retry() race conditions
- [Pull 3028](https://github.com/ReactiveX/RxJava/pull/3028) Delay: error cut ahead was not properly serialized
- [Pull 3042](https://github.com/ReactiveX/RxJava/pull/3042) add backpressure support for defaultIfEmpty()
- [Pull 3049](https://github.com/ReactiveX/RxJava/pull/3049) single: add toSingle method to Observable
- [Pull 3055](https://github.com/ReactiveX/RxJava/pull/3055) toSingle() should use unsafeSubscribe
- [Pull 3023](https://github.com/ReactiveX/RxJava/pull/3023) ConnectableObservable autoConnect operator
- [Pull 2928](https://github.com/ReactiveX/RxJava/pull/2928) Merge and MergeMaxConcurrent unified and rewritten
- [Pull 3039](https://github.com/ReactiveX/RxJava/pull/3039) Window with Observable: fixed unsubscription and behavior
- [Pull 3045](https://github.com/ReactiveX/RxJava/pull/3045) ElementAt request management enhanced
- [Pull 3048](https://github.com/ReactiveX/RxJava/pull/3048) CompositeException extra NPE protection
- [Pull 3052](https://github.com/ReactiveX/RxJava/pull/3052) Reduce test failure likelihood of testMultiThreadedWithNPEinMiddle
- [Pull 3031](https://github.com/ReactiveX/RxJava/pull/3031) Fix OperatorFlatMapPerf.flatMapIntPassthruAsync Perf Test
- [Pull 2975](https://github.com/ReactiveX/RxJava/pull/2975) Deprecate and rename two timer overloads to interval
- [Pull 2982](https://github.com/ReactiveX/RxJava/pull/2982) TestSubscriber - add factory methods
- [Pull 2995](https://github.com/ReactiveX/RxJava/pull/2995) switchOnNext - ensure initial requests additive and fix request overflow
- [Pull 2972](https://github.com/ReactiveX/RxJava/pull/2972) Fixed window(time) to work properly with unsubscription, added
- [Pull 2990](https://github.com/ReactiveX/RxJava/pull/2990) Improve Subscriber readability
- [Pull 3018](https://github.com/ReactiveX/RxJava/pull/3018) TestSubscriber - fix awaitTerminalEventAndUnsubscribeOnTimeout
- [Pull 3034](https://github.com/ReactiveX/RxJava/pull/3034) Instantiate EMPTY lazily
- [Pull 3033](https://github.com/ReactiveX/RxJava/pull/3033) takeLast() javadoc fixes, standardize parameter names (count instead of num)
- [Pull 3043](https://github.com/ReactiveX/RxJava/pull/3043) TestSubscriber javadoc cleanup
- [Pull 3065](https://github.com/ReactiveX/RxJava/pull/3065) add Subscribers.wrap
- [Pull 3091](https://github.com/ReactiveX/RxJava/pull/3091) Fix autoConnect calling onStart twice.
- [Pull 3092](https://github.com/ReactiveX/RxJava/pull/3092) Single.toObservable

I will be adding examples and more comprehensive release notes for `rx.Single`.

---

These were reverted and won't be included in 1.0.13:
- [Pull 2969](https://github.com/ReactiveX/RxJava/pull/2969) Operator cache() now supports backpressure
- [Pull 3047](https://github.com/ReactiveX/RxJava/pull/3047) Operator replay() now supports backpressure,Nice release :)
 =||= FWIW, I bumped the couchbase SDK to 1.0.13-SNAPSHOT and all the unit and integration tests look good. Looking forward to the 1.0.13 release, will be shipping with 2.2.0 :)
 =||= This SNAPSHOT badly failed our production canary testing. It seems be causing our application threads to block and grow overtime.

@abersnaze is currently doing the tedious bisect + canary test process to figure out which commit is causing the issue. 

Until we can determine what it is we will not be releasing this version.
 =||= Sorry to hear this. Can you give more details about the failure?
My guesses are:
- window with boundary observable factory contains behavior change: at every window end condition, now the factory is called
- the anomaly @davidmoten encountered with retry is now amplified
- you are using custom operators which don't properly honor backpressure and the rewritten operators expose this in some ways.
 =||= All we know so far is that threadActiveCount on the app is now constantly increasing, and the only change is the RxJava jar. Here is the comparison between baseline and canary:

![canary](https://cloud.githubusercontent.com/assets/813492/8711198/b765f004-2b04-11e5-89d6-cd18c96279ae.png)
 =||= Really looking forward to this release :clap: 

BTW, why isn't the version v1.1.0? This version seems to include [significant enhancements](https://github.com/ReactiveX/RxJava#versioning).
 =||= > why isn't the version v1.1.0

So far all new functionality has been added with `@Experimental` or `@Beta` annotations. The intent is for them to stabilize and prove themselves and then at the 1.1.0 release promote them to "final"/"stable". Thus, the "significant enhancements" aren't considered formally released until we remove the annotations. This approach allows us to continue moving quickly without piling up changes for months, and avoid increment the minor number every few weeks (which no one wants ... since it implies more change than is really happening). 

The change of `merge` is the only change in this release that really has made me cautious, as last time we touched `merge` "bad things happened" :-)

We definitely are nearing a 1.1.0 release as we have had several `@Beta` and `@Experimental` items for a few months now.

Does anyone think anything in this release should be removed from a 1.0.13 release and held off until we're ready for 1.1.0?
 =||= @benjchristensen Thanks to detailed explanations. `Single` is what I thought is significant.  I agree with you ;)
 =||= turned out to be `cache()`
 =||= Thank you @abersnaze for figuring this out. https://github.com/ReactiveX/RxJava/pull/2969 will need to be reverted, which is proposed in https://github.com/ReactiveX/RxJava/pull/3081.

At this point we don't yet know what the issue is. Do we proceed with 1.0.13 without `cache()` changes, or do we hold up a release until we figure that out?
 =||= I'd hold up the release because if there is indeed a problem with cache(), fixing it surely involves less drastic changes than a full revert.
 =||= Do you have time to help figure it out in the coming days? Also, we don't need to wait a month until 1.0.14. The delay since 1.0.12 is primarily my fault because I've been busy elsewhere. We can definitely move faster.

Another concern I have is your comment about `replay().autoConnect()`: https://github.com/ReactiveX/RxJava/pull/3081#issuecomment-121852351 Do you only suspect the new `autoConnect()` behavior, or all the changes on `replay`?
 =||= I can spare some time to fix cache() but without the usage pattern, I can only guess. Certainly, releasing as is increases a likelihood the problem manifests somewhere else where the devs can create a report with a unit test reproducing the problem.

Both backpressure-aware `replay()` and `cache()` were built quite similarly (`autoConnect()` is not relevant from this aspect), therefore, you could change the `Observable.cache()` method implementation to use `replay().autoConnect()` and see if the same problem happens or not.
 =||= > without the usage pattern, I can only guess

We are trying to build a unit test. I believe the issue we're seeing comes from use of `cache()` in Hystrix: https://github.com/Netflix/Hystrix/blob/990394e98ba7472b96d90d7246e785d0966ade9a/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L481

We use Hystrix at very high volume, and `cache()` will be used by a large percentage of those calls. This explains why this impacted our canary so significantly.

> releasing

Should we revert both `cache()` and `replay()` changes for now, release 1.0.13 with the `Single`, `merge` and other changes, then followup with 1.0.14 including `cache()` and `replay()`?
 =||= I've looked at cache() again and it was prone to child-thrown exceptions, breaking the caching process completely. I've fixed it and replay() in #3088 along with other small changes.
 =||= I ran two canaries. The first was with the #3088 and the second with `cache()` replaced `replay().autoConnect()`. Both showed signed of request threads locking up.  At this point I would like to move forward with a smaller but stable build now.  Pushing off backpressure on cache/replay to the 1.0.14 won't make the feature any later and will allow people access to the bug fixes in 1.0.13 that we know are okay available sooner.

![image](https://cloud.githubusercontent.com/assets/406038/8758730/751f666e-2c9c-11e5-9ff1-b06cf3a3fb14.png)
 =||= Agreed. Let's revert these and move forward with 1.0.13 and release 1.0.14 when these are fixed. 
 =||= I've updated the #3081 to rollback both cache and replay.
 =||= @benjchristensen Could you apply, release and undo the "undo" in #3081 so I don't need to start from scratch again? 

One final test I'd conduct is to revert `cache()` to its previous form and add `.onBackpressureBuffer()` to it. If this hangs, it is likely there is a backpressure bug in the consumers of `cache()`. If it passes, my guess is that the downstream doesn't tolerate live synchronous replays (`cache()` used to connect first, then accept the child `Subscriber`).
 =||= One other thing I can think of is the effect of the `onStart` patch. Some existing code relied on the fact that it will be called twice and is now under-requesting at the beginning.
 =||= I think the handling of this issue, distinguishing between experimental vs stable APIs, stability vs features philosophy, usage of Atlas and canary builds would make a nice addition to the Netflix tech blog. So many good practices demonstrated in one place, it's exemplary.
 =||= @akarnokd the test of commit `96786bb` + `.onBackpressureBuffer()` also fails the canary. What kind of bug should we be looking for? Not requesting enough?
 =||= I'd check all places which call `request` but with an odd amount, for example, `request(RxRingBuffer.SIZE / 2)` in your code base.
 =||= `replay` and `cache` changes reverted: https://github.com/ReactiveX/RxJava/pull/3081
 =||= Please consider including fix #3091 as well into 1.0.13.
 =||= Merged. The current 1.x branch is what I intend on releasing shortly.
 =||= Released https://github.com/ReactiveX/RxJava/releases/tag/v1.0.13 and https://bintray.com/reactivex/RxJava/RxJava/1.0.13/view
 =||= ,0
3101,3095,Observable.take() on a BehaviorSubject swallows "fatal" errors.,It seems that if your subscriber throws a "fatal" exception when subscribing to a BehaviorSubject chained with just, the fatal there error is swallowed and nothing is logged. See the following example:

```
    public static void main( String[] args )
    {
        BehaviorSubject<String> strings = BehaviorSubject.create( "First" );

        RxJavaPlugins.getInstance().registerErrorHandler( new RxJavaErrorHandler()
        {
            public void handleError( Throwable throwable )
            {
                System.err.println( throwable );
            };
        } );

        strings.take( 1 ).subscribe( string -> { throw new NoClassDefFoundError(); },
                                     System.err::println );
    }
```

If the error thrown from the subscribe function is anything but a "fatal" error as determined by `Exceptions.throwIfFatal(Throwable)` an error is properly propagated.,This is a strange situation: take sets its completed flag before the emission and when the exception is bounced back, it is not propagated any further. Looks like a bug.
 =||= @akarnokd Thanks for the quick bug fix!
 =||= The bug is fixed and is now part of 1.0.14. Thanks for reporting.
 =||= ,0
3103,3098,materialize() and dematerialize() backpressure support,Just a note that I'm working on PRs for backpressure support for `materialize()` and `dematerialize()`. Let me know if you are already working on this.

The problems are these
- `materialize` can emit one more than requested (the completion or  error notification)
- `dematerialize` on a source of N items should emit N-1 items but requires a request of N to also report the completion event,Solved via #3103
 =||= ,0
3108,3106,OperatorOnErrorFlatMap - can we remove?,The class `OperatorOnErrorFlatMap` is not used and I see bugs in its implementation anyway (unsubscribe of `child` does not unsubscribe `resume` subscription). Can we remove?,Yes
 =||= ,0
3118,3003,API for Creating Safe Back Pressure Observables,# The Problem:

Creating Back-Pressure Enabled Observables that produce data from a non-blocking source is hard and our current APIs for creating arbitrary observables do not lend towards creating observables that respect the back pressure rules. Users have a choice between calling one of the Observable static method to generate standard case observables using well known patterns or they can attempt to implement a responsible observable out of an `OnSubscribe<T>`. I will define a "responsible Observable" to be an observable that does the following:
- calls `subscriber.onNext(t)` only when the `subscriberCapacity > 0` where `subscriberCapacity` is the sum of the integer arguments for all invocations of `producer.request(n)` minus the number of calls made to `subscriber.onNext(t)`.
- calls `subscriber.onCompleted()` or `subscriber.onError(e)` only once.
- does not call `subscriber.onNext(t)` concurrently.

The onSubscribe lifecycle of a responsible observable should fit within the following lifecycle.
1. The `onSubscribe.call(Subscriber<T>)` method is invoked by the `Observable.subscribe(Subscriber<T>)` method.
2. The OnSubscribe func creates a `Producer` via the `subscriber.setProducer(Producer<T>)` method. At some point in the (potentially distant) future the subscriber may call `producer.request(n)`. This signals to the observable that capacity is allocated  in the subscriber.
   3a. Values are produced via a call to `subscriber.onNext(t)`.
   3b. At some point a terminal event is emitted via `onCompleted` or `onError`.

This allows for many different variations of control flow given that onNexts could possibly be scheduled, data could be pre-fetched, excess data could be batched or dropped, etc...
# Proposal

With this ground work in mind I would like to start a discussion about a general framework that correctly models the various use cases, particularly with respects to the following requirements:
- capable of paginating data across multiple requests
- batching requests
- hot and cold data sources
- async and blocking onNexts
## Naive Implementation

User provides callbacks that the framework will call between each of the steps above. That is
1. Observable calls `onSubscribe.call(s)`
2. The framework's onSubscribe calls: `S dataState = onSubscribeGenerator.call()`
3. Next the onSubscribe calls: `subscriber.setProducer(p)` setting a framework Producer
4. At some point the request is received by our producer `p.request(n)`
5. Then the framework will call the user provided request callback and store the new resultant `dataState` for future requests. `dataState = onRequestCallback.call(dataState, n, s)`

Obvious short comings of this approach: Order may not be preserved across multiple requests if the `onRequestCallback` schedules the onNext. Also onNexts may be concurrent so the subscriber must be wrapped with a serializing subscriber. Also, a case could be made that many observables created should specify the backpressure strategy. Any thoughts are welcome. ,What's wrong with [AbstractOnSubscribe](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/observables/AbstractOnSubscribe.java)? 

In addition, there is a PR #2813 which features a batching-capable producer-construction. 

Also you can read my blog about [Advanced RxJava](https://akarnokd.blogspot.com) which explains the concepts and shows examples about how one can build producers and thus operators and `Observables`.
 =||= @akarnokd The purpose of this issue is to initiate a discussion and refine the concepts in AbstractOnSubscribe and the AbstractProducer. Both of these facilities are currently annotated `Experimental`. The goal here is to refine them to something that supports the various use cases in an approachable manner.

Some items that need some work on the AbstractOnSubscribe:
- does not support batching multiple requests
- generating data in a paginated way is difficult with the api since for each request there is an invocation of the user callback. i suspect this is where the phases are intended to help.
- the decoupling of the onNext to the SubscriptionState and the onNext to the subscriber makes stacktraces and errors harder to reason about

The [AbstractProducer](https://github.com/ReactiveX/RxJava/pull/2813) is clearly a better approach to me. For every `request(n)` call there is a call to the `onRequest` callback. This makes it easier to paginate data and also to respond to requests asynchronously. However I think that async responses to a request would cause interleaving batches to be processed in the naive implementation. @benjchristensen and I have been discussing this problem and believe that the user would have to account for this by appending to a queue and then draining. This could probably be made first class for some use cases if that's what's needed for responsible observables from non-blocking sources.
 =||= @benjchristensen and I worked on the following examples and we would like input on the following APIs. We have broken apart this issue into what we think are 2 primary use cases. Firstly there is the case where data is generated asynchronously from a non-blocking source. Secondly there is an api for writing responsible observables from synchronous sources. This looks very similar to the AbstractOnSubscribe. 

The async case is illustrated in code below. We are considering a system which calls your function every time there is a call to `producer.request(n)` and the user's function would return an `Observable<T>`. The returned observable would then be eagerly subscribed and concatted (to ensure ordering is maintained). 

``` java
// to illustrate method signature in below example
class ObservableAsync {
    /**
     * Has an overload for handling request(Long.MAX_VALUE)
     * It is possible to chunk an infinite request and make a requestFiniteFunc
     * play nicely.
     *
     * Note: this assumes serialized request calls per subscriber. This means we 
     * will have to do thread stealing (essentially merge).
    */
    public static <T> Observable<T> createAsynchronous(
        Func0<S> generatorFunc,
        Func2<S, Long requested, Observable<T>> requestFiniteFunc,
        Func1<S, Observable<T>> requestInfiniteFunc,
        Action1<S> onTerminate) {}
}

// Data state class used in the below example
public class RestClientState<T> {
    private Client client = /* your favorite async client */ null;
    private Integer lastIndex = 0;
}

// ASYNC EXAMPLE
Observable.<T>createAsynchronous(
    () -> { new RestClientState<Foo>(url) },
    (RestClientState<Foo> state, Long requested) -> {
        int i = state.lastIndex;
        state.lastIndex = i + requested;
        Observable<Foo> obs = state.client.getRange(i, i+requested);
        return obs;
    },
    (RestClientState<Foo> state) -> {
        Observable<Foo> allOfThem = state.client.getAll();
        return allOfThem;
    },
    (RestClientState<Foo> state) -> {
        state.client.free();
    });
```

The synchronous case (below) is a modification from the existing designs embodied in the `AbstractOnSubscrbe`. The highlight of the changes are as follows. 
- Changed the `SubscriptionState` to be agnostic of the data state. This results in the handler passing in the datastate and returning a datastate.
- Changed the data generator func to call onNext, onCompleted, and onError straight into an object that wraps the subscriber. This object would prevent calling onNext more than once per invocation of the user's func.
- Generator func no longer has access to the `Subscriber`

``` java
class ObservableSync {
    public static <T> Observable<T> createSynchronous(
        Func0<S> generatorFunc, 
        Func2<S, Subscriber<T>, S> nextFunc, 
        Action1<S> onTerminate) {/*...*/}

    // Functional equivalent overload but no need to return
    public static <T> Observable<T> createSynchronousStateful(
        Func0<S> generatorFunc, 
        Action2<S, Subscriber<T>> nextFunc, 
        Action1<S> onTerminate) {/*...*/}
}

List<Foo> myList = null; // ....

// SYNC Example
Observable.<Foo>createSynchronous(
    () -> { myList.iterator() }, 
    (Iterator<Foo> state, Subscriber<Foo> child) -> {
        if (!state.hasNext())
            child.onCompleted();
        // cannot onNext more than once from func
        child.onNext(state.next());
        return state;
    },
    (it) -> {it.free()}
    ).subscribe();
```
 =||= > there is a call to producer.request(n) and the user's function would return an `Observable<T>`

How will you make sure the observable contains exactly n elements? What kind of observable would you create and return?

> `Func2<S, Integer requested, Observable<T>>`

Requested amounts are Longs.
 =||= @akarnokd The return type would be a plain ole `rx.Observable` (kinda like a POJO but... without the J). We should be able to eagerly subscribe to all emitted observables then serialize their outputs using buffers. I imagine these would be calls using RxNetty, RxJdbc, wrapped futures, etc. 

Do we have to ensure that the observable contains exactly n elements? If they write an irresponsible observable then they get a `MissingBackpressureException`. Its possible to subscribe a take(n) to the observable but then we are getting into the business of enforcing that all observables play nicely when its relatively easy to follow the documentation. 

I have edited the comment to correct the types.
 =||= I think that an implementation for #3017 should help serialize the output from multiple observables.
 =||= @akarnokd Do you disagree with anything here in principle? If not, are you already working on refactoring the synchronous `AbstractOnSubscribe` or working on the async case? I'd like to coordinate our efforts to make sure we aren't both working on the same piece. 
 =||= I'm not working on any of the cases and I'm not planning it either.
 =||= I strongly agree that we need to improve how `Observable.create` can be used to generate correct `Observable`s with and without backpressure. 

These "abstract" classes are the base, but I suggest we need to incorporate them into the Observable API such as this:

##### Non-backpressured Push Sources

This is for pure push sources that don't have backpressure.

``` java
Observable.createEventStream(..., DefaultBackpressureStrategy)
```

For example:

``` java
// mouse event listener with default backpressure strategy to DROP
Observable.createEventStream(o -> {
          mouseEventListener.addListener(l -> o.onNext(l));
}, OnBackpressure.DROP);
```

##### Backpressured Synchronous Pull Sources (Batched Stream)

This is for data sources that can be pulled synchronously, such as an `Iterable` or other similar data structure.

``` java
Observable.createSync(...)
```

##### Backpressured Asynchronous Pull Sources (Batched Stream)

This is for data sources that can be pulled asynchronously, such as network IO, async File IO, or retrieving from queues across thread-boundaries, etc.

This is very common, and very hard to do right. 

``` java
Observable.createAsync(...)
```

##### Backpressured Asynchronous Pull Sources (Single Item)

This is actually for returning a `Single`, but I'm suggesting we have a factory method on the `Observable` because that is the common place to start from. Or we still return an `Observable` but it is only a single item.

This is the same behavior as the `createAsync`, except that it is far easier since it only fetches a single item. This is the most common case for async request/response.

``` java
Single<T> Observable.createFetch(...)
```

###### Summary

If we can improve how these all work, it will greatly simplify creation and use of Observable.

Are there use cases or variants I'm missing? What should we name them? What are the method signatures we should have for each?
 =||= We have `SyncOnSubscribe` and `AsyncOnSubscribe`. Is there anything else?
 =||= I think we should come up with factory methods on Observable to expose these abilities alongside the default 'create'. What do you think the right names are?
 =||= `generate` and `generateAsync`
 =||= How about something starting with 'create' so that people find it alongside the 'create' method in Javadocs and IDE code-completion? 

We want to nudge people to using these instead of normal 'create'. Also, I don't want to confuse with the Rx.Net/RxJS 'generate', as they aren't exactly the same (though the sync one is similar). 
 =||=  A quick note that I don't think the names `SyncOnSubscribe` and `AsyncOnSubscribe` are great in that the names do not characterize their functionality. To my mind they are not natural duals which is suggested by the naming. I also note that `AsyncOnSubscribe` is not practical at the moment without a request batching operator (a downstream `filter` for example may cause async requests for one element at a time at the source).
 =||= It'd be a good idea if we fixed these inefficient `producer.request(1)` cases and batched them more intelligently. For instance when observeOn request behavior devolves into request 1 patterns. 

Initial names that come to mind... `createSynchronousSource` and `createAsynchronousSource`

But considering @davidmoten 's input perhaps the existing names are not indicative of their usage. `SyncOnSubscribe` is intended for usage generating data from a synchronous data source while the `AsyncOnSubscribe` is intended to consume data from a potentially asynchronous data source. The confusion may come from a lack of clarity in their usage. 

That said, would you agree with `Observable.createFromHotProducer(...)` (which would use a `SyncOnSubscribe`) and `Observable.createFromColdProducer(...)` (`AsyncOnSubscribe`)?
 =||= We have `create(SyncOnSubscribe)` and `create(AsyncOnSubscribe)` in 1.x. Do you want to pursue the remaining generator modes for 1.x?
- Signal  0 or 1 element or an error in push fashion. (for Observable and Single) Use case: working with classical callback-based APIs.
- Signal 0 to N elements, followed by an error or a complete signal in a push fashion. Use case: callback-based APIs and listeners that produce multiple values.
 =||= I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one. =||= ,0
3120,1914,Thread Interruption on Unsubscribe,A few issues recently have been related to Thread interruption and brings into question why we interrupt the thread when we unsubscribe a scheduled action (via a `Scheduler`). 
- #1913 Computation Scheduler gets interrupted thousands of times per second?
- #1898 Scheduled action no interrupt
- #1832 Fix Take Early Unsubscription Causing Interrupts
- #1804 "Interrupted while waiting for subscription to complete." in 1.0.0-rc8

The code that causes this is from https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/subscriptions/Subscriptions.java#L102 that wraps a `Subscription` around a `Future`. This in turn is used by `ScheduledAction` which is used when scheduling work via a `Scheduler`. 

Issue #1898 is working to not cause an interrupt after successful termination, but I want to question why we ever interrupt as default behavior. 

I don't think much thought went into choosing to call `cancel(true)` instead of `cancel(false)` and I'd like to discuss changing this to not interrupt. 

The implication of interrupting are difficult to manage well and add a lot of complexity. 

The only time interrupting seems wanted is if unsubscribing early to a `ScheduledAction` doing blocking IO. Otherwise the `Subscription` itself is the cancellation token that work should be checking (most code doesn't properly use `Thread.isInterrupted()` anyways so it rarely helps). 

If an `Observable` is doing blocking IO it seems it should opt itself into doing Thread interruption. Perhaps we should figure out an idiomatic approach to that for opting into that behavior without requiring interruption all the time. ,@benjchristensen makes total sense. I'm not so into the details, maybe we can only do the interruption on the IO scheduler? especially not on the computation one.
 =||= The developers of the JDK threadpool couldn't decide it either so they went for providing the option to the programmer. Either we don't do interrupts on the computation scheduler, but do it everywhere else; or we extend the API and inject an `interruptible` flag all around. 

Two clarifications: ScheduledAction has its own Future wrapper; ScheduledAction wraps an Action0 and the ScheduledAction itself is not accessible inside this Action0 so it can't act as a cancellation token nor can be manipulated to gain access to the Future it holds to issue an cancel(true); one would need to exfiltrate the worker thread but then it becomes dangerous to call interrupt on it.
 =||= I have a `ScheduledAction` enhancements that will support customization of the interrupt behavior. See #2592.
 =||= Resolved in https://github.com/ReactiveX/RxJava/pull/2579
 =||= Following #2579 to #2592 to #2761 to #2772, it doesn't look like this is actually resolved, is it @akarnokd?
 =||= None of the customizations made it and it seems Hystrix solved it internally. There were a few changes made to ScheduledAction so it doesn't call cancel(true) when cancelling from the same thread.
 =||= ,0
3121,3119,NewThreadWorker.tryEnableCancelPolicy doing costly reflection on Android,I was  analyzing startup time in the NY Times Android app and started method profiling on startup using Android Device Monitor.  Total time from the beginning of the application class to end of onCreate for first activity is roughly  2.2seconds. Diving deeper I was able to observe that `NewThreadWorker.tryEnableCancelPolicy`
 was taking 1200ms to execute with the offending line being  
`for (Method m : exec.getClass().getMethods())` (1017ms)
Diving deeper shows a call to 
`CollectionUtils.removeDuplicates (992 ms)`  
which will call 
`collection.sort` (719ms)
 & 
`reflect.compare`(259ms).

tryEnableCancelPolicy has the following comment: 

``` /**
     * Tries to enable the Java 7+ setRemoveOnCancelPolicy.
     * <p>{@code public} visibility reason: called from other package(s) within RxJava.
     * If the method returns false, the {@link #registerExecutor(ScheduledThreadPoolExecutor)} may
     * be called to enable the backup option of purging the executors.
     * @param exec the executor to call setRemoveOnCaneclPolicy if available.
     * @return true if the policy was successfully enabled 
     */ 
```

I tried creating a Scheduler from an Executor but still hit the offending code.  Is there a way to avoid this code or fix the large performance hit that it is causing?,Woah. If the signature of the to-be-reflected method is known why is a direct lookup not being done?
 =||= @digitalbuddha You can use the system property "rx.scheduler.jdk6.purge-force" set to "true" to avoid the loop. The reason for the loop is to avoid NoSuchMethodException being thrown on JDK 6 which is more costly than looping through ~70 methods. Although I admit evaluating that all the time is unnecessary as Executors.newScheduledExecutor() won't change is ability during runtime.
 =||= Thankfully that property _just_ squeezes under Android's 31 character max at 29 chars!
 =||= Can we use `PlatformDependent.isAndroid()` to default this to `true`?
 =||= My google search indicates the method `setRemoveOnCancelPolicy` is supported from API level 22. If there could be a way to discover the API level programmatically and cross-platform safe then sure.
 =||= The `android.os.Build.VERSION` class has an `SDK_INT` int constant which can be read. The presence of the class could replace the check for `android.app.Application`.
 =||= @akarnokd what do you mean by 

>  cross-platform safe

? `android.os.Build.VERSION` is safe to call for all Android versions. 

Documentation: http://developer.android.com/reference/android/os/Build.VERSION.html#SDK_INT
 =||= Android is one platform
 =||= Great. Would you like to submit a PR?
 =||= Just pushed the PR #3121.

Android [supports `ScheduledThreadPoolExecutor.setRemoveOnCancelPolicy()` since API 21](http://developer.android.com/reference/java/util/concurrent/ScheduledThreadPoolExecutor.html#setRemoveOnCancelPolicy%28boolean%29).
 =||= Little Gist for those who want to fix this in Android app with RxJava: https://gist.github.com/artem-zinnatullin/51b6c6720ecb8a2a71eb
 =||= Your gist says "static initializer block" and then proceeds to use an instance initializer block.
 =||= Such a stupid mistake…Uh. Thanks.
 =||= ,0
3129,3128,MissingBackpressureException when using Retry with Predicate,In some production code, I noticed that it is possible to create a situation where the retry method that accepts a predicate produces a MissingBackpressureException. However, other retry methods do not produce such an exception.

I've created a small test case here:
https://github.com/dfjones/RxJava/blob/67a18a453616539faf16204637b9399057e0bf8e/src/test/java/rx/RetryBackpressureTest.java

Apologies for this being a non-deterministic test, but on my laptop the `testBackpressurePredicateRetry` test will reliably fail due to MissingBackpressureException with the trace below. 

However, the `testBackpressureNormalRetry` test will run for 1 minute without producing this exception.

Admittedly, this might be a convoluted setup, but it reflects a situation I had in some production code. Essentially, I have a flow where for each event produced by an Observable, I need to perform some IO with retries. So, I've spread that IO work over a Scheduler. The IO work produces many individual events. In my test case, imagine this inner Observable is performing IO:

``` java
AbstractOnSubscribe.create((state) ->
            state.onNext(2L))
```

Everything in this flow should respond to back-pressure through the use of `AbstractOnSubscribe`, however I'm running into the issue described here when using retry with a predicate function.

```
rx.exceptions.MissingBackpressureException
        at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:349)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.queueScalar(OperatorMerge.java:345)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:328)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:802)
        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)
        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber$1$1.onNext(OperatorRetryWithPredicate.java:113)
        at rx.observables.AbstractOnSubscribe$SubscriptionState.accept(AbstractOnSubscribe.java:535)
        at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:369)
        at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:340)
        at rx.Subscriber.setProducer(Subscriber.java:209)
        at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:192)
        at rx.observables.AbstractOnSubscribe$LambdaOnSubscribe.call(AbstractOnSubscribe.java:275)
        at rx.Observable.unsafeSubscribe(Observable.java:7689)
        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber$1.call(OperatorRetryWithPredicate.java:120)
        at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:80)
        at rx.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:59)
        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:77)
        at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:45)
        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)
        at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)
        at rx.Observable$1.call(Observable.java:144)
        at rx.Observable$1.call(Observable.java:136)
        at rx.Observable.unsafeSubscribe(Observable.java:7689)
        at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
        at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)
```,That particular retry overload doesn't support backpressure. I'll post a PR that fixes it.
 =||= Fixed in #3129. It may take some weeks until 1.0.14 is released though.
 =||= @akarnokd Thank you for the quick response and fix. I tried your patch with my test and it appears to have fixed the issue. Thanks!
 =||= Fixed via #3129 and patch delivered in 1.0.14
 =||= ,0
3147,3145,Expanding Community Involvement & Contribution,Earlier this year we expanded the committers of RxJava to include non-Netflix engineers. I'd like to now further explore how we can broaden community involvement and lessen dependence on me. The recent ["RxJava Truck Factor" issue](https://github.com/ReactiveX/RxJava/issues/3133) was a reminder of this topic and pushed several of us inside Netflix to raise the priority on tackling this. 

First, a note on how great the community has been thus far! We have had great [contributors](https://github.com/ReactiveX/RxJava/graphs/contributors), several having contributed significant time, effort and skill and without whom RxJava would not be as good as it is. Many who are not shown with "code contributions" have helped immensely in answering questions on Twitter, StackOverflow, Google Groups, blogging, speaking at meetups and conferences, or helping build reactivex.io. In short, the community around RxJava is already great.

However, I'd like to achieve a few things:

1) Make it possible for others to fulfill the "release engineer" role I'm still playing.
2) Ensure there are no irreplaceable people on the project. 
3) Improve the reliability for getting code reviews and questions answered in a reasonable time frame.
4) Improve the release cadence so it is more reliable, and less dependent on me getting bursts of time. 
5) Make it easier for community to get involved by pointing to where they can help in ways other than writing code.
6) Find a way to recognize people for involvement in the many important areas other than lines of code committed. 

A few ideas on making these happen include:
- More engineers from Netflix with time formally allocated. I will bootstrap them and ensure they have everything needed to do releases without me.
- More comprehensive CONTRIBUTING.md (Rust has a good example: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md)
- Ask community to help with StackOverflow, Google Groups, Issue/PR Triage, Twitter (and perhaps recognize people somehow who do these things?)

A key thing I want people to understand is that writing code is actually the easiest part of maintaining a project like this. The lifecycle is far harder and more time consuming. This includes:
- code reviews
- answering questions
- deciding whether a change should be made or not
- discussing design decisions and deciding which tradeoffs to make
- balancing change with stability
- writing documentation
- debugging issues 
- replicating bugs with unit tests
- answering more questions
- tutorials, blogs, speaking, training, etc

All who are interested in RxJava, what ideas do you have for helping us improve and achieve the above? What else should we pursue and improve?,Netflix Engineers involved in this discussion include: @stevegury @abersnaze @stealthcode @mattrjacobs 

I am making sure they have all necessary credentials for Travis, BinTray and Maven Central so that in my absence, if there are issues with the automated pipeline, they can debug and fix. Additionally they will get the Twitter credentials so they can post to Twitter for releases and other such information. 

We are working amongst ourselves to allocate time each week per engineer to help with code reviews (pull requests), Github issues, and releases.
 =||= Various places of community engagement:

Google Group: https://groups.google.com/forum/#!forum/rxjava
Gitter: https://gitter.im/ReactiveX/RxJava
StackOverflow: http://stackoverflow.com/search?q=rx-java
Twitter: https://twitter.com/search?q=rxjava
Github: https://github.com/ReactiveX/RxJava/issues
Speakerdeck: https://speakerdeck.com/search?utf8=✓&q=rxjava
 =||= Benjchristensen, I'm not from Netflix and would like to contribute to RxJava. 
Can you pls direct me  how to contribute to RxJava?

Tks
Sudar
 =||= @sudaredd https://github.com/ReactiveX/RxJava/wiki/How-to-Contribute is a start (we could probably add more info to that page)
 =||= I like this, guys! Kudos! RxJava is a huge effort. @benjchristensen needs all the help we can give him.
Obviously, I expect I will get a cool Netflix t-shirt as bug hunter, funny conference speaker and books author :tongue: 
 =||= > I expect I will get a cool Netflix t-shirt as bug hunter, funny conference speaker and books author

We'll see what we can do! :-)

@sudaredd The link @davidmoten gave is the current starting point. I'm trying to mature that with this discussion and figure out how we can improve community engagement.

The best way to get started in the project is to help us answer questions at the many places above, help triage and prove bugs (and fixes), and improve documentation.
 =||= Anyone have suggestions on how to execute on my stated goals?
 =||= Here are my 2 cents:
- Knowing that Netflix is offering more full-time people to the project, I think that the _releasing_ task should be still safely handled by Netflix;
- From a _coding_ point of view, Github should handle the contribution recognition properly: PR, comments, tech discussions will shows active users;
- From a _supporting_ point of view, StackOverflow offers _tags_ and _top users_
  http://stackoverflow.com/tags/rx-java/topusers
  Btw, congrats @davidmoten! @mrsasha we definitely need to spend more time on SO :smile:  
- We could use the wiki to create a collection of useful teaching contents: videos, tutorials, example, and try to involve those authors
- A bit of marketing, promoting this new project with Android Weekly, for instance, and other equivalent Java communities.

What do you think?
 =||= > Anyone have suggestions on how to execute on my stated goals?

->

> 3) Improve the reliability for getting code reviews and questions answered in a reasonable time frame.

There are **21 open pull requests**, some of them are really old, also there are **166 open issues**…

And looks like that at the moment, the only active (comments, code reviews and PRs almost every day) person in the project is David Karnok @akarnokd and I guess he has other things to deal with, so it will be good to **add at least one another active person** to the project. 
 =||= @artem-zinnatullin that is certainly a motivating factor behind adding Netflix engineers to the project and by expanding the community involvement. We want to insure that issues and pull requests are responded to in a timely manner. 
 =||= Thanks @hamen for the input.

> I think that the releasing task should be still safely handled by Netflix;

Agreed.

> From a coding point of view, Github should handle the contribution recognition properly: PR, comments, tech discussions will shows active users;

Agreed. Though would it be helpful to call out in a "TEAM" doc those who are actively engaged so others know who to reach out to for different aspects of the project? For example, those for documentation, build tooling, release, etc?

> From a supporting point of view, StackOverflow offers tags and top users

Good point. Though not everything is on StackOverflow.

The part I'm wondering about is whether it makes sense to have individuals called out as being part of "the team". If someone is involved, but then drifts away, perhaps we have a 3 month expiry so that if we haven't seen someone for a while, we move them into "emeritus" status so we recognize their involvement from the past, but let people know they aren't actively involved.

Does something like that make sense?
 =||= Had a working meeting at Netflix today to start transferring domain knowledge that resulted in [v1.0.14](https://github.com/ReactiveX/RxJava/releases/tag/v1.0.14) being released, without me being the one pushing the buttons. 

Going forward the intent is to have the Netflix RxJava team as:
- @stevegury 
- @mattrjacobs 
- @stealthcode 
- @abersnaze 
- @benjchristensen

I am bringing them up to speed on release and communication roles, and they will start involving themselves in pull requests. Over the next week we are going to triage the backlog of open issues.

This should help address the first 4 goals:

> 1) Make it possible for others to fulfill the "release engineer" role I'm still playing.
> 2) Ensure there are no irreplaceable people on the project. 
> 3) Improve the reliability for getting code reviews and questions answered in a reasonable time frame.
> 4) Improve the release cadence so it is more reliable, and less dependent on me getting bursts of 
> time. 

Still need to figure out the others ...
 =||= > If someone is involved, but then drifts away, perhaps we have a 3 month expiry so that if we haven't seen someone for a while, we move them into "emeritus" status so we recognize their involvement from the past, but let people know they aren't actively involved.

Agreed. We could schedule "involved developers" list updates every quarter as a "development task" (a Github issue could work).

> Good point. Though not everything is on StackOverflow.

I have asked Github support guys if they have some kind of statistics for repo wiki. We could have users helping on the wiki and it will be fair to recognize them.

> Had a working meeting at Netflix today to start transferring domain knowledge that resulted in v1.0.14 being released, without me being the one pushing the buttons.

Very nice, guys! Updating `build.gradle` right now.
Looking forward.
 =||= Github reply came in: it's not possible at the moment. We will figure out something else then.
 =||= From the "release engineering" point of view, maybe it would be useful to schedule some kind of release runs where a few people would go through PRs and issues and try to solve them before the release, and triaging the old ones to see if they're still applicable or not? Like a tentative release every month and a week before that is just for issues and open PRs?

As for contributing, I might have missed it, but I didn't see a style guide anywhere. Is there one?
 =||= Not sure of the actual entity and library impact but I think @davidmoten helped quite a bit in this last period.
 =||= I'd like to revisit this discussion. It's about 6 months on from the initial discussion, and it seems that @akarnokd is still the only _active_ collaborator on the project. I've had side discussions with a lot of fellow engineers, and some are starting to worry about the future of this project given the passiveness from Netflix on this since @benjchristensen left. 2.0 doesn't seem any closer with only three commits since October, and the future beyond that seems largely unclear (especially in regards to Java 9's Flow API).

This becomes particularly obvious when you consider that there was an agreement some time ago that :+1:'s from two collaborators are enough to get something merged, but there's only ~two actively reviewing collaborators period. There are **31** open PRs and a further **160+** open issues.

I'm not sure what the solution to this is, but the current trajectory seems that the project is beginning to stagnate due to a lack of active maintainers and leadership.

# Some stats since August 1st, 2015

Generated from a script I wrote up for this comment: https://gist.github.com/hzsweers/1453fdcd92b4ab689021

### Commits to 1.x

_Who's moving the project forward._

```
122 akarnokd
36  stealthcode
23  abersnaze
23  artem-zinnatullin
13  zsxwing
8   davidmoten
5   DavidMGross
5   stevegury
3   hyleung
3   Turbo87
2   JakeWharton
2   vqvu
2   Chaoba
2   benjchristensen
2   vanniktech
```

### Comments on issues

_Who's maintaining the repo and engaging the community._

```
224 akarnokd
102 benjchristensen
76  davidmoten
56  artem-zinnatullin
28  stealthcode
28  zsxwing
26  JakeWharton
19  abersnaze
13  thomasnield
10  headinthebox
8   srvaroa
8   NachoSoto
8   Chaoba
7   NiteshKant
6   eirslett
```

### Comments on PRs

_Who's reviewing code._

```
27  akarnokd
26  artem-zinnatullin
10  davidmoten
7   thomasnield
4   zsxwing
3   srvaroa
2   JakeWharton
2   stevegury
1   JohnWowUs
1   msavitskiy
1   bcorne
```

### Opened PRs

_Who's moving the project forward._

```
18  akarnokd
2   davidmoten
2   artem-zinnatullin
1   thomasnield
1   JohnWowUs
1   msavitskiy
1   myArea51
1   bcorne
1   srvaroa
1   achinthagunasekara
1   Chaoba
```

### Total contributions

```
391 akarnokd
107 artem-zinnatullin
104 benjchristensen
96  davidmoten
64  stealthcode
45  zsxwing
42  abersnaze
30  JakeWharton
21  thomasnield
12  srvaroa
11  Chaoba
10  stevegury
10  headinthebox
9   DavidMGross
8   NachoSoto
```

(This weighs a PR equal to comments, which is a little misleading. I don't know what fair weights would be, but considering PRs are the lifeblood of the repo, akarnokd's factor would be more through-the-roof than it already is)
 =||= Chiming in from NY Times. We were one of the early adopters and would hate to see project stagnate as we are very heavily invested. Artem was recently hired by my team (framework). We'd love to be more involved as contributors/collaborators  to this project 
 =||= I read every issue and review every PR but refrain from commenting on 99% of them since my only issues are nitpick or style related which is just annoying (to other contributors) and there's no other value commenting since I'm not one of the contributors whose votes are required.

As a non-contributor reviewer, though, it's annoying to review every PR only to see them sit for long periods of time.
 =||= Yes, 2.0 is standing still, maybe its too big for anyone to review it.

> 2.0 doesn't seem any closer with only three commits since October

And 11 other waiting in line. I gave up on it because fixes started to depend on the order the PRs have to be merged and I don't want to rebase all the time.

> As a non-contributor reviewer, though, it's annoying to review every PR only to see them sit for long periods of time.

As an active contributor, it makes me annoyed having things sitting there as well. I, lately, tend to forget what fix I posted to what project and what version and sometimes find myself unable to move because a fix or the addition of some utility in one PR is required by some other PR.

In addition, things have evolved beyond my 2.0 implementation over in [reactive-streams-commons](https://github.com/reactor/reactive-streams-commons) project, but I have hard time to imagine how those enhancements will ever get back into RxJava (any version) at the moment.

The policy on the review process really slowed things down; I'm on the favor of merge first, discuss later since there is the release-gate as the final resort to stop something very wrong. But if RxJava went on the release-early release-often path, even that wouldn't be an issue.

Certainly, @zsxwing (contributor so his :+1: counts)  has become more active recently but generally @artem-zinnatullin does a good job at review too. I suggest accepting @artem-zinnatullin 's :+1: also towards merging a PR. Of course, due to timezone differences, some non-trivial PRs may need to wait 16 - 24 hours so all contributors have a chance to look at it.

Even though this speeds up merging PRs, the release right is still in Netflix' hand (but technically it's just pressing a button).

The benefit of having Neflix' banner over the project is that developers tend to chose libraries from big names over unknown Eastern European solo guy, but the drawback is that the project mostly mirrors the internal expectations and requirements of Netflix' own use and involves the **risk** that their use 'breaks' due to the community moving into a different direction. The other side of the **risk** is that Netflix can't cherry-pick fixes to support their own process from a free-running project with intertwined fixes and enhancements.

I've been thinking a lot about forking RxJava lately, which I technically did with the [RxJava 2 backport](https://github.com/akarnokd/rxjava2-backport) and the [JDK 9 conversion](https://github.com/akarnokd/RxJavaUtilConcurrentFlow) (thus I'm covered); but RxJava is the foundation to many other projects, RxNetty, RxAndroid, Rx..., that have to decide to switch as well. Otherwise, any fork without them is practically useless for real world use. 

This affects 1.x mostly because reactive-streams is general enough you can have interoperating implementations thus using the RxJava 2.0 backport, Rsc, Project Reactor or Akka-Streams mixed is quite possible.

So what's the solution? As Microsoft let RxJS go, maybe Netflix should let RxJava go, or at least allow pressing the release button by other contributors.
 =||= I've been contributing for about two years now to this project and we do seem to be in a slow patch. The project is big enough that a full-time investment from Netflix wouldn't go astray if they seek to have input in such a potentially fast developing codebase (thanks largely to @akarnokd). I've been very happy with @akarnokd's high quality major contributions and oversight. He's clearly able to spend a lot of time on the project and I'd support him having more freedom with merging PRs. Two thumbs up from committers is clearly not working well enough, I assume the Netflix committers have other tasks on their plate (as do most of us!). A big thank you to @zsxwing for weighing in a lot more recently and to new guy @artem-zinnatullin for throwing himself at stuff too.

Like @JakeWharton I read every issue and PR that comes through and review and comment on the ones that interest me. I'd expect non-trivial PRs to be open for a short period to attract input and review but after that period I think @akarnokd's judgement generally is too good to prevent him from merging. There's nothing stopping somebody saying "don't merge this for a week or so I want to have a good look at it".

Recent history has curbed my contributions I should add. The version 2.0 explosion of commits stopped me in my tracks (so much to review and why contribute to 1.0 if 2.0 is just around the corner) as did the introduction of a bunch of new committers (curious about a new dynamic). 1.0 seems alive and well still so I may contribute more to it.

@akarnokd has some confidence in 2.0, leave the merges to him and push out an alpha release? Might at least attract more review and experimentation if at that point.

I'd definitely support much more frequent releases and think it's time Netflix shared the release button or dedicated resources to ensure that this happens.
 =||= Be assured that Netflix is committed to making RxJava a success. Maybe more than any other company, most of our infrastructure rely on it, and we don't want to see it fail. @benjchristensen left a couple of months ago, and we needed time to reorganize the teams around RxJava. 

I'm not opposed to giving more freedom to other external contributors, I need to discuss this internally with the management.
I think that @akarnokd is right to say that having Netflix behind RxJava give more credibility to the project, and, on the other hand, we want to weight in the technical decision made about the project.
 =||= @stevegury that's reassuring to hear. 

I don't think the release frequency has been much of a problem though, there have still been a good few releases in the past 6 months. I think that giving collaborators a little more involvement in the release process is good, but I think the most significant missing element right now is proper stewardship of the repo. Aside from @benjchristensen's code contributions, he was a great shepherd of the project itself. All issues were triaged, issues and PRs were discussed at length, others were called upon for their input, and the direction of the repo was largely clear. In a sense, the train was always chugging on. I think it's safe to say that much of RxJava's flourishing over the past 2-3 years was due to that incubation.

The impression I have is that other Netflix engineers were supposed to step into that maintainer role after Ben left, but that doesn't appear to have happened (at least not nearly to the same degree). I don't know who the right person would be for it if not Netflix (though there are some obvious potential candidates here), but I would be interested to hear your thoughts on it.
 =||= **Not yet** nearly as the same degree indeed.
I'll make sure to dedicate myself more on this task.
 =||= 2014 was RxJava's year on tweeter (2015 is Docker's) and countless developers have seen the greatness of declarative and reactive programming...

As a simple noname developer among many, I don't care if Netflix is behind RxJava.
I'm already using the stuff. It kicks ass.

What I want is bug fixes, more performance, great apis, some new nice features if possible but not bloat, high quality code, simple and painless upgrade paths, maintainers who care and know what they are doing, ...

I'm really grateful to Microsoft to have invented Rx and to Netflix to have brought it to Java. 
But in case the ship was sinking or slowing down to a crawl and there was a healthy fork, battle tested, going forward and maintained by a few caring and dedicated maintainers (even if one of them is living in some unheard of village in eastern Europe), that would just require a package change to join,  I would jump ship in an instant. 

Just felt like chiming in what other RxJava's users might think... 
please excuse me if I'm being rude (that was not my intention). 
 =||= @stevegury Do you think you/Netflix would be able to put together some more concrete plans going forward? 
 =||= Yes!
 =||= Closing in favor of #4013.
 =||= ,0
3149,3022,Scheduler shutdown capability,This comes back from time to time (#1730): some containers, when removing RxJava enabled applications expect it to shut down all its threads but by default, computation threads can't be shut down manually and io threads take 1 minute to shut down on their own. 

This PR adds the capability to make them shut down their worker threads more eagerly. Since such shutdown would be terminal and thus break any subsequent test, a restart capability is required.

Therefore, I've introduced the optional `SchedulerLifecycle` interface which if implemented by a Scheduler, makes it eligible for the `Schedulers` factory to trigger a shutdown or restart for all kinds of schedulers.

Naturally, this implies some extra cost:
- The underlying pool of the computation scheduler is no longer constant and involves a volatile get every time a worker is requested. I haven't benchmarked this but it just adds a cheap load on x86 and shouldn't be a performance hit.
- Since we need to track all ThreadWorkers of the io scheduler, this involves a `CompositeSubscription` and the cost of starting new workers is increased by the synchronization and HashSet.add() operations. However, since starting a new thread in itself is somewhat expensive, again this shouldn't be a performance hit although it's hard to benchmark it.

In addition, to support proper task rejection after the scheduler has shut down, both scheduler types require a constant shutdown worker. These workers are created at class load time and will spin up a thread for a short duration before they shut it down. They don't affect, performance wise, the normal operations but the app startup time might get increased. The tradeoff here is to save on a mandatory class cast whenever a worker is requested.,It appears I've made a copy-paste error and missed the `RxScheduledExecutorPool`.
 =||= I think this all looks good. @abersnaze I'd appreciate your review of this as well.

My only real question is whether we should have `shutdown`/`start`, or just `shutdown` or `reset` that shuts everything down and resets it to a state where it will automatically start up again if anything is used without needing an explicit `start`.

Everything else seems to be internal changes and not public API.
 =||= Cool, I was hoping for this feature!

Small question: would it make sense for the user to be able to control wether the threads execute in daemon mode when the user controls the lifecycle of the threads ? Schedulers.computation() threads are created in daemon mode by default
 =||= Holding off as I want to finish discussing the shutdown/start vs reset API decision. 
 =||= I'll submit a new PR since Eclipse rebase is [broken](https://bugs.eclipse.org/bugs/show_bug.cgi?id=470013) at the moment.
 =||= @akarnokd Why not to rebase from the Terminal? I can help you with that :)

Had never trusted IDEs for such Git actions…
 =||= ,0
3150,3050,Backpressure support for most BufferUntilSubscriber use places.,I've added backpressure support to `BufferUntilSubscriber`, however, the internal workings of `groupBy` were in conflict with my 'clean' approach. Therefore, I kept the original `BufferUntilSubscriber` use in `groupBy` and added `BufferUntilSubscriberV2` and made the various `window()` operators use it instead.

I've also added a two unbounded Spsc queue implementations from JCTools which can reduce the allocation-rate of these linked-node queues.

The problem with `groupBy` seems to be that it sets a producer on the `Subscriber` before it is actually subscribed to the `BufferUntilSubscriber`. The V2 however sets its on producer to support proper replay and kicks out the original coordinator producer. I don't know how to make the two work together yet. Maybe the `groupBy` has to be rewritten from scratch and inline the group backpressure support, request coordination and queueing more directly. An alternative might be to expose the single child request amount in `BufferUntilSubscriber` through a callback to the group somehow.,Holding off on this ... it's is a non-trivial change and I don't have time to review it right now. 

And yes, `groupBy` is a very tricky one to solve. We have rewritten it a couple times already. There are some very tricky edge cases such as "time gap" and head-of-line-blocking. 
 =||= @akarnokd I'm about to review this with @stevegury but before we do, do you want anything changed on this? It does need to be rebased at a minimum if it's still all valid.
 =||= No changes planned to this. I need to manually reapply the changes to a fresh version because my Eclipse's git is broken. Maybe it is better to review a mergeable version instead of this.
 =||= See #3150.
 =||= ,0
3155,2464,`Observable.using` sliently ignores exception of dispose action,Code:

``` java
import rx.Observable;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.functions.Func0;
import rx.functions.Func1;

class Main {

    public static void main(String[] args) {
        Observable.using(
                new Func0<String>() {
                    @Override
                    public String call() {
                        System.out.println("Calling resourceFactory");
                        return "resourceFactory";
                    }
                },
                new Func1<String, Observable<String>>() {
                    @Override
                    public Observable<String> call(String str) {
                        System.out.println("Calling observableFactory");
                        return Observable.just("observableFactory");
                    }
                },
                new Action1<String>() {
                    @Override
                    public void call(String s) {
                        System.out.println("Calling disposeAction");
                        throw new RuntimeException("disposeAction");
                    }
                }
        ).subscribe(
                new Action1<String>() {
                    @Override
                    public void call(String s) {
                        System.out.println("onNext: " + s);
                    }
                },
                new Action1<Throwable>() {
                    @Override
                    public void call(Throwable e) {
                        System.out.println("onError: " + e.getMessage());
                    }
                },
                new Action0() {
                    @Override
                    public void call() {
                        System.out.println("onComplete");
                    }
                }
        );
    }
}
```

Output:

```
Calling resourceFactory
Calling observableFactory
onNext: observableFactory
onComplete
Calling disposeAction
```

This program finishes without error, and the `RuntimeException` thrown in dispose action is silently ignored.,Hi. At that point, it can't notify the subscriber because it received a termination event before. The best thing we can do is to route the exception into the plugin system.
 =||= Can it be made so that `onCompleted` will be called after the dispose action returns successfully? So that if the dispose action throws an error, it can be notified with `onError`. This will make its behaviour consistent with the rest of the error notification workflow.
 =||= @laec, according to the [Rx design guide](http://blogs.msdn.com/b/rxteam/archive/2010/10/28/rx-design-guidelines.aspx), you should not throw an error in the dispose action:

> 6.18. Unsubscription should not throw
> As the Rx’s composition makes that subscriptions are chained, so are unsubscriptions. Because of this,  any operator can call an unsubscription at any time. Because of this, just throwing an exception will lead  to the application crashing unexpectedly. As the observer instance is already unsubscribed, it cannot be  used for receiving the exception either. Because of this, exceptions in unsubscriptions should be  avoided.
 =||= Hi @zsxwing the issue is not whether one should or should not throw the exception, sometimes unexpected errors do occur. According to your quote, I would expect a crash, which generates good visibility, but currently it sliently ignores the error and moves on, which is bad.
 =||= > Can it be made so that onCompleted will be called after the dispose action returns successfully?

I think the essential question is:

How RxJava handle exceptions from `unsubscribe`? 

In many places, RxJava assumes `unsubscribe` won't throw any exception, such as `OperatorTake`. If `unsubscribe` throws some error, it may send it to `onError` (will be swallowed if the subscriber has already received an error), or notify the RxJava plugin, or crash the current thread.

As @akarnokd said, the best solution for RxJava may be sending the exception to the RxJava plugin.
 =||= I don't mind how it gets handled internally, as long as the default behaviour is fail fast - crash, this gives people a chance to notice the issue and fix it.
 =||= How about:

``` java
class Main {

    public static void main(String[] args) {
        final AsyncSubject<Void> onFree = AsyncSubject.create();
        Observable.using(
                new Func0<String>() {
                    @Override
                    public String call() {
                        System.out.println("Calling resourceFactory");
                        return "resourceFactory";
                    }
                },
                new Func1<String, Observable<String>>() {
                    @Override
                    public Observable<String> call(String str) {
                        System.out.println("Calling observableFactory");
                        return Observable.just("observableFactory");
                    }
                },
                new Action1<String>() {
                    @Override
                    public void call(String s) {

                        System.out.println("Calling disposeAction");
                        try {
                            throw new RuntimeException("disposeAction");
                            // onFree.onCompleted();
                        } catch (Throwable ex) {
                           onFree.onError(ex);
                        }
                    }
                }
        ).mergeWith(onFree).subscribe(
                new Action1<String>() {
                    @Override
                    public void call(String s) {
                        System.out.println("onNext: " + s);
                    }
                },
                new Action1<Throwable>() {
                    @Override
                    public void call(Throwable e) {
                        System.out.println("onError: " + e.getMessage());
                    }
                },
                new Action0() {
                    @Override
                    public void call() {
                        System.out.println("onComplete");
                    }
                }
        );
    }
}
```
 =||= I feel that's just a short term workaround for the issue. We can't expect users of `Observable.using` to do this every time (and we certainly can't expect them to be aware of this issue), it's boilerplate and awkward and even more so when you need to chain multiple `Observable.using` together.
 =||= You can always roll your own operator so you can hide the boilerplate in a reusable fashion. Here is an example:

``` java
public final class MyUsing<T, Resource> implements OnSubscribe<T> {
    private final Func0<Resource> resourceFactory;
    private final Func1<? super Resource, ? extends Observable<? extends T>> observableFactory;
    private final Action2<? super Resource, Observer<T>> dispose;
    public MyUsing(Func0<Resource> resourceFactory,
            Func1<? super Resource, ? extends Observable<? extends T>> observableFactory,
            Action2<? super Resource, Observer<T>> dispose) {
        this.resourceFactory = resourceFactory;
        this.observableFactory = observableFactory;
        this.dispose = dispose;
    }
    @Override
    public void call(Subscriber<? super T> subscriber) {
        try {
            final Resource resource = resourceFactory.call();
            final AsyncSubject<T> disposeOutcome = AsyncSubject.create();
            subscriber.add(Subscriptions.create(new Action0() {
                @Override
                public void call() {
                    dispose.call(resource, disposeOutcome);
                }
            }));
            @SuppressWarnings("unchecked")
            Observable<T> observable = (Observable<T>)observableFactory.call(resource);
            observable.mergeWith(disposeOutcome).subscribe(subscriber);
        } catch (Throwable e) {
            // eagerly call unsubscribe since this operator is specifically about resource management
            subscriber.unsubscribe();
            // then propagate error
            subscriber.onError(e);
        }
    }
    public Observable<T> toObservable() {
        return Observable.create(this);
    }
}
```
 =||= Thanks for the suggestion, but do you agree that the underlying issue is in RxJava itself that it sliently swallows errors? If you do then I think the fix should be done to RxJava itself instead.
 =||= Note that without addressing the core issue of RxJava silently swallowing errors, the eager disposal overload for `using` proposed in #2759 would emit an `onError` event on disposal failure if `disposeEagerly` is set to true.
 =||= This issue is a bit aged, what is the verdict?
 =||= Looks to me that we should do these things:
- document in `using` javadoc that disposal should not throw
- call an RxJava plugin when disposal does throw (I'm not familiar with this side of things)
  
  I can knock up a PR with these if someone has some RxJava plugin advice for me.
 =||= Looks it's a very simple fix to call the RxJava plugin: just replace this line
https://github.com/ReactiveX/RxJava/blob/bb89744b6b934fa43a187f2d5199c62bcf31e5d3/src/main/java/rx/observers/SafeSubscriber.java#L90 with 

```
                try {
                    unsubscribe();
                } catch (Throwable e) {
                    _onError(e);
                }
```
 =||= Thanks @zsxwing, that's nice and simple. @akarnokd happy to proceed with this?
 =||= That would call `onError` after an `onCompleted` (successful and unsuccessful) so even in the current form it violates the protocol.
 =||= Yep, you're right. So I'll just need code like this in the catch on the dispose action in `using`?

``` java
    try {
        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
    } catch (Throwable e) {
        e.printStackTrace();
    }
```
 =||= Stepping back a bit, we probably should put the catch in `SafeSubscriber` , don't call `_onError(e)` but rather call the plugin handler like `_onError` does at the start of its method. i.e.

``` java
try {
    unsubscribe();
} catch (Throwable e) {
    try {
        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
    } catch (Throwable pluginException) {
        handlePluginException(pluginException);
    }
}
```
 =||= By the way, the change to `SafeSubscriber` would only work for the `using` scenario if unsubscription all the way up the chain is synchronous. Is this an assumption we make and should it be documented in the Observable contract?
 =||= If unsubscription is asynchronous and SafeSubscriber won't swallow it, it should be caught by the user or handled by the thread's `UncaughtExceptionHandler`. Right? Looks it's acceptable.
 =||= Yeah I agree @zsxwing. If some Operator is introduced into the chain that unsubscribes from upstream asynchronously then it becomes its responsibility to handle exceptions (by for example calling the RxJavaPlugin error handler). So I can knock up a PR for this or would you like to do it @zsxwing as it was your fix?
 =||= @davidmoten feel free to send a PR :)
 =||= I've submitted a fix for `SafeSubscriber` as described but I realize it only fixes part of the problem being that we are now covered for when `unsubscribe` is called after completion. If `unsubscribe` is called before termination we still need `using` to report an error to the `RxJavaPlugin` error handler itself. I'll submit another PR for that one.
 =||= Still thinking about this. I suspect post termination unsubscribe failures are the ones that need `RxJavaPlugin` error handler notifications and no special handling is required in `using` if the `SafeSubscriber` fix goes in. In the case of pre-termination unsubscribe, intermediate or  endpoint `Subscriber`s will in general throw from an `onNext`, `onError`, or `onCompleted` or catch the exception and push it downstream as an `onError` signal so that ultimately this failure is not lost.
 =||= The `using` operator now has an eager flag that will close the resource before emitting the terminal event, thus you may get the exception from closing the resource.
 =||= ,0
3167,3166,"java.lang.IllegalArgumentException: n >= 0 required" when unsubscribing,Saw this exception in crash logs, but haven't been able to reproduce it. Any ideas what the cause is?   

```
java.lang.IllegalArgumentException: n >= 0 required
at rx.internal.operators.OperatorMerge$MergeProducer.request(OperatorMerge.java:128)
at rx.internal.operators.OperatorReplay$ReplaySubscriber.manageRequests(OperatorReplay.java:521)
at rx.internal.operators.OperatorReplay$InnerProducer.unsubscribe(OperatorReplay.java:716)
at rx.internal.util.SubscriptionList.unsubscribeFromAll(SubscriptionList.java:124)
at rx.internal.util.SubscriptionList.unsubscribe(SubscriptionList.java:113)
at rx.Subscriber.unsubscribe(Subscriber.java:98)
at rx.internal.util.SubscriptionList.unsubscribeFromAll(SubscriptionList.java:124)
at rx.internal.util.SubscriptionList.unsubscribe(SubscriptionList.java:113)
at rx.Subscriber.unsubscribe(Subscriber.java:98)
```

https://github.com/ReactiveX/RxJava/blob/v1.0.14/src/main/java/rx/internal/operators/OperatorMerge.java#L128,Could you post the code (or equivalent) which exhibits this problem? Looks like there is a flatmap followed by a replay.
 =||= Found the problem. Fix in #3167. 
 =||= Awesome, thanks for the speedy fix. As a workaround until there's an update to RX, is it be safe to wrap the unsubscribe call in a catch statement? I'd be discarding the entire source observable at that point also.
 =||= The bug can leave the operator in inconsistent state and could stop replaying altogether.
 =||= Fixed via #3167 
 =||= ,0
3169,3156,Merge Limiting Concurrency - Can Deadlock,Since the `merge` changes in 1.0.13 we now have a bug in `merge` that limits concurrency and can cause an async "deadlock" since not all `Observable`s being merged will be subscribed to. 

These unit tests show the issue:

``` java
    @Test
    public void testUnboundedDefaultConcurrency() {
        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();
        for(int i=0; i < 2000; i++) {
            os.add(Observable.<Integer>never());
        }
        os.add(Observable.range(0, 100));       

        TestSubscriber<Integer> ts = TestSubscriber.create();
        Observable.merge(os).take(1).subscribe(ts);
        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);
        ts.assertValue(0);
        ts.assertCompleted();
    }

    @Test
    public void testConcurrencyLimit() {
        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();
        for(int i=0; i < 2000; i++) {
            os.add(Observable.<Integer>never());
        }
        os.add(Observable.range(0, 100));       

        TestSubscriber<Integer> ts = TestSubscriber.create();
        Observable.merge(os, Integer.MAX_VALUE).take(1).subscribe(ts);
        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);
        ts.assertValue(0);
        ts.assertCompleted();
    }
```

Surprisingly, even when providing the `maxConcurrent` value the issue still happens.

We have bounded **vertical** buffers, but always must default to unbounded **horizontal** buffers, since it is the code that defines how many items are horizontally buffered. This affects both `merge` and `groupBy`. The `maxConcurrent` overload allows a developer to limit the horizontal buffering, and a developer controls the `groupBy` selector.,This shortcoming is much earlier, at least as old as RxRingBuffer and a certain Scalar optimization in merge...
 =||= Scalar is different ... they aren't async so aren't an issue. A scalar ALWAYS has a value in it, thus it will always emit if there is downstream support. 

These unit tests pass if I go back to 1.0.12

``` java
    @Test
    public void testUnboundedDefaultConcurrency() {
        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();
        for(int i=0; i < 2000; i++) {
            os.add(Observable.<Integer>never());
        }
        os.add(Observable.range(0, 100));       

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
        Observable.merge(os).take(1).subscribe(ts);
        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);
        ts.assertValue(0);
        ts.assertCompleted();
    }

    @Test
    public void testConcurrencyLimit() {
        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();
        for(int i=0; i < 2000; i++) {
            os.add(Observable.<Integer>never());
        }
        os.add(Observable.range(0, 100));       

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
        Observable.merge(os, 5000).take(1).subscribe(ts); // reduced to 5000 instead of MAX_VALUE since it causes an OOM
        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);
        ts.assertValue(0);
        ts.assertCompleted();
    }
```
 =||= In v12, if there were scalars in the input source, the subscribing was held off until some scalars were drained (i.e., in case of an async downstream request): given 1 normal and 128 scalar queued up, the next source wasn't requested until some or all scalars were drained.

In order for the tests to pass, we need an Spsc queue instead of the RxRingBuffer if the maxConcurrency is lesss than max, otherwise, we need an unbounded spsc queue. JCTools' SpscArrayQueue supports only power of 2 capacity so a backpressure violation wouldn't be detected at item 5000 but only at item 8192. SpscUnboundedArrayQueue works if its capacity is at least some value due to a bug in its lookahead-grow logic (8 with defaults). 

V14 merge has the side effect of limiting the tracking array size so the copy-on-write has to work with at most 512 bytes per add/remove.

I happen to have a platform safe SpscArrayQueue with explicit capacity insurance (but still power of 2 memory cost) and a platform safe SpscLinkedArrayQueue (still sensitive to certain capacity settings), courtesy of my rsi flatMap.

I can't do PR for a few days but this is a simple change (provided the tradeoff is understood) and most of the community should be able to pull this off.
 =||= ,0
3171,3168,BehaviorSubject.scan not picking up initial value,I would expect this:

```
final Observable<Void> ob = BehaviorSubject.create();
ob.scan(0, (accum, x) -> 123)
  .subscribe(x -> {
    Timber.d("Hit!");
  });
```

to emit a value (and indeed it does in the equivalent RxJS code).

Is this a bug?,This is odd. The initial value is emitted just before the first accumulated value or a completion event.
 =||= Fix available via #3171.
 =||= ,0
3174,3063,toBlocking ignore all,When I want to use `toBlocking` and I want to ignore results but wait for completion I will often do 

``` java
observable.count().toBlocking().single();
```

This works but I'd like something concise for this common use case. We have a `forEach` method that takes an `Action1`. What about a `forEach` overload that takes no argument?

``` java
observable.toBlocking().forEach();
```

or perhaps `.ignoreElements()`?,I've been thinking about this too and could use these new blocking methods:
- `run()` or `subscribe()` run to completion or exception
- `subscribe(Observer)`, `subscribe(Action1, Action1)` and `subscribe(Action1, Action1, Action0)` blocking callback style
- `subscribe(Subscriber)` allow breaking out of the iteration and have the unsubscription properly propagate up.
 =||= Sounds good, may as well duplicate all the `subscribe()` overloads across to `BlockingObservable` that make sense. That symmetry would be nice.
 =||= +1 for the topic. I have many use cases where I would love to use something like that !
 =||= I'll throw `none()` out there. Would be a void method that threw an Exception if any elements were output.

```
observable.ignoreElements().toBlocking().none();
```
 =||= See for the proposed methods in #3174.
 =||= ,0
3181,3180,NullPointerException with flatMap version that handles notification handling,The following code works with RxJava 1.0.12, but throws a NullPointerException with 1.0.13 and 1.0.14

```
Observable.just(1)
                .flatMap(
                        item -> Observable.just(item + 1),
                        e -> Observable.error(e),
                        () -> Observable.never())
                .subscribe(
                        i -> {
                            Log.d(TAG, "Got " + i);
                        },
                        e -> {
                            Log.d(TAG, "RxJava ERROR", e);
                        });

```

```
java.lang.NullPointerException: Attempt to invoke virtual method 'void rx.internal.operators.OperatorMapNotification$SingleEmitter.offer(java.lang.Object)' on a null object reference
at rx.internal.operators.OperatorMapNotification$1.onNext(OperatorMapNotification.java:82)
at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)
at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)
at rx.Observable$1.call(Observable.java:145)
at rx.Observable$1.call(Observable.java:137)
at rx.Observable$1.call(Observable.java:145)
at rx.Observable$1.call(Observable.java:137)
at rx.Observable.subscribe(Observable.java:7803)
at rx.Observable.subscribe(Observable.java:7579)
```

Further notice: Observable.just(1,2,3) works fine on all versions.,Thanks for reporting. #3181 fixes this issue.
 =||= Fix merged via #3181 and will be delivered in 1.0.15.
 =||= ,0
3286,3252,Add Single.toBlocking?,Now that we have `rx.Single`,  would it make sense to add a `toBlocking()` method on the`rx.Single` that would return the blocking version of the Single, similar to `rx.Observable.toBlocking()`?

Given that Single either returns a single item or fails, I'd imagine it would be pretty minimal. I took a stab at it [here](https://github.com/hyleung/RxJava/tree/blocking-single) - just a `get()` to return the value and `toFuture()` at the moment, couldn't think of anything else that would be useful on a blocking Single...,Do you want to open a pull request with your change to branch 1.x? 
 =||= Close by #3286
 =||= ,0
3342,3067,OperatorGroupBy - redundant onStart implementation,These lines

https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorGroupBy.java#L262-L264

are redundant. I'm concerned that there is some intent behind placing these lines here that is not honoured.  @akarnokd looks like you put these lines here, what do you think?

The same goes for `OperatorDoOnUnbsubscribe`.,Yes, that start is unnecessary.
 =||= Related PR #3342.
 =||= Fix merged via #3342 and delivered in 1.0.15.
 =||= ,0
3352,3157,Committer Merge Policy,Thus far there have been so few committers that we haven't had a formal policy, mostly just an arrangement between @akarnokd and myself. As per https://github.com/ReactiveX/RxJava/issues/3145 we are seeking to increase the number of people involved in reviewing pull requests and thus will end up with more people merging changes.

I don't want to over police this, but I do think we should formalize to having at least a :+1: from another committer before any pull request is merged that affects code in /src/main. 

Exceptions that do not require a :+1: would be:
- javadoc changes
- unit test additions or refactoring
- perf test additions, fixes or refactoring
- grammatical and presentation fixes to README, CONTRIBUTING, and other such metadata files

Things that do require a :+1: would be:
- any code changes to /src/main that would affect running applications
- unit test changes that affect behavior being tested
- changes to README, CONTRIBUTING, LICENSE, etc that affect meaning of the document
- changes to build or release

Thoughts? Agreement? Disagreement?

/cc @ReactiveX/rxjava-committers ,:+1: 

Maybe not require a like for additions to the internal package that otherwise doesn't affect existing code or is essentially unused (as of the time). Example: addition of a new queue implementation for later use, bugfix to this queue when it is still not in use.

Deleting unused code still requires a like.

Perhaps it is better to state that PRs requiring likes with at least 2 likes can be merged, since the merge can be performed by either of the like giver or somebody else.
 =||= :+1:
We can also :+1: but recommend to wait for more (in case of unfamiliar part of the code).
e.g. ":+1: Look good to me, but wait for David to confirm"
 =||= :+1: 

In addition, I think the build script changes also require a like, such as #3089.
 =||= Agreed @zsxwing 
 =||= Added "changes to build or release" to description above.
 =||= I've been thinking about this and I'd add a timeout to the second approval. How about 3 business days after which if nobody else complains, the first and only approver can merge stuff on his own responsibility?
 =||= +1 to this, I guess you'll receive response to the comment in 3 business days :)

But I'd keep "at least 2 :+1:s" rule via requiring :+1: from one or more developers who are not part of the RxJava GitHub team but have at least 1-2 good contributions to the RxJava.
 =||= @artem-zinnatullin does raise a point of interest to me. I've contributed about 4000 lines to the code base   mostly in the last year but as a non-committer would not be expected to put a thumbs-up on issues/PRs but rather something like LGTM?
 =||= > LGTM

:+1: for RxJava team and LGTM for others looks good to me. More eyes and feedback — better result :)
 =||= I don't see why the distinction is needed or useful.

Also why are all of the v2 PRs being merged without any review?

On Thu, Sep 3, 2015, 6:13 PM Artem Zinnatullin notifications@github.com
wrote:

> LGTM
> 
> [image: :+1:] for RxJava team and LGTM for others looks good to me. More
> eyes and feedback — better result :)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/3157#issuecomment-137588470.
 =||= > I don't see why the distinction is needed or useful.

~~Just a hack to see who is in the team and who is not (GitHub UI does not help with that), but yes, it's not very important.~~

Just found that GitHub displays "collaborator" and "owner" near to the comments, hadn't seen it for years…

Now I totally agree, distinction is not needed at all.

> Also why are all of the v2 PRs being merged without any review?

This and PRs without tests in v2 bother me too, though the speed of v2 development is fantastic.
 =||= The speed is too fast to keep up! But that's a good complaint to have.

On Thu, Sep 3, 2015, 7:12 PM Artem Zinnatullin notifications@github.com
wrote:

> I don't see why the distinction is needed or useful.
> 
> Just a hack to see who is in the team and who is not (GitHub UI does not
> help with that), but yes, it's not very important.
> 
> Just found that GitHub displays "collaborator" and "owner" near to the
> comments, hadn't seen it for years…
> 
> Now I totally agree, distinction is not needed at all.
> 
> Also why are all of the v2 PRs being merged without any review?
> 
> This and PRs without tests in v2 bother me too, though the speed of v2
> development is fantastic.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/3157#issuecomment-137598474.
 =||= The process with v2 was to reimplement operators first then port the unit tests from v1 because they depend on multiple operators most of the time. 

Besides, reviewing hundreds of operators would take months at the current review speed due to the +2 rule.
 =||= Your first sentence explains the how, not the why. I still don't see why
these changes are exempt from oversight. I realize code review becomes
slower. On our library projects I have to go through only one reviewer and
it can be annoying. But that's the price you pay for creating more correct
code. We've saved hundreds of bugs across libraries with this system.

So I don't understand why this merge policy exists if it only applies when
it's convenient.

On Thu, Sep 3, 2015, 7:39 PM David Karnok notifications@github.com wrote:

> The process with v2 was to reimplement operators first then port the unit
> tests from v1 because they depend on multiple operators most of the time.
> 
> Besides, reviewing hundreds of operators would take months at the current
> review speed due to the +2 rule.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/3157#issuecomment-137602395.
 =||= No point in reviewing till unit tests in and passing and all of this action is on the 2.x branch. Might have to wait till a big chunk goes in then review?

Can I suggest that all PRs associated with v2 have a title prefixed with v2? That way I can filter them mentally when I look at email notifications from github or the abbreviated github combination issues/pr view. I realize that these PRs have been assigned as Milestone 2.0 but that is only useful when using the github PRs ui.
 =||= > So I don't understand why this merge policy exists if it only applies when it's convenient.

"any code changes to /src/main that would affect **running applications**"

I don't think anybody runs v2 yet, nor is it released officially.

> I still don't see why these changes are exempt from oversight.

They aren't, but due to the different approach reactive-streams requires, one would need to learn to review the new style of code. That requires code to learn from and we are in a deadlock situation.

> Your first sentence explains the how, not the why.

Many v1 tests depend on the existence of multiple operators and the dependency graph is complicated. If I implement one operator then port its unit test, that pulls in 3 other operators which have unit tests requiring 3 subsequent operators; 6 degrees of separation in action.

By doing operators first, I concentrated on the logic, minimized the potential interference from others' PRs and posted operators in batched PRs so they don't get too fragmented but can be commented on more easily.

@davidmoten Sure!
 =||= > I've been thinking about this and I'd add a timeout to the second approval. How about 3 business days after which if nobody else complains, the first and only approver can merge stuff on his own responsibility?

I'm not okay with this type of change. The point of the reviews is quality assurance, not speed. Version 1.x is mission critical for many companies. Just because one person can move faster than the group does not mean we reduce the threshold of review. We have chosen to adopt this practice for a reason.

> Also why are all of the v2 PRs being merged without any review?

I currently consider v2 in a pre-alpha, sprint phase and am okay with @akarnokd doing what he's been doing to bootstrap the effort. It is effectively a massive refactor/port at this point.

Once there is unit test coverage, and general functionality comparable with v1, we will then flip into a mode like v1 where we require reviews of all PRs going forward. We are probably a few weeks from that still. 

The initial review of the ported code base will take several months for people to do, but I felt it would be best if there was functioning code that could be run as a snapshot, and reviewed as a codebase, not via dozens of PRs that are mostly all boilerplate refactoring. 

Once v2 feels like it is more-or-less working, I will do a 2.0.0-DP1 release to Maven Central, and we will iterate on DP# releases as long as it takes for us to all agree with the public API, performance and quality. That entire process will go through PRs requiring review.
 =||= If v2 PRs are to be exempt, I just want it to be an explicit decision instead of trying to make up reasons about why they magically don't fall under the normal policy. In general, I'm still fundamentally opposed to the approach, for the record.

> "any code changes to /src/main that would affect running applications"
> 
> I don't think anybody runs v2 yet, nor is it released officially.

Well this is patently false and the fact that you're trying to argue semantics of policy is truly worrying. 

Unless you intend v2 to _never_ be used, then every piece of code you write actually does affect applications. And if you think it doesn't, then _every_ PR falls into that argument and can skip their review under the same logic. After all, no one is running HEAD, and even if they are, it doesn't affect their applications until they deploy so there's no reason to review synchronously.

> ...due to the different approach reactive-streams requires, one would need to learn to review the new style of code. That requires code to learn from and we are in a deadlock situation.

This is a fallacy. Not only are PRs one of the best places to learn these semantics, but a vast majority of code review (including things for v1) are trivial, normal things that apply to nearly every project. The idea that somehow no one else can understand what's happening is ridiculous.
 =||= @akarnokd has finished the sprint to port 1.x to 2.x. That branch is now following the PR review model and calm enough for everyone to begin reviewing and playing with. 

I'm going to take time to start working with it and let it settle for a while before attempting a 2.0.0-DP1 release to Maven Central. Until then, it is available as a snapshot and I suggest people start digging in and filing issues or PRs with suggestions, issues, alternatives, etc.

To be clear, virtually all design decisions about 2.x is still up for grabs if there are strong, objective reasons for change. There are still large design decisions to make, such as being debates in https://github.com/ReactiveX/RxJava/issues/2787
 =||= I'm closing this in favor of #4013 and #4016. Let me know if there's something is not addressed (in necessary detail) in those.
 =||= ,0
3357,3017,Eager ConcatMap,Is there already a name for something in the ecosystem that is like an eager concatMap, or ordered flatMap?

I often see the pattern of people wanting to eagerly kick off several Observables, but merge them together in order. 

It is absolutely not a good idea for infinite lists, but similar to how `concatMap` and `flatMap` can both be dangerous if used wrong, an `eagerConcatMap` that eagerly subscribes and caches the inner `Observable`s could be useful. 

Of course this can be done without adding anything to RxJava, it's just tedious. 

Bad idea? Does it already have a name that I'm unaware of?,I can't help you with the name and it is non-trivial to change merge() to support it (#2928): fast-path would require unbounded buffers for the later sources; the scalar queue wouldn't really work if interleaved with regular sources and potentially one would need to wrap each value into an indexed container anyway. 

In theory, after getting rid of the optimizations, the [plain merge's](https://github.com/akarnokd/RxJava/blob/OperatorMergeFullRewrite/src/main/java/rx/internal/operators/OperatorMerge.java#L714) round-robin collector can be modified to stick to the first buffer until it is terminated before moving onto the next.

(In my plans for the semi-auto-parallelization, I thought about the join option to be either ordered or unordered merge.)
 =||= > non-trivial to change merge() to support it 

Merge does not need to be changed. I can implement this today by composition. For example, I iterate over an array of Observables, .cache().subscribe() them, then concat those together. 
 =||= One use case for a eager concat was a bug that I ran into a while ago with using concat and publish with a closure.

`source.publish((pub) -> Observable.eagerConcat(pub.map(...), pub.map(...)));`
 =||= This would also be useful where the `onSubscribe` makes an async call. We will need a way to order the responses in the order that the producer generated them from a request. This would of course require buffering. 
 =||= I like the idea. Out of interest I think `concat(Observable<T))` is a little bit eager internally at the moment inasmuch as it requests the next observable before the first has completed. It doesn't subscribe to it before the current observable has completed though which is more what you are referring to.
 =||= I was misunderstanding concat operator as it subscribes each observables eagerly.

![image](https://cloud.githubusercontent.com/assets/400558/8453595/161c02de-2031-11e5-9db1-36cfa2ec896a.png)

http://reactivex.io/documentation/operators/concat.html

In this figure concat is very, very looks eager :P
 =||= >  It doesn't subscribe to it before the current observable has completed though which is more what you are referring to.

That's the point. A `request` does not represent subscription work. It just means downstream is capable of receiving. Let's not confuse those points. An `Iterable` should be used if even `request` can't be handled. 
 =||= > In this figure concat is very, very looks eager :P

Yes, that diagram looks wrong. It shows both as subscribing immediately, which it definitely does not do.

/cc @DavidMGross 
 =||= Ah; I thought I'd fixed that. I'll go back and make sure the right diagrams
get copied over.  I can't fix the rxmarbles version, though; that's out of
my bailiwick (@andrestaltz)

On Wed, Jul 1, 2015 at 9:24 AM, Ben Christensen notifications@github.com
wrote:

> In this figure concat is very, very looks eager :P
> 
> Yes, that diagram looks wrong. It shows both as subscribing immediately,
> which it definitely does not do.
> 
> /cc @DavidMGross https://github.com/DavidMGross
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/3017#issuecomment-117736447.

## 

David M. Gross
PLP Consulting
 =||= Oh; I see what happened. That particular illustration (
http://reactivex.io/documentation/operators/images/concat.hot.png) is meant
to illustrate what happens when both of the observables passed to concat
are "hot" observables. In such a case, as I understood it, an onError
notification from the second Observable may "jump the queue" and interrupt
the emissions from the resulting Observable even if the first Observable's
emissions haven't finished yet. Is that not correct?

The other illustrations on the page (e.g. under the RxJava and RxGroovy
accordion-folds) show the more ordinary behavior with cold Observables and
without onError notifications, and these show the subscription to the
second Observable being delayed until the first Observable completes.

On Wed, Jul 1, 2015 at 2:42 PM, PLP Consulting (David Gross) <
davgross@netflix.com> wrote:

> Ah; I thought I'd fixed that. I'll go back and make sure the right
> diagrams get copied over.  I can't fix the rxmarbles version, though;
> that's out of my bailiwick (@andrestaltz)
> 
> On Wed, Jul 1, 2015 at 9:24 AM, Ben Christensen notifications@github.com
> wrote:
> 
> > In this figure concat is very, very looks eager :P
> > 
> > Yes, that diagram looks wrong. It shows both as subscribing immediately,
> > which it definitely does not do.
> > 
> > /cc @DavidMGross https://github.com/DavidMGross
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/ReactiveX/RxJava/issues/3017#issuecomment-117736447.
> 
> ## 
> 
> David M. Gross
> PLP Consulting

## 

David M. Gross
PLP Consulting
 =||= It is very useful to implement observable for data-store backed value.
Implementing with concat or startWith will miss update notification from backed store before first fetch request is finished (i.e. before subscribing to second observable).

Refer: https://github.com/pwittchen/prefser/issues/47

(I know BehaviorSubject is enough to implement observable for just a variable. :)
 =||= Oops... there is pitfall when implementing get-and-observe with eager concatMap.

If `Observable.just(observableForGet, observableForObserve).eagerConcatMap(o -> o)` will subscribe observableForGet then observableForObserve, it will miss updates between subscription of first and second observable.
1. eagerConcatMap calls observableForGet.subscribe().
2. observableForGet calls onNext() from another thread.
3. Someone updates backed store from yet another thread.
4. observableForObserve should call onNext() but it is not subscribed yet!
5. eagerConcatMap calls observableForObserve.subscribe().

It is easier to use merge for this purpose like below:

``` java
Observable.merge(observableForObserve, observableForGet)
```

This will subscribe observableForObserve at first, so no update will be missed.
 =||= Such operator with backpressure has limited use because even if it subscribes to all sources at once, they can produce up to `RxRingBuffer.SIZE` values upfront until each of them gets drained to completion.

@ypresto If `observableForObserve` is hot, `merge` may not see all of its values either.
 =||= @akarnokd 

~~Thanks, reproduced with snippet like below:~~

```
Observable.interval(100, TimeUnit.MILLISECONDS)
    .flatMap(l -> observableForGet)
    .mergeWith(observableForGet);
```

~~It calls onNext() only once, not per 100msec...~~

And I found it may deliver outdated data if observableForObserve called onNext() after observableForGet stored fetch result in local var.

Then how do I implement get-and-observe with RxJava?
I use shared stream of cache()d observable in another project:

``` java
private Observable<List<Item>> mSharedRequestQueueObservable = updateNotificationObservable
                .onBackpressureLatest()
                .map(aVoid -> getObservable.cache()) // cache to share result with all subscribers
                .share();

public Observable<List<Item>> getAndObserve() {
        return Observable.merge(mSharedRequestQueueObservable, getObservable.nest())
                .flatMap(observable -> observable) // not using any schedulers to execute synchronously
                .subscribeOn(Schedulers.io());
}
```

(Let me know if mailing list is better place to discuss :)
 =||= Sorry, I was using wrong snippet of `Observable.interval(...)` with publish() (not share()) after interval() call.
It just works well with hot observable (share()).

```
Observable.interval(100, TimeUnit.MILLISECONDS).share()
    .flatMap(l -> observableForGet)
    .mergeWith(observableForGet);
```
 =||= It looks like this thread may have gone off the rails. It seems like there is interest in having an eager concat operator. I think I have implemented one in the internal processing of #3203. It's a composition of `BufferUntilSubscriber` subjects and `Observable.concat()`. 
 =||= I think the following example does exactly this:

``` java
Observable<Long> source1 = Observable.intervalRange(0, 20, 100, 100, TimeUnit.MILLISECONDS);
Observable<Long> source2 = Observable.intervalRange(20, 20, 100, 100, TimeUnit.MILLISECONDS);
Observable<Long> source3 = Observable.intervalRange(40, 20, 100, 100, TimeUnit.MILLISECONDS);

Observable<Observable<Long>> sources = Observable.just(source1, source2, source3);

sources.map(v -> {
    ConnectableObservable<Long> c = v.replay();
    c.subscribe(); // to cache all
    c.connect(); // starting now
    return c;
})
.onBackpressureBuffer() // make sure all source started
.concatMap(v -> v)
.toBlocking()
.forEach(System.out::println);
```

Edit: The following alternative doesn't retain everything:

``` java
Observable<Long> source1 = Observable.intervalRange(0, 20, 100, 100, TimeUnit.MILLISECONDS);
Observable<Long> source2 = Observable.intervalRange(20, 20, 100, 100, TimeUnit.MILLISECONDS);
Observable<Long> source3 = Observable.intervalRange(40, 20, 100, 100, TimeUnit.MILLISECONDS);

Observable<Observable<Long>> sources = Observable.just(source1, source2, source3);

sources.map(v -> {
    UnicastSubject<Long> subject = UnicastSubject.create();
    v.subscribe(subject);
    return subject;
})
.onBackpressureBuffer() // make sure all source started
.concatMap(v -> v)
.toBlocking()
.forEach(System.out::println);
```
 =||= See #3357.
 =||= The new operator has been delivered with 1.0.15.
 =||= ,0
3377,3346,1.x Take operator can emit more values than its limit,This can happen if a `doOnNext` action downstream can cause the observable upstream to emit another value. Here's a test that demonstrates this behavior:

``` java
@Test
public void testEmittingMoreValuesThanLimit() {
    final AtomicBoolean emittedFirstValue = new AtomicBoolean(false);
    final PublishSubject<Integer> subject = PublishSubject.create();
    final int firstValue = 1;
    final int secondValue = 2;

    // Record emitted values with this action.
    Action1<Integer> record = mock(Action1.class);
    InOrder inOrder = inOrder(record);

    subject
            .take(1)
            .doOnNext(record)
            .doOnNext(new Action1<Integer>() {
                @Override
                public void call(final Integer integer) {
                    // As the first value passes through, emit the second value.
                    if (!emittedFirstValue.getAndSet(true)) {
                        subject.onNext(secondValue);
                    }
                }
            })
            .subscribe();

    inOrder.verifyNoMoreInteractions();

    // Will record both values even though take(1) is upstream.
    subject.onNext(firstValue);
    subject.onCompleted();
    inOrder.verify(record).call(firstValue);
    inOrder.verify(record).call(secondValue);
    inOrder.verifyNoMoreInteractions();
}
```

I first noticed this in a project that uses RxJava 1.1.10. The `onNext` implementation of `OperatorTake` has changed a bit in master. Before I go ahead and submit a PR that fixes this behavior, I just wanted to ensure that it wasn't deliberate? Thanks!,Hi and thanks for discovering this. The behavior is not intentional. We are generally not prepared for synchronous reentry such as this. Solving it is a bit tricky because a delicate behavior needs to be ensured right at the limit. Here is how I'd fix this:
- I'd introduce a `boolean stop` variable on the parent Subscriber
- I'd change the onNext to have the reentrancy protection:

``` java
@Override
public void onNext(T i) {
    if (!isUnsubscribed()) {
        boolean stop = ++count >= limit;
        if (stop) {
            if (this.stop) {
                return;
            }
            this.stop = true;
        }
        child.onNext(i);
        if (stop && !completed) {
            completed = true;
            try {
                child.onCompleted();
            } finally {
                unsubscribe();
            }
        }
    }
}
```

This will prevent a recursive onNext call to be delivered after the limit.
 =||= Thanks for the response! I think alternatively you could do:

``` java
if (!isUnsubscribed() && (count++ < limit)) {
    boolean stop = count >= limit;
    child.onNext(i);
    if (stop && !completed) {
        completed = true;
        try {
            child.onCompleted();
        } finally {
            unsubscribe();
        }
    }
}
```

Which only changes the outer conditional and the computation of `stop`. LMK if that sounds good and I'll prepare a PR?
 =||= Looks even better, go ahead with the PR.
 =||= @mgp Are you going to post a PR against 1.x?
 =||= Closing via #3384.
 =||= ,0
3382,3381,2.x: UnicastSubject fix for the child becoming visible before onSubscribe is called.,Discovered while the test `NbpOperatorConcatTest.testIssue2890NoStackoverflow` hung on Travis.

What happened is that the reference to the child became visible before the call to its `onSubscribe` method so a concurrent source emitting at the exact same time could already see the "unstarted" child. The PR fixes this in both `NbpUnicastSubject` and `UnicastSubject` by changing the order of calls. The rest of the subjects behave correctly (call `onSubscribe` first, make child visible second).

In addition, `UnicastSubject` now calls `drain()` because when the `onSubscribe` calls `request` and `drain`, the child is not visible and nothing gets replayed. Once both `onSubscribe` call returns and the child is becomes visible, a call to `drain` again will now correctly replay all available contents that were requested.,Closing, will be included in the complete backport PR.
 =||= ,0
3384,3346,1.x Take operator can emit more values than its limit,This can happen if a `doOnNext` action downstream can cause the observable upstream to emit another value. Here's a test that demonstrates this behavior:

``` java
@Test
public void testEmittingMoreValuesThanLimit() {
    final AtomicBoolean emittedFirstValue = new AtomicBoolean(false);
    final PublishSubject<Integer> subject = PublishSubject.create();
    final int firstValue = 1;
    final int secondValue = 2;

    // Record emitted values with this action.
    Action1<Integer> record = mock(Action1.class);
    InOrder inOrder = inOrder(record);

    subject
            .take(1)
            .doOnNext(record)
            .doOnNext(new Action1<Integer>() {
                @Override
                public void call(final Integer integer) {
                    // As the first value passes through, emit the second value.
                    if (!emittedFirstValue.getAndSet(true)) {
                        subject.onNext(secondValue);
                    }
                }
            })
            .subscribe();

    inOrder.verifyNoMoreInteractions();

    // Will record both values even though take(1) is upstream.
    subject.onNext(firstValue);
    subject.onCompleted();
    inOrder.verify(record).call(firstValue);
    inOrder.verify(record).call(secondValue);
    inOrder.verifyNoMoreInteractions();
}
```

I first noticed this in a project that uses RxJava 1.1.10. The `onNext` implementation of `OperatorTake` has changed a bit in master. Before I go ahead and submit a PR that fixes this behavior, I just wanted to ensure that it wasn't deliberate? Thanks!,Hi and thanks for discovering this. The behavior is not intentional. We are generally not prepared for synchronous reentry such as this. Solving it is a bit tricky because a delicate behavior needs to be ensured right at the limit. Here is how I'd fix this:
- I'd introduce a `boolean stop` variable on the parent Subscriber
- I'd change the onNext to have the reentrancy protection:

``` java
@Override
public void onNext(T i) {
    if (!isUnsubscribed()) {
        boolean stop = ++count >= limit;
        if (stop) {
            if (this.stop) {
                return;
            }
            this.stop = true;
        }
        child.onNext(i);
        if (stop && !completed) {
            completed = true;
            try {
                child.onCompleted();
            } finally {
                unsubscribe();
            }
        }
    }
}
```

This will prevent a recursive onNext call to be delivered after the limit.
 =||= Thanks for the response! I think alternatively you could do:

``` java
if (!isUnsubscribed() && (count++ < limit)) {
    boolean stop = count >= limit;
    child.onNext(i);
    if (stop && !completed) {
        completed = true;
        try {
            child.onCompleted();
        } finally {
            unsubscribe();
        }
    }
}
```

Which only changes the outer conditional and the computation of `stop`. LMK if that sounds good and I'll prepare a PR?
 =||= Looks even better, go ahead with the PR.
 =||= @mgp Are you going to post a PR against 1.x?
 =||= Closing via #3384.
 =||= ,0
3417,3385,rx.Single - why no `doOnNext()`?,I have a `Single<?>` that I would like to call `.doOnNext()` on. Why is this omitted? I get why `.doOnCompleted()` does not exist, but I want to call a void action once and there seems to be no simple way to do this with `rx.Single`

Technically I could call `.map()`, do my thing, and return the same object - but that seems like too much overhead. Or call `.toObservable().doOnNext().toSingle()`, but I cannot imagine that is too efficient.,Hi. The class received too little attention after it has been added to the library. The 1.x operators are kind of hanging off the `Observable` so currently you can't do better than `map()`.

If you are interested, you can port back operators from the 2.x version (https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Single.java#L1073)
 =||= So I guess `doOnSuccess()` is the equivalent in `Single` for `doOnNext()` of `Observable`? =||= The `doOnX` matches the parent reactive type's terminology, thus `Single` has `onSuccess` -> `doOnSuccess`. Same for v2 `Maybe.onSuccess`. =||= ,0
3428,3425,Outer groupBy doesn't obey backpressure,Someone here brought by some code that was throwing a MissingBackpressureException. Aaron and I narrowed it down to this snippet.

`merge(range(0, 500).groupBy(i -> i % (RxRingBuffer.SIZE + 2)).observeOn(computation())).toBlocking().last()`

it comes down observeOn requesting 128 Observables from groupBy and groupBy hard coded to request 1024 from range.

We fixed his problem changing the `observeOn(computation())` to `flatMap(grp -> grp.subscribeOn(computation()))`2,It fails with 2.x too. I'll have a look at this within 2.x.
 =||= I've looked into this with 2.x. The problem is that a `request(N)` may result in a new group beyond the requested amount by the main subscriber (i.e., the one that receives `GroupedObservable`s). Since consuming groups requires value replenishment from main, one can't be sure what the next value will be or where it will go (into the same group, into another group or into a completely new group).

The solution is to buffer the `GroupedObservable`s for the main subscriber and hand them out based on requests while letting the groups be consumed. Since we can't know the number of groups, this buffering has to be unbounded, similar to how each group has to be unbounded (due to the same reason as before: asking for replenishment for a group may result in a value for another group).

I don't fully understand 1.x GroupBy so I don't know how to fix it with minimal changes. The best I can do is to port back the 2.x GroupBy, however, that requires `SpscLinkedArrayQueue` from #3169.
 =||= ,0
3436,3435,OperatorFinally calls action twice if action throws exception. Exception thrown by action is swallowed,While I was implementing #3434 I've found two problems with `OperatorFinally`.

I'll call `OperatorFinally.action` as `finallyAction` for better readability.
1. If `finallyAction` is `null` — `NullPointerException` will be swallowed by `SafeSubscriber`, this can be solved via `action != null` check in the `OperatorFinally` (I'll make PR).
2. If `finallyAction` throws exception, `lift` calls `onError()` and `OperatorFinally` invokes `finallyAction` again (this may brake user-defined logic)! And second exception is swallowed by the `SafeSubscriber` (see problem 1).

I vote for solving both of these problems before 1.0.15/1.1.10.,Here are the tests:

``` java
@Test
public void nullFinallyActionShouldBeCheckedASAP() {
    try {
        Observable
                .just("value")
                .finallyDo(null);

        fail();
    } catch (NullPointerException expected) {

    }
}

@Test
public void ifFinallyActionThrowsExceptionShouldNotBeSwallowedAndActionShouldBeCalledOnce() {
    Action0 finallyAction = mock(Action0.class);
    doThrow(new IllegalStateException()).when(finallyAction).call();

    TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

    Observable
            .just("value")
            .finallyDo(finallyAction)
            .subscribe(testSubscriber);

    testSubscriber.assertValue("value");

    verify(finallyAction).call();
    // Actual result:
    // Not only IllegalStateException was swallowed
    // But finallyAction was called twice!
}
```
 =||= I'll try to send PRs with fixes ASAP, `null` check is easy, but second problem looks tricky.
 =||= If the action throws, you can't do much but call `RxJavaPlugins.getInstance().getErrorHandler().handleError()` for it.
 =||= We can throw it as `Error`. Leaving the app in an unknown state is very bad idea, especially in something like `finallyDo()`.
 =||= The sequence has already terminated at that point and this operator is there to have side-effects after it. The exception has nowhere to go and there is no guarantee a thrown error reaches its intended target because of a potential async boundary. So it either propagates up to a synchronous caller, gets thrown away by the `ExecutorService` or gets sent to the error handler.
 =||= Can this be closed?
 =||= @akarnokd won't be able to work on this for at least 2 days, feel free to run the tests I posted  ^ and see what we can do here or I'll investigate this in the end of the week.

As far as I remember, the biggest problem is that `action` gets called twice if it throws exception and it may break app's logic in a dramatic manner.
 =||= Fix posted in #3823.
 =||= Closing via #3823
 =||= ,0
3444,3439,2.x: Completable class for valueless event composition.,I saw this mentioned in [this talk](https://www.youtube.com/watch?v=ET_SMMXkE5s) from @benjchristensen 

This PR adds a new class `Completable` which allows composing events
that never want to fire `onNext`, but only `onError` or `onComplete`. It
is built upon the same Reactive-Streams principles as `Single`,
`NbpObservable` and `Observable`.

I've added most methods that made sense and left out the others (such as
`map` and `flatMap`) that would require at least a single value.

Depending on whether this type is actually required, I'll add unit test to this PR or in a new PR in case this gets merged.,I'm adding unit tests and some fixes, stay tuned.
 =||= Added 240 unit tests and fixed a few bugs.
 =||= I've added `amb`, `startWith` and `endWith` methods + their unit tests. The latter two have convenience overload that help with continuation-style flows (run the `Completable` before or after the `Observable`/`NbpObservable` delivered its values).
 =||= What is the difference between `Completable` vs `Single<Void>`? It's possible to add some utility methods to Single to terminate using null values, so end up almost with the same interface than Completable. Maybe is better to improve Single as something similar to a Deferred/Promise which will handle the 1/0 items situations (been 0 a null item) which is probably the origin of both interfaces. Even Completable might be just a `Completable extends Future<Void>`. So end up with `Observable<T>` (async multiple items) and `Future<Void>` (async single item) as main types (as puts here for some time http://reactivex.io/intro.html :astonished:).

Hope this helps. Just ignore me if you think that this is non sense. I see that @akarnokd are doing amazing things this days (specially rxjava v2), I'm not try to say that this pull request is bad or something similar.
 =||= The difference is that, among other things, you don't have to drag around a mute type parameter. Null values are forbidden with 2.x and Reactive-Streams anyway. `Future` void is not an option because `Completable` is a deferred cold computation which runs only if one subscribes to it whereas Future is hot and is expected to be running or already completed such as `AsyncSubject`.
 =||= Consider making `Completable` implement both `Publisher` and `IObservable` (an interface for `Observable` similar to `Publisher` for `Flowable`) so that `Completable` can be composed directly with either a `Flowable` or `Observable` without special method overloads. 
 =||= I've started out with `Completable implements Publisher<Object>` but it didn't work with `Subscriber<T>` because `T` is not a supertype of `Object` and java doesn't have a bottom type in its type system (its top type is `Object`, however, `Void` is not a bottom type so that `Void` extends every other type). The same would be true for `IObservable`. So what's left is a bunch of `subscribe()` method with call-site variance.
 =||= Well that really sucks that `Void` doesn't work properly. How about as `Publisher<?>`?
 =||= You can't have wildcards as the type parameter of the super type.
 =||= :( Oh well. 
 =||= Is there any chance we will get this with RxJava 1.x?
 =||= The PR for 1.x has already been merged and should appear in 1.1.1
 =||= see #3444
 =||= Closing, will be included in the complete backport PR.
 =||= ,0
3447,3445,Add delaySubscription(Observable<U>) overload?,Usage of `delaySubscription` has started popping up in our code base, and I've noticed that we always have to define a `Func0` simply to yield an observable that's either cold (in which case the function provides no value) or hot (in which case the function also provides no value). It's not clear to me why the function indirection was added in the first place as it's provided no data and `Observable.defer` could have served in its place.

I would like to propose adding an `Observable`-taking overload and replacing the `Func0` variant to instead wrap its given argument in `Observable.defer` before passing to `OnSubscribeDelaySubscriptionWithSelector`.

Being able to sneak this in before 1.0.15 / 1.1.0 would also be nice :grinning: ,See #3447. I didn't touch the current `Func0` variant to avoid introducing unexpected effects to existing code.
 =||= :+1: Thanks @akarnokd! 
 =||= Fix merged.
 =||= ,0
3447,3446,How can I use OperatorConcat<T>?,I'm trying to write an operator `then<R,T>` which ignores all emissions from the source (except errors), and continues with a second Observable when completed.

Something like:

```
// Typical Case
Observable.just(1, 2, 3, 4, 5)
   .lift(new then<String, Integer>(Observable.just("Hello")))
   .subscribe(new Action1<String>() {
      @Override
      public void call(String s) {
         // Called once with "Hello"
      });

// Source Errors
Observable.<Integer>error(new RuntimeException())
   .lift(new then<String, Integer>(Observable.just("Hello")))  // <-- the second observable should never be subscribed to since the source error'd
   .subscribe(new Action1<String>() {
      @Override
      public void call(String s) {
         // Not Called

      }, new Action1<Throwable>() {
      @Override
      public void call(Throwable e) {
        System.out.println("Error: "+e); // Should be called with the RuntimeException from above

      }
   });
```

I've come up with an implementation using `ignoreElements` + `map` + `concatWith`:

```
    public static <R, T> Observable<? extends R> then(Observable<T> source, Observable<R> other) {
        return source
                .ignoreElements()
                .map(new Func1<T, R>() {
                    @Override
                    public R call(T integer) {
                        return null;
                    }
                }).concatWith(other);
    }
```

I'm quite new to writing custom operators, and I can't quite figure out how to translate that static function into an operator. I've written a few operators by composing the provided Operator\* types, but I'm having trouble with this one.

Any help would be greatly appreciated :),This is discussed in #3113 and implemented awaiting merge in #3443.
 =||= Ok, well that eliminates the need for my operator, but I'm still interested in how it could be correctly implemented using lift(). I'm sure I'll be writing more operators in the future so I'd like to have a better understanding of how they work. 

This is what I've come up with:

```
/**
 * Ignores all emissions from the source observable. Once the source completes, the provided
 * observable will be subscribed to. If the source errors, the error will terminate the stream and
 * the provided observable will not be subscribed to.
 *
 * @param <T> The type of objects emitted by the source observable.
 * @param <R> The type of objects emitted by the provided `next` observable.
 */
public class then<R, T> implements Observable.Operator<R, T> {
    private final OperatorIgnoreElements<T> mIgnoreElements;
    private final OperatorMap<T, R> mMap;
    private final OperatorConcat<R> mConcat;

    private final Observable<R> mNextObservable;

    public then(Observable<R> nextObservable) {
        assert( nextObservable != null );
        mNextObservable = nextObservable;
        mIgnoreElements = OperatorIgnoreElements.instance();
        mMap = new OperatorMap<>(new Func1<T, R>() {
            @Override
            public R call(T t) {
                return null;
            }
        });
        mConcat = OperatorConcat.instance();
    }

    @Override
    public Subscriber<? super T> call(final Subscriber<? super R> subscriber) {
        // TODO: Compose operators...
    }
}
```
 =||= This is "super easy" to implement as an `Operator`:

``` java
public final class Then<T, R> implements Operator<R, T> {
    final Observable<R> other;

    public Then(Observable<R> other) {
        this.other = other;
    }

    @Override
    public Subscriber<? super T> call(final Subscriber<? super R> t) {
        MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription();
        t.add(mas);

        Subscriber<T> parent = new Subscriber<T>() {
            @Override
            public void onNext(T t) {
                // ignored
            }

            @Override
            public void onError(Throwable e) {
                t.onError(e);
            }

            @Override
            public void onCompleted() {
                Subscriber<R> tr = Subscribers.wrap(t);
                mas.set(tr);
                other.subscribe(tr);
            }
        };

        mas.set(parent);

        return parent;
    }
}
```
 =||= Awesome, thanks! 

I have a few questions about your solution:
1. Shouldn't it check if the subscriber has unsubscribed before calling `t.onError(e)`?
2. Why is the MultipleAssignmentSubscription needed? I'm a bit of an rx newbie, so it's not clear to me why you can't just return the `parent` subscriber directly.

Cheers!
 =||= 1) unnecessary
2) so the unsubscription from the child can target both the first parent and the second subscriber.
 =||= ,0
3454,3452,Bounded replay() request coordination doesn't work properly with latecommers,Replay works by requesting as many items as the largest requester subscriber does. So if there is one with `request(2)` and another with `request(5)`, replay will `request(5)` from the upstream. To be precise, subscriber requests are accumulated and the operator requests the difference between the last known max and the latest known max. This way, if there is an additional `request(10)` from the first subscriber above, `replay` will request only 5 additional elements.

This works for the unbounded `replay()` because all subscribers start from the very beginning. However, if the buffer is bounded, this differencing doesn't work anymore. The following unit test fails with both 1.x and 2.x implementations.

``` java
@Test
public void testSubscribersComeAndGoAtRequestBoundaries() {
    ConnectableObservable<Integer> source = Observable.range(1, 10).replay(1);
    source.connect();

    TestSubscriber<Integer> ts1 = TestSubscriber.create(2);

    source.subscribe(ts1);

    ts1.assertValues(1, 2);
    ts1.assertNoErrors();
    ts1.unsubscribe();

    TestSubscriber<Integer> ts2 = TestSubscriber.create(2);

    source.subscribe(ts2);

    ts2.assertValues(2, 3);
    ts2.assertNoErrors();
    ts2.unsubscribe();

    TestSubscriber<Integer> ts3 = TestSubscriber.create();

    source.subscribe(ts3);

    ts3.assertNoErrors();
    ts3.assertValues(3, 4, 5, 6, 7, 8, 9, 10);
    ts3.assertCompleted();
}
```

What happens here is that even though `ts2` subscribes after 2 elements were requested from source, it only receives the very last and `replay()` doesn't request 1 more.

The idea about fixing this is that the total requested amount of late subscribers would start from a "current index", i.e., the number of items received by `replay()` so far. 

This approach would work in this synchronous test but may not work with asynchronous subscribers. The problem is that the start node and the index has to be atomically updated together so a subscriber "pins" both at the same time: the continuous delivery is guaranteed as well as the proper total requested amount. I'll investigate to make this happen.

Let me emphasize again that the unbounded `replay()` works properly and the v2 `ReplaySubject` isn't affected because it is unbounded-in.,Fix in #3454.
 =||= ,0
3467,3461,High CPU usage after time changed on device,On Android using this library, if the user changes the system time, there is a huge spike in the CPU usage emanating from the RXComputationThreadPool, without any expensive calls being made to the RX library.,Thanks for reporting. It has been already reported in #2943.
 =||= Thanks for your swift reply.

Do we have a feel of when we might have a fix for this on v1.x?
 =||= // one of the possible fixes — Abstraction for Clock #3295.
 =||= I also experienced this issue and it's quite serious. Will this be fixed soon? 
 =||= I've proposed a fix for this issue in #3467. I don't know if and when this can get into a release.
 =||= ,0
3467,2943,Scheduler.schedulePeriodically is sensitive to system time changes,Scheduler.schedulePeriodically can potentially get into busy loop if you set your system time into the future due to using System.currentTimeMillis() to calculate the next delay.,Confirmed this causes a busy loop and spikes cpu to 100% because of ObjectPool.
 =||= I guess it is due to the way the next delay is calculated from a constant absolute time position and a time set back will result in 0 delay between subsequent executions. Any tips on fixing it?
 =||= If we want to measure elapsed time, we should use `System.nanoTime`, which won't be affected by the user's system time. https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#nanoTime()
 =||= I wouldn't trust [nanoTime that much](http://shipilev.net/blog/2014/nanotrusting-nanotime/) because the weaker guarantees of its monotonity and consistency across cores.
 =||= This is not an easy thing ;-) http://blogs.msdn.com/b/rxteam/archive/2012/06/20/reactive-extensions-v2-0-release-candidate-available-now.aspx
 =||= @headinthebox  Especially if you _are_ platform independent to begin with (i.e., what is the Linux equivalent of `SERVICE_CONTROL_TIMECHANGE` callback?)

What the solution boils down:
1. We need a supervising task scheduled on a small, 5-10s period to detect System.currentTimeMillis() drift or change (i.e., now - last is: > 5s + tolerance / negative).
2. We need to capture tasks scheduled on any Scheduler that sets a delay/period > 10s and schedule them according to Zeno's paradox.
3. If the supervising task detects a drastic clock change, it has to catch all those long-delay tasks and re-schedule them based on the new absolute time information, of course, atomically to prevent double-executions.

These all add some non-trivial overhead to scheduling and task-memory-sizes.

My first thought was the same as in the article:

> Observable.Timer/Interval implementation would start its quest to catch up with the new time, draining the battery due to the flood of callbacks it triggered. The fix was more of a band aid, whereby the timer would ignore ticks that occurred in the distant past, resetting the “next” state to be based on the current system time.

But that's still a half-solution at best.
 =||= Using nanoTime was my temporary solution as well. It is not the best, but the quickest way to fix this bug and doesn't offer anything worst then the current solution.
 =||= Some systems like Android give a way to measure time and don't care about system time changes. http://developer.android.com/reference/android/os/SystemClock.html

What do you think about abstraction for `System.currentTimeMillis()` which can be overridden via [RxJava Plugin](https://github.com/ReactiveX/RxJava/wiki/Plugins)?

Default: `System.currentTimeMillis()` -> no breaking changes to the API.
Android: `SystemClock.elapsedRealtime()` -> no breaking changes and guarantees++ for free.
Others: users can provide custom implementation, for example for Linux it can be native C call, or in general it can be some implementation of synchronized calls to `System.nanoTime()`.
 =||= I've implemented compensation logic in [2.x](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Scheduler.java#L128) but I haven't tested it and unsure if the calculation is actually correct.
 =||= I've proposed a fix for this issue in #3467. I don't know if and when this can get into a release.
 =||= Fix delivered in 1.1.0.
 =||= ,0
3470,3469,replay/refCount subscribe/unsubscribe exhibit O(N) behavior,Subscribing to replay/refCount chain slows down as O(N) with number of existing subscribers. 

This is reproducible on a simple chain that never emits an item, thus data traffic should not be a factor in the performance degradation behavior:

``` java
Observable<?> shared = Observable.never().replay(1).refCount();
```

After certain number of subscribers sharing observable becomes unusable and wasting a lot of CPU cycles. In turn this draws useless some caching scenarios specifically with big number of subscribers.

Here is the simple test:

``` java
    final Observable<?> shared = Observable.never().replay(1).refCount();

    final int count = 300000;
    final int page = 10000;
    List<Subscription> ss = new ArrayList<>();
    System.out.println("subscribing...");
    long prev = System.currentTimeMillis();
    for (int i = 0; i < count; i++) {
      ss.add(shared.subscribe());
      if ((i+1) % page == 0) {
        long now = System.currentTimeMillis();
        System.out.println("subscribed so far " + (i+1) + "; took " + (now-prev) + "ms to subscribe last " + page + 
            " at rate: " + page*1000/(now-prev) + " per sec...");
        prev = now;
      }
    }
    System.out.println("unsubscribing...");
    prev = System.currentTimeMillis();
    for (int i = 0; i < count; i++) {
      ss.get(i).unsubscribe();
      if ((i+1) % page == 0) {
        long now = System.currentTimeMillis();
        System.out.println("unsubscribed so far " + (i+1) + "; took " + (now-prev) + "ms to unsubscribe last " + page + 
            " at rate: " + page*1000/(now-prev) + " per sec...");
        prev = now;
      }
    }

```

Here is the output on a 2015 MacBook Pro (PhysMem: 16G, jvm launched with -Xmx8000m):

```

subscribing...
subscribed so far 10000; took 374ms to subscribe last 10000 at rate: 26737 per sec...
subscribed so far 20000; took 905ms to subscribe last 10000 at rate: 11049 per sec...
subscribed so far 30000; took 1646ms to subscribe last 10000 at rate: 6075 per sec...
subscribed so far 40000; took 2557ms to subscribe last 10000 at rate: 3910 per sec...
...
subscribed so far 290000; took 29635ms to subscribe last 10000 at rate: 337 per sec...
subscribed so far 300000; took 30998ms to subscribe last 10000 at rate: 322 per sec...
unsubscribing...
unsubscribed so far 10000; took 32352ms to unsubscribe last 10000 at rate: 309 per sec...
unsubscribed so far 20000; took 28413ms to unsubscribe last 10000 at rate: 351 per sec...
unsubscribed so far 30000; took 27722ms to unsubscribe last 10000 at rate: 360 per sec...
...
unsubscribed so far 260000; took 2979ms to unsubscribe last 10000 at rate: 3356 per sec...
unsubscribed so far 270000; took 2012ms to unsubscribe last 10000 at rate: 4970 per sec...
unsubscribed so far 280000; took 1335ms to unsubscribe last 10000 at rate: 7490 per sec...
unsubscribed so far 290000; took 649ms to unsubscribe last 10000 at rate: 15408 per sec...
unsubscribed so far 300000; took 198ms to unsubscribe last 10000 at rate: 50505 per sec...
```

The main suspect is manageRequest() in OperatorReplay:

https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorReplay.java#L481-L546

That's where stack traces are pointing to during both subscribe() and unsubscribe() when the rate slows down.,Hi and thanks for the feedback. I've posted the PR #3470 improving on the performance (up to ~20x improvement).
 =||= 20x improvement is great but making it constant or near would be also nice. :) At this time we do not have any resources to look at it, but if no one else is able to pick this up, we might try to investigate and possibly contribute. 

For now, we will have to put a concept of caching observables via replay() aside. That was pretty elegant way of doing async cache though.
 =||= I've updated #3470 to have O(1) subscription cost and don't lose too much on the dispatching side by using the internals of an `OpenHashSet`. Let me know if it's fast enough for you.
 =||= Sweet!!! Hope this is merged into 1.x
 =||= Closing via #3470, should be available in 1.1.6.
 =||= ,0
3470,3469,replay/refCount subscribe/unsubscribe exhibit O(N) behavior,Subscribing to replay/refCount chain slows down as O(N) with number of existing subscribers. 

This is reproducible on a simple chain that never emits an item, thus data traffic should not be a factor in the performance degradation behavior:

``` java
Observable<?> shared = Observable.never().replay(1).refCount();
```

After certain number of subscribers sharing observable becomes unusable and wasting a lot of CPU cycles. In turn this draws useless some caching scenarios specifically with big number of subscribers.

Here is the simple test:

``` java
    final Observable<?> shared = Observable.never().replay(1).refCount();

    final int count = 300000;
    final int page = 10000;
    List<Subscription> ss = new ArrayList<>();
    System.out.println("subscribing...");
    long prev = System.currentTimeMillis();
    for (int i = 0; i < count; i++) {
      ss.add(shared.subscribe());
      if ((i+1) % page == 0) {
        long now = System.currentTimeMillis();
        System.out.println("subscribed so far " + (i+1) + "; took " + (now-prev) + "ms to subscribe last " + page + 
            " at rate: " + page*1000/(now-prev) + " per sec...");
        prev = now;
      }
    }
    System.out.println("unsubscribing...");
    prev = System.currentTimeMillis();
    for (int i = 0; i < count; i++) {
      ss.get(i).unsubscribe();
      if ((i+1) % page == 0) {
        long now = System.currentTimeMillis();
        System.out.println("unsubscribed so far " + (i+1) + "; took " + (now-prev) + "ms to unsubscribe last " + page + 
            " at rate: " + page*1000/(now-prev) + " per sec...");
        prev = now;
      }
    }

```

Here is the output on a 2015 MacBook Pro (PhysMem: 16G, jvm launched with -Xmx8000m):

```

subscribing...
subscribed so far 10000; took 374ms to subscribe last 10000 at rate: 26737 per sec...
subscribed so far 20000; took 905ms to subscribe last 10000 at rate: 11049 per sec...
subscribed so far 30000; took 1646ms to subscribe last 10000 at rate: 6075 per sec...
subscribed so far 40000; took 2557ms to subscribe last 10000 at rate: 3910 per sec...
...
subscribed so far 290000; took 29635ms to subscribe last 10000 at rate: 337 per sec...
subscribed so far 300000; took 30998ms to subscribe last 10000 at rate: 322 per sec...
unsubscribing...
unsubscribed so far 10000; took 32352ms to unsubscribe last 10000 at rate: 309 per sec...
unsubscribed so far 20000; took 28413ms to unsubscribe last 10000 at rate: 351 per sec...
unsubscribed so far 30000; took 27722ms to unsubscribe last 10000 at rate: 360 per sec...
...
unsubscribed so far 260000; took 2979ms to unsubscribe last 10000 at rate: 3356 per sec...
unsubscribed so far 270000; took 2012ms to unsubscribe last 10000 at rate: 4970 per sec...
unsubscribed so far 280000; took 1335ms to unsubscribe last 10000 at rate: 7490 per sec...
unsubscribed so far 290000; took 649ms to unsubscribe last 10000 at rate: 15408 per sec...
unsubscribed so far 300000; took 198ms to unsubscribe last 10000 at rate: 50505 per sec...
```

The main suspect is manageRequest() in OperatorReplay:

https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorReplay.java#L481-L546

That's where stack traces are pointing to during both subscribe() and unsubscribe() when the rate slows down.,Hi and thanks for the feedback. I've posted the PR #3470 improving on the performance (up to ~20x improvement).
 =||= 20x improvement is great but making it constant or near would be also nice. :) At this time we do not have any resources to look at it, but if no one else is able to pick this up, we might try to investigate and possibly contribute. 

For now, we will have to put a concept of caching observables via replay() aside. That was pretty elegant way of doing async cache though.
 =||= I've updated #3470 to have O(1) subscription cost and don't lose too much on the dispatching side by using the internals of an `OpenHashSet`. Let me know if it's fast enough for you.
 =||= Sweet!!! Hope this is merged into 1.x
 =||= Closing via #3470, should be available in 1.1.6.
 =||= ,0
3480,3479,1.x: reduce Subscriber's creation overhead,This PR changes the internals of the `Subscriber` class to reduce its creation overhead by deferring the creation of the SubscriptionList until it is actually needed.

Benchmark (i7 4770K, Windows 7 x64, Java 8u66)

![image](https://cloud.githubusercontent.com/assets/1269832/10806351/14e6567e-7dd5-11e5-8c06-3716454ccbc7.png)

For no-backpressure sources, the throughput is now doubled for the safe case and improved by ~20% for the unsafe case. For a backpressuring source, the improvement is between 3-10% but the error ranges overlap.

There is one case where the the throughput halved for some reason. Since JITs are smart, my best guess is that generally the benchmark method gets stack-allocated instead of heap allocated, hence the very large amounts relative to a range(1, 1) benchmark (which tops at 24 MOps/s). 

However, the justStart case is worse than the baseline. My guess is that the `this` looks like it escaped and thus a regular heap allocation is required. I'll test this theory in the morning by blackholing the test `Subscriber`s before subscription thus forcing a heap allocation in each case.

Note that `Subscriber` has now more synchronization which combined with the synchronization in `SubscriptionList` may increase the overhead elsewhere; I plan to run more benchmarks in the morning. The solution would be to inline the logic of `SubscriptionList` into `Subscriber` directly. 

Note also the recursive call to `add` and `unsubscribe` in case the `Subscriber` was created in sharing mode. In RxJava 1.x, operators like to share a single underlying `SubscriptionList` and if the chain is very long, that may prevent some JIT optimizations due to stack dept. The upside is that generally only a few resources are added to a `Subscriber`, especially in async operators, whose overhead may be shadowed by other things and thus not really a problem.,I've updated the `SubscribingPerf` to see what effect the isUnsubscribed implementation has and its not good: the throughput is generally reduced by ~20% due to the additional indirections:

Benchmark comparison (i7 **4790**, Windows 7 x64, Java 8u66):

![image](https://cloud.githubusercontent.com/assets/1269832/10813524/18512e74-7e20-11e5-9ac7-a38d3fe10431.png)

I've run out of ideas; due to the structure of the 1.x classes and the mandatory resource management of `Subscriber` I don't believe subscribing can be improved any further without endangering the streaming performance.
 =||= ,0
3491,3490,scan infinite loop,The following test fails in 1.x (and 1.0.15):

``` java
    @Test(timeout=1000)
    public void testScanDoesNotHang() {
        Observable.range(0, Integer.MAX_VALUE)
                //
                .scan(1, new Func2<Integer, Integer, Integer>() {

                    @Override
                    public Integer call(Integer t1, Integer t2) {
                        return t1;
                    }
                })
                //
                .subscribe(new Subscriber<Integer>() {

                    int count = 0;

                    @Override
                    public void onCompleted() {

                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onNext(Integer t) {
                        count++;
                        if (count == 2)
                            unsubscribe();
                    }
                });
    }
```

@akarnokd  I've stepped through in a debugger and in `OperatorScan` L284 initiates a fast path emission in `OnSubscriberRange` which calls `OperatorScan.emit()` L289 but because the method containing L284 has set `emitting` to true the emission goes no further and an a loop occurs that fills the heap.

Though the test might look a bit contrived I just isolated the behaviour to `scan` for the test. I encountered the bug when this hung:

``` java
observable.scan(..).elementAt(n); //where n > 1
```

I'd rank this bug as nasty (not an improbable edge case like some concurrency bugs) and possibly deserving of a new release quickly.,You are right. Serializing the requesting/producer arrival with the normal event emission is unnecessary. I'll merge #3485 now but start working on the fix in my morning. I'll review other operators that might exhibit the same problem.
 =||= Thanks @akarnokd 
 =||= See #3491 for the fix.
 =||= ,0
3493,3492,Backpressure on OperatorZip doesn't work when the observable is created using toList(),I've written an "SortedMerge" operator, which is used to orderly merge several ordered observables. The operator is based on [OperatorZip](https://github.com/ReactiveX/RxJava/blob/f2410f88dc28c1013f48754606e38507e493245f/src/main/java/rx/internal/operators/OperatorZip.java) except for several key differences:
1. Instead of passing an array of items into a zip function the items are compared using a comparator and only the smallest one is emitted.
2. After emissions, `requestMore` is called only on the observable from which the minimum was taken, and only its buffer's head is removed. The others are left untouched for future comparison. So no items are lost.
3. Additional type safety is added since the types of the incoming observables is known.

(I can contribute the operator to the project if anyone's interested).

During testing, I stumbled upon a use case that failed for my operator, and it turns out that the same problem exists in the original Zip.

Take a look at the following observables. First, o1:

```
Observable<Integer>[] osArray = new Observable[] { Observable.range(0, 10), Observable.range(0, 10) };
Observable<Observable<Integer>> os = (Observable<Observable<Integer>>) Observable.from(osArray);
Observable<Integer> o1 = Observable.zip(os, (a) -> 0);
```

Second, o2:

```
Observable<Integer> o2 = Observable.zip(Observable.range(0, 10), Observable.range(0, 10), (a, b) -> 0);
```

According to my understanding, both should work in exactly the same way. However, their response to requests from the subscriber is different:

```
TestSubscriber<Integer> sub1 = new TestSubscriber<>(5);
TestSubscriber<Integer> sub2 = new TestSubscriber<>(5);

o1.subscribe(sub1);
o2.subscribe(sub2);

sub1.requestMore(5);
sub2.requestMore(5);

sub1.awaitTerminalEvent(1, TimeUnit.SECONDS);
sub2.awaitTerminalEvent(1, TimeUnit.SECONDS);

System.out.println(sub1.getOnNextEvents().size());
System.out.println(sub2.getOnNextEvents().size());
```

produces this response:
     5
     10

Which is exactly what happened to my SortedMerge operator. After poking at the operator for a while, it turned out that the issue can be solved by changing the construction of the Zip subscriber ZipSubscriber from this:

```
public ZipSubscriber(Subscriber<? super R> child, Zip<R> zipper, ZipProducer<R> producer) {
        super(child);
        this.child = child;
        this.zipper = zipper;
        this.producer = producer;
    }
```

to this:

```
public ZipSubscriber(Subscriber<? super R> child, Zip<R> zipper, ZipProducer<R> producer) {
        super();
        this.child = child;
        this.zipper = zipper;
        this.producer = producer;
    }
```

Which seems to make sense, but I'm not sure that I understand Rx's backpressure well enough to know whether that's indeed the right solution.,Hello and thanks for the in-depth analysis. What happens is that the child is caputed by `ZipSubscriber` and when it receives its `Producer` from `toList`, that also gets forwarded to child which overwrites the `ZipProducer` and thus no further requests get accounted. The fix is posted in #3493

Ordered merging comes up from time to time on StackOverflow; you can post a PR for it but frankly, if Netflix doesn't need one urgently, it can take a long time to get it approved.
 =||= Thanks. That's pretty much what I suspected.

So if I understand correctly, your solution was to disconnect the child from the backpressure chain, but add the `ZipSubscriber` to its subscription list so it'll know whether the downstream is subscribed.
 =||= Yes. I've fixed like dozens of such bugs before; it is a design shortcoming of `Subscriber`.
 =||= @MaltAlex re your sorted merge operator. You can find one at [rxjava-extras](https://github.com/davidmoten/rxjava-extras) as well (`Transformers.orderedMergeWith`) with almost complete test coverage (for what that's worth). Even if you don't use it the testing strategy might be useful to you:
- test ordered merge of all pairs of sorted sets taken from a Power Set of numbers from 1..n, perform for n=0 to 10
- do the above synchronously and asynchronously

The operator I made requires backpressure supporting sources but does not support backpressure itself and would be combined with `.onBackpressureXXX`.

I think @akarnokd has one of these floating around as well but I don't know if it has unit tests.
 =||= I [have one](https://gist.github.com/akarnokd/c86a89738199bbb37348) that supports backpressure but without unit tests.
 =||= I'll have a look at your SortedMerge @akarnokd and beef up unit tests
(there were some with your gist)

On 5 November 2015 at 18:59, David Karnok notifications@github.com wrote:

> I have one https://gist.github.com/akarnokd/c86a89738199bbb37348 that
> supports backpressure but without unit tests.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/3492#issuecomment-153981952.
 =||= @davidmoten I looked at your implementation before going forward with my own. There were a few details in the implementation that I couldn't figure out, plus the lack of backpressure support was a complete deal breaker in my case. That's why I modified the Zip operator to fit my needs. Its functionality is almost identical.

So now I have one of those operators too, and the only test that failed for it (erm... so far) was a test that failed for the original Zip as well (hence this issue). I might put it on github sometime later.
 =||= would be good to see your implementation @MaltAlex. Operators are complex and are hard to test due to async possibilities but I'll chuck the best candidate in a _rxjava-extras_ release. The candidate from @akarnokd will have a good chance of winning out because he knows this domain so well!
 =||= The implementation from @akarnokd passes my power set tests. Do you have any plans for it @akarnokd? Do you mind if I throw it in to _rxjava-extras_ (I'd make clear your authorship in the source)?
 =||= No plans, go ahead.
 =||= Fix delivered with 1.0.16. The discussion about sorted merge can continue in a different thread if you wish.
 =||= ,0
3510,3508,Null pointer using ConcatMapEager on Android 4.2,I am using a Tablet with Android 4.2  using 'io.reactivex:rxjava:1.0.15'

In Android 5.1 it works fine, but not it 4.2

```
public Observable<Artist[]> batchGetArtistsById(ArtistIdList artistIdList) {
        return Observable.from(artistIdList.getArtistIds())
                .concatMapEager(artist -> getArtistById(artist))
                .subscribeOn(Schedulers.io())
                .toList()
                .observeOn(AndroidSchedulers.mainThread())
                .doOnError(e ->
                        {
                            System.out.println("Error what to do? " + e);
                        }
                )
                .flatMap(artistList -> {
                    Artist[] artistsArray = artistList.toArray(new Artist[artistList.size()]);
                    return Observable.just(artistsArray);
                });
}
```

11-09 16:23:01.485 6762-6782/? E/AndroidRuntime: FATAL EXCEPTION: RxCachedThreadScheduler-1
                                                 java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.
                                                     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)
                                                     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)
                                                     at java.util.concurrent.FutureTask.run(FutureTask.java:234)
                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)
                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)
                                                     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)
                                                     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)
                                                     at java.lang.Thread.run(Thread.java:856)
                                                  Caused by: java.lang.ExceptionInInitializerError
                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.<init>(OperatorEagerConcatMap.java:281)
                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.onNext(OperatorEagerConcatMap.java:130)
                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:127)
                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70)
                                                     at rx.Subscriber.setProducer(Subscriber.java:209)
                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)
                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)
                                                     at rx.Observable$2.call(Observable.java:162)
                                                     at rx.Observable$2.call(Observable.java:154)
                                                     at rx.Observable.unsafeSubscribe(Observable.java:8171)
                                                     at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
                                                     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
                                                     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390) 
                                                     at java.util.concurrent.FutureTask.run(FutureTask.java:234) 
                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153) 
                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267) 
                                                     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080) 
                                                     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573) 
                                                     at java.lang.Thread.run(Thread.java:856) 
                                                  Caused by: java.lang.NullPointerException
                                                     at rx.internal.util.unsafe.ConcurrentCircularArrayQueue.<clinit>(ConcurrentCircularArrayQueue.java:51)
                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.<init>(OperatorEagerConcatMap.java:281) 
                                                     at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.onNext(OperatorEagerConcatMap.java:130) 
                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:127) 
                                                     at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70) 
                                                     at rx.Subscriber.setProducer(Subscriber.java:209) 
                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49) 
                                                     at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32) 
                                                     at rx.Observable$2.call(Observable.java:162) 
                                                     at rx.Observable$2.call(Observable.java:154) 
                                                     at rx.Observable.unsafeSubscribe(Observable.java:8171) 
                                                     at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62) 
                                                     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) 
                                                     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390) 
                                                     at java.util.concurrent.FutureTask.run(FutureTask.java:234) 
                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153) 
                                                     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267) 
                                                     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080) 
                                                     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573) 
                                                     at java.lang.Thread.run(Thread.java:856) ,Do you, by any chance, have a Samsung device?
 =||= Its a Custom Tablet , non branded .

On 9 November 2015 at 17:14, David Karnok notifications@github.com wrote:

> Do you, by any chance, have a Samsung device?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/3508#issuecomment-155128725.
 =||= @akarnokd you can create Android 4.2 emulator (Android API level 17) and try to run tests (#3503) on it, or I'll do this tonight.
 =||= I tried with Genymotion I get the same error

On 9 November 2015 at 17:38, Artem Zinnatullin notifications@github.com
wrote:

> @akarnokd https://github.com/akarnokd you can create Android 4.2
> emulator (Android API level 17) and try to run tests (#3503
> https://github.com/ReactiveX/RxJava/issues/3503) on it, or I'll do this
> tonight.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/3508#issuecomment-155135337.
 =||= My guess is that there is the same field error as with those Samsung devices so android.os.Build.VERSION.INT_VER is not properly discovered and the library thinks it runs on desktop Java.
 =||= Ups, my bad. Forgot to check the unsafe access in eager concatmap.
 =||= Fix posted in #3510
 =||= Closing via #3510.
 =||= ,0
3511,310,How to observe perpetually changing Iterable,Hi guys. Can you explain how to observer a perpetually changing Iterable? For instance, here is some code:

``` java
public class ReportConnector {

  private ConcurrentLinkedQueue<String> eventList = new ConcurrentLinkedQueue<String>();
  private Observable<String> observable;

  public ReportConnector() {
    observable = Oberservable.toObservable(eventList);
    observable.subscribe(new Action1<String>() {
      @Override
      public void call(String event) {
        System.out.println("Val sent: "+event);
      }
    });
  }

  public addEvent(String event) {
    eventList.add(event);
  }
}
```

The problem is, the observable immediately calls onComplete in the constructor after adding the subscriber, and then subsequent additions to my linked queue through the addEvent method never get processed by the subscriber. I'm sure I'm missing a big concept here, so any help in pointing me to how to do this correctly would be greatly appreciated. Thanks!,The Oberservable.toObservable(eventList) method captures the current state
of the Iterable, emits it and completes. There is no builti-in mechanism
for observing an Iterable for future changes.

If the source Iterable must exist and can't be wrapped/modified then
something (likely a thread) would need to poll that Iterable for new values
that are then emitted to an Observable via onNext and never call
onCompleted.

If the source Iterable can be wrapped or replaced, I'd make it so whenever
something is offered to the ConcurrentLinkedQueue that it also gets sent to
the Observable onNext. This is obviously far more efficient than polling an
Iterable.

Basically, wherever the events originally come from it is better to capture
that event and push it to the Observable rather than route them through an
Iterable if you can. The Observable.from(Iterable) method is just a bridge
from a snapshot of a List/Collection.

The monitoring approach could theoretically be done with a signature such
as Observable.monitor(Iterable i, Scheduler s) with the Scheduler giving it
the thread to perform the monitoring on.

Ben

On Tue, Jul 23, 2013 at 3:41 PM, Eric Nelson notifications@github.comwrote:

> Hi guys. Can you explain how to observer a perpetually changing Iterable?
> For instance, here is some code:
> 
> public class ReportConnector {
> 
>   private ConcurrentLinkedQueue<String> eventList = new ConcurrentLinkedQueue<String>();
>   private Observable<String> observable;
> 
>   public ReportConnector() {
>     observable = Oberservable.toObservable(eventList);
>     observable.subscribe(new Action1<String>() {
>       @Override
>       public void call(String event) {
>         System.out.println("Val sent: "+event);
>       }
>     });
>   }
> 
>   public addEvent(String event) {
>     eventList.add(event);
>   }}
> 
> The problem is, the observable immediately calls onComplete in the
> constructor after adding the subscriber, and then subsequent additions to
> my linked queue through the addEvent method never get processed by the
> subscriber. I'm sure I'm missing a big concept here, so any help in
> pointing me to how to do this correctly would be greatly appreciated.
> Thanks!
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/310
> .

## 

Ben Christensen - API Team
+1-310-781-5511  @benjchristensen
 =||= You might want to look at the Subject and friends.  A subject is both and observable and observer at the same time.

```
    PublishSubject<String> events = PublishSubject.create();
    events.subscribe(new Action1<String>() {
        @Override
        public void call(String event) {
            System.out.println("Val sent: " + event);
        }
    });
    events.onNext("one");
    events.onNext("two");
```
 =||= Thanks so much for your quick responses. I really appreciate it!
 =||= ,0
3512,3059,SafeSubscriber does not call `onCompleted` after `unsubscribe`, allows further calls to `onNext`,[The documentation for `SafeSubscriber`](http://reactivex.io/RxJava/javadoc/rx/observers/SafeSubscriber.html) states:

> If `unsubscribe` is called, calls `onCompleted` and forbids any further `onNext` calls.

However, in practice, it appears that `SafeSubscriber` does neither of those.

---

The following code should call `onCompleted`:

``` java
Subscription sub = Observable.interval(10, TimeUnit.MILLISECONDS)
  .subscribe(
    l -> System.out.println("Received: " + l),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
  );

sleep(50);
sub.unsubscribe();
```

However, the output is as follows:

```
Received: 0
Received: 1
Received: 2
Received: 3
Received: 4
```

---

The following code should not call `onNext` after unsubscription:

``` java
Observable<Long> observable = Observable.create(subscriber -> {
  long n = 0;
  while (true) {
    sleep(10);
    subscriber.onNext(n++);
  }
});

Subscription sub = observable
  .subscribeOn(Schedulers.newThread())
  .subscribe(
    l -> System.out.println("Received: " + l),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
  );
sleep(50);
sub.unsubscribe();
System.out.println("Unsubscribed!");
```

However, this is the output:

```
Received: 0
Received: 1
Received: 2
Received: 3
Received: 4
Unsubscribed!
Received: 5
Received: 6
Received: 7
Received: 8
...
```

---

It seems to me that one of three things is going on:
1. `SafeSubscriber` isn't as safe as it should be.
2. The documentation is out-of-date.
3. I'm missing something.,> If unsubscribe is called, calls onCompleted...
- `onCompleted` should only be called after all the `onNext` notifications have arrived so the behaviour described in the javadoc does not comply with the Observable contract. We should remove this. 

> and forbids any further onNext calls.
- if unsubscription occurs it is preferred that no more notifications be forwarded to the subscriber (though this is not mandated behaviour generally). `SafeSubscriber` attempts no such guarantees currently as you've noticed though it could do so by adding an unsubscribe action to the underlying subscriber that sets a volatile boolean  when called. That boolean could then be checked on each arrival to `SafeSubscriber` of a notification. I assume the addition of a volatile read on every emission could be sufficiently expensive at runtime to make this undesirable. I'm sure @akarnokd will have an opinion on this one for us. 
 =||= > I assume the addition of a volatile read on every emission could be sufficiently expensive at runtime to make this undesirable.

and 

> if unsubscription occurs it is preferred that no more notifications be forwarded to the subscriber 

seem to slightly contradict in that to accurately stop notifications one has to check `!s.isUnsubscribed()` before emitting which _is_ that very volatile read anyway.

I discovered this problem last night when `unsubscribe()` was being called from a thread different than subscribe and emission and in order to stop future emission I had to get back onto the original thread.

``` java
Thing thing = //...
Observable<Object> o = Observable.create(s -> {
  checkUiThread();
  Thing.Listener listener = v -> s.onNext(v);
  s.add(Subscriptions.create(() -> {
    postUiThread(() -> thing.removeListener(listener));
  }));
  thing.addListener(listener);
});
```

When unsubscribe happens, we cannot detach the emitter without moving back to the original subscription thread. This runs synchronously if you are already on that thread, but sometimes it has to be queued and there might be an event already queued for processing.

Where I find this extremely problematic is when you have a `doOnUnsubscribe` action on the stream. This action will be fired yet you still might receive an `onNext`.
 =||= Hah, yes of course, just need to check `isUnsubscribed` on the underlying subscriber as you point out! 

No surprise to you I'm sure but `doOnUnsubscribe` will report the unsubscribe request on its way upstream to the source and there could still be inflight emissions. Another possibility is that sources and operators are not bound to honour unsubscribe by the Observable contract, it's best endeavours.

The catch with all this is that putting the `isUnsubscribed` check in `SafeSubscriber` doesn't help much  if our Observable looks like this:

``` java
observable.doOnNext(System.out::println).subscribe(...);
```

In this case though `unsubscribe` was called and `SafeSubscriber` prevented the endpoint subscriber getting notifications after unsubscription we might still get more emissions fed to the `doOnNext`.

I suppose there are probably techniques for making your use case more responsive to unsubscription @JakeWharton and you are no doubt on top of them. Is there support you'd like to see in the API that would help you? What sort of reliance on `doOnUnsubscribe` do you have (you said it's extremely problematic)?
 =||= Oops, I may have a been a bit too apocalyptic with my words. I have used subscribe/unsubscribe callbacks for holding state as a side-effect. This almost certainly would trigger an unexpected condition if I tear down/complete the side-effect state and then receive another event and assume I could act on it. But you're right, it makes total sense that the notifications are happening in two directions here.

Thankfully, in practice this has never been a problem. In all of these cases unsubscription has happened from the UI thread which allows everything to happen synchronously anyway. I only discovered the errant behavior (and its subsequent documentation problem) during a unit test which was operating on two threads.

I think all we're really after here is a documentation change to remove the guarantees it currently claims to offer. As to whether guarantees about `onNext` will be enforced on not, I'll leave that up to you all to decide based on the performance implications. I'm pretty sure that checking for unsubscription before emitting is a best practice for operators so I'm perfectly fine if it results only in a documentation change as well.
 =||= Well, @dlew found the errant documentation and wrote the nice tests. I just assumed it was user error in my operator implementation!
 =||= The first example works as expected and the documentation is wrong.

The behavior of `SafeSubscriber` is somewhat questionable but the general expectation is that sources check for `isUnsubscribed` before calling `onNext`, therefore, `SafeSubscriber` doesn't duplicate such work.
 =||= Posted a PR that changes the javadoc in #3512.
 =||= ,0
3513,2835,Cannot define plugin properties on Android,The property key max length on Android devices/emulators is 31 characters thereby preventing the ability to set properties for use by the plug in system.  

The property key template is 29 characters on its own.
`rxjava.plugin.[class-name-here].implementation`

Is it likely that a shorter key could be used to enable this feature on Android?,I'm not familiar with the constraints on Android. How about we give you the following system property that wraps other system properties:

```
rxjava.props.1.key=rxjava.plugin.[class-name-here].implementation
rxjava.props.1.value=come.somepath.SomeClass
```

i.e., is it possible the use System.setProperty(key, value) on Android with long keys? Does the 31 character limit apply to command-line only?
 =||= I have to say, that is a ridiculous limitation.

We can't change existing keys, but if someone wants to submit a PR with aliases that set both, that could work.
 =||= I've posted PR #3513 with a shorter scheme proposal.
 =||= Solution merged and delivered in 1.1.0
 =||= ,0
3524,3523,subscribe() doesn't actually "ignore its emissions and notifications" as documented,The zero-arg rx.Observable#subscribe() method says that it "ignore its emissions and notifications" but in fact it throws an Exception for onError.,Fix in #3524 merged.
 =||= ,0
3556,3555,Exceptions not being propagated via onError when using toMap with observeOn,Hi,

When I try to use toMap() where my value selector may throw an exception, the error only seems to be propagated via the Observable error stream if the observable is with running single threaded or subscribeOn is being used, but not when observeOn is being used.

Here is a unit test to illustrate the problem, where the test "onErrorCalledWhenObserveOnUsed" fails:

``` java
public class RxJavaToMapWithErrorBehaviourTest {

  @Test
  public void onErrorCalledForSingleThread() {
    Observable<Map<Integer, Integer>> observable = Observable.just(1, 2, 3, 4, 5)
          .toMap(n -> n, n -> {
            throw new IllegalStateException();
          });

    assertOnErrorCalled(observable);
  }

  @Test
  public void onErrorCalledWhenSubscribeOnUsed() {
    Observable<Map<Integer, Integer>> observable = Observable.just(1, 2, 3, 4, 5)
          .subscribeOn(Schedulers.computation())
          .toMap(n -> n, n -> {
            throw new IllegalStateException();
          });

    assertOnErrorCalled(observable);
  }

  @Test
  public void onErrorCalledWhenObserveOnUsed() {
    Observable<Map<Integer, Integer>> observable = Observable.just(1, 2, 3, 4, 5)
          .observeOn(Schedulers.computation())
          .toMap(n -> n, n -> {
              throw new IllegalStateException();
          });

    assertOnErrorCalled(observable);
  }

  private <T> void assertOnErrorCalled(Observable<T> observable) {
    TestSubscriber<T> subscriber = new TestSubscriber<>();
    observable.subscribe(subscriber);

    subscriber.awaitTerminalEvent(2, TimeUnit.SECONDS);
    subscriber.assertError(IllegalStateException.class);
  }

}
```

The error thrown is:

```
Exception in thread "RxComputationThreadPool-3" java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.IllegalStateException
    at RxJavaToMapWithErrorBehaviourTest.lambda$onErrorCalledWhenObserveOnUsed$5(RxJavaToMapWithErrorBehaviourTest.java:47)
    at RxJavaToMapWithErrorBehaviourTest$$Lambda$2/431687835.call(Unknown Source)
    at rx.internal.operators.OperatorToMap$1.onNext(OperatorToMap.java:90)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:208)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:170)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
    ... 7 more

```

The observeOn() case seems to make make sense for my use-case at least (where I used subscribeOn to do a database call, followed by observeOn for subsequent calculations).

I think I can probably workaround this problem by first doing a map() to do the calculation and then the toMap(), but I wondered whether this was a bug or expected behaviour?

Thanks.,Hi. This is an oversight on our part. Fix in #3556.
 =||= Wow, that was quick. :+1: 

Thanks very much.
 =||= ,0
3584,3411,#groupBy resubscribes to Observable after unsubscribing,_Apologies if this is repeated. #283 looked similar but I'm opening a new issue since that doesn't seem to be the current behavior_

`Observable#groupBy` encourages us to unsubscribe from `Observables` that we no longer want values from to avoid leaking that memory, which makes total sense:

Example:

``` java
observable
    .groupBy(SomeKey::new)
    .subscribe(groupedObservable -> {
        // This is called again after unsubscribing.
        groupedObservable
            .take(1)
            .subscribe(...)
    })
```

This works fine. However, there's a behavior I was not expecting: after `groupedObservable` has been unsubscribed, the `Observable` returned by `observable.groupBy` emits that observable again!

Is this expected?

_(Currently using version 1.0.10)_,This is the expected behavior.

``` java
Observable.range(1, 10)
.groupBy(v -> 1)
.flatMap(g -> g.take(1))
.subscribe(System.out::println);
```

This will print values from 1-10. 

Whether or not this is reasonable is up for discussion, the alternative would be to drop values once the single subscriber to the group unsubscribes so no groups are opened
 =||= Seems counter intuitive, and I think it at least deserves a comment in the docs.
How could I implement a similar `groupBy` operator that never emits that same `Observable` again?
 =||= This behaviour is not what I would hope from `groupBy` either. I can imagine both the resubscribing and non-resubscribing behaviour being useful but I would expect the default to be non-resubscribing. 
 =||= Thanks @davidmoten, I agree.
 =||= Anyone out there know what the Microsoft Rx `groupBy` behaviour is in this regard?
 =||= What I can deduce from the [source code](https://github.com/Reactive-Extensions/Rx.NET/blob/a13e3ff05bdded5cef2bf40bface22f8fa4ae316/Rx.NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/GroupBy.cs) is that groups are created but never removed and once all groups and the main output is disposed, the source is stopped.

Note that Rx.NET doesn't have backpressure and the synchronous cancellation is a mistery to me in it.

> How could I implement a similar groupBy operator that never emits that same Observable again?

GroupBy is perhaps the most complicated operator to think about because of the request/unsubscribe coordination requirement. 

You could try using publish on a group to prevent it from unsubscribing:

``` java
Observable.range(1, 10)
.groupBy(i -> i % 2 == 0)
.flatMap(g -> g.publish().autoConnect().take(1))
.subscribe(System.out::println);
```
 =||= Thanks for checking that out @akarnokd. I assume from your description that the Microsoft Rx `groupBy` follows the non-resubscribing approach. 

I'm tempted to describe the current `groupBy` behaviour as a bug. @benjchristensen any thoughts?
 =||= It is supposed to resubscribe, and is different than the Microsoft version on purpose which has issues with 'time gap' and which does not support back pressure (which seriously changes things). 

See the 1.0 release notes for information (section on 'groupBy/groupByUntil'  in https://github.com/ReactiveX/RxJava/releases/tag/v1.0.0) and https://github.com/ReactiveX/RxJava/pull/1727 for the proposed changes and reasoning. 

In v2 we will separate Observable and Flowable which will allow the resubscribe behavior to be different if we wanted again on the non-backpressured version. 
 =||= Another thought on this for clarification - if the operator remembers what has been unsubscribed so as to drop subsequent events, that means it uses memory and is the "memory leak" mentioned above. Not a big deal for small numbers of groups or short-lived streams, but it does retain all group keys for the duration if that implementation is chosen. 
 =||= > You could try using publish on a group to prevent it from unsubscribing:

Then we're just leaking more memory than the group keys.

> Another thought on this for clarification - if the operator remembers what has been unsubscribed so as to drop subsequent events, that means it uses memory and is the "memory leak" mentioned above.

True, but that's required to get the behavior that most people in this issue have labeled as expected (and unfortunately this is not documented).

Would it be easy to implement the old `groupByUntil`?
 =||= The things I linked to explain why they were combined, and groupByUntil behaves how you don't want it (it would re-emit the group). Your use case requires remembering previously seen keys, so you have to retain that knowledge. The solution from @akarnokd is a good one. There are other ways involving filter, such as not using take(1) but instead filtering out all values after the first. 
 =||= This is a solution using `filter` as mentioned by @benjchristensen:

``` java
Observable.range(1, 10)
  .groupBy(i -> i % 2 == 0)
  .flatMap(g -> 
    Observable.defer(() -> {
      final AtomicBoolean isFirst = new AtomicBoolean(true);
      return g.filter(x -> isFirst.compareAndSet(true, false));
    }))
  .subscribe(System.out::println);
```

Admittedly it doesn't offer the same guarantees as `take(1)` like emitting an error if the stream completes without emitting.
 =||= That's only a solution equivalent to `take(1)`, but in my case the inner `Observable` is unsubscribed with more complex logic.
 =||= > if the operator remembers what has been unsubscribed so as to drop subsequent events, that means it uses memory and is the "memory leak" mentioned above

Isn't that true with any operator that has "memory", like `distinct`? In fact I don't see how this is any different than `distinct`.
 =||= Thanks @NachoSoto for bringing the behaviour of `groupBy` to my attention. I think this behaviour needs description in the javadoc at minimum. I checked my codebases for `groupBy` usage to make sure I wasn't going to get bitten by this and I've nothing to worry about. Since I've become aware of the behaviour I keep bumping into use cases where I would want the resubscribing behaviour so I'll be glad if the behaviour is retained under some method name.

My leaning at the moment is to document the behaviour of the existing operator and not change it but add another operator say `groupByOnce` (?) that offers the non-resubscribing behaviour you expected. Thoughts?
 =||= :+1: :+1: :+1: 
 =||= I can't read that comment @NachoSoto, say again?
 =||= Fixed?
 =||= I'm preparing a PR to clarify the behaviour in the javadoc and notice that `groupBy` says this in javadoc:

```
Groups the items emitted by an {@code Observable} according to a specified criterion, and emits these
grouped items as {@link GroupedObservable}s, one {@code GroupedObservable} per group.
```

No surprise that people have been confused by this operator because it is explicit that its output is _one_ `GroupedObservable` per group! I'll correct this and explain further.
 =||= ~~Correction: it is one `GroupedObservable` per group, just potentially multiple subscriptions.~~
 =||= Blimey, correction to my correction, multiple GroupedObservables can be emitted (against what the javadoc says), deleting my previous comment.
 =||= I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.
 =||= ,0
3584,3581,observable.first() not working properly after grouping data,I am calling things like this

```
Observable.just(1, 2, 3, 4, 5, 6)
                .groupBy(i -> i % 3)
                .flatMap(o -> o.first())
                .subscribe(System.out::println);
```

Ideally this should return 1,2,3
But the result is - 

```
1
2
3
4
5
6
```

got this issue in version 1.0.10 and 1.1.0 as well,This is expected. `groupBy` will emit a new `Observable` if the previous `Observable` of the same group is subscribed.
 =||= This has been discussed in #3411. It's about time I made this clearer in the javadoc so I'll knock up a PR soon.
 =||= Looks like this issue can be closed? 
 =||= #3584 has updated the doc.
 =||= ,0
3584,3411,#groupBy resubscribes to Observable after unsubscribing,_Apologies if this is repeated. #283 looked similar but I'm opening a new issue since that doesn't seem to be the current behavior_

`Observable#groupBy` encourages us to unsubscribe from `Observables` that we no longer want values from to avoid leaking that memory, which makes total sense:

Example:

``` java
observable
    .groupBy(SomeKey::new)
    .subscribe(groupedObservable -> {
        // This is called again after unsubscribing.
        groupedObservable
            .take(1)
            .subscribe(...)
    })
```

This works fine. However, there's a behavior I was not expecting: after `groupedObservable` has been unsubscribed, the `Observable` returned by `observable.groupBy` emits that observable again!

Is this expected?

_(Currently using version 1.0.10)_,This is the expected behavior.

``` java
Observable.range(1, 10)
.groupBy(v -> 1)
.flatMap(g -> g.take(1))
.subscribe(System.out::println);
```

This will print values from 1-10. 

Whether or not this is reasonable is up for discussion, the alternative would be to drop values once the single subscriber to the group unsubscribes so no groups are opened
 =||= Seems counter intuitive, and I think it at least deserves a comment in the docs.
How could I implement a similar `groupBy` operator that never emits that same `Observable` again?
 =||= This behaviour is not what I would hope from `groupBy` either. I can imagine both the resubscribing and non-resubscribing behaviour being useful but I would expect the default to be non-resubscribing. 
 =||= Thanks @davidmoten, I agree.
 =||= Anyone out there know what the Microsoft Rx `groupBy` behaviour is in this regard?
 =||= What I can deduce from the [source code](https://github.com/Reactive-Extensions/Rx.NET/blob/a13e3ff05bdded5cef2bf40bface22f8fa4ae316/Rx.NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/GroupBy.cs) is that groups are created but never removed and once all groups and the main output is disposed, the source is stopped.

Note that Rx.NET doesn't have backpressure and the synchronous cancellation is a mistery to me in it.

> How could I implement a similar groupBy operator that never emits that same Observable again?

GroupBy is perhaps the most complicated operator to think about because of the request/unsubscribe coordination requirement. 

You could try using publish on a group to prevent it from unsubscribing:

``` java
Observable.range(1, 10)
.groupBy(i -> i % 2 == 0)
.flatMap(g -> g.publish().autoConnect().take(1))
.subscribe(System.out::println);
```
 =||= Thanks for checking that out @akarnokd. I assume from your description that the Microsoft Rx `groupBy` follows the non-resubscribing approach. 

I'm tempted to describe the current `groupBy` behaviour as a bug. @benjchristensen any thoughts?
 =||= It is supposed to resubscribe, and is different than the Microsoft version on purpose which has issues with 'time gap' and which does not support back pressure (which seriously changes things). 

See the 1.0 release notes for information (section on 'groupBy/groupByUntil'  in https://github.com/ReactiveX/RxJava/releases/tag/v1.0.0) and https://github.com/ReactiveX/RxJava/pull/1727 for the proposed changes and reasoning. 

In v2 we will separate Observable and Flowable which will allow the resubscribe behavior to be different if we wanted again on the non-backpressured version. 
 =||= Another thought on this for clarification - if the operator remembers what has been unsubscribed so as to drop subsequent events, that means it uses memory and is the "memory leak" mentioned above. Not a big deal for small numbers of groups or short-lived streams, but it does retain all group keys for the duration if that implementation is chosen. 
 =||= > You could try using publish on a group to prevent it from unsubscribing:

Then we're just leaking more memory than the group keys.

> Another thought on this for clarification - if the operator remembers what has been unsubscribed so as to drop subsequent events, that means it uses memory and is the "memory leak" mentioned above.

True, but that's required to get the behavior that most people in this issue have labeled as expected (and unfortunately this is not documented).

Would it be easy to implement the old `groupByUntil`?
 =||= The things I linked to explain why they were combined, and groupByUntil behaves how you don't want it (it would re-emit the group). Your use case requires remembering previously seen keys, so you have to retain that knowledge. The solution from @akarnokd is a good one. There are other ways involving filter, such as not using take(1) but instead filtering out all values after the first. 
 =||= This is a solution using `filter` as mentioned by @benjchristensen:

``` java
Observable.range(1, 10)
  .groupBy(i -> i % 2 == 0)
  .flatMap(g -> 
    Observable.defer(() -> {
      final AtomicBoolean isFirst = new AtomicBoolean(true);
      return g.filter(x -> isFirst.compareAndSet(true, false));
    }))
  .subscribe(System.out::println);
```

Admittedly it doesn't offer the same guarantees as `take(1)` like emitting an error if the stream completes without emitting.
 =||= That's only a solution equivalent to `take(1)`, but in my case the inner `Observable` is unsubscribed with more complex logic.
 =||= > if the operator remembers what has been unsubscribed so as to drop subsequent events, that means it uses memory and is the "memory leak" mentioned above

Isn't that true with any operator that has "memory", like `distinct`? In fact I don't see how this is any different than `distinct`.
 =||= Thanks @NachoSoto for bringing the behaviour of `groupBy` to my attention. I think this behaviour needs description in the javadoc at minimum. I checked my codebases for `groupBy` usage to make sure I wasn't going to get bitten by this and I've nothing to worry about. Since I've become aware of the behaviour I keep bumping into use cases where I would want the resubscribing behaviour so I'll be glad if the behaviour is retained under some method name.

My leaning at the moment is to document the behaviour of the existing operator and not change it but add another operator say `groupByOnce` (?) that offers the non-resubscribing behaviour you expected. Thoughts?
 =||= :+1: :+1: :+1: 
 =||= I can't read that comment @NachoSoto, say again?
 =||= Fixed?
 =||= I'm preparing a PR to clarify the behaviour in the javadoc and notice that `groupBy` says this in javadoc:

```
Groups the items emitted by an {@code Observable} according to a specified criterion, and emits these
grouped items as {@link GroupedObservable}s, one {@code GroupedObservable} per group.
```

No surprise that people have been confused by this operator because it is explicit that its output is _one_ `GroupedObservable` per group! I'll correct this and explain further.
 =||= ~~Correction: it is one `GroupedObservable` per group, just potentially multiple subscriptions.~~
 =||= Blimey, correction to my correction, multiple GroupedObservables can be emitted (against what the javadoc says), deleting my previous comment.
 =||= I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.
 =||= ,0
3614,3496,1.x: make just() support backpressure,One does not simply add backpressure support to `just()`.
## Fixes

The reason for this is the bugs hidden by the lack of backpressure support of just(): the overwriting of a previous Producer by `timeout`, `zip` and `subscribeOn`. I've fixed up `timeout` with a proper `ProducerArbiter`, had to apply the bugfix from #3493 to `zip` (may conflict) and had to rewrite `subscribeOn` from scratch and have it an `OnSubscribe`. This change required that `Single.subscribeOn` to be rewritten as well.
## Benchmark

Let's see the benchmark comparison (i7 4790, Windows 7 x64, Java 8u66):

![image](https://cloud.githubusercontent.com/assets/1269832/10972989/ec1eb288-83db-11e5-951c-48840b165b7e.png)

There are two ways to implement backpressure: with strong atomics or with plain field accesses. The latter tries to exploit the high chance that there won't be concurrent calls to `request()` ever and thus saves on the atomics. As far as I can tell, there is nothing in RxJava 1.x or 2.x that would violate this assumption. However, I added an escape hatch in case of rogue requesters: set the `rx.just.strong-mode` system parameter to "true" and `just` will run with strong atomics.

As seen in the table, the weak version is just slightly better (+3-+10%) in some cases and slightly worse (up to -3%) in other cases. Note, however, the original cases have 2x-5x less overhead. 

Maybe the most revealing are the `simple`, `simpleEscape` and `simpleEscapeAll` comparison between and within version. What's seen there is that with the original version, the JIT converted the test into a pure stack-allocation and thus saving on overhead in the `simple` case. As the other tests add escapes, it forces the JIT to do regular allocations. Interesting that with this PR, the escape doesn't really matter: this is due to how `Subscriber.setProducer` makes the JIT believe the producer escapes.

In the `simpleEscapeAll` (which should be the most restrictive for JIT), the overhead is still 2 - 2.3 times bigger: this is due to the extra allocation of a `Producer` instance when subscribing.

If one remembers my recent [blog post](http://akarnokd.blogspot.hu/2015/10/comparison-of-reactive-streams.html), it can be seen that RxJava 2.x does quite well, about 30 Mops/s in the range-1 test (which is equivalent to `simple`). 

Where does the overhead come from? `SubscriptionList`. In 1.x, the `Subscriber` creates a `SubscriptionList` whether or not it is ever required. (I've tried my best several times to defer the creation of this list to no success: the performance improved for some cases while worsened for others, see #3479.)

The strong/weak optimization is not applied to `scalarScheduleOn`. I haven't benchmarked it but I guess the scheduling overhead overshadows it anyways.
## Conclusion

I believe the correctness of `just` is more important than its performance, but the increased overhead bothers me nonetheless. Given the architecture of 2.x, I'll look into ways to get rid of the mandatory `SubscriptionList` allocation without breaking public API classes such as `Subscriber`.,Rebased.
 =||= Interesting. Thanks! :+1: 
 =||= This should probably be checked out by @benjchristensen before merging
 =||= Just to check, you are fine with the overhead, right?
 =||= @akarnokd yes. I think consistent behavior is worth the hit. 
 =||= :+1: 
 =||= Any plans to merge this one?
 =||= We are waiting for Ben but I have to fix the merge conflict as well now I see.
 =||= Sorry, I'll redo this entire PR, everything is messed up.
 =||= Replaced by #3614 
 =||= ,0
3623,3618,Improve README.MD by adding links to the source files of @Beta and @Experimental,There are no links to the annotations mentioned above in the documentation and this makes their source unaccessible a bit.,Closing via #3623
 =||= ,0
3630,3629,concatMapEager blows up on null values,While flatMap and concatMap are fine with flattening null values, concatMapEager blows up.

```
import rx.Observable;

public class RxJavaNullValueTolerance {

    public static void main(String[] args) {
        Observable.just("just me")
                .flatMap(nextString -> Observable.just(null))
                .subscribe(nextObject -> System.out.println("Got: " + nextObject));
        System.out.println("flatMap is fine with null values");

        Observable.just("just me")
                .concatMap(nextString -> Observable.just(null))
                .subscribe(nextObject -> System.out.println("Got: " + nextObject));
        System.out.println("concatMap is fine with null values");

        Observable.just("just me")
                .concatMapEager(nextString -> Observable.just(null))
                .subscribe(nextObject -> System.out.println("Got: " + nextObject));
        System.out.println("concatMapEager is fine with null values");
    }
}
```

(RxJava 1.1.0)

Output:

```
Got: null
flatMap is fine with null values
Got: null
concatMap is fine with null values
Exception in thread "main" rx.exceptions.OnErrorNotImplementedException: null elements not allowed
    at rx.Observable$27.onError(Observable.java:7923)
    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:159)
    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)
    at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.drain(OperatorEagerConcatMap.java:216)
    at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.onError(OperatorEagerConcatMap.java:302)
    at rx.Observable.unsafeSubscribe(Observable.java:8105)
    at rx.internal.operators.OperatorEagerConcatMap$EagerOuterSubscriber.onNext(OperatorEagerConcatMap.java:144)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)
    at rx.Observable$2.call(Observable.java:162)
    at rx.Observable$2.call(Observable.java:154)
    at rx.Observable.subscribe(Observable.java:8191)
    at rx.Observable.subscribe(Observable.java:8158)
    at rx.Observable.subscribe(Observable.java:7914)
    at RxJavaNullValueTolerance.main(RxJavaNullValueTolerance.java:18)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
Caused by: java.lang.NullPointerException: null elements not allowed
    at rx.internal.util.unsafe.SpscArrayQueue.offer(SpscArrayQueue.java:104)
    at rx.internal.operators.OperatorEagerConcatMap$EagerInnerSubscriber.onNext(OperatorEagerConcatMap.java:294)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)
    at rx.Observable.unsafeSubscribe(Observable.java:8098)
    ... 14 more
```

This is IMO critical, since these three operators are closely related and often replaced thru each other, depending on the concrete "flattening" requirements.,@akarnokd what do you think about this one? Best regards, Peti
 =||= Yes, this is yet another oversight in eager concatMap. I'll post the fix soon.
 =||= @akarnokd , thanks a lot!
 =||= Fixed in #3630 
 =||= ,0
3655,3652,Mapping onError notifications,I often have the use case that I want to map the `Throwable` emitted by an `onError` notification of an `Observable` to something else, for example wrapping or unwrapping it.

Maybe I missed something, but apparently there is no stock solution in RxJava to achieve this. Currently, I use a custom `Operator`. Would it make sense to add such an `Operator` along with its corresponding `Observable.mapError` / `Single.mapError` methods to RxJava directly?,There is the `onErrorReturn` and `onErrorResumeNext` operators that will give you the Throwable which you can then map to a value or another error through `Observable.error()`, i.e.:

``` java
source.onErrorResumeNext(e -> Observable.error(e.getCause()))...
```
 =||= 'materialize()' is useful in this regard too

On Wed, 27 Jan 2016 19:56 David Karnok notifications@github.com wrote:

> There is the onErrorReturn and onErrorResumeNext operators that will give
> you the Throwable which you can then map to a value or another error
> through Observable.error(), i.e.:
> 
> source.onErrorResumeNext(e -> Observable.error(e.getCause()))...
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/3652#issuecomment-175492833.
 =||= Ah yeah, `onErrorResumeNext` is a bit more verbose, but does the trick, thanks! On the other hand, there's no `onErrorResumeNext` for `Single`, only `onErrorReturn`, which cannot be used for the described use case.

Would it then perhaps make sense to add an implementation of `onErrorResumeNext` to `Single`, too?
 =||= I'll add required operators for `Single`, first one is #3655, next one later.

@twz123 looks like your issue is now resolved? If so — please close it :)
 =||= Cool! `onErrorResumeNext(Func1<Throwable, Single>)` would be the thing I need. I'll close this and wait for the PR ;) Thanks a lot!
 =||= See #3766 for second part...
 =||= ,0
3658,3657,Sample operator: last item before termination is dropped after sampling,Hi. Recently I found that `sample` operator drops last value before `onCompleted` event. This is behaviour is valid according to these discussions https://github.com/ReactiveX/RxJava/pull/566 and https://github.com/ReactiveX/RxJava/pull/571 and this [test](https://github.com/ReactiveX/RxJava/blob/1.x/src/test/java/rx/internal/operators/OperatorSampleTest.java#L190). It originated in Rx.NET and still exists in RxJava to be consistent across all implementations as far as I understood.

But, marble diagram in documentation shows otherwise: item 5 is emitted before termination and sampled by sampler.
![sample_marble](https://cloud.githubusercontent.com/assets/1917615/12701532/b435ef44-c846-11e5-841f-92eb8d4c4418.png)

This behaviour is odd and unexpectable. I stumbled across it trying to resolve backpressure issue with observables where last emitted item is the most important.

So, my question is whether it can be changed? I prepared [a commit](https://github.com/kboyarshinov/RxJava/commit/29ad810a7d134afa0b43703fcd162e1cfee006de) with fixes and corresponding tests. 
Or at least marble diagram should be changed to showcase this behaviour and it would be good to have a note about it in documentation.

Thank you.,What about when the source completes and the sampler doesn't?
 =||= @akarnokd it would emit the last item from completed source and nothing after that, no?
 =||= Right, the diff tricked me. I expected 3 calls to emit, 1 in sampler's onNext, 1 in sampler's onCompleted and 1 in parent's onCompleted.

Besides, I can see that operator still has some issues with unsubscription and backpressure management.
 =||= Yep, 2 calls is enough: 1 in sampler's onNext and 1 in parent's onCompleted.
 =||= So if the sampler completes, then the value should be dropped just like now?
 =||= It is ok in my usecase. If sampler completes before source completes it means no values are expected before completion. But if source completes before sampler does it should emit last value. 

However, it worth discussing.
 =||= See #3658 that contains other fixes.
 =||= Great! Also `OperatorSampleWithTime` will require fixes too.
 =||= Would you like to submit a PR?
 =||= @akarnokd I would like to. Will submit soon.
 =||= Done https://github.com/ReactiveX/RxJava/pull/3757
 =||= #3757 merged.
 =||= ,0
3661,3660,Add combineLatest overload for Collection,2.x already uses `Iterable`, but that's a very drastic change compared to just `Collection`.

Motivation here is that I'm using set bindings to create observables in a dependency injector and I want to skip the current `new ArrayList<>(sources)` that I have to do on the set.,Can we revisit this once #3507 is merged?
 =||= Yep. That allows exposing `Iterable` as well which is even better.
 =||= :+1: 

Don't you want to add tests for your new `Observable.combineLatest()`? `OnSubscribeCombineLatest.java` is internal, will be great to cover public API as well for possible changes in future implementation and to test operator from user's point of view.
 =||= The tests were modified to use it.

On Mon, Feb 1, 2016 at 10:27 AM Artem Zinnatullin notifications@github.com
wrote:

> [image: :+1:]
> 
> Don't you want to add tests for your new Observable.combineLatest()?
> OnSubscribeCombineLatest.java is internal, will be great to cover public
> API as well for possible changes in future implementation and to test
> operator from user's point of view.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/pull/3660#issuecomment-178019743.
 =||= Tests for `OnSubscribeCombineLatest` were modified, but I'm talking about tests for `Observable.combineLatest(Collection, FuncN)`.
 =||= They use that API.
 =||= ,0
3670,366,Operator: throttleWithTimeout,Another take on `throttle` … I believe this matches Rx.Net behavior.

This will wait until timeout value has passed without any further values before emitting the received value.,This example will throttle by waiting until `timeout` value has passed without any other `onNext` calls before emitting. If anything else is emitted it will throw away the previous value and restart the timer.

This will not emit anything if events keep firing shorter than the timeout. 

``` java
        PublishSubject<Integer> o = PublishSubject.create();
        o.throttleWithTimeout(500, TimeUnit.MILLISECONDS, s).subscribe(observer);

        // send events with simulated time increments
        s.advanceTimeTo(0, TimeUnit.MILLISECONDS);
        o.onNext(1); // skip
        o.onNext(2); // deliver
        s.advanceTimeTo(501, TimeUnit.MILLISECONDS);
        o.onNext(3); // skip
        s.advanceTimeTo(600, TimeUnit.MILLISECONDS);
        o.onNext(4); // skip
        s.advanceTimeTo(700, TimeUnit.MILLISECONDS);
        o.onNext(5); // skip
        o.onNext(6); // deliver at 1300 after 500ms has passed since onNext(5)
        s.advanceTimeTo(1300, TimeUnit.MILLISECONDS);
        o.onNext(7); // deliver
        s.advanceTimeTo(1800, TimeUnit.MILLISECONDS);
        o.onCompleted();
```

Compare with https://github.com/Netflix/RxJava/pull/365
 =||= Please review this behavior and let me know if it is accurate and if the name is explanatory.
 =||= [RxJava-pull-requests #259](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/259/) SUCCESS
This pull request looks good
 =||= `throttleLast` and `throttleWithTimeout` both have the same javadoc, that's confusing...
 =||= that was fast :D
 =||= Javadoc:

> Throttles by dropping all values that are followed by newer values before the timeout value expires. The timer reset on each `onNext` call.
> NOTE: If the timeout is set higher than the rate of traffic then this will drop all data.
 =||= I have submitted 3 separate pull requests with different variants of `throttle`. I would appreciate feedback on them:
- is the name and javadoc descriptive?
- does the throttling strategy make sense?

Variants are:
- throttleWithTimeout: https://github.com/Netflix/RxJava/pull/366 
- throttleLast: https://github.com/Netflix/RxJava/pull/365 
- throttleFirst: https://github.com/Netflix/RxJava/pull/367 
 =||= -    throttleWithTimeout: the really interesting one, not easily implemented using other operators, corresponds to the C# version
-    throttleLast: easily obtained combining `window`, `flatMap`, and `takeLast`
-    throttleFirst: easily obtained combining `window`, `flatMap`, and `takeFirst`

Is this correct?
 =||= Yes.
 =||= ,0
3681,3673,publish(Func1) may leave operators hang,The following unit test fails because the sequence doesn't complete:

``` java
    public void publishConcat() {
        TestSubscriber<Integer> ts = TestSubscriber.create();

        Observable.range(1, 3)
        .publish(o -> o.take(5).concatWith(o.takeLast(5)))
        .subscribe(ts);

        ts.assertValues(1, 2, 3);
        ts.assertNoErrors();
        ts.assertCompleted();
    }
```

 The problem lies in operator `publish()`. When a published source completes, the operator switches back to a ready state where more subscribers can be subscribed to it and they all receive values from the upstream on the next `connect()`. Otherwise, it wouldn't be possible to observe the sequence again from the beginning by more than one subscriber.

In the test, the source is sort and by the time take(5) completes and makes `concat` subscribe to `o`, the published source, the underlying OperatorPublish is already in the ready state and awaits another connect, which will never arrive, thus leaving the second takeLast hang forever.

This anomaly is there since the rewrite of `publish()` to support backpressure, namely when it doubles as a multicast source. Previously, a PublishSubject was the mediator between the upstream and the use places in the lambda. PublishSubject, when completed will complete any latecommer subscriber such as the one by `takeLast()` thus the unit test passes.

The solution would be to write a request-coordinating internal PublishSubject variant and dispatch upstream values over it in the multicast scenario.

(Note that unbounded `replay` has no such problem because it stays in the completed state until the next `connect()` call, thus latecommers still receive the orignal sequence. Because it buffers all values, there is no penalty for latecommers after a new `connect()` call.),Closing via #3681
 =||= ,0
3681,3674,concat not subscribing to the next source if requested is at 0,The following test fails because the sequence misses the last value of the source:

``` java
    @Test
    public void publishConcatBackpressure() {
        TestSubscriber<Integer> ts = TestSubscriber.create(5);

        Observable.range(1, 6)
        .publish(o -> Observable.concat(o.take(5), o.takeLast(5)))
        .subscribe(ts);

        ts.requestMore(1);

        ts.assertValues(1, 2, 3, 4, 5, 6);
        ts.assertNoErrors();
        ts.assertCompleted();
    }
```

The operator `publish()` has the property that if all subscribers unsubscribe but the upstream hasn't completed yet, it "slowly" consumes the upstream until a subscriber shows up (at which case it consumes the upstream at the rate of the slowest subscriber again). This may be a discussable property (i.e., why not "pause" until more interesting parties show up), but when it is combined with `concat`, unexpected data loss may happen.

`concat` seems to be implemented in a way that if a source completes on a request boundary, that is downstream's requested count is zero, it doesn't subscribe to the next immediately but only when the downstream requests more. This might be a residue from a case where the next source ignores backpressure (`just`?) and would flood the downstream that didn't request anything yet. However, such sources would ignore any request amount anyway so this behavior might be unnecessary.

In the test above, this is simulated by an initial request of 5. After the `subscribe` returns, however, the `publish()` already consumed the rest of the source so the `requestMore(1)` making the `concat` subscribe to the second part, there is no value available anymore. (Besides, it won't complete either, see #3673 .)

I'm not sure if these two behaviors are bugs or just unexpected but legal outcomes, so my question is what should we do about them. I believe, tests exist that verify both `concat` and `publish()` for their current behavior.

The fix to `publish()` would be to remove the `n == 0` case in its drain loop, making it pause when nobody is interested; and the fix to `concat` would be a different completion-subscription trampolining that subscribes immediately to the next but doesn't request anything (or zero). 

Both can individually ensure the continuity of values in the example above.

Thoughts?,Might want to @ mention people to get this on their radar
 =||= It makes sense to pause the publish operator when no one is subscribed, and now `concat` have to  subscribe immediately to the next source without requesting any data (until the subscriber does).
 =||= See #3681 that solves this issue without changing `concat` whose behavior is somewhat expected.
 =||= Closing via #3681
 =||= ,0
3682,3002,ObserveOn: Unsubscribe of RecursiveScheduler,Need to explore the unsubscribe of `recursiveScheduler`: https://github.com/ReactiveX/RxJava/blob/34dce48b4d591a2c574839b4527cbc30cb69e5a2/src/main/java/rx/internal/operators/OperatorObserveOn.java#L122

It seems to wrap with `child.add(scheduledUnsubscribe)` and then defeat that with `child.add(recursiveScheduler)`.,Yes, looks odd. I can't really remember why the unsubscription of the worker had to be scheduled. Maybe it had something to do with pitfall no. 2: unsubscribing the downstream: something around subscribe and `SafeSubscriber` doing this and cutting off the last few events from the wrapped `Subscriber`.
 =||= Might be another problem here that the call to `child.setProducer` is made before adding all the subscriptions. I might test with #2997.
 =||= > why the unsubscription of the worker had to be scheduled

Was it was because we could end up not emitting an `onError` that was scheduled but then dropped because the `worker` got unsubscribed?
 =||= I think @akarnokd is right, that `SafeSubscriber` reports `onCompleted` to its wrapped subscriber then unsubscribes which if `child.add(recursiveScheduler)` is present can cut short the schedule in `OperatorObserveOn` so that it doesn't emit its stuff. 

Re `onError` getting dropped this is still a possiblity but still consistent with the Observable contract (?). All the scheduled polls of the queue do check for error first so that once a scheduled task is run the error can shortcut the queue. Perhaps we can do something to aid this scenario without stuffing up the `onComplete` case.
 =||= I've probably got my last comment backwards. I was thinking that SafeSubscriber was upstream of observeOn but should be downstream so wouldn't have the effect I stated.
 =||= `SafeSubscriber` came into play earlier when the operators used `subscribe()` to attach to each other instead of `unsafeSubscribe()`.
 =||= Closing via #3682.
 =||= ,0
3682,3542,Scheduling should serialize notifications.,Currently, `onError` cuts ahead of `onNext` calls when you schedule work, but does not (cannot) when you use a single thread.

```
Observable.create(o -> {
    o.onNext(1);
    o.onError(new NotImplementedException());
})
.observeOn(Schedulers.newThread())
.subscribe(i -> System.out.println(i), 
        e -> System.out.println("error:" + e));
```

This yields `error` instead of `1, error` as expected. Other implementations of Rx like Rx.Net do serialize notifications. This 'cut ahead' behavior is actually described as a [common pitfall](https://realm.io/news/gotocph-mattias-kappler-reactive-architecture-android/) in RxJava by some.,RxJava 2.0 will allow you to customize this behavior in many operators, including `observeOn`, `delay`, `combineLatest`, `zip`, `groupBy`, `onBackpressureBuffer`, `skipLast` and `takeLast`.

I was planning to post a PR targeting `observeOn` to remove some unnecessary code (#3002) and may well do this as well.
 =||= This is really scary nondeterministic behavior, and against Rx contract. I hope the (future) default will be to not lose data. If anything it might be an appropriate setting on the subscriber.
 =||= The `observeOn` operator received an overload that takes a `delayError` parameter you can set.

Closing via #3682.
 =||= ,0
3684,1511,Missing javadoc comments for Producer.java,The Producer interface needs an interface description in the javadocs.

I've flagged areas that need help in the javadocs with "@warn" tags. That tag is not part of the javadoc standard, so it triggers a javadoc compilation warning. Please remove those tags from any areas that you fix.,Closing via #3684
 =||= ,0
3688,3687,NullPointerException on OperatorZip,I get crashreports caused by a NullPointerException in OperatorZip's tick() method. You find the stacktrace and my code, causing the problem below.

The responsible line in tick() method is

``` java
RxRingBuffer buffer = ((InnerSubscriber) observers[i]).items;
```

where observers[i] seems to be null. 

The app crashes only rarely on one device, which I don't have acces to (Samsung S3, Android 4.3).  The reason seems to be, that  the property `missedProducer` in `ProducerArbiter` must be set, which is never the case on my devices.

We're not in production yet, so I can not tell how many other devices will show this error. 

Stacktrace:

```
0 java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.
1   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)
2   at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:98)
3   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)
4   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)
5   at java.lang.Thread.run(Thread.java:841)
6 Caused by: java.lang.NullPointerException
7   at rx.internal.operators.OperatorZip$Zip.tick(OperatorZip.java:237)
8   at rx.internal.operators.OperatorZip$ZipProducer.request(OperatorZip.java:175)
9   at rx.internal.producers.ProducerArbiter.emitLoop(ProducerArbiter.java:181)
10  at rx.internal.producers.ProducerArbiter.request(ProducerArbiter.java:69)
11  at rx.internal.operators.OperatorConcat$ConcatSubscriber.requestFromChild(OperatorConcat.java:118)
12  at rx.internal.operators.OperatorConcat$ConcatSubscriber.access$100(OperatorConcat.java:79)
13  at rx.internal.operators.OperatorConcat$ConcatProducer.request(OperatorConcat.java:74)
14  at rx.internal.producers.ProducerArbiter.request(ProducerArbiter.java:66)
15  at rx.internal.operators.OperatorSubscribeOn$1$1$1$1$1.call(OperatorSubscribeOn.java:94)
16  at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
17  ... 4 more
```

This is the code causing the problem: Get `Observable<List<ContainerEntity>>`, map each container entity to my actual container model. flatmap is used to split my list into single items.

``` java
getContainerEntities()
.flatMap(containerEntities ->
            Observable.from(containerEntities))
    .concatMap(containerEntity ->
            mDashboardMapper.mapContainerEntity(containerEntity))
    .onErrorResumeNext(throwable -> {
        Log.e(TAG, throwable);
        return Observable.empty();
    });
```,What RxJava version are you using?
 =||= I'm using version 1.1.0
 =||= Could be a missing barrier on line 207 or somewhere else, or a bug in that particular runtime. I'll reorganize things in zip so this doesn't happen.
 =||= Great. Thanks a lot!
 =||= See #3688
 =||= Closing via #3688.
 =||= ,0
3689,3685,1.x: onErrorResumeNext(Func1) should not call plugin handler there,When the operator switches to the other, that counts as a handled error. 

See also #3347.,There are similar patterns in the other `onError*` operators, namely `OperatorOnErrorResumeNextViaObservable` and `OperatorOnErrorReturn` - do those need changing as well?
 =||= Yes, I'll update this PR.
 =||= Updated, although all of these classes have backpressure bugs in them.
 =||= Replaced by #3689
 =||= ,0
3694,3618,Improve README.MD by adding links to the source files of @Beta and @Experimental,There are no links to the annotations mentioned above in the documentation and this makes their source unaccessible a bit.,Closing via #3623
 =||= ,0
3696,359,Varargs cause compiler warnings,I'm trying to use the `concat` operator, but I can't use it without getting a compiler warning. Here's my code:

```
Observable<HorrorMovie> horrorMoviesWithException() {
    Observable<HorrorMovie> movies = Observable.from(new HorrorMovie());
    Observable<HorrorMovie> ex = Observable.error(new Exception("test")); 
    return Observable.concat(movies, ex); // (WARNING)
}
```

I get the warning "Type safety: A generic array of Observable<CovarianceTest.HorrorMovie> is created for a varargs parameter".

This problem was discussed on [stackoverflow](http://stackoverflow.com/questions/1445233/is-it-possible-to-solve-the-a-generic-array-of-t-is-created-for-a-varargs-param) and this [bug report](http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6227971) explains why it's not going to be fixed.,The same problem also occurs with `merge`, `mergeDelayError`, and if arguments with generic type are passed to `from` and `startWith`, they are also affected.
 =||= Unless someone shows me how to get rid of this warning without using `@SuppressWarnings("unchecked")`, I would suggest that we remove the varargs methods and add instead
-    an overloaded method for each arity
-    a method taking an Iterable (will be used by the Scala adaptor)
 =||= Like the zip operator?

Sent from my iPhone

On Sep 9, 2013, at 1:50 AM, samuelgruetter notifications@github.com wrote:

> Unless someone shows me how to get rid of this warning without using @SuppressWarnings("unchecked"), I would suggest that we remove the varargs methods and add instead
> 
> an overloaded method for each arity
> a method taking an Iterable (will be used by the Scala adaptor)
> —
> Reply to this email directly or view it on GitHub.
 =||= yes
 =||= That issue with varargs is definitely one of the weaknesses of generics. 

How about if we had overloads for up to 9 arities, and then on that one have a 10th vararg for scenarios were people truly do want/need more? That way it would only affect someone using beyond 9 args?
 =||= I don't quite get what you mean by "a 10th vararg for scenarios..." but I'd also be fine with overloads for up to 9 arguments, plus another overload which takes only 1 argument of type `Collection<Observable<T>>` or `Iterable<Observable<T>>`, so if people want more than 9 arguments, they have to construct a list containing the arguments and pass this list to `concat`.
 =||= I meant something like this ...

``` java
concat(T t1, T t2)
... etc ...
concat(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8)
concat(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9)
concat(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9, T... rest)
```

I will start refactoring vararg method signature later today or tonight (US Pacific time) unless someone else is already doing it. If one of you already are tackling this please let me know here so we don't replicate effort.
 =||= Closing as I have removed all varargs from Observable.
 =||= The `@SafeVarargs` annotation allows us to solve this. Trying to figure out if we can leverage this Java 7 feature without breaking Android support (which is obviously more important).
 =||= ,0
3701,3700,Make Observable.doOnCompleted name match Completable.doOnComplete in 1.x,`Observable` has a `doOnCompleted` method (past tense), and `Completable` has `doOnComplete` (present tense). The 2.x branch changes `Observable`'s method to be present tense. The 1.x branch can add alias the past tense method in `Observable` and deprecate it.

I'm happy to make the change if this is approved.,Sure.
 =||= ,0
3712,3708,Single and Completable takeUntil(),In reading the original PR for `Single`, I saw Ben was OK with adding a `takeUntil(Single/Observable)` operator for `Single` later. I was wondering if this was still the plan, and if you would be open to contributions on this front. Same with `Completable`.

One caveat that I've thought of is that there's a potentially conflicting contact with `Single` and `takeUntil()` in the sense that `takeUntil()` calls `onCompleted()` in observables, but `Single`s will actually go to `onError()` if `onCompleted()` is called before any events are emitted (and by extension `onSuccess()`). Not sure what the clear path would be, but it seems like `Single`s would have to only unsubscribe and not propagate any notifications, differing from `Observable`s and likely `Completable`s in this regard.,`Single.takeUntil` still has to emit an onSuccess or onError; you need to emit a `NoSuchElementException` from the other `Single.onSuccess`. Unsubscribing the main and not emitting anything is bad because it keeps the subscribers hanging. I don't think it is worth it.

`Completable.takeUntil` is just `completable.ambWith(other)`.
 =||= The completable makes sense. For `Single`, do you think there's a feasible way to do a sort of takeUntil-like behavior where it completes/unsubscribes on the emission of another observable/single? 

I'm working on some lifecycle handling for android, and a use case that's worked well in the past is to emit lifecycle events via behaviorsubject and then just `takeUntil(lifecycleSubject.filter(e -> e == DETACH))`. The idea is you want it to unsubscribe when the detach happens, and perhaps out of convenience we've always been using the fact that takeUntil would call onComplete and eventually cause it to unsubscribe. 
 =||= It seems like forcing an onSuccess or onError defeats the purpose of having a subscription that supports `unsubscribe` prior to that.
 =||= The best you can do with `takeUntil` is to signal an error, like `CancellationException` similar to how `Future` does.
 =||= I see. Would that be something you guys would be open to as PR? Or at least consider making `Single#lift()` public since it's still experimental? Otherwise it doesn't seem like it's possible in the current API. Could catch existing `NoSuchElementException`s but there'd be no way to know if it was due to completion or cancellation. 

Alternatively, would there be a simple way to potentially swallow that error upstream rather than force the subscriber to handle it?
 =||= We are open for PRs.
 =||= Closing via #3712
 =||= Actually this just reminded me, would we want `Single` and `Observable` overloads for `Completable`, or just use `amb` and call `toCompletable` on those when passing them in?
 =||= Maybe, submit a PR and let's see the opinions.
 =||= Will do, though likely not until this weekend or next week
 =||= ,0
3714,3710,concatMapEager and maxConcurrent,How should I limit the maximum number of concurrently subscribed observables ?

I think a parameter like the one in flatMap (maxConcurrent) could be very useful.
concatMapEage currently has an optional parameter, capacityHint.

I think this is not very useful, I expected to find something like maxConcurrent
This operator might be confusing for some people, similar with #3498,The operator was designed to be eager on the input side and bounded on the mapped inner Observables.

I agree that adding a parameter would be confusing to `concatMapEager` but you can name the maxConcurrent+capacityHint version like `orderedMerge` or something like it.

Would you like to post a PR for this?
 =||= Are you proposing to rename`concatMapEager(Func1 mapper, int capacityHint)` into `orderedMerge` ?

I am proposing to add extra functionality to manage the number of concurrent observables and change the docs/rename some operators to make the functionality more obvious.

I can try to provide a PR.
 =||= Don't rename `concatMapEager`, just add an overload `concatMapEager(Func1 mapper, int capacityHint, int maxConcurrency)` and modify the `OperatorConcatMapEager` to support the maxConcurrency mode.
 =||= I am not sure how to write a proper test case for this change, I tested various scenarios manually and ran the existing test case
 =||= Add a `doOnRequested` before the operator and capture the long values in a List. Then compare it against the expected pattern, i.e., `5, 1, 1, 1, 1, 1, 1`.
 =||= Closing via #3714
 =||= ,0
3722,3711,flatMapIterable with maxConcurrent,As far as I saw flatMapIterable doesn't have maxConcurrent parameter and thus doesn't offer a way to apply backpressure. In order to align it with other flatMap would be good to add an overload with maxConcurrent.

What do you think?,PR is welcome.
 =||= Although you stated here that this was useless https://github.com/ReactiveX/RxJava/pull/2627 . Is it really the case?
I believe with current implementation this would be usefull to control backpressure. 
 =||= I was wrong back then.
 =||= Closing via #3722
 =||= ,0
3733,372,Zip/Map/Select with index,I'm looking for a function corresponding to this Rx C# function:

http://msdn.microsoft.com/en-us/library/hh244311(v=vs.103).aspx

Do we already have this in RxJava? I'm asking this because I want to implement the `zipWithIndex` function in the Scala adaptor.,No we do not have that yet. Your naming convention will be what we need to use so we don't overload methods with functions of different arities as that causes issues.

So `mapWithIndex` and `zipWithIndex` make sense.
 =||= I'd be happy with `mapWithIndex` and `zipWithIndex`.
 =||= I don't think we have the arity problem with `map` (`mapWithIndex`), or do we? I think it should be specific to `zip`. So we could name it `map` instead of `mapWithIndex` if we wanted to. But probably we should be consistent and still call it `mapWithIndex`.
 =||= I take that back. I just experimented with this and noticed that at least Clojure does indeed have a problem with that. So `mapWithIndex` it is.
 =||= ,0
3741,3740,Single#doOnSubscribe is missing,just noticed that we have a `Single.doOnUnsubscribe()` but not `Single.doOnSubscribe()` in RxJava 1.1.1,Closing via #3741
 =||= ,0
3752,3732,Request: Single.using,To match `Observable.using`

```
public static <T, Resource> Single<T> using(
        Func0<Resource> resourceFactory,
        Func1<? super Resource, ? extends Single<? extends T>> singleFactory,
        Action1<? super Resource> disposeAction)
```

and

```
public static <T, Resource> Single<T> using(
        Func0<Resource> resourceFactory,
        Func1<? super Resource, ? extends Single<? extends T>> singleFactory,
        Action1<? super Resource> disposeAction, boolean disposeEagerly)
```,I'll do this.
 =||= See #3752
 =||= PR was merged and released as part of v1.1.2, this issue can be closed!
 =||= Closing via #3752.
 =||= ,0
3754,1653,Optimisations with Observable.empty(),I notice that calling `observable.concat(Observable.empty())` invokes back-pressure. I'd find it useful if when I used `Observable.empty()` that optimisations came into play such as ensuring that `observable.concat(Observable.empty())` simply returned `observable`.

To achieve this I'd make a private constant `EMPTY = from(new ArrayList())`  in `Observable` so that calling `Observable.empty()` always returned this object cast into the appropriate generic type. Then I'd use a simple object reference equality test to determine if an optimisation could be made.

Do you think this proposal has legs? If so, I'll knock up a PR. I would seek to optimise more than just the `concat` operator , it would include `merge` and possibly others which I can think about if the time comes.,In this vein might be good to get `from(List)` return EMPTY whenever the list is empty. That would enable the optimisations more often.
 =||= This is inaccurate "I notice that calling observable.concat(Observable.empty()) invokes back-pressure". It was actually a combination of operators including concat. Regardless I think the optimisations would be useful.
 =||= I stumbled upon your report while also looking at `Observable.empty()`. I wonder why it instantiates a new `ArrayList` every single time instead of using `Collections.emptyList()`? It's the canonical way to represent the list "null object" in Java and it's more memory efficient too, since it doesn't allocate an empty array of capacity 16 that will never end up having items.
 =||= No idea why we aren't using `Collections.emptyList()` ... we should be. Just a simple oversight by my or someone else who has contributed. 
 =||= Thanks @mttkay, that looks good. @benjchristensen what about more optimisations that would
- collapse the call stack
- avoid unnecessary invocations of backpressure slow path

For example, `concat` is now:

```
public final static <T> Observable<T> concat(Observable<? extends T> t1, Observable<? extends T> t2) {
    return concat(just(t1, t2));
}
```

but could be:

```
public final static <T> Observable<T> concat(Observable<? extends T> t1, Observable<? extends T> t2) {
    if (t1 == EMPTY) 
        return t2;
    else if (t2 == EMPTY)
        return t1;
    else 
        return concat(just(t1, t2));
}
```
 =||= @davidmoten `merge` can benefit from it, too.
 =||= @davidmoten what about adding the empty check here, too: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorConcat.java#L126

```
        @Override
        public void onNext(Observable<? extends T> t) {
            if(t==EMPTY) return; // check EMPTY
            queue.add(nl.next(t));
            if (WIP_UPDATER.getAndIncrement(this) == 0) {
                subscribeNext();
            }
        }
```
 =||= there are a LOT of operators that can benefit from this. I would hazard a guess that most can use this optimisation at the high level within the `Observable` class and yes good point @zsxwing we could dig into operators for more optimisations. I'll proceed with the PR if @benjchristensen gives it the tick.
 =||= If you want to submit a PR with this work done I'll accept it. If we can use `Collections.emptyList()` somewhere that we are currently allocating that will always be better.
 =||= Put on 1.0.x as this is not a blocker for 1.0, but whenever you submit the PR I'll do it.
 =||= I'm starting work on this PR now and I'd like to get the ok on some detail.

I'd propose adding this to `Observable` just after the init of the hook:

``` java
private static final Observable<?> EMPTY = from(Collections.emptyList());
```

`Observable.empty()` would be changed to:

``` java
    @SuppressWarnings("unchecked")
    public final static <T> Observable<T> empty() {
        return (Observable<T>) EMPTY;
    }
```

As an example of how it would be used the static method `Observable.merge` would be changed to:

``` java
    @SuppressWarnings("unchecked")
    public final static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? extends T> t2) {
        if (t1 == EMPTY) 
            return (Observable<T>) t2;
        else if (t2 == EMPTY)
            return (Observable<T>) t1;
        else 
            return merge(from(Arrays.asList(t1, t2)));
    }
```

Note that I've confirmed in the debugger that this optimisation avoids triggering backpressure if say `o.mergeWith(Observable.empty())` is called. ~~I'll get a unit test going for this as well.~~

A large number of methods will use this optimisation so I'd like to get my exact approach approved before submitting.

The final thing to note is that optimisations outside of the `Observable` class would do a reference equality check against `Observable.empty()`. So in the example from `OperatorConcat` by @zsxwing above:

``` java
        @Override
        public void onNext(Observable<? extends T> t) {
            if(t==Observable.empty()) return; // check EMPTY
            queue.add(nl.next(t));
            if (WIP_UPDATER.getAndIncrement(this) == 0) {
                subscribeNext();
            }
        }
```

I'd like to limit the scope of my PR to optimisations in Observable.java only. Optimisations in Operators would wait for this base PR to be accepted.

How does that sound?
 =||= Why do you have so many `empty()` to merge?

Edit: At least I looked at the implementation and improved it in #2622.
 =||= Ta for improvement. The reason I have `empty()`s to merge is that this is a common pattern for me:

``` java
o.flatMap(t -> {
   if (cond(t)) 
       return someObservable(t);
  else 
       return Observable.empty(); 
  });
```

I'm experimenting now with substituting the special case where the flatMap function returns either 0 or 1 by doing 

``` java
o.map(toOptional).filter(isPresent).map(toValue);
```

I'd hope it would be faster but not sure.
 =||= This PR is quite old. Can you create a reasonable benchmark to see how concatMap and flatMap behaves? In addition, I suggest we tackle this after both #2928 and #2960 are merged.
 =||= Yep I'll do benchmarks after those PRs have been merged.
 =||= This may be part of the operator-fusion optimizations in 2.x but I don't see this in 1.x due to non-technical reasons.
 =||= For a start: here is the baseline perf: #3754. I'm going to merge it so subsequent PRs can be benchmarked with it.
 =||= See #3759 for the optimized `concat`s.
 =||= See #3761 for the optimized `merge`s
 =||= Optimizations have been added and released with 1.1.4. Closing the issue. If you have more ideas where it's worth adding extra checks for empty, don't hesitate to open a new issue.
 =||= ,0
3756,3616,Join operator incorrect sequence,I found a weird bug where join operator is emitting incorrect sequence in **some** Android devices. Here is the block of code that I am using:

```
Observable.just("A", "B")
        .join(Observable.just(1),
                new Func1<String, Observable<Object>>() {
                    @Override
                    public Observable<Object> call(String s) {
                        return Observable.never();
                    }
                }, new Func1<Integer, Observable<Object>>() {
                    @Override
                    public Observable<Object> call(Integer integer) {
                        return Observable.never();
                    }
                }, new Func2<String, Integer, String>() {
                    @Override
                    public String call(String s, Integer integer) {
                        return s + " " + integer;
                    }
                })
        .subscribe(new Action1<String>() {
            @Override
            public void call(String s) {
                System.out.println(s);
            }
        });
```

Expected sequence:

```
A1
B1
```

Incorrect sequence:

```
B1
A1
```

After digging in `rx.internal.operators.OnSubscribeJoin` class. I found this:

```
final class ResultSink {
        final CompositeSubscription group;
        final Subscriber<? super R> subscriber;
        final Object guard = new Object();
        /** Guarded by guard. */
        boolean leftDone;
        /** Guarded by guard. */
        int leftId;
        /** Guarded by guard. */
        final Map<Integer, TLeft> leftMap;
        /** Guarded by guard. */
        boolean rightDone;
        /** Guarded by guard. */
        int rightId;
        /** Guarded by guard. */
        final Map<Integer, TRight> rightMap;

        public ResultSink(Subscriber<? super R> subscriber) {
            this.subscriber = subscriber;
            this.group = new CompositeSubscription();
            this.leftMap = new HashMap<Integer, TLeft>();
            this.rightMap = new HashMap<Integer, TRight>();
        }
        ....
}
```

I suspect the cause is because it's using `HashMap` to store left and right emitted values. Causing incorrect order in the values since `HashMap` cannot guarantee the order of the entries. It should uses `LinkedHashMap` to maintain the order of the entries.
Any thoughts? Or did I miss something here? Thanks!,There was never a guaranteed order and even .Net has  no guarantees, not to mention the two platform produce in different order from the beginning
 =||= By looking at the marble diagram, I thought that the order is guaranteed. I think it should be stated in the Javadoc to avoid confusion for anyone else. Anyway, thanks for the heads up @akarnokd!
 =||= See #3756
 =||= Great! Thanks @akarnokd :+1: 
 =||= Closing via #3756.
 =||= ,0
3766,3440,Single.onErrorResumeNext,Observable has a onErrorResumeNext to continue with a new Observable if onError is called. I'd like something similar for Single, so:

``` java
Single<T> onErrorResumeNext(Single<? extends T> resumeSingle)

Single<T> onErrorResumeNext(Func1<? super Throwable, ? extends Single<? extends T>> resumeFunction)
```

Single already has onErrorReturn, it makes sense to have onErrorResumeNext as well.,related: https://groups.google.com/forum/#!topic/rxjava/vCMxB6CY88w
 =||= I'll work on this.
 =||= @akarnokd I can do it in 2 ways: 
1. Convert `Single` to `Observable` and `lift` already implemented and tested `OperatorOnErrorResumeNextViaFunction` and `OperatorOnErrorResumeNextViaObservable`.
2. Re-implement these operators for `Single`, it may give some performance boost, but adds two classes to the library.

I guess you'll vote for 2nd way, but I think it worth to ask :)
 =||= Frankly, I'm not satisfied with 1.x Single and how it tries to reuse Observable components; it leads to wrappers and un-wrappers and so on even for the trivial operators. If they were `retryWhen` then I'd say convert back and forth like I do with 2.x. So yes, I vote for option 2.
 =||= ok, no problem :)
 =||= ,0
3766,3731,Request: Single.onErrorResumeNext(Func1<? super Throwable, Single<? extends T>> resumeFunction),To match `Observable`'s.

```
public Single<V> onErrorResumeNext(Func1<? super Throwable, Single<? extends T>> resumeFunction);
```,We are also interested in this feature. Currently we are in the process of switching `Observable` to `Single` where it makes sense. Not having this feature is blocking us. Since we would use this internally and not expose the details to users, does anybody know a workaround for accessing the `Throwable`?
 =||= Since we are just interested in mapping the emitted exception to something else, here is something that just occurred to me. It's ugly, but it seems that it works as a temporary workaround in our use case. It may be useful for others too, so here it is:

``` java
single.onErrorReturn(throwable -> {
    throw mapException(throwable);
});
```

Where `mapException` maps the `Throwable` to one of our exceptions.
 =||= Isn't this a dupe of #3440 ?
 =||= Yes, you're right. It's a duplicate.
 =||= ,0
3766,3472,Flatmap Single into Observable and ignore errors,I have UI observable which should work as long as my UI lives. When my UI emits I create a network request which could be an Observable or a Single. A Single fits best for a network call.

``` java
RxView.clicks(myButton)
    .flatMap(v - > networkRequest())
    .subscribe(data -> showSomething(data),
            e -> {
                // should only be called when the RxView.clicks() throws. 
                // should not be called for network errors
            });
```

When using an Observable I would use `onErrorResumeNext` returning `Observable.empty()` to prevent errors coming from the network request going into my UI Observable and calling `onError` because the UI Observable should life forever:

``` java
Observable networkRequest() {
    mApiService.fireActionObservable()
        .onErrorResumeNext(throwable -> {
            // somehow handle error here
            return Observable.empty();
     });
}
```

This, in my opinion, elegant way does not work for Single because no `Single.empty()` exists.

``` java
Single networkRequest() {
    mApiService.fireActionSingle()
        .onErrorResumeNext(throwable -> {
            // somehow handle error here
            return Single.empty(); // <-- does not exist. I have to call success or error :/
     });
}
```

`Single.onErrorResumeNext` is btw only available in 2.x

Converting my `Single` to an `Observable` seems wrong, because the network request is a `Single`!,`Single.empty()` doesn't make sense because `Single` has to emit either an `onSuccess` or an `onError`. The best you can do is to have a `Single.just()` with a normal value that represents emptiness.

Generally, this is why I'm skeptic about `Single` and `Completable` because `Observable` can "emulate" both and the overhead in true async use is negligible.
 =||= My current solution wraps my Singles:

``` java
    public static <T> Observable<T> onErrorResumeNext(final Single<T> single,
            final Observable<? extends T> resumeSequence) {
        return single.toObservable().onErrorResumeNext(resumeSequence);
    }

    public static <T> Observable<T> onErrorResumeNext(final Single<T> single,
            final Func1<Throwable, ? extends Observable<? extends T>> resumeFunction) {
        return single.toObservable().onErrorResumeNext(resumeFunction);
    }
```

``` java
RxView.clicks(myButton)
    .flatMap(v - > onErrorResumeNext(networkRequest(),
            throwable -> {
            // somehow handle error here
            return Observable.empty();
     }))
    .subscribe(data -> showSomething(data),
            e -> {
                // only called when the RxView.clicks() throws
            });
```

@benjchristensen what happened to the [initial idea](https://github.com/ReactiveX/RxJava/issues/1594#issuecomment-101300655) of heaving a `Single` with 3 final states?

> A Single will always behave in one of 3 ways:
> 
> 1) respond with an error
> 2) never respond
> 3) respond with a success

I was hoping a `Single` is a `Observable` where I don't have to care about multiple items. Nothing more. Like `Observable#single()` but with zero item support and type safetyness.
 =||= @artem-zinnatullin I'm starting to loose what is implemented where. Do you work on `Single.onErrorResumeNext(Func1)`?
 =||= @akarnokd damn… will submit PR today/tomorrow!
 =||= My solution:
RxView.clicks(myButton)
    .flatMap(v - > networkRequest())
    .compose(exceptionHandling())
    .subscribe(data -> showSomething(data),
            e -> {
                // Now you should remove this lambda as it will never be called.
            });
Final: 
RxView.clicks(myButton)
    .flatMap(v - > networkRequest())
    .compose(exceptionHandling())
    .subscribe(data -> showSomething(data));
exceptionHandling:
   protected  <T> ObservableTransformer<T, T> exceptionHandling() {
        return observable ->
                observable
                        .doOnError(t ->{ /* handle error here */})
                        .retry(); // Ignore error to keep subscription.
    }
 =||= ,0
3777,3751,Confusion when using Backpressure operators,Hey,

We have a use case in which a consumer might not be able to process items fast enough than what is emitted from a source observable. I understood that in this case, a backpressure with either `onBackPressureBuffer()` or `onBackPressureDrop()` might be useful. In case of overflow / drop, we would like to store items to a local storage and try processing them later when the consumer in this case is again able to handle the input rate. Our consumer is actually a remote REST call which might timeout or not be available in which case we retry.

Anyways, I tried alternative ways to address the problem but I can't find a suitable way to solve it. To illustrate my testings, here is some code:

```
package io.reactivex;

import org.junit.Test;
import rx.Observable;
import rx.Subscriber;
import rx.schedulers.Schedulers;

public class BackPressureTest {
    @Test
    public void testOnBackPressureDrop() throws InterruptedException {
        Observable<Integer> emitter = toObservable()
                .subscribeOn(Schedulers.newThread());

        emitter.onBackpressureDrop(i -> System.out.println("Dropped " + i))
                .observeOn(Schedulers.computation())
                .map(this::doWork)
                .doOnNext(i -> System.out.println("Output " + i))
                .toBlocking()
                .subscribe(new SingleItemSubscriber<>());
    }

    @Test
    public void testOnBackPressureBuffer() throws InterruptedException {
        Observable<Integer> emitter = toObservable()
                .subscribeOn(Schedulers.newThread());

        emitter.onBackpressureBuffer(2, () -> System.out.println("Overflow"))
                .observeOn(Schedulers.computation())
                .map(this::doWork)
                .doOnNext(i -> System.out.println("Output " + i))
                .toBlocking()
                .subscribe(i -> System.out.println("Subscriber received " + i));
    }

    private Observable<Integer> toObservable() {
        return Observable.create(subscriber -> {
            for (int i = 0; i < 10; i++) {
                System.out.println("Emitting " + i);

                subscriber.onNext(i);

                try {
                    Thread.sleep(250);
                } catch (InterruptedException e) {
                    subscriber.onError(e);
                }
            }

            subscriber.onCompleted();
        });
    }

    private int doWork(int integer) {
        System.out.println("Consuming " + integer);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return integer;
    }

    private static class SingleItemSubscriber<T> extends Subscriber<T> {
        @Override
        public void onStart() {
            request(1);
        }

        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onNext(T t) {
            System.out.println("Subscriber received " + t);
            request(1);
        }
    }
}
```

In `testOnBackPressureDrop()` I would assume that after the `emitter` has queued some items, it would start dropping them. However, it seems that the backpressure operation subscription gets a receive size of 128 items. 128 items in memory in this case is far too much for us and we would like to control the size of the request items.

In `testOnBackPressureBuffer()` I would assume that the `emitter` would overflow after emitting more than two items into the buffer.

However, in neither of the cases, I don't experience an oveflow or dropped items. Also I realized that when using `onBackPressureBuffer()` it seems that in overflow, the observable emits `onError()`. To me that wouldn't be an option since I want the `emitter` to continue and I wan't to deal with the problem myself.

Could you please instruct me that what we are missing here or are we trying to do something that is not yet even possible, e.g. is the API missing an operator like `onBackPressureBufferAndDrop(int capacity, Action1 onDrop)`?

I wrote my tests based on the documentation in https://github.com/ReactiveX/RxJava/wiki/Backpressure,It seems your source doesn't emit enough values thus the default buffer of 128 elements in `observeOn` can hold all of it without backpressure. The `onBackpressureBuffer(int)` behavior is expected and is there to give room to bursty sources but fail on sustained backpressure to prompt the developer to reevaluate the flow.

There is a [PR](https://github.com/ReactiveX/RxJava/pull/3487) in limbo that tries to address this buffer behavior by allowing dropping, but if you want to queue on disk, you have to write a custom operator.
 =||= I've bumped into the queueing on disk use case a few times but haven't implemented anything. I'll have a look (probably in a couple of weeks).
 =||= I see.

The challenge with the PR above is that currently the overflow function does not supply the item(s) which caused the overflow. It is just a void action (`Action0`). Changing that to e.g. `Action1` would probably break the semantics of the original `onBackPressureBuffer()` API so I guess the naming would need to be reconsidered for a new API if it would accept a `Action1` type function.

Based on @akarnokd's comment, we should not use the buffer backpressure but ideally it seems that the current implementation of `onBackpressureDrop(Action1<? super T> onDrop)` is close what I'm after here but I would need to be able to control the size of the default internal buffer (128 now). We can write a custom operator of course but I was just wondering would this be something other may benefit if part of the `Observable` API? When using the current implementation of drop you have very little control when the dropping starts to happen and in our case we can calculate a value for the buffer based on the characteristics and configuration of the application.

The term "buffer" fooled me a bit in the API docs and I assumed that the capacity controls the size after which the source observable starts to overflow. Would it make sense to clarify that documentation at least and mention that there is an internal buffer which can hold actually more items than what you specify as your overflow buffer? 

Thanks for the quick reply!
 =||= I've hit this a number of times and generally ended up turning most .observeOn() into .onBackpressureBuffer().observeOn(), I guess the ability to control the 128 size buffer as an optional parameter to observeOn would be a nice addition.
 =||= @srvaroa PR welcome.
 =||= ,0
3787,3775,concat can't display all the groupedBy observers on version 1.1.1,Here are the code I‘m using to test：

``` java
        final Observable<GroupedObservable<String, AppInfo>> groupBy = Observable.from(appInfoList)
                .groupBy(appInfo -> {
                    SimpleDateFormat sdf = new SimpleDateFormat("MM/yyyy");
                    String groupedStr = sdf.format(new Date(appInfo.getLastUpdateTime()));
                    return groupedStr;
                });
        Observable.concat(groupBy)
                .subscribe(mSubscriber);
```

and the library is :

```
    compile 'io.reactivex:rxjava:1.1.1'
    compile 'io.reactivex:rxandroid:1.1.0'`
```

 I got this result which apparently is not correct,  I only got three results!:
![device-2016-03-17-151005](https://cloud.githubusercontent.com/assets/10875078/13838994/e1f62658-ec52-11e5-93c7-f3c726af5bc8.png)

but it should be like this as shown on the Rxjava-essential-code.
![image](https://cloud.githubusercontent.com/assets/10875078/13839031/283c1870-ec53-11e5-8da5-57add00c3b35.png)

This problem never occurs on Version 1.1.0.,Strange. This code works for me on 1.1.1:

``` java
public class GroupConcat {
    static final class AppInfo {
        String name;
        LocalDate date;
        @Override
        public String toString() {
            return name + " @ " + date;
        }
    }
    public static void main(String[] args) {
        System.setProperty("rx.ring-buffer.size", "16");

        List<AppInfo> list = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 3; j++) {
                AppInfo ai = new AppInfo();
                ai.name = i + " - " + j;
                ai.date = LocalDate.of(2016, 3, i + 1);
                list.add(ai);
            }
        }

        Observable<GroupedObservable<String, AppInfo>> o = Observable.from(list)
        .groupBy(v -> v.date.format(DateTimeFormatter.ofPattern("MM/yyyy")));

        Observable.concat(o)
        .subscribe(System.out::println);
    }
}
```
 =||= ``` java
public class Concat {
    public static class Student {
        public String classId;
        public String name;

        @Override
        public String toString() {
            return "Student{classId='" + classId + "', name='" + name + "'}";
        }
    }

    public static void main(String[] args) {
        ArrayList<Student> list = new ArrayList<>();
        for (int i = 0; i < 20; i++) {
            Student student = new Student();
            student.classId = String.valueOf(i % 5);
            student.name = String.valueOf(i);
            list.add(student);
        }

        Observable<GroupedObservable<String, Student>> groupBy =
                Observable.from(list)
                          .groupBy(new Func1<Student, String>() {
                              @Override
                              public String call(Student student) {
                                  return student.classId;
                              }
                          });

        Observable.concat(groupBy)
                  .subscribe(new Observer<Student>() {
                      @Override
                      public void onCompleted() {
                          System.out.println("Completed");
                      }

                      @Override
                      public void onError(Throwable e) {
                          System.out.println("Error");
                      }

                      @Override
                      public void onNext(Student student) {
                          System.out.println(student);
                      }
                  });
    }
}
```

in RxJava 1.1.1,console print :

```
Student{classId='0', name='0'}
Student{classId='0', name='5'}
Student{classId='0', name='10'}
Student{classId='0', name='15'}

Process finished with exit code 0
```

in RxJava 1.1.0,console print :

```
Student{classId='0', name='0'}
Student{classId='0', name='5'}
Student{classId='0', name='10'}
Student{classId='0', name='15'}
Student{classId='1', name='1'}
Student{classId='1', name='6'}
Student{classId='1', name='11'}
Student{classId='1', name='16'}
Student{classId='2', name='2'}
Student{classId='2', name='7'}
Student{classId='2', name='12'}
Student{classId='2', name='17'}
Student{classId='3', name='3'}
Student{classId='3', name='8'}
Student{classId='3', name='13'}
Student{classId='3', name='18'}
Student{classId='4', name='4'}
Student{classId='4', name='9'}
Student{classId='4', name='14'}
Student{classId='4', name='19'}
Completed

Process finished with exit code 0
```

1.1.1 only print first group, and not call `onCompleted`.
1.1.0 print all group.

System OS : windows 10 64-bit
JDK Version : Oracle JDK 1.7.0_80 64-bit
Gradle Version : 2.12
IntelliJ IDEA Version : 14.1.6
 =||= Yep, this is a bug. The groups don't complete until all groups have been emitted which doesn't happen because concat() prefetches only 2 groups of the 5. I overlooked this case and apparently the unit tests weren't checking for this.
 =||= See the fix in #3787.
 =||= :+1: 
 =||= Closing via #3787.
 =||= ,0
3789,3784,Single.zip on empty collection never terminate,``` java
Single.zip(new ArrayList<Single<Integer>>(), i -> i)
          .doAfterTerminate(() -> System.out.println("terminated"))
          .subscribe();
```

this behavior is different from `Observable.zip`

``` java
Observable.zip(new ArrayList<Observable<Integer>>(), i -> i)
                   .doAfterTerminate(() -> System.out.println("terminated"))
                   .subscribe();
```,What do you expect it to do? Throw error? Single either emits one result or throws error. 

Looks like the best we can do is to throw something like `IllegalArgumentException`. 
 =||= Observable.zip just completes if there are no sources. If one converts an empty Observable to single, it produces a NoSuchElementException error.
 =||= I'll check this and work on PR soon. 
 =||= ,0
3790,3161,'lift(final Operator<? extends R, ? super T>)' has private access in 'rx.Single',I was expecting `Single#lift()` to be part of the public API like `Observable#lift()`. Is there a reason for this restriction?

`Single#compose()` is public, too (and links to `#lift()` in the docs). I guess the private access is just a bug.

https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Single.java#L176

My workaround:

```
Single.just("value")
        .toObservable()
        .lift(myOperator)
        .toSingle();
```,Single is in experimental phase, its API is not stable and there wasn't enough confidence to open up many of the methods, including lift.
 =||= I think the time has come to expose `Single.lift()`. PRs welcome.
 =||= ,0
3809,3808,NullPointerException caused by null elements in merge() queue,Take a look at this (admittedly somewhat wonky) sample stream:

``` java
Observable.range(0, 2)
    .flatMap(__ -> Observable.just(null))
    .subscribe(new Subscriber<Object>() {
      @Override public void onNext(Object o) {
        System.out.println("onNext(" + o + ")");
      }

      @Override public void onError(Throwable e) {
        e.printStackTrace();
      }

      @Override public void onStart() {
        request(1);
      }

      @Override public void onCompleted() { }
    });
```

In this sample I'm purposefully only requesting one item so that the second one ends up getting queued in the internal `OperatorMerge`. As a result of passing `null` to the queue, though, I end up getting this in `onError`:

``` java
java.lang.NullPointerException
    at rx.internal.util.atomic.SpscUnboundedAtomicArrayQueue.offer(SpscUnboundedAtomicArrayQueue.java:71)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.queueScalar(OperatorMerge.java:465)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(OperatorMerge.java:437)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:228)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:142)
    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)
    at rx.internal.operators.OnSubscribeRange$RangeProducer.fastpath(OnSubscribeRange.java:126)
    at rx.internal.operators.OnSubscribeRange$RangeProducer.request(OnSubscribeRange.java:63)
    at rx.Subscriber.setProducer(Subscriber.java:211)
    at rx.Subscriber.setProducer(Subscriber.java:205)
    at rx.internal.operators.OnSubscribeRange.call(OnSubscribeRange.java:38)
    at rx.internal.operators.OnSubscribeRange.call(OnSubscribeRange.java:26)
    at rx.Observable$2.call(Observable.java:162)
    at rx.Observable$2.call(Observable.java:154)
    at rx.Observable$2.call(Observable.java:162)
    at rx.Observable$2.call(Observable.java:154)
    at rx.Observable.subscribe(Observable.java:8191)
    at rx.Observable.subscribe(Observable.java:8158)
    at net.danlew.experiments.Tester.main(Tester.java:39)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
Caused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: 1
    at rx.exceptions.OnErrorThrowable.addValueAsLastCause(OnErrorThrowable.java:109)
    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)
    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:56)
    ... 18 more
```

I'm running into in more complex code where the requests # is different than the # items pushed and seeing the same problem.,This is a bug on the entry side of the scalar-queue not encoding the `null` value. Fix posted in #3809.
 =||= Closing via #3809.
 =||= ,0
3822,3749,ConcurrentModificationException in RxJavaPlugins.getPluginImplementationViaProperty,I am using RxJava 1.1.1 on Android and getting the following error:

``` java
Caused by java.util.ConcurrentModificationException
       at java.util.Hashtable$HashIterator.nextEntry(Hashtable.java:727)
       at java.util.Hashtable$EntryIterator.next(Hashtable.java:778)
       at java.util.Hashtable$EntryIterator.next(Hashtable.java:776)
       at rx.plugins.RxJavaPlugins.getPluginImplementationViaProperty(RxJavaPlugins.java:177)
       at rx.plugins.RxJavaPlugins.getSchedulersHook(RxJavaPlugins.java:232)
       at rx.schedulers.Schedulers.(Schedulers.java)
       at rx.schedulers.Schedulers.(Schedulers.java)
```

My code is 

``` java
unreadConversationsServer = unreadConversations;
      final Scheduler.Worker worker = Schedulers.io().createWorker();
      worker.schedule(() -> {
        try {
          computeUnreadUnSyncedConversationCount();
        } catch (Exception e) {
          Timber.e(e, "Error while computing Unread Unsynced Conversation Count");
        }
        worker.unsubscribe();
      });
```

Full detail here: http://crashes.to/s/4ecb8083b7f,You seem to have something changing `System.getProperties()` concurrently with the initialization of the plugin.
 =||= Ping @niqo01: were you able to fix the problem? 

@akarnokd gave most possible reason of the issue, probably some third-party library modifies system properties concurrently (you can debug access to system properties to find that out).

// We can try to `clone()` properties before iterating over them (it's a `Hashtable` (ew) which is `synchronized` almost everywhere but iterating), but personally, I'd like to not do it if possible.
 =||= I don't know what kind of map it is thus copying might have the same issue. We could catch the CME and retry the operation with a fresh iterator.
 =||= `clone` looks good to me, since it's called only `once` for each hook. We won't lose any performance after warming up.

> I don't know what kind of map it is thus copying might have the same issue. We could catch the CME and retry the operation with a fresh iterator.

According to the javadoc of Properties, I think `clone` is safe.

> Each key and its corresponding value in the property list is a string.
> Because Properties inherits from Hashtable, the put and putAll methods can be applied to a Properties object. Their use is strongly discouraged as they allow the caller to insert entries whose keys or values are not Strings. The setProperty method should be used instead. If the store or save method is called on a "compromised" Properties object that contains a non- String key or value, the call will fail. Similarly, the call to the propertyNames or list method will fail if it is called on a "compromised" Properties object that contains a non- String key.
 =||= @zsxwing Great!

PR welcome.
 =||= Closing via #3822
 =||= ,0
3823,3435,OperatorFinally calls action twice if action throws exception. Exception thrown by action is swallowed,While I was implementing #3434 I've found two problems with `OperatorFinally`.

I'll call `OperatorFinally.action` as `finallyAction` for better readability.
1. If `finallyAction` is `null` — `NullPointerException` will be swallowed by `SafeSubscriber`, this can be solved via `action != null` check in the `OperatorFinally` (I'll make PR).
2. If `finallyAction` throws exception, `lift` calls `onError()` and `OperatorFinally` invokes `finallyAction` again (this may brake user-defined logic)! And second exception is swallowed by the `SafeSubscriber` (see problem 1).

I vote for solving both of these problems before 1.0.15/1.1.10.,Here are the tests:

``` java
@Test
public void nullFinallyActionShouldBeCheckedASAP() {
    try {
        Observable
                .just("value")
                .finallyDo(null);

        fail();
    } catch (NullPointerException expected) {

    }
}

@Test
public void ifFinallyActionThrowsExceptionShouldNotBeSwallowedAndActionShouldBeCalledOnce() {
    Action0 finallyAction = mock(Action0.class);
    doThrow(new IllegalStateException()).when(finallyAction).call();

    TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

    Observable
            .just("value")
            .finallyDo(finallyAction)
            .subscribe(testSubscriber);

    testSubscriber.assertValue("value");

    verify(finallyAction).call();
    // Actual result:
    // Not only IllegalStateException was swallowed
    // But finallyAction was called twice!
}
```
 =||= I'll try to send PRs with fixes ASAP, `null` check is easy, but second problem looks tricky.
 =||= If the action throws, you can't do much but call `RxJavaPlugins.getInstance().getErrorHandler().handleError()` for it.
 =||= We can throw it as `Error`. Leaving the app in an unknown state is very bad idea, especially in something like `finallyDo()`.
 =||= The sequence has already terminated at that point and this operator is there to have side-effects after it. The exception has nowhere to go and there is no guarantee a thrown error reaches its intended target because of a potential async boundary. So it either propagates up to a synchronous caller, gets thrown away by the `ExecutorService` or gets sent to the error handler.
 =||= Can this be closed?
 =||= @akarnokd won't be able to work on this for at least 2 days, feel free to run the tests I posted  ^ and see what we can do here or I'll investigate this in the end of the week.

As far as I remember, the biggest problem is that `action` gets called twice if it throws exception and it may break app's logic in a dramatic manner.
 =||= Fix posted in #3823.
 =||= Closing via #3823
 =||= ,0
3829,3459,NoSuchFieldException: unsubscribed,```
java.lang.NoSuchFieldException: unsubscribed
java.lang.Class.getDeclaredField(Class.java:929)
java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.<init>(AtomicIntegerFieldUpdater.java:251)
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(AtomicIntegerFieldUpdater.java:49)
rx.subscriptions.BooleanSubscription.<clinit>(SourceFile:32)
rx.subscriptions.Subscriptions.create(SourceFile:75)
rx.subjects.SubjectSubscriptionManager.addUnsubscriber(SourceFile:68)
rx.subjects.SubjectSubscriptionManager.call(SourceFile:58)
rx.subjects.SubjectSubscriptionManager.call(SourceFile:35)
rx.Observable.subscribe(SourceFile:7803)
rx.Observable.subscribe(SourceFile:7531)
```

Happened randomly, I cannot reproduce this.

Machine Info

```
SM-N900;Android 5.0 LRX21V,level 21
```,I too have seen this issue occurring randomly. In my case it was happening while using `HystrixCollapser` inside map/flatMap operator. On debugging I found that `onCompleted` was being called on the observable before `onNext`. I was not able to isolate if it was due to rx operator or Hystrix.

@yyfrankyy What is scenario in your use-case? Can you share your flow of composition ?
 =||= Hi. Do you use ProGuard by any chance? I'm not an expert on it but you might need to change the field retention policy.
 =||= ProGuard detects and keeps fields used by `AtomicFieldUpdater` since v4.6 (release happened 4 years ago), maybe @yyfrankyy uses another code obfuscator?
 =||= @akarnokd @artem-zinnatullin we do use proguard, but keep all the staff that rx needs by `-keep class rx.** { * ; }`

@amitcse It crashed at the very beginning since the `Application#onCreate()`, code is here:

https://github.com/WeTeX/Watchers/blob/master/src/main/java/com/github/QQMail/Watchers.java#L244

And here are some use cases, it works quite well at most of the time.

https://github.com/WeTeX/Watchers/blob/master/src/test/java/com/github/QQMail/WatchersTest.java

I grep all the crashes related to `NoSuchFieldException: unsubscribed`, all the crashes came from 
- **SM-G900I;Android 5.0,level 21**
- **SM-G9006V;Android 5.0,level 21**

Some of the crashes look like this, from these two devices. they look so similar..
- **GT-I9507V;Android 5.0.1,level 21**
- **GT-I9500;Android 5.0.1,level 21**

```
java.lang.NoSuchFieldException: requested
java.lang.Class.getDeclaredField(Class.java:929)
java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater.<init>(AtomicLongFieldUpdater.java:251)
java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater(AtomicLongFieldUpdater.java:50)
rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.<clinit>(SourceFile:86)
rx.internal.operators.OperatorObserveOn.rx.Subscriber call(rx.Subscriber)(SourceFile:64)
rx.internal.operators.OperatorObserveOn.java.lang.Object call(java.lang.Object)(SourceFile:44)
```
 =||= IDK, but I see 2 possible reasons:
1. Samsung: probably, they've patched the Runtime (they like to change everything in Android) and it tries to minify fields names for less memory usage (though I don't think that they're really doing such things, but, who knows).
2. ProGuard rules problem or ProGuard bug or Android Gradle Plugin bug when you're doing non-clean builds (though it'll break app on other devices too).

@yyfrankyy can you please wrap the `subscribe()` call into `try-catch` and then collect info about the fields of the `BooleanSubscription` class, it'll help us detect the problem.

``` java
try {
  obs.subscribe(...);
} catch (NoSuchFieldException e) {
  // collect info about fields of the BooleanSubscription class
  BooleanSubscription.class.getDeclaredFields(); // include it into the crash report
}
```

Also, recently I've shipped ProGuard rules for RxJava as aar https://github.com/artem-zinnatullin/RxJavaProGuardRules, you can try to use them instead of yours.
 =||= It's definitely not pro-guard, since the decompiled class code looks correct.  I can also try to capture the fields in the class (thank you for the suggestion), but since I haven't reproduced the issue myself it'll take a week before I have that data.  In the mean time, I think I'll just replace Atomic_FieldUpdater with Atomic_ objects, since I confirmed that it works.
 =||= @artem-zinnatullin Sure, we can do this on our next release next month, will come back later.
 =||= Hi,
I have the same issues. All only on Samsung devices with Android 5

1:
....
Caused by java.lang.NoSuchFieldException: producerIndex
       at java.lang.Class.getDeclaredField(Class.java)
       at rx.internal.util.unsafe.UnsafeAccess.addressOf(SourceFile)
       at rx.internal.util.unsafe.SpmcArrayQueueProducerField.(SourceFile)
       at rx.internal.util.RxRingBuffer$2.createObject(SourceFile)
       at rx.internal.util.ObjectPool.borrowObject(SourceFile)
       at rx.internal.util.RxRingBuffer.(SourceFile)
       at rx.internal.util.RxRingBuffer.getSpmcInstance(SourceFile)
       at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.(SourceFile)
       at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile)
       at rx.Observable.unsafeSubscribe(SourceFile)
       at rx.internal.operators.OperatorSubscribeOn$1$1.call(SourceFile)
       at rx.internal.schedulers.ScheduledAction.run(SourceFile)
       at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(SourceFile)
       ...

2:
...
Caused by java.lang.NoSuchFieldException: do
       at java.lang.Class.getDeclaredField(Class.java)
       at java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.(AtomicIntegerFieldUpdater.java)
       at java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(AtomicIntegerFieldUpdater.java)
       at rx.subscriptions.BooleanSubscription.(SourceFile)
       at rx.subscriptions.Subscriptions.create(SourceFile)
       at rx.subjects.SubjectSubscriptionManager.addUnsubscriber(SourceFile)
       at rx.Observable.subscribe(SourceFile)
       at rx.Observable.subscribe(SourceFile)
       ...

3:
...
Caused by java.lang.NoSuchFieldException: this
       at java.lang.Class.getDeclaredField(Class.java)
       at java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater.(AtomicLongFieldUpdater.java)
       at java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater(AtomicLongFieldUpdater.java)
       at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.(SourceFile)
       at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile)
       at rx.Observable.unsafeSubscribe(SourceFile)
       at rx.internal.operators.OperatorSubscribeOn$1$1.call(SourceFile)
       at rx.internal.schedulers.ScheduledAction.run(SourceFile)
       at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(SourceFile)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java)
       at java.lang.Thread.run(Thread.java)

4:
...
Caused by java.lang.NoSuchFieldException: do
       at java.lang.Class.getDeclaredField(Class.java)
       at java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.(AtomicIntegerFieldUpdater.java)
       at java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(AtomicIntegerFieldUpdater.java)
       at rx.schedulers.CachedThreadScheduler$EventLoopWorker.(SourceFile)
       at rx.schedulers.CachedThreadScheduler.createWorker(SourceFile)
       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.(SourceFile)
       at rx.internal.operators.OperatorObserveOn.call(SourceFile)
       at rx.Observable$2.call(SourceFile)
       at rx.Observable.subscribe(SourceFile)
       at rx.Observable.subscribe(SourceFile)
       ...

5:
...
Caused by java.lang.NoSuchFieldException: case
       at java.lang.Class.getDeclaredField(Class.java)
       at java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater.(AtomicLongFieldUpdater.java)
       at java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater(AtomicLongFieldUpdater.java)
       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.(SourceFile)
       at rx.internal.operators.OperatorObserveOn.call(SourceFile)
       at rx.Observable$2.call(SourceFile)
       at rx.Observable.subscribe(SourceFile)
       at rx.Observable.subscribe(SourceFile)
       ....

Looks like Samsung introduce some specific problem on Android 5.

Do you plan to apply a workaround for that? 
 =||= 1000+ crashes past few days in New York Times app.  Hoping for @markrietveld fix to be merged soon.  We are reaching out to Samsung as well to find out exactly what happened on their end.

```
Package: com.nytimes.android
Version Code: 9486
Version Name: 5.9.2
Android: 5.0.2
Manufacturer: samsung
Model: SM-T805Y
Date: Mon Oct 26 06:31:34 AEDT 2015

java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.
    at rx.internal.schedulers.ScheduledAction.run(SourceFile:62)
    at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(SourceFile:98)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
    at java.lang.Thread.run(Thread.java:818)
Caused by: java.lang.ExceptionInInitializerError
    at rx.internal.operators.OperatorZip.call(SourceFile:113)
    at rx.internal.operators.OperatorZip.call(SourceFile:58)
    at rx.Observable$2.call(SourceFile:158)
    at rx.Observable$2.call(SourceFile:154)
    at rx.Observable.subscribe(SourceFile:7804)
    at rx.Observable.subscribe(SourceFile:7772)
    at com.nytimes.android.notification.DailyRichNotificationHelper.displayDailyRichNotification(SourceFile:108)
    at com.nytimes.android.notification.DailyRichNotificationHelper.displayDailyRichNotification(SourceFile:99)
    at com.nytimes.android.notification.DailyRichNotificationHelper$1.call(SourceFile:86)
    at com.nytimes.android.notification.DailyRichNotificationHelper$1.call(SourceFile:83)
    at rx.Observable$28.onNext(SourceFile:7588)
    at rx.observers.SafeSubscriber.onNext(SourceFile:130)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(SourceFile:364)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(SourceFile:326)
    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(SourceFile:802)
    at rx.internal.operators.OperatorDoOnEach$1.onNext(SourceFile:84)
    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.onNext(SourceFile:224)
    at rx.internal.operators.NotificationLite.accept(SourceFile:150)
    at rx.subjects.ReplaySubject$UnboundedReplayState.accept(SourceFile:466)
    at rx.subjects.ReplaySubject$UnboundedReplayState.replayObserverFromIndex(SourceFile:515)
    at rx.subjects.ReplaySubject$UnboundedReplayState.replayObserver(SourceFile:503)
    at rx.subjects.ReplaySubject.caughtUp(SourceFile:423)
    at rx.subjects.ReplaySubject.onNext(SourceFile:369)
    at rx.Observable$30.onNext(SourceFile:7681)
    at rx.observers.SafeSubscriber.onNext(SourceFile:130)
    at rx.internal.operators.OperatorDoOnEach$1.onNext(SourceFile:84)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(SourceFile:364)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(SourceFile:326)
    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(SourceFile:802)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(SourceFile:364)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(SourceFile:326)
    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(SourceFile:802)
    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.onNext(SourceFile:224)
    at rx.subjects.AsyncSubject.onCompleted(SourceFile:101)
    at rx.util.async.Async$1$1.call(SourceFile:533)
    at rx.internal.schedulers.ScheduledAction.run(SourceFile:55)
    ... 4 more
Caused by: java.lang.RuntimeException: java.lang.NoSuchFieldException: counter
    at java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater.<init>(AtomicLongFieldUpdater.java:269)
    at java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater(AtomicLongFieldUpdater.java:50)
    at rx.internal.operators.OperatorZip$Zip.<clinit>(SourceFile:187)
    ... 40 more
Caused by: java.lang.NoSuchFieldException: counter
    at java.lang.Class.getDeclaredField(Class.java:929)
    at java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater.<init>(AtomicLongFieldUpdater.java:251)
    ... 42 more
```
 =||= Fix delivered, all AtomicXFieldUpdater changed to AtomicX classes.
 =||= Hi, 
there is still a reference to `AtomicIntegerFieldUpdater` here:

https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/schedulers/CachedThreadScheduler.java#L180

Any chance to have it fixed in the 1.x branch?

Thanks,
Rocco
 =||= @roccozanni Would you be interested in fixing it?
 =||= @akarnokd I can definitely give it a try.

I forked the project and imported into Eclipse, but I have some troubles with the unit tests, because there are some failures and I'm not so confident in doing changes without the help of a robust existing test suites. I use RxJava since a while but I'm definitely not into the internals.

Not sure if it's something misconfigured on my side (I followed the instructions in the "How to contribute" wiki page), but I can send you the JUnit xml output if needed. Can you please verify if the 1.x branch tests are working on your side?
 =||= We have CI associated with the project and all the current tests pass both locally and on Travis. After you imported the project, go to the Eclipse preferences, look for Compiler warnings and set the restricted access to ignore. You should also install the Gradle IDE plugin to make sure all test dependencies are wired up properly.
 =||= Same android samsung 5.0.X appeared for us with the latest 1.1.2

> Caused by java.lang.NoSuchFieldException: producerIndex
>        at java.lang.Class.getDeclaredField(Class.java:929)
>        at rx.internal.util.unsafe.UnsafeAccess.addressOf(UnsafeAccess.java:100)
>        at rx.internal.util.unsafe.SpmcArrayQueueProducerField.<clinit>(SpmcArrayQueue.java:31)
>        at rx.internal.util.RxRingBuffer$2.createObject(RxRingBuffer.java:294)
>        at rx.internal.util.RxRingBuffer$2.createObject(RxRingBuffer.java:290)
>        at rx.internal.util.ObjectPool.borrowObject(ObjectPool.java:74)
>        at rx.internal.util.RxRingBuffer.<init>(RxRingBuffer.java:307)
>        at rx.internal.util.RxRingBuffer.getSpmcInstance(RxRingBuffer.java:45)
>        at rx.internal.operators.OperatorZip$Zip$InnerSubscriber.<init>(OperatorZip.java:305)
>        at rx.internal.operators.OperatorZip$Zip.start(OperatorZip.java:205)
>        at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:156)
>        at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:122)
>        ...
 =||= So those Android devices have `Unsafe`?

I wonder if the `addressOf` might be triggering the bug in the runtime by hiding the `getDeclaredField` call.
 =||= I was thinking that too but I've checked and the implementation has not changed recently and we started seeing the errors just with the latest version. Pretty weird stuff...
 =||= If you could play with a manual build, inlining the `addressOf` in `rx.internal.util.unsafe.SpmcArrayQueueProducerField` and `rx.internal.util.unsafe.SpmcArrayQueueConsumerField` could rule out that sort of bug.

In the meantime, I'll try to have a System property driven way of disabling `Unsafe` use in a PR.
 =||= I'm still having this following issue

```
java.lang.IllegalArgumentException: Must be integer type

at java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.<init>(AtomicIntegerFieldUpdater.java:275)
at java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(AtomicIntegerFieldUpdater.java:49)
at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker

```

Should we replace the AtomicIntegerFieldUpdater on the class CachedThreadScheduler as well ?
 =||= See #3979.
 =||= ,0
3829,3815,1.x Provide public constant instead of UnsafeAccess.isUnsafeAvailable(),Motivation: save some nanoseconds on JVM and a little bit more on Android, new construction will also be easier for JIT.,I guess this single line should be inlined by JIT. Are you worrying about some old Android versions without JIT?
 =||= RxJava doesn't support Android devices which lacked a JIT because they only
have Java 5 APIs.

On Thu, Mar 31, 2016 at 3:14 PM Shixiong Zhu notifications@github.com
wrote:

> I guess this single line should be inlined by JIT. Are you worrying about
> some old Android versions without JIT?
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/pull/3815#issuecomment-204085567
 =||= Yes, `if (UnsafeAccess.isUnsafeAvailable())` should be interpreted and inlined in places, but it won't be immediate and JIT will have to figure that out. Also, I think it'll have to do it again for every place where we use this method, but not sure.

Regarding Android afaik: from Android 2.3 to 4.4 it has Dalvik VM that has JIT, from Android 5 to 6 it has ART without JIT, upcoming Android N release will have ART with JIT.

Idea is: if we can do something a little bit more efficiently and it doesn't make code much worse, why not.
 =||= I don't know.
 =||= Totally up to you, it's nanooptimization in `internal` package, very easy to go back, basically CTRL + R one to another.

// -1 method for Android BTW haha
 =||= I think the reason for this should be that it's just a bit cleaner, inlined, and one less method. Perf isn't really a good or measurable heuristic for this. Maybe there's an argument for keeping the method for testing purposes, but I doubt people are mocking this.
 =||= We have trouble with Samsung devices again. Could you include a check for a system property named `rx.unsafe-disable` (content value irrelevant) and thus force IS_UNSAFE_AVAILABLE to be false?
 =||= @akarnokd to not mix refactoring with new logic I've opened separate PR for system property #3829.

Feel free to merge in any order.

@hzsweers at the moment I don't see any profit in using method, and I'm not sure that somebody is mocking static method (PowerMock?), if I'll need it I'll rewrite value of `UNSAFE` field via reflection.
 =||= Was just chiming in, I doubt anyone us mocking it and it is cleaner so I say go for it.
 =||= In term of performance, I don't think the impact will be measurable (even in interpreted mode), the method will be under the default threshold for Trivial Method (=6 for Hotspot), and will be inlined as soon as the caller is compiled, [reference code in OpenJDK](http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/opto/bytecodeInfo.cpp#l301).

The only remaining question is, what is cleaner:
`UnsafeAccess.isUnsafeAvailable()` or `UnsafeAccess.IS_UNSAFE_AVAILABLE` ?
I prefer the method call.
 =||= As we may add other logic into `isUnsafeAvailable` in future (E.g., #3829), I prefer the method call too.
 =||= I'd keep this as a method as well.
 =||= ok
 =||= ,0
3845,384,Implemented the `delay` operator,This implements the operator from #36 in all four variants.

The tests also found a bug in `interval` that I fixed.

Maybe this is a bug of `map` though - `map` throws exceptions in `onNext`, not sure if it should be allowed to do that - the `SafeObserver` that it relies on comes too late for scheduled actions. However, this can be discussed and fixed independently.,[RxJava-pull-requests #281](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/281/) SUCCESS
This pull request looks good
 =||= > Maybe this is a bug of map though - map throws exceptions in onNext, not sure if it should be allowed to do that - the SafeObserver that it relies on comes too late for scheduled actions. However, this can be discussed and fixed independently.

The idea is that `Func` implementations from internal code functions correctly and does not break the Rx contract (that `onNext` should not throw). Thus, we shouldn't need the `SafeObserver` around anything internal that complies with the Rx contract.

The `SafeObserver` only wraps functions and observers that are passed in from outside the RxJava codebase as those are untrusted. This was discussed further at https://github.com/Netflix/RxJava/issues/216 and then more recently changes to `map` were made for error handling: https://github.com/Netflix/RxJava/pull/314
 =||= [RxJava-pull-requests #282](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/282/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #283](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/283/) SUCCESS
This pull request looks good
 =||= > Only errors emitted by the source Observable are not delayed.

Why was this decision made? Is that how Rx.Net works (the MSDN docs don't say).

This means we'd ignore `onNext` events scheduled to be delivered since we'd push `onError` before them. That  breaks the Rx contract so don't know why we'd want to do this.

It seems that `onError` and `onCompleted` should be delayed just like `onNext` - all notifications scheduled for future delivery.
 =||= Concerning the question whether Rx.NET emits errors without delay: [Here](http://www.introtorx.com/content/v1.0.10621.0/13_TimeShiftedSequences.html) it says that they get emitted without delay. MSDN doesn't say anything about it.

So I tried it out in F#, and it actually doesn't get delayed:

``` fsharp
#light
open Core.Printf
open System
open System.Reactive.Linq

module Program =
  exception ObsvError

  [<EntryPoint>]
  let Main(args) =
    let mapToError = fun (x: int64) -> if x > 4L then raise ObsvError else x
    let obsv = Observable.Interval(TimeSpan.FromSeconds 1.0).Select(mapToError).Delay(TimeSpan.FromSeconds 4.5)
    let sub = obsv.Subscribe(onNext = (fun x -> printfn "%d" x), 
                             onError = (fun exn -> Console.WriteLine "Error!"))            
    Console.ReadLine() |> ignore
    sub.Dispose()
    0
```

Will output:

```
0
1
Error!
```

If the error weren't delayed at all, however, it should happen before `1`. If it were delayed fully, it should happen after `4`. So that's a bit strange.
 =||= I guess all that means that we'll have to introduce a specific timestamped queue here.
 =||= @headinthebox Erik, can you provide guidance on what we should do here? It seems that `onError` should be delayed if any `onNext` are still outstanding, but that isn't what happens in .Net and that seems to break the Rx contract.
 =||= Erik has confirmed that 'onError' should emit immediately and that if the 'onNext' events should not be lost then `onErrorResumeNext` or something similar should be used before `delay` or `materialize` can be used before passing into `delay` to treat `onError` as an event rather than exception.
 =||= @jmhofer 

Based on Erik's confirmation is this good to merge?
 =||= Unfortunately, I didn't get around to another close look here yet.

I'm afraid that this might still need a queue and some synchronization in order to be clean concurrency-wise. Imho the current implementation should work for sane use cases, though.
 =||= I must say that I am surprised that in .NET 

```
xs.Delay(t)
```

does not behave the same as 

```
xs.Select(x => Observable.Timer(t).Select(_ => x)).Concat()
```

Erik

On Oct 22, 2013, at 10:05 PM, Joachim Hofer notifications@github.com wrote:

> Unfortunately, I didn't get around to another close look here yet.
> 
> I'm afraid that this might still need a queue and some synchronization in order to be clean concurrency-wise. Imho the current implementation should work for sane use cases, though.
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= Could we implement delay with something like

```
xs.map(x => Observable.timer(t).map(_ => x).cache()).concat()
```
 =||= That’s what I effectively do below; except I am not sure why you add the extra call to cache.

I am digging into the .NET implementation as we speak 
since I am not sure that implementation is correct.

On Oct 23, 2013, at 11:44 AM, samuelgruetter notifications@github.com wrote:

> Could we implement delay with something like
> 
> xs.map(x => Observable.timer(t).map(_ => x).cache()).concat()
> —
> Reply to this email directly or view it on GitHub.
 =||= `concat(Observable<Observable<T>>)` has never more than two subscriptions at the same time: one to the outer `Observable<Observable<T>>` and one to the current inner `Observable<T>`. For delay however, if the time distance between two elements is smaller than the delay, both TimerObservables created for delaying these two elements must have a subscriber as soon as they're created to make sure that they start counting time. Comcat doesn't do these necessary subscriptions, and that's why I added cache().

(Note that I'm making these claims without having access to a computer where I can do tests, so this risks being complete nonsense ;-) )
 =||= The .NET implementation has a bug. The version using the Delay operator
delivers one value, _after_ the input has experienced an OnError and waits
for 10 seconds to deliver the answer and fail. The values in X~~>Y don't
matter.

[0] 31~~>44
[Exception of type 'System.Exception' was thrown.]

If you draw the marble diagram, the correct answer is to call onError after
4 seconds.

{Exception of type 'System.Exception' was thrown.}

Erik

var xs = Observable.Interval(TimeSpan.FromSeconds(1))

```
   .Select(x => 

     { 

      if(x == 4)  throw new Exception();

        return "["+x+"] "+System.DateTime.Now.Millisecond; 

     })

     .Delay(TimeSpan.FromSeconds(10))

     .Select(x => x+"~~>"+System.DateTime.Now.Millisecond);
```

xs.Subscribe

( x => Console.WriteLine(x)

, e => Console.WriteLine("["+e.Message+"]")

, () => Console.WriteLine("!")

);

var zs = Observable.Interval(TimeSpan.FromSeconds(1))

```
   .Select(x => 

     { 

      if(x == 4)  throw new Exception();

      return "{"+x+"} "+System.DateTime.Now.Millisecond;

      })

     .Select(x => Observable.Timer(TimeSpan.FromSeconds(10)).Select(_ =>
```

x)).Concat()

```
     .Select(x => x+"~~>"+System.DateTime.Now.Millisecond);
```

zs.Subscribe

( x => Console.WriteLine(x)

, e => Console.WriteLine("{"+e.Message+"}")

, () => Console.WriteLine("!")

);

From: erik meijer [mailto:erik.meijer@meijcrosoft.com] 
Sent: Wednesday, October 23, 2013 2:52 AM
To: Netflix/RxJava
Cc: Netflix/RxJava; Erik Meijer
Subject: Re: [RxJava] Implemented the `delay` operator (#384)

That's what I effectively do below; except I am not sure why you add the
extra call to cache.

I am digging into the .NET implementation as we speak 

since I am not sure that implementation is correct.

On Oct 23, 2013, at 11:44 AM, samuelgruetter notifications@github.com
wrote:

Could we implement delay with something like

xs.map(x => Observable.timer(t).map(_ => x).cache()).concat()

## 

Reply to this email directly or view it on GitHub
https://github.com/Netflix/RxJava/pull/384#issuecomment-26892143 .
<https://github.com/notifications/beacon/f5Np9-JVjG56Yyi3j3ToPDeurdEmqyCr9bz
IdcgJ4T5obnlPCkNxbsmS18XcQofG.gif>
 =||= @jmhofer Can you rebase this with master so it can be merged and ensure it matches the final answers we got from @headinthebox ?
 =||= this is a +1 on this PR.
 =||= I have rebased this onto netflix/rxjava/master and issued a PR to @jmhofer... here is my fork: https://github.com/jonnolen/RxJava/tree/delay
 =||= Completed in #576
 =||= ,0
3856,3724,APIs for easily changing the thread priority of default schedulers via hook.,On Android, the main thread is a sacred holy land at which we must all worship. As such this means other threads (ideally) shouldn't be favorably scheduled in priority with it. For network and filesystem operations this usually means using low priority threads.

One solution is to just use low priority threads on our own schedulers, but this doesn't affect code using the standard `io()` and `computation()` schedulers. Unfortunately there's a whole bunch of ceremony around how various schedulers are initialized which includes a mixed bag of public vs. non-public types and APIs which makes replacing them in a scheduler hook difficult.

I think the most easy way to accomplish this is the following:
- [x] ~~`RxThreadFactory` constructor overload which takes a thread priority to use.~~ Not needed.
- [ ] Factory methods on `Schedulers` for creating instances of `io()`, `computation()`, and `newThread()` except using a supplied `ThreadFactory`
  - [ ] `Schedulers.createIoScheduler(ThreadFactory)`
  - [ ] `Schedulers.createComputationScheduler(ThreadFactory)`
  - [ ] `Schedulers.createNewThreadScheduler(ThreadFactory)`

Nice to have:
- [x] `Schedulers` using these factory methods to create the default implementations. This involves moving the thread factories from the individual types "up" to `Shedulers`.,Happy to do some of the work if this sounds acceptable.
 =||= @JakeWharton I think that sound acceptable, I'm happy to review your PR.
 =||= This is a little more tricky than I had initially anticipated. Perhaps it's worth talking about a means of setting the default priority of the internal thread pools through a mechanism like properties as a separate, easier first step? Plus that would be a lot lower-overhead for Android users anyway, and we could even use the existing Android platform detection to lower the thread priority by default.
 =||= Pass a ThreadFactory

On Fri, Jan 20, 2017, 10:48 PM erDaren <notifications@github.com> wrote:

> so, how to set thread priority in android with android values(like
> Process.THREAD_PRIORITY_BACKGROUND)?
>
> —
> You are receiving this because you were mentioned.
>
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/3724#issuecomment-274242173>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEUOSEQqdFAeQocjdNnUfjwJ8gjubks5rUaorgaJpZM4Heynt>
> .
>
 =||= ,0
3866,3865,flatMap from Single to Completable,Is there an easy way of doing a `flatMap` from a `Single` to a `Completable`?

Currently I need to do something like this:

``` java
 Completable saveData(Data data) {
      ... 
 }

 Single.just(data)
        .flatMapObservable(new Func1<Data, Observable<?>>() {
            @Override
            public Observable<?> call(Data data) {
                return saveData(data).toObservable();
            }
        })
        .toCompletable();
```

I think It would be good to have an operator like `Single.flatMapCompletable()` so we could do:

``` java
Single.just(data)
        .flatMapCompletable(new Func1<Data, Completable>() {
            @Override
            public Completable call(Data data) {
                return saveData(data);
            }
        });
```,At the moment you can pass the `Single` to `Completable.fromSingle()`, I'll submit a PR for `Single.toCompletable()`.
 =||= I'm not sure this issue is resolved by adding `Single.toCompletable()`? 

My question was how to "link" a `Single` to a `Completable` using an operator like `flatMap` so that the `Completable` can use the result from the `Single`. If I transform my source `Single` to a completable using `Single.toCompletable()` then the value is lost.

My suggestion is to add `Single.flatMapCompletable()`. 
 =||= > so that the `Completable` can use the result from the `Single`

`Completable` is value-less type, you won't be able to use result from `Single` or `Observable`. It was created to replace `Observable<Void> / Single<Void>` when you just need to perform some side-effect work.

Can you use `Single` instead of `Completable`?
 =||= So If I have a method in class `A` like this:

``` java
Completable saveData(Data data) {
     // Creates and returns a Completable that saves some data in local storage
}
```

Then in class `B` I have a method that retrieves some data from a REST API 

``` java
Single<Data> retrieveData() {
     // Creates and returns a Single that gets some data
}
```

Now from class `C` I want to `flatMap` both methods so when `retrieveData()` completes I can pass the result to `saveData(data)`. Are you suggesting that `saveData(data)` should return a `Single` instead of a `Completable`? I would imagine a `Completable` is a better option because I don't care about the value after it's been saved. 
 =||= If you want final result to be `Completable` then one way is to do:

``` java
Completable result = retrieveData()
  .flatMap(data -> saveData(data).toSingle(() -> "")) // Just emit something.
  .toCompletable()
```

If you want final result to be `Single` then one way to do this:

``` java
Single<Data> result = retrieveData()
  .flatMap(data -> saveData(data).toSingle(() -> data))
```
 =||= Yeah, that makes sense. I want the final result to be a `Completable` so the first option would work for me. However it seems a bit redundant having to call `toSingle()` and then call `toCompletable()`. That's why I was thinking that adding a new operator like `single.flatMapCompletable()` could be useful. 
Thanks. 
 =||= A simple extension function in Kotlin would be the following:

``` Kotlin
fun <T> Single<T>.flatMapCompletable(producer: (T) -> Completable): Completable {
    return Completable.create { subscriber ->
        subscribe(
              { producer(it).subscribe(subscriber) },
              { subscriber.onError(it) }
        )
    }
}
```
 =||= Could this please be re-opened? The scenario with a save method seems like a prime use case for `Completable`. To say that you can't go from Single to a nested save is pretty hard to accept.
 =||= There is the PR #4226 for that.
 =||= Didn't see that thanks!
 =||= ,0
3879,3724,APIs for easily changing the thread priority of default schedulers via hook.,On Android, the main thread is a sacred holy land at which we must all worship. As such this means other threads (ideally) shouldn't be favorably scheduled in priority with it. For network and filesystem operations this usually means using low priority threads.

One solution is to just use low priority threads on our own schedulers, but this doesn't affect code using the standard `io()` and `computation()` schedulers. Unfortunately there's a whole bunch of ceremony around how various schedulers are initialized which includes a mixed bag of public vs. non-public types and APIs which makes replacing them in a scheduler hook difficult.

I think the most easy way to accomplish this is the following:
- [x] ~~`RxThreadFactory` constructor overload which takes a thread priority to use.~~ Not needed.
- [ ] Factory methods on `Schedulers` for creating instances of `io()`, `computation()`, and `newThread()` except using a supplied `ThreadFactory`
  - [ ] `Schedulers.createIoScheduler(ThreadFactory)`
  - [ ] `Schedulers.createComputationScheduler(ThreadFactory)`
  - [ ] `Schedulers.createNewThreadScheduler(ThreadFactory)`

Nice to have:
- [x] `Schedulers` using these factory methods to create the default implementations. This involves moving the thread factories from the individual types "up" to `Shedulers`.,Happy to do some of the work if this sounds acceptable.
 =||= @JakeWharton I think that sound acceptable, I'm happy to review your PR.
 =||= This is a little more tricky than I had initially anticipated. Perhaps it's worth talking about a means of setting the default priority of the internal thread pools through a mechanism like properties as a separate, easier first step? Plus that would be a lot lower-overhead for Android users anyway, and we could even use the existing Android platform detection to lower the thread priority by default.
 =||= Pass a ThreadFactory

On Fri, Jan 20, 2017, 10:48 PM erDaren <notifications@github.com> wrote:

> so, how to set thread priority in android with android values(like
> Process.THREAD_PRIORITY_BACKGROUND)?
>
> —
> You are receiving this because you were mentioned.
>
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/3724#issuecomment-274242173>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEUOSEQqdFAeQocjdNnUfjwJ8gjubks5rUaorgaJpZM4Heynt>
> .
>
 =||= ,0
3883,3881,Single not calling doAfterTerminate when used in flatMap,I've noticed that when I return a Single from a flatMap and that Single calls doAfterTerminate(Action0) the Action0's call method is never called.  This behaviour is not consistent with what happens when you do the same thing with an Observable.  I am using 1.1.3

When I run:

``` java
Single.just("Test")
    .flatMap(s -> 
        Single.just("Test2")
            .doAfterTerminate(() -> System.out.println("singleFlatMapDoAfterTerminate"))
        )
.doAfterTerminate(() -> System.out.println("singleDoAfterTerminate"))
.subscribe(new TestSubscriber<String>());
```

I would expect the following to be printed to the console:

> singleDoAfterTerminate
> singleFlatMapDoAfterTerminate

However only the following is printed to the console

> singleDoAfterTerminate

When I do the same with an Observable

``` java
Observable.just("Test")
    .flatMap(s -> Observable.just("Test2")
        .doAfterTerminate(() -> System.out.println("observableFlatMapDoAfterTerminate"))
     )
.doAfterTerminate(() -> System.out.println("observableDoAfterTerminate"))
.subscribe(new TestSubscriber<String>());`
```

I see the following printed to the console:

> observableDoAfterTerminate
> observableFlatMapDoAfterTerminate,Interesting.
 =||= Thanks for reporting. See #3883 for a fix.
 =||= This works for me.
 =||= ,0
3886,388,Program using interval and take does not terminate,When I run the following snippet:

``` java
static Action1<Long> onNextFunc(final String who) {
    return new Action1<Long>() {
        public void call(Long x) {
            System.out.println(who + " got " + x);
        }            
    };
}
static Action1<Throwable> onErrorFunc(final String who) {
    return new Action1<Throwable>() {
        public void call(Throwable t) {
            t.printStackTrace();
        }            
    };
}    
static Action0 onCompleteFunc(final String who) {
    return new Action0() {
        public void call() {
            System.out.println(who + " complete");
        }            
    };
}
public static void main(String[] args) {
    Observable<Long> oneNumberPerSecond = Observable.interval(1, TimeUnit.SECONDS).take(5);
    oneNumberPerSecond.subscribe(onNextFunc("subscriber 1"), onErrorFunc("subscriber 1"), onCompleteFunc("subscriber 1"));
}
```

then I get (as expected) the following output:

```
subscriber 1 got 0
subscriber 1 got 1
subscriber 1 got 2
subscriber 1 got 3
subscriber 1 got 4
subscriber 1 complete
```

However, the program does not terminate, and that's unexpected.

I ran this test using `rxjava-core-0.13.2-SNAPSHOT.jar` built from commit 00d7c3b009053e6d5472f8bcb438e268a3d3c70b (Sat Sep 14 08:37:09 2013 -0700).

Due to this problem, some tests in the [`RxScalaDemo`](https://github.com/samuelgruetter/RxJava/blob/idiomaticscala/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala) that I'm working on do not terminate, which is annoying.,Just replicated it ... taking a look to see if I can find the cause.
 =||= The `OperationInterval` class was creating a new `ExecutorService` on every invocation, and that is never shut down, and launches non-daemon threads.

``` java
Schedulers.executor(Executors.newSingleThreadScheduledExecutor())
```

Changing that, the demo code now doesn't even run as the app quits immediately as it's all async (as it should).

I revised the example to use `BlockingObservable` for the demo (this and unit tests are where I generally use `BlockingObservable`) and it runs, then exits nicely.

``` java
    public static void main(String[] args) {
        Observable<Long> oneNumberPerSecond = Observable.interval(1, TimeUnit.SECONDS).take(5);
        oneNumberPerSecond.toBlockingObservable().forEach(onNextFunc("subscriber 1"));
    }
```

I'll submit a fix shortly.
 =||= Thanks, now it behaves as I'd expect, but the example I'd like to get to work still doesn't because of problems with groupBy https://github.com/Netflix/RxJava/pull/289#issuecomment-24738668 ...
 =||= ,0
3893,3892,java.lang.IllegalStateException: more items arrived than were requested,We're seeing this exception for a small percent of our users. We haven't been able to reproduce this ourselves so providing a sample might not be feasible. Any idea what could be causing this based on the stacktrace alone?

``` java
Non-fatal Exception: java.lang.IllegalStateException: more items arrived than were requested
       at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:206)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:129)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:107)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.onCompleted(OperatorMerge.java:268)
       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)
       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable.unsafeSubscribe(Observable.java:8741)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:125)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.emit(OperatorTakeLastOne.java:159)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:125)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)
       at rx.internal.operators.OperatorMerge$InnerSubscriber.onCompleted(OperatorMerge.java:836)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorSubscribeOn$1$1.onCompleted(OperatorSubscribeOn.java:68)
       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:76)
       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:43)
       at rx.Observable.unsafeSubscribe(Observable.java:8741)
       at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)
       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)
       at java.util.concurrent.FutureTask.run(FutureTask.java:237)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
       at java.lang.Thread.run(Thread.java:818)
```,Looks like `OnSubscribeToObservableFuture` was not refitted with backpressure support and it fires the future's value unconditionally. I'll post a fix for this. Thanks for reporting!
 =||= See #3893.

Workaround for now: apply `onBackpressureBuffer()` after the `from(Future)` you are using.
 =||= Great, thanks!
 =||= I think there might be other operators that need to be retrofitted? 

``` java
Non-fatal Exception: java.lang.IllegalStateException: more items arrived than were requested
       at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:206)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:129)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:107)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.onCompleted(OperatorMerge.java:268)
       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)
       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable.unsafeSubscribe(Observable.java:8741)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:125)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.emit(OperatorTakeLastOne.java:159)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:125)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)
       at rx.internal.operators.OperatorMerge$InnerSubscriber.onCompleted(OperatorMerge.java:836)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorOnBackpressureBuffer$BufferSubscriber.complete(OperatorOnBackpressureBuffer.java:169)
       at rx.internal.util.BackpressureDrainManager.drain(BackpressureDrainManager.java:187)
       at rx.internal.util.BackpressureDrainManager.terminateAndDrain(BackpressureDrainManager.java:114)
       at rx.internal.operators.OperatorOnBackpressureBuffer$BufferSubscriber.onCompleted(OperatorOnBackpressureBuffer.java:140)
       at rx.internal.operators.OperatorSubscribeOn$1$1.onCompleted(OperatorSubscribeOn.java:68)
       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:76)
       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:43)
       at rx.Observable.unsafeSubscribe(Observable.java:8741)
       at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)
       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)
       at java.util.concurrent.FutureTask.run(FutureTask.java:237)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
       at java.lang.Thread.run(Thread.java:818)
```
 =||= Do you have a default value on your single() operator?
 =||= We call `lastOrDefault` which calls `new OperatorSingle<T>(defaultValue)`.
 =||= Thanks, found the issue in OperatorSingle, when the default path is taken, the value is emitted without checking for backpressure. I'll post a fix soon.
 =||= See #3905.
 =||= Thanks!
 =||= Close via #3905
 =||= ,0
3905,3892,java.lang.IllegalStateException: more items arrived than were requested,We're seeing this exception for a small percent of our users. We haven't been able to reproduce this ourselves so providing a sample might not be feasible. Any idea what could be causing this based on the stacktrace alone?

``` java
Non-fatal Exception: java.lang.IllegalStateException: more items arrived than were requested
       at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:206)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:129)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:107)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.onCompleted(OperatorMerge.java:268)
       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)
       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable.unsafeSubscribe(Observable.java:8741)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:125)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.emit(OperatorTakeLastOne.java:159)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:125)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)
       at rx.internal.operators.OperatorMerge$InnerSubscriber.onCompleted(OperatorMerge.java:836)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorSubscribeOn$1$1.onCompleted(OperatorSubscribeOn.java:68)
       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:76)
       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:43)
       at rx.Observable.unsafeSubscribe(Observable.java:8741)
       at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)
       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)
       at java.util.concurrent.FutureTask.run(FutureTask.java:237)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
       at java.lang.Thread.run(Thread.java:818)
```,Looks like `OnSubscribeToObservableFuture` was not refitted with backpressure support and it fires the future's value unconditionally. I'll post a fix for this. Thanks for reporting!
 =||= See #3893.

Workaround for now: apply `onBackpressureBuffer()` after the `from(Future)` you are using.
 =||= Great, thanks!
 =||= I think there might be other operators that need to be retrofitted? 

``` java
Non-fatal Exception: java.lang.IllegalStateException: more items arrived than were requested
       at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:206)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:129)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:107)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.onCompleted(OperatorMerge.java:268)
       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)
       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable$2.call(Observable.java:233)
       at rx.Observable$2.call(Observable.java:225)
       at rx.Observable.unsafeSubscribe(Observable.java:8741)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)
       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:125)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.emit(OperatorTakeLastOne.java:159)
       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:125)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)
       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)
       at rx.internal.operators.OperatorMerge$InnerSubscriber.onCompleted(OperatorMerge.java:836)
       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)
       at rx.internal.operators.OperatorOnBackpressureBuffer$BufferSubscriber.complete(OperatorOnBackpressureBuffer.java:169)
       at rx.internal.util.BackpressureDrainManager.drain(BackpressureDrainManager.java:187)
       at rx.internal.util.BackpressureDrainManager.terminateAndDrain(BackpressureDrainManager.java:114)
       at rx.internal.operators.OperatorOnBackpressureBuffer$BufferSubscriber.onCompleted(OperatorOnBackpressureBuffer.java:140)
       at rx.internal.operators.OperatorSubscribeOn$1$1.onCompleted(OperatorSubscribeOn.java:68)
       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:76)
       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:43)
       at rx.Observable.unsafeSubscribe(Observable.java:8741)
       at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)
       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)
       at java.util.concurrent.FutureTask.run(FutureTask.java:237)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
       at java.lang.Thread.run(Thread.java:818)
```
 =||= Do you have a default value on your single() operator?
 =||= We call `lastOrDefault` which calls `new OperatorSingle<T>(defaultValue)`.
 =||= Thanks, found the issue in OperatorSingle, when the default path is taken, the value is emitted without checking for backpressure. I'll post a fix soon.
 =||= See #3905.
 =||= Thanks!
 =||= Close via #3905
 =||= ,0
3907,387,Zip calls onNext later than C#'s Zip does,In the C# example below, the zipped Observable completes as soon as o3 has completed, because all of o3's elements have been paired with an element from o6.

``` cs
static void Main() {
    var o3 = Observable.Interval(TimeSpan.FromMilliseconds(1000)).Take(3);
    var o6 = Observable.Interval(TimeSpan.FromMilliseconds(1000)).Take(10);

    var watch = new Stopwatch();
    watch.Start();

    Observable.Zip(o3, o6).Subscribe(
        list => Console.WriteLine("(" + list[0] + ", " + list[1] + ") at t=" + watch.ElapsedMilliseconds), 
        e => Console.WriteLine(e.StackTrace),
        () => Console.WriteLine("complete at t=" + watch.ElapsedMilliseconds)
    );
    Console.ReadLine();
}
```

outputs

```
(0, 0) at t=1055
(1, 1) at t=2045
(2, 2) at t=3047
complete at t=4058
```

In the corresponding Java code, however, the zipped Observable only completes once both o3 and o6 have completed.

``` java
static Func2<Long, Long, Long> zipFunc = new Func2<Long, Long, Long>() {
    public Long call(Long n1, Long n2) {
        if (n1.equals(n2)) {
            return n1;
        } else {
            throw new RuntimeException("numbers not equal");
        }
    }
};

public static void main(String[] args) {
    Observable<Long> o3 = Observable.interval(1000, TimeUnit.MILLISECONDS).take(3);
    Observable<Long> o6 = Observable.interval(1000, TimeUnit.MILLISECONDS).take(10);

    final long startTime = System.currentTimeMillis();

    Observable.zip(o3, o6, zipFunc).subscribe(
        new Action1<Long>() { public void call(Long n) { 
            System.out.println(n + " at t=" + (System.currentTimeMillis()-startTime));
        }},
        new Action1<Throwable>() { public void call(Throwable t) {
            t.printStackTrace();
        }},
        new Action0() { public void call() {
            System.out.println("complete at t=" + (System.currentTimeMillis()-startTime));
        }}
    );
}
```

outputs

```
0 at t=1019
1 at t=2019
2 at t=3019
complete at t=10019
```

I'd like RxJava to follow C# here, unless there are very good reasons against doing so.

This difference becomes even more important if one of the observables never completes: Then, the zipped Observable never completes either, which was very unexpected for me.,This unit test demonstrates the issue:

``` java
        @Test
        public void testOnFirstCompletion() {
            PublishSubject<String> oA = PublishSubject.create();
            PublishSubject<String> oB = PublishSubject.create();

            @SuppressWarnings("unchecked")
            Observer<String> observer = mock(Observer.class);

            Observable<String> o = Observable.create(zip(oA, oB, getConcat2Strings()));
            o.subscribe(observer);

            InOrder inOrder = inOrder(observer);

            oA.onNext("a1");
            inOrder.verify(observer, never()).onNext(anyString());
            oB.onNext("b1");
            inOrder.verify(observer, times(1)).onNext("a1-b1");
            oB.onNext("b2");
            inOrder.verify(observer, never()).onNext(anyString());
            oA.onNext("a2");
            inOrder.verify(observer, times(1)).onNext("a2-b2");

            oA.onNext("a3");
            oA.onNext("a4");
            oA.onNext("a5");
            oA.onCompleted();

            // assert we complete the zip stream here
            inOrder.verify(observer, times(1)).onCompleted();

            oB.onNext("b3");
            oB.onNext("b4");
            oB.onNext("b5");
            oB.onNext("b6");
            oB.onNext("b7");
            // never completes (infinite stream for example)

            // we should receive nothing else despite oB continuing after oA completed
            inOrder.verifyNoMoreInteractions();
        }
```
 =||= I need to play more with the C# version before I finish the changes, as fixing this unit test could be done in different ways, and the most obvious one breaks other unit tests.
 =||= Branch with unit test at https://github.com/benjchristensen/RxJava/commit/6921f729c76c9b6bc940e239d99181e93eba8406
 =||= Hello, I've ported my Zip implementation and it appears to be doing almost the expected behavior: https://github.com/akarnokd/RxJava/commit/cd0a5e7ec27169816738f63547289102f2044639

0 at t=1016
1 at t=2016
2 at t=3017
complete at t=3017

The difference to Rx seems to be that it terminates right after the 3rd item whereas Rx.NET after rejecting the 4th item of the second observable.
 =||= I believe this is fixed in https://github.com/Netflix/RxJava/pull/510 thanks to @akarnokd 
 =||= ,0
3922,3921,Possible resource leak in OnSubscribeUsing,Hi.
I am considering using of RxJava to represent REST API responses so was looking into the sources to understand how stuff works. In the OnSubscribeUsing operator there is something that looks like a logic error to me that may lead to leaking resources.

(I am reporting "theoretical" issue, I have not tried actually making it happen. Also, I have almost zero knowledge on how RxJava works so can be really missing something. Sorry about that in advance)

So in https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OnSubscribeUsing.java the call() method allocates resource the first thing and then creates Observable, attaches dispose handler etc. In the end it calls unsafeSubscribe handling for the potential exception.
But what if exception happens earlier? Imagine the resource was allocated successfully but observableFactory.call(resource) throws for example. There seems to be nothing to dispose the resource in that case.

Again. I have no deep understanding of RxJava but it looks to me that resource disposal should be happening in the top level try/finally block if resource was allocated but doOnTerminate has not been installed yet (or failed to install). I would probably just remove the inner try/catch and did all the handling at the top level (possibly setting some boolean to indicate that stuff actually started so no cleanup needed).

Cheers,Thanks for reporting! This is indeed a bug and I've posted a fix PR #3922 for it.
 =||= Oh that was quick. Impressive )
Just out of curiosity - is it kind of implied that thing like 

``` java
 subscriber.add(disposeOnceOnly);
```

always succeed and cannot throw? As well as doOnTerminate / doAfterTerminate.
Isn't it safer to always do dispose in a big finally block _unless_ unsafeSubscribe was successful? That would probably also simplify exception handling as now you have two identical copy&paste blocks...

Sorry if I am asking nonsense - really unfamiliar with the framework right now.

PS: you also have a semicolon following .doAfterTerminate(disposeOnceOnly) on a separate line - probably a typo.
 =||= The Observable can complete outside the method so the classical imperative try-finally doesn't work.
 =||= For the completion outside the method you install these doOnTerminate / doAfterTerminate "callbacks". I was only talking on what can happen inside OnSubscribeUsing.call method. You already have something like

``` java
    public void call(final Subscriber<? super T> subscriber) {
        try {
            final Resource resource = resourceFactory.call();
            // ... do some stuff ...
            try {
                // ... create Observable via factory
            } catch (Throwable e) {
                // ... release resource and do some sophisticated exception handling ...
                return;
            }
            // ... do some stuff ...
            // ... install doOnTerminate / doAfterTerminate hooks
            try {
                // ... unsafeSubscribe
            } catch (Throwable e) {
                // ... release resource and do some sophisticated exception handling ...
                return;
            }

        } catch (Throwable e) {
            // ... some high level exception handling ...
        }
    }
```

So my concerns here are:
- you have two try/catch blocks inside that look very similar to me 
- still exception can (in theory) happen on a line not covered by those blocks - one of "do some stuff" ones in the example above

So I though maybe these inner try/catch can be avoided completely in favour of one bit try/catch/finally

``` java
    public void call(final Subscriber<? super T> subscriber) {
        Resource resource = null;
        try {
            resource = resourceFactory.call();
            // ... do some stuff ...
            // ... do some stuff ...
            // ... install doOnTerminate / doAfterTerminate hooks
            // ... unsafeSubscribe
            subscribed = true;
        } catch (Throwable e) {
            // ... error reporting
        } finally {
            if (!subscribed) {
                // we are returning with exception so subscribe was not successful, dispose resource
            }
        }
    }
```

it does not have to be finally block given that you catching Throwable - it is safe to release it in "catch".. Just saying...
 =||= Fixed in #3922. If you think you can clean up the code, PR is welcome.
 =||= ,0
3924,3923,Should RxRingBuffer's validator really be on the computation scheduler?,I just helped debug an issue where some Android robolectric tests timed out after upgrading from 1.1.1 to 1.1.5 due to https://github.com/ReactiveX/RxJava/commit/ef1d418f43e55eafb1cf9f09d13f37afb5b80b84

As it turned out, they were replacing the computation scheduler with immediate via RxJavaPlugins. The new commit caused RxRingBuffer.SIZE to load the RxRingBuffer class in any call to observeOn, which in turn created its ObjectPools, which in turn ran their start() which sets up a periodic scheduling on the computation thread. This caused the tests to hang indefinitely because of the repeated SleepingActions triggered by the validation tasks.

So, since RxRingBuffer can be loaded in various places by Rx internally, that seems to make it a lot more difficult to reliably replace the computation scheduler, particularly with immediate. I recommended against the immediate override in this case, but using a test scheduler wasn't really helping in this scenario either, although I am unfamiliar with that codebase and didn't have time to dive too deep into why. Short term fix for this particular case was to call observeOn with a size constant to sidestep the RxRingBuffer load in these tests, until we can clean up the underlying scheduler plugin overrides. However, I'm wondering if maybe internal scheduling things like this should have their own scheduler? Maybe an internal computation scheduler that could be an additional override in the schedulers hook. That would allow them to run unhindered in most cases despite computation being overridden, but in extreme cases they could be overridden as well.,Btw, I can write the PR for this once a decision is made, but I thought it deserved a little discussion of what the right fix is before I jump to an implementation.
 =||= This came up recently in another forum to the same effect but I never followed up here. But :+1: to something that doesn't pass through user code in such a dangerous way.
 =||= Yep, they have a cyclic dependency. I believe the `ObjectPool`s can be switched to `GenericScheduledExecutorService`. Let me write up a PR.
 =||= See #3924.
 =||= Fix merged in #3924.
 =||= ,0
3928,392,Add a way to stop an Observable executed in another thread,Function may take time to be executed.

This work can be realised on another thread as showed in this post from @mttkay blog:
http://mttkay.github.io/blog/2013/08/25/functional-reactive-programming-on-android-with-rxjava/

In particular this snipset let the work be done on a different thread that the main one:

``` java
    subscription = downloadFileObservable()
                          .subscribeOn(Schedulers.newThread())
                          .observeOn(AndroidSchedulers.mainThread())
                          .subscribe(this);
```

However, if we stop the activity, and unsubscribe the observable before exiting, the obsevable (or the function mapped...) will finish, try to send its work somewhere and notice there is no one to take care of it. 

Then it will make the entire application crash.

If we had a way to stop a work before it finished we would be able to manage many more asynctask cases.

May be this is going to be released soon (from the same blog entry)

```
For instance, we use a custom Observer which makes guarantees that callbacks to fragments only happen whenever the fragment is attached and the Activity is alive, thus making your own code more reliable.
```

If not... it should!

Regards

An idea of solution: I think it may be possible to use the Subscription object returned by an observable to add the needed code to stop the work in the unsubscribe method... But I don't have any idea how to reach the Thread (Scheduler class has no method to stop the created thread or to reach it) where the observable is executed...,>  if we stop the activity, and unsubscribe the observable before exiting, the obsevable (or the function mapped...) will finish, try to send its work somewhere

I would argue that if it tries to emit items even though you unsubscribed, your subscription function is broken. You as the developer need to ensure that the subscription's unsubscribe method acts appropriately in the context of your observable.

The safe observer we wrote mitigates this and removes some of the burden involved in littering your code with calls to `isUnsubscribed` by keeping a weak reference to the fragment, and not firing the callback if it has been detached meanwhile.
 =||= Hi matthias,

Thank you for answering.

I am very new to Rx thing, so may be I don't get obvious things.

When I call unsubscribe method on the subscriber object I stop my activity
from listening but I don't stop the observable from working, am I right?

The subscriber object returned from the observable is the one obtained with
the factory Observers. Empty ()

(I am writing from my phone so may be the names are not exacts.)

To reach this purpose I need to have something to stop the work inside the
unsubscribe method, am I true?

I saw an example on the Rx wiki which call interrupt method on the thread
where the work is done inside rhetoric observable.

But if I use the Android scheduler provided in the Android project, then I
can't reach the thread where the work is done.

I am wondering if I am doing something really wrong.

Another related question, say I am working on a list so I create the
observable using the factory method from(list). Then I map my functions on
it.

Even if I insert a kind of system to stop the current work, it will then
jump to the next item of the observable? And so another work will start.

The wiki is full of explanation about how the observable works and can be
filtered, transformed but there is not so many thing about basic things...
 =||= > The wiki is full of explanation about how the observable works and can be
> filtered, transformed but there is not so many thing about basic things...

What basic things are you referring to that you would like to see on the wiki?
 =||= @benjchristensen I am thinking to things related of how to create an Observable.

In the wiki, methods are listed (from, create...) but the subscription part is missing.

In particular, it took me time to realize that onCompleted is not call if you use Observable.create() method.

I ve found the reason on StackO (http://stackoverflow.com/questions/13561842/rx-for-net-when-calling-observer-oncompleted-from-within-disposable-create-no).

I am still wondering what to put in Subscription object that I return in my Observable because it seems the method unsubscribe() is never called too. May be I need to only use Subscriptions.empty() method only... (I unsubscribe() after the end of the process, probably the reason why it s not called...).

Moreover I find some part a bit misleading, there are Scheduler to manage async call, but on the Wiki (https://github.com/Netflix/RxJava/wiki/How-To-Use#asynchronous-observable) one example use a thread to manage it.

Again I am still a newbee in the Rx technology. In my first tries I really used Rx as a new way to manage thread. Now I have a better understanding of how it works, (was not difficult compared to a 0 level), but I have still many questions.

Listing all the methods to build a flow is cool, but some words about how it works inside, just to let the user put its code where he has to put it would be nice too :-)

However may be I am missing obvious documentation...

@mttkay Hi, would it be possible for you to share a simple snipset / write a short blog entry about your custom Observer, just to give an idea of what you did?

Regarrds
 =||= @benjchristensen regarding the Wiki, I have spent lots of time on website dedicated to Rx for C# to learn about this technology.

I think in general one important thing is missing, real examples!

I know each important method has its own example, but some more general example are still missing, showing simple cases using several method.

It has not to be super complex for the love of complexity but real cases showing what is possible to do.

I really enjoy to read and play with this technology, I am still at a beginner level but I know enough to understand how powerful it is.

To get at this point, I had to Google a lots of things. I have some time right now so that's Ok for me. But to reach a new audience of busy programmers knowing nothing about reactive programming, putting all example in the same Wiki, just to give an idea what kind of problem this technology solves would help. And I am sure more people using RxJava means more improvements.

And by the way, some Java code would be nice too. I mean I can read C#, Scala or whatever, but Java is the language I use (and most people too) :-)

Thank you anyway for all the work you/your company/other companies have put in this work, that's really awesome. Long time I have not seen something interesting like that!

Regards
 =||= I agree that there are not yet enough Rx examples in Java and for the other JVM languages, but, hey, RxJava is still being created, you're joining the adventure, not consuming a finished product ;-)

However, for C#, there are great resources to learn Rx, such as [introtorx](http://www.introtorx.com/) and the [Rx Workshop Videos](http://channel9.msdn.com/Series/Rx-Workshop). For RxJava, this does not yet exist...

IMHO the only way to learn RxJava now is to start with C#, and to try to translate C# examples to Java. If you do so, please publish your examples somewhere, so that for other people, it will be easier to learn RxJava than it was for you.

You can find my few little examples [here](https://github.com/samuelgruetter/rx-playground/blob/master/README.md), but they're mostly in Scala.
 =||= @pommedeterresautee Is this issue considered resolved? Should there be any further actions (other than more code examples) out of this?
 =||= For me it's ik
 =||= ,0
3941,3940,toSingle() leaks subscriber if followed by flatmap.,Not sure this is a correct test, let me know if I can provide any extra information.

```
    private Subscriber<? super Object> subscriber;

    @Test public void thisTestPasses() throws Exception {

        final Subscription subscribe = Observable.create(subscriber -> {
            this.subscriber = subscriber;
        }).subscribeOn(Schedulers.io()).flatMap(o -> Observable.just("")).toSingle().subscribe();

        subscribe.unsubscribe();

        assertThat(subscriber.isUnsubscribed()).isTrue();
    }

    @Test public void thisTestFails() throws Exception {

        final Subscription subscribe = Observable.create(subscriber -> {
            this.subscriber = subscriber;
        }).subscribeOn(Schedulers.io()).toSingle().flatMap(o -> Single.just("")).subscribe();

        subscribe.unsubscribe();

        assertThat(subscriber.isUnsubscribed()).isTrue();
    }
```,Thanks for reporting. Indeed, this is a bug in `Single.flatMap`. Fix PR in #3941 .
 =||= ,0
3942,3938,1.x: Add missing error handler call in Completable,nan,Why do you think it's missing? In operators, only undeliverable exceptions are supposed to be sent to the global handler.
 =||= I'm not pretty sure if this call to the handler goes there. But it arises from using the Retrofit's RxJava adapter, and realizing that Completable's endpoints errors are not caught by an error handler, while Observable's and Single's are.
 =||= Interesting, could be that Completable doesn't use SafeSubscriber, which is responsible to deliver some errors thrown by onXXX methods. To be sure, could you add a unit test that demonstrates how Single gets your exception and how Completable isn't?
 =||= Okey
 =||= I think this comment is related: [Completable.java#L1968](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Completable.java#L1968). From what I see, `Completable`, in a different way to `Observable` and `Single`, does calls to the error handler plugin by itself, instead of delegating it to a `SafeCompletableSubscriber` (which btw doesn't exist). Why there is no safe subscriber for `Completable` and why is this done this way?

The call to the handler is missing from `onError` in `subscribe(Action1<? super Throwable>, Action0)`, `subscribe(CompletableSubscriber)` and `subscribe(Subscriber)` methods, but `subscribe()` and `subscribe(Action0)` have it. This should be refactored to have just one place for calling the handler, as in `Observable` and `Single`.
 =||= Completable was designed with a modern mindset where end-CompletableSubscribers are not expected to throw from the onXXX methods, but apparently, there was no safeSubscribe() added to the API. The current 1.x convention is to have subscribe() do additional safeguards and have an unsafeSubscribe() as direct as possible.
 =||= See #3942 for other forms of handling errors.
 =||= Closing via #3942
 =||= ,0
3948,3947,Request: Completable.andThen(Completable),To match `Completable#andThen(Observable<T> next)` and `Completable#andThen(Single<T> next)` it would be nice if there were an operator like this:

`Completable#andThen(Completable next)`.

Unless there is some other way to achieve the same functionality right now.,There is the `endWith` operator for this purpose, but you can post a PR renaming it.
 =||= @akarnokd thanks for the quick reply. Posted a PR for that. Just a quick question what about `endWith(Observable<T> next)` should that stay or should there also be `andThen` used?
 =||= You can deprecate that as well.
 =||= Alright thanks. I updated the PR let me know whether I should squash commits and change commit message to match the new updated title or whether you'll use the GitHub squash and merge functionality.
 =||= No need for squashing on your end.
 =||= Closing via #3948
 =||= ,0
3958,2656,just(T) : RxJavaObservableExecutionHook not called,When using rx.Observable.just(T) the RxJavaObservableExecutionHook is not call.

This is not like other just(T,...) that call rx.Observable.from(Iterable<? extends T>).,Thanks for the report. 
 =||= @abersnaze Since this probably affects work you're doing as well, can you take a look at what we need to fix here? It will be anything using the internal ScalarSynchronousObservable optimization I think. 
 =||= sure.
 =||= What is the status of this issue? I've lost track of the proposed changes to `ScalarSynchronousObservable`.
 =||= See #3958.
 =||= Closing via #3958
 =||= ,0
3966,3779,withLatestFrom interface inconsistent with combineLatest,Why withLatestFrom has only 1 calling signature while combineLatest has plenty of convenient overload for combining multiple observables.  
Should it be the same or this is by design?,How would you imagine those missing forms of `withLatestFrom`, especially in their behavior?
 =||= Does this make sense?

```
a$.withLatestFrom(b$, c$, d$, new Func4<a,b,c,d>{
// use a, b, c, d relying on timing emit by a only
});
```
 =||= Would you like to submit a PR?
 =||= I would love to if I have some spare time.  
I look into the code a bit and found out that combineLatest is just thin wrapper of OnSubscribeCombineLatest factory inside Observable class.  
The test is done on OnSubscribeCombineLatest class itself the factory methods are untested.  

It will be trivial if I can just create an overload by the calling exist (current) withLatestFrom method multiple times to aggregate the value one by one in Observable class without additional test on the overloads.  

Is this the way to go?  
If yes you can expect me to send the PR eventually.
(Don't know when. If anyone want it fast feel free to pick it up. It is just convenient overloads after all we can continue working without it.)  
If no please give me your opinion about my proposed method. At least I will learn a thing or two from this issue. 
 =||= No, you have to work from `withLatestFrom` with more sources, subscribers and current values.
 =||= Yep that's the reply I expected.
By looking at the code I have to integrate Iterable into the operator class.

For sure it will be easier than CombineLatest implementation but I don't know concurrency concerns and proper way (exist method/pattern) to handle it inside RxJava that well.
So it will require more time digging into the code I don't even sure if I am able to do it.

So I will say don't expect PR from me anytime soon.
Thank you for your feedback.
 =||= Do you have an use case for such an operator? I'd say it is uncommon and I'd guess the original [request](https://github.com/ReactiveX/RxJava/issues/405) for `withLatestFrom` didn't mention a multi-source version.

You can achieve an effect with some tuple types:

``` java
source.withLatestFrom(b, (a, b) -> Pair.of(a, b))
.withLatestFrom(c, (ab, c) -> func.call(ab.a, ab.b, c))
```
 =||= Sorry for the delay.
Yes this is coming from a real use case.
I use withLatestFrom heavily to handles Observable from user. (e.g. button pressed)

The actual case I am facing is a bit complicate but I can give you one common concrete case of multiple withLatestFrom usage. It is for handle (says) form validation and submit.

If all fields in form are valid the submit button will be enabled and when user press submit button all value emit from field observables will form the server request.
withLatestFrom will be used for field observables compilation based on timing of button press in this case.

Thank you for Pair suggestion but I already go with SparseArray (List, Map will work the same way too but SparseArray just fit the bill in my case) the downsize is losing type safety but it is so local so I am OK with it.
 =||= I also have a use case for that. Basically I want to get latest state of several observables when main 'trigger' event happens.

I approached it by creating observable that is `combineLatest` of all the 'secondary' observables; and then used it as an argument for `withLatestFrom`. Unfortunately it involved creating of mostly useless holder object just to feed last items of several observables into `withLatestFrom`.

I guess the better way would be to use `combineLatest` chained by `distinctUntilChanged(selector)` where selector would return items of 'trigger' observable.
 =||= I have a use case for this in the current project. I am using reactive sensors to keep track of motion, position, env, and location sensors. Location sensor is the driving sensor. Others use `.window(locationObservable)` to then compute min, max, avg for the windowed list for x, y, z. Because location is the driver, I was hoping that I could do:

`locationObservable.withLatestFrom(positionObs, motionObs, envObs, (location, position, motion, env) -> SensorPoint::new)...`

But it only takes just one observable.
 =||= See #3966.
 =||= Added via #3966.
 =||= ,0
3971,3964,1.x: observeOn + immediate scheduler to be a request rebatcher,This PR removes the `immediate()` scheduler "optimization" from `observeOn` and treats it as a common scheduler. Since `observeOn` has a stable request pattern, this turns it into a rebatching operator. No matter what the downstream requests, the upstream will requests of the specified size (with 25% as low water mark; i.e., replenishment after 75%). Since `immediate` is synchronous, this will run the drain loop, non-reentrant, on the caller thread.

I found this mode of operation very handy in my Reactive-RPC prototype and a simple streaming echo RPC call; it prevents going unbounded and bloating the message sender threads:

``` java
// remote
public Observable<Integer> echo(RpcStreamContext<?> ctx, Observable<Integer> in) {
   return in.observeOn(Schedulers.immediate(), 16);
}

// client
api.echo(Observable.range(1, 100_000)).observeOn(Schedulers.immediate(), 32)
.subscribe(System.out::println, Throwable::printStackTrace);
```,Great! What about adding a method to `Observable` that calls it so this functionality is discoverable? Say `Observable.batchRequests(n)`?
 =||= That could be a follow-up PR if this gets accepted.
 =||= Why not just adding a `batchRequests` operator instead of changing the existing behavior? This probably affects some users' applications if they depends on the optimization.

Secondly, using `observeOn(Schedulers.immediate(), 16)` and assuming how it implements is not reliable. This is not an API contract and it could be changed in any time.
 =||= The alternative requires duplicating code, which triggers more outcry usually...
 =||= I think you can add a flag (e.g., disallowOptimization) to `OperatorObserveOn` and use it for `batchRequests`.
 =||= ,0
3974,3576,Clarify behaviour in JavaDoc of switchOnNext() with respect to completions,The JavaDoc of `switchOnNext()` doesn't currently say anything about how the resulting Observable will complete. 

The marble diagram implies (but not totally clearly) that if an inner Observable completes after an outer `onNext()`, that completion is swallowed, and if an inner Observable completes after the outer Observable completes, that the resulting Observable also completes.

However, there's no info about what happens in an inner Observable completes _before_ an outer `onNext()`. Does the resulting Observable complete at that point or not?

I've read the tests, and it seems the answer is that the resulting Observable will complete exactly when the following happen, in this order:
1. the outer Observable completes (implying that the current inner Observable will never be switched to any other);
2. the current inner Observable completes.

And that the resulting Observable won't complete under any other circumstances.

Firstly, is my understanding correct, and secondly, can the JavaDoc be improved?,If I have understood things correctly, I'd be happy to submit a PR clarifying the JavaDoc.
 =||= PRs are welcome!
 =||= See #3974 
 =||= ,0
3977,3679,Actual exception is being hidden by OnErrorFailedException,Using RxJava 1.10 (and similar issue on 1.0.15), I stumbled upon a mysterious stack trace that made no sense in my app, after a lot of debugging, I found that RxJava will report the wrong exception in some scenarios. For example, if you run this sample code:

```
Observable.just(1).doOnNext(new Action1<Integer>() {
        @Override public void call(Integer val) {
            throw new IllegalStateException("doOnNextException");
        }
    }).retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {
        @Override public Observable<?> call(Observable<? extends Throwable> errorObservable) {
            return errorObservable.flatMap(new Func1<Throwable, Observable<?>>() {
                @Override public Observable<?> call(Throwable throwable) {
                    return Observable.just(3).delay(1, TimeUnit.SECONDS).doOnNext(
                            new Action1<Integer>() {
                                @Override public void call(Integer integer) {
                                    throw new UnsupportedOperationException("retry exception");
                                }
                            });
                }
            });
        }
    }).subscribe(new Subscriber<Integer>() {
        @Override public void onCompleted() {
            Log.v("EX", "onCompleted");
        }

        @Override public void onError(Throwable e) {
            Log.v("EX", "onError");
            throw new IllegalThreadStateException();
        }

        @Override public void onNext(Integer integer) {
            Log.v("EX", "onNext");
        }
    });
```

The expected behaviour should be that `IllegalThreadStateException` (thrown within the `onError` handler of the subscriber) is included as the cause. However, the actual stack trace contains `UnsupportedOperationException` as the cause - which is not the problem in the code snippet above. the `UnsupportedOperationException` is totally fine, but the problem arises when `onError` throws.

This leads to a stack trace that points to the wrong cause and does not include the actual cause (which would be the `IllegalThreadStateException`). If I removed the `retryWhen()` block - then the stack trace correctly includes `IllegalThreadStateException` as the exception from within `onError`.

The (incorrect) trace from the code snippet above:

```
Process: com.example.mydemoapp, PID: 14118
java.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:62)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)
    at java.util.concurrent.FutureTask.run(FutureTask.java:237)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
    at java.lang.Thread.run(Thread.java:818)
 Caused by: rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError
    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:194)
    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)
    at rx.internal.operators.OnSubscribeRedo$4$1.onError(OnSubscribeRedo.java:331)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:240)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:776)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:537)
    at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:526)
    at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:810)
    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:71)
    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)
    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82)
    at rx.internal.operators.OperatorDelay$1$3.call(OperatorDelay.java:88)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) 
    at java.util.concurrent.FutureTask.run(FutureTask.java:237) 
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) 
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) 
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) 
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) 
    at java.lang.Thread.run(Thread.java:818) 
 Caused by: rx.exceptions.CompositeException: 2 exceptions occurred. 
    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:194) 
    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120) 
    at rx.internal.operators.OnSubscribeRedo$4$1.onError(OnSubscribeRedo.java:331) 
    at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:240) 
    at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:776) 
    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:537) 
    at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:526) 
    at rx.internal.operators.OperatorMerge$InnerSubscriber.onError(OperatorMerge.java:810) 
    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:71) 
    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187) 
    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82) 
    at rx.internal.operators.OperatorDelay$1$3.call(OperatorDelay.java:88) 
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) 
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) 
    at java.util.concurrent.FutureTask.run(FutureTask.java:237) 
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) 
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) 
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) 
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) 
    at java.lang.Thread.run(Thread.java:818) 
 Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>
    at android.util.Log.getStackTraceString(Log.java:504)
    at com.android.internal.os.RuntimeInit.Clog_e(RuntimeInit.java:59)
    at com.android.internal.os.RuntimeInit.access$200(RuntimeInit.java:43)
    at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:91)
    at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)
    at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:66)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) 
    at java.util.concurrent.FutureTask.run(FutureTask.java:237) 
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) 
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) 
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) 
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) 
    at java.lang.Thread.run(Thread.java:818) 
 Caused by: java.lang.UnsupportedOperationException: retry exception
    at com.example.mydemoapp.MainActivity$3$1$1.call(MainActivity.java:74)
    at com.example.mydemoapp.MainActivity$3$1$1.call(MainActivity.java:72)
    at rx.Observable$11.onNext(Observable.java:4445)
    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:80)
    at rx.internal.operators.OperatorDelay$1$3.call(OperatorDelay.java:88)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) 
    at java.util.concurrent.FutureTask.run(FutureTask.java:237) 
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) 
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) 
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) 
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) 
    at java.lang.Thread.run(Thread.java:818) 
 Caused by: rx.exceptions.OnErrorThrowable$OnNextValue: OnError while emitting onNext value: 3
    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)
    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82)
    at rx.internal.operators.OperatorDelay$1$3.call(OperatorDelay.java:88) 
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) 
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422) 
    at java.util.concurrent.FutureTask.run(FutureTask.java:237) 
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152) 
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265) 
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) 
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) 
    at java.lang.Thread.run(Thread.java:818) 
```,You shoudn't throw from `Observer.onError` or `Subscriber.onError` but there are safeguards which have to wrap exceptions and deliver it somewhere upstream.
 =||= > You shoudn't throw from Observer.onError or Subscriber.onError but there are safeguards which have to wrap exceptions and deliver it somewhere upstream.

This is just an example to illustrate the problem, my point was not that there shouldn't be exception, my point is that the cause exception that `OnErrorFailedException` wraps is the wrong exception and not the cause.

Instead the log is of an exception which is already handled. This is confusing and can take a lot of time to understand and to find the actual cause.

For example, in my app there is a rare bug somewhere inside my `onError` handler, which causes an exception, but I don't know which line inside my handler throws or what exception it throws because I do not see the actual stack trace. Instead I see the error that caused the `onError` to be invoked.

If you run the same example above with the `retryWhen` removed, you get the correct exception (note **IllegalStateException** is at the bottom of the stack trace, while in the first stack trace above the already-handled **UnsupportedOperationException** is at the bottom of the stack trace):

```
rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError
    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:194)
    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)
    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:71)
    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)
    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)
    at rx.Observable$2.call(Observable.java:162)
    at rx.Observable$2.call(Observable.java:154)
    at rx.Observable.subscribe(Observable.java:8191)
    at rx.Observable.subscribe(Observable.java:8158)
    at com.example.mydemoapp.MainActivity.testRetryError(MainActivity.java:65)
    at com.example.mydemoapp.MainActivity.onOptionsItemSelected(MainActivity.java:53)
    at android.app.Activity.onMenuItemSelected(Activity.java:2908)
    at android.support.v4.app.FragmentActivity.onMenuItemSelected(FragmentActivity.java:361)
    at android.support.v7.app.AppCompatActivity.onMenuItemSelected(AppCompatActivity.java:147)
    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100)
    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100)
    at android.support.v7.app.ToolbarActionBar$2.onMenuItemClick(ToolbarActionBar.java:68)
    at android.support.v7.widget.Toolbar$1.onMenuItemClick(Toolbar.java:172)
    at android.support.v7.widget.ActionMenuView$MenuBuilderCallback.onMenuItemSelected(ActionMenuView.java:760)
    at android.support.v7.view.menu.MenuBuilder.dispatchMenuItemSelected(MenuBuilder.java:811)
    at android.support.v7.view.menu.MenuItemImpl.invoke(MenuItemImpl.java:152)
    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:958)
    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:948)
    at android.support.v7.view.menu.MenuPopupHelper.onItemClick(MenuPopupHelper.java:191)
    at android.widget.AdapterView.performItemClick(AdapterView.java:310)
    at android.widget.AbsListView.performItemClick(AbsListView.java:1145)
    at android.widget.AbsListView$PerformClick.run(AbsListView.java:3042)
    at android.widget.AbsListView$3.run(AbsListView.java:3879)
    at android.os.Handler.handleCallback(Handler.java:739)
    at android.os.Handler.dispatchMessage(Handler.java:95)
    at android.os.Looper.loop(Looper.java:148)
    at android.app.ActivityThread.main(ActivityThread.java:5417)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)
 Caused by: rx.exceptions.CompositeException: 2 exceptions occurred. 
    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:194) 
    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120) 
    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:71) 
    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187) 
    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82) 
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46) 
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35) 
    at rx.Observable$2.call(Observable.java:162) 
    at rx.Observable$2.call(Observable.java:154) 
    at rx.Observable.subscribe(Observable.java:8191) 
    at rx.Observable.subscribe(Observable.java:8158) 
    at com.example.mydemoapp.MainActivity.testRetryError(MainActivity.java:65) 
    at com.example.mydemoapp.MainActivity.onOptionsItemSelected(MainActivity.java:53) 
    at android.app.Activity.onMenuItemSelected(Activity.java:2908) 
    at android.support.v4.app.FragmentActivity.onMenuItemSelected(FragmentActivity.java:361) 
    at android.support.v7.app.AppCompatActivity.onMenuItemSelected(AppCompatActivity.java:147) 
    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100) 
    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100) 
    at android.support.v7.app.ToolbarActionBar$2.onMenuItemClick(ToolbarActionBar.java:68) 
    at android.support.v7.widget.Toolbar$1.onMenuItemClick(Toolbar.java:172) 
    at android.support.v7.widget.ActionMenuView$MenuBuilderCallback.onMenuItemSelected(ActionMenuView.java:760) 
    at android.support.v7.view.menu.MenuBuilder.dispatchMenuItemSelected(MenuBuilder.java:811) 
    at android.support.v7.view.menu.MenuItemImpl.invoke(MenuItemImpl.java:152) 
    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:958) 
    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:948) 
    at android.support.v7.view.menu.MenuPopupHelper.onItemClick(MenuPopupHelper.java:191) 
    at android.widget.AdapterView.performItemClick(AdapterView.java:310) 
    at android.widget.AbsListView.performItemClick(AbsListView.java:1145) 
    at android.widget.AbsListView$PerformClick.run(AbsListView.java:3042) 
    at android.widget.AbsListView$3.run(AbsListView.java:3879) 
    at android.os.Handler.handleCallback(Handler.java:739) 
    at android.os.Handler.dispatchMessage(Handler.java:95) 
    at android.os.Looper.loop(Looper.java:148) 
    at android.app.ActivityThread.main(ActivityThread.java:5417) 
    at java.lang.reflect.Method.invoke(Native Method) 
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726) 
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) 
 Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>
    at android.util.Log.getStackTraceString(Log.java:338)
    at com.android.internal.os.RuntimeInit.Clog_e(RuntimeInit.java:61)
    at com.android.internal.os.RuntimeInit.-wrap0(RuntimeInit.java)
    at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:86)
    at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)
    at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)
 Caused by: java.lang.IllegalStateException: doOnNextException
    at com.example.mydemoapp.MainActivity$3.call(MainActivity.java:63)
    at com.example.mydemoapp.MainActivity$3.call(MainActivity.java:61)
    at rx.Observable$11.onNext(Observable.java:4445)
    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:80)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)
    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)
 at rx.Observable$2.call
```
 =||= Simpler way to reproduce is to just throw within a `doOnError()` - the exception that is thrown is swallowed and is not part of the causal chain.

```
    Observable.just(1).doOnNext(new Action1<Integer>() {
        @Override public void call(Integer val) {
            throw new IllegalStateException("doOnNextException");
        }
    }).doOnError(new Action1<Throwable>() {
                @Override public void call(Throwable throwable) {
                    throw new UnsupportedOperationException("onError exception");
                }
    }).subscribe(new Subscriber<Integer>() {
        @Override public void onCompleted() {
            Log.v("EX", "onCompleted");
        }

        @Override public void onError(Throwable e) {
            Log.v("EX", "onError");
            throw new IllegalThreadStateException();
        }

        @Override public void onNext(Integer integer) {
            Log.v("EX", "onNext");
        }
    });
```
 =||= I see this issue too. When I see logs via crashlytics the stacktrace just shows the composite exception but not the details of the actual crash in `onError()`. I see there's a bug in `CompositeException.java`. Fixing in a new PR
 =||= Closing via #3977
 =||= ,0
3981,3960,zip(o1, o2) doesn't unsubscribe from o1,A simple example, looks ok

``` java
Observable<Integer> o1 = Observable.just(1)
    .doOnCompleted(() -> System.out.println("o1 completed"));

Observable<Integer> o2 = Observable.just(1, 2, 3, 4)
    .doOnCompleted(() -> System.out.println("o2 completed"));

Observable.zip(o1, o2, (integer1, integer2) -> null).subscribe();
```

Output:

```
o1 completed
```

Now swap o1 and o2

``` java
Observable<Integer> o1 = Observable.just(1, 2, 3, 4)
    .doOnCompleted(() -> System.out.println("o1 completed"));

Observable<Integer> o2 = Observable.just(1)
    .doOnCompleted(() -> System.out.println("o2 completed"));

Observable.zip(o1, o2, (integer1, integer2) -> null).subscribe();
```

Output:

```
o1 completed
o2 completed
```,Zip uses a prefetch of 128 elements by default. Since both sources are synchronous, the second case takes all 4 from the first source, including completion, then moves onto `o2` which first emits 1, then its completion completes the whole sequence. Thus, you see both doOnCompleted executed.

The first case, `o1` signals 1 and completion, then once `o2` signals its 1, it is known `o2` won't ever signal more values, thus `o2` gets unsubscribed and never allowed to run to completion.

Both are the expected behavior. If you need resource cleanup associated with a sequence, you can't rely on doOnCompleted as sequences may get unsubscribed before that.
 =||= I see, but isn't this implementation details?
 =||= It is the explanation for what you experienced. The `zip` javadoc has this clause:

> The resulting `Observable<R>` returned from `zip` will invoke `Observer#onNext`
> as many times as the number of `onNext` invocations of the source Observable that emits the fewest
> items.

Since `zip`'s behavior seems to be confusing, maybe we could add a clause that `zip` completes eagerly if one of the sources emits fewer elements than the others and unsubscribes the rest.
 =||= I agree that docs should be updated. Although the new clause you suggested needs to be more accurate:
1. Examples in this issue contradict it
2. If source observables emit equal number of elements (and not fewer), some (which? this one really bothers me) are still going to be unsubscribed.
 =||= See the proposed documentation changes in #3981.
 =||= Thanks, now I know what to expect from `zip`. The current implementation still feels unpolished to me, though.
 =||= ,0
3981,3124,zip: doOnTerminate is not called on some observables,``` java
    @Test
    public void test() {
        Observable.zip(
                Observable.just("1")
                        .doOnTerminate(() -> System.out.println("TERMINATE 1")),
                Observable.just("2")
                        .delay(1, TimeUnit.SECONDS)
                        .doOnTerminate(() -> System.out.println("TERMINATE 2")),
                (result1, result2) -> null)
                .doOnTerminate(() -> System.out.println("TERMINATE"))
                .toBlocking()
                .single();
    }
```

Output:

```
TERMINATE 1
TERMINATE
```

Expected output:

```
TERMINATE 1
TERMINATE 2
TERMINATE
```

Or maybe my thinking is wrong?

Context of the problem: I use [Hystrix](https://github.com/Netflix/Hystrix) observable commands in zip:

``` java
Observable.zip(
  new MyHystrixObservableCommand(arg1).toObservable(),
  new MyHystrixObservableCommand(arg2).toObservable(),
  (result1, result2) -> null)
.toBlocking()
.single()
```

and hystrix command semaphore release happens in doOnTerminate. One of them is not called and semaphore is not released.,Once the second delayed value runs the zip, it detects that the first source has terminated, completes and unsubscribes the second source. At this time, there is an onCompleted scheduled by the second source which due to the unsubscription won't be executed and you don't see the doOnTerminate called.
 =||= I felt back to merge:

``` java
        Observable.merge(
                Observable.just("1")
                        .doOnTerminate(() -> System.out.println("TERMINATE 1")),
                Observable.just("2")
                        .delay(1, TimeUnit.SECONDS)
                        .doOnTerminate(() -> System.out.println("TERMINATE 2")))
                .doOnTerminate(() ->
                        System.out.println("TERMINATE"))
                .ignoreElements()
                .singleOrDefault(null)
                .toBlocking()
                .single();
```

```
TERMINATE 1
TERMINATE 2
TERMINATE
```

This code looks strange to me. Please, advice how to properly run some observables in parallel and wait for them to finish. I can go with merge for now because I do not need observable results.
 =||= You can use `lastOrDefault` to shorten your codes, e.g., `o1.mergeWith(o2).toBlocking().lastOrDefault(null)`.
 =||= @vleushin Is your issue resolved ? I am facing same issue . What is the drawback of using `merge` ? 
 =||= I use merge. Drawback of merge is that it's hard to combine results, if you need them. If you don't need them (like in my case), you can be good with merge
 =||= I just encountered this same thing. I want to zip together two `Observables` and do some simple logging on each when complete. You don't even need the `delay` to make this happen.

```
        Observable<Integer> nums = Observable.just(1, 2, 3, 4)
                .doOnCompleted(() -> System.out.println("done with nums"));
        Observable<String> letters = Observable.just("a", "b", "c", "d")
                .doOnCompleted(() -> System.out.println("done with letters")); // this won't appear

        nums.zipWith(letters, (n, l) -> "got " + n + " and " + l)
                .toBlocking()
                .forEach(System.out::println);
```

I found this behavior to be very surprising. Could zip be changed to allow the source `Observables` to fully complete in the case where they are the same length?
 =||= I'd add `doOnUnsubscribe` so you can execute the cleanup action or simply use `using` that will execute the cleanup if the source completes normally or is cancelled.
 =||= Why is this closed? I think the current zip behavior is incorrect.
My point is, if inner observables of zip emit the same number of items, then onCompleted (doOnCompleted, doOnTerminate etc.) should be called on each of them.
 =||= DoOnTerminate won't be called if the observable is unsubscribed before the onCompleted/onError. Use doOnUnsubscribe if you need to always get a call back.
 =||= That is what I'm talking about.
Why unsubscribe just before completion? An event is lost without a reason.
Also there is an obvious inconsistency: you have two identical inner observables, the first completes, then unsubscribes, the second one unsubscribes before completion, even though it was about to do so.
 =||= With collections over time, you can't know you are just before completion. The `zip` operator behaves correctly and you need a different operator, `doOnTerminate`+`doOnUnsubscribe` or `using`, to handle completion and unsubscription case together.
 =||= It is clear to me now. Thank you all for clarifications. I think we can close this issue.
 =||= @abersnaze doOnUnsubscribe can be an acceptable workaround, but what if I don't want it to trigger on error?

@akarnokd Formally, `zip` behaves correctly, since it is not documented whether onCompletes (and so on) should be called on inner observables.
The fact is the behavior is unspecified and unpredictable. The problem is, I want to know exactly what does my code do.
 =||= See the proposed documentation changes in #3981.
 =||= ,0
3986,3985,Proposal: Make Schedulers should be more friendly to tests,`RxJavaPlugins.reset()` was recently made public, but there was a common misconception that this would also reset schedulers. This isn't the case however since Schedulers permanently cache their resolved schedulers, so `RxJavaPlugins.reset()` actually doesn't help in this regard. 

I'd like to propose adding a `Schedulers.reset()` function as well. It comes with same caveats that `RxJavaPlugins.reset()` has in that it's dangerous to call in live code, but it would be enormously helpful in testing. This would simply null out the cached schedulers to force a re-check the next time they're used, and thus letting you change the scheduling hook and have the new one's output propagate. 

With JUnit, it could be nicely wrapped up in a rule that could be optionally dropped into test suites on the fly. Otherwise, schedulers must be set at the beginning of your whole test suite and delegate schedulers put in place that can be configured later.

If people would be open to this, I'd be happy to provide a PR. I looked for prior discussion around this but wasn't able to find any. If I missed them somewhere, please let me know.,👍 In the long term, I would like to see that `RxJavaPlugins.reset()` can reset static fields related to plugins.
 =||= Actually it wouldn't just be nulling out those fields. It would have to replace the singleton `INSTANCE` of Schedulers to re-trigger its constructor and evaluation of those scheduler instances. For just tests though, I still think this is a reasonable tradeoff since it's opt-in and doesn't change existing behavior by default.
 =||= @hzsweers That's what I meant :)
 =||= Opened a PR in #3986 for further review
 =||= ,0
3996,3993,SchedulerLifecycleTest failures,After merging #3986, these to fail in master (worked as PR):

```
rx.schedulers.SchedulerLifecycleTest > testShutdown FAILED
    java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@73f20bba rejected from java.util.concurrent.ScheduledThreadPoolExecutor@17e01bce[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
        at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2048)
        at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:821)
        at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:325)
        at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:530)
        at java.util.concurrent.ScheduledThreadPoolExecutor.execute(ScheduledThreadPoolExecutor.java:619)
        at rx.schedulers.SchedulerLifecycleTest.tryOutSchedulers(SchedulerLifecycleTest.java:98)
        at rx.schedulers.SchedulerLifecycleTest.testShutdown(SchedulerLifecycleTest.java:36)
rx.schedulers.SchedulerLifecycleTest > testStartIdempotence STARTED
rx.schedulers.SchedulerLifecycleTest > testStartIdempotence FAILED
    java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@18264a30 rejected from java.util.concurrent.ScheduledThreadPoolExecutor@17e01bce[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
        at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2048)
        at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:821)
        at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:325)
        at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:530)
        at java.util.concurrent.ScheduledThreadPoolExecutor.execute(ScheduledThreadPoolExecutor.java:619)
        at rx.schedulers.SchedulerLifecycleTest.tryOutSchedulers(SchedulerLifecycleTest.java:98)
        at rx.schedulers.SchedulerLifecycleTest.testStartIdempotence(SchedulerLifecycleTest.java:117)
```

@hzsweers can you have a look at these? (It's night time for me btw.),Sure I'll take a look
 =||= They run fine on 1.x/master for me locally. Maybe something to do with Travis? Or related to or in the same vein as https://github.com/ReactiveX/RxJava/pull/3987?
 =||= @hzsweers I guess it's related to CPU/cores configuration + machine state. Please try to run tests on Travis through your fork of RxJava (via PRs or other ways). Just add env variable `TRAVIS_PULL_REQUEST=true` on Travis for your fork.

P.S. sorry for "laugh" reaction, removed, thought that it was funny and "I've warned you" things, but this project is too significant to break it so yeah, sorry. I'll be here to review fix in few hours.
 =||= So we've chatted with @hzsweers about the problem, he has to go for few hours, if somebody interested in fixing that — looks like #3986 shuts down scheduler too early or tests that run after `reset()` see shutdowned scheduler or something like this:

https://github.com/hzsweers/RxJava/pull/1/commits/615d91eda5f84616f4a4ddb3a9b9e5950fe9b30b

```
rx.schedulers.ResetSchedulersTest > reset STARTED

rx.schedulers.SchedulerLifecycleTest > testShutdown STARTED

rx.schedulers.SchedulerLifecycleTest > testShutdown FAILED
    java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@4240096f rejected from java.util.concurrent.ScheduledThreadPoolExecutor@7a2b7863[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
        at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2048)
        at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:821)
        at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:325)
        at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:530)
        at java.util.concurrent.ScheduledThreadPoolExecutor.execute(ScheduledThreadPoolExecutor.java:619)
        at rx.schedulers.SchedulerLifecycleTest.tryOutSchedulers(SchedulerLifecycleTest.java:108)
        at rx.schedulers.SchedulerLifecycleTest.testShutdown(SchedulerLifecycleTest.java:46)

rx.schedulers.SchedulerLifecycleTest > testStartIdempotence STARTED

rx.schedulers.SchedulerLifecycleTest > testStartIdempotence FAILED
    java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@7cbac34b rejected from java.util.concurrent.ScheduledThreadPoolExecutor@7a2b7863[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
        at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2048)
        at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:821)
        at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:325)
        at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:530)
```
 =||= So, `Schedulers.reset()` shuts down `GenericScheduledExecutorService`, then `SchedulerLifecycleTest` tries to run some tasks on it `GenericScheduledExecutorService.getInstance().execute()` and fails because `reset()` test already shut it down.

The fix would be to restart `GenericScheduledExecutorService` correctly in `SchedulerLifecycleTest` or `Schedulers.reset()` or `GenericScheduledExecutorService.getInstance()`.
 =||= Yes, the `reset` is overscoped; it should only shutdown the main schedulers but leave the helper schedulers. I'll post a fix.
 =||= This can be closed now
 =||= Closing via #3996
 =||= ,0
4020,4017,1.X: Why is CompletableSubscriber not a Subscription?,I see that `CompletableSubscriber` is not a `Subscription`, but `Subcription` is. So, when I use `Completable#subscribe(CompletableSubscriber)`, I cannot then unsubscribe if I want to.,`CompletableSubscriber` was designed along the Reactive-Streams pattern where cancellation support is injected via `onSubscribe` call. Consumers extending `CompletableSubscriber` then can decide individually if they want to expose this cancellation support to the outside world by implementing `Subscription` themselves. In contrast, `Subscriber` can never revoke its ability to be unsubscribed externally.

If you are using `subscribe()` or the lambda versions of `subscribe`, you get a `Subscription` back. As for the `subscribe(CompletableSubscriber)`, indeed we don't have a supporting class for it (as far as I remember). I'll post a PR for it today.
 =||= Closing via #4020.
 =||= ,0
4023,3917,replay(bufferSize, time, TimeUnit) not working - truncate should be called with replay?,The buffer only gets truncated when a new item is added. So any subscribers will always receive that last emission even if it's older than the time-limit. 

```
    'Observable<Long> retrofit = Observable.interval(2L, 2L, TimeUnit.SECONDS).take(10);

    ConnectableObservable<Long> connectableRetrofit;
    connectableRetrofit = retrofit.replay(1, 5, TimeUnit.SECONDS);


    System.out.println("Subscribing A");
    connectableRetrofit.subscribe(new Action1<Long>() {
        @Override
        public void call(Long aLong) {
            System.out.println("subscriber! A ========== " + aLong);
        }
    });

    System.out.println("Connecting!");
    connectableRetrofit.connect();

    Thread.sleep(10000L);


    System.out.println("Subscribing B");
    connectableRetrofit.subscribe(new Action1<Long>() {
        @Override
        public void call(Long aLong) {
            System.out.println("subscriber! B ========== " + aLong);
        }
    });

    Thread.sleep(30000L);


    System.out.println("Subscribing C");
    connectableRetrofit.subscribe(new Action1<Long>() {
        @Override
        public void call(Long aLong) {
            System.out.println("subscriber! C ========== " + aLong);
        }
    });`
```

Here subscriber C is subbing after 30 secs so you'd expect the buffer to have truncated the last value since the time-limit is 5 secs.

This is the output: 

> Subscribing A
> Connecting!
> subscriber! A ========== 0
> subscriber! A ========== 1
> subscriber! A ========== 2
> subscriber! A ========== 3
> subscriber! A ========== 4
> Subscribing B
> subscriber! B ========== 4
> subscriber! A ========== 5
> subscriber! B ========== 5
> subscriber! A ========== 6
> subscriber! B ========== 6
> subscriber! A ========== 7
> subscriber! B ========== 7
> subscriber! A ========== 8
> subscriber! B ========== 8
> subscriber! A ========== 9
> subscriber! B ========== 9
> Subscribing C
> subscriber! C ========== 9,True, replay starts from the current head which is only moved forward by `onNext`. I've been thinking about rewriting `ReplaySubject` to support backpressure; in that structure, when the child Subscriber picks up [the head](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/processors/ReplayProcessor.java#L975), we can skip old entries right there.

Question is, do we want this behavior change and whether the current behavior is expected by unit tests?
 =||= Good point. I think the current behavior is a conflict with the method description/purpose. So I'd say change, if not at least an update to the documentation. Maybe deprecate the current one? Being new to Rx I spent quite a while trying to figure out why this wasn't working. 
 =||= Also, could you recommend a workaround to achieve that behavior? Basically I wanted to do something like replay a network call within a specific time, and if it came out empty I'd repeat the call.
 =||= You can timestamp values before it reaches the ReplaySubject then use skipWhile(n -> n.timestamp < now - maxAge).

Otherwise, see #3918 for an updated ReplaySubject where stale data is skipped on subscription.
 =||= Sorry, I completely forgot about this. I'll post an PR to replay() and see what it takes to skip old entries.
 =||= See #4023 for a proposed fix for `replay()` itself.
 =||= Closing via #4023.
 =||= ,0
4024,3721,doOnEach marble diagram incorrect,Should show the completion event forwarded to the supplied `Action1` or `Observer`.,If so, the javadocs also need to be rewritten to indicate that the
completion event is sent to the action or observer.

I notice also that the description of the parameter in the javadoc of
doOnEach(Observer) describes the observer as an Action rather than an
Observer.

On Thu, Feb 18, 2016 at 11:30 AM, Jake Wharton notifications@github.com
wrote:

> Should show the completion event forwarded to the supplied Action1 or
> Observer.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/3721.

## 

David M. Gross
PLP Consulting
 =||= Reopening because the javadocs still need correction.

Also: there's a new doOnEach.o.png marble diagram that's specific to the doOnEach(observer) operator and should replace the diagram in the javadocs for that operator.
 =||= See #4024 for my proposed text changes
 =||= Great! Closing via #4024.
 =||= ,0
4026,3007,Javadoc for cache suggests eager subscribe,Lines 27-28 of OnSubscribeCache:
- This method has similar behavior to {@link Observable#replay()} except that this auto-subscribes
  - to the source Observable rather than returning a connectable Observable.

It appears that the subscribe() to the source is lazy ,Care to submit a PR for this?
 =||= See #4026 for the proposed javadoc changes.
 =||= Closing via #4026.
 =||= ,0
4034,4001,1.x: added distinctUntilChanged(comparator),For some cases, `Observable.distinctUntilChanged(keySelector)` isn't enough. For example, when data consists of 2+ objects with ID, you cannot simply summarize them and use it as a key. Also often there are stream of arrays of data which can't be distincted easily and generically.
So I think `Observable.distinctUntilChanged(comparator)` would be helpful. I use kinda tricky implementation, but think, it is okey. Firstly I tried to add ctor to OperatorDistinctUntilChanged(), but it was... too bad.

**p.s.** I was really confused by 

> If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request (on a branch other than master, 1.x, 2.x, or gh-pages).

and spent some time trying to create some sort of temporal branch here (newbie me). But finally looked up into PRs and so that it is okey to PR into 1.x. Is it an error in .md-file?,Please add unit tests that verify the behavior.
 =||= How about this one?
 =||= Sorry for the delay. I remembered there was a discussion about this overload a while ago in #395.

The verdict was to not have them and you have to create your own wrapper class with custom `equals` and use it as a keySelector.

The decision may be revised, depending on the other's opinions.

(Otherwise, I would have done it differently, not with that subscriberProvider).
 =||= See #4034 about how I'd implement this instead (easier shown in code than as a comment). Let me know if you want to adjust your PR.
 =||= By `adjust your PR` you mean copy-paste your implementation as successive commit to existed ones?
 =||= > By adjust your PR you mean copy-paste your implementation as successive commit to existed ones?

If you think that my PR doesn't cover everything you wanted then yes. Otherwise, I leave it to you.
 =||= > If you think that my PR doesn't cover everything you wanted then yes

No, I think your PR is just okay and do what I wanted and do it better than mine own :+1: 
So I guess I need to close this PR now?
 =||= Yes, you can close this. Thanks for your contribution anyway! If you have any further improvement suggestions / PRs for the library don't hesitate to post them. (If you need some hints about operator coding styles and structure, try looking at the common and simpler operators implementations.)
 =||= ,0
4036,4035,Consider adding zip function with Observable array for reduced overhead.,Currently the `zip` function takes an Iterable in the form `Iterable<? extends Observable<?>> ws` and then is transformed into an array:

```
List<Observable<?>> os = new ArrayList<Observable<?>>();
for (Observable<?> o : ws) {
    os.add(o);
}
return Observable.just(os.toArray(new Observable<?>[os.size()])).lift(new OperatorZip<R>(zipFunction));
```

This causes not only the copy from one list to another but also a copy from the created list to the array, which will add some overhead if the list is big enough.

Instead, consider adding the following function:

```
public static <R> Observable<R> zip(Observable<?>[] ws, FuncN<? extends R> zipFunction) {
    return Observable.just(ws).lift(new OperatorZip<R>(zipFunction));
}
```

So whoever who has the chance to create an array instead of a List will save some cpu time.

I'd be glad to create a pull request with the related code to any specified branch if needed.
Thanks for your attention.,It should be a straightforward addition with minimal API surface expansion cost. PR is welcome.
 =||= ,0
4051,4028,ReplaySubjectConcurrencyTest > testReplaySubjectConcurrentSubscriptions FAILED,```
rx.subjects.ReplaySubjectConcurrencyTest > testReplaySubjectConcurrentSubscriptions FAILED
    java.lang.RuntimeException: Concurrency Bug
        at rx.subjects.ReplaySubjectConcurrencyTest.testReplaySubjectConcurrentSubscriptions(ReplaySubjectConcurrencyTest.java:235)
```,New crash type:

```
rx.subjects.ReplaySubjectConcurrencyTest > testReplaySubjectConcurrentSubscriptions FAILED
    java.lang.NullPointerException
        at rx.subjects.ReplaySubjectConcurrencyTest.testReplaySubjectConcurrentSubscriptions(ReplaySubjectConcurrencyTest.java:221)
```
 =||= Fixed via #4051.
 =||= ,0
4053,4052,2.x: Change SchedulerSupport to string?,In some specific uses of RxJava it's common to have other important schedulers that one cares about. If the `@SchedulerSupport` annotation was changed to use a `String` as its value and provide constants on that type for its first-party values this would allow those other schedulers to be analyzed in the same way.

This will allow static analysis tools to enforce constraints with these "custom" schedulers as actual named-entities instead of having to rely on the otherwise opaque `CUSTOM` value. Additionally, libraries will be able to annotate their factory methods which operate on these schedulers appropriately.

I'm thinking specifically of Android, RxAndroid, and having `"mainThread"` be a value.

Happy to make this change if it sounds like a good idea.,:+1:, I'm not touching the base reactive types in the next 12 hours so go ahead with the PR.
 =||= Resolved by #4053. Not sure why it didn't auto-close. 
 =||= > Resolved by #4053. Not sure why it didn't auto-close.

Only patches merged to the `default` branch can auto-close issues.
 =||= Ah, good call.

On Tue, Jun 21, 2016, 8:36 PM Shixiong Zhu notifications@github.com wrote:

> Resolved by #4053 https://github.com/ReactiveX/RxJava/pull/4053. Not
> sure why it didn't auto-close.
> 
> Only patches merged to the default branch can auto-close issues.
> 
> —
> You are receiving this because you modified the open/close state.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4052#issuecomment-227612498,
> or mute the thread
> https://github.com/notifications/unsubscribe/AAEEEffrBjE_5NKqCcUK63DbG4JT4OBkks5qOIOlgaJpZM4I7K09
> .
 =||= ,0
4063,3959,1.x: scan with an initial factory callback,This PR adds an overload to `scan` which allows specifying an initial value factory. The initial value factory is invoked for each incoming Subscriber individually and provides a non-shared starting point for the `scan` operation.

I propose the `scan(Func2 accumulator, Func0 initialFactory)` parameter order because some Java 8+ compilers can't properly disambiguate with `scan(R initialValue, Func2 accumulator)`, thinking that R can be made `Func0`. 

Related: #3667,Why add the overload if it can be done with defer and scan then?
 =||= Yep, it can be done. A decision has to be made if this convenience should make it into the library or not, and notify @NiteshKant the outcome in #3667.
 =||= I'd like to see this overload in, thanks.
 =||= I'm not strong against adding it but not like the idea of the new parameter order. I would give +1 if giving it a better name instead of changing the parameter order. By the way, there is already a `OperatorScan(Func0<R> initialValueFactory, Func2<R, ? super T, R> accumulator)` for this overload so you don't need to use `defer`.

Probably @benjchristensen should take a look since you removed it before.
 =||= It was removed due to ambiguity as shown in https://github.com/ReactiveX/RxJava/issues/1881#issue-48878398

As long as that issue is not recreated, I have nothing against the functionality pursued here. I too don't like solving the overload ambiguity by moving parameter order around. But there is no good solution, it's either that or a new name. 
 =||= As an alternative, I suggest extending `scan`'s javadoc with the example of the defer trick.
 =||= The argument order bothers me as well. I'll close this and post a javadoc update instead.
 =||= ,0
4069,4056,2.x: Unify two type parameters from Subject into one?,This came up in passing in an issue or PR before (that I can't find at this moment), but the two type parameters on `Subject` seem to only be a nuisance instead of a benefit.

Should we remove them?

None of the built-in implementations allow consuming a type different than is being emitted, which makes the two type parameters on the supertype seem very out of place.,:+1: RxScala uses one parameter for a long time and no one complaints.
 =||= It's a remnant of the "Subject as a processing stage" mentality of Rx.NET, but unlike Java, you can have classes with the same name and different number of type parameters.

:+1:, would you like to do it?
 =||= I can tomorrow! It's 3am here and that other PR I sent wore me out.

On Wed, Jun 22, 2016, 2:57 AM David Karnok notifications@github.com wrote:

> It's a remnant of the "Subject as a processing stage" mentality of Rx.NET,
> but unlike Java, you can have classes with the same name and different
> number of type parameters.
> 
> 👍, would you like to do it?
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4056#issuecomment-227659453,
> or mute the thread
> https://github.com/notifications/unsubscribe/AAEEETo3RW7ffxc0p3GoiOj4dKQypbsoks5qONzogaJpZM4I7ZYv
> .
 =||= ,0
4070,4057,2.x: SerialDisposable and MultipleAssignmentDisposable are exactly the same,Either one is erroneously implemented or let's pick one to keep.,There is a difference:

https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/disposables/SerialDisposable.java#L33

https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/disposables/MultipleAssignmentDisposable.java#L32

Multiple doesn't dispose the previous Disposable but Serial does.

However, I'm totally for merging the two classes and have `set` and `replace` on them.
 =||= Wow super subtle! I had them open side-by-side and wasn't able to see that.

I can take this change tomorrow as well. Is there a preference for the name
of this merged type?

On Wed, Jun 22, 2016, 3:06 AM David Karnok notifications@github.com wrote:

> There is a difference:
> 
> https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/disposables/SerialDisposable.java#L33
> 
> https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/disposables/MultipleAssignmentDisposable.java#L32
> 
> Multiple doesn't dispose the previous Disposable but Serial does.
> 
> However, I'm totally for merging the two classes and have set and replace
> on them.
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4057#issuecomment-227660891,
> or mute the thread
> https://github.com/notifications/unsubscribe/AAEEEaJHuo4bnQp1ZPbnZfUMKT-u5lWXks5qON8DgaJpZM4I7bXX
> .
 =||= Open for discussion, I was leaning towards `SingleDisposable` but could get confused with `Single` in IDE content assist.
 =||= `AssignableDisposable`? `ReferenceDisposable`?
 =||= Closed by #4070.
 =||= I think `SerialDisposable` is good enough now.
 =||= ,0
4092,4067,Add Animal Sniffer tool to the build process,This came up in #3805 to make sure the code uses only Java 6 APIs.

https://github.com/xvik/gradle-animalsniffer-plugin

In the first round, we could apply it to the 1.x branch (shorted build time) and then move on to 2.x.,nan,0
4099,3164,Code Coverage and Static Analysis Tools,The developers on RxJava have historically avoided adding new tools to the project in the interests of keeping the release and build processes as simple as possible. Today this includes Gradle, Nebula, JMH, and JUnit. So, if this impacts you we'd like to know. What tools do you like to use and how can we help make your hacking experience more productive? Can they be easily integrated and optionally executed or would they require integrating into the release process? Note that it's very unlikely that we'll choose to add complexity to the build process without a compelling reason. 

Right now our guidelines for assessing tools related pull requests are roughly the following:
- For changes which integrate a new tool which is not essential to the release process there should be no changes to the `build.gradle`. 
- Auxiliary tools that require gradle changes must remain unlinked to the build system. They should be optionally included as an init script via the `-I` gradle parameter on an as-needed basis by the developer.
- Runtime code should not /suffer/ for the benefit of an auxiliary tool. This includes adding mental overhead (readability, complexity) or reducing the efficiency of crucial computational paths. 

Hope to hear your ideas and suggestions.,Closing this as we added code coverage to the build process. Apart for indicating what extra unit tests are needed, it already helped discovering bugs by highlighting code sections that never run but should.
 =||= What about static analyze tools though such as PMD / Findbugs / Checkstyle?
 =||= My personal opinion about PMD / Findbugs is that they tend to give too many false positives on RxJava. As for Checkstyle, we didn't have a strict code style so far and were forgiving in many cases.

As with the code coverage, the best would be if you or somebody else posted a PR with the tools added to the build process to see how it works out.
 =||= I could prepare branches with those. Should I target 1.x or 2.x?
 =||= Start with 1.x as it builds faster.
 =||= ,0
4102,4075,2.x: Expose Disposable.isDisposed()?,In `Disposable.java` currently:

``` java
// TODO let's see if we really need this
// boolean isDisposed();
```

I think we should add this since `dispose()` already states:

> Dispose the resource, the operation should be idempotent.

Which means every disposable already needs a mechanism for idempotence which should trivially translate into `isDisposed()`.

There's some massive refactors that can be done if this change is made. `BooleanDisposable` can completely disappear from the public API since `Disposables.from(Runnable)` + `Disposables.empty()` mimic its behavior. Additionally a large portion of the other internal, custom disposables can be rewritten to build on an internal `BooleanDisposable` which manages both idempotence and the `isDisposed()` implementation for you.

I did some of this work last night as an experiment and it looks like a good win. The argument against the refactor would be if there's a reason we don't actually want to expose `isDisposed()` on `Disposable` directly. I'll note that `BooleanDisposable` is not unique in having an `isDisposed()` method. Most other implementations also have this method, they simply don't share it from the interface.,And I'm volunteering for this work, if that wasn't obvious...
 =||= The problem with adding `isDisposed` that it mandates stateful `Disposable` implementations for all use cases (empty can't be constant but requires newing up a new instance because it has to switch to disposed state in a visible manner). As the current 2.x demonstartes, checking for `isDisposed` is only required by a few container classes. Thus, I'd like to keep `Disposable` as is. You can introduce an interface on top of it for the container classes if you really want to.
 =||= Ok let me see how far I can get without exposing method. I did see that empty had to become a factory as a result, but I don't know how frequent the need for an empty instance is such that it would be a problem.
 =||= After more investigation it looks like `empty()` is the _only_ stateless `Disposable` in the entire lib aside from `disposed()`. Every other implementation is stateful and if it doesn't already declare `isDisposed()`, it can do so trivially.

Tell me what you think about this plan:
1. Document `DisposableHelper.DISPOSED` as a marker instance to be compared by identity (done in #4081) and `EmptyDisposable.INSTANCE` as a no-op implementation to be used internally as a value.
2. Change `Disposables.empty()` to return `new BooleanDisposable()`
3. Uncomment `isDisposed()` on `Disposable` and ensure a proper implementation on all implementations.

That said, I'm not convinced `empty()` needs to even exist as a public API. But if it does, then it's likely used so rarely that the fact that it needs to allocate a single, tiny object shouldn't matter. Internally all "empty" values will use `EmptyDisposable.INSTANCE` which will behave like an already-disposed `Disposable`.
 =||= Okay, go ahead with the PR.
 =||= ,0
4139,4138,2.x: FlowableReplayTest > testAsyncComeAndGo ,Could be an bug with `replay()` or the fact that it goes lockstep and doesn't request in time if the further downstream (observeOn) is slow.

```
io.reactivex.internal.operators.flowable.FlowableReplayTest > testAsyncComeAndGo FAILED
    java.lang.AssertionError: Error(s) present: [io.reactivex.exceptions.MissingBackpressureException: Can't deliver value 236 due to lack of requests]
        at io.reactivex.subscribers.TestSubscriber.fail(TestSubscriber.java:397)
        at io.reactivex.subscribers.TestSubscriber.assertNoErrors(TestSubscriber.java:465)
        at io.reactivex.internal.operators.flowable.FlowableReplayTest.testAsyncComeAndGo(FlowableReplayTest.java:1022)
        Caused by:
        io.reactivex.exceptions.CompositeException
            at io.reactivex.subscribers.TestSubscriber.fail(TestSubscriber.java:398)
            ... 2 more
            Caused by:
            io.reactivex.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>
                Caused by:
                io.reactivex.exceptions.MissingBackpressureException: Can't deliver value 236 due to lack of requests
```,Closing via #4139
 =||= It's [back](https://travis-ci.org/ReactiveX/RxJava/builds/144412254#L3408).
 =||= Closing again. Haven't encountered this for a while.
 =||= ,0
4139,4109,2.x: NbpOperatorConcatTest > testIssue2890NoStackoverflow FAILED,Looks like a timeout issue.

```
io.reactivex.internal.operators.observable.NbpOperatorConcatTest > testIssue2890NoStackoverflow FAILED
    java.lang.AssertionError: expected:<5000> but was:<3797>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:834)
        at org.junit.Assert.assertEquals(Assert.java:645)
        at org.junit.Assert.assertEquals(Assert.java:631)
        at io.reactivex.internal.operators.observable.NbpOperatorConcatTest.testIssue2890NoStackoverflow(NbpOperatorConcatTest.java:730)
```,Closing via #4139
 =||= ,0
4139,405,combineWithMostRecent,I'm looking for an operation which does the following:

Whenever Observable o1 emits an item, combine this item with the most recent item of Observable o2.

Illustration:

```
----A-------B------C----->  o1

--0----1-2----3-4-------->  o2

    |       |      |
    V       V      V

  (A,0)   (B,2)  (C,4)
```

I can't find a nice way of doing this.
Can anyone help me?
Or do we need to add a new operation to `rx.Observable`?,Actually, `combineLatest` together with `distinctUntilChanged`, with equality based on the tuple projection would work here I think. Maybe there's an easier way, but this is what first came to my mind...
 =||= But what if o1 emits two equal items in sequence?
 =||= If that is part of your problem we're discussing the distinct operator here. https://github.com/Netflix/RxJava/issues/395#issuecomment-24858966
 =||= Maybe this is a `Join` use case? I found a description [here](http://www.introtorx.com/content/v1.0.10621.0/17_SequencesOfCoincidence.html).
 =||= Join is hardly ever used, and the semantics are subtle. and because of all the functions you need to pass pretty nasty if you don't have groupBy query comprehension syntax.

But implementing it would be a fun task for anyone that wants to dig down to the next level of detail.

Watch http://channel9.msdn.com/Series/Rx-Workshop/Rx-Workshop-7-Reactive-Coincidence first ...

> On Sep 24, 2013, at 7:32 AM, Joachim Hofer notifications@github.com wrote:
> 
> Maybe this is a Join use case? I found a description here.
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= This means that maybe it's a good idea to add `combineWithMostRecent` (as described by @samuelgruetter) as an operator? - To me it sounds like a relatively frequent use case.
 =||= I have similar problem - came up with:

```
public static <T, U, R> Observable<R> enrich(Observable<T> source, Observable<U> data, Func2<T, U, R> f) {
    return Observable.zip(source, data.sample(source), f);
}
```

but noticed sample() doesn't really sample input - it doesn't emit last value multiple times when no change occured between timer, causing zip operation to get out of sync. 

Isn't that a bug (or at least serious documentation problem) with sample()?

marcin
 =||= I agree, that's inconsistent: `sample(long, TimeUnit)` emits the last value multiple times if the source observable didn't emit a new value between two ticks, but `sample(Observable<U>)` does not repeat it, and [this line](https://github.com/Netflix/RxJava/blob/019aa93a39db36019033d18f23a78b331f5cd445/rxjava-core/src/main/java/rx/operators/OperationSample.java#L182) suggests it was done on purpose. But I think `sample(Observable<U>)` should be changed to match the behavior of `sample(long, TimeUnit)`.
 =||= How about this?

``` groovy
    Observable.combineLatest(a, b, { x, y -> [x, y] })
        .distinctUntilChanged({ tuple -> tuple[0]})
        .distinctUntilChanged({ tuple -> tuple[1]})
        .toBlockingObservable().forEach({ v-> println(v)})
```
 =||= Regarding issue1: How to get combineWithMostRecent/enrich behavior: What if the source Observable `a` emits two equal values in succession? We still want to see this in the resulting Observable, so we can't use an approach with `distinctUntilChanged`.

Regarding issue2: Is the behavior of `sample(Observable<U>)` correct? @benjchristensen what do you think?
 =||= The `sample` operator was fixed in v0.18.2.
 =||= Note: The `sample` operator was indeed fixed, but not the way @zorba128 and me would have expected.  `sample(Observable<U>)` and `sample(long, TimeUnit)` are now consistent and both do **not** emit the last value multiple times if it hasn't changed between two sampler ticks.

[I've reread this thread because this question was asked on [stackoverflow](http://stackoverflow.com/questions/27203435/combinelatest-emit-only-when-one-of-the-streams-changes)].
 =||= Would something like the following work:

``` java
observableA.combineWithMostRecentFrom(observableB)
```

This would different from `combineLatest` as it would not emit all permutations. It would only emit when `A` emits and take whatever the last from `B` was. 

Then the `A` observable could be the "slow one" and we just grab whatever the last from `B` was. 
 =||= Guys, guys, we need to solve this one. I've been using this "combineWithMostRecent" or "enrich" (I call it "combinePrev") many times in an Android project in production. It's very useful. Basically what we need is the asymmetric version of combineLatest. I used to have an implementation of it based on `join`, and I informed @mattpodwysocki that it would be good if we could do that in RxJS too, see https://github.com/Reactive-Extensions/RxJS/issues/335#issuecomment-60421335.

My implementation of the operator with join is this:

``` java
 /**
   * Similar to combineLatest, except it joins the latestitems from the two source
   * observables only when the first observable emits an item.
   * 
   * first:  ------f----f-------------f--------------f----|>
   * second: ---s1----------s---s--s3-----s-s-s-s4--------|>
   * result: ------R1---R1------------R3-------------R4---|>
   * 
   * @param first
   *        The first source Observable
   * @param second
   *        The second source Observable
   * @param combineFunction
   *        the aggregation function used to combine the items emitted by the source
   *        Observables
   * @return an Observable that emits items that are the result of combining the items
   *         emitted by the source Observables by means of the given function
   */
  public static <TFirst, TSecond, R> Observable<R> combinePrev(
    final Observable<TFirst> first, 
    final Observable<TSecond> second, 
    final Func2<TFirst, TSecond, R> combineFunction) 
  {
    final Observable<TSecond> hotSecond = second.publish().refCount();
    return first.join(hotSecond, new Func1<TFirst, Observable<Object>>() {
      public Observable<Object> call(final TFirst it) {
        return Observable.<Object>empty();
      }
    }, new Func1<TSecond, Observable<TSecond>>() {
      public Observable<TSecond> call(final TSecond it) {
        return hotSecond;
      }
    }, combineFunction);
  }
```

But I just figured a much simpler implementation based only on map and switch, basically this:

```
A.map({a -> B.map({b -> [a, b]})}).switch()
```

See [this StackOverflow answer I wrote](http://stackoverflow.com/questions/27203435/combinelatest-emit-only-when-one-of-the-streams-changes/27207073#27207073).
 =||= > not the way @zorba128 and me would have expected

What was expected? It emits the last item in a given time window if something was emitted. If nothing was emitted then nothing is emitted at the end of the time window. 

http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(long,%20java.util.concurrent.TimeUnit)
 =||= > we need to solve this one

Sure, let's get it solved. 

Once https://github.com/ReactiveX/RxJava/pull/1905 is confirmed let's add a new operator marked with `@Beta` and make sure it works well for everyone and then in 1.1 or 1.2 we can mark it as stable and remove the `@Beta` marker. 
 =||= So we just need to find a proper name for it. I prefer shorter names, but `enrich` didn't ring a bell to me. Maybe `sampleCombine`?
 =||= It's not quite `sample` though, as it's not sampling with a time interval, it really is just taking whatever the last value is, similar to `BehaviorSubject`, or `BlockingObservable.latest()`. 

The static `Observable.combinateLatest` combines all permutations of all Observables it combines. 

To confirm, here we want to combine every value from one Observable with the latest or most recent of another, correct?

It feels like an instance method of `combineWithMostRecent` or `combineWithLatest`. Or is `combine` too confusing with the static `combineLatest` that does all permutations?

It ends up being very similar to `zipWith` if we had a `zipWithLatest` variant?

Does this have a proper name in Haskell, Scala or some other functional language that I'm unaware of? 

@headinthebox Your input on this would be helpful. 
 =||= Let me think what the shortest way to implement this is using the existing combinators; cant believe it is very long but I am jetlagged ;-)
 =||= This appears to be producing the expected results:

``` java
public class CombineWhenOther {
    public static void main(String[] args) {
        PublishSubject<Integer> source = PublishSubject.create();
        BehaviorSubject<Integer> other = BehaviorSubject.create();


        source.concatMap(e -> other.take(1).map(f -> e + f))
        .subscribe(System.out::println, Throwable::printStackTrace, 
                       () -> System.out.println("Done"));

        source.onNext(1);
        other.onNext(10);
        other.onNext(20);
        other.onNext(30);
        source.onNext(2);
        source.onNext(3);
        other.onNext(40);
        source.onCompleted();
    }
}
```

But both sources are hot, and since we don't have multicast(), I don't know how to convert a general other Observable to BehaviorSubject with the stable API.
 =||= Sorry, with this implementation

```
A.map({a -> B.map({b -> [a, b]})}).switch()
```

I forgot to mention that B must be hot.

> It's not quite sample though, as it's not sampling with a time interval, it really is just taking whatever the last value is, similar to BehaviorSubject, or BlockingObservable.latest().

It is sample as in `a.sample(b)` combined with `b`. It is not sampling with a time interval, it is sampling with b as the sampler. See this [jsfiddle](http://jsfiddle.net/staltz/6140qLv3/) (c is `a.sample(b)`).

> The static Observable.combineLatest combines all permutations of all Observables it combines.
> 
> To confirm, here we want to combine every value from one Observable with the latest or most recent of another, correct?
> 
> It feels like an instance method of combineWithMostRecent or combineWithLatest. Or is combine too confusing with the static combineLatest that does all permutations?

If we _could_ afford renaming existing operators, one suggestion is `combineSymmetric` for `combineLatest` and `combineAsymmetric` for this new one. The problem with names such as `combineWithMostRecent`and `combineWithLatest` is that in English they mean basically the same as `combineLatest`, and a lot of confusion can emerge from this ambiguity.

Another thing to keep in mind is that this new operator is an instance method, and shouldn't have a static version. Because of the asymmetric behavior, there should be one source Observable that commands the emission of the resulting Observable.

If we take that into consideration, we could name it `withLatest`, since it will be always applied on some source observable `a`:

```
c = a.withLatest(b, combineFunction)
```

Another insight is that since the `c` observable emits at the same time `a` emits, we can take advantage of the `map` concept. `mapWithLatest` could work as a name.

My humble suggestions are then either `sampleCombine` or `withLatest` or `mapWithLatest`. 
 =||= > Would something like the following work:
> 
> ```
> observableA.combineWithMostRecentFrom(observableB)
> ```
> 
> This would different from combineLatest as it would not emit all permutations. It would only emit when A emits and take whatever the last from B was. 

That's exactly what I was looking for.

> > not the way @zorba128 and me would have expected
> 
> What was expected? It emits the last item in a given time window if something was emitted. If nothing was emitted then nothing is emitted at the end of the time window.
> 
> http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(long,%20java.util.concurrent.TimeUnit)

For example, if I sample an audio signal `s` at a frequency of 44100 Hz, I expect to get one sample every 1/44100 seconds, no matter what the shape of `s` is. Taking this analogy to observables, I'd expect that

```
myObservable.sample(50 milliseconds)
```

emits an element every 50 milliseconds, no matter when `myObservable` emits how many items. That is, I'd expect that if nothing was emitted in the time window, the last value is repeated.

But I agree that the way RxJava understands "sample" also makes sense, and it's well explained in the docs what happens, so I'm not saying we should change anything.

> If we take that into consideration, we could name it `withLatest`, since it will be always applied on some source observable `a`:
> 
> ```
> c = a.withLatest(b, combineFunction)
> ```

I think `withLatest` would be a nice name.
 =||= I agree this is a very useful operator, and, @staltz , I like your map - switch implementation. Just for cross-reference, I have already raised this issue (#912) some time ago.

Naming the new operator indeed is difficult now that `sample` is taken. Perhaps `sampleEach` could be considered, to express that there is a difference in behavior to `sample`, while still asserting that it is sampling in some sense?
 =||= Or, what about `combineSampled`? I like how it is simillar to `combineLatest` - both do combining, both have same type signatures (`(T, U) => (T, U)`), they but they differ in _what_ they combine - either latest values, or values taken at times defined by the sampler. They even sort close alphabetically, so the user can see he has a choice, what suits him best.

`sampleEach` could be used as an alternative to just `sample`, with slightly different behavior (not filtering out non-changed values), if need for it's inclusion in the library ever arises (but it can be trivially replaced by `combineSampled`, so it will probably not).
 =||= @dvtomas if we would use `a.combineSampled(b, combineFunction)`, it would sound like we are combining `a` with `b.sample(something)` while in reality we are combining `a.sample(b)` with `b`. 
 =||= Or `a.combineWithLatestOf(b, throughAFunction)`.
 =||= @staltz Sorry, can't see it. My mind is already too deeply connected with my interpretation.. Also, I work in scala, the combineFunction would probably be absent, it would be just `a combineSampled b`, I haven't thought of Java.

@akarnokd That sounds reasonable wrt to `combineLatest` being widely understood and used. I had to go through some pondering about what the `Latest` part in `combineLatest` really means first, to appreciate that...
 =||= > it would be just `a combineSampled b`, I haven't thought of Java.

So to clarify, which of `a` or `b` do you think is being sampled by the other, in this `a combineSampled b` idiom? How are you "reading" this in plain english?
 =||= @staltz I see your point now. It reads roughly as _`A` combine with sampled `B`_ (sampled with what?). That's not right.. 

I like @akarnokd's  `combineWithLatestOf` the best so far.
 =||= @dvtomas precisely, when we say "sampled B", we think "we take samples of B" which to RxJava translates to `b.sample(something)`, which does not happen in reality. I don't want this to become a [gotcha](https://en.wikipedia.org/wiki/Gotcha_%28programming%29).
 =||= Now implemented in [RxJS as `withLatestFrom`](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/withlatestfrom.md). I would make a PR in RxJava as well, but I'm having a hard time navigating through the core in the codebase, maybe someone else familiar with the codebase could implement it?

The implementation can be roughly 

```
A.map({a -> hotB.map({b -> [a, b]})}).switch()
```

Or a state machine like I did in RxJS.
 =||= http://stackoverflow.com/questions/28580490/rxjava-how-to-emulate-withlatestfrom
People are asking for this operator.

Some one please implement it?
 =||= :+1: I have had 4 separate instances of need of this in the last two weeks that I felt dirty working around!
 =||= I'll do this.
 =||= :+1: :+1: 
 =||= See #2760 for the proposed name and behavior.
 =||= This issue can be closed.
 =||= The `window` operator looks like an interesting option for building this. The initial drawing looks almost exactly like the marble diagram for the operator.

![window marble diagram](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window8.png)
 =||= Damn it, I couldn't stop thinking about this all night.

```
package asdf;

import static rx.Observable.zip;
import rx.subjects.PublishSubject;
import rx.subjects.Subject;

public class Main {
    private static class Tuple {
        public final String t;
        public final int i;

        Tuple(String t, int i) {
            this.t = t;
            this.i = i;
        }

        @Override
        public String toString() {
            return t + ":" + i;
        }
    }

    public static void main(String[] args) {
        Subject<String, String> trigger = PublishSubject.create();
        Subject<Integer, Integer> data = PublishSubject.create();

        trigger.publish(trigger_ -> {
            return zip(trigger_, data.window(trigger_).flatMap(window -> window.lastOrDefault(-1)), Tuple::new);
        }).scan((last, curr) -> curr.i == -1 ? new Tuple(curr.t, last.i) : curr).subscribe(System.out::println);

        data.onNext(0);
        trigger.onNext("A");
        data.onNext(1);
        data.onNext(2);
        trigger.onNext("B");
        trigger.onNext("C");
        data.onNext(3);
        data.onNext(4);
        trigger.onNext("D");
    }
}
```

produces the output

```
A:0
B:2
C:2
D:4
```

It would simpler if you don't need the triggers value.

```
package asdf;

import rx.subjects.PublishSubject;
import rx.subjects.Subject;

public class Main {
    public static void main(String[] args) {
        Subject<String, String> trigger = PublishSubject.create();
        Subject<Integer, Integer> data = PublishSubject.create();

        data.window(trigger).flatMap(window -> window.lastOrDefault(-1)).scan((last, curr) -> curr == -1 ? last : curr).subscribe(System.out::println);

        data.onNext(0);
        trigger.onNext("A");
        data.onNext(1);
        data.onNext(2);
        trigger.onNext("B");
        trigger.onNext("C");
        data.onNext(3);
        data.onNext(4);
        trigger.onNext("D");
    }
}
```

produces the output

```
0
2
2
4
```
 =||= @abersnaze or just

``` java
A.switchMap({a -> hotB.map({b -> [a, b]})})
```
 =||= I had to change the variable names to grok it.  Much better than mine.
`data.switchMap(i -> trigger.map(t -> new Tuple(t, i))).subscribe(System.out::println);`
 =||= ,0
4140,3851,Completable.subscribe(onError, onComplete) design issue,This [particular overload](https://github.com/ReactiveX/RxJava/blob/3c5efaa9442ee24227b63ad039eb965b59aad774/src/main/java/rx/Completable.java#L1916) of `Completable.subscribe()` looks out of design in compare to other RxJava classes like `Observable` and `Single`.

Spent ~5 minutes trying to understand why such code didn't compile:

``` java
Completable
  .fromAction(() -> doSomething())
  .subscribe(
    () -> ui.success(), 
    error -> ui.error(error)
  );
```

And the reason is because this overload accepts `error` handler **first** and `complete` handler second.

I do understand that it comes from `Observable.subscribe(onNext, onError, onComplete)`. 

But in compare to many other overloads like:
- `Observable.subscribe(onNext, onError)`
- `Single.subscribe(onSuccess, onError)` // this one has very similar semantic to target overload.
- `Observable.subscribe(onNext)`
- `Single.subscribe(onSuccess)`

Error handler is **never first** parameter in `Observable.subscribe()` and `Single.subscribe()`.

Another point is that compiler error displayed in IDE makes it even worse:
<img width="303" alt="screen shot 2016-04-12 at 00 35 50" src="https://cloud.githubusercontent.com/assets/967132/14443236/f19ec000-004e-11e6-95bb-178466587d52.png">

---

`Completable` is still in `@Experimental`, so, we can change this signature as we want. We can `@Deprecate` this overload and add "better" alternative and then delete deprecated overload after one-two releases.,The design pattern was:

``` java
subscribe(Action0 onComplete)
subscribe(Action0 onComplete, Action1<Throwable> onError)
```
 =||= @akarnokd what do you mean by

> was

?
 =||= I mean that is your suggestion but the current is swapped for case 2 because it is in the same order as the 3 arg `Observable.subscribe` minus `onNext`. Not sure which order feels more consistent with the other classes.
 =||= Right, I pointed that in the issue description, but we do have `Single.subscribe(onSuccess, onError)` even though it's also `Observable.subscribe(onNext, onError, onComplete)` minus `onNext`.

As said before: no other overloads of `subscribe()` in any classes accept `onError` first -> makes `Completable` inconsistent.
 =||= Okay. Since Completable is experimental, lets swap the arguments as you suggested.
 =||= Oh great, will do PR soon!
 =||= ,0
4140,4137,Inverted onError and onComplete in Completable,In completable subscribe method there is inverted order of methods (in compare to ex. Observable). In every other classes there is onNext/onSucces first, and in Completable there is onError first.,Dupe of #3851 
 =||= Closing as duplicate. If you have time, you could post a PR that swaps the params as described in #3851.
 =||= ,0
4154,4115,Throttling Observables,We have a problem where multiple code paths are making different calls to a backend service but we want to throttle the number of concurrent requests that each client is making. The problem is that different requests could be different types or without knowledge of the other happening something like this:

``` java
Service.getA()
    .subscribe(processResponseA())
```

I was thinking that it would be cool to have a ThrottlingScheduler and/or a MaxConcurrentScheduler that could limit the number of Observables that are active without having to interfere with the data of any of them and without having to make a new thread pool.

``` java
static Scheduler serviceLimiter = Schedulers.maxConcurrent(2, Schedulers.computation());

Service.getA()
    .subscribeOn(serviceLimiter)
    .subscribe(processResponseA())
```,So the completion of the subscribe action upstream of the call to `subscribeOn(serviceLimiter)` would release back to the pool?
 =||= I was thinking `rx.Scheduler.Worker.unsubscribe()` would be when the next Observable in the queue would be subscribed too.
 =||= With the existing API, you can submit Observables to a PublishSubject+flatMap with maxConcurrency of 2:

``` java
    Observable<T1> t1 = Observable.fromCallable(() -> 1).observeOn(Schedulers.computation());
    Observable<T1> t2 = ...

    Subject<Observable, Observable> ps = PublishSubject.create().toSerialized(); // raw Observable

    ps.flatMap(v -> v.ignoreElements(), 2).subscribe(() -> { }, e -> log(e));

    ps.onNext(t1);
    ps.onNext(t2);
```
 =||= I was thinking of using mergeMaxConcurrent inside the scheduler implementation. I would map createWorker() to Observable.create and onNext to a subject. Then map worker.unsubscribe() to onComplete(). While this strange Worker + Observable thing is subscribed to it schedules it's actions on the underlying actual Scheduler. I'm not sure if schedule() would be mapped on onNext or if any uncaught exceptions would be mapped to onError. It might be interesting to think about.

Having the user do all the subject stuff would mean significant constraint of all code paths to only make at most one call the service. The result of each service call Observable would need to be returned and sent through a publish subject for throttling. For example how would could this code be rewritten to only run 2 at a time across the whole of the VM.

```
void foo() {
   return zip(Service.getA(), Service.getB(), Service.getC(), (a,b,c) -> {...});
}
```

With the max concurrent as a scheduler the Service code and apply the subscribeOn to protect itself without the client being any the wiser of the throttling.
 =||= I made two versions of the idea. I'm kind of partial to the fine grained version because I think coarse grain throttling will result in deadlocks. For example in the zip in my last comment if `getA()` and `getB()` could end up blocking `getC()` from being subscribed to until `getA()` completes and deadlocking. The cost is the fine grain throttling creates an Observable for each scheduled action.

Fine grained throttling:
https://gist.github.com/abersnaze/c8c37847bc4bddf13dbc7cc75b99ae95
Coarse grained throttling:
https://gist.github.com/abersnaze/07d995f63ed6100ef60bd9ac980d59ed
 =||= Closing via #4154 and 1.1.7.
 =||= ,0
4173,4171,Cannot customize ThreadFactory in GenericScheduledExecutorService,Some platform like AppEngine have limitations populating threads and have their own mechanism to do it. with last version (1.1.6 at this moment) it's not posible to use rx-java in gae due to don't exist a mechanism to override via RxPlugin or whatever the ThreadFactory in GenericScheduledExecutorService used in [ObjectPool](https://github.com/ReactiveX/RxJava/blob/ed92ba833f05b7eb04ff7d592040656f9bcbcf32/src/main/java/rx/internal/util/ObjectPool.java#L109).

In 1.0.X version don't exist that class and[ ObjectPool(1.0.X)](https://github.com/ReactiveX/RxJava/blob/v1.0.16/src/main/java/rx/internal/util/ObjectPool.java#L107) use Schedulers.computation().createWorker instead.
Please add some mechanism to pass our custom ThreadFactory into GenericScheduledExecutorService in order to use last version of rx-java in GAE,See #4173. It would be great if you could check that PR out and see if there isn't anything pre-initializing the GSES if your first action only touches `RxJavaHooks`.
 =||= Closing via #4173.
 =||= work like a charm with 1.1.7 using RxJavaHooks instead of RxJavaPlugin thanks a lot @akarnokd 
 =||= Great, thanks for confirming!
 =||= ,0
4184,4149,Release 1.1.7 preparations,### Version 1.1.7 - July 10, 2016 ([Maven](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.1.7%7C))

This release has several documentation fixes (`AsyncSubject`, `doOnEach`, `cache`, `scan`, `reduce`, backpressure descriptions) and internal cleanups based on tool feedback (code-coverage and PMD).

**Warning: behavior change in the time-bound `replay()` operator**: the aging of the values continues after the termination of the source and thus late subscribers no longer get old data. For example, a given `just(1).replay(1, TimeUnit.MINUTE)` a subscriber subscribing after 2 minutes won't get `1` but only `onCompleted`.

**Warning: behavior change in `timestamp()` and `timeInterval()` (no arguments) operators**: they now take timing information from the `computation` scheduler instead of the `immediate` scheduler. This change now allows hooking these operators' time source.

**Warning**: the parameter order of `Completable.subscribe(onError, onComplete)` has been changed to `Completable.subscribe(onComplete, onError)` to better match the callback order in the other base reactive classes, namely the most significant signal comes first (`Observer.onNext`, `SingleSubscriber.onSuccess`, and now `CompletableSubscriber.onCompleted`).
#### The new RxJavaHooks API

PR #4007 introduced a new way of hooking into the lifecycle of the base reactive types (`Observable`, `Single`, `Completable`) and the `Scheduler`s. The original `RxJavaPlugins`' design was too much focused on class-initialization time hooking and didn't properly allow hooking up different behavior after that. There is a `reset()` available on it but sometimes that doesn't work as expected.

The new class `rx.plugins.RxJavaHooks` allows changing the hooks at runtime, allowing tests to temporarily hook onto an internal behavior and then un-hook once the test completed.

``` java
RxJavaHooks.setOnObservableCreate(s -> {
   System.out.println("Observable created");
   return s;
});

Observable.just(1).subscribe(System.out::println);

RxJavaHooks.reset();
// or
RxJavaHooks.setOnObservableCreate(null);
```

It is now also possible to override what `Scheduler`s the `Schedulers.computation()`, `.io()` and `.newThread()` returns without the need to fiddle with `Schedulers`' own reset behavior:

``` java
RxJavaHooks.setOnComputationScheduler(current -> Schedulers.immediate());

Observable.just(1).subscribeOn(Schedulers.computation())
.subscribe(v -> System.out.println(Thread.currentThread()));
```

By default, all `RxJavaHooks` delegate to the original `RxJavaPlugins` callbacks so if you have hooks the old way, they still work. `RxJavaHooks.reset()` resets to this delegation and `RxJavaHooks.clear()` clears all hooks (i.e., everything becomes a pass-through hook).
#### API enhancements
- [Pull 3966](https://github.com/ReactiveX/RxJava/pull/3966): Add multi-other `withLatestFrom` operators.
- [Pull 3720](https://github.com/ReactiveX/RxJava/pull/3720): Add vararg of `Subscription`s to composite subscription.
- [Pull 4034](https://github.com/ReactiveX/RxJava/pull/4034): `distinctUntilChanged` with direct value comparator - alternative.
- [Pull 4036](https://github.com/ReactiveX/RxJava/pull/4036): Added zip function with Observable array.
- [Pull 4020](https://github.com/ReactiveX/RxJava/pull/4020): Add `AsyncCompletableSubscriber` that exposes `unsubscribe()`.
- [Pull 4011](https://github.com/ReactiveX/RxJava/pull/4011): Deprecate `TestObserver`, enhance `TestSubscriber` a bit.
- [Pull 4007](https://github.com/ReactiveX/RxJava/pull/4007): new hook management proposal
- [Pull 3931](https://github.com/ReactiveX/RxJava/pull/3931): add `groupBy` overload with `evictingMapFactory`
- [Pull 4140](https://github.com/ReactiveX/RxJava/pull/4140):  Change `Completable.subscribe(onError, onComplete)` to `(onComplete, onError)`
- [Pull 4154](https://github.com/ReactiveX/RxJava/pull/4154):  Ability to create custom schedulers with behavior based on composing operators.
#### API deprecations
- [Pull 4011](https://github.com/ReactiveX/RxJava/pull/4011): Deprecate `TestObserver`, enhance `TestSubscriber` a bit.
- [Pull 4007](https://github.com/ReactiveX/RxJava/pull/4007): new hook management proposal (deprecates some `RxJavaPlugins` methods).
#### Performance enhancements
- [Pull 4097](https://github.com/ReactiveX/RxJava/pull/4097): update `map()` and `filter()` to implement `OnSubscribe` directly.
- [Pull 4176](https://github.com/ReactiveX/RxJava/pull/4176): Optimize collect, reduce and takeLast(1)
#### Bugfixes
- [Pull 4027](https://github.com/ReactiveX/RxJava/pull/4027): fix `Completable.onErrorComplete(Func1)` not relaying function crash.
- [Pull 4051](https://github.com/ReactiveX/RxJava/pull/4051): fix `ReplaySubject` anomaly around caughtUp by disabling that optimization.,👍 
 =||= 👍 
 =||= 👍 
 =||= @zsxwing If I remember correctly, you did regenerate the javadoc for the web the last time. When the release happens, could you do it again?
 =||= Closing via #4184.
 =||= ,0
4209,4206,Unexpected difference between flatmap and concatmap when the stream has only one element,Hello,

I am encountering an unexpected behavior in a piece of code I wrote. I've tried to narrow down a reproduction case in [this gist](https://gist.github.com/rrevol/b08f7231887321f584bc76e20dc81fa7).

To sum up : 
- It's on RxJava 1.1.7
- I have 2 Observables built in such that I am sure their elements match
- These observables come from a flatmap on another observable that emits only one element
- I zip the 2 observables and see that in the output some elements do not match
- important : I use observeOn/subscribeOn because in real life, my process performs io.

What I observe :
- if I replace flatmap by concatmap, no more problem. The way I understand both operations, they should not be different if the mapped stream emits only one element. Do I miss sth ?
- If I remove the observeOn/subscribeOn, no more problem, so I suspect a concurrency issue
- The way it looks is that flatmap shuffles data, but I did a simpler test (use method `initTestFlowWithOrderCheck` instead of `initTestFlowWithZip` ) that seems to discard this hypothesis
- In the end, it could be a concurrency issue in zip but I've read the operator extensively and could not see any problem with it.

Here I am with my investigation, I may have missed something obvious to someone else so I'm looking forward to have your feedback on that.

Thx,By definition, `flatMap` doesn't guarantee any ordering of its events - not between different sources but sometimes not even within the same source (solo or otherwise). 

If you drive it in an async flow, signals may skip ahead yielding the inconsistency. Therefore, If you need strict ordering, use `concat(Map)` or `concat(Map)Eager`.
 =||= > but sometimes not even within the same source

are you talking about onNext from one source being emitted out of order with itself? something like this:

```
--A-B--->
--C----->

flatMap

--C-B-A->
```
 =||= Yes.
 =||= That is surprising to me. @benjchristensen I thought that ordering of onNext from one Observable was to be maintained. I don't see in the general rx contract anywhere but I know we've verbally talked about it over the years.
 =||= I'm still having a hard time understanding what happens under the hood. @akarnokd I'm not saying you're wrong, I just want to understand.

First of all, how can this be that a source can be shuffled ? Map is probably not responsible for that, so it must come from merge. As I understand MergeOperator, there are 2 ways to emit a scalar that came from a source : the fast path, from tryEmit, or the emit loop whose role is to unstack failed fast path attempts. Because each source/inner subscriber has its own queue and because of exclusion ensured by the `emitting` flag, I don't see how it would be possible inside the operator. I would rather see that coming from the fact that the inner subscriber requests batches of scalars that, in an asynchronous flow, may return in a shuffled order. But the shuffling would not be induced by merge operator hence not by flatmap. What am I missing here ?

Assuming now that flatmap may shuffle even the events emitted by one of the observables produced in map, I should be able to reproduce the problem without a zip (using `initTestFlowWithOrderCheck` as stated in my 3rd observation mark). How can zip play a role in it given your explanation ?

I think there is a lack in the javadoc. The user of the API should be warned about the fact that Merge and operators composed from it (flatmap for instance) may shuffle the flow. I may propose an update of the doc if the behavior is confirmed. 

Finally I agree with @abersnaze about the fact that such a behavior is surprising and unexpected.
 =||= It's a property of the queue bypass interacting with the backpressure logic.

This happens when the coordinator runs out of requests. When the source emits, it goes to the queue. Then a request comes in (Thread A), increments the counter but at the same time, the source emits again (Thread B). Now the bypass sees a non-zero requested, emits the later immediately. Then either it or the requestor thread enters the drain loop and emits the first value from the queue.
 =||= Ok, I get it. Thanks a lot for the explanation.

Wouldn't it be interesting to try to drain the queue of the source at the begining of the scalar emission ? Of course this would be a slower path, but still a faster one than the whole emitLoop.
 =||= ```
--A-B--->
--C----->

flatMap

--C-B-A->
```

That breaks the Rx contract. Ordering of a single stream should always be maintained. Interleaving via merge etc is between streams, not elements of the same stream.
 =||= @benjchristensen then the operator `delay(Func1<T, Observable<U>>)` would illegal in case the item delays change the order. This is more like a matter of expectation regarding `flatMap`.

The fix is trivial but adds a likely 10% overhead to the fast-path emissions.
 =||= That operator is allowing a developer to consciously reorder events, so that's not breaking the contract, as it isn't the Observable itself changing order, but user code choosing to do so. 

Similar to how filter chooses to drop events. But filter can't reorder them for example.
 =||= I agree completely that the reordering within an Observable behavior is not at all what I expect intuitively.

If we do want to add the ability to arbitrarily change events, then we should definitely make it explicit rather than the default behavior.
 =||= See #4209.
 =||= Closing via #4209. Fix released in 1.1.8.
 =||= ,0
4215,421,Adding collect method to Scala Observable,I think it's a good idea to add a `collect` method analogous with the one in the Scala collection library. It was simplest to implement it using a combination of `filter` & `map`.

If you find any major disadvantages with this please chime in.,[RxJava-pull-requests #329](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/329/) SUCCESS
This pull request looks good
 =||= @samuelgruetter can you review this and comment as it related to Scala?

@madnl thanks for getting involved. Once review with Samuel, can you please rebase this on top of the recent changes so it can merge without conflicts again? Right now it conflicts as there was a large set of Scala changes that just got merged to master.
 =||= Yes, adding methods which are in Scala collections but not in RxJava is one of the points which are still on the [TODO list](https://github.com/Netflix/RxJava/blob/df0436c9293f05de2f00f9ef50b6be0b053d99fc/language-adaptors/rxjava-scala/TODO.md). 
@madnl your `collect` looks good, but we would also like to have some unit tests. (We had the following unit test policy for Scala adaptor until now: If a method just calls the corresponding RxJava method, no need for a test, but if new functionality is added, also add a test).
 =||= This conflicts so can't be cleanly merged. Can unit tests be added and a new pull request submitted after rebasing changes from master?
 =||= ,0
4225,3850,Unsubscribed observer receives event,This code:

``` java
import rx.Observable;
import rx.Subscription;
import rx.subjects.PublishSubject;

final class Unsubscribing {

   private static Subscription mFirst;
   private static Subscription mSecond;

   public static void main(final String[] args) {
      final PublishSubject<Integer> publisher = PublishSubject.create();

      mFirst = publisher.subscribe(i -> {
            mSecond.unsubscribe();
            log("first: " + i);
         } );

      mSecond = publisher.subscribe(i -> {
            log("second: " + i);
         } );


      publisher.onNext(1);
      publisher.onNext(2);
   }


   private static void log(final String msg) {
      System.out.println(msg);
   }

}
```

Unsubscribes second subscription in the first callback. At the time second callback called it is not subscribed (unsubscribe call completed for it). 

It's expected that second callback will not be called, but it is.

Output of that program is

```
first: 1
second: 1
first: 2
```,This is due to the best-effort way of unsubscribing: PublishSubject, to remain low overhead as possible, doesn't check `isUnsubscribed` before calling `onNext` on a child and the dispatch loop works on a snapshot of the available subscribers. Therefore, if the first unsubscribes the second, that is not becoming visible to `PublishSubject.onNext` but only the next time.
 =||= I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.
 =||= @akarnokd isn't from point of view of observer pattern, which is rx based on, this situation is incorrect?

 I mean "subscribed" and "unsubscribed" states from abstraction's point of view differs only by fact if observer continues to receive events. "Subscribed" == "receives events", "unsubscribed" == "not receives events". 

Is this something to be fixed, or user code needs additional checks to ensure that unsubscribed subscriber will not get events?
 =||= Yes, you should check `mSecond.isUnsubscribed()` in this case.
 =||= @akarnokd as a consequence this makes "unsubscribe" method non trustworthy.

Every time this method is used we need additinally check if subscriber was unsubscrubed when receiving events.

Imagine next code:

``` java
public final class SomeMechanics {
    private final Subscription mEventSubscription;

    public SomeMechanics(final Observable<Event> eventStream) {
        mEventSubscription = eventStream.subscribe(/* ... */);
    } 

    public void stop() {
        mEventSubscription.unsubscribe();
    } 
} 
```

This code must check if mEventSubscription is unsubscribed because it can't guarantee the conditions "stop" called from.

``` java
public final class SomeMechanics {
    private final Subscription mEventSubscription;

    public SomeMechanics(final Observable<Event> eventStream) {
        mEventSubscription 
            = eventStream.subscribe(onNext -> {
                    if (mEventSubscription.isUnsubscribed()) return;

                    // do stuff
                } );
    } 

    public void stop() {
        mEventSubscription.unsubscribe();
    } 
}
```

Moreover, that behavior is in contradictory in the description of "unsubscribe" method from documentation: http://reactivex.io/RxJava/javadoc/rx/Subscription.html#unsubscribe()
 =||= See #4225 for an update to `PublishSubject` which includes a fix for this case.
 =||= @akarnokd thanks!
 =||= ,0
4226,4216,1.x: Feature Request Single#flatMapCompletable,Would be nice to flatMap from Single to Completable unless there is any other way to do this right now. `flatMapObservable` already does exist.

Happy to hear thoughts on that from you guys.,PR welcome.
 =||= I'm curious how would you start implementing this?
 =||= Subscribe to the `Single` and in the `onSuccess`, call the mapper and subscribe to the returned `Completable`.
 =||= Closing via #4226.
 =||= ,0
4229,4228,OperatorReplay leaks its subscribers,We use `replay(1)` a lot in our Android projects. All subscriptions are kept in `CompositeSubscription` and, of course, we always clear it when we don't need it anymore.

Even though we unsubscribe from observable, subscriber won't get collected by GC, because it is referenced by `OperatorReplay`, which prevents Activity or Fragment from being garbage collected. We do need to keep observable alive and resubscribe to it from new Activity instance, but now we can't use replay() as all our Activities are leaked.

Right now we downgraded back to 1.1.5. Alternatively, one can use `publish()` with behavior subject to work around this issue. I believe the issue was introduced in one of the latest versions of the library (perhaps 1.1.6, not sure though).,Do you have your replay in a completed state or with infrequent updates?
 =||= Infinite stream is "replayed", so, I guess, it is never in a completed state. 
What do you mean by infrequent updates?
 =||= Connectable observable with replay example (no error handling to keep it simple): 

``` kotlin
val dataStream = refreshes.startWith(Unit)
        .flatMap { model.getData() }
        .replay(1)
```

When presenter is created we connect to the stream and store subscription until presenter is destroyed:

``` kotlin
val presenterSubscription = CompositeSubscription()
val viewSubscription = CompositeSubscription()

presenterSubscription.add(dataStream.connect())
```

View is attached to presenter:

``` kotlin
// subscribe view to the data stream, subscriber has a strong reference to view
viewSubscription.add(dataStream.subscribe {  view.showContent(it) })
```

View detached from presenter:

``` kotlin
// clear view subscription
// after this there should be no strong references to the view
viewSubscription.clear()
```

When presenter is destroyed (when activity is closed): 

``` kotlin
presenterSubscription.unsubscribe()
```

Throughout the presenter lifecycle, different instances of view are attached and then detached (for instance, during screen rotation when Activity is recreated). However, after the new view instance is attached, the old instance is still referenced from within OperatorReplay. According to heap dump analysis, each time there exist only two instances of the view – no matter how I many times I rotate the screen, there are two instances of view: current and only 1 leaked view.
 =||=  👍 
 =||= Thanks for the report. This is a bug in `replay()`'s internal cache of `Subscriber`s. I've posted a PR #4229 with the fix. A temporary workaround is to use `onTerminateDetach` on the `ConnectableObservable` the `replay()` returns and subscribe through it. 
 =||= Fixed via #4229.
 =||= ,0
4231,4230,Schedulers.io() reuses blocked threads,Some actions are not interruptible. Since Schedulers.io() reuses threads after unsubscribe, a previous uninterruptible action might block execution of new actions, causing unexpected delays or in some cases, deadlocks.,Could you give an example of such non-interruptible blocking tasks?
 =||= @akarnokd A concrete example is in the test case that I added in #4231, but in general any task that is carelessly written (swallows `InterruptedException`, or busy looping, etc.) will trigger this issue. 

Example:

```
int numClients = 0;
for (Server s : servers) {
    try {
        numClients += s.queryNumClients();
    } catch (Exception e) {
        // Assume 0 clients
    }
}
return numClients;
```

The `InterruptedException` caused by `unsubscribe()` is swallowed and if the next `s.queryNumClients()` blocks for minutes, then this will block the thread for minutes.

What's worse is that this may even come from 3rd party code that also uses `Schedulers.io()` and cause extremely hard to debug problems.
 =||= I see. I'd consider the fix in #4231 as a temporary workaround because such tasks will keep blocking out threads (and leak resources). Generally, this is what `newThread()` is handy for: you get a new thread that can be blocked without the fear of reuse. Send such untrustwothy tasks to newThread() and the rest to io().
 =||= Absolutely, #4231 only prevents other tasks from being blocked by the misbehaving task, it does't prevent the thread (and potentially other resource) leaks.

I believe the thread leak would be present with `newThread()` as well and there is not much we can do about this. There is `Thread.stop()` but it introduces more problems than it solves. Hopefully the misbehaving task will complete eventually and at that point the resources will be freed up. If it never completes then it's a lost thread and the resources are leaked permanently.
 =||= I happened to face this bug today, was using RxJava 1.1.2. After half an hour of debugging went to check for newer version, and guess what - first bug fix in release notes is exactly the one I was fighting. Pulled latest, everything works like a charm. Thank you guys!
 =||= ,0
4241,4175,testRetryWithBackpressureParallel failed,Just [failed on Travis](https://travis-ci.org/ReactiveX/RxJava/builds/143126717). Last time it was some time ago.

```
rx.internal.operators.OperatorRetryTest > testRetryWithBackpressureParallel FAILED
    java.lang.AssertionError: Data content mismatch: 15={beginningEveryTime x 128}
        at org.junit.Assert.fail(Assert.java:88)
        at rx.internal.operators.OperatorRetryTest.testRetryWithBackpressureParallel(OperatorRetryTest.java:771)
```,Closing as appears to be fixed with #4241.
 =||= ,0
4244,4242,Observable.map unsubscribe question,Just looking at `OnSubscribeMap`  and I noticed a possibly undesirable `unsubscribe()` call in `MapSubscriber` (L72):

``` java
        @Override
        public void onNext(T t) {
            R result;

            try {
                result = mapper.call(t);
            } catch (Throwable ex) {
                Exceptions.throwIfFatal(ex);
                unsubscribe();
                onError(OnErrorThrowable.addValueAsLastCause(ex, t));
                return;
            }

            actual.onNext(result);
        }
```

If an exception occurs we eagerly unsubscribe from the source before emitting the error. I'm not sure we have a policy on this yet but my first impression is that a length `unsubscribe` activity could delay the emission of the error and this might not be expected. I wonder if we should delete this `unsubscribe()` call?,Another question about `OnSubscribeMap` is the defensive use of `done`. Is this necessary and can I remove it (and thus reduce allocation)? I know the boolean is only one bit but requires a byte and with padding can be up to 8 bytes.

``` java
        @Override
        public void onError(Throwable e) {
            if (done) {
                RxJavaHooks.onError(e);
                return;
            }
            done = true;

            actual.onError(e);
        }


        @Override
        public void onCompleted() {
            if (done) {
                return;
            }
            actual.onCompleted();
        }
```
 =||= It has to tell the upstream to stop emitting. Most `unsubscribe` is simple enough that this doesn't take that long.

The defensive `done` is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.

Don't change anything in map.
 =||= > It has to tell the upstream to stop emitting. Most unsubscribe is simple enough that this doesn't take that long.
> 
> The defensive done is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.
> 
> Don't change anything in map.

Righto. As a general rule then is it fair to say when an operator maps an `onNext` emission to a terminal event that we should follow this pattern (unsubscribe eagerly and use defensive `done` flag)?
 =||= Yes. I found a bunch of operators violating this rule before (around the same time map and filter were fixed) but there could be others.
 =||= I thought I'd add this rule to the https://github.com/ReactiveX/RxJava/wiki/Implementing-custom-operators-(draft) page but I couldn't edit it. I was thinking of adding  just above Further Reading.

When an operator maps an `onNext` emission to a terminal event then before calling the terminal event it should unsubscribe the subscriber to upstream (usually called the `parent`). In addition,  because upstream may (legally) do something like this:

``` java
child.onNext(blah);
//  no check for unsubscribed here
child.onCompleted();
```

we should ensure that the operator complies with the Observable contract and only emits one terminal event so we use a defensive `done` flag:

``` java
boolean done = false;

@Override 
public void onError(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}

@Override 
public void onCompleted(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}
```

An example of this pattern is seen in `OnSubscribeMap`.

Would you like to add this info the wiki page @akarnokd?
 =||= Done.
 =||= Thanks. I'll have a look for operators not complying with this.
 =||= You might consider instead adding this information to the page at

http://reactivex.io/documentation/implement-operator.html
("Implementing Your Own Operators")

as most of the RxJava operator-oriented documentation has moved to the
reactivex.io site.

On Tue, Jul 26, 2016 at 2:02 PM, Dave Moten notifications@github.com
wrote:

> Closed #4242 https://github.com/ReactiveX/RxJava/issues/4242.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4242#event-735581367, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AESHoLGkvnfudKMCu9u0-7yQbwC8RKZVks5qZnXPgaJpZM4JUm1d
> .

## 

David M. Gross
PLP Consulting
 =||= Good idea @DavidMGross, I'll make a PR
 =||= ,0
4245,4242,Observable.map unsubscribe question,Just looking at `OnSubscribeMap`  and I noticed a possibly undesirable `unsubscribe()` call in `MapSubscriber` (L72):

``` java
        @Override
        public void onNext(T t) {
            R result;

            try {
                result = mapper.call(t);
            } catch (Throwable ex) {
                Exceptions.throwIfFatal(ex);
                unsubscribe();
                onError(OnErrorThrowable.addValueAsLastCause(ex, t));
                return;
            }

            actual.onNext(result);
        }
```

If an exception occurs we eagerly unsubscribe from the source before emitting the error. I'm not sure we have a policy on this yet but my first impression is that a length `unsubscribe` activity could delay the emission of the error and this might not be expected. I wonder if we should delete this `unsubscribe()` call?,Another question about `OnSubscribeMap` is the defensive use of `done`. Is this necessary and can I remove it (and thus reduce allocation)? I know the boolean is only one bit but requires a byte and with padding can be up to 8 bytes.

``` java
        @Override
        public void onError(Throwable e) {
            if (done) {
                RxJavaHooks.onError(e);
                return;
            }
            done = true;

            actual.onError(e);
        }


        @Override
        public void onCompleted() {
            if (done) {
                return;
            }
            actual.onCompleted();
        }
```
 =||= It has to tell the upstream to stop emitting. Most `unsubscribe` is simple enough that this doesn't take that long.

The defensive `done` is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.

Don't change anything in map.
 =||= > It has to tell the upstream to stop emitting. Most unsubscribe is simple enough that this doesn't take that long.
> 
> The defensive done is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.
> 
> Don't change anything in map.

Righto. As a general rule then is it fair to say when an operator maps an `onNext` emission to a terminal event that we should follow this pattern (unsubscribe eagerly and use defensive `done` flag)?
 =||= Yes. I found a bunch of operators violating this rule before (around the same time map and filter were fixed) but there could be others.
 =||= I thought I'd add this rule to the https://github.com/ReactiveX/RxJava/wiki/Implementing-custom-operators-(draft) page but I couldn't edit it. I was thinking of adding  just above Further Reading.

When an operator maps an `onNext` emission to a terminal event then before calling the terminal event it should unsubscribe the subscriber to upstream (usually called the `parent`). In addition,  because upstream may (legally) do something like this:

``` java
child.onNext(blah);
//  no check for unsubscribed here
child.onCompleted();
```

we should ensure that the operator complies with the Observable contract and only emits one terminal event so we use a defensive `done` flag:

``` java
boolean done = false;

@Override 
public void onError(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}

@Override 
public void onCompleted(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}
```

An example of this pattern is seen in `OnSubscribeMap`.

Would you like to add this info the wiki page @akarnokd?
 =||= Done.
 =||= Thanks. I'll have a look for operators not complying with this.
 =||= You might consider instead adding this information to the page at

http://reactivex.io/documentation/implement-operator.html
("Implementing Your Own Operators")

as most of the RxJava operator-oriented documentation has moved to the
reactivex.io site.

On Tue, Jul 26, 2016 at 2:02 PM, Dave Moten notifications@github.com
wrote:

> Closed #4242 https://github.com/ReactiveX/RxJava/issues/4242.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4242#event-735581367, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AESHoLGkvnfudKMCu9u0-7yQbwC8RKZVks5qZnXPgaJpZM4JUm1d
> .

## 

David M. Gross
PLP Consulting
 =||= Good idea @DavidMGross, I'll make a PR
 =||= ,0
4246,4242,Observable.map unsubscribe question,Just looking at `OnSubscribeMap`  and I noticed a possibly undesirable `unsubscribe()` call in `MapSubscriber` (L72):

``` java
        @Override
        public void onNext(T t) {
            R result;

            try {
                result = mapper.call(t);
            } catch (Throwable ex) {
                Exceptions.throwIfFatal(ex);
                unsubscribe();
                onError(OnErrorThrowable.addValueAsLastCause(ex, t));
                return;
            }

            actual.onNext(result);
        }
```

If an exception occurs we eagerly unsubscribe from the source before emitting the error. I'm not sure we have a policy on this yet but my first impression is that a length `unsubscribe` activity could delay the emission of the error and this might not be expected. I wonder if we should delete this `unsubscribe()` call?,Another question about `OnSubscribeMap` is the defensive use of `done`. Is this necessary and can I remove it (and thus reduce allocation)? I know the boolean is only one bit but requires a byte and with padding can be up to 8 bytes.

``` java
        @Override
        public void onError(Throwable e) {
            if (done) {
                RxJavaHooks.onError(e);
                return;
            }
            done = true;

            actual.onError(e);
        }


        @Override
        public void onCompleted() {
            if (done) {
                return;
            }
            actual.onCompleted();
        }
```
 =||= It has to tell the upstream to stop emitting. Most `unsubscribe` is simple enough that this doesn't take that long.

The defensive `done` is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.

Don't change anything in map.
 =||= > It has to tell the upstream to stop emitting. Most unsubscribe is simple enough that this doesn't take that long.
> 
> The defensive done is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.
> 
> Don't change anything in map.

Righto. As a general rule then is it fair to say when an operator maps an `onNext` emission to a terminal event that we should follow this pattern (unsubscribe eagerly and use defensive `done` flag)?
 =||= Yes. I found a bunch of operators violating this rule before (around the same time map and filter were fixed) but there could be others.
 =||= I thought I'd add this rule to the https://github.com/ReactiveX/RxJava/wiki/Implementing-custom-operators-(draft) page but I couldn't edit it. I was thinking of adding  just above Further Reading.

When an operator maps an `onNext` emission to a terminal event then before calling the terminal event it should unsubscribe the subscriber to upstream (usually called the `parent`). In addition,  because upstream may (legally) do something like this:

``` java
child.onNext(blah);
//  no check for unsubscribed here
child.onCompleted();
```

we should ensure that the operator complies with the Observable contract and only emits one terminal event so we use a defensive `done` flag:

``` java
boolean done = false;

@Override 
public void onError(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}

@Override 
public void onCompleted(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}
```

An example of this pattern is seen in `OnSubscribeMap`.

Would you like to add this info the wiki page @akarnokd?
 =||= Done.
 =||= Thanks. I'll have a look for operators not complying with this.
 =||= You might consider instead adding this information to the page at

http://reactivex.io/documentation/implement-operator.html
("Implementing Your Own Operators")

as most of the RxJava operator-oriented documentation has moved to the
reactivex.io site.

On Tue, Jul 26, 2016 at 2:02 PM, Dave Moten notifications@github.com
wrote:

> Closed #4242 https://github.com/ReactiveX/RxJava/issues/4242.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4242#event-735581367, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AESHoLGkvnfudKMCu9u0-7yQbwC8RKZVks5qZnXPgaJpZM4JUm1d
> .

## 

David M. Gross
PLP Consulting
 =||= Good idea @DavidMGross, I'll make a PR
 =||= ,0
4250,4242,Observable.map unsubscribe question,Just looking at `OnSubscribeMap`  and I noticed a possibly undesirable `unsubscribe()` call in `MapSubscriber` (L72):

``` java
        @Override
        public void onNext(T t) {
            R result;

            try {
                result = mapper.call(t);
            } catch (Throwable ex) {
                Exceptions.throwIfFatal(ex);
                unsubscribe();
                onError(OnErrorThrowable.addValueAsLastCause(ex, t));
                return;
            }

            actual.onNext(result);
        }
```

If an exception occurs we eagerly unsubscribe from the source before emitting the error. I'm not sure we have a policy on this yet but my first impression is that a length `unsubscribe` activity could delay the emission of the error and this might not be expected. I wonder if we should delete this `unsubscribe()` call?,Another question about `OnSubscribeMap` is the defensive use of `done`. Is this necessary and can I remove it (and thus reduce allocation)? I know the boolean is only one bit but requires a byte and with padding can be up to 8 bytes.

``` java
        @Override
        public void onError(Throwable e) {
            if (done) {
                RxJavaHooks.onError(e);
                return;
            }
            done = true;

            actual.onError(e);
        }


        @Override
        public void onCompleted() {
            if (done) {
                return;
            }
            actual.onCompleted();
        }
```
 =||= It has to tell the upstream to stop emitting. Most `unsubscribe` is simple enough that this doesn't take that long.

The defensive `done` is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.

Don't change anything in map.
 =||= > It has to tell the upstream to stop emitting. Most unsubscribe is simple enough that this doesn't take that long.
> 
> The defensive done is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.
> 
> Don't change anything in map.

Righto. As a general rule then is it fair to say when an operator maps an `onNext` emission to a terminal event that we should follow this pattern (unsubscribe eagerly and use defensive `done` flag)?
 =||= Yes. I found a bunch of operators violating this rule before (around the same time map and filter were fixed) but there could be others.
 =||= I thought I'd add this rule to the https://github.com/ReactiveX/RxJava/wiki/Implementing-custom-operators-(draft) page but I couldn't edit it. I was thinking of adding  just above Further Reading.

When an operator maps an `onNext` emission to a terminal event then before calling the terminal event it should unsubscribe the subscriber to upstream (usually called the `parent`). In addition,  because upstream may (legally) do something like this:

``` java
child.onNext(blah);
//  no check for unsubscribed here
child.onCompleted();
```

we should ensure that the operator complies with the Observable contract and only emits one terminal event so we use a defensive `done` flag:

``` java
boolean done = false;

@Override 
public void onError(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}

@Override 
public void onCompleted(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}
```

An example of this pattern is seen in `OnSubscribeMap`.

Would you like to add this info the wiki page @akarnokd?
 =||= Done.
 =||= Thanks. I'll have a look for operators not complying with this.
 =||= You might consider instead adding this information to the page at

http://reactivex.io/documentation/implement-operator.html
("Implementing Your Own Operators")

as most of the RxJava operator-oriented documentation has moved to the
reactivex.io site.

On Tue, Jul 26, 2016 at 2:02 PM, Dave Moten notifications@github.com
wrote:

> Closed #4242 https://github.com/ReactiveX/RxJava/issues/4242.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4242#event-735581367, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AESHoLGkvnfudKMCu9u0-7yQbwC8RKZVks5qZnXPgaJpZM4JUm1d
> .

## 

David M. Gross
PLP Consulting
 =||= Good idea @DavidMGross, I'll make a PR
 =||= ,0
4251,4242,Observable.map unsubscribe question,Just looking at `OnSubscribeMap`  and I noticed a possibly undesirable `unsubscribe()` call in `MapSubscriber` (L72):

``` java
        @Override
        public void onNext(T t) {
            R result;

            try {
                result = mapper.call(t);
            } catch (Throwable ex) {
                Exceptions.throwIfFatal(ex);
                unsubscribe();
                onError(OnErrorThrowable.addValueAsLastCause(ex, t));
                return;
            }

            actual.onNext(result);
        }
```

If an exception occurs we eagerly unsubscribe from the source before emitting the error. I'm not sure we have a policy on this yet but my first impression is that a length `unsubscribe` activity could delay the emission of the error and this might not be expected. I wonder if we should delete this `unsubscribe()` call?,Another question about `OnSubscribeMap` is the defensive use of `done`. Is this necessary and can I remove it (and thus reduce allocation)? I know the boolean is only one bit but requires a byte and with padding can be up to 8 bytes.

``` java
        @Override
        public void onError(Throwable e) {
            if (done) {
                RxJavaHooks.onError(e);
                return;
            }
            done = true;

            actual.onError(e);
        }


        @Override
        public void onCompleted() {
            if (done) {
                return;
            }
            actual.onCompleted();
        }
```
 =||= It has to tell the upstream to stop emitting. Most `unsubscribe` is simple enough that this doesn't take that long.

The defensive `done` is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.

Don't change anything in map.
 =||= > It has to tell the upstream to stop emitting. Most unsubscribe is simple enough that this doesn't take that long.
> 
> The defensive done is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.
> 
> Don't change anything in map.

Righto. As a general rule then is it fair to say when an operator maps an `onNext` emission to a terminal event that we should follow this pattern (unsubscribe eagerly and use defensive `done` flag)?
 =||= Yes. I found a bunch of operators violating this rule before (around the same time map and filter were fixed) but there could be others.
 =||= I thought I'd add this rule to the https://github.com/ReactiveX/RxJava/wiki/Implementing-custom-operators-(draft) page but I couldn't edit it. I was thinking of adding  just above Further Reading.

When an operator maps an `onNext` emission to a terminal event then before calling the terminal event it should unsubscribe the subscriber to upstream (usually called the `parent`). In addition,  because upstream may (legally) do something like this:

``` java
child.onNext(blah);
//  no check for unsubscribed here
child.onCompleted();
```

we should ensure that the operator complies with the Observable contract and only emits one terminal event so we use a defensive `done` flag:

``` java
boolean done = false;

@Override 
public void onError(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}

@Override 
public void onCompleted(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}
```

An example of this pattern is seen in `OnSubscribeMap`.

Would you like to add this info the wiki page @akarnokd?
 =||= Done.
 =||= Thanks. I'll have a look for operators not complying with this.
 =||= You might consider instead adding this information to the page at

http://reactivex.io/documentation/implement-operator.html
("Implementing Your Own Operators")

as most of the RxJava operator-oriented documentation has moved to the
reactivex.io site.

On Tue, Jul 26, 2016 at 2:02 PM, Dave Moten notifications@github.com
wrote:

> Closed #4242 https://github.com/ReactiveX/RxJava/issues/4242.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4242#event-735581367, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AESHoLGkvnfudKMCu9u0-7yQbwC8RKZVks5qZnXPgaJpZM4JUm1d
> .

## 

David M. Gross
PLP Consulting
 =||= Good idea @DavidMGross, I'll make a PR
 =||= ,0
4252,4242,Observable.map unsubscribe question,Just looking at `OnSubscribeMap`  and I noticed a possibly undesirable `unsubscribe()` call in `MapSubscriber` (L72):

``` java
        @Override
        public void onNext(T t) {
            R result;

            try {
                result = mapper.call(t);
            } catch (Throwable ex) {
                Exceptions.throwIfFatal(ex);
                unsubscribe();
                onError(OnErrorThrowable.addValueAsLastCause(ex, t));
                return;
            }

            actual.onNext(result);
        }
```

If an exception occurs we eagerly unsubscribe from the source before emitting the error. I'm not sure we have a policy on this yet but my first impression is that a length `unsubscribe` activity could delay the emission of the error and this might not be expected. I wonder if we should delete this `unsubscribe()` call?,Another question about `OnSubscribeMap` is the defensive use of `done`. Is this necessary and can I remove it (and thus reduce allocation)? I know the boolean is only one bit but requires a byte and with padding can be up to 8 bytes.

``` java
        @Override
        public void onError(Throwable e) {
            if (done) {
                RxJavaHooks.onError(e);
                return;
            }
            done = true;

            actual.onError(e);
        }


        @Override
        public void onCompleted() {
            if (done) {
                return;
            }
            actual.onCompleted();
        }
```
 =||= It has to tell the upstream to stop emitting. Most `unsubscribe` is simple enough that this doesn't take that long.

The defensive `done` is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.

Don't change anything in map.
 =||= > It has to tell the upstream to stop emitting. Most unsubscribe is simple enough that this doesn't take that long.
> 
> The defensive done is required as some sources don't expect unsubscription before sending out the terminal event and would cause double termination in many cases.
> 
> Don't change anything in map.

Righto. As a general rule then is it fair to say when an operator maps an `onNext` emission to a terminal event that we should follow this pattern (unsubscribe eagerly and use defensive `done` flag)?
 =||= Yes. I found a bunch of operators violating this rule before (around the same time map and filter were fixed) but there could be others.
 =||= I thought I'd add this rule to the https://github.com/ReactiveX/RxJava/wiki/Implementing-custom-operators-(draft) page but I couldn't edit it. I was thinking of adding  just above Further Reading.

When an operator maps an `onNext` emission to a terminal event then before calling the terminal event it should unsubscribe the subscriber to upstream (usually called the `parent`). In addition,  because upstream may (legally) do something like this:

``` java
child.onNext(blah);
//  no check for unsubscribed here
child.onCompleted();
```

we should ensure that the operator complies with the Observable contract and only emits one terminal event so we use a defensive `done` flag:

``` java
boolean done = false;

@Override 
public void onError(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}

@Override 
public void onCompleted(Throwable e) {
    if (done) {
        return;
   }
   done = true;
   ...
}
```

An example of this pattern is seen in `OnSubscribeMap`.

Would you like to add this info the wiki page @akarnokd?
 =||= Done.
 =||= Thanks. I'll have a look for operators not complying with this.
 =||= You might consider instead adding this information to the page at

http://reactivex.io/documentation/implement-operator.html
("Implementing Your Own Operators")

as most of the RxJava operator-oriented documentation has moved to the
reactivex.io site.

On Tue, Jul 26, 2016 at 2:02 PM, Dave Moten notifications@github.com
wrote:

> Closed #4242 https://github.com/ReactiveX/RxJava/issues/4242.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4242#event-735581367, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AESHoLGkvnfudKMCu9u0-7yQbwC8RKZVks5qZnXPgaJpZM4JUm1d
> .

## 

David M. Gross
PLP Consulting
 =||= Good idea @DavidMGross, I'll make a PR
 =||= ,0
4261,4152,1.x: concatDelayError with multiple args,I think it'd be great if `concatDelayError` supports multiple parameters as `mergeDelayError`.

Btw, doesn't `mergeDelayError` miss a variation in which a variable number of args is admitted?,/cc @matir91
 =||= The general problem with these that they expand the API surface (like + 8 methods per operator) which is already 'bloated'.

We don't do variable arguments in Java 6 because it necessitates `@SuppressWarnings` almost always (hence the convenience 2-9 arg operators).
 =||= Closing via #4261.
 =||= ,0
4262,4260,OperatorDoEach could do with some work,While looking for emissions after terminal events I was looking at `OperatorDoEach` which is called by `doOnNext`, `doOnError`, `doOnCompleted`, and `doOnEach` of course. I noticed these things:
- lots of wasted allocations per call (use of `ActionSubscriber` when all that is needed is an `ActionObserver`) and passing three actions to `OperatorDoEach` when for three of the four operators we only need one action.
- it doesn't call `RxJavaHooks.error` for secondary error emissions from upstream
- it does call `Exceptions.throwIfFatal` for all error emissions (do we want to do this generally? I haven't seen it much outside error catching on externally supplied functions or actions)

I'd quite like to see `doOnNext` and `doOnError` in particular more efficient because I use them a lot. Should I create dedicated Operator/OnSubscribe classes for the single action operators or perhaps one shared one that has an extra parameter (to indicate what notification type is being used)?,You may optimize it into an OnSubscribe. I'm not sure about splitting as it triples the method count for the sake of saving 16 bytes.
 =||= I could also use `ActionObserver` instead of `ActionSubscriber` I suppose (saves 32 bytes). Let me know what you think of the `throwIfFatal` issue and I'll do it.
 =||= The `throwIfFatal` shouldn't be there; the operators should not call onError with a fatal exceptions anymore but throw them immediately - this should be also reviewed and fixed in 2.x as well.
 =||= FYI, I follow [this](https://gist.github.com/akarnokd/693866d6b4453ca8c66b866584163e5e) list when I port tests.
 =||= Closing via #4262.
 =||= ,0
4264,4263,Observable.sort method,I'd like to add `Observable.sort` (or `Observable.sorted`) to the API. I tried this a couple of years ago and it was knocked back but now that people are getting used to the offerings of java 8 streams for instance (and its `.sorted()` method) I thought I'd raise it again.

In particular to sort a stream at the moment  I have to call 

`observable.toSortedList().flatMapIterable(x -> x)`

or using an internal class:

`observable.toSortedList().flatMapIterable(UtilityFunctions.<T>identity())`

This is poor for discoverability, hard to read, and pretty disappointing when I want to show off RxJava's coolness.

Any takers?,@davidmoten would you forward the calls to corresponding toSortedList() like your example: 
`observable.toSortedList().flatMapIterable(UtilityFunctions.<T>identity())`  ?
I'm curious if you would implement it differently
 =||= @SherifMakhlouf yes I'd forward the call because I think there are enough operators to support as is.
 =||= @SherifMakhlouf happy for you to run with PR. I was looking for support from committers before making one.
 =||= @davidmoten Thanks ! glad to support !
 =||= We may want to consider `Observable<T> mergeSorted(Observable<Observable<T> sortedObservables, Func2<T, T, Integer> sortFunction)` that takes a two or more already sorted observables and produces a new sorted observable with the results merged. It would work kind of like zip where is would wait for at least one onNext from each inner `Observable<T>` and only emit the smallest `T`.
 =||= @abersnaze yep I use that functionality and there is an operator for that [`orderedMergeWith`](https://github.com/davidmoten/rxjava-extras#transformersorderedmergewith) in _rxjava-extras_. It was written by @akarnokd.
 =||= Closing via #4264.
 =||= ,0
4288,4280,2.x: Exceptions is in internal package,...despite its tests being in the public API package.

It's hard to write libraries without `Exceptions.throwIfFatal`. Should this be in the public API?,Possibly, what should happen with the rest of the methods?

If you'd review #4278 that would allow the refactoring to happen without interference.
 =||= I would think they'd split, although having two classes of the same name would obviously be less than ideal. Maybe it could be hoisted onto RxJavaPlugins since its often used with calling `RxJavaPlugins.onError`? There could even be a combination method that does both, since there's a few hundred uses of the pair throughout RxJava's codebase as-is.
 =||= This can be closed! 🎉 
 =||= Oh wait it's my issue, I can do that!
 =||= ,0
4297,404,Add fromChangeEvents methods to SwingObservable,For swing components which fire `ChangeEvent`s, I added a method `SwingObservable.fromChangeEvents`, similar to the other methods of `SwingObservable`. 

Unfortunately, there is no common base interface for all components which fire `ChangeEvents`s, so I created one myself: `ChangeEventSource.ChangeEventComponentWrapper`.

Then, each component which fires `ChangeEvents`s needs its own overload in `SwingObservable`.

An other approach would be to use reflection, but then we loose typesafety.,[RxJava-pull-requests #309](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/309/) ABORTED
 =||= Before merging this, we should also try a solution with reflection and then decide which one is better.
 =||= @jmhofer Can you comment on this as well since you were involved in the first submission of rxjava-swing?
 =||= Looks good to me. - Will all these overloads work with dynamic languages, though?

I wouldn't want to switch to reflection for this, even if it's a bit ugly doing all this by hand.
 =||= I think we should at least try a solution with reflection, because this would also work with custom components which have `addChangeListener` and `removeChangeListener` methods. With reflection, we lose typesafety, but C# also uses reflection when I call something like

``` cs
Observable.FromEventPattern<EventArgs>(myTextFieldComponent, "TextChanged")
```

see http://msdn.microsoft.com/en-us/library/hh229424(v=vs.103).aspx
 =||= I'm always very sceptical when it comes to anything to do with reflection, but I see your point. If I understand you right, you want to simulate a Scala structural type here, correct? This could very well be worth it.
 =||= [RxJava-pull-requests #318](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/318/) FAILURE
Looks like there's a problem with this pull request
 =||= For testing the negative maybe send a mock(Observer) and then verify(obr, times(1)).onNext(sentEvent).
 =||= This is a very long discussion ... is this ready for final review and merge?
 =||= @abersnaze Is this ready to merge?
 =||= I've added some more commits, just to avoid duplicate work, but IMHO this is not yet ready for merge.
 =||= [RxJava-pull-requests #340](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/340/) SUCCESS
This pull request looks good
 =||= Is this waiting on people's time or is there something fundamental still to decide upon?
 =||= Last comment 20 days ago was that this is still not ready to merge so where is this going?
 =||= I think the current reflection-based approach is good, but the unit tests need to be rewritten from scratch, and it might also need some polishing. I don't have time now, but if no one does it until December, I will do it then.
 =||= Closing ... if any of you want to revive at some point please send another request.
 =||= ,0
4299,404,Add fromChangeEvents methods to SwingObservable,For swing components which fire `ChangeEvent`s, I added a method `SwingObservable.fromChangeEvents`, similar to the other methods of `SwingObservable`. 

Unfortunately, there is no common base interface for all components which fire `ChangeEvents`s, so I created one myself: `ChangeEventSource.ChangeEventComponentWrapper`.

Then, each component which fires `ChangeEvents`s needs its own overload in `SwingObservable`.

An other approach would be to use reflection, but then we loose typesafety.,[RxJava-pull-requests #309](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/309/) ABORTED
 =||= Before merging this, we should also try a solution with reflection and then decide which one is better.
 =||= @jmhofer Can you comment on this as well since you were involved in the first submission of rxjava-swing?
 =||= Looks good to me. - Will all these overloads work with dynamic languages, though?

I wouldn't want to switch to reflection for this, even if it's a bit ugly doing all this by hand.
 =||= I think we should at least try a solution with reflection, because this would also work with custom components which have `addChangeListener` and `removeChangeListener` methods. With reflection, we lose typesafety, but C# also uses reflection when I call something like

``` cs
Observable.FromEventPattern<EventArgs>(myTextFieldComponent, "TextChanged")
```

see http://msdn.microsoft.com/en-us/library/hh229424(v=vs.103).aspx
 =||= I'm always very sceptical when it comes to anything to do with reflection, but I see your point. If I understand you right, you want to simulate a Scala structural type here, correct? This could very well be worth it.
 =||= [RxJava-pull-requests #318](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/318/) FAILURE
Looks like there's a problem with this pull request
 =||= For testing the negative maybe send a mock(Observer) and then verify(obr, times(1)).onNext(sentEvent).
 =||= This is a very long discussion ... is this ready for final review and merge?
 =||= @abersnaze Is this ready to merge?
 =||= I've added some more commits, just to avoid duplicate work, but IMHO this is not yet ready for merge.
 =||= [RxJava-pull-requests #340](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/340/) SUCCESS
This pull request looks good
 =||= Is this waiting on people's time or is there something fundamental still to decide upon?
 =||= Last comment 20 days ago was that this is still not ready to merge so where is this going?
 =||= I think the current reflection-based approach is good, but the unit tests need to be rewritten from scratch, and it might also need some polishing. I don't have time now, but if no one does it until December, I will do it then.
 =||= Closing ... if any of you want to revive at some point please send another request.
 =||= ,0
4300,4044,2.x: New base interface types,As part of the 2.x design, new base interface types have been recently merged & applied. The aim is to match the style of the Reactive-Streams base types + their fluent base class:

`Flowable` -> `Publisher` -> `Subscriber`
`Observable` -> `ObservableConsumable` -> `Observer`
`Single` -> `SingleConsumable` -> `SingleSubscriber`
`Completable` -> `CompletableConsumable` -> `CompletableSubscriber`

They feel odd to me too so any idea is welcome.,Just to be clear before I start thinking about this more, `Publisher` and `Subscriber` are the only RS types here, right? And `Single` and `Completable` are always backpressure-aware types?
 =||= > Publisher and Subscriber are the only RS types 

Yes.

> Single and Completable are always backpressure-aware types?

The other base types (including Observable) don't have a notion for backpressure.
 =||= Can we please keep names for `Observable`, `Single` and `Completable` since they're not part of [RS](https://github.com/reactive-streams/reactive-streams-jvm)? They're short and well known. 

I'd just rename `Observer` to `ObservableSubscriber` to have same pattern as `SingleSubscriber` and `CompletableSubscriber` and not interfere with `Publisher -> Subscriber`.
 =||= I wouldn't mind renaming `Observable` since it's a description of the pattern to which all these types conform. It's the least descriptive of the bunch, and you wouldn't chose it today given the others.

I used to like `Flowable`, and I still do, but now that we have a non-BP vs. BP distinction perhaps we should consider making BP-aware variants of all 3 types and using `Flowable` as an adjective instead of a noun? The problem is that gets verbose.
 =||= `Single` and `Completable` don't need backpressure because they emit 1 or 0 items respectively.

The non-backpressured `Observable` was requested to allow pure GUI event handling where the sources are hot and can't be backpressured.
 =||= Hmm what about the `request(0)` case though? Where work isn't triggered upon subscription but deferred until explicitly requested.
 =||= Sorry I mean the case where an operation cannot respect `request(0)`. I'm struggling to come up with an example, but I know I've ran into potential cases before but I never wrote them down (because we never had `Flowable` either).
 =||= The current rule of thumb is that if an operator can't respect the request amount, it will signal a `MissingBackpressureException` instead of overflowing the downstream. This behavior still requires request tracking. The reason for signalling is due to the confusion about the situation in 1.x where exception is signalled in the operator that suffered the buffer overflow attempt and no indication whose fault it was really.
 =||= There's also the `Subject` and `FlowProcessor` types in the mix here.
 =||= I made a chart of the current naming:

<img width="639" alt="screen shot 2016-08-07 at 2 11 01 am" src="https://cloud.githubusercontent.com/assets/66577/17460862/f27cd036-5c45-11e6-8b26-bfb5ae099d9e.png">

And here's my proposal for normalization:

<img width="639" alt="screen shot 2016-08-07 at 2 22 10 am" src="https://cloud.githubusercontent.com/assets/66577/17460866/00c2c01a-5c46-11e6-854d-6cecfdf4c5a9.png">

The changes from current `master` are highlighted.
 =||= :+1:
 =||= I'll give the Single changes a try.
 =||= Will continue with Completable once the other 2 PRs are merged to avoid merge conflicts.
 =||= The proposed new names have been applied and I guess this issue can be closed then if there is no further input.
 =||= Renames and refactorings happened.
 =||= ,0
4302,4044,2.x: New base interface types,As part of the 2.x design, new base interface types have been recently merged & applied. The aim is to match the style of the Reactive-Streams base types + their fluent base class:

`Flowable` -> `Publisher` -> `Subscriber`
`Observable` -> `ObservableConsumable` -> `Observer`
`Single` -> `SingleConsumable` -> `SingleSubscriber`
`Completable` -> `CompletableConsumable` -> `CompletableSubscriber`

They feel odd to me too so any idea is welcome.,Just to be clear before I start thinking about this more, `Publisher` and `Subscriber` are the only RS types here, right? And `Single` and `Completable` are always backpressure-aware types?
 =||= > Publisher and Subscriber are the only RS types 

Yes.

> Single and Completable are always backpressure-aware types?

The other base types (including Observable) don't have a notion for backpressure.
 =||= Can we please keep names for `Observable`, `Single` and `Completable` since they're not part of [RS](https://github.com/reactive-streams/reactive-streams-jvm)? They're short and well known. 

I'd just rename `Observer` to `ObservableSubscriber` to have same pattern as `SingleSubscriber` and `CompletableSubscriber` and not interfere with `Publisher -> Subscriber`.
 =||= I wouldn't mind renaming `Observable` since it's a description of the pattern to which all these types conform. It's the least descriptive of the bunch, and you wouldn't chose it today given the others.

I used to like `Flowable`, and I still do, but now that we have a non-BP vs. BP distinction perhaps we should consider making BP-aware variants of all 3 types and using `Flowable` as an adjective instead of a noun? The problem is that gets verbose.
 =||= `Single` and `Completable` don't need backpressure because they emit 1 or 0 items respectively.

The non-backpressured `Observable` was requested to allow pure GUI event handling where the sources are hot and can't be backpressured.
 =||= Hmm what about the `request(0)` case though? Where work isn't triggered upon subscription but deferred until explicitly requested.
 =||= Sorry I mean the case where an operation cannot respect `request(0)`. I'm struggling to come up with an example, but I know I've ran into potential cases before but I never wrote them down (because we never had `Flowable` either).
 =||= The current rule of thumb is that if an operator can't respect the request amount, it will signal a `MissingBackpressureException` instead of overflowing the downstream. This behavior still requires request tracking. The reason for signalling is due to the confusion about the situation in 1.x where exception is signalled in the operator that suffered the buffer overflow attempt and no indication whose fault it was really.
 =||= There's also the `Subject` and `FlowProcessor` types in the mix here.
 =||= I made a chart of the current naming:

<img width="639" alt="screen shot 2016-08-07 at 2 11 01 am" src="https://cloud.githubusercontent.com/assets/66577/17460862/f27cd036-5c45-11e6-8b26-bfb5ae099d9e.png">

And here's my proposal for normalization:

<img width="639" alt="screen shot 2016-08-07 at 2 22 10 am" src="https://cloud.githubusercontent.com/assets/66577/17460866/00c2c01a-5c46-11e6-854d-6cecfdf4c5a9.png">

The changes from current `master` are highlighted.
 =||= :+1:
 =||= I'll give the Single changes a try.
 =||= Will continue with Completable once the other 2 PRs are merged to avoid merge conflicts.
 =||= The proposed new names have been applied and I guess this issue can be closed then if there is no further input.
 =||= Renames and refactorings happened.
 =||= ,0
4309,4306,2.x: Unused exceptions in public API,Currently there's a few exceptions which are unused that are in the public API:
- `OnCompleteFailedException`
- `OnErrorFailedException`
- `OnErrorNotImplementedException`
- `UnsubscribeFailedException`

There are tests which use these for various reasons, but the primary cause of lack of use is that subscribers cannot throw according to the Reactive Streams specification.

This is just a tracking issue for doing something about that or removing them before 2.0.,Yes, they are there mostly to satisfy some tests that are mostly ignored by the way. Certainly we can't throw them  so they can be removed. If you remove them from tests, please keep the test method with `@Ignored` so they don't show up as missing for the test-sync I'm doing.
 =||= ,0
4317,4255,1.x: Rename Observable.fromAsync(),`fromAsync()` sounds like it's ok to emit from multiple threads in parallel while in fact it doesn't serialize emission.

Can we rename it? For example to `Observable.fromCallback()` which also seems more obvious to use when you convert callback-styled code to `Observable`.,The suggested name is too close to `fromCallable`. Besides, the Javadoc of `AsyncEmitter` warns about sequential use:

``` java
/**
 * Abstraction over a RxJava Subscriber that allows associating
 * a resource with it and exposes the current number of downstream
 * requested amount.
 * <p>
 * The onNext, onError and onCompleted methods should be called 
 * in a sequential manner, just like the Observer's methods. The
 * other methods are threadsafe.
 *
 * @param <T> the value type to emit
 */
```
 =||= > The suggested name is too close to fromCallable.

You're worried about dynamic languages like Groovy? They're not _that_ bad!

> Besides, the Javadoc of AsyncEmitter warns about sequential use

Well, to me it looks ~like `void threadSafe()` which has note in javadoc that it's not thread safe 😁 
 =||= They sound to similar and may lead to speaker embarrassment when mixed up, not to mention, users getting confused and Content assist/Intellisense bringing up both of them when typing `fromCall`.
 =||= I don't think something being asynchronous immediately implies that it's also concurrent.
 =||= True, but not a lot of people understand that.

Only because of `AsyncTask` a lot of Android devs think that async == bg
thread.

Another point is that `fromAsync()` is probably not what developer would
look into when he/she will need to convert callback-styled api to Rx,
`fromCallback()` looks more user-friendly (in my opinion of course).

On Fri, Aug 5, 2016 at 5:54 PM, Jake Wharton notifications@github.com
wrote:

> I don't think something being asynchronous immediately implies that it's
> also concurrent.
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4255#issuecomment-237872294,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AA7B3OtRTCnB7B8AxYvVICdAQeLktIVmks5qc07DgaJpZM4JXQRO
> .
 =||= Using an `AsyncTask` inside `fromAsync` would be perfectly fine since it's not concurrent.

`fromCallback` is clearly not usable for the reasons previously stated. I'm not against a rename, but I'm having a hard time coming up with a better name than what we already have.
 =||= I would almost rename _both_ `fromCallable` and `fromAsync` to just overloads of `from`. We already have a few overloads of `from` for adapting various sources so I don't see why these are treated any differently than just more sources.

Additionally, the naming conventions of `fromCallable` and `fromAsync` disagree with each other and other RxJava conventions.

The first one, `fromCallable`, describes the mechanism (`Callable`) of what it's adapting. We don't see `fromIterable` or `fromFuture` so why `fromCallable`?

`fromAsync`, on the other hand, describes the behavior that it is adapting (a callback-based source). Again, we don't have `fromSynchronous` or `justSynchronous` so why `fromAsync`? Additionally, `fromAsync` is perfectly usable for non-asynchronous sources. It's merely adapting a callback-based system (the foundation of Artem's argument) but there's no reason it has to be asynchronous. It might be just be abstracting over a visitor-based API.

I would prefer both of these be renamed to `from` because that's how you adapt an external implementation of a data source into an `Observable`. It doesn't matter if it's an `Iterable`, `Future`, `Callable`, or a callback-based source. I would also rename `AsyncEmitter` to just `Emitter` with this change.
 =||= Humorously enough, RxJava 2 actually does postfix `from` with the source (e.g., `fromArray`, `fromIterable`, etc.). I stand by my argument that both of these should be just `from()` in RxJava 1.x, and we can bikeshed the name for 2.x in a separate issue.
 =||= > I would almost rename both fromCallable and fromAsync to just overloads of from. 

I don't recommend it, Java 8 compiler gets sometimes quite confused, for example:

```
from(() -> 1)

from(() -> new Iterator() { })
```

In this case, `from()` could mean any of the prefixed operators and you'll end up casting a lot to make it right - postfix is shorter.
 =||= Great point. In that case, I still think `fromAsync` is the wrong name based solely on the fact that its a potentially-inaccurate description of what's being adapted, but I'm not sold on the need to change it for 1.x.
 =||= Could be `fromEmitter`.
 =||= `fromEmitter` sounds better than `fromAsync` to me, 👍 
 =||= See #4442.
 =||= Closing via #4442.
 =||= ,0
4317,4286,2.x: Add fromAsync Observable factory,but potentially with a different name based on what the resolution of #4255 is.,And bonus: no backpressure strategy argument needed!
 =||= I would also argue for the deletion of `Flowable.fromAsync` since it's just `Observable.fromAsync(...).toFlowable(strategy)` which isn't much longer than `Flowable.fromAsync(..., strategy)`. Plus visitor/callback-based APIs are unlikely to have built-in backpressure so it makes sense to wrap them as a backpressure-free type and then apply a strategy.
 =||= :+1:
 =||= I'll try to give this a go tomorrow. I'm afraid I've sent too many PRs already and the statistical likelihood of conflicts is approaching 100%.
 =||= I have an alternate proposal:
- Remove `Flowable.fromAsync` + `AsyncEmitter`
- Rename `Observable.create` to `Observable.unsafeCreate`
- Add `Observable.create` which wraps the incoming `Observer` in one which checks for cancelation (similar to what `BaseAsyncEmitter` is doing now).

This has a few advantages:
- It makes `Observable.create(ObservableSource)` actually usable by "normal" users! No more traps to fall in!
- It still allows fully-compliant `ObservableSource` implementations via `unsafeCreate` (or subclassing).
- It re-uses the same interface types and names we already have without needing new ones.
- It re-uses the existing `onBackpressure*` methods for adding backpressure to created observables.

And disadvantages:
- It removes the ability to do proper backpressure-aware implementations easily. But perhaps something similar to `AsyncOnSubscribe` could be brought along for handling requests and then using this new, safer `Observable.create` for its return values.
 =||= In terms of the last disadvantage, `Flowable.create` could be renamed to `Flowable.unsafeCreate` and `Flowable.create(BatchPublisher)` could be added where `BatchPublisher` is something like a pared down `AsyncOnSubscribe`.
 =||= This happened!
 =||= ,0
4330,4329,Concat<Iterable<Observable>>,Is there a reason that there is `Observable.merge(Iterable<Observable>)` but not `Observable.concat(Iterable<Observable>)`?

If I understand correctly it could work similarly as
`concat(from(iterable));`,Can't remember. People just kept writing `concat(from(iterable))`.
 =||= Working on it ;-)
 =||= Closing via #4330.
 =||= ,0
4337,4082,2.x: Subscribers, Observables classes leak internal types into the public API,All of the methods doing this are at present unused. If they're for public consumption we need `DisposableSubscriber` and `NbpDisposableSubscriber` (or equivalent) to be in a public package.,Yes, we should avoid these.
 =||= I'd like to resolve this; could you point me to the problematic classes and what exactly is leaking?
 =||= It's the `createDisposable` methods in `Subscribers` and `Observers` which return `DisposableSubscriber` and `DisposableObserver`.
 =||= See #4337.
 =||= I think this has been resolved. Let me know if you find something else (or post a fix PR).
 =||= ,0
4370,4365,2.x Design: Try+Optional vs Notification,In 1.x we have the `Notification<T>` that can hold a value, error or completion.

When I started with 2.0, it was aimed at Java 8+ back then, thus I thought we could leverage Java 8's own `Optional` type plus a `Try<T>` to hold an error or an `Optional<T>`. Since now we aim at Java 6, the `Optional<T>` was manually ported back as well to retain the signatures of operators.

Uses: `materialize()`, `dematerialize()`; pacing out `onComplete()` with `retryWhen` and `repeatWhen`.

The drawback of `Try<Optional<T>>` is that for each normal value, it incurs 2 allocations whereas the 1.x notification required only 1 allocation. The completion signal in 1.x requires no allocation - 2.x requires 1 allocation (the `Try`).

Should we prefer less allocation and thus go back to (something like) `Notification<T>` or do we keep the Java 8 style?,I much prefer the more semantic Notification type which maps into the Rx
domain better than Try+Optional.

On Thu, Aug 18, 2016 at 4:11 AM David Karnok notifications@github.com
wrote:

> In 1.x we have the Notification<T> that can hold a value, error or
> completion.
> 
> When I started with 2.0, it was aimed at Java 8+ back then, thus I thought
> we could leverage Java 8's own Optional type plus a Try<T> to hold an
> error or an Optional<T>. Since now we aim at Java 6, the Optional<T> was
> manually ported back as well to retain the signatures of operators.
> 
> Uses: materialize(), dematerialize(); pacing out onComplete() with
> retryWhen and repeatWhen.
> 
> The drawback of Try<Optional<T>> is that for each normal value, it incurs
> 2 allocations whereas the 1.x notification required only 1 allocation. The
> completion signal in 1.x requires no allocation - 2.x requires 1 allocation
> (the Try).
> 
> Should we prefer less allocation and thus go back to (something like)
> Notification<T> or do we keep the Java 8 style?
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4365, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEXhAoluJ2TbeTdY-rgXa9WoXkPCkks5qhBOmgaJpZM4JnPKg
> .
 =||= :+1: for Notifications, less allocations, easier to understand.
 =||= See #4370
 =||= ,0
4371,4366,2.x Design: BlockingFlowable, BlockingObservable,The `BlockingFlowable` and `BlockingObservable` classes host blocking operations. They were introduced to make absolutely clear someone uses blocking operations.

The drawback is that they wrap a `Flowable` and `Observable` respectively which incurs allocation whenever `toBlocking()` is called on the base class.

I suggest discarding these blocking classes and moving their operators into the base classes, prefixing the operator name with `blockingX`.,SGTM
 =||= I'm supportive of this only to see two types removed from the public API
and seeing the disconnect of having no BlockingSingle and
BlockingCompletable eliminated. It seems a bit ridiculous to worry about a
single allocation, though, when every other operator already allocates at
least once and this operator is already doing something 10x worse by
throwing away the current thread on a lock.

On Thu, Aug 18, 2016 at 8:04 AM David Karnok notifications@github.com
wrote:

> The BlockingFlowable and BlockingObservable classes host blocking
> operations. They were introduced to make absolutely clear someone use
> blocking operations.
> 
> The drawback is that they wrap a Flowable and Observable respectively
> which incurs allocation whenever toBlocking() is called on the base class.
> 
> I suggest discarding these blocking classes and mving their operators into
> the base classes, prefixing the operator name with blockingX.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4366, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEWDlZDNoAX0W-oarFxIn1LblG-FVks5qhEpbgaJpZM4Jna4U
> .
 =||= See #4371.
 =||= ,0
4421,1353,Make operator parameter names consistent across operators.,I recommend that some of the parameter names used in Observable operators be changed so that similar parameters have similar names from operator to operator.

Specifically:
#### Collections of Observables

An iterable, list, or array of Observables is called "`sources`" in `amb()` and `combineLatest()`; "`sequences`" in `merge()`, and "`ws`" in `zip()`.

I recommend standardizing on "`observables`" as the parameter name for these.
#### Observables that emit Observables

An Observable that emits Observables is called "`observables`" in `concat()`, "`source`" in `merge()` and `mergeDelayError()`; "`sequenceOfSequences`" in `switchOnNext()`; and "`ws`" in `zip()`.

I recommend standardizing on "`observables`" as the parameter name for these
#### Ordinary Observable

Some operators take an ordinary Observable as a parameter.

The `zip()` operator calls the Observable that you pass as a parameter to zip with the source Observable "`other`"; the `groupJoin()` and `join()` operators use the parameter name "`right`" to describe a similar thing.

(The new operators `ambWith()`, `concatWith()`, and `mergeWith()` use "`t1`" for this sort of parameter; `zipWith()` uses "`other`".)

I recommend standardizing on "`other`" for this.
#### Multiple Observables

Some operators take two or more Observables as parameters.
- `amb()`, `combineLatest()`, and `zip()` call these "`o1`," "`o2`," "`o3`," etc.
- `concat()`, `merge()`, and `mergeDelayError()` call these "`t1`," "`t2`," "`t3`," etc.
- `sequenceEqual()` calls these "`first`" and "`second`"

My recommendation: for at least the operators in the first two bullet points, choose a single naming scheme and standardize over it for all of those operators.
#### Special-Function Observables

Some operators are passed Observables that emit indicators that instruct the operators to do certain things at certain times.  The naming schemes for these could be improved.

Currently:
**`buffer()`**
- opening indicator: `bufferOpenings`
- closing indicator: `bufferClosingSelector`
- boundary indicator: `boundary`

**`window()`**
- opening indicator: `windowOpenings`
- closing indicator: `closingSelector`
- boundary indicator: `boundary`

My recommendation for both:
- opening indicator: `openingIndicator`
- closing indicator: `closingIndicator`
- boundary indicator: `boundaryIndicator`

I also recommend changing the names of the following parameters so that they conform to a similar naming scheme:
- "`durationSelector`", "`leftDuration`", "`rightDuration`" (`groupByUntil()`)
- "`leftDurationSelector`", "`rightDurationSelector`" (`join()`)
- "`other`" (`skipUntil()` and `takeUntil()`)
- "`firstTimeoutSelector`" and "`timeoutSelector`" (`timeout()`)
- "`debounceSelector`" (`debounce()`)
- "`sampler`" (`sample()`)

(There are also parameter names for functions that _generate_ Observables that emit indicators: 
"`subscriptionDelay`" and "`itemDelay`" from `delay()`, "`closingSelector`" from `window()`, and "`notificationHandler`" from `repeatWhen()` and `retryWhen()`).
#### Observables that act as back-up sequences

Observables that are meant to supply items in case of failure in a primary Observable are called "`resumeSequence`" in `onError/ExceptionrResumeNext()`, and "`other`" in `timeout()`.

I recommend standardizing on a single parameter name for these.
#### Number of repetitions

`repeat()` uses "`count`" to indicate how many times the items should be repeated; `retry()` uses "`retryCount`" to indicate how many times to attempt to retry.

Recommendation: either use "`count`" for both, or change the first one to "`repeatCount`"
#### Numbers of items to skip, emit, or observe

You can instruct some operators to ignore a certain number of items emitted by an observable. You indicate this number with "`skip`" (`buffer()` and `window()`), "`num`" (`skip()`), or "`count`" (`skipLast()`). I recommend standardizing on "`skip`" for all three.

You can also instruct some operators to attend to or to emit a particular number of items emitted by an observable. You indicate this number with "`num`" (`limit()` and `take()`), "`count`" (`buffer()`, `range()`, `takeLast()`, `takeLastBuffer()`, and `window()`), or "`capacity`" (`cache()`). I recommend standardizing on one or the other for all of these operators.
#### Durations

Several operators have parameters that indicate durations of time. There are currently at least eight parameter names for parameters indicating duration. I recommend this be reduced, not necessarily to one, but to fewer. Here are the current ones:
- "`timespan`" (`buffer()`, `window()`)
- "`timeout`" (`debounce()`, `from()`, `throttleWithTimeout()`, `timeout()`)
- "`interval`" (`interval()`)
- "`time`" (`replay()`, `skip()`, `skipLast()`, `take()`, `takeLast()`, `takeLastBuffer()`)
- "`period`" (`sample()`, `timer()`)
- "`windowDuration`" and "`skipDuration`" (`throttleFirst()`)
- "`intervalDuration`" (`throttleLast()`)

There are also several operators that have parameters related to shifting things forward in time or delaying things in time. There are three names for these parameters now: one or maybe two are probably sufficient:
- "`timeshift`" (`buffer()`, `window()`)
- "`delay`" (`delay()`, `delaySubscription()`)
- "`initialDelay`" (`timer()`)

There is a single inconsistency in the parameter for indicating the time unit. This is called "`unit`" everywhere except in `timeout()` where it is called "`timeUnit`" -- I recommend changing it to "`unit`" there as well.
#### Items emitted by Observables

There are many names used for the parameters that describe an item emitted, or to be emitted, by an Observable: for instance "`element`" (`contains()`) and "`value`" (`just()`); also "`t1`" (`startWith()`) and "`initialValue`" (`publish()`, `reduce()`, `BlockingObservable.mostRecent()`) for an item to emit as the first emission; and "`defaultValue`" (many operators) for an item to emit if there were no emitted items from the source or none that met a predicate.

I've been using "item" in the wiki & javadocs to describe things emitted from Observables, rather than "value," "element," or "object." This is because Observables can emit lots of sorts of things (e.g. objects, elementals, additional Observables), and usually in the documentation, the important thing about these emissions is _that_ they're emissions, rather than that they're a particular sort of thing. "Item" is a less-misleading vague specifier for such emissions.

For this reason, I recommend that the parameter names also standardize on the "item" terminology, so:
- "`element`" and "`value`" become **"`item`"**
- "`t1`" and "`initialValue`" become **"`initialItem`"**
- "`defaultValue`" becomes **"`defaultItem`"**

There are also a few different names for parameters describing _arrays_ of items:
- "`t1`" (`from()`)
- "`items`" (`from()`)
- "`values`" (`startWith()`)

I recommend consolidating these into "`items`".
#### Collectors and accumulators

Are collectors and accumulators two different sorts of things or pretty much the same sort of thing?  `collect()` calls its function a "`collector`" while `reduce()` and `scan()` call theirs an "`accumulator`".  I'm not certain whether these are distinct enough things to necessitate distinct terminology.
#### Functions that transform items emitted by Observables

The following are used as parameter names for passing functions that are meant to transform items emitted by Observables:
- "`valueSelector`" (`groupByUntil()`, `toMap()`, `toMultiMap()`)
- "`elementSelector`" (`groupBy()`)
- "`func`" (`map()`)
- "`selector`" (`multicast()`, `publish()`, `publishLast()`, `replay()`)

I recommend standardizing on a single name, and considering something other than "selector", since these functions aren't really "selecting" items so much as _changing_ them.
#### Functions that combine multiple items emitted by Observables to create single items

The following parameter names describe functions that take items emitted by multiple Observables and operate on them to generate a single new item to be emitted:
- "`combineFunction`" (`combineLatest()`)
- "`resultSelector`" (`groupByUntil()`, `join()`, `mergeMap()`, `mergeMapIterable()`)
- "`zipFunction`" (`zip()`, `zipWith()`)

I recommend standardizing on a single name for all of these, and again I'm not sold on the "selector" terminology...
#### Functions that generate Observables

There are a number of parameters that describe functions that generate Observables:
- "`func`" (`concatMap()`, `flatMap()`, `mergeMap()`, `switchMap()`)
- "`collectionSelector`" (`mergeMap()`)
- "`observableFactory`" (`defer()`, `using()`)
- "`resumeFunction`" (`onErrorFlatMap()`, `onErrorResumeNext()`)

My recommendation: change "`func`" to something more descriptive, and see if you can consolidate some of these others as well.
#### On[State] actions/functions

`doOnCompleted()` and `mergeMap()` have "`onCompleted`" parameters; `forEach()` and `subscribe()` call their parameters "`onComplete`". Recommendation: change `forEach()` and `subscribe()` to use "`onCompleted`" so as to better match the name of the Observer method.

`finallyDo()` takes a parameter called "`action`"; most other operators of this sort take parameters of the form "onSomething" (e.g. "`onTerminate`", "`onNotification`", "`onNext`").  Recommendation: change the name of this parameter to use an "onSomething" form.
#### Iterables

`from()` calls its Iterable parameter "`iterable`"; `zip()` calls it "`other`". Recommendation, change `zip()` to match `from()` in this respect.,Great notes @DavidMGross! 

One remark from my side, I would like to stay as close as possible to the original Rx .NET names as we can http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable(v=vs.103).aspx, even if it is a bit suboptimal (for instance for buffer http://msdn.microsoft.com/en-us/library/hh229621(v=vs.103).aspx). Then we can maintain some uniformity in Rx across the different languages without creating a tower of Babel.

[Of course one can also argue to use the same parameter names as Java streams if there is a match].

Besides that I am all for improving parameter names and making them more uniform.

(Note that in Scala everything is called `f` and `g` etc. to match the local style. Nothing to gain there).
 =||= LIKE! @DavidMGross  

Seems like a good idea @headinthebox. If we see inconsistencies in the Rx.NET parameter names what's the plan (@benjchristensen)? 
 =||= Then let's make a list of those so we can see whats going on, and relay back to the .NET folks and Js/C++.
 =||= Beaut.
On 22 Jun 2014 19:04, "headinthebox" notifications@github.com wrote:

> Then let's make a list of those so we can see whats going on, and relay
> back to the .NET folks and Js/C++.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/Netflix/RxJava/issues/1353#issuecomment-46775923.
 =||= Anyone want to tackle this? I would ignore the Rx.NET parameter names since parameter names themselves do not affect the public API so it doesn't affect functionality or uniformity.
 =||= @headinthebox parameter name is more important in RxScala since changing parameter names will break the source compatibility. Therefore, do you think if it's worth to review the names in RxScala and make them consistent?
 =||= Yes, but let's make them consistent with the _Scala libraries_ instead, i.e. `def map[R](func: T => R): Observable[R]` should be `def map[B](f: (A) => B): Observable[B]` and `filter(predicate: T => Boolean): Observable[T]` should be `filter(p: T => Boolean): Observable[T]` to be consistent with the native Scala style as in say http://www.scala-lang.org/api/current/index.html#scala.collection.Iterable. 

So I guess that means lots of alpha-renaming of `S`,`T` ~~> `A`,`B` and using `f`, `g`, and `h`, and `op`.

Makes sense?
 =||= Removing milestone as this is nice-to-have (doesn't affect behavior).
 =||= Any chance some of the low-hanging fruit in this issue could be tackled before 1.0?

(For example: the scheduler parameter to parallel(), the use of onCompleted vs. onComplete.)

A little work here could do a lot to improve the clarity of the API and also make it look more deliberately and carefully engineered, which would improve first impressions and make people more confident in using it.
 =||= Giving this a bump in the hopes of getting it on the radar of folks who are working on the 2.0 versions...
 =||= @artem-zinnatullin - as long as you're doing code clean-up stuff... care to tackle this one?
 =||= I am afraid, that versioning scheme won't allow us to do it, several JVM langs such as Kotlin, Groovy,  Scala supports ["Named Arguments"](http://kotlinlang.org/docs/reference/functions.html#named-arguments) and we can break compilation of someone's code. Though I think that in terms of Java we are not breaking anything and this is RxJava, not RxKotlin or RxScala… 

@benjchristensen I can do this in 1.x if you don't mind, or it's time to start 2.x and move on.
 =||= This will be tackled in 2.x before RC 1. Let's rename parameters based on @DavidMGross suggestions then.
 =||= bump
 =||= I'm doing some minor cleanups for 2.0 RC1 now and will try to unify the field names as well.
 =||= The names were mostly unified. If anything left out, we can do that post 2.0 for perhaps a few months; it may take some time other language adapters, who actually rely on parameter naming, pick 2.0 up.
 =||= ,0
4422,440,libGDX support,This is the start of a new contrib project that lays the foundation for RxJava support for **[libGDX](http://libgdx.badlogicgames.com/)**.

This is still missing tests because it's very difficult to unit test this properly due to the nature of libGDX. However, I'll be using this a lot in my own Android projects.

I'm not sure whether this should be a contrib subproject of RxJava or maybe a separate repo. If you think this should be separate, just decline the PR.,[RxJava-pull-requests #357](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/357/) FAILURE
Looks like there's a problem with this pull request
 =||= What do you think is the determination for something being contrib or separate?

To me the benefit of contrib is simplified artifact publishing (goes along for the ride) and increased visibility for things that are common extensions, bindings and add-ons.

The drawback is that the release cycle is tied to RxJava. A breaking change in a module will not result in a major revision bump for the RxJava project.

Thus, things are that simple bindings of common projects make perfect sense as contrib modules ... things we'd almost consider putting in core but don't because of dependencies on other libraries.

Considering that, do you think the lifecycle of this library is suited to being part of RxJava or being on its own?
 =||= What is the common model in the JVM world? 

My guess s that at some point, RxJava will converge to a stable version, and then you want to want to have bindings being released at their own, faster pace.

Erik

On Oct 22, 2013, at 9:30 PM, Ben Christensen notifications@github.com wrote:

> What do you think is the determination for something being contrib or separate?
> 
> To me the benefit of contrib is simplified artifact publishing (goes along for the ride) and increased visibility for things that are common extensions, bindings and add-ons.
> 
> The drawback is that the release cycle is tied to RxJava. A breaking change in a module will not result in a major revision bump for the RxJava project.
> 
> Thus, things are that simple bindings of common projects make perfect sense as contrib modules ... things we'd almost consider putting in core but don't because of dependencies on other libraries.
> 
> Considering that, do you think the lifecycle of this library is suited to being part of RxJava or being on its own?
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= The release cycle is no problem at all. - I'm just wondering if libgdx is common enough.
 =||= @jmhofer I have no idea about the commonality of libgdx as I don't work in that space. I'd never heard of it but that doesn't mean much. I lean towards this being a separate project but being linked to from here: https://github.com/Netflix/RxJava/wiki#rxjava-libraries

@headinthebox I have never seen a one-size-fits-all approach. Generally the best is to keep them separate and decoupled so they have their own release cycle. Submodules work well though when things are tightly coupled but not wanted in the same project so the core stays lean and has less dependencies (such as what we're doing with Android/Swing in the contrib modules).
 =||= That's exactly what I was trying to say Ben. 
Keep the core as lean as possible, then pick and choose what libraries you want.

On Oct 22, 2013, at 9:43 PM, Ben Christensen notifications@github.com wrote:

> @jmhofer I have no idea about the commonality of libgdx as I don't work in that space. I'd never heard of it but that doesn't mean much. I lean towards this being a separate project but being linked to from here: https://github.com/Netflix/RxJava/wiki#rxjava-libraries
> 
> @headinthebox I have never seen a one-size-fits-all approach. Generally the best is to keep them separate and decoupled so they have their own release cycle. Submodules work well though when things are tightly coupled but not wanted in the same project so the core stays lean and has less dependencies (such as what we're doing with Android/Swing in the contrib modules).
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= > Keep the core as lean as possible

Yes, which is why it is a single-jar project at this point with no external dependencies.

The use of rxjava-contrib is somewhat fuzzy though as we use it for things that "could" go in core but we choose not to because they have other dependencies or are "extra" but are still tightly associated so we want them in the RxJava project and not a 3rd party.

The 'rxjava-android' and 'rxjava-swing' contrib modules are good examples of this. The 'rxjava-apache-http' one is murkier. It could easily be argued for that to be a separate project and I'd probably agree even though I put it there. 
 =||= I think it makes sense for this to be kept separate. Let's definitely link to it though from https://github.com/Netflix/RxJava/wiki#rxjava-libraries
 =||= ,0
4425,4420,1.x: Base interface types,Before `Single` and `Completable` progress to stable, I'd like to address the interface naming inconsistency in a similar fashion to what #4044 did for 2.x.

Here's the current state:

<img width="614" alt="screen shot 2016-08-24 at 1 30 57 pm" src="https://cloud.githubusercontent.com/assets/66577/17940957/3f4ee112-69ff-11e6-8d0f-68dc06df051a.png">

It's very clear that there's a lack of normalization. ~~I'd like to take the same approach as we did in 2.x and move to prefixes and top-level types.~~ I'd like to normalize the names of the nested classes and make the subscribers top-level types. We can `@Deprecate` the existing types and make them extend from these new top-level types to make migration easier, deleting these `@Deprecated` types whenever these APIs turn stable. 👍 👎 ?

Additionally, there's a problem with `CompletableSubscriber` in that it's an interface instead of an abstract class that also implements `Subscription` (as both `Subscriber` and `SingleSubscriber` do). I would like to correct this. 👍 👎 ?,1) Kind of disruptive at this point, plus `@Deprecated` never get removed from the main versions (since it was promised)

2) It's a modern design just like in 2.x but you can introduce the `ResourceCompletable` similar to 2.x `ResourceSubscriber`.
 =||= Er, sorry I meant to change that paragraph before hitting create. I want to propose non-prefixed inner types similar to what `Observable` has except for the `Subscribers` which will be top-level.

This will only change non-stable APIs so they could just be renamed.

I was suggesting `@Deprecating` these non-stable old interfaces so that it didn't immediately break people upgrading. Then eventually you could delete those interfaces since they were never stable in the first place. We also could just rename them though and not bother.

The changes would look like this:

<img width="614" alt="screen shot 2016-08-24 at 3 51 00 pm" src="https://cloud.githubusercontent.com/assets/66577/17945620/9e654228-6a12-11e6-96e5-8a3618d9f762.png">
 =||= Let's see a PR so the diff is more telling about the consequences.
 =||= Can we do more about this or can this be closed?
 =||= I think we're now at a good enough place with 1.x here. Any more changes would only be disruptive for the sake of being disruptive.
 =||= Great!
 =||= ,0
4436,4321,2.x changing some Observable operators to return Single. ,I was looking through the Observable operators and wondering if now would be a good time to change the following methods to return Singles instead of Observables.
- [x] `Single<Boolean> all(Predicate<? super T> predicate)`
- [x] `Single<Boolean> any(Predicate<? super T> predicate)`
- [x] `<U> Single<U> collect(Callable<? extends U> initialValueSupplier, BiConsumer<? super U, ? super T> collector)`
- [x] `<U> Single<U> collectInto(final U initialValue, BiConsumer<? super U, ? super T> collector)`
- [x] `Single<Boolean> contains(final Object o)`
- [x] `Single<Long> count()`
- [x] `Maybe<T> elementAt(long index)`
- [x] `Single<T> elementAt(long index, T defaultValue)`
- [x] `Maybe<T> firstElement()`
- [x] `Single<T> first(T defaultItem)`
- [x] `Completable ignoreElements()`
- [x] `Single<Boolean> isEmpty()`
- [x] `Maybe<T> lastElement()`
- [x] `Single<T> last(T defaultItem)`
- [x] `Maybe<T> reduce(BiFunction<T, T, T> reducer)`
- [x] `<R> Single<R> reduce(R seed, BiFunction<R, ? super T, R> reducer)`
- [x] `<R> Single<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer)`
- [x] `Maybe<T> singleElement()`
- [x] `Single<T> single(T defaultItem)`
- [x] `Single<List<T>> toList()`
- [x] `Single<List<T>> toList(final int capacityHint)`
- [x] `<K> Single<Map<K, T>> toMap(final Function<? super T, ? extends K> keySelector)`
- [x] `<K, V> Single<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector, final Function<? super T, ? extends V> valueSelector)`
- [x] `<K> Single<Map<K, Collection<T>>> toMultimap(Function<? super T, ? extends K> keySelector)`
- [x] `<K, V> Single<Map<K, Collection<V>>> toMultimap(Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector)`
- [x] `Single<List<T>> toSortedList()`
- [x] `Single<List<T>> toSortedList(final Comparator<? super T> comparator)`
- [x] `Single<List<T>> toSortedList(final Comparator<? super T> comparator, int capacityHint)`
- [x] `Single<List<T>> toSortedList(int capacityHint)`

(These were removed from the API:)
- ~~`Single<List<T>> takeLastBuffer(int count)`~~
- ~~`Single<List<T>> takeLastBuffer(int count, long time, TimeUnit unit)`~~
- ~~`Single<List<T>> takeLastBuffer(int count, long time, TimeUnit unit, Scheduler scheduler)`~~
- ~~`Single<List<T>> takeLastBuffer(long time, TimeUnit unit)`~~
- ~~`Single<List<T>> takeLastBuffer(long time, TimeUnit unit, Scheduler scheduler)`~~,I'm +1 for it I also suggested that here for a few operators #4277 
 =||= I don't know, looks like one needs to convert back to `Flowable` all the time plus one needs to update a large amount of unit tests manually.
 =||= @akarnokd Why don't the operators on Single return Flowables? Isn't singleSubscribe an implicit request one?

As for the unit tests it's a large task but not insurmountable.
 =||= Some do, like `Single.concat` that have to be "widened" but mostly Single stays Single. Plus, Single doesn't have backpressure at all so no request(1) inside it. Reactor's `Mono` (0, 1, error) is a `Publisher` so they have to honor backpressure for that maybe 1 element.
 =||= @akarnokd Yes, I agree Single should not have back pressure because it is fixed size and subscribing can be thought of as an implicit request one. In other words if the subscriber doesn't have enough room in the queue for one element then don't subscribe.
 =||= I'm a bit nervous about Single not supporting backpressure. We got into trouble with `Observable.just(item)` not supporting backpressure in 1.x. See
https://github.com/ReactiveX/RxJava/issues/3044 which includes references to failures.
 =||= I agree with @davidmoten. It was clear that a mistake was made with `just` ignoring backpressure and it feels like the same mistake is being made again. Plus gaining compatibility with `Mono` is something which I would much appreciate.
 =||= The main difference in this case is that Single isn't meant to support back pressure so it wouldn't mix of behavior like there was with just.
 =||= I understand. I just dislike the lack of consistency between the flow control mechanisms on `Flowable` and `Single`/`Completeable` i.e. for `Flowable` I call `request` to control flow but I need to hold off on subscription entirely for `Single`/`Completeable`.

I do get that `Observable` relates much better to `Single`/`Completeable` than `Flowable`, but I also feel that backpressure should be a default and only turned off if performance is truly a consideration - i.e. use `Flowable` until it is known that `Observable` is truly going to improve performance and transform an `Observable` to `Flowable` as soon as possible using one of the flow control mechanisms. (AFAIK the only reason `Observable` exists is for performance right?).
 =||= I don't see Single or Completable missing backpressure being a problem in
this specific case because Observable itself doesn't support it either. I
wouldn't expect the equivalent operators for Flowable to return Single.

On Wed, Aug 10, 2016, 8:44 PM Lalit Maganti notifications@github.com
wrote:

> I understand. I just dislike the lack of consistency between the flow
> control mechanisms on Flowable and Single/Completeable i.e. for Flowable
> I call request to control flow but I need to hold off on subscription
> entirely for Single/Completeable.
> 
> I do get that Observable relates much better to Single/Completeable than
> Flowable, but I also feel that backpressure should be a default and only
> turned off if performance is truly a consideration - i.e. use Flowable
> until it is known that Observable is truly going to improve performance
> and change Observable to Flowable as soon as possible. (AFAIK the only
> reason Observable exists is for performance right?).
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4321#issuecomment-239047190,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEZfQ-Ml72NNlWwd_snzT3PnRHV9cks5qenB5gaJpZM4JfzIM
> .
 =||= It's not necessarily a problem and I guess reworking Single is unfeasible anyway this close to 2.x RC. Just a small gripe I had :)
 =||= Backpressure is there to avoid buffer bloat with unknown length streams. Single has only one element to get buffered and generally not a problem.

`Observable` was introduced because some got annoyed with backpressure and want truly unbounded flows no matter the cost. It has lower overhead than with backpressure but generally, the late optimizations to `Flowable` put them [quite close](https://twitter.com/akarnokd/status/752465265091309568).

Personally, I'd get rid of all but `Flowable` because it can support all the other behaviors plus I don't have to do 3x the work to keep everybody symmetric in terms of features.
 =||= Yeah, even 1.x codebase is quite hard to maintain, 2.x with different Flowable/Observable makes it even harder to work with…

@akarnokd you can add basic support of `Single` and `Consumable` in 2.x (basically just make library architecture aware of them from the beginning instead of adding them post-factum as it was in 1.x), non-basic operators can be added by community according to its needs as it happens/happened in 1.x.
 =||= The reason for `Single` and `Completable` being in the main library is that people expect convenient transformations to them: `Flowable.toSingle`, `Flowable.toCompletable()`. If these returned `SingleSource` or `CompletableSource`, those don't provide operators at all and are practically useless. `toX`s need the full classes.

The alternative could be to make this dependence indirect via reflection:

``` java
Single<T> single = someFlowable.to(Single.class);

public Z to(Class<Z> target) {
   return (Z)target.getMethod("from", Publisher.class).invoke(null, this);
}
```

but even a cached method may be too expensive on some platforms.

Otherwise:

``` java
someFlowable.to(Single::from).blah().blah();

someSingle.toFlowable(); // Single library depending on Flowable library is okay
```
 =||= I was talking about this a bit more and noticed that `reduce(Func2<R, T, R>)` would have to return a `Maybe<T>` in the case that source `Observable<T>`/`Flowable<T>` was empty.  I couldn't find any issues on thinking about supporting a `Maybe<T>` type.  I'm also not sure if people are willing to support yet another type in rx java.
 =||= There's already an Optional and Try type!

On Wed, Aug 17, 2016, 5:44 PM George Campbell notifications@github.com
wrote:

> I was talking about this a bit more and noticed that reduce(Func2<R, T,
> R>) would have to return a Maybe<T> in the case that source Observable<T>/
> Flowable<T> was empty. I couldn't find any issues on thinking about
> supporting a Maybe<T> type. I'm also not sure if people are willing to
> support yet another type in rx java.
> 
> —
> You are receiving this because you commented.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4321#issuecomment-240558790,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEERkt4lVN62YrfObR5ZecushOv-Bxks5qg4C-gaJpZM4JfzIM
> .
 =||= I'm not sure about Try but isn't `java.util.Optional` eager?
 =||= Ah I see. It's a custom Optional, not Java 8s, so we could make a lazy
factory, but it's not a good idea to reuse it for two behaviors.

On Wed, Aug 17, 2016, 7:09 PM George Campbell notifications@github.com
wrote:

> I'm not sure about Try but isn't java.util.Optional eager?
> 
> —
> You are receiving this because you commented.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4321#issuecomment-240576699,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEeM0vdzXfveuBl7hN5wkylEDH5usks5qg5SagaJpZM4JfzIM
> .
 =||= I've been going over method signatures trying to come up with a plan for all of the conversion methods:

| From\To | Completable | Maybe | Single | Flow/Observable |
| --- | --- | --- | --- | --- |
| Completable |  | `toMaybe()` `toMaybe(T)` `toMaybe(()->T)` | `toSingle(T)` `toSingle(()->T)` | `toFlow/Observable()` |
| Maybe | `toCompletable()` |  | `toSingle(T)` `toSingle(()->T)` | `toFlow/Observable()` |
| Single | `toCompletable()` | `toMaybe()` |  | `toFlow/Observable()` |
| Flow\Observable | `toCompletable()` | `toMaybeLast()` `toMaybeFirst()` | `toSingleFirst(T)` `toSingleFirst(()->T)` `toSingleLast(T)` `toSingleLast(()->T)` |  |

From 5 reactive types I want to drop the methods like `first`, `last`, `single`, and `ignoreElements` since they are redundant.  I would like to also take out the `blocking*` variants of the methods. Leaving the only the type specific blocking methods for each type.

This is the core of the changes that I'm working on the effects of which will ripple out to all of the unit tests.
 =||= Please don't remove the internal operators backing the original same-type behavior.
 =||= @abersnaze How is your progress on this? I held off changes to 2.x but RC3 time is nearing and I'd like to improve performance on various elements.
 =||= I've got a branch that compiles but they're unit tests that failing for reasons. I'll push my branch to my fork if you want to take over. 

> On Sep 20, 2016, at 03:23, David Karnok notifications@github.com wrote:
> 
> @abersnaze How is your progress on this? I held off changes to 2.x but RC3 time is nearing and I'd like to improve performance on various elements.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
 =||= No. I think it's best if I redo it step-by-step, one operator at a time to rule out test anomalies and also apply optimizations.
 =||= The operator .last() effect 100s of tests.

> On Sep 20, 2016, at 08:03, David Karnok notifications@github.com wrote:
> 
> No. I think it's best if I redo it step-by-step, one operator at a time to rule out test anomalies and also apply optimizations.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
 =||= See #4570
 =||= What should happen with
- `single()` vs `toSingle()`,
- `ignoreElements()` vs `toCompletable()` ?

Should these be merged into the former or the latter of each? 
 =||= I picked single, first, last, & ignoreElements over toSingle, toMaybe, & toCompletable because the former were more descriptive of what it does when there more than one value.
 =||= Thanks for the info.
 =||= `first`, `last` and `reduce` signal `NoSuchElementException` traditionally. Do you think we should have `maybeFirst`, `maybeLast` and `maybeReduce` to avoid the exception?
 =||= I think that if we are going to make a breaking change to the API that we should also take the opportunity to change the behavior (not throwing exceptions)
 =||= To be clear, this is what can happen:

`Single<T> first(T defaultItem)` and `Maybe<T> first()`
`Single<T> last(T defaultItem)` and `Maybe<T> last()`
`Single<T> elementAt(long index, T defaultItem)` and `Maybe<T> elementAt(long index)` <-- not sure
`Single<T> single(T defaultItem)` and `Maybe<T> single()` <-- looks odd
 =||= You could postfix "Element" onto the names which has precedence from `ignoreElements` (e.g., `firstElement()`, `singleElement()`). This makes the return type mismatch less odd looking.
 =||= Closing via #4573, #4574, #4576, #4579

Let me know if I missed some classic operator.
 =||= What about `Observable<T> takeFirst(Predicate<T>)`. In my opinion it should become:

`Maybe<T> takeFirst(Predicate<T>)`
`Single<T> takeFirstOrError(Predicate<T>`
 =||= Actually, since all other such predicate versions were removed, `takeFirst` should be removed. Use `filter().first()` instead.
 =||= You want me to remove it?
 =||= Yes, but only the Api and please fix up the tests that used  it.
 =||= What about `Observable.timer()`? That one only ever emits one item.
 =||= We need those to jumpstart their respective types without conversion.
 =||= ,0
4442,4199,add documentation for AsyncEmitter.BackpressureMode,`AsyncEmitter.BackpressureMode` does not have documentation explaining how the different backpressure modes work. Maybe there could be a breadcrumb linking to `Observable#onBackpressureDrop`, `Observable#onBackpressureBuffer` and `Observable#onBackpressureLatest`?

It doesn't look like there's a corresponding `Observable` method for `BackpressureMode.ERROR` so this could also be documented.,A PR is welcome.
 =||= See #4442.
 =||= Closing via #4442.
 =||= ,0
4442,4255,1.x: Rename Observable.fromAsync(),`fromAsync()` sounds like it's ok to emit from multiple threads in parallel while in fact it doesn't serialize emission.

Can we rename it? For example to `Observable.fromCallback()` which also seems more obvious to use when you convert callback-styled code to `Observable`.,The suggested name is too close to `fromCallable`. Besides, the Javadoc of `AsyncEmitter` warns about sequential use:

``` java
/**
 * Abstraction over a RxJava Subscriber that allows associating
 * a resource with it and exposes the current number of downstream
 * requested amount.
 * <p>
 * The onNext, onError and onCompleted methods should be called 
 * in a sequential manner, just like the Observer's methods. The
 * other methods are threadsafe.
 *
 * @param <T> the value type to emit
 */
```
 =||= > The suggested name is too close to fromCallable.

You're worried about dynamic languages like Groovy? They're not _that_ bad!

> Besides, the Javadoc of AsyncEmitter warns about sequential use

Well, to me it looks ~like `void threadSafe()` which has note in javadoc that it's not thread safe 😁 
 =||= They sound to similar and may lead to speaker embarrassment when mixed up, not to mention, users getting confused and Content assist/Intellisense bringing up both of them when typing `fromCall`.
 =||= I don't think something being asynchronous immediately implies that it's also concurrent.
 =||= True, but not a lot of people understand that.

Only because of `AsyncTask` a lot of Android devs think that async == bg
thread.

Another point is that `fromAsync()` is probably not what developer would
look into when he/she will need to convert callback-styled api to Rx,
`fromCallback()` looks more user-friendly (in my opinion of course).

On Fri, Aug 5, 2016 at 5:54 PM, Jake Wharton notifications@github.com
wrote:

> I don't think something being asynchronous immediately implies that it's
> also concurrent.
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4255#issuecomment-237872294,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AA7B3OtRTCnB7B8AxYvVICdAQeLktIVmks5qc07DgaJpZM4JXQRO
> .
 =||= Using an `AsyncTask` inside `fromAsync` would be perfectly fine since it's not concurrent.

`fromCallback` is clearly not usable for the reasons previously stated. I'm not against a rename, but I'm having a hard time coming up with a better name than what we already have.
 =||= I would almost rename _both_ `fromCallable` and `fromAsync` to just overloads of `from`. We already have a few overloads of `from` for adapting various sources so I don't see why these are treated any differently than just more sources.

Additionally, the naming conventions of `fromCallable` and `fromAsync` disagree with each other and other RxJava conventions.

The first one, `fromCallable`, describes the mechanism (`Callable`) of what it's adapting. We don't see `fromIterable` or `fromFuture` so why `fromCallable`?

`fromAsync`, on the other hand, describes the behavior that it is adapting (a callback-based source). Again, we don't have `fromSynchronous` or `justSynchronous` so why `fromAsync`? Additionally, `fromAsync` is perfectly usable for non-asynchronous sources. It's merely adapting a callback-based system (the foundation of Artem's argument) but there's no reason it has to be asynchronous. It might be just be abstracting over a visitor-based API.

I would prefer both of these be renamed to `from` because that's how you adapt an external implementation of a data source into an `Observable`. It doesn't matter if it's an `Iterable`, `Future`, `Callable`, or a callback-based source. I would also rename `AsyncEmitter` to just `Emitter` with this change.
 =||= Humorously enough, RxJava 2 actually does postfix `from` with the source (e.g., `fromArray`, `fromIterable`, etc.). I stand by my argument that both of these should be just `from()` in RxJava 1.x, and we can bikeshed the name for 2.x in a separate issue.
 =||= > I would almost rename both fromCallable and fromAsync to just overloads of from. 

I don't recommend it, Java 8 compiler gets sometimes quite confused, for example:

```
from(() -> 1)

from(() -> new Iterator() { })
```

In this case, `from()` could mean any of the prefixed operators and you'll end up casting a lot to make it right - postfix is shorter.
 =||= Great point. In that case, I still think `fromAsync` is the wrong name based solely on the fact that its a potentially-inaccurate description of what's being adapted, but I'm not sold on the need to change it for 1.x.
 =||= Could be `fromEmitter`.
 =||= `fromEmitter` sounds better than `fromAsync` to me, 👍 
 =||= See #4442.
 =||= Closing via #4442.
 =||= ,0
4442,4356,setCancellation for Single and Completable ,We can use `setCancellation` for the `AsyncEmitter` that we have inside `Observable.fromAsync` method. It's very useful because we are able to release something in the case when the subscription was terminated. For example: 

``` Java
Observable.fromAsync(emitter -> {
    SomeProtocolClient client = new SomeProtocolClient(getUri());

    Callback callback = new Callback() {
        @Override
        public void onLoad(Response response) {
            Model model = parse(response);

            emitter.onNext(model);
            emitter.onCompleted();
        }

        @Override
        public void onError() {
            emitter.onError(new ApiException("No response"));
        }
    };

    Request request = client.get(callback);
    emitter.setCancellation(request::cancel); // release some resources, it's useful to have setCalcellation
}, AsyncEmitter.BackpressureMode.BUFFER);
```

Wouldn't it be nice to have something like that for the `Single` and `Completable`? ,Sounds good.
 =||= There is already such API:

``` java
Single.create(subscriber -> {
  subscriber.add(Subscriptions.create(request::cancel))
})
```

Same for `Consumable`.  Not sure if we should add `fromAsync` to `Completable` and `Single` in 1.x since in 2.x it'll be `create()`
 =||= A small drawback with the `SingleSubscriber.add` approach is that you need try-catch if `request::cancel` throws checked exception.

Completable doesn't support such resource management so you'd need to manually use `MultipleAssignmentSubscription` or other containers before calling `onSubscribe`.

Besides, we will (have to) provide a safe `create` in 2.x with similar API for all base reactive types.
 =||= // Damn, why we didn't do it for `Completable`?!

Ok, 👍 for adding `fromAsync` to both `Completable` and `Single` in 1.x, I can work on that if you don't mind
 =||= Go ahead, I'll do 2.x anyway within a few days.
 =||= Why not just call `.toSingle()` or `.toCompletable()` on the `Observable.fromAsync`?
 =||= To indicate on the API level that you should call exactly one of `onSuccess(T)`, `onError()` or `onCompleted()` methods.
 =||= I don't see how that's possible. `Single.OnSubscribe` doesn't prevent me from calling methods on the `SingleSubscriber` multiple times.
 =||= By having `SingleEmitter` and `CompletableEmitter` as input to you:

``` java
public static <T> Single<T> fromAsync(Action1<SingleEmitter<T>> emitter);

Single.fromAsync(e -> {
   e.setCancellable(() -> { });
   e.onSuccess(null);
   e.onSuccess(null); // will be dropped
});
```

> Single.OnSubscribe doesn't prevent me from calling methods on the SingleSubscriber multiple times.

Like all `create` operators, there are no safeguards with the raw access. Extending `fromAsync` (`create` in 2.x) to the other base reactive types give the necessary safeguards.
 =||= That should throw an exception, not be silently ignored. You've violated the contract of the type.
 =||= See #4442. Should there be one for Single?
 =||= Agree. It's confusing that there is Observable.fromEmitter, Completable.fromEmitter but not Single.fromEmitter
 =||= See #4851
 =||= Closing via #4851 & #4442
 =||= ,0
4458,4456,2.x: Naming of .doOnCancel(),As I understand it the `.doOnCancel()` operator is basically the replacement of `.doOnUnsubscribe()` in the 1.x world.

In that case: Just from a naming perspective wouldn't it be clearer to name it `.doOnDispose()` ?,`Flowable` -> `doOnCancel()` because of `Subscription.cancel()`, the other can be called `doOnDispose()`. Want to submit a PR?
 =||= Ah, I was not looking much at Flowable yet, that's why I missed that part. Thanks for explaining!

I'll get started on the PR.
 =||= ,0
4460,4457,1.x: Single and Completable are missing doOnEach,Both are missing that method. Is this one wanted?,Single is either success or error and Completable is either complete or error, and both types have doOn- methods for those events.
 =||= Yes I'm aware of that however I'd like something like a `doOnEach`. Also in Observable `doOnEach` includes terminal events.

If you want to execute some code regardless of whether it was successful or an error was thrown you'd need to call that method  in `onSuccess` and `onError`, where as with a `doOnEach` you'd call it once instead.

Again just a proposal if this is not wanted at all I'm also happy to live without it.
 =||= Oh I misread as next not each. Go for it.
 =||= Alright will do in the next few hours.
 =||= How about 2.x in this case? Both `Single` and `Completable` are also "missing" `doOnEach` there. Will the changes automatically be merged from 1.x to 2.x?
 =||= For 2.x, I'd imagine `Completable.doOnEvent(Consumer<? super Throwable> onEvent)` and `Single.doOnEvent(BiConsumer<? super T, ? super Throwable>)` where if the `Throwable` is null, it means the other event happened. There is a similar  API in `CompletableFuture.whenComplete(BiConsumer)` or something.
 =||= What about the Maybe type? That one would need one too, right?
 =||= I'm currently expanding Maybe so I'll add one.
 =||= ,0
4461,4457,1.x: Single and Completable are missing doOnEach,Both are missing that method. Is this one wanted?,Single is either success or error and Completable is either complete or error, and both types have doOn- methods for those events.
 =||= Yes I'm aware of that however I'd like something like a `doOnEach`. Also in Observable `doOnEach` includes terminal events.

If you want to execute some code regardless of whether it was successful or an error was thrown you'd need to call that method  in `onSuccess` and `onError`, where as with a `doOnEach` you'd call it once instead.

Again just a proposal if this is not wanted at all I'm also happy to live without it.
 =||= Oh I misread as next not each. Go for it.
 =||= Alright will do in the next few hours.
 =||= How about 2.x in this case? Both `Single` and `Completable` are also "missing" `doOnEach` there. Will the changes automatically be merged from 1.x to 2.x?
 =||= For 2.x, I'd imagine `Completable.doOnEvent(Consumer<? super Throwable> onEvent)` and `Single.doOnEvent(BiConsumer<? super T, ? super Throwable>)` where if the `Throwable` is null, it means the other event happened. There is a similar  API in `CompletableFuture.whenComplete(BiConsumer)` or something.
 =||= What about the Maybe type? That one would need one too, right?
 =||= I'm currently expanding Maybe so I'll add one.
 =||= ,0
4466,4462,1.x: Unused Notification.createOnCompleted(Class<T> type),While reading the Notification class due to #4457 I noticed [`Notification.createOnCompleted(Class<T> type)`](https://github.com/ReactiveX/RxJava/blob/30da1aa1e38a5ead8965d1784ab8c6df8111d354/src/main/java/rx/Notification.java#L73) which seems to be only used in one [test](https://github.com/ReactiveX/RxJava/blob/30da1aa1e38a5ead8965d1784ab8c6df8111d354/src/test/java/rx/NotificationTest.java#L89) and that test does not really add any value. So I'm wondering since this is in the public API and not used can be it removed or do you see any value in having this method around?,You could deprecate it but since the 1.x series can't remove methods that are non-beta and non-experimental, it doesn't make much difference.
 =||= ,0
4488,4481,Integrate Maybe and Single into Observable. *** DO NOT MERGE,I've been working on the this for too long in the background and want to get this out for review even though many of the units tests don't pass yet. Its a bit rough at the moment but there was a couple of things that I wanted to talk about.
1. does it make sense to have ignoreElements where there is a toCompletable.
2. the same goes for single when there is a toSingle.
3. moved toFuture to Single since it seems to fit better.,Don't delete the old ops because we can macro fuse them back in such cases: 
`source.reduce(...).toFlowable()`
 =||= I'll post a PR that incorporates some helper types and demoes what I mean by macro-fusion for these Flowable->X and Observable->X conversions.
 =||= @abersnaze Your commit somehow has me as it's author.
 =||= @Mauin yeah it's odd

@abersnaze 
See #4484 about how we could do this while keeping the performance when converting back to the `Flowable`/`Observable`.

Also it would be great if you didn't mix plain addition to `Maybe` with the other changes in one PR.
 =||= @mauin something wires must have got crossed my last rebate. I'll. Try and fix it before it's merged.

@akarnokd would you like the additions as preliminary PR before this one?
 =||= Yes, that would be great.
 =||= Let me take out the Maybe additions into a separate PR.
 =||= > does it make sense to have ignoreElements where there is a toCompletable
> the same goes for single when there is a toSingle.

Reactor's `Flux` does return `Mono<Void>` for `ignoreElements` (last time I checked) and their community liked it. I think `ignoreElements` is more intuitive for naming the function. The question is, how the return type change will disrupt the developer's flow and how many time does he/she apply `.toFlowable()` (which we dutifully try to optimize) to get back to the `Flowable`/`Observable` world:

``` java
Flowable.range(1, 10)
.flatMap(v -> .saveToDb(restCall(v)).ignoreElements().toFlowable())
.blockingLast(0)
```

To avoid this burden, we have to provide `flatMapCompletable(T -> Completable)` etc in the `Flowable`/`Observable` as well, or for basically any XMap(Function) operator there is (`concatMap`, `concatMapDelayError`, `flatMap`, `switchMap`)
 =||= Closing as out of date and will be redone in subsequent PRs.
 =||= ,0
4503,4389,2.x: Ability/API to set thread priority of shared schedulers,In 1.x I implemented this with factory methods that accept user-supplied `ThreadFactory` instances. We could mimic this in 2.x, or we could add per-scheduler properties for the thread priority. A nice advantage of the property-based approach is that we can do platform detection and automatically lower the default when running on Android (which was the initial motivation for the feature).,PR welcome.
 =||= See #4503.
 =||= Closing via #4503.
 =||= ,0
4504,4501,2.x: Matching DisposableObserver class for Single,How do you feel about adding a matching class for `DisposableObserver` with Single support?

Instead of `Observer` it'll implement `SingleObserver`,Sounds good; please add one for Completable and Maybe while you are at it.
 =||= Will do 👍 
 =||= Closing via #4504 
 =||= ,0
4513,4512,[RxJava 2.0.0-RC2] Observable.switchMap doesn't unsubscribe from inner Observable,``` java
public class SwitchMapBug {
  public static void main(String[] args) throws Exception {
    final Disposable disposable = Observable.just(true)
        .subscribeOn(Schedulers.io())
        .switchMap(value -> Observable.timer(1000, TimeUnit.MILLISECONDS)
            .compose(new TraceComposer<>("inner"))
        )
        .compose(new TraceComposer<>("outer"))
        .subscribe();

    Thread.sleep(500);
    disposable.dispose();
    Thread.sleep(2000);
  }

  private static class TraceComposer<T> implements Function<Observable<T>, Observable<T>> {
    private final String prefix;

    private TraceComposer(final String prefix) {
      this.prefix = prefix;
    }

    @Override
    public Observable<T> apply(Observable<T> observable) throws Exception {
      return observable
          .doOnSubscribe(disposable -> System.out.println("[" + prefix + "]" + " " + "doOnSubscribe"))
          .doOnDispose(() -> System.out.println("[" + prefix + "]" + " " + "doOnDispose"))
          .doOnNext(value -> System.out.println("[" + prefix + "]" + " " + "doOnNext" + " " + value))
          .doOnError(error -> System.out.println("[" + prefix + "]" + " " + "doOnError" + " " + error))
          .doOnComplete(() -> System.out.println("[" + prefix + "]" + " " + "doOnComplete"))
          .doOnTerminate(() -> System.out.println("[" + prefix + "]" + " " + "doOnTerminate"))
          .doAfterTerminate(() -> System.out.println("[" + prefix + "]" + " " + "doAfterTerminate"));

    }
  }
}
```

Output:

```
[outer] doOnSubscribe
[inner] doOnSubscribe
[outer] doOnDispose
[inner] doOnNext 0
[inner] doOnComplete
[inner] doOnTerminate
[inner] doAfterTerminate
```

Expected output:

```
[outer] doOnSubscribe
[inner] doOnSubscribe
[inner] doOnDispose
[outer] doOnDispose
```,Looks like `a.cancel()` is missed here:
https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java#L179
 =||= Thanks for the feedback. Indeed, that line should be `a.cancel()`. I'll post a fix soon.
 =||= Closing via #4513.
 =||= ,0
4516,4514,2.x Should observer be disposed after the source observable has finished emitting items?,With 1.x this test pass:

``` java
@Test
  public void subscriberShouldBeUnsubscribed() {
    rx.observers.TestSubscriber subscriber = new rx.observers.TestSubscriber();
    rx.Observable.just("").subscribe(subscriber);
    subscriber.awaitTerminalEvent();

    subscriber.assertNoErrors();
    subscriber.assertCompleted();
    subscriber.assertUnsubscribed();
  }
```

But with 2.x this test does not pass:

``` java
  @Test
  public void observerShouldBeDisposed()  {
    TestObserver observer = new TestObserver();
    Observable.just("").subscribe(observer);
    observer.awaitTerminalEvent();

    observer.assertNoErrors();
    observer.assertComplete();
    assertThat(observer.isDisposed(), is(true));
  }
```

I think that dispose is similar to unsubscribe (but maybe I'm wrong). So I was wondering if this is the expected behaviour.

  Thanks.,It's a small inconsistency. I'll fix that in my next cleanup/coverage PR.
 =||= Closing via https://github.com/ReactiveX/RxJava/commit/1145819b658983807e0cede5ba2c7d5ac1117baa
 =||= @akarnokd, with RxJava 2.0.7 the test still fails:
```java
    @Test
    public void observerShouldBeDisposed()  {
        TestObserver observer = new TestObserver();
        Observable.just("").subscribe(observer);
        observer.awaitTerminalEvent();

        observer.assertNoErrors();
        observer.assertComplete();
        assertTrue(observer.isDisposed());
    }
``` =||= There was a problem with that change and has been reverted in #4873. =||= ,0
4518,451,(question) how can I show the task progress with RxJava?,nan,This is a snippet of groovy code that will probably do most of what you want.

``` java
input = from([1,2,3,4])

// we are going to be branching off of the input observable three times so cache it.
cached = input.cache()

// produce an observable that is the fraction completed. In this case 0.25, 0.5, 0.75, 1
fract = cached.reduce(0, {count,value -> count+1}).mapMany({size -> cached.mapWithIndex({value,index -> (index+1)/size})})

// zip the fraction observable with the values to sync the timing of the values coming out with the fraction of completion
output = Observable.zip(cached,fract, {value, fractionDone ->
    // side effect to update progress bar with fraction done.
    println "done $fractionDone"
    return value
})

// OR

// if updating the status of a progress bar produces an observable you'll have to use this for the last zip
output = Observable.merge(Observable.zip(cached,fract, {value, fractionDone ->
    // operation to update progress bar with fraction done results in an observable too
    update = just("done $fractionDone")

    return zip(just(value), update, {value2, updateStatus -> value2})
}))
```
 =||= Closing out ... further conversation can be taken up on https://groups.google.com/d/forum/rxjava
 =||= ,0
4522,4521,[RxJava 2.0.0-RC2] Observable.delay doesn't respect the provided Scheduler,``` Java
public class DelayBug {
  public static void main(String[] args) throws Exception {
    final CountDownLatch latch = new CountDownLatch(1);

    Observable.<String>error(new Exception())
        .delay(100, TimeUnit.MILLISECONDS, Schedulers.io())
        .doOnError(throwable -> System.out.println("onError @ " + Thread.currentThread().getName()))
        .onErrorResumeNext(Observable.empty())
        .doAfterTerminate(latch::countDown)
        .subscribe();

    latch.await();
  }
}
```

Output:

```
onError @ main
```

Expected output:

```
onError @ RxCachedThreadScheduler-1
```,Please check the available overloads for the feature you are looking for.
 =||= I don't want to delay the error, but I still want to receive `onError` callback on the provided scheduler. This is how RxJava 1 works ([OperatorDelay.java#L66-L78](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorDelay.java#L66-L78)). I think the following code [ObservableDelay.java#L89-L105](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java#L89-L105) should be:

``` java
@Override
public void onError(final Throwable t) {
    w.schedule(new Runnable() {
        @Override
        public void run() {
            try {
                actual.onError(t);
            } finally {
                w.dispose();
            }
        }
    }, delayError ? delay : 0, unit);
}
```
 =||= PR welcome.
 =||= Closed via #4522 
 =||= ,0
4525,4524,RxJava2 `Observable.zip` taking `Iterable` and a `zipper` is broken,http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#zip-java.lang.Iterable-io.reactivex.functions.Function-

The `zipper` signature is `Function<? super T[]>, ? extends R> zipper`, where use of `T[]` breaks it. Just invoke it with non `Object` T, and a `ClassCastException` is thrown.

I checked with `Single` and `Flowable`, they have different signatures for the comparable `zip` operators. They use `Object[]` where `T[]` is used for `Observable`, which are also consistent with the 1.x zip operator.

I think this is just a bug in the signature.,Totally possible. Can you post a small unit test that fails?
 =||= ``` Java
    @Test
    public void zipIterableOfObservables() {
        List<Observable<Integer>> observables =
                new ArrayList<Observable<Integer>>();
        observables.add(Observable.just(1, 2, 3));
        observables.add(Observable.just(1, 2, 3));

        Observable.zip(observables, new Function<Integer[], Integer>() {
            @Override
            public Integer apply(Integer[] o) throws Exception {
                int sum = 0;
                for (int i : o) {
                    sum += i;
                }
                return sum;
            }
        }).test().assertResult(2, 4, 6);
    }
```

Please note that if we use lambda as a zipper, it eventually generates what the above test has.
 =||= FYI, the following works and it's what is generated with the 1.x signature:

``` Java
    @Test
    public void zipIterableOfObservables() {
        List<Observable<Integer>> observables =
                new ArrayList<Observable<Integer>>();
        observables.add(Observable.just(1, 2, 3));
        observables.add(Observable.just(1, 2, 3));

        Observable.zip(observables, new Function<Object[], Object>() {
            @Override
            public Object apply(Object[] o) throws Exception {
                int sum = 0;
                for (Object i : o) {
                    sum += (Integer) i;
                }
                return sum;
            }
        }).test().assertResult(2, 4, 6);
    }
```
 =||= Thanks. The underlying problem is that we can't do `new T[n]` and such lambdas cast the bridge `Object apply(Object[])` argument to `Integer[]` which fails since `zip` and `combineLatest` use `Object[]` internally.

Currently I can't write a PR. @vanniktech could you change all `? super T[]` signatures back to `? super Object[]` and add unit tests like above to verify there is no `ClassCastException` in a PR?
 =||= Sure 👍 
 =||= Closing via #4525.
 =||= BTW, why use array instead of `List` there? Any reason? If `List` is used, then at least it seems safe with generics, doesn't it?
 =||= Using array has reduced allocation cost and less indirection.
 =||= I've Singles of different types to run with Single.zip, and I'm getting ClassCastException as SingleZipIterable. Is it wrong zipping Singles of different type together? =||= You have to be careful which index you cast back to what type. =||= My Single.zip returns io.reactivex.internal.operators.single.SingleZipIterable but I'm expecting a Single<Object>, any Advice?
 =||= Please provide a standalone unit test that demonstrates your problem. =||= ,0
4580,4577,fromEmitter cleanup,The rename of `Observable.fromAsync` to `Observable.fromEmitter` isn't quite complete in that the signature of `Observable.fromEmitter` still refers to an interface `AsyncEmitter` which I would like to rename to `Emitter`.

 I'm happy to make a PR. It would add a new method 

``` java
@Experimental
public static <T> Observable<T> fromEmitter(Action1<Emitter<T>> emitter, Emitter.BackpressureMode backpressure) ;
```

and I would deprecate this one:

``` java
public static <T> Observable<T> fromEmitter(Action1<AsyncEmitter<T>> emitter, AsyncEmitter.BackpressureMode backpressure);
```

Proceed with PR?,Yes, PR welcome.
 =||= ,0
4585,4572,2.x: Defer Scheduler initialization in hook init API,An issue was [filed on RxAndroid](https://github.com/ReactiveX/RxAndroid/issues/332) asking for the default "main thread" scheduler to be lazily initialized. This would allow support for unit testing on the JVM by swapping out the scheduler for one that works where Android's main thread doesn't exist.

The hook API provides a means of replacing the scheduler during initialization, but the problem is that in order to call these "init" methods the instance needs to be eagerly created.

What I'm proposing is that we change the "init" functions from `Function<Scheduler, Scheduler>` to `Function<Scheduler, Callable<Scheduler>>` which would allow ignoring the default scheduler instance by never delegating to `Callable.call()` to create it.

The implementation of the initializer would change to something like:

``` java
Scheduler initFoo(Callable<Scheduler> defaultScheduler);
Function f = initFunc;
if (f == null) {
  return defaultScheduler.call();
}
return apply(f, defaultScheduler);
```

Now we can make this change _only_ in RxAndroid to support this case. I think that there's a large value in having as much symmetry between the two libraries as possible, however.

Is this something that would be acceptable to change in RxJava? Or are there any alternative APIs that anyone can think of for this?,I don't think RxJava needs this change. We have standard Java ExecutorServices backing the Schedulers so their creation should always succeed in a reasonable JDK implementation.

Maybe you could combine `AndroidSchedulers` the plugin and use a holder class to defer the creation of the looper/handler if the function happens to be null the first time `main` is invoked. I can see this needs to change the callback to `Callable` and not rely on the default anymore.

``` java
class AndroidSchedulers {
    static final class DefaultHolder {
        static final Scheduler DEFAULT_MAIN = new HandlerScheduler(
            new Handler(Looper.getMainLooper())));
    }

    static volatile Callable<Scheduler> mainHook;

    public static Scheduler main() {
        Function f = mainHook;
        if (f == null) {
            return DEFAULT_HOLDER.DEFAULT_MAIN; // initialized once and lazily
        }
        try {
            return mainHook.call();
        } catch (Throwable ex) {
            throw ExceptionHelper.wrapOrThrow(ex);
        }
    }
}
```
 =||= That doesn't allow decorating the default scheduler which is a common use
of these init hooks on Android.

I know RxJava doesn't need this, what I'm asking is if the change would be
acceptable for symmetry. As an added bonus: it means you no longer have to
remember to call .shutdown() on the original scheduler when returning a
different one (which I bet 100% of people don't do and we don't check for).

On Wed, Sep 21, 2016, 3:40 AM David Karnok notifications@github.com wrote:

> I don't think RxJava needs this change. We have standard Java
> ExecutorServices backing the Schedulers so their creation should always
> succeed in a reasonable JDK implementation.
> 
> Maybe you could combine AndroidSchedulers the plugin and use a holder
> class to defer the creation of the looper/handler if the function happens
> to be null the first time main is invoked. I can see this needs to change
> the callback to Callable and not rely on the default anymore.
> 
> class AndroidSchedulers {
>     static final class DefaultHolder {
>         static final Scheduler DEFAULT_MAIN = new HandlerScheduler(
>             new Handler(Looper.getMainLooper())));
>     }
> 
> ```
> static volatile Callable<Scheduler> mainHook;
> 
> public static Scheduler main() {
>     Function f = mainHook;
>     if (f == null) {
>         return DEFAULT_HOLDER.DEFAULT_MAIN; // initialized once and lazily
>     }
>     try {
>         return mainHook.call();
>     } catch (Throwable ex) {
>         throw ExceptionHelper.wrapOrThrow(ex);
>     }
> }
> ```
> 
> }
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4572#issuecomment-248535441,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEaPxo9olTdBE7-0fk5UDkdvE-tvLks5qsN9XgaJpZM4KCUav
> .
 =||= > That doesn't allow decorating the default scheduler which is a common use
> of these init hooks on Android.

The OP wanted to avoid depending on Handler completely so he could test on desktop. The only workaround I see is a boolean flag that when set, invokes the Function with null instead of loading the default Android scheduler.

``` java
class AndroidSchedulers {
    static final class DefaultHolder {
        static final Scheduler DEFAULT_MAIN = new HandlerScheduler(
            new Handler(Looper.getMainLooper())));
    }

    static volatile boolean noDefault;
    static volatile Function<Scheduler, Scheduler> mainHook;

    public static Scheduler main() {
        Function f = mainHook;
        if (f == null) {
            return DEFAULT_HOLDER.DEFAULT_MAIN; // initialized once and lazily
        }
        try {
            if (noDefault) {
                return f.apply(null);
            }
            return f.apply(DEFAULT_HOLDER.DEFAULT_MAIN);
        } catch (Throwable ex) {
            throw ExceptionHelper.wrapOrThrow(ex);
        }
    }
}
```
 =||= My original proposal passes a `Callable<Scheduler>` to the function. That is what I'm proposing.
 =||= Right, sounds reasonable now. How about a PR?
 =||= @akarnokd I'm the said OP. Happy to put together a PR for the change.
 =||= Sure.
 =||= Closing via #4585
 =||= ,0
4586,4498,Matcher for TestSubscriber.assertError(),In order to test occurred error in subscriber we are using `TestSubscriber.assertError()`. However, the method accepts either `Throwable` or class. So if we want to check the details of the thrown exception, we need to have methods `equals()` and `hashCode()` in each exception. But it's a bad practice.

Does it make sense to have a matcher for checking thrown exception and it?,Not sure what you mean or how you imagine it, but PR is welcome.
 =||= Closing via #4586.
 =||= ,0
4629,4628,2.x: Completable missing fromRunnable,There's `Maybe.fromRunnable` but `Completable` is missing this method.,PR welcome.
 =||= Closing via #4629.
 =||= ,0
4636,4634,Upgrade Mockito to 2.1.0-RC.2,The second release candidate of Mockito 2 has been released, which is mostly backwards compatible with your code base. I had to remove the deprecated usage of `Matchers` and replace it with the new `Mockito` equivalent matchers. This solved several ambiguity issues where both `Mockito` and `Matchers` were imported in the same file. Other than that all tests were passing locally, so let's see if CI agrees too.

Thanks a lot for using Mockito and if you have any feedback, we are eager to hear from you!,Any particular reason we should upgrade? Mockito 1.10.19 worked for us so far; also why RC2 and not wait for final?
 =||= @akarnokd This PR allows us to verify the behaviour of mockito in the wild before the final.

Here's features that may be of interest : https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2#improvements
 =||= @akarnokd thank you for your response. Mockito 2 should be in general compatible with 1.10.19. The main change in Mockito 2 is using ByteBuddy as mock maker engine. ByteBuddy is future proof and works on more recent Java versions, while it is also (almost) ready for Java 9. CGLib was sadly becoming outdated and had several issues we could not work around.

This PR was mainly for us to investigate the impact of upgrading, especially since we have published our release candidate. We expect to release final in the next week; I understand if you would rather wait a couple of days for the final release.

Apart from the import changes, it does seem some tests started failing on CI, which we will take a look if this is an issue with Mockito 2 in particular, or a breaking change in its usage.

Hopefully this addresses your concerns right now, if you have more questions we are happy to answer them.
 =||= > Other than that all tests were passing locally.

Strange, I get 4 deterministic failures when I run your code locally.
- It seems that `any(T.class)` no longer matches `null`
- Test that matched Exception such as `onError(any(NullPointerException.class))` now get a different exception. Even stranger, the tests expected the wrong exception all along yet never complained.
 =||= Ah, I see `any(T)` no longer accepts nulls and `any(Class<T>)` now actually checks for the type.
 =||= @akarnokd Yes they are failing for me locally now too. I sadly have no explanation for why they weren't earlier.

Yes `any` rejects null now. Users were missing bugs, because the matchers accepted too many values. This also seems the case for the second point where Types are actually checked.
 =||= For 1.x the allowing null is important so unless there's a way to accept nulls with Mockito, we can't move to 2.1 yet.
 =||= @akarnokd Luckily checking for null is as easy as `verify(observer, times(1)).onNext(null);` :smile: 

The four failing tests should now be fixed, with explicit checks for null as well as the correct types of exceptions.
 =||= ## [Current coverage](https://codecov.io/gh/ReactiveX/RxJava/pull/4634?src=pr) is 84.53% (diff: 100%)

> Merging [#4634](https://codecov.io/gh/ReactiveX/RxJava/pull/4634?src=pr) into [1.x](https://codecov.io/gh/ReactiveX/RxJava/branch/1.x?src=pr) will increase coverage by **0.05%**

``` diff
@@                1.x      #4634   diff @@
==========================================
  Files           274        274          
  Lines         17766      17766          
  Methods           0          0          
  Messages          0          0          
  Branches       2727       2727          
==========================================
+ Hits          15009      15018     +9   
+ Misses         1889       1884     -5   
+ Partials        868        864     -4   
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [2b47efe...3a18449](https://codecov.io/gh/ReactiveX/RxJava/compare/2b47efee292099ea7f27a606a421e22aca76dc2e...3a18449457971da4cb4c9a682255036999a53936?src=pr)
 =||= Generally speaking it is not an issue to disallow `null`, also this allow more control. API wise any family was broken in design in the 1.x to avoid casts, because of this we felt it was an important step to rework the any matchers.

Here's the change about any family matchers
- `<T> T any()` will matches anything including `null`
- `T anyT()` / `<T> any(Class<T>)` are aliases of `<T> isA(T)`, will matches non-`null` object of given type. e.g. :
  - `int anyInt()` won't match `null` (for Integers) anymore
  - `int anyString()` won't match `null` (for Strings) anymore, and will check the object is indeed a `String`
  - `int anyMap()` won't match `null` (for Maps) anymore, and will check the object is indeed a `Map`
  - `<T> List<T> anyListOf(Class<T>)` won't match `null`, and will check the object is indeed a `List`

Signature have been reworked and is balanced between the worlds of JDK6 and JDK8, although favoring JDK8 compiler.

We welcome your feed back on this !
 =||= Thanks for looking into this but I believe we'd be better experimenting with this in the 2.x branch and then apply the lessons learned in 1.x with the final/GA of Mockito 2.1. Could you post a PR targeting 2.x?
 =||= Thanks for looking into this. I'm closing this for now as may become conflicting in the meantime anyway. Once you release 2.1, I'm gladly redoing these changes on the fresh base.
 =||= ,0
4641,4332,RxJavaHooks.onError() catches all Throwables (not just undeliverable ones),The `RxJavaHooks.onError()` documentation says:

> Consume undeliverable Throwables (acts as a global catch).

However, it consumes deliverable `Throwables` just as much. For example, `SafeSubscriber._onError()` immediately calls it ([source](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/observers/SafeSubscriber.java#L150)) whether there's an onError set for the subscriber or not.

Either the documentation is wrong (and it should say it consumes _all_ `Throwables`) or the behavior is wrong.,The behavior of `SafeSubscriber` is wrong but many rely on this property already.
 =||= Would it make sense to have a second hook that is _really_ just for undelivered `Throwables`? That would be handy.
 =||= Maybe `SafeSubscriber` could call `RxJavaPlugins...handleError()` again, skipping `RxJavaHooks` entirely.
 =||= That would work for me - want a PR?
 =||= Sure.
 =||= See #4641
 =||= Closing via #4641
 =||= ,0
4645,464,(question) Is it right that rx.observables.BlockingObservable.last() returns null when the Observable is empty?,Now `rx.observables.BlockingObservable.last()` returns `null` when the Observable is empty. However, `null` is a valid value in an Observable. So when `last` returns `null`, we can not make a distinction between these two situations. I think throwing an `IndexOutOfBoundException` is more reasonable.,Have fixed in #470
 =||= ,0
4647,4633,2.x Operators ReactiveType::AmbArray + ReactiveType::AmbIterable vs ReactiveType::Amb,It seems that for the implementation of the operators `AmbArray` and `AmbIterable` different strategies have been adopted depending on the reactive type. 
- `Single` uses `SingleAmbArray` and `SingleAmbIterable`
- `Maybe` uses `MaybeAmbArray` and `MaybeAmbIterable`
- `Completable` uses `CompletableAmbArray` and `CompletableAmbIterable`
- `Observable` uses `ObservableAmb`
- `Flowable` uses `FlowableAmb`

I propose to adopt the same approach for `Single`, `Maybe` and `Completable`, merging xAmbArray and xAmbIterable into one single class, xAmb, just like `Observable` and `Flowable`.

I think this will increase the test coverage for the internal operators. 

Should I create a PR?,Sure.
 =||= I'm following the `FlowableAmb` operator implementation to create the SingleAmb operator implementation, regarding the conversion of the `Iterable` to Array. 

`FlowableAmb`

``` java
if (sources == null) {
    sources = new Publisher[8];
    for (Publisher<? extends T> p : sourcesIterable) {
        if (count == sources.length) {
            Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];
            System.arraycopy(sources, 0, b, 0, count);
            sources = b;
        }
        sources[count++] = p;
    }
}
```

If the `sourcesIterable` has less elements than 8, `sources` array will contain null references. It seems to be fine for `FlowableAmb`, somehow it will remove or ignore the null references later. 

`SingleAmb` (current adaptation of SingleAmbArray)

``` java
if (sources == null) {
    sources = new SingleSource[8];

    int count = 0;
    for (SingleSource<? extends T> element : sourcesIterable) {
        if (count == sources.length) {
            SingleSource<? extends T>[] b = new SingleSource[count + (count >> 2)];
            System.arraycopy(sources, 0, b, 0, count);
            sources = b;
        }
        sources[count++] = element;
    }
}
```

But that's not the case for `SingleAmb` operator. This class validates that none of the sources value is null.  So, I will need to reduce the value of the initial size of  sources to 1, or remove all the null references at some point later.

But, all this overhead could be avoided just converting internally from array to `Iterable` and work always with `Iterable`.

`Arrays.asList(sources)`

Is there any particular reason for not be doing that (performance?)? And, what approach should I take for SingleAmb?

Thanks.
 =||= > somehow it will remove or ignore the null

Just look a further bit down to see that `count` is used for pre-creating the consumers and the subscribe loop only considers that many elements from the input array whose tail has nulls (but should have checked for null returned by the iterable and array).

The separate implementations were there to reduce overhead and branching during subscription time. Null checks should be enforced everywhere.
 =||= Thanks @akarnokd for the explanation.

I'll change the for-each loop implementation for a classic loop using the `count` as part of the termination expression. 
 =||= ,0
4651,4650,2.x: Should Maybe and Single have a corresponding Transformers?,Currently, `Maybe.compose()` requires a `Function<? super Maybe<T>, ? extends MaybeSource<R>>` and `Single.compose()` requires something similar

While other types have `FlowableTransformer` and `CompletableTransformer`. Would it make sense to bring them into the same pattern? Aside from consistency, early testing for me shows that the generics gymnastics involved in `Maybe` and `Single`'s `Function` approaches is a major headache, as any parameterized stream type gets lost and requires manual specification, forfeiting the ability to  reuse APIs.

Consider RxLifecycle, which historically has just returned an implementation of the required Transformer.

``` java
someSingle
    .compose(RxLifecycle.bind(this).forSingle())
    .subscribe();
```

This works for simple unparameterized types, but breaks down when parameterized types come in.

![screenshot 2016-10-01 02 21 10](https://cloud.githubusercontent.com/assets/1361086/19012563/3ac09300-877f-11e6-8886-940e45ca4572.png)

``` java
// Same result with both Single and Maybe. Screenshot is Maybe, example below is Single.
// The type is now a List<T> of some type T
someListSingle
    .compose(Confine.to(this).forSingle())  // Compiler error because R type instance not found
    .subscribe();
```

Where `Confine.to` returns a bridging helper like this:

``` java
public static class LifecycleTransformer2<T> implements FlowableTransformer<T, T> {

  // Delegate transformer, what's currently returned by RxLifecycle.bind()
  private LifecycleTransformer<T> delegate;

  public static <T> LifecycleTransformer2<T> create(@NonNull LifecycleTransformer<T> delegate) {
    return new LifecycleTransformer2<>(delegate);
  }

  private LifecycleTransformer2(@NonNull LifecycleTransformer<T> delegate) {
    this.delegate = delegate;
  }

  public Function<Maybe<T>, MaybeSource<T>> forMaybe() {
    return source -> {
      Observable<T> o = toV1Observable(source.toFlowable());
      o = delegate.call(o);
      return RxJavaInterop.toV2Flowable(o).singleElement();
    };
  }

  public Function<? super io.reactivex.Single<T>, ? extends SingleSource<T>> forSingle() {
    return new Function<io.reactivex.Single<T>, SingleSource<T>>() {
      @Override
      public SingleSource<T> apply(io.reactivex.Single<T> source) throws Exception {
        Single<T> o = toV1Single(source);
        o = (Single<T>) delegate.forSingle().call((Single<Object>) o);
        return RxJavaInterop.toV2Single(o);
      }
    };
  }

  public CompletableTransformer forCompletable() {
    return source -> {
      Completable o = toV1Completable(source);
      o = delegate.forCompletable().call(o);
      return RxJavaInterop.toV2Completable(o);
    };
  }

  @Override
  public Publisher<? extends T> apply(Flowable<T> source) throws Exception {
    Observable<T> o = toV1Observable(source);
    o = delegate.call(o);
    return RxJavaInterop.toV2Flowable(o);
  }
}
```

`FlowableTransformer` and `CompletableTransformer` work fine, but the other two have been really tricky to nail down.,We have those kind of transformers but they are not wired up to `compose` for some reason  (forgotten?). PR welcome.
 =||= Totally missed that they already existed. Done! - https://github.com/ReactiveX/RxJava/pull/4651
 =||= Closing via #4651
 =||= ,0
4654,4653,2.x: Possible 6.x/Android compatibility issue,If I have an Android app targeting source compatibility 1.8, I get the following exception at runtime on a 7.0 device:

```
FATAL EXCEPTION: RxSchedulerPurge-1
     Process: io.sweers.catchup.debug, PID: 29250
     java.lang.NoSuchMethodError: No virtual method keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView; in class Ljava/util/concurrent/ConcurrentHashMap; or its super classes (declaration of 'java.util.concurrent.ConcurrentHashMap' appears in /system/framework/core-libart.jar)
         at io.reactivex.internal.schedulers.SchedulerPoolFactory$1.run(SchedulerPoolFactory.java:69)
         at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:428)
         at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:278)
         at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:273)
         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)
         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)
         at java.lang.Thread.run(Thread.java:761)
```

The exact line is:

``` java
for (ScheduledThreadPoolExecutor e : new ArrayList<ScheduledThreadPoolExecutor>(POOLS.keySet())) {  // CHM.keySet returns KeySetView in Java 8+; false positive here
```

When I look at it in the debugger, it is indeed a KeySetView, but I'm not sure what the issue is here. Let me know if this would be better served posting in RxAndroid.

CC @JakeWharton ,Interestingly, if I breakpoint this line, the rest of the app appears to run just fine and isn't blocked. As soon as I let it pass though, it crashes.
 =||= Java 8 changed the return type of `keySet` and it trips AnimalSniffer as well. In theory, by compiling with javac 7, there should be no binding to Java 8's type there.
 =||= doesn't that come at the expense of being able to target Java 8 entirely though?
 =||= Let's see if http://stackoverflow.com/a/32955708/61158 works for us as well.
 =||= While you are at this, could you post a PR with the fix above?
 =||= Looks like that fixed it when I test locally, will upload a PR in a sec
 =||= Closing via #4654.
 =||= ,0
4681,4680,2.x: ElementAt Operators in Observable and Flowable don't behave correctly on empty sources,`elementAtOrError(1)` on an empty source just leaves the new Single hanging without signalling `onError()`:

``` java
Observable.empty()
    .elementAtOrError(1)
    .test()
    .assertFailure(NoSuchElementException.class);
```

`elementAt(1)` on an empty source just leaves the Maybe hanging without signalling `onComplete()`:

```
Observable.empty()
    .elementAt(1)
    .test()
    .assertResult();
```

Just tested this against RC4. Happy to fix this.,Sure.
 =||= Closing via #4681
 =||= ,0
4686,4684,2.0.0 RC4 Errors get lost with flatMapSingle and Single.fromCallable,Try the following code:

```
public static void main(final String[] args) {
        Observable.fromArray(new String[]{"1","a","2"}).flatMapSingle(new Function<String, SingleSource<Integer>>() {
            @Override
            public SingleSource<Integer> apply(final String s) throws NumberFormatException {
                //return Single.just(Integer.valueOf(s)); //This works
                return Single.fromCallable(new Callable<Integer>() {
                    @Override
                    public Integer call() throws NumberFormatException {
                        return Integer.valueOf(s);
                    }
                });
            }
        }).subscribe(new Observer<Integer>() {
            @Override
            public void onSubscribe(final Disposable d) {
                System.out.println("Subscribe");
            }

            @Override
            public void onNext(final Integer value) {
                System.out.println("Value: " + value);
            }

            @Override
            public void onError(final Throwable e) {
                System.out.println("Error: " + e);
            }

            @Override
            public void onComplete() {
                System.out.println("Complete");
            }
        });
    }
```

The program will only output the Value 1, the NumberFormatException gets lost. If I were to use Single.just, the exception gets printed correctly.,Does `Single.fromCallable` work on its own?
 =||= Yes, if I subscribe just to the Single.fromCallable, onError gets called. 
I noticed that innerError and dispose get called on ObservableFlatMapSingle, before drainLoop just returns because the cancelled flag is set.
 =||= Yes, that's a bug.
 =||= I can't fix this today but perhaps you or @vanniktech can do it. Just don't have the code call dispose but inline the cleanup code or factor that out into a method everybody calls. Note that this is likely affecting all 4 flatMapX.
 =||= Closing via #4686
 =||= ,0
4687,4683,2.x: Observable.range(long start, long count),I'd like to have a range of long values as an Observable however only a range method with ints do exist. Is there a reason for this?

The only way I could imagine doing this now would be by using `intervalRange` with a low period however that does not seem right.,Nobody wanted to have more than 2^31 elements and you can map an int to long via `map`.
 =||= I've often wanted a range that wouldn't run out. Using 1.x when I call 

```
Observable.range(1, Integer.MAX_VALUE).subscribe();
```

it completes in 6 seconds. Sure I can manufacture a `rangeLong` myself but library support might be nice.
 =||= PR welcome. You may call it rangeLong() to avoid overload problems down the line.
 =||= Alright will add it for Flowable too
 =||= Should I copy the existing classes and just them to work on long instead of int or should I make them reusable?
 =||= Copy.
 =||= Closing via #4687.
 =||= ,0
4690,4688,2.x: BaseTestConsumer add assertValueAt(index, Predicate<T>),That one would check that the value at the given index matches the predicate. Also assertValue(Predicate<T>) could forward to the new method with the given index 0.

What are your thoughts?,Fine with me.
 =||= Closing via #4690 
 =||= ,0
4710,4709,2.x: Remove checked exceptions from transformer interfaces?,Now that transformers are not `Function` extensions, does it makes sense that they allow throwing checked exceptions? When a transformer is being invoked, its job is taking an observable and _transforming_ it into another observable but not actually doing any real work. Thus, it seems strange that you would ever encounter something that threw a checked exception in this operation. It would be a sign that you need to move that work into the stream pipeline instead of the observable creation pipeline.

This also makes code that has to deal with transformers annoying because they now have to handle (aka wrap and throw) these checked exceptions.

Happy to send a PR, but wanted to get some thoughts first and make sure I wasn't missing anything.,Works for me both ways so its up to the community to decide.
 =||= Ok. Sent a PR for it. No rush to merge if you want to wait for other opinions.
 =||= I'm a fan of this change, for the reason stated above - due to its nature, a transformer should rarely (never?) be throwing a checked exception.
 =||= I thought about it and couldn't find a reason to allow throwing there.

Closing via #4710.
 =||= ,0
4716,4715,Subscription#isUnsubscribed of Single keep false after onSuccess/onError,I updated from 1.2.0 to 1.2.1.

Until 1.2.0, `Subscription#isUnsubscribed` return `true` after `onSuccess`.
But from 1.2.1, `Subscription#isUnsubscribed` keeps `false` even if `onSuccess` / `onError` is called.

Is this a expected behavior change? If so, sorry to file rude issue.

This can reproduce with below simple code. 

``` java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        final Subscription subscription = Single.create(new Single.OnSubscribe<Boolean>() {
            @Override
            public void call(SingleSubscriber<? super Boolean> singleSubscriber) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    singleSubscriber.onSuccess(true);
                }
            }
        })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                        new Action1<Boolean>() {
                            @Override
                            public void call(Boolean aBoolean) {
                                Toast.makeText(MainActivity.this, "success", Toast.LENGTH_SHORT).show();
                            }
                        },
                        new Action1<Throwable>() {
                            @Override
                            public void call(Throwable throwable) {
                                Toast.makeText(MainActivity.this, "error", Toast.LENGTH_SHORT).show();
                            }
                        }
                );

        findViewById(R.id.check_subscription_button).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                boolean status = subscription.isUnsubscribed();
                Toast.makeText(MainActivity.this, "unsubscribed status: " + status,
                        Toast.LENGTH_SHORT).show();
            }
        });
    }
}
```

Thanks,There were internal changes to `Single` that got rid of the `SafeSubscriber` and with it the reporting on `isUnsubscribed`. If you don't call `unsubscribe` it doesn't report `true` on termination. I'll try to hunt down such cases.
 =||= Closing via #4716
 =||= ,0
4729,4727,2.x Why is FlowableEmitter.BackpressureMode and BackpressureStrategy not merged,Why are the two enums not merged into one, they both serve the same purpose and both places where they are used should have the same features.

Also because 
`BackpressureStrategy.NONE` does not exist, I currently can not use a `BufferStrategy` on an `Observable`

I don't think this code is simple easy

``` java
Observable.toFlowable(BackpressureStrategy.NONE)
.onBackpressureBuffer(10, Functions.EMPTY_ACTION, BackpressureOverflowStrategy.DROP_OLDEST)
```,If you can make it work, then PR welcome.
 =||= Closing via #4729
 =||= ,0
4747,4743,[2.0.0-RC5] distinctUntilChanged doesn't work nicely with mutable objects,``` java
public class Main {
  static class Header {
    String name = "key";
    String value = "one";
  }

  public static void main(String[] args) {
    final Header header = new Header();
    final BehaviorSubject<Header> subject = BehaviorSubject.createDefault(header);

    subject.distinctUntilChanged(new Function<Header, Object>() {
      @Override
      public Object apply(final Header header) throws Exception {
        return header.value;
      }
    }).subscribe(new Consumer<Header>() {
      @Override
      public void accept(final Header header) throws Exception {
        System.out.println("Name = " + header.name + ", Value = " + header.value);
      }
    });

    header.value = "two";
    subject.onNext(header);
  }
}
```

Output:

```
Name = key, Value = one
```

Expected output:

```
Name = key, Value = one
Name = key, Value = two
```

The same code used to work as expected with 2.0.0-RC4 and all previous RxJava versions.,Fixed via #4747
 =||= ,0
4751,4620,FlowableConcatMapEagerTest > testAsynchronousRun FAILED,```
io.reactivex.internal.operators.flowable.FlowableConcatMapEagerTest > testAsynchronousRun FAILED
    java.lang.AssertionError: Value counts differ; Expected: 2000, Actual: 1184 (latch = 1, values = 1184, errors = 0, completions = 0)
        at io.reactivex.observers.BaseTestConsumer.fail(BaseTestConsumer.java:132)
        at io.reactivex.observers.BaseTestConsumer.assertValueCount(BaseTestConsumer.java:389)
        at io.reactivex.internal.operators.flowable.FlowableConcatMapEagerTest.testAsynchronousRun(FlowableConcatMapEagerTest.java:583)
```,Closing via #4751
 =||= ,0
4757,4702,1.x: Replaying a `Single` to future subscribers. cache() missing?,As far as I can tell, there isn't a way to replay a `Single`'s result to future subscribers without re-subscribing upstream or round-tripping through an `Observable` for `cache()`. This has come up 3 times in various channels with no good answer found.

Is `cache()` missing? Or is there some other way of doing this that I can't see?,So far, nobody complained about it for 1.x. PR welcome.
 =||= Closing via #4757.
 =||= ,0
4767,4643,2.x: Remove/Hide Flowable BackpressureMode.NONE?,So, we have `Observable` for nbp streams and `Flowable` for bp streams.

What I'm afraid of is that a lot of users will do `Flowable.create(emitter, BackpressureMode.NONE)` or `toFlowable(BackpressureMode.NONE)` while in fact they should use `Observable`.

The only correct usage of `BackpressureMode.NONE` I see at the moment is RS interop since `Observable` is not RS type (please share other valid cases that can't be changed to `Observable`).

I might be overworrying of course, so opinions of project members are very appreciated.,The `NONE` can be used if you use `onBackpressureBuffer(int capacity)` or other parametrized `onBackpressureXXX` method. The default enums only support the parameterless behavior of `onBackpressureXXX`s.
 =||= ```
        /**
         * OnNext events are written without any buffering or dropping.
         * Downstream has to deal with any overflow.
         * <p>Useful when one applies one of the custom-parameter onBackpressureXXX operators.
         */
        NONE,
```
 =||= Yeah I see, hm. But isn't it kind of weird to create Flowable with no
backpressure strategy and apply afterwards If you can accept it from client
and use it at creation time?

On 29 Sep 2016 5:12 pm, "David Karnok" notifications@github.com wrote:

> ```
>     /**
>      * OnNext events are written without any buffering or dropping.
>      * Downstream has to deal with any overflow.
>      * <p>Useful when one applies one of the custom-parameter onBackpressureXXX operators.
>      */
>     NONE,
> ```
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4643#issuecomment-250592756,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AA7B3PEchh4fEG1Yr8G_cYnhYxbcdJ1aks5qvCmngaJpZM4KKej9
> .
 =||= So, what should we do about it? 

I still think that it's kind of weird to have such easily-available API that can and probably will be misused pretty often and as a result will lead to `MissingBackpressureException` though one of the ideas of `Flowable` was to move Backpressure to type level and force users to handle it while `BackpressureMode.NONE` basically disables that.

Closest semantic problem I can think of is `Observable.create()` in RxJava v1 which was misused so often that we had to "deprecate" it.

> The NONE can be used if you use onBackpressureBuffer(int capacity) or other parametrized onBackpressureXXX method. The default enums only support the parameterless behavior of onBackpressureXXXs.

@akarnokd what if we add APIs to apply parametrized `onBackpressureXXX()` at creation time?

cc @JakeWharton, we've discussed that offline a little bit and I would like to invite you to discussion here.
 =||= > what if we add APIs to apply parametrized onBackpressureXXX() at creation time?

Either you supply a varargs of options or introduce 8+ overloads.

> I still think that it's kind of weird to have such easily-available API that can and probably will be misused pretty often.

Here, the user puts in the mode parameter and is explicit. So if someone reports a MissingBackpressureException and posts a create(..., NONE), that's a clear indication of the user error.
 =||= > Here, the user puts in the mode parameter and is explicit. So if someone reports a MissingBackpressureException and posts a create(..., NONE), that's a clear indication of the user error.

Yes, but I'm not sure that a lot of users will understand that `BackpressureMode.NONE` basically `== MissingBackpresssureException`.

And even worse that when you use already created `Flowable` you can't be sure that it handles backpressure which basically `==` situation with `Observable` in RxJava v1.
 =||= Lot of users copy from examples and so far, almost all 2.x create examples used `BackpressureMode.BUFFER`.

> you can't be sure that it handles backpressure

If you wrote the `create()`, then it's on you. If you get a `Flowable` somewhere and fails, you can check the source code of the provider and apply the missing operator. If no source available, complain to the developer who created it.
 =||= Can't completely agree. Ok, what about renaming `BackpressureMode.NONE` to something that mentions consequences of its usage? I'm bad at naming: `UNSAFE_NONE`, etc.
 =||= If you find a good name...
 =||= Variants from my team: `MISSING`, `UNSAFE_NONE`, `TODO`, `UP_TO_DOWNSTREAM`.

I really like `MISSING` because it matches `MissingBackpressureException`.
 =||= UNSUPPORTED

On Wed, Oct 5, 2016, 7:05 AM Artem Zinnatullin notifications@github.com
wrote:

> Variants from my team: MISSING, UNSAFE_NONE, TODO, UP_TO_DOWNSTREAM.
> 
> I really like MISSING because it matches MissingBackpressureException.
> 
> —
> You are receiving this because you were mentioned.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4643#issuecomment-251645364,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEdIQi457CIe4MgVtVPAnoO9wJYjLks5qw4SMgaJpZM4KKej9
> .
 =||= Alright, `MISSING` is compact enough. PR welcome.
 =||= Closing via #4767
 =||= ,0
4783,4782,[2.0.0] repeatWhen/retryWhen memory leak,The following test case fails with `RxJava-2.0.0`, but works fine with `1.2.1`:

``` java
public class RepeatWhenTest {
  @Test
  public void shouldDisposeInnerObservable() {
    final PublishSubject<String> subject = PublishSubject.create();
    final Disposable disposable = Observable.just("Leak")
        .repeatWhen(completions -> completions.switchMap(ignore -> subject))
        .subscribe();

    assertTrue(subject.hasObservers());
    disposable.dispose();
    assertFalse(subject.hasObservers());
  }
}
```,The same issue with `retryWhen`:

``` java
public class RetryWhenTest {
  @Test
  public void shouldDisposeInnerObservable() {
    final PublishSubject<String> subject = PublishSubject.create();
    final Disposable disposable = Observable.error(new RuntimeException("Leak"))
        .retryWhen(errors -> errors.switchMap(ignore -> subject))
        .subscribe();

    assertTrue(subject.hasObservers());
    disposable.dispose();
    assertFalse(subject.hasObservers());
  }
}
```
 =||= Thanks. I'll investigate the reasons and post a fix. The `Flowable` variants seem to work.
 =||= See #4783
 =||= Closing via #4783
 =||= ,0
4810,4809,1.x and 2.x Javadoc for Completable's retryWhen differs from Observable, Single and Docs,While trying to use the `retryWhen` operator of the Completable I had problems understanding the behaviour detailed in it´s javadoc:

> Returns a Completable which given a Publisher and when this Completable emits an error, delivers that error through an Observable and the Publisher should return a value indicating a retry in response or a terminal event indicating a termination.

Which highly differs from the documentation of Observable, Single and the docs, where the need of calling the provided observable's onNext/onError/onCompleted is more detailed:

> Returns an Observable that emits the same values as the source observable with the exception of an {@code onError}. An {@code onError} notification from the source will result in the emission of a {@link Throwable} item to the Observable provided as an argument to the {@code notificationHandler} function. If that Observable calls {@code onComplete} or {@code onError} then {@code retry} will call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will resubscribe to the source Observable.

I could prepare a PR for both 1.x and 2.x versions if needed.,Most people set up a flow inside the retryWhen so nobody calls `onNext` manually in there. However, the text should use a bit of a cleanup:

> Returns a Completable which given a Publisher and when this Completable emits an error, delivers that error through a **Flowable** and the Publisher should **signal** a value indicating a retry in response or a terminal event indicating a termination.
 =||= Subtle but meaningful change! :)

@akarnokd Would you prefer to do the change yourself or should I?
 =||= You are welcome to change 2.x. Don't change 1.x.
 =||= @akarnokd Any specific reason why not to change 1.x? Just curious.
 =||= Don't want to mix in 2.x terminology.

Closing via #4810.
 =||= ,0
4828,482,Wiki documentation missing link,I cannot find `rxjava-examples`, supposedly at https://github.com/Netflix/RxJava/tree/master/rxjava-examples/src/main/ which is linked from https://github.com/Netflix/RxJava/wiki/Getting-Started,Forgot to change those. We started out having a single example project, but it didn't work as the number of languages expanded, so we ended up moving examples into each language.

https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-groovy/src/examples
https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala/src/examples
https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-clojure/src/examples
etc
 =||= Updated on wiki.
 =||= ,0
4830,482,Wiki documentation missing link,I cannot find `rxjava-examples`, supposedly at https://github.com/Netflix/RxJava/tree/master/rxjava-examples/src/main/ which is linked from https://github.com/Netflix/RxJava/wiki/Getting-Started,Forgot to change those. We started out having a single example project, but it didn't work as the number of languages expanded, so we ended up moving examples into each language.

https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-groovy/src/examples
https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala/src/examples
https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-clojure/src/examples
etc
 =||= Updated on wiki.
 =||= ,0
4841,4562,throwing a Serializable RuntimeException in OnNext requires OnNext value to be Serializable as well,when throwing a runtime exception during OnNext, the exception is wrapped within OnErrorThrowable$OnNextValue, which features access to the value emitted in OnNext. this feature comes at a cost - If one would wish to serialize/deserialize the exception or any object containing that exception, one would also be required to have the type of item emitted by OnNext also implement Serializable (which could lead to whole hierarchy of objects be serializable). While the original runtime exception thrown is serializable, the OnErrorThrowable$OnNextValue which includes reference to the onnext emitted item, isn't.
This leads to java.io.NotSerializableException thrown when trying to serialize the exception:

```
Caused by: java.io.NotSerializableException: com.example.SomeUnserializableObject
        at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1344)
        at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)
        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)
        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)
        at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)
        at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)
        at java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1054)
        at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1384)
        at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)
        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)
        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)
        at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)
        at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)
        at java.lang.Throwable.writeObject(Throwable.java:436)
        at java.lang.reflect.Method.invoke(Native Method)
        at java.io.ObjectO
```

I dont see any way around it other than avoiding throwing of RuntimeException during onNext, and instead move to flatmap and return Observable.error(exception).,We can mark the value as transient in the exception.

On Thu, Sep 15, 2016 at 3:29 PM saharh notifications@github.com wrote:

> when throwing a runtime exception during OnNext, the exception is wrapped
> within OnErrorThrowable$OnNextValue, which features access to the value
> emitted in OnNext. this feature comes at a cost - If one would wish to
> serialize/deserialize the exception or any object containing that
> exception, one would also be required to have the type of item emitted by
> OnNext also implement Serializable (which could lead to whole hierarchy of
> objects be serializable). While the original runtime exception thrown is
> serializable, the OnErrorThrowable$OnNextValue which includes reference to
> the onnext emitted item, isn't.
> This leads to java.io.NotSerializableException thrown when trying to
> serialize the exception:
> 
> ```
>                                                                      Caused by: java.io.NotSerializableException: com.example.sample.SomeUnserializableObject
>                                                                         at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1344)
>                                                                         at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)
>                                                                         at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)
>                                                                         at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)
>                                                                         at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)
>                                                                         at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)
>                                                                         at java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1054)
>                                                                         at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1384)
>                                                                         at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)
>                                                                         at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)
>                                                                         at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)
>                                                                         at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)
>                                                                         at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)
>                                                                         at java.lang.Throwable.writeObject(Throwable.java:436)
>                                                                         at java.lang.reflect.Method.invoke(Native Method)
>                                                                         at java.io.ObjectO
> ```
> 
> I dont see any way around it other than avoiding throwing of
> RuntimeException during onNext, and instead move to flatmap and return
> Observable.error(exception).
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4562, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEd3gv1EWHy9yKNEmMMtIbHjEAqpjks5qqZyhgaJpZM4J-QSY
> .
 =||= I must ask: what's your use case where you want to serialize exceptions? Are passing them over to some other process maybe?
 =||= It is a rather rare use case, but i do pass a result which might include an exception between activities in android, which requires the object to be serializable
 =||= See #4841
 =||= Closing via #4841
 =||= ,0
4858,485,Added  aliases and objects for concrete subject types in Scala.,-AsyncSubject[T]
-BehaviorSubject[T]
-PublishSubject[T]
-ReplaySubject[T],[RxJava-pull-requests #410](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/410/) SUCCESS
This pull request looks good
 =||= This is not really helping as subjects are “unrelated” to rx.lang.scala.Observable. 

At this point I believe we need to give up on transparent interop from Scala to Java.

I am finishing up a binding that feels more native Scala, and is very close to what I catually promise in my slides. 

Object Observable {…}
trait Observable[+T] {

  def asJavaObservable: rx.Observable[_ <: T]

}

object Observer {…}

trait Observer[-T] { 

  def asJavaObserver: rx.Observer[_ >: T]

}

object Subject {…}

trait Subject[-T, +R] extends Observable[R] with Observer[T] {

 val asJavaSubject: rx.subjects.Subject[_ >: T, _<: R]

}

object Scheduler {…}

trait Scheduler {

  def asJavaScheduler: rx.Scheduler;

}

object Notification {…}

trait Notification[+T] {

 def asJavaNotification: rx.Notification[_ <: T]

}

object Subscription {…}

trait Subscription {

  def asJavaSubscription: rx.Subscription

}

From: Rob Emanuele [mailto:notifications@github.com] 
Sent: Friday, November 15, 2013 2:38 PM
To: Netflix/RxJava
Subject: [RxJava] Added aliases and objects for concrete subject types in Scala. (#485)

-AsyncSubject[T]
-BehaviorSubject[T]
-PublishSubject[T]
-ReplaySubject[T]

---

You can merge this Pull Request by running

  git pull https://github.com/lossyrob/RxJava subjects

Or view, comment on, or merge it at:

  https://github.com/Netflix/RxJava/pull/485

Commit Summary
-   Added aliases and objects for concrete subject types.

File Changes
-   M language-adaptors/rxjava-scala/TODO.md https://github.com/Netflix/RxJava/pull/485/files#diff-0  (1) 
-   M language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subjects/package.scala https://github.com/Netflix/RxJava/pull/485/files#diff-1  (78) 
-   M rxjava-core/src/main/java/rx/subjects/AsyncSubject.java https://github.com/Netflix/RxJava/pull/485/files#diff-2  (2) 
-   M rxjava-core/src/main/java/rx/subjects/PublishSubject.java https://github.com/Netflix/RxJava/pull/485/files#diff-3  (2) 

Patch Links:
-   https://github.com/Netflix/RxJava/pull/485.patch
-   https://github.com/Netflix/RxJava/pull/485.diff
 =||= Fair. I wanted to use PublishSubjects idiomatically from Scala, and wrapping them was in the TODO list, but if something better is in the pipeline then that's great. Is there a link to the slides you mention?
 =||= ,0
4873,4872,Completable.doOnDipose() not called when disposing with TestObserver,The following test case fails:

```java
final AtomicBoolean atomicBoolean = new AtomicBoolean();

assertThat(atomicBoolean.get()).isFalse();

Completable.complete()
    .doOnDispose(() -> atomicBoolean.set(true))
    .test()
    .assertResult()
    .dispose();

assertThat(atomicBoolean.get()).isTrue(); // Fails
```

In my opinion this is a bit misleading and probably should not be the case. Is this working as intended?,Apparently `TestObserver` disconnects from the upstream on `onComplete` but `TestSubscriber` doesn't so this might be some residue. I'll post a PR to fix this.

Generally though, some operators disconnect in a similar fashion so calling dispose has no effect after they complete. =||= Closing via #4873 =||= ,0
4881,4878,2.x: @CheckReturnValue for public API,How do you guys feel if the `@CheckReturnValue` annotation was added to certain public API methods?

The one that would probably benefit the most in my opinion would be the `subscribe` method where you get a `Subscription` or `Disposable` back. In 99% of the cases you want to handle it.

Also static analyze tools such as [Error Prone](http://errorprone.info/bugpattern/CheckReturnValue) could emit an error / warning.,I frequently fire up `subscribe(Consumer)` and don't care about cancellation so it would just bother me. Also `@CheckReturnValue` sounds like part of some extra dependency and we don't want that. The only dependency is the Reactive-Streams API. =||= Yes either get the annotation from JSR 305 or I believe that creating our own annotation with the same name would also work. =||= I think `subscribeWith` is a reasonable target here as its purpose is to give you back what you gave to it so you can continue with that value. Also methods returning `Flowable` etc. shouldn't be ignored. If you can make it without external dependencies, I'm fine with the extra annotations. =||= Alright will give it a try soon. =||= Closing via #4881 =||= What's the rationale behind forcing handling of a `Disposable` return value? In most of the cases I've encountered I've preferred a setup where my subscription runs indefinitely. Is it unsafe to ignore the return here? If so, why? =||= @markelliot It was decided anything that returns `Disposable` should not have `@CheckReturnValue`. Did you find method(s) that do? =||= I'm on 2.0.5 and the source for subscribe looks like this:

```java
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer<? super T> onNext) {
        return subscribe(onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION, Functions.emptyConsumer());
    }
```

 =||= Can't link to the source since GH is truncating at ~10k lines, but it looks like on master the code is the same. =||= #5244 =||= Why would you want to not handle the returned Disposable? =||= Per above, I'm subscribing a consumer with intent to subscribe to every subsequent event. In that case, why should I handle the Disposable? =||= Since you may need to `dispose()` it later? =||= Nope, intent is to subscribe for the remaining lifetime of my program.  =||= I see it differently but it might be just because I'm on Android and you're forced to dispose() when you hit a certain lifecycle method (e.g. Activity gets destroyed) =||= @vanniktech we have quite a few subscriptions within our android app that are done from one Singleton to another and do not require disposing.  One example is a memory cache observing a disk cache.  =||= Both having and not having this annotation makes sense. Can't you just ignore warnings at that location that can legally ignore the return value? =||= You most certainly can the minor inconvenience we see is having to suppress the warning when using static analyzers/lint inspectors. For example Error Prone failed our build without `    @SuppressWarnings("CheckReturnValue")` =||= I like to think of it as a forced documentation opportunity to indicate that you really don't care about the `Disposable`. You either _always_ care about it and thus use the return value or you explicitly don't care and should suppress and comment as why it's being ignored. =||= Cool, I guess I'm asking when one _should_ check `Disposable`, it's not clear from this thread under what conditions it's safe to ignore. If it's always safe to ignore, it seems like this annotation is erroneous, if not, I'd like to know when, and why, so that I can write my code sanely. =||= I'd add that the current code explicitly excepts methods with signature `Disposable subscribe()`, so would be good to understand why those `Disposable`s are always safe to ignore but the others are not. =||= The no-arg `subscribe()` seems, in general, an anti-pattern to use. It indicates you want the side-effects of subscription to happen but do not actually care about the results, success, or failure which is a recipe for a bad user experience when such side-effect actually does fail or emit something unexpected which goes entirely unhandled. =||= I love the `@CheckReturnValue`, but in some projects with [RxLifecycle](https://github.com/trello/RxLifecycle) we do not actually need to care about this return value. In this case, we have to use `suppress` everywhere, 🤔...

P.S. I finally found  a perfect solution: https://github.com/uber/AutoDispose =||= Ugh. After updating to RxJava 2.1.12, I have awful yellow warning highlighting everywhere. My two cents -- I hate `@CheckReturnValue`. I do the following, which works well for my project:
```
.doOnSubscribe(subscriptions::add) // subscriptions is a CompositeDisposable
```
I find this much more readable than
```
Disposable disposable = somethingService.get().subscribe(...);
composititeDisposable.add(disposable);
```

I don't want to suppress that warning _everywhere_, so now I have to litter my code with local suppressions. =||= I am with @autonomousapps on this one.

I also have a convenience method to be used with `.compose()`

```
protected <T> ObservableTransformer<T, T> asDisposable() {
        return upstream ->
                upstream.doOnSubscribe(disposable -> mDisposables.add(disposable));
    }
```

And I needed to add `@SuppressWarnings("CheckReturnValue")` in order to pass on Error Prone, while  in fact I am using the disposable on `doOnSubscribe`. =||= I see little point in using `Disposable` of `Single`/`Completable`/`Maybe`. Sure, you might want to explicitly cancel them at some point, but that's definitely not something that you'll always need.

Plus `@CheckReturnValue` is incompatible with [RxLifecycle](https://github.com/trello/RxLifecycle) for regular `Observable`.

Project-wide or even class-wide `@SuppressLint("CheckResult")` is a very bad idea so I'm forced to use 
```
.subscribe(() -> {
	...
})
.isDisposed();
```

Looks ugly. =||= I'd like to kick the tires on this discussion again

> In 99% of the cases you want to handle it.

I don't think I agree with that. For cases like @digitalbuddha mentioned with singletons or places where the scope of the execution is implicitly bound to the object (such as subscribing to an Android View's click events from within the View). To me, `@CheckReturnValue` should only apply in cases where it is **100% programmer error to not** capture it, such as a factory method. This to me is not such a case.

Thoughts? =||= Views have a lifecycle you should be using to unsubscribe. For singletons, you can suppress with a comment to document the rare nature of that object and its exception to the rule. =||= > Views have a lifecycle you should be using to unsubscribe

If you need to dispose at some point before the View is up for GC, sure. That's not the case 100% of the time though. I could be listening for detach events too, for instance, or tracking through multiple attach/detaches. There's no other lifecycle event to hook into beyond detach, but I'm happy to let the subscription die with the View once they're all leafs for GC if the subscription is only internal to the View.

Another example would be synchronous cases like `just` or `fromIterable`.

I just don't think this case is as rare as is being described. On top of that, conditions for cases like lifecycle management vary depending on the codebase, and often doesn't involve directly dealing with the `Disposable` itself. In RxLifecycle, a completion event is sent from upstream. In AutoDispose, it's handled internally (though there we just omit these annotations from the returned subscribe proxy interfaces). Some codebases might use Kotlin with their own extensions, or `CompositeDisposable`s in some fancy way, or even pass in a `Consumer<Disposable>` directly to the full-arg `subscribe()` overload, yet still will have this imposed on them by static analysis tools. I think enforcement for this case is much better left to consumers to implement what fits their codebase best. Perhaps a community EP/lint check that recreates this behavior would be useful for those that want to keep it, without requiring it for all. =||= ,0
4884,488,Possible Interop with Spring Reactor,Hi,

Reactor pattern is very much related to Observable. So is it possible to have some level of interop with Reactor (https://github.com/reactor/reactor).

Suminda ,Bindings for it would make sense, but probably as part of Reactor itself. It doesn't make sense for RxJava itself to try and have bindings for every possible 3rd party library out there and their different release cycles.
 =||= I see you already opened [an issue there](https://github.com/reactor/reactor/issues/213)
 =||= There is a good fit here. Only minor concern is if there is an impedance mismatch on speed.

Reactor Selector-based dispatching w/ dynamic Consumer assignment: ~10-15M events/sec 
Reactor Selector-based dispatching w/o dynamic Consumer assignment: ~20-25M events/sec 
Reactor Processor (LMAX Disruptor wrapper) no dispatching at all, fixed Consumer: ~90-100M events/sec 
Reactor TCP syslog to HDFS: 600k messages/sec 

(Source: https://groups.google.com/d/msg/reactor-framework/e3q9IqOKHdk/Et9zuw896JEJ)
 =||= If there are performance issues, then we should fix them. 

If you make progress on this please let the RxJava community know, and if you find performance bottlenecks please help identity and/or fix them.
 =||= ,0
4911,490,Scala Adaptor: Inheritance, subscriptions and subjects,I tried to add subscriptions and subjects using the value class trick, and came to the conclusion that it won't work. The problem is that inheritance and value classes don't work together, because value classes cannot be extended. We want Observable to be a value class, and at the same time, we want Subject to extend Observable, so that doesn't work.

This PR is very similar to [Erik's code](https://github.com/headinthebox/ScalaBindingsRecent), but I added a trait

``` scala
trait JavaWrapper[+W] {
  def asJava: W
}
```

which all classes extend. This allows us to have an `asJava` method everywhere (instead of `asJavaSubject` / `asJavaObserver` etc). The main challenge was to get the double inheritance Subject extends Observer and Observable working.
Now all wrappers are done the same way. For instance, Observable looks as follows:

``` scala
trait Observable[+T] extends JavaWrapper[rx.Observable[_ <: T]] { 
  ... 
}

object Observable {
  private[Observable] class ObservableWrapper[+T](val asJava: rx.Observable[_ <: T]) extends Observable[T] {}

  def apply[T](asJava: rx.Observable[_ <: T]): Observable[T] = {
    new ObservableWrapper[T](asJava)
  }

  ...
}
```

In Scala code, to convert from Scala types to Java types, there's the `asJava` method, and to convert from Java types to Scala types, there's an `apply` method in each companion object.

When we used value classes, such conversions were not necessary in Java, because Scala types appeared as Java types for the Java compiler. Now, they become necessary, but note that this PR does not yet contain such conversions, but that should be no big problem.,[RxJava-pull-requests #413](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/413/) SUCCESS
This pull request looks good
 =||= I'm reviewing this with Erik tomorrow and will get this or some variant of it pulled in.
 =||= Yes, this PR is incomplete, closing.
 =||= ,0
4912,4697,PlatformDependent.resolveAndroidApiVersion() fails when running under Robolectric,PlatformDependent.resolveAndroidApiVersion() tries to determine the Android SDK version by reading the android.os.Build$VERSION#SDK_INT field:

```
        try {
            return (Integer) Class
                    .forName("android.os.Build$VERSION", true, getSystemClassLoader())
                    .getField("SDK_INT")
                    .get(null);
        } catch (Exception e) {
            // Can not resolve version of Android API, maybe current platform is not Android
            // or API of resolving current Version of Android API has changed in some release of Android
            return ANDROID_API_VERSION_IS_NOT_ANDROID;
        }
```

When running under Robolectric, the class will be found (since Robolectric bundles an original android.jar). However, the method is using the system class loader for loading it (instead of the Robolectric instrumenting class loader), which will not instrument the class to run in the JVM. As a result, static initialization of the class fails with an UnsatisfiedLinkError when calling SystemProperties.get(), which calls native method native_get.

PlatformDependent.resolveAndroidApiVersion() should use the default class loader or discard UnsatisfiedLinkErrors (or all throwables).,Thanks for reporting this. I don't know enough about the platform so PR welcome.
 =||= Sure.
 =||= If I remember correctly, this android check is used for setting the default buffer size to 16 on Android. I don't know how drastic would it be to use 128 (desktop default) from now on? Alternative would be to detect small max memory via some management bean.
 =||= This is really a problem. Is there any progress or work-around? E.g. downgrading RxJava etc? Thx! =||= Sorry for the late reply.

@jwedel I patched by copying the android.os.Build class from the Android framework to my test source set. RxJava finds that instead and doesn't throw an exception.

@akarnokd The fix is straightforward: just catch Throwable instead of Exception. That'll cover the cases where the class can't be found (not Android) or the class can be found but not loaded (Robolectric). I'll send a PR. =||= @cesar1000 Hi, thanks for your reply. 
I copied the Build.java file from our Andoid 22 sdk source to test/android/os/Build.java. I see that this file is being used, but it still fails:

```
java.lang.UnsatisfiedLinkError: android.os.SystemProperties.native_get(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
	at android.os.SystemProperties.native_get(Native Method)
	at android.os.SystemProperties.get(SystemProperties.java:64)
	at android.os.Build.getString(Build.java:693)
	at android.os.Build.<clinit>(Build.java:38)
	at android.os.Build$VERSION.<clinit>(Build.java:152)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:348)
	at rx.internal.util.PlatformDependent.resolveAndroidApiVersion(PlatformDependent.java:69)
	at rx.internal.util.PlatformDependent.<clinit>(PlatformDependent.java:33)
	at rx.internal.util.RxRingBuffer.<clinit>(RxRingBuffer.java:246)
	at rx.Observable.observeOn(Observable.java:7613)
```

I see that the copied file is used.
 =||= @jwedel this is the class I used: https://gist.github.com/cesar1000/06139a68d5c062beaecbd26d52c3563d. You should put it under src/test/java/android/os in the module containing your tests. =||= One concern with addressing this issue by discarding the UnsatisfiedLinkError is that RxJava will not run in Android mode when under Robolectric. This feels wrong, since Robolectric is meant to simulate an Android environment in the JVM.

@akarnokd, the root cause of this problem is that using the system class loader fails when in Robolectric. I see that the code was copied from Netty. Do you know if using the system class loader for loading the class is strictly needed in this case? Using the default class loader would fix the bug here. =||= I don't know. =||= Ok, I'll do this: I'll try using the default class loader and validate both on an Android device and in Robolectric.

@benjchristensen, you added this code originally. Do you have any concerns about switching to using the default class loader instead of the system class loader for trying to load the Build$VERSION class on Android? =||= Ben is no longer active in this project and he may not answer. =||= Yeah, I thought it wouldn't hurt to try :). I'll test my changes locally. I suspect that using the default class loader will suffice for our purposes. =||= @cesar1000 :+1: 
With this file, it works like a charm! Yay, thanks alot! =||= @jwedel hopefully we can do better though :). I'll try a fix tomorrow. =||= @cesar1000 One update, this runs in AndroidStudio, but not on commandline with `gradlew clean build`. There (and on jenkins), I still get the exception shown above. Do you have any idea how to change the classpath ordering for the gradle android plugin? For the Gradle Java task it is possible, but I couldn't find anything in the Android plugin docs... :( =||= @jwedel yeah, we happened to have some code in our scripts that addressed that indirectly.

```
        project.android.unitTestVariants.each { variant ->
            def scope = variant.variantData.scope
            project.tasks.getByName("test${variant.name.capitalize()}") { testTask ->
                doFirst {
                    // Move the mockable Android jar to the beginning of the classpath, so that it's not overriden
                    // by the Robolectric jar (which is only preferred in the compilation of the robolectric project).
                    // Run this in a doFirst to make sure all prepare*Dependencies tasks have resolved their artifact
                    // paths before resetting the classpath conventionMapping.
                    // Also, xmlpull needs to go first, since it's used by robolectric but mocked in the Android jar.
                    def xmlPullJar = classpath.find { file -> file.path.contains('xmlpull') }
                    classpath = files(xmlPullJar, scope.globalScope.mockableAndroidJarFile).plus(classpath)
                }
            }
        }

```

It's hacky, but it does the job since it ensures that the Build$VERSION class in the mockable jar is found before the class brought in by Robolectric. =||= Fixed in 1.2.4 just released. =||= ,0
4921,4920,2.x: TestSubscriber/TestObserver wrong error message,TestSubscriber:210 `onNext received a null Subscription`
TestSubscriber:229 `onError received a null Subscription`
TestObserver:152  `onNext received a null Subscription` 
,Closing via #4921 =||= ,0
4924,4923,2.x Single.flatMapCompletable expects Completable instead of CompletableSource,The signature looks like this:

`final Function<? super T, ? extends Completable> mapper`

although it should be 

`final Function<? super T, ? extends CompletableSource> mapper`,I don't think there are any `CompletableSource` implementations other than RxJava but you are welcome to send a PR. =||= Well it's mostly for consistency and I'll send one right away. =||= Closing via #4924 =||= ,0
4927,4926,[2.x] IllegalStateException on Observable.timer with 0 milliseconds,- Library version 2.0.3

The following test occasionally fails (about 200 out of 1000 fail):

```kotlin
@Test
fun test() {
    var t: Throwable? = null
    RxJavaPlugins.setErrorHandler { t = it }
    Observable.timer(0L, MILLISECONDS).blockingFirst()
    t?.let { throw it }
}
```

Stacktrace:

```
java.lang.IllegalStateException: Disposable already set!

	at io.reactivex.internal.disposables.DisposableHelper.reportDisposableSet(DisposableHelper.java:144)
	at io.reactivex.internal.disposables.DisposableHelper.setOnce(DisposableHelper.java:70)
	at io.reactivex.internal.operators.observable.ObservableTimer$IntervalOnceObserver.setResource(ObservableTimer.java:74)
	at io.reactivex.internal.operators.observable.ObservableTimer.subscribeActual(ObservableTimer.java:40)
	at io.reactivex.Observable.subscribe(Observable.java:10514)
	at io.reactivex.Observable.blockingFirst(Observable.java:4535)
	at myapp.MyTest.test(MyTest.kt:15)
```

Whenever the test fails, [IntervalOnceObserver#setResource](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableTimer.java#L40) is called _after_ it is disposed.,Thanks for reporting. If the emission happens before the `setResource` call, the `setResource` will find the wrong reference there and complain about it. I'll fix it shortly. =||= Closing via #4927 =||= Tried v2.0.2 in production and seeing a lot of these crashes come up. I know this has been fixed, but do we have an ETA for v2.0.4? Thank you. =||= See https://github.com/ReactiveX/RxJava/issues/4947 =||= ,0
4932,493,Zip many from scratch, missing concat of iterable.,nan,[RxJava-pull-requests #416](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/416/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #417](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/417/) FAILURE
Looks like there's a problem with this pull request
 =||= ,0
4941,494,Operators without co- or contravariance,I'm looking at the operator definition and found a bunch of places where the "lambda" functions do not have wildcard bounds specified, e.g.,

reduce(Func2[T, T, T])
max(Comparator[T])

etc.
Is there a particular reason these are not:

reduce(Func2[? super T, ? super T, ? extends T])
max(Comparator[? super T])

?,reduce:

That's a long story, see https://github.com/Netflix/RxJava/pull/369 , https://github.com/Netflix/RxJava/issues/360 , and https://github.com/Netflix/RxJava/issues/336#issuecomment-24094254 . 
In short:
-    It's considered unnecessary (or not necessary enough to complicate the signature)
-    Note, though, that the signature of reduce is not entirely correct, because the covariant type parameter T appears in a contravariant position, so you can't use reduce on an `Observable<? extends XXX>` , but only on an `Observable<XXX>` . To fix this, one would need lower bounds for type parameters, but Java doesn't support this.

min/max:

IMHO it would be a good idea to add wildcards, what do others think?
 =||= For min/max, I agree with you. I'll fix it.
 =||= It seems we can close this issue now.
 =||= ,0
4943,4902,FlowablePublishFunctionTest > inputOutputSubscribeRace FAILED,```
io.reactivex.internal.operators.flowable.FlowablePublishFunctionTest > inputOutputSubscribeRace FAILED
    java.lang.AssertionError: Value count differs; Expected: 1 [1], Actual: 0 [] (latch = 1, values = 0, errors = 0, completions = 0)
        at io.reactivex.observers.BaseTestConsumer.fail(BaseTestConsumer.java:133)
        at io.reactivex.observers.BaseTestConsumer.assertValues(BaseTestConsumer.java:404)
        at io.reactivex.observers.BaseTestConsumer.assertResult(BaseTestConsumer.java:613)
        at io.reactivex.internal.operators.flowable.FlowablePublishFunctionTest.inputOutputSubscribeRace(FlowablePublishFunctionTest.java:410)
```,CLosing via #4943 =||= ,0
4945,4944,Using Observable.timeout could cause uncaught exception in RxJava 2.x,Please have a look at this sample:

    public void testSubject() {
        io.reactivex.subjects.PublishSubject<Integer> subject = io.reactivex.subjects.PublishSubject.create();       
        subject
                .timeout(10, TimeUnit.SECONDS, io.reactivex.Observable.error(new RuntimeException()))
                .takeWhile(integer -> integer < 3)
                .toList()
                .subscribe(integers -> System.out.println(integers), throwable -> System.out.println("throwable"));

        subject.onNext(0);
        subject.onNext(1);
        subject.onNext(2);
        subject.onNext(3);

        subject.onError(new RuntimeException());
    }
`
It is expected, that after posting value '3' chain emits result [0, 1, 2] and unsubscribes from the subject and subsequent posting of RuntimeException doesn't push it anywhere and doesn't throw it.

But on v2.0.3 it crashes with RuntimeException

The same test with rx.subjects.PublishSubject on v1.2.4 works as expected

If remove timeout from the chain everything works as expected.

Thanks,Thanks for reporting. This is a bug with the fallback version of the `timeout` operator, both in `Observable` and `Flowable`. The fix is underway. =||= Closing via #4945 =||= ,0
4955,495,Zip many rewritten, Concat with iterable, Merge with Iterable.,I've rewritten the Zip method to terminate as soon as possible. In addition, the concat(Iterable<Observable<T>> and merge(Iterable<Observable<T>>) where missing from Observable.,[RxJava-pull-requests #418](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/418/) SUCCESS
This pull request looks good
 =||= @akarnokd Thank you for this. I'm checking out the branch now to play with it and see how the problematic unit tests behave.

Would you mind re-submitting the pull request though after rebasing this onto a new branch so we don't have all the commit clutter resulting from you working on your master branch? The commit "Merge origin/master" https://github.com/akarnokd/RxJava/commit/0dcbe89f291f3a77f8bbbd5cefd745a12600c40e and commits before that are a result of merging /Netflix/RxJava master into your master then submitting back from the same branch. It is preferable to always commit only to a clean branch and submit a pull request from that so only the relevant commits are applied. The only time anything should commit to your forked master is when fetching from the upstream to sync back up.

Thanks!
 =||= I want to confirm a unit test for this code. @headinthebox can you please validate something? 

The following unit test shows how this will correctly complete once the first stream completes. However, it still waits until ALL items are emitted before the `onCompleted` is sent. I want to ensure that's how it should behave as opposed to skipping those and completing as soon as onComplete is sent (like onError should).

``` java
    @Test
    public void testOnFirstCompletion() {
        PublishSubject<String> oA = PublishSubject.create();
        PublishSubject<String> oB = PublishSubject.create();

        @SuppressWarnings("unchecked")
        Observer<String> observer = mock(Observer.class);

        Observable<String> o = Observable.create(zip(oA, oB, getConcat2Strings()));
        o.subscribe(observer);

        InOrder inOrder = inOrder(observer);

        oA.onNext("a1");
        inOrder.verify(observer, never()).onNext(anyString());
        oB.onNext("b1");
        inOrder.verify(observer, times(1)).onNext("a1-b1");
        oB.onNext("b2");
        inOrder.verify(observer, never()).onNext(anyString());
        oA.onNext("a2");
        inOrder.verify(observer, times(1)).onNext("a2-b2");

        oA.onNext("a3");
        oA.onNext("a4");
        oA.onNext("a5");
        oA.onCompleted();

        // SHOULD ONCOMPLETE BE EMITTED HERE INSTEAD OF WAITING
       // FOR B3, B4, B5 TO BE EMITTED?

        oB.onNext("b3");
        oB.onNext("b4");
        oB.onNext("b5");

        inOrder.verify(observer, times(1)).onNext("a3-b3");
        inOrder.verify(observer, times(1)).onNext("a4-b4");
        inOrder.verify(observer, times(1)).onNext("a5-b5");

        // WE RECEIVE THE ONCOMPLETE HERE
        inOrder.verify(observer, times(1)).onCompleted();

        oB.onNext("b6");
        oB.onNext("b7");
        oB.onNext("b8");
        oB.onNext("b9");
        // never completes (infinite stream for example)

        // we should receive nothing else despite oB continuing after oA completed
        inOrder.verifyNoMoreInteractions();
    }

    private Func2<String, String, String> getConcat2Strings() {
        return new Func2<String, String, String>() {

            @Override
            public String call(String t1, String t2) {
                return t1 + "-" + t2;
            }
        };
    }
```
 =||= This confirms the `onError` event is propagated immediately:

``` java
@Test
    public void testOnErrorTermination() {
        PublishSubject<String> oA = PublishSubject.create();
        PublishSubject<String> oB = PublishSubject.create();

        @SuppressWarnings("unchecked")
        Observer<String> observer = mock(Observer.class);

        Observable<String> o = Observable.create(zip(oA, oB, getConcat2Strings()));
        o.subscribe(observer);

        InOrder inOrder = inOrder(observer);

        oA.onNext("a1");
        inOrder.verify(observer, never()).onNext(anyString());
        oB.onNext("b1");
        inOrder.verify(observer, times(1)).onNext("a1-b1");
        oB.onNext("b2");
        inOrder.verify(observer, never()).onNext(anyString());
        oA.onNext("a2");
        inOrder.verify(observer, times(1)).onNext("a2-b2");

        oA.onNext("a3");
        oA.onNext("a4");
        oA.onNext("a5");
        oA.onError(new RuntimeException("forced failure"));

        // it should emit failure immediately
        inOrder.verify(observer, times(1)).onError(any(RuntimeException.class));

        oB.onNext("b3");
        oB.onNext("b4");
        oB.onNext("b5");
        oB.onNext("b6");
        oB.onNext("b7");
        oB.onNext("b8");
        oB.onNext("b9");
        // never completes (infinite stream for example)

        // we should receive nothing else despite oB continuing after oA completed
        inOrder.verifyNoMoreInteractions();
    }
```
 =||= Sorry for the clutter, I'm new to Git in this manner. Will do a new pull shortly.
 =||= > Sorry for the clutter, I'm new to Git in this manner. Will do a new pull shortly.

Not a problem, the Git flow for pull requests is not obvious when first starting. I totally messed up a few repos when I first started, had to wipe them out and start fresh with clean forks until I got the hang of it :-)
 =||= Closing as replaced by https://github.com/Netflix/RxJava/pull/497
 =||= ,0
4957,4956,RxJava 2.0.4 Observable calls dispose before terminal event.,Recently discovered behaviour that brings incorrect order for Observable.doFinally

Here is code to check
``` Java
    @Test
    public void operationFinallyOrder() throws Exception {
        Single.error(new RuntimeException())
                .doOnDispose(() -> System.out.println("Single.doOnDispose"))
                .doFinally(() -> System.out.println("Single.doFinally"))
                .subscribe(o -> System.out.println("Single.onSuccess"),
                        t -> System.out.println("Single.onError"));
        System.out.println();

        Completable.error(new RuntimeException())
                .doOnDispose(() -> System.out.println("Completable.doOnDispose"))
                .doFinally(() -> System.out.println("Completable.doFinally"))
                .subscribe(() -> System.out.println("Completable.onComplete"),
                        t -> System.out.println("Completable.onError"));
        System.out.println();

        Observable.error(new RuntimeException())
                .doOnDispose(() -> System.out.println("Observable.doOnDispose"))
                .doFinally(() -> System.out.println("Observable.doFinally"))
                .subscribe(o -> System.out.println("Observable.onNext"),
                        t -> System.out.println("Observable.onError"),
                        () -> System.out.println("Observable.onComplete"));
        System.out.println();

        Observable.just(new Object())
                .doOnDispose(() -> System.out.println("Observable.doOnDispose"))
                .doFinally(() -> System.out.println("Observable.doFinally"))
                .subscribe(o -> System.out.println("Observable.onNext"),
                        t -> System.out.println("Observable.onError"),
                        () -> System.out.println("Observable.onComplete"));
    }
```
Output:
```
Single.onError
Single.doFinally

Completable.onError
Completable.doFinally

Observable.doOnDispose
Observable.doFinally
Observable.onError

Observable.onNext
Observable.doOnDispose
Observable.doFinally
Observable.onComplete
```
As you can see, order and amount of messages for Single and Completable are correct, but ```LambdaObserver``` calls dispose before terminal event. That triggers doFinally too early. 
According to new lifecycle (confirmed here https://github.com/ReactiveX/RxJava/issues/4811) no messages Observable.doOnDispose should be there.,Indeed, `Observable` behaves differently from `Flowable`:

```
Flowable.onError
Flowable.doFinally

Flowable.onNext
Flowable.onComplete
Flowable.doFinally
```

I'll post a fix shortly. =||= See #4957 =||= Closing via #4957 =||= ,0
4962,4961,2.0.3 Single.takeUntil() crashes ,```java
Single<T> main;
Flowable<T> other;

main.takeUntil(other.take(1)).subscribe(...);
```

This pseudo-code crashes when `other` emits an item. `SingleTakeUntil.TakeUntilOtherSubscriber.onCompleted()` is called twice and second call generate a crash. Please fix this.,Please provide the crash stacktrace. =||= Closing via #4962 =||= ,0
4972,4950,2.x: compose() generics,Migrating some of our code to RxJava 2, we've run into some issues around transformers due to the following signature change:

```java
// 1
public <R> Observable<R> compose(Transformer<? super T, ? extends R> transformer) {     
    return ((Transformer<T, R>) transformer).call(this); 
}

// 2
public final <R> Observable<R> compose(ObservableTransformer<T, R> composer) {     
    return wrap(composer.apply(this));
 }
```

Was this intentionally narrowed? If not, open to a PR to add back the `? super` semantics?,Do you have an example that doesn't compile for you without `? super`? We have to be careful with such variance changes because it may break current users. =||= Whoops just saw your response. I'll put together a sample later tonight =||= So here's an example where an observable emits `A` instances down the stream and transforms them into `B` instances.

```java
interface A<T, R> {}
interface B<T> {}

// RxJava 1
static <T> rx.Observable.Transformer<A<T, ?>, B<T>> oldStyle() {
    return new rx.Observable.Transformer<A<T, ?>, B<T>>() {
        @Override
        public rx.Observable<B<T>> call(rx.Observable<A<T, ?>> a) {
            return rx.Observable.empty();
        }
    };
}

// RxJava 2
static <T> ObservableTransformer<A<T, ?>, B<T>> newStyle() {
    return new ObservableTransformer<A<T, ?>, B<T>>() {
        @Override
        public ObservableSource<B<T>> apply(Observable<A<T, ?>> a) {
            return Observable.empty();
        }
    };
}

void test() {
    
    A<String, Integer> a = new A<String, Integer>() { };

    // RxJava 1
    rx.Observable.just(a)
            .compose(TransformersTest.<String>oldStyle())  // Yay, because Integer is irrelevant here
            .subscribe(new Action1<B<String>>() {
                @Override
                public void call(B<String> stringB) {

                }
            });

    // RxJava 2
    Observable.just(a)
            .compose(TransformersTest.<String>newStyle())   // This doesn't compile
            .subscribe(new Consumer<B<String>>() {
                @Override
                public void accept(B<String> tB) throws Exception {

                }
            });
}
```

In the RxJava 2 example, the `compose()` line there doesn't compile because of generics issues.

<img width="1341" alt="screen shot 2017-01-07 at 11 55 01 pm" src="https://cloud.githubusercontent.com/assets/1361086/21748246/f0879672-d534-11e6-9f53-48c5b776ba89.png">

In order to make it compile, the transformer signature needs to be changed to be like the following:

```java
static <T, R> ObservableTransformer<A<T, R>, B<T>> newStyle() {
    return new ObservableTransformer<A<T, R>, B<T>>() {
        @Override
        public ObservableSource<B<T>> apply(Observable<A<T, R>> a) {
            return Observable.empty();
        }
    };
}
```

And imposes some boilerplate on the consumer in that they now have to specify the second type even though it's irrelevant.

```java
Observable.just(a)
        .compose(TransformersTest.<String, Integer>newStyle())  // :(
        .subscribe(new Consumer<B<String>>() {
            @Override
            public void accept(B<String> tB) throws Exception {

            }
        });
``` =||= Okay, please verify that with the variance changes it compiles with Java 6, 7 and 8 targets. =||= ,0
4982,4981,2.x Observable#concatMapEager doesn't always preserve order,Sample code (using RxJava 2.0.4):
```java
Observable.just(1, 2, 3, 4, 5)
        .concatMapEager(i -> {
            System.out.println("Processing " + i);
            return i == 3 ? Observable.just(i) : Observable
                    .just(i)
                    .delay(1, TimeUnit.MILLISECONDS, Schedulers.io());
        })
        .observeOn(Schedulers.io())
        .subscribe(i -> System.out.println("Value: " + i));
```

Expected output:
```
Processing 1
Processing 2
Processing 3
Processing 4
Processing 5
Value: 1
Value: 2
Value: 3
Value: 4
Value: 5
```

Actual output:
```
Processing 1
Processing 2
Processing 3
Processing 4
Processing 5
Value: 3
Value: 1
Value: 2
Value: 4
Value: 5
```

As you can see the order is incorrect. This is due to the fact that the item `3` is mapped to a `Callable` source which won't wait for the previous observables.,Thanks for the feedback. This is indeed a bug with `Observable.concatMapEager()`. `Flowable` works properly.

I'll post a fix shortly. A workaround is to use `just(i).hide()` to break the bad/false internal optimization. =||= Closing via #4982 =||= ,0
4987,4414,CombineLatestDelayError emits error before all inner observables emit result,Recently I came across following issue while using `combineLatestDealyError` operator. This code has been tested on Android, Nexus 5x running OS 6.0.1.

```
Observable<Boolean> errorObservable = Observable.create(subscriber -> {
    subscriber.onError(new NullPointerException());
});

Observable timeoutObservable = Observable.create(subscriber -> {
    subscriber.onNext(true);
    subscriber.onCompleted();
})
.delay(5, TimeUnit.SECONDS, AndroidSchedulers.mainThread())
.doOnNext(result -> Log.d("Combine", "Delay emitted"));

Observable<Object> zippedObservable = Observable.zip(
        Observable.just(true), timeoutObs,
        (flag1, flag2) -> {
            Log.d("Combine", "On Zip emitted");
            return new Object();
        });

return Observable.combineLatestDelayError(
        Arrays.asList(errorObservable, zippedObservable),
        result -> {
            Boolean flag1 = (Boolean) result[0];
            Object object = result[1];
            Log.d("Combine", "Result of errorObservable: " + flag1);
            Log.d("Combine", "Result of zippedObservable: " + object);
            return null;
        }).subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Subscriber<Object>() {
            @Override
            public void onCompleted() {
                Log.d("Combine", "OnCompleted");
            }

            @Override
            public void onError(Throwable e) {
                Log.d("Combine", "OnError");
            }

            @Override
            public void onNext(Object o) {
                Log.d("Combine", "OnNext");
            }
        });
```

This piece of code is trying to simulate callbacks using delays - for example Android Pay availability callback.

Problem here arises once this code is run. The log will be:

```
OnError
Delay emitted
On Zip emitted
```

This is quite contradictory to the docs that state that expected behavior should be:

```
Delay emitted
On Zip emitted
OnError
```

The expected result does happens if you add `subscriber.onNext(true)`  to the `errorObservable` before `subscriber.onError...`,Your `errorObservable` doesn't emit any value and since `combineLatestDelayError` won't ever be able to combine values, it terminates with the error immediately.
 =||= Docs state:

> Concatenates the Observable sequence of Observables into a single sequence by subscribing to each inner Observable, one after the other, one at a time and delays any errors till the all inner and the outer Observables terminate.

In diff:
[https://github.com/ReactiveX/RxJava/pull/3759/files#diff-c3bbc6e9e497930d46361b0b8140431cR1163](url)

So empahsis is on:

> and delays any errors till the ALL inner and the outer Observables terminate.

In this scenario second observable is not finished and error is not delayed.

What if you want to make two API calls no matter of the result of previous and combine their result? I do understand that there is always different type of solution and approach but I just believe that either docs are not correct or this is potential bug since it should behave as stated.
 =||= The documentation is incorrect as there is no "outer `Observable`" with this operator. Otherwise, it's an undocumented corner case that needs a revisit. Note however that even if the operator delayed the error to the very end, you wouldn't see any combined values ever (but perhaps the errors of the others).
I'll see what it takes to make the operator wait out all events.
 =||= This is more complicated to work out the proper rules. For example, what should happen if you `combineLatestDelayError(empty(), error(x), func2)` or `combineLatestDelayError(error(x), empty(), just(1), func3)`?
 =||= For `combineLatestDelayError(empty(), error(x), func2)` it makes sense that `empty()` will terminate and `onError` will be invoked?

For second, I would say `empty()`, then `just(1)` then `onError` will be invoked?

I'm just following up with an idea, its not that I expect it to work that way.
 =||= `combineLatestDelayError` can wait out all terminal events to make sure errors are reported after. The problem is that if you write `combineLatest(empty(), just())` and `combineLatestDelayError(empty(), just())`, they are no longer behaving the same way.
 =||= /cc @zsxwing 
 =||= Sorry for the delay. Once RC3 is released, I'll look into it and work out the details.
 =||= I've considered many alternatives and can give you a reasonable workaround: apply `cache()` on the source `Observable` which you want to be consumed entirely even if the `combineLatest` cancels its consumer. =||= I spent a considerable amount of time on this and was unable to come up with a reasonable way for changing `combineLatest` inside RxJava. All I can offer is I write you a custom operator that awaits all sources to terminate in some fashion, regardless of having been emitted values or not. =||= ,0
4987,498,Implement the 'Repeat' operator,Hi, this PR implemented the `Repeat` operator #70. Please take a look. Thanks!,[RxJava-pull-requests #422](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/422/) SUCCESS
This pull request looks good
 =||= I believe this stack overflows:

``` java
        Observable.from(1).repeat().toBlockingObservable().forEach(new Action1<Integer>() {

            @Override
            public void call(Integer t1) {

            }});
```

Stacktrace:

```
java.lang.RuntimeException: java.lang.StackOverflowError
    at rx.observables.BlockingObservable.forEach(BlockingObservable.java:159)
    at rx.operators.OperationRepeatTest.main(OperationRepeatTest.java:39)
Caused by: java.lang.StackOverflowError
    at java.util.HashMap$Entry.<init>(HashMap.java:814)
    at java.util.HashMap.createEntry(HashMap.java:901)
    at java.util.HashMap.addEntry(HashMap.java:888)
    at java.util.HashMap.put(HashMap.java:509)
    at rx.subjects.ReplaySubject$SubscriptionFunc.call(ReplaySubject.java:115)
    at rx.subjects.ReplaySubject$SubscriptionFunc.call(ReplaySubject.java:1)
    at rx.subjects.ReplaySubject$DelegateSubscriptionFunc.onSubscribe(ReplaySubject.java:84)
    at rx.Observable.subscribe(Observable.java:224)
    at rx.operators.OperationMulticast$MulticastConnectableObservable$1.onSubscribe(OperationMulticast.java:41)
    at rx.Observable.subscribe(Observable.java:224)
    at rx.operators.OperationObserveOn$ObserveOn.onSubscribe(OperationObserveOn.java:50)
    at rx.Observable.subscribe(Observable.java:224)
    at rx.operators.OperationRepeat$1$1.onCompleted(OperationRepeat.java:82)
    at rx.subjects.ReplaySubject.onCompleted(ReplaySubject.java:141)
    at rx.operators.OperationMulticast$MulticastConnectableObservable$2.onCompleted(OperationMulticast.java:54)
    at rx.operators.OperationToObservableIterable$ToObservableIterable.onSubscribe(OperationToObservableIterable.java:48)
    at rx.Observable.subscribe(Observable.java:224)
    at rx.operators.OperationMulticast$MulticastConnectableObservable.connect(OperationMulticast.java:51)
    at rx.operators.OperationRepeat$1$1.onCompleted(OperationRepeat.java:83)
    at rx.subjects.ReplaySubject.onCompleted(ReplaySubject.java:141)
    at rx.operators.OperationMulticast$MulticastConnectableObservable$2.onCompleted(OperationMulticast.java:54)
    at rx.operators.OperationToObservableIterable$ToObservableIterable.onSubscribe(OperationToObservableIterable.java:48)
    at rx.Observable.subscribe(Observable.java:224)
    at rx.operators.OperationMulticast$MulticastConnectableObservable.connect(OperationMulticast.java:51)
    at rx.operators.OperationRepeat$1$1.onCompleted(OperationRepeat.java:83)
    at rx.subjects.ReplaySubject.onCompleted(ReplaySubject.java:141)
    at rx.operators.OperationMulticast$MulticastConnectableObservable$2.onCompleted(OperationMulticast.java:54)
    at rx.operators.OperationToObservableIterable$ToObservableIterable.onSubscribe(OperationToObservableIterable.java:48)
    at rx.Observable.subscribe(Observable.java:224)
    at rx.operators.OperationMulticast$MulticastConnectableObservable.connect(OperationMulticast.java:51)
    at rx.operators.OperationRepeat$1$1.onCompleted(OperationRepeat.java:83)
    at rx.subjects.ReplaySubject.onCompleted(ReplaySubject.java:141)
    at rx.operators.OperationMulticast$MulticastConnectableObservable$2.onCompleted(OperationMulticast.java:54)
    at rx.operators.OperationToObservableIterable$ToObservableIterable.onSubscribe(OperationToObservableIterable.java:48)
    at rx.Observable.subscribe(Observable.java:224)
    at rx.operators.OperationMulticast$MulticastConnectableObservable.connect(OperationMulticast.java:51)
    at rx.operators.OperationRepeat$1$1.onCompleted(OperationRepeat.java:83)
    at rx.subjects.ReplaySubject.onCompleted(ReplaySubject.java:141)
    at rx.operators.OperationMulticast$MulticastConnectableObservable$2.onCompleted(OperationMulticast.java:54)
    at rx.operators.OperationToObservableIterable$ToObservableIterable.onSubscribe(OperationToObservableIterable.java:48)
    at rx.Observable.subscribe(Observable.java:224)
... etc
```

If `Subscriptions` has not been touched before the StackOverflow you will instead see this:

```
java.lang.NoClassDefFoundError: Could not initialize class rx.subscriptions.Subscriptions
    at rx.Observable.subscribe(Observable.java:254)
    at rx.observables.BlockingObservable.protectivelyWrapAndSubscribe(BlockingObservable.java:93)
    at rx.observables.BlockingObservable.forEach(BlockingObservable.java:121)
    at rx.operators.OperationRepeatTest.main(OperationRepeatTest.java:39)
```

We need to use the recursive scheduler idiom to implement repeat.
 =||= Small detail: in some places, you should replace "The number of times to repeat the element" by "The number of times to repeat the source sequence".
 =||= Is there a reason the repeat() uses an external Scheduler and the ReplaySubject? How about a simpler approach:

``` java
    public static <T> OnSubscribeFunc<T> repeat(final Observable<T> source, final int count) {
        return new OnSubscribeFunc<T>() {
            @Override
            public Subscription onSubscribe(final Observer<? super T> t1) {
                final SerialSubscription sreg = new SerialSubscription();
                final Observable<T> ssource = source.subscribeOn(Schedulers.currentThread());
                Observer<T> o = new Observer<T>() {
                    int remaining = count;
                    @Override
                    public void onNext(T args) {
                        t1.onNext(args);
                    }
                    @Override
                    public void onError(Throwable e) {
                        try {
                            t1.onError(e);
                        } finally {
                            sreg.unsubscribe();
                        }
                    }
                    @Override
                    public void onCompleted() {
                        if (remaining-- > 0) {
                            sreg.setSubscription(ssource.subscribe(this));
                        } else {
                            t1.onCompleted();
                            sreg.unsubscribe();
                        }
                    }
                };
                sreg.setSubscription(ssource.subscribe(o));
                return sreg;
            }
        };
    }
```
 =||= @benjchristensen I think using Schedulers.immediate() causes the stack overflow problem. Here is a test in C#:

``` c#
        static void Main(string[] args)
        {
            IObservable<int> obs = Observable.Create<int>(o => new Foo(o).test(Scheduler.Immediate, 0));
            obs.Subscribe(
                x => Console.WriteLine("OnNext: " + x)
                );
            Console.ReadLine();
        }

        class Foo
        {
            IObserver<int> _o;

            public Foo(IObserver<int> o)
            {
                _o = o;
            }

            public IDisposable test(IScheduler s, int i)
            {
               return s.Schedule(i + 1,  (scheduler, x) => {
                    _o.OnNext(x);
                    return this.test(scheduler, x);
                });
            }
        }
```

This code does not cause a stack overflow exception.

But in RxJava, the following unit test will cause a stack overflow exception:

``` java
    @Test
    public void testRecursiveScheduler1() {
        Observable<Integer> obs = Observable
                .create(new OnSubscribeFunc<Integer>() {
                    @Override
                    public Subscription onSubscribe(
                            final Observer<? super Integer> observer) {
                        return Schedulers.immediate().schedule(0,
                                new Func2<Scheduler, Integer, Subscription>() {
                                    @Override
                                    public Subscription call(
                                            Scheduler scheduler, Integer i) {
                                        observer.onNext(i);
                                        return scheduler.schedule(i + 1, this);
                                    }
                                });
                    }
                });

        obs.subscribe(new Observer<Integer>() {

            @Override
            public void onCompleted() {
            }

            @Override
            public void onError(Throwable e) {
                e.printStackTrace();
            }

            @Override
            public void onNext(Integer args) {
                System.out.println(args);
            }
        });
    }
```

I'm trying to understand the ImmediateScheduler in Rx.Net. Seems that it also uses a queue to save the Actions to avoid the stack overflow exception.
http://rx.codeplex.com/SourceControl/latest#Rx.NET/Source/System.Reactive.Core/Reactive/Concurrency/ImmediateScheduler.cs
http://rx.codeplex.com/SourceControl/latest#Rx.NET/Source/System.Reactive.Core/Reactive/Concurrency/LocalScheduler.TimerQueue.cs
 =||= [RxJava-pull-requests #444](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/444/) FAILURE
Looks like there's a problem with this pull request
 =||= [RxJava-pull-requests #445](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/445/) FAILURE
Looks like there's a problem with this pull request
 =||= [RxJava-pull-requests #446](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/446/) SUCCESS
This pull request looks good
 =||= The current implementation still has some problems which can not be simply handled in `OperationRepeat`. 

If using ImmediateScheduler in `repeat` operator, there may be a stack overflow exception mentioned above. 

If using CurrentThreadScheduler, the following test will not stop. I suppose it should stop when the observer has some error.

``` java
    @Test
    public void testRepeatWithInfiniteRepeatCountWithCurrentThread() {
        Observable<String> observable = repeat("foo", Schedulers.currentThread());

        @SuppressWarnings("unchecked")
        Observer<String> observer = (Observer<String>) mock(Observer.class);

        doAnswer(new Answer<Void>() {
            private int count = 0;

            @Override
            public Void answer(InvocationOnMock invocation) throws Throwable {
                count++;
                if (count == 100) {
                    // Only verify if repeating 100 times
                    // We can not really verify if repeating infinitely.
                    throw new RuntimeException("some error");
                }
                return null;
            }
        }).when(observer).onNext(anyString());

        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(100)).onNext("foo");
        inOrder.verify(observer).onError(isA(RuntimeException.class));
        inOrder.verifyNoMoreInteractions();
    }
```
 =||= - You should use the current thread scheduler (which is what C# does), see my pull request.
- I don't think we need an overload with count, just as easy to do a take(n) afterwards.
- There is an issue with toblocking observable where it does not terminate that does not appear in .toeneumerable() in .NET
 =||= > You should use the current thread scheduler (which is what C# does), see my pull request.

Agree. But now as the current thread has some issue, I use ImmediateScheduler to pass the unit test.

> I don't think we need an overload with count, just as easy to do a take(n) afterwards.

Could you give me an example? How can we know the `n` to use in `take` when the observable size is unknown.

> There is an issue with toblocking observable where it does not terminate that does not appear in .toeneumerable() in .NET

I suppose my problem it's about SafeObservableSubscription and SafeObserver. But maybe we are talking about the same issue since SafeObservableSubscription and SafeObserver are used in toBlockingObservable, too.
 =||= This hangs in Rx.NET as well (2.1.30214.0)

``` c#
Observable.Return(1).Repeat().Take(100).Subscribe(Console.WriteLine);
```

The issue is in the `Repeat.subscribe()` not returning until the (infinite) re-subscription finishes, so there is no way the Take method can signal its uplink to terminate as it hasn't yet received a reference to it. However, this works:

``` c#
Observable.Return(1, Scheduler.Default).Repeat().Take(100).Subscribe(Console.WriteLine);
```

as now the Repeat.onCompleted can run in another thread and the Repeat.subscribe() can return.

I believe this can be achieved by not subscribing to the raw source in the Repeat.subscribe() but rather using subscribeOn(Schedulers.newThread()) to move the subscription into a parallel thread and let the Repeat.subscribe() return.

``` java
public static <T> OnSubscribeFunc<T> repeat(final Observable<T> source, final int count) {
    return new OnSubscribeFunc<T>() {
        @Override
        public Subscription onSubscribe(final Observer<? super T> t1) {
            final SerialSubscription sreg = new SerialSubscription();
            final Observable<T> ssource = source.subscribeOn(Schedulers.newThread());
            Observer<T> o = new Observer<T>() {
                int remaining = count;
                @Override
                public void onNext(T args) {
                    t1.onNext(args);
                }
                @Override
                public void onError(Throwable e) {
                    try {
                        t1.onError(e);
                    } finally {
                        sreg.unsubscribe();
                    }
                }
                @Override
                public void onCompleted() {
                    if (remaining-- > 0) {
                        sreg.setSubscription(ssource.subscribe(this));
                    } else {
                        t1.onCompleted();
                        sreg.unsubscribe();
                    }
                }
            };
            sreg.setSubscription(ssource.subscribe(o));
            return sreg;
        }
    };
}
```
 =||= > I believe this can be achieved by not subscribing to the raw source in the Repeat.subscribe() but rather using subscribeOn(Schedulers.newThread()) to move the subscription into a parallel thread and let the Repeat.subscribe() return.

Thanks, you remind me one thing: There is not an `repeat` overload with Observable and Scheduler together in Rx.Net. When I tried to implement the `repeat` overload, I was wondering why there was not a such overload. Maybe this is because `repeat` can not be used with all of Schedulers. However, even if we do not provide such overload, users still can use Schedulers by `observeOn`. For example, `Observable.from(1).repeat().take(100).observeOn().(Schedulers.CurrentThread);`.

So is it OK that we do not provide this kind of method and warn that `should not use repeat with Schedulers.CurrentThread() or Schedulers.immediate()` in the document?
 =||= I think Rx.Net started out its Return operator to run on the threadpool. If manually put back there, the example works. Nowadays it runs on the immediate scheduler, causing the problem. Even if you warn the user about the scheduler, there is no way to know if an incoming observable is dangerous or not. This affects other operators such as concat and onerrorresume.
 =||= Return always used the immediate scheduler :-)
 =||= Same stack overflow issue happens in `interval`.

``` java
    @Test
    public void testIntervalWithImmediateScheduler() {
        Observable.interval(1, TimeUnit.MILLISECONDS, Schedulers.immediate())
                .subscribe(new Observer<Long>() {

                    @Override
                    public void onCompleted() {
                        System.out.println("onCompleted");
                    }

                    @Override
                    public void onError(Throwable e) {
                        e.printStackTrace();
                    }

                    @Override
                    public void onNext(Long args) {
                        System.out.println(args);
                    }
                });
    }
```
 =||= CurrentThreadScheduler can work with `interval` because `interval` does not use SafeObservableSubscription and SafeObserver.
 =||= I am working with @headinthebox on changes to Schedulers including `Interval` and will come back to this and https://github.com/Netflix/RxJava/pull/518 when ready.
 =||= Completed in https://github.com/Netflix/RxJava/pull/699
 =||= ,0
5002,4993,2.x: Should schedulers have RxThreadFactory constructor parameters?,RxJava 1 allowed for specifying a custom thread factory, but it looks like this feature did not make it to RxJava 2. Was this intentional or something that a PR would be welcome for?,Which scheduler? Computation? It was intentional. You can now configure the priority of each scheduler so there was little benefit from a customizing the factory. Use the [ParallelScheduler](https://github.com/akarnokd/RxJava2Extensions#parallelscheduler) from extensions which allows more [customization](https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/schedulers/ParallelScheduler.java#L87).

 =||= We used it for the IO scheduler as well. It was useful for tracking our own thread naming and setting their priority to android-specific priorities. We'd like to use it for that and SingleScheduler. Can ParallelScheduler be used as a substitute for non-computation schedulers too? =||= Since scheduler implementations are internal, it is not recommended anyway to use them directly.

ParallelScheduler is an individual scheduler with a specified number of threads that doesn't change over time. So unlike io(), ParallelScheduler won't stop its threads when they become idle for too long. =||= > Since scheduler implementations are internal, it is not recommended anyway to use them directly.

I'm not sure I follow. As in we shouldn't create a new IoScheduler instance? =||= Prior discussions/work for reference - #3724 #3879 =||= Anything in the `io.reactivex.internal.*` is considered private and not part of any binary or API compatibility contracts. =||= So either use `Schedulers.from(Executor)` with your own pool or copy the internal code and change it locally. =||= I missed that they were internal now. That's disappointing to see, and seems like a bit of a step backward compared to RxJava 1. We'll just copy then :| =||= They're internal in 1.x too. The only remnants are public for binary
compatibility that no one should be using anyway. Are you referring to the
factory methods? Those could easily be replicated on 2.x.

On Fri, Jan 13, 2017, 4:22 AM Zac Sweers <notifications@github.com> wrote:

> I missed that they were internal now. That's disappointing to see, and
> seems like a bit of a step backward compared to RxJava 1. We'll just copy
> then :|
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/4993#issuecomment-272431211>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEERdKOOoaZajpQio5Pgsyac0sCa0Lks5rR2x0gaJpZM4LiyuF>
> .
>
 =||= Yeah I was referring to the factory methods. Basically wanted to do the same thing you added in the linked PR above =||= > Those could easily be replicated on 2.x.

@akarnokd any thoughts on this? This is what I was thinking of in opening this issue, in case I wasn't clear before =||= They will be still internal classes. However, we could expose them, for example, `Schedulers.newComputation()`, `Schedulers.newIO()` etc where extra parameters can be passed in, similar to how Project Reactor's schedulers were exposed. =||= That sounds reasonable to me.[ The APIs they expose cover pretty much everything we'd want](https://github.com/reactor/reactor-core/blob/master/src/main/java/reactor/core/scheduler/Schedulers.java), would be happy to make a PR matching those if you're up for it. =||= Sure. =||= ,0
5005,5004,2.0.4: an infinite disposable,
This fails:

    @Test
    public void directScheduleOnSingleThreadExecutor() {
        Scheduler scheduler = Schedulers.from(Executors.newSingleThreadExecutor());

        Disposable disposable = scheduler.scheduleDirect(() -> {
        });

        long start = nanoTime();
        while (!disposable.isDisposed()) {
            assertTrue(nanoTime() - start < SECONDS.toNanos(10));
        }
    }

while replacing `from(...)` with `io()` works

I can't find where the error exactly is, my debugger can't jump in to the right source code line.,Yes, the internal `ExecutorScheduler.BooleanDisposable` doesn't set its state to disposed after the task has run.

How much problem is it for you? 

(Sidenote: It is generally not recommended to spin on `isDisposed()` because that nullifies the reason RxJava exists: not blocking on `Future.get()` or spinning on `Future.isDone()`.) =||= The bug it was causing is that when user scrolls messages up, I wanted paging to run if it is not already running. After the transition to RxJava 2 I started to use this new `scheduleDirect` method. The first paging iteration worked as expected, but after that it just hangs up without any signs of living.

This is my current workaround:

    public static Disposable scheduleDirect(Scheduler scheduler, Runnable runnable) {
        Scheduler.Worker worker = scheduler.createWorker();
        worker.schedule(() -> {
            try {
                runnable.run();
            } finally {
                worker.dispose();
            }
        });
        return worker;
    }

 =||= (As a sidenote: some real-world tasks DO require blocking operations or running of tasks depending on other tasks state.) =||= Okay, for consistency with other Schedulers, I'll post a fix for this. =||= Cool! :) =||= Closing via #5005. =||= ,0
5007,495,Zip many rewritten, Concat with iterable, Merge with Iterable.,I've rewritten the Zip method to terminate as soon as possible. In addition, the concat(Iterable<Observable<T>> and merge(Iterable<Observable<T>>) where missing from Observable.,[RxJava-pull-requests #418](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/418/) SUCCESS
This pull request looks good
 =||= @akarnokd Thank you for this. I'm checking out the branch now to play with it and see how the problematic unit tests behave.

Would you mind re-submitting the pull request though after rebasing this onto a new branch so we don't have all the commit clutter resulting from you working on your master branch? The commit "Merge origin/master" https://github.com/akarnokd/RxJava/commit/0dcbe89f291f3a77f8bbbd5cefd745a12600c40e and commits before that are a result of merging /Netflix/RxJava master into your master then submitting back from the same branch. It is preferable to always commit only to a clean branch and submit a pull request from that so only the relevant commits are applied. The only time anything should commit to your forked master is when fetching from the upstream to sync back up.

Thanks!
 =||= I want to confirm a unit test for this code. @headinthebox can you please validate something? 

The following unit test shows how this will correctly complete once the first stream completes. However, it still waits until ALL items are emitted before the `onCompleted` is sent. I want to ensure that's how it should behave as opposed to skipping those and completing as soon as onComplete is sent (like onError should).

``` java
    @Test
    public void testOnFirstCompletion() {
        PublishSubject<String> oA = PublishSubject.create();
        PublishSubject<String> oB = PublishSubject.create();

        @SuppressWarnings("unchecked")
        Observer<String> observer = mock(Observer.class);

        Observable<String> o = Observable.create(zip(oA, oB, getConcat2Strings()));
        o.subscribe(observer);

        InOrder inOrder = inOrder(observer);

        oA.onNext("a1");
        inOrder.verify(observer, never()).onNext(anyString());
        oB.onNext("b1");
        inOrder.verify(observer, times(1)).onNext("a1-b1");
        oB.onNext("b2");
        inOrder.verify(observer, never()).onNext(anyString());
        oA.onNext("a2");
        inOrder.verify(observer, times(1)).onNext("a2-b2");

        oA.onNext("a3");
        oA.onNext("a4");
        oA.onNext("a5");
        oA.onCompleted();

        // SHOULD ONCOMPLETE BE EMITTED HERE INSTEAD OF WAITING
       // FOR B3, B4, B5 TO BE EMITTED?

        oB.onNext("b3");
        oB.onNext("b4");
        oB.onNext("b5");

        inOrder.verify(observer, times(1)).onNext("a3-b3");
        inOrder.verify(observer, times(1)).onNext("a4-b4");
        inOrder.verify(observer, times(1)).onNext("a5-b5");

        // WE RECEIVE THE ONCOMPLETE HERE
        inOrder.verify(observer, times(1)).onCompleted();

        oB.onNext("b6");
        oB.onNext("b7");
        oB.onNext("b8");
        oB.onNext("b9");
        // never completes (infinite stream for example)

        // we should receive nothing else despite oB continuing after oA completed
        inOrder.verifyNoMoreInteractions();
    }

    private Func2<String, String, String> getConcat2Strings() {
        return new Func2<String, String, String>() {

            @Override
            public String call(String t1, String t2) {
                return t1 + "-" + t2;
            }
        };
    }
```
 =||= This confirms the `onError` event is propagated immediately:

``` java
@Test
    public void testOnErrorTermination() {
        PublishSubject<String> oA = PublishSubject.create();
        PublishSubject<String> oB = PublishSubject.create();

        @SuppressWarnings("unchecked")
        Observer<String> observer = mock(Observer.class);

        Observable<String> o = Observable.create(zip(oA, oB, getConcat2Strings()));
        o.subscribe(observer);

        InOrder inOrder = inOrder(observer);

        oA.onNext("a1");
        inOrder.verify(observer, never()).onNext(anyString());
        oB.onNext("b1");
        inOrder.verify(observer, times(1)).onNext("a1-b1");
        oB.onNext("b2");
        inOrder.verify(observer, never()).onNext(anyString());
        oA.onNext("a2");
        inOrder.verify(observer, times(1)).onNext("a2-b2");

        oA.onNext("a3");
        oA.onNext("a4");
        oA.onNext("a5");
        oA.onError(new RuntimeException("forced failure"));

        // it should emit failure immediately
        inOrder.verify(observer, times(1)).onError(any(RuntimeException.class));

        oB.onNext("b3");
        oB.onNext("b4");
        oB.onNext("b5");
        oB.onNext("b6");
        oB.onNext("b7");
        oB.onNext("b8");
        oB.onNext("b9");
        // never completes (infinite stream for example)

        // we should receive nothing else despite oB continuing after oA completed
        inOrder.verifyNoMoreInteractions();
    }
```
 =||= Sorry for the clutter, I'm new to Git in this manner. Will do a new pull shortly.
 =||= > Sorry for the clutter, I'm new to Git in this manner. Will do a new pull shortly.

Not a problem, the Git flow for pull requests is not obvious when first starting. I totally messed up a few repos when I first started, had to wipe them out and start fresh with clean forks until I got the hang of it :-)
 =||= Closing as replaced by https://github.com/Netflix/RxJava/pull/497
 =||= ,0
5015,4813,reactive-streams should be scoped as compile dependency,Something is wrong in the build process that produces the released pom.xml. The pom.xml for 2.0.0 has 

```xml
<dependency>
    <groupId>org.reactivestreams</groupId>
    <artifactId>reactive-streams</artifactId>
    <version>1.0.0</version>
    <scope>runtime</scope>
</dependency>
```

Scope for this dependency should be `compile`.  As it stands maven builds of projects that use RxJava 2 will fail with compile errors. The workaround for anyone encountering this error is to add the `reactive-streams` dependency explicitly (scoped `compile`) above the `rxjava` dependency.,Found [this](https://discuss.gradle.org/t/maven-publish-plugin-generated-pom-making-dependency-scope-runtime/7494/14).
 =||= See #5015. It works locally for me:

![image](https://cloud.githubusercontent.com/assets/1269832/22243465/bdf6ac8e-e227-11e6-8b3f-c7d8f1abf4b9.png)
 =||= https://oss.jfrog.org/libs-snapshot/io/reactivex/rxjava2/rxjava/2.0.0-DP0-SNAPSHOT/rxjava-2.0.0-DP0-20170124.111838-392.pom

Closing via #5015 =||= ,0
5027,5024,Question about interrupted threads in RxJava2,hi,
i have a question that's similar to #4863, but a bit simpler. i am running into a strange issue that i have been able to simplify to a simple test case - what’s happening is, sometimes, by the time my most downstream method is called, the thread is interrupted (which causes issues because the code i call there bails if the thread is interrupted).

i've been able to simplify the code and repro using this:

```java
  private Single<ArrayList<Integer>> fakeDataPiece() {
    return Single.fromCallable(() -> {
      Thread.sleep(500);
      return new ArrayList<Integer>();
    }).subscribeOn(Schedulers.io());
  }

  private Single<BookmarkData> fakeGetData() {
    return Single.zip(fakeDataPiece(), fakeDataPiece(), fakeDataPiece(),
        (integers, integers2, integers3) ->
            new BookmarkData(new ArrayList<>(), new ArrayList<>(), new ArrayList<>()))
        .subscribeOn(Schedulers.io());
  }

  public Single<Uri> exportBookmarksObservable() {
        return fakeGetData()
        .flatMap(bookmarkData -> Single.just(exportBookmarks(bookmarkData)))
        .subscribeOn(Schedulers.io());
  }
```

by the time `exportBookmarks` is called, in many cases, `Thread.currentThread().isInterrupted()` returns `true`.

my question is: why is the thread interrupted? (i am curious as to whether this is expected or if there is something i am misunderstanding or doing wrong).

observations:
1. if i explicitly remove all the `subscribeOn`s except for the one in `exportBookmarksObservable`, then i don’t see the issue (though it does change the behavior a bit in the sense that, with this, all workers are run on the same thread as opposed to each piece of work happening on a potentially different thread).
2. if i add a `doOnSuccess` in `fakeGetData()`, i find the thread is interrupted (and is the same thread that `exportBookmarks` gets called on, while also being interrupted). this also is the same as one of the `fakeDataPiece` threads, which, at the time of its completion, is not interrupted.
3. calling `Thread.interrupted()` as suggested in #4863 also fixes the problem.

i am using RxJava 2.0.4 - thanks!,Could you create a self contained unit test (in a gist)? Or you could apply doOnDisposed() everywhere to see if the problem is due to internal disposing. =||= here is a self contained unit test that fails:
https://gist.github.com/ahmedre/b7267d020b284faa5552c090b79707ad

with respect to `doOnDisposed`, i find that only the first 3 parameters to `zip` get `doOnDisposed` called, with the same thread for all 3, and with `isInterrupted()` set to true for the second and third parameters. =||= Could you post the stacktrace at those doOnDispose placed to see what is calling through them. =||= sure:

```
fakeDataPiece: Thread[RxCachedThreadScheduler-2,5,main], false
java.lang.Thread.getStackTrace(Thread.java:1556)
com.quran.labs.androidquran.model.bookmark.ContrivedTest.lambda$fakeDataPiece$1(ContrivedTest.java:15)
io.reactivex.internal.operators.single.SingleDoOnDispose$DoOnDisposeObserver.dispose(SingleDoOnDispose.java:60)
io.reactivex.internal.operators.single.SingleToFlowable$SingleToFlowableObserver.cancel(SingleToFlowable.java:74)
io.reactivex.internal.subscriptions.SubscriptionHelper.cancel(SubscriptionHelper.java:188)
io.reactivex.internal.operators.flowable.FlowableZip$ZipSubscriber.cancel(FlowableZip.java:404)
io.reactivex.internal.operators.flowable.FlowableZip$ZipCoordinator.cancelAll(FlowableZip.java:161)
io.reactivex.internal.operators.flowable.FlowableZip$ZipCoordinator.drain(FlowableZip.java:208)
io.reactivex.internal.operators.flowable.FlowableZip$ZipSubscriber.onNext(FlowableZip.java:388)
io.reactivex.internal.subscriptions.DeferredScalarSubscription.complete(DeferredScalarSubscription.java:117)
io.reactivex.internal.operators.single.SingleToFlowable$SingleToFlowableObserver.onSuccess(SingleToFlowable.java:63)
io.reactivex.internal.operators.single.SingleDoOnDispose$DoOnDisposeObserver.onSuccess(SingleDoOnDispose.java:84)
io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.onSuccess(SingleSubscribeOn.java:68)
io.reactivex.internal.operators.single.SingleFromCallable.subscribeActual(SingleFromCallable.java:37)
io.reactivex.Single.subscribe(Single.java:2656)
io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.run(SingleSubscribeOn.java:89)
io.reactivex.Scheduler$1.run(Scheduler.java:134)
io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)
io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)
java.util.concurrent.FutureTask.run(FutureTask.java:266)
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
java.lang.Thread.run(Thread.java:745)

fakeDataPiece: Thread[RxCachedThreadScheduler-2,5,main], true
java.lang.Thread.getStackTrace(Thread.java:1556)
com.quran.labs.androidquran.model.bookmark.ContrivedTest.lambda$fakeDataPiece$1(ContrivedTest.java:15)
io.reactivex.internal.operators.single.SingleDoOnDispose$DoOnDisposeObserver.dispose(SingleDoOnDispose.java:60)
io.reactivex.internal.operators.single.SingleToFlowable$SingleToFlowableObserver.cancel(SingleToFlowable.java:74)
io.reactivex.internal.subscriptions.SubscriptionHelper.cancel(SubscriptionHelper.java:188)
io.reactivex.internal.operators.flowable.FlowableZip$ZipSubscriber.cancel(FlowableZip.java:404)
io.reactivex.internal.operators.flowable.FlowableZip$ZipCoordinator.cancelAll(FlowableZip.java:161)
io.reactivex.internal.operators.flowable.FlowableZip$ZipCoordinator.drain(FlowableZip.java:208)
io.reactivex.internal.operators.flowable.FlowableZip$ZipSubscriber.onNext(FlowableZip.java:388)
io.reactivex.internal.subscriptions.DeferredScalarSubscription.complete(DeferredScalarSubscription.java:117)
io.reactivex.internal.operators.single.SingleToFlowable$SingleToFlowableObserver.onSuccess(SingleToFlowable.java:63)
io.reactivex.internal.operators.single.SingleDoOnDispose$DoOnDisposeObserver.onSuccess(SingleDoOnDispose.java:84)
io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.onSuccess(SingleSubscribeOn.java:68)
io.reactivex.internal.operators.single.SingleFromCallable.subscribeActual(SingleFromCallable.java:37)
io.reactivex.Single.subscribe(Single.java:2656)
io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.run(SingleSubscribeOn.java:89)
io.reactivex.Scheduler$1.run(Scheduler.java:134)
io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)
io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)
java.util.concurrent.FutureTask.run(FutureTask.java:266)
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
java.lang.Thread.run(Thread.java:745)

fakeDataPiece: Thread[RxCachedThreadScheduler-2,5,main], true
java.lang.Thread.getStackTrace(Thread.java:1556)
com.quran.labs.androidquran.model.bookmark.ContrivedTest.lambda$fakeDataPiece$1(ContrivedTest.java:15)
io.reactivex.internal.operators.single.SingleDoOnDispose$DoOnDisposeObserver.dispose(SingleDoOnDispose.java:60)
io.reactivex.internal.operators.single.SingleToFlowable$SingleToFlowableObserver.cancel(SingleToFlowable.java:74)
io.reactivex.internal.subscriptions.SubscriptionHelper.cancel(SubscriptionHelper.java:188)
io.reactivex.internal.operators.flowable.FlowableZip$ZipSubscriber.cancel(FlowableZip.java:404)
io.reactivex.internal.operators.flowable.FlowableZip$ZipCoordinator.cancelAll(FlowableZip.java:161)
io.reactivex.internal.operators.flowable.FlowableZip$ZipCoordinator.drain(FlowableZip.java:208)
io.reactivex.internal.operators.flowable.FlowableZip$ZipSubscriber.onNext(FlowableZip.java:388)
io.reactivex.internal.subscriptions.DeferredScalarSubscription.complete(DeferredScalarSubscription.java:117)
io.reactivex.internal.operators.single.SingleToFlowable$SingleToFlowableObserver.onSuccess(SingleToFlowable.java:63)
io.reactivex.internal.operators.single.SingleDoOnDispose$DoOnDisposeObserver.onSuccess(SingleDoOnDispose.java:84)
io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.onSuccess(SingleSubscribeOn.java:68)
io.reactivex.internal.operators.single.SingleFromCallable.subscribeActual(SingleFromCallable.java:37)
io.reactivex.Single.subscribe(Single.java:2656)
io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.run(SingleSubscribeOn.java:89)
io.reactivex.Scheduler$1.run(Scheduler.java:134)
io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)
io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)
java.util.concurrent.FutureTask.run(FutureTask.java:266)
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
java.lang.Thread.run(Thread.java:745)
``` =||= Thanks, I see the problem now: `Single.zip` delegates to `Flowable.zip` which cancels when a source completes before the others complete.

This has to be fixed on the operator level so I can't give you any workaround other than the clearing of the interrupted flag or a custom operator that suppresses cancellation if it comes after an onsuccess. =||= Closing via #5027. =||= thanks! =||= ,0
5030,5029,GroupBy with flatMap and observeOn does not seem to support backpressure in 1.2.x,There are a plenty of issues fixing some sorts of backpressure problems in groupBy (e.g. #3428, #3425).
But nevertheless when I try the following code it requests all 10000 values from the source at once without waiting for processing of single items (example running with rxjava 1.2.x):

```
import rx.Observable;
import rx.schedulers.Schedulers;

import java.util.Random;

import static rx.Observable.range;

public class GroupByTest {
    public static void main(String[] args) throws Exception {
        Observable<Integer> source = range(1, 10000);
        source
                .doOnNext(i -> System.out.println("Requested " + i))
                .groupBy(v -> v % 5)
                .flatMap(g -> g.observeOn(Schedulers.io()).map(GroupByTest::calculation))
                .subscribe(i -> System.out.println("Got " + i));
        Thread.sleep(100000);
    }

    private static Integer calculation(Integer i) {
        sleep();
        System.out.println("Processing " + i);
        return i * 20;
    }

    private static void sleep() {
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

When running the code I see 10000 "Requested X" messages getting printed immediately and afterwards messages "Processing X" coming after some timeout.
With this behavior it does not seem to be possible to parallelize processing of single groups in rxjava  in any useful way when working with large or unlimited sources.,It does work correctly with rxjava 2.x Flowable. =||= For historical reasons, `flatMap` in 1.x requests an unbounded amount of source elements for its 1 argument overload. There is another overload that takes a `maxConcurrent` parameter with which you can limit the number of active inner sources. =||= I know ;). But it does not work either :(. If I add maxConcurrent (1 or 2 or 3 etc.) to flatMap after groupBy the behavior stays the same - all 10000 items are requested at once.

```
    public static void main(String[] args) throws Exception {
        Observable<Integer> source = range(1, 10000);
        source
                .doOnNext(i -> System.out.println("Requested " + i))
                .groupBy(v -> v % 5)
                .flatMap(g -> g.observeOn(Schedulers.io()).map(GroupByTest::calculation), 4) // <---- maxConcurrent
                .subscribe(i -> System.out.println("Got " + i));
        Thread.sleep(100000);
    }
``` =||= In RxJava 1.x there is OperatorGroupByTest which tests some backpressure scenarios.
If I adjust https://github.com/ReactiveX/RxJava/blob/1.x/src/test/java/rx/internal/operators/OperatorGroupByTest.java#L1027 by putting `doOnNext` with `System.out.println` I observe the same behavior as I described above - all items are requested at once.
So OperatorGroupByTest#testGroupByBackpressure does not test any backpressure ;). =||= OperatorGroupBy L247 keeps requesting from upstream and thus consumes it in an unbounded manner. Would you like to work out a fix? =||= This is a bug. Fix posted in #5030. =||= Looks good. Your fix seems to work :). 
I tried my examples from above and also tested in a more complex scenario from a customer project (consuming from Kafka, grouping by partition and processing every partition in its own thread).
Is any action required from my side? =||= Thanks for verifying the fix. No further action is necessary of you. There are a few pending contributions targeting 1.x but I'll try to release 1.2.6 next Friday. =||= Closing via #5030 =||= ,0
5047,5044,Declare subscription order for amb and ambWith in documentation.,`amb()` should declare that it subscribes to the supplied observables in the order of the iterable/array. `ambWith()` should declare that it subscribes to the host observable before the supplied 'other' observable.

This allows consumers to explicitly rely on this ordering and a deviation from it to be a bug.,I can send a PR for this, I just wanted to make sure that the subscription order is something that we want to put into the public API. In theory a perfectly acceptable implementation of `ambWith` _could_ be `amb(other, this)` (but that'd be bad!). =||= This ordered subscribe is implied, what makes you want this to be explicitly defined? =||= We have code whose behavior depends on it. It basically does
behaviorSubject.ambWith(just(sentinel)) to ensure a value is always
synchronously emitted downstream upon subscribe. Would the subscription
order of this (or amb) change we'd never see the subject value when it was
set.

On Thu, Feb 2, 2017, 2:09 AM David Karnok <notifications@github.com> wrote:

> This ordered subscribe is implied, what makes you want this to be
> explicitly defined?
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/5044#issuecomment-276884321>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEUw5FvFu5gBiUnAD-ccvupBhhRa3ks5rYYEPgaJpZM4L0m_L>
> .
>
 =||= This looks like you need `BehaviorSubject.createDefault(sentinel)` (or `create(sentinel)` to make sure you have something to start with when subscribing.

Generally, I don't think such ordering guarantee should explicitly be declared on `amb`. =||= That was a contrived example so your suggestion won't work in practice. I
see no reason to omit ordering guarantees around subscription since the
behavior in the synchronous case relies on it. Also it would be completely
illogical to have any ordering but the obvious one that already exists, so
this really isn't a commitment of any challenge.

On Thu, Feb 2, 2017, 10:07 AM David Karnok <notifications@github.com> wrote:

> This looks like you need BehaviorSubject.createDefault(sentinel) (or
> create(sentinel) to make sure you have something to start with when
> subscribing.
>
> Generally, I don't think such ordering guarantee should explicitly be
> declared on amb.
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/5044#issuecomment-276982685>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEVpKoznqc6RXSatXInM85GgnfPHkks5rYfFEgaJpZM4L0m_L>
> .
>
 =||= Okay then, but don't forget to add unit tests that verify the order is actually held by the implementation (in case of another complete rewrite for 3.x). 5 base types x 3 `amb` types == 15 tests. =||= Essentially, docs should (more) explicitly state that:

`assertThat(amb(just(1), just(2)).toBlocking().single()).isEqualTo(1);` =||= Closing via #5047. =||= ,0
5049,5045,2.x: RxJavaPlugin.get/setXXX generics?,For unit tests I frequently bump into the restrictiveness of 

```java
RxJavaPlugins.setErrorHandler(Consumer<Throwable> handler);
```

I would like the signature to be 

```java
RxJavaPlugins.setErrorHandler(Consumer<? super Throwable> handler);
```

There are many more methods in `RxJavaPlugins` that could support lower and upper bounded wildcards. Can I make these changes?,setErrorHandler: yes, others would bring trouble I think. =||= I gave it a shot: https://github.com/ReactiveX/RxJava/pull/5058
Widening the generics seems to work so far

But of course I don't know about any side effects, possible problems. =||= ,0
5051,4876,2.x: Add @NonNull annotation for Function/Predicate/etc.,One of the larger tasks when transitioning from 1 to 2 is removing the use of null. Right now there's no automated way to do it, but if we had `@NonNull` then we'd be able to use static analysis to find where we're returning null when we shouldn't be.

I'm not sure the best way to go about it - if we should include jsr305, use Java 8's NonNull, create our own, or something else.,We can't do external dependencies like jsr305 and I can't find `@NonNull` or `@NotNull` in Java 8's public API. We could introduce our own if your tools support custom annotations for this purpose. =||= It looks like Java 8 doesn't actually include it - it's part of a checker framework. More details [here](https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type).

Regardless, I'm specifically targeting IntelliJ's "Constant Conditions & Expressions" inspection and it looks like you can tell IntelliJ about which annotations should be considered non-null / nullable. So it would work if RxJava had its own `@NonNull` annotation included with the library (as long as developers are willing to do a little configuration on their end to accept it).

The only downside to not using jsr305 is that we can't use something like `@ParametersAreNonnullByDefault` which would be less verbose.

If people are on board with this, I could start implementing this (but it's a lot of busywork so I don't want to bother unless people want it). =||= Looks like there is an interest for new annotations, #4878, so it this has to be coordinated with that. I'm not sure about adding `@NonNull` to the functional interfaces though as it may add internal noise to RxJava. We could, however, annotate parameters and return types of the base reactive classes. =||= Hmm, I'm most concerned about the functional interfaces, actually. Those are the ones where the app may accidentally crash during execution unexpectedly.

Here's a contrived example:

```java
void main() {
    Observable.just("Dan")
        .map(new Function<String, String>() {
            @Override
            public String apply(String s) throws Exception {
                return usuallyDependableMethod(s);
            }
        })
        .subscribe();
}

String usuallyDependableMethod(String name) {
    return (Math.random() < .95) ? "Hello " + name : null;
}
```

I can imagine a lot of circumstances where coders don't even realize that `usuallyDependableMethod()` could sometimes return null (when it's not such an obvious problem). That's where static analysis would really help out. =||= Another +1 reason for this would be that Kotlin automatically changes variables to Not null as a language feature if they are annotated with `@NonNull` from JSR 305 along with the IntelliJ and Android equivalents. 

https://kotlinlang.org/docs/reference/java-interop.html#nullability-annotations

Therefore, Kotlin users using RxJava would have the benefit of knowing that their values in something like `onNext()` are not null.

@akarnokd Can you give a reason for not being able to pull in JSR 305 or some equivalent? Just curious. =||= Historically, RxJava is kept to a minimum dependency: 0 in v1 and 1 in v2 =||= I agree @dlew - in a larger code base, it's pretty easy to run into issues like this and there's no way to catch them until runtime.

If it's annotated, a handful of static analysis tools and IDEs can leverage this at compile time (even if it's a custom annotation within the library). =||= I have created a pull request with some changes:
https://github.com/ReactiveX/RxJava/pull/5051 =||= Closing via #5051 & #5055. Let us know if further annotations are necessary. =||= I recently had an issue where a null List<T> was accidentally passed into `Observable.fromIterable()`. Unfortunately that bug made it to production, but it would have been caught if the parameters are annotated. 

@akarnokd @dlew I believe it would be worth it add nullability annotations every where `ObjectHelper.requireNonNull(object, message)` is used to guard execution.

This would be a massive change and it will definitely break compilation in some Kotlin code bases, mine included. =||= Recent IntelliJ infers most nullability annotations for me in Java:

![image](https://user-images.githubusercontent.com/1269832/34566623-68b8c250-f15f-11e7-862f-70bd4cbedc05.png)

and in Kotlin but it doesn't post a warning (see [Kotlin](https://stackoverflow.com/a/45691968/61158)):

![image](https://user-images.githubusercontent.com/1269832/34567008-f3a3d994-f160-11e7-80fd-8bd2a75ab057.png)
 =||= Thanks for the quick reply. 

I haven't been able to get IntelliJ to infer nullability annotations. I've put together a [quick example of my problem](https://github.com/tevjef/RxJava/commit/ef33495a5b7885d524af6a6af0163140635d95f8).

The post you linked seems to address the problem of consuming Java types in Kotlin, rather than here where Kotlin types are consumed by Java. RxJava's `io.reactivex.annotations.NonNull` is [compatible](https://github.com/JetBrains/kotlin/blob/master/core/descriptors.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt#L48) with the Kotlin's compiler as such will cause a compiler error if a nullable Kotlin type is passed into a `@NonNull` Java parameter.

I apologize if this level of Kotlin support is outside of the scope of this project. 
 =||= > rather than here where Kotlin types are consumed by Java

I thought writing in Kotlin requires one to explicitly forfeit non-nullness. Have you been using this particular nullable `List` source elsewhere where it being `null` conveys additional information?

> I apologize if this level of Kotlin support is outside of the scope of this project.

We could add the `@NonNull` annotations, but for the sake of any other library out there, I'd also prefer IntelliJ had the same nullness warning in a Kotlin file (officially) that is already available for Java. =||= > Have you been using this particular nullable List source elsewhere where it being null conveys additional information?

The project was recently converted from RxJava 1.x -> 2.x and from Java to Kotlin in a short time span and this bug went unnoticed. As far as I can tell, `null` does not convey additional information in the stream. 

> I thought writing in Kotlin requires one to explicitly forfeit non-nullness. 

It's not necessarily the case if Java types are correctly annotated.
   =||= @akarnokd Is there any reason why return type of `Function` interface is not annotated with `@NonNull`? `BiFunction` and `Function3` - `Function9` return types are annotated with `@NonNull`. Does it break some contract? =||= Nulls that can't end up in a sequence are allowed, for example, in `groupBy` key selector and `distinct` selector. =||= > Nulls that can't end up in a sequence are allowed, for example, in groupBy key selector and distinct selector.

What do you think about creating annotation `@ReturnsNonNull` and annotate all `Function` interface usages where the nullable value is not allowed? Unfortunately, it will require changes in static analysis tools. Another option is to create `NonNullFunction` interface with `@NonNull` return type but imho breaking API to fix this isn't worth it. =||= Java 6 doesn't allow annotating type arguments that way. You'd need to break binary compatibility to introduce all combinations of possible nullness to the interfaces and use sites. =||= ,0
5054,5053,2.x: SpscLinkedArrayQueue#poll returns null,io.reactivex.internal.queue.SpscLinkedArrayQueue#poll returns null

io.reactivex.internal.fuseable.SimpleQueue#poll is not documented or annotated. Therefore I do not know whether returning null is allowed. But I strongly suspect this is not the case.

If SimpleQueue#poll might return null, at least io.reactivex.internal.operators.flowable.FlowableGroupJoin.GroupJoinSubscription#drain needs to be fixed.,SimpleQueue may return null indicating an empty queue.

> If SimpleQueue#poll might return null, at least io.reactivex.internal.operators.flowable.FlowableGroupJoin.GroupJoinSubscription#drain needs to be fixed.

You mean L238? Due to the bi-offer, if the first call to poll is not null the second one is guaranteed to be non null. You have a false positive there. =||= Yes, that is the line. Ok, is a false positive.
I will add some annotations to SimpleQueue to avoid confusion. =||= https://github.com/ReactiveX/RxJava/pull/5054 =||= ,0
5055,4876,2.x: Add @NonNull annotation for Function/Predicate/etc.,One of the larger tasks when transitioning from 1 to 2 is removing the use of null. Right now there's no automated way to do it, but if we had `@NonNull` then we'd be able to use static analysis to find where we're returning null when we shouldn't be.

I'm not sure the best way to go about it - if we should include jsr305, use Java 8's NonNull, create our own, or something else.,We can't do external dependencies like jsr305 and I can't find `@NonNull` or `@NotNull` in Java 8's public API. We could introduce our own if your tools support custom annotations for this purpose. =||= It looks like Java 8 doesn't actually include it - it's part of a checker framework. More details [here](https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type).

Regardless, I'm specifically targeting IntelliJ's "Constant Conditions & Expressions" inspection and it looks like you can tell IntelliJ about which annotations should be considered non-null / nullable. So it would work if RxJava had its own `@NonNull` annotation included with the library (as long as developers are willing to do a little configuration on their end to accept it).

The only downside to not using jsr305 is that we can't use something like `@ParametersAreNonnullByDefault` which would be less verbose.

If people are on board with this, I could start implementing this (but it's a lot of busywork so I don't want to bother unless people want it). =||= Looks like there is an interest for new annotations, #4878, so it this has to be coordinated with that. I'm not sure about adding `@NonNull` to the functional interfaces though as it may add internal noise to RxJava. We could, however, annotate parameters and return types of the base reactive classes. =||= Hmm, I'm most concerned about the functional interfaces, actually. Those are the ones where the app may accidentally crash during execution unexpectedly.

Here's a contrived example:

```java
void main() {
    Observable.just("Dan")
        .map(new Function<String, String>() {
            @Override
            public String apply(String s) throws Exception {
                return usuallyDependableMethod(s);
            }
        })
        .subscribe();
}

String usuallyDependableMethod(String name) {
    return (Math.random() < .95) ? "Hello " + name : null;
}
```

I can imagine a lot of circumstances where coders don't even realize that `usuallyDependableMethod()` could sometimes return null (when it's not such an obvious problem). That's where static analysis would really help out. =||= Another +1 reason for this would be that Kotlin automatically changes variables to Not null as a language feature if they are annotated with `@NonNull` from JSR 305 along with the IntelliJ and Android equivalents. 

https://kotlinlang.org/docs/reference/java-interop.html#nullability-annotations

Therefore, Kotlin users using RxJava would have the benefit of knowing that their values in something like `onNext()` are not null.

@akarnokd Can you give a reason for not being able to pull in JSR 305 or some equivalent? Just curious. =||= Historically, RxJava is kept to a minimum dependency: 0 in v1 and 1 in v2 =||= I agree @dlew - in a larger code base, it's pretty easy to run into issues like this and there's no way to catch them until runtime.

If it's annotated, a handful of static analysis tools and IDEs can leverage this at compile time (even if it's a custom annotation within the library). =||= I have created a pull request with some changes:
https://github.com/ReactiveX/RxJava/pull/5051 =||= Closing via #5051 & #5055. Let us know if further annotations are necessary. =||= I recently had an issue where a null List<T> was accidentally passed into `Observable.fromIterable()`. Unfortunately that bug made it to production, but it would have been caught if the parameters are annotated. 

@akarnokd @dlew I believe it would be worth it add nullability annotations every where `ObjectHelper.requireNonNull(object, message)` is used to guard execution.

This would be a massive change and it will definitely break compilation in some Kotlin code bases, mine included. =||= Recent IntelliJ infers most nullability annotations for me in Java:

![image](https://user-images.githubusercontent.com/1269832/34566623-68b8c250-f15f-11e7-862f-70bd4cbedc05.png)

and in Kotlin but it doesn't post a warning (see [Kotlin](https://stackoverflow.com/a/45691968/61158)):

![image](https://user-images.githubusercontent.com/1269832/34567008-f3a3d994-f160-11e7-80fd-8bd2a75ab057.png)
 =||= Thanks for the quick reply. 

I haven't been able to get IntelliJ to infer nullability annotations. I've put together a [quick example of my problem](https://github.com/tevjef/RxJava/commit/ef33495a5b7885d524af6a6af0163140635d95f8).

The post you linked seems to address the problem of consuming Java types in Kotlin, rather than here where Kotlin types are consumed by Java. RxJava's `io.reactivex.annotations.NonNull` is [compatible](https://github.com/JetBrains/kotlin/blob/master/core/descriptors.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt#L48) with the Kotlin's compiler as such will cause a compiler error if a nullable Kotlin type is passed into a `@NonNull` Java parameter.

I apologize if this level of Kotlin support is outside of the scope of this project. 
 =||= > rather than here where Kotlin types are consumed by Java

I thought writing in Kotlin requires one to explicitly forfeit non-nullness. Have you been using this particular nullable `List` source elsewhere where it being `null` conveys additional information?

> I apologize if this level of Kotlin support is outside of the scope of this project.

We could add the `@NonNull` annotations, but for the sake of any other library out there, I'd also prefer IntelliJ had the same nullness warning in a Kotlin file (officially) that is already available for Java. =||= > Have you been using this particular nullable List source elsewhere where it being null conveys additional information?

The project was recently converted from RxJava 1.x -> 2.x and from Java to Kotlin in a short time span and this bug went unnoticed. As far as I can tell, `null` does not convey additional information in the stream. 

> I thought writing in Kotlin requires one to explicitly forfeit non-nullness. 

It's not necessarily the case if Java types are correctly annotated.
   =||= @akarnokd Is there any reason why return type of `Function` interface is not annotated with `@NonNull`? `BiFunction` and `Function3` - `Function9` return types are annotated with `@NonNull`. Does it break some contract? =||= Nulls that can't end up in a sequence are allowed, for example, in `groupBy` key selector and `distinct` selector. =||= > Nulls that can't end up in a sequence are allowed, for example, in groupBy key selector and distinct selector.

What do you think about creating annotation `@ReturnsNonNull` and annotate all `Function` interface usages where the nullable value is not allowed? Unfortunately, it will require changes in static analysis tools. Another option is to create `NonNullFunction` interface with `@NonNull` return type but imho breaking API to fix this isn't worth it. =||= Java 6 doesn't allow annotating type arguments that way. You'd need to break binary compatibility to introduce all combinations of possible nullness to the interfaces and use sites. =||= ,0
5058,5045,2.x: RxJavaPlugin.get/setXXX generics?,For unit tests I frequently bump into the restrictiveness of 

```java
RxJavaPlugins.setErrorHandler(Consumer<Throwable> handler);
```

I would like the signature to be 

```java
RxJavaPlugins.setErrorHandler(Consumer<? super Throwable> handler);
```

There are many more methods in `RxJavaPlugins` that could support lower and upper bounded wildcards. Can I make these changes?,setErrorHandler: yes, others would bring trouble I think. =||= I gave it a shot: https://github.com/ReactiveX/RxJava/pull/5058
Widening the generics seems to work so far

But of course I don't know about any side effects, possible problems. =||= ,0
5064,5060,2.x: NPE at ObservableReplay.ReplayObserver.dispose(),Stack trace below shows a crash that I unfortunately can't reproduce currently. I've checked the source for `ObservableReplay.ReplayObserver` and it looks like this can only happen if it's being disposed before being subscribed which sounds odd to me? What might be relevant is that `unsubscribeOn()` is used on the observable.

```
java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference
    at io.reactivex.internal.operators.observable.ObservableReplay$ReplayObserver.dispose(ObservableReplay.java:361)
    at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:216)
    at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:79)
    at io.reactivex.internal.operators.observable.ObservableRefCount$2.run(ObservableRefCount.java:126)
    at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:28)
    at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:18)
    at io.reactivex.disposables.ReferenceDisposable.dispose(ReferenceDisposable.java:42)
    at io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.dispose(ObservableRefCount.java:181)
    at io.reactivex.internal.disposables.DisposableHelper.setOnce(DisposableHelper.java:79)
    at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onSubscribe(ObservableSubscribeOn.java:58)
    at io.reactivex.internal.operators.observable.ObservableRefCount.doSubscribe(ObservableRefCount.java:113)
    at io.reactivex.internal.operators.observable.ObservableRefCount$1.accept(ObservableRefCount.java:98)
    at io.reactivex.internal.operators.observable.ObservableRefCount$1.accept(ObservableRefCount.java:92)
    at io.reactivex.internal.operators.observable.ObservableReplay.connect(ObservableReplay.java:305)
    at io.reactivex.internal.operators.observable.ObservableRefCount.subscribeActual(ObservableRefCount.java:68)
    at io.reactivex.Observable.subscribe(Observable.java:10514)
    at io.reactivex.internal.operators.observable.ObservableSubscribeOn$1.run(ObservableSubscribeOn.java:39)
    at io.reactivex.Scheduler$1.run(Scheduler.java:134)
    at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)
    at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)
    at java.util.concurrent.FutureTask.run(FutureTask.java:237)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)
    at java.lang.Thread.run(Thread.java:761)
```,Thanks for reporting, this is a bug. What happens is that the asnyc dispose happens before the chain of onSubscribe call reaches the operator. The same happens inside `FlowableReplay`. I'll post a fix shortly. =||= See #5064 =||= Closing via #5064 =||= ,0
5086,4253,1.x: Deprecate Observable.create(),Finally we have `Observable.fromAsync()` and it's time to prevent users from using `Observable.create()`.,Don't. Makes all legitimate uses now show up as warnings, including all RxJava!
 =||= But we have to. It's too dangerous and people keep using it in tutorials for **beginners**! 
@JakeWharton is trying to teach them all not to do so (:+1:) but `@Deprecate` is a much more efficient and better way to do it.

> Makes all legitimate uses now show up as warnings

Pretty sure most of them don't support backpressure -> `legitimate == false`!
 =||= ## [Current coverage](https://codecov.io/gh/ReactiveX/RxJava/pull/4253?src=pr) is 84.24% (diff: 100%)

> Merging [#4253](https://codecov.io/gh/ReactiveX/RxJava/pull/4253?src=pr) into [1.x](https://codecov.io/gh/ReactiveX/RxJava/branch/1.x?src=pr) will decrease coverage by **0.09%**

``` diff
@@                1.x      #4253   diff @@
==========================================
  Files           266        266          
  Lines         17446      17446          
  Methods           0          0          
  Messages          0          0          
  Branches       2657       2657          
==========================================
- Hits          14715      14698    -17   
- Misses         1870       1883    +13   
- Partials        861        865     +4   
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [41959f7...ea7300d](https://codecov.io/gh/ReactiveX/RxJava/compare/41959f71b33e71b41c0d6130216e5e6a0f98bfb6...ea7300d06f7bc1e44f0e6b67af65e3bb05448a7f?src=pr)
 =||= If so should not SyncOnSubscribe & AsyncOnSubscribe be mentioned too?
 =||= This I why I use Eclipse: it's immediately obvious what the cascading effects of changes are:

![image](https://cloud.githubusercontent.com/assets/1269832/17214880/33901546-54db-11e6-8c05-2c37fc4cad16.png)

The javadoc contains the warning about using the method:

> This method requires advanced knowledge about building operators and data sources; please consider other standard methods first; 
 =||= We can suppress them in RxJava! 

Sometimes to save someone you love you need to sacrifice something 🚢
 =||= You may not care about the impact but I have to. This change is too radical; a small deprecation now amplified to 400+ warnings and would need to suppress several hundred places - all legitimate (operators) or acceptable uses (unit tests for corner cases).

:-1:
 =||= I better suppress 400+ warnings than let one user to misuse `Observable.create()` and get `MissingBackpressureException` or allow emission without `subscriber.isUnsubscribed()` check.

I understand that you care about library 👍, but I care about users in this PR!

Only in open source projects with shitty GitHub search I found [about 6k+ usages](https://github.com/search?l=java&q=%22Observable.create%22&ref=searchresults&type=Code&utf8=✓) of `Observable.create()`, are you sure they all correctly handle backpressure, errors and unsubscription?

Recently we had to handle backpressure with `Observable.create()` in our library StorIO, same was done in SQLBrite and Retrofit. And this is because maintainers of those libraries were aware of MBE and how to handle it, others may not have required level of understanding to correctly use `Observable.create()`. (I try to avoid it as much as possible). 
 =||= Still you don't just deprecate something and leave the fallout to other maintainer(s).

Instead of just deprecating `create` this is what I'd do:
- refactor-rename `create` to `build` in the entire project -> keeps all our use places intact, no suppressing needed
- copy the `build` method back to `create`
- mark `create` as deprecated, add pointers to the alternative methods in the Javadoc
 =||= That sounds better to me, I was thinking about package private method inside `Observable`, like `createInternal()` + `rx.Internal.createObservable()`, if it would be required, to completely hide it from users (and deprecate `Observable.create()`).

Does it sound good to you @akarnokd?

> If so should not SyncOnSubscribe & AsyncOnSubscribe be mentioned too?

Up to @akarnokd.
 =||= Just making it package-private does not work. We have accesses from other packages that require the create feature. It means we'd have to dump them into the main `rx`, all their tests. With `Internal`, now you have a publicly accessible class and just switched `Observable.create` with `Internal.createObservable`. Java 6's visibility rules are simply not powerful enough to hide `create`.
 =||= So, after discussing that in Twitter looks like our steps could be:
1. Teach users to use `fromAsync()` in their apps but not in libraries yet because it's `@Experimental`.
2. Collect feedback.
3. Stabilise `fromAsync()` and promote it to `@Beta` or stable.
4. Deprecate `create()`.

Regarding hiding it, I think `internalCreate()` or `unsafeCreate()` will do the work.

If that sounds good to you, I'll close this pr and start working on things from list.
 =||= That sounds good.
 =||= > Regarding hiding it, I think internalCreate() or unsafeCreate() will do the work.

Deprecating `create` seems like  a good idea to get users to consider what they're doing but the `create` functionality still needs to be part of the public API. `unsafeCreate` may be a useful name to make people think twice about it.

Re `fromAsync` teaching, one outstanding issue with it was request batching. @akarnokd submitted an operator that we can use for that (`rebatchRequests`)  and I suspect it should be covered as part of the  documentation of `fromAsync` usage. 
 =||= ,0
5087,5067,Documetation points to some nonexistent marble diagrams ,Noticed this while reading some JavaDoc in the context of a 1.2.6 -> 2.0.5 upgrade. I wrote the following script to list all JavaDoc-referenced PNGs which do not yield an HTTP 200 response when resolved:
```sh
#!/usr/bin/env bash

find . -name '*.java' -print0 \
  | xargs -0 grep '^\s*\*' \
  | grep -oP 'https.*?\.png' \
  | sort -u \
  | while read -r I; do
      curl -L -o /dev/null -s -w "%{http_code} ${I}\n" "${I}"
    done \
  | grep -v '^200'
```
And then applied it to the `2.x` branch (rev 0a2610ef6ddfdcdce1e4fecf3434848390e9c6f4). The output is:
```
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toObservable.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.error.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapCompletable.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapPublisher.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapSingle.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.just.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.map.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.oo.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.observeOn.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.subscribeOn.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onExceptionResumeNextViaMaybe.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/S.BehaviorProcessor.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapCompletable.png
404 https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapMaybe.png
```,Thanks, I'll draw them next week. =||= Completable.toObservable.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toObservable.png)

Maybe.concat.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.png)

Maybe.error.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.error.png)

Maybe.flatMapCompletable.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapCompletable.png)

Maybe.flatMap.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.png)

Maybe.flatMapPublisher.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapPublisher.png)

Maybe.flatMapSingle.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapSingle.png)

Maybe.just.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.just.png)

Maybe.map.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.map.png)

Maybe.merge.oo.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.oo.png)

Maybe.merge.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.png)

Maybe.observeOn.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.observeOn.png)

Maybe.subscribeOn.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.subscribeOn.png)

onExceptionResumeNextViaMaybe.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onExceptionResumeNextViaMaybe.png)

S.BehaviorProcessor.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/S.BehaviorProcessor.png)

Single.flatMapCompletable.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapCompletable.png)

Single.flatMapMaybe.png
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapMaybe.png)

 =||= Note that the images inside the javadoc may be skewed. Let me know if you'd like to post a PR that fixes the width= and height= constants for these. =||= @akarnokd, thanks for generating these images. As for your fixing the dimensions, I filed PR #5087 for that; let me know whether that's what you intended. =||= ,0
5090,5089,2.0.4 FlowableScanSeed introduces delay,Hi guys! 

I'm using `Flowable.scan(seed)` to accumulate values of infinite sequence(stream of updates from server that comes not so often). The problem is that whenever FlowableScanSeed receives new value it publishes previous one. I guess it's not a problem with a finite sequence(at completion all values will be published anyway), but with infinite seq the last value is held until next comes.

I wrote test case to demonstrate the issue
```
    @Test
    public void testScanWithSeedEmitsAllItemsOnInfiniteSequence() {
        Flowable.concat(Flowable.just(1, 2, 3), Flowable.<Integer>never()).scan(0, SUM)
                .test(4)
                .assertValues(0, 1, 3, 6);
    }
```

Here seed+3 values are expected, but since sequence is infinite last value never comes.

I don't have much experience with rx so can't provide you with a patch, sorry ;),Scan was changed to have less overhead than before at the cost of delaying the upstream values by one step. This works if the source keeps emitting frequently enough but as you demonstrated, if there is nothing to push more the operator just stops.

I'll create a PR that doesn't delay items shortly. =||= Closing via #5090. =||= ,0
5091,4735,fromEmitter same-pool deadlock,This affects both 1.x and 2.x.

There is a question on [StackOverflow](http://stackoverflow.com/questions/40145203/rxjava-observable-fromemitter-odd-backpressure-behaviour) where the example program hangs after it delivered the default bufferSize elements until the `fromEmitter` source completes.

The problem is that `subscribeOn` schedules the downstream's replenishing `request` on the same thread that is busy/sleeping and has no opportunity to update its internal requested amount. We had similar problems with `onBackpressureBlock` which had to be dropped.

We could introduce a `subscribeOn` mode in which it doesn't reschedule the `request` from downstream but it will confuse some and make wonder others.,This was resolved in 2.x by making sure a `subscribeOn` after `create` doesn't reschedule downstream requests.
 =||= I think I'm running into this problem as well. `fromEmitter` suddenly stops emitting `onNext` items whereas the emitter itself is still being called.

I was using a single-thread-scheduler for the emitter, so I thought (from your explanation) that moving to a threadpool would resolve the problem. It apparently does not for my case. I'm probably misunderstanding what is going on behind the scenes.

Do you have any suggestions on how to workaround this issue (without moving to 2.x). =||= @bobvanderlinden Yes, use the NONE policy and apply `onBackpressureXXX` *after* `subscribeOn`. =||= @akarnokd That works like a charm! Thanks a lot! =||= Closing via #5091 for 1.x  and #4770 for 2.x. =||= ,0
5092,4988,1.x: Merging an observable of singles.,The addition of a `Observable<Single<T>> -> Observable<T>` to round out the basic API of `rx.Single`. I need this for doing a flat scan of sorts.

```
Single.merge(events.scan(Single.just(seed), (stateSingle, event) -> {
    return stateSingle.flatMap((state) -> {
        return state.write(event);
    }).cache();
}));
```,## [Current coverage](https://codecov.io/gh/ReactiveX/RxJava/pull/4988?src=pr) is 83.54% (diff: 57.57%)
> Merging [#4988](https://codecov.io/gh/ReactiveX/RxJava/pull/4988?src=pr) into [1.x](https://codecov.io/gh/ReactiveX/RxJava/branch/1.x?src=pr) will decrease coverage by **0.73%**

```diff
@@                1.x      #4988   diff @@
==========================================
  Files           288        289     +1   
  Lines         17806      18235   +429   
  Methods           0          0          
  Messages          0          0          
  Branches       2698       2782    +84   
==========================================
+ Hits          15007      15234   +227   
- Misses         1950       2096   +146   
- Partials        849        905    +56   
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [3716747...1008acd](https://codecov.io/gh/ReactiveX/RxJava/compare/371674746dc4136bf74515962edf52e21ca7d420...1008acde4e4c263bc22ad275a76a603be3a89d36?src=pr) =||= Looks like a big copy and paste from an existing merge operator. Can you summarize the differences from the original tried and true operator to help review? I also wonder if we can share a decent chunk of code between operators. =||= It was a copy for the most part but for changing the class names. It could have be done by mapping the `Observable<Single<T>>` to an `Observable<Observable<T>>`. =||= @akarnokd actually do you think that the back pressure could be streamlined because of the guarantee that they'll be one onNext for each subscription? Does it even need a custom Producer if we got rid of the maxConcurrent overloads? =||= The [v2 version](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java) is optimized. =||= > if we got rid of the maxConcurrent overloads

You may not want to have a million outstanding `Single`-based network request. Limiting flatMap's concurrency is expected here where backpressure helps naturally. =||= Any progress on this? =||= Closing via #5092. =||= ,0
5101,5100,Maybe concat with firstElement still call second Maybe although the first emit value,Hi, I'm relatively new to RxJava.

I tried RxJava 2.0.6 (previously 2.0.5) to check if it still produces the same result.

Here my code (still using Java 6)

```
Maybe<String> m1 = Maybe.create(new MaybeOnSubscribe<String>() {

    @Override public void subscribe(MaybeEmitter<String> e) throws Exception {
        System.out.println("m1 called");
        e.onSuccess("m1");
    }
});
Maybe<String> m2 = Maybe.create(new MaybeOnSubscribe<String>() {

    @Override public void subscribe(MaybeEmitter<String> e) throws Exception {
        System.out.println("m2 called");
        e.onSuccess("m2");
    }
});
Disposable subscribe = Maybe.concat(m1, m2)
        .firstElement()
        .subscribe(new Consumer<String>() {

            @Override public void accept(String t) throws Exception {
                System.out.println(t);
            }
        });
```

the output :
m1 called
m1
m2 called

Is it correct or not? Because while using Observable, the second Observable is not called when the first one already emit value

Thanks,Hi and thanks for reporting. This is a bug in the underlying `concat` operator that doesn't expect a cancellation (happening due to `firstElement`) after emitting an item and happily subscribes to the next source, triggering subscription side-effects but actually cancelling out that new source immediately.

I'll post a fix shortly. =||= Closing via #5101.

Temporary workaround: add `Maybe.empty()` between the sources to absorb the extra subscription. =||= ,0
5106,5104,2.x : window(timespan, unit, count) always emit empty observable if not reach max count,This code will print nothing all the time.

```java
PublishSubject<String> vehicleToFetch = PublishSubject.create();
        vehicleToFetch
                .delay(2,TimeUnit.SECONDS)
                .window(10, TimeUnit.SECONDS, 5)
                .observeOn(Schedulers.io())
                .subscribe(w-> w.toList().subscribe(ws-> {
                    ws.forEach(v -> {
                        System.out.println(String.format("%s %d", v, Thread.currentThread().getId()));
                        vehicleToFetch.onNext(v);
                    });
                }));


        Observable.just("v1","v2","v3","v4")
                .subscribe(v->{
                    vehicleToFetch.onNext(v);
                });

```

I am using rxjava:2.0.6.,There are two problems with your code:

- You are using `toList` which requires a finite stream. Since you don't call `onComplete` on `vehicleToFetch` the sequence above won't print anything.
- You are probably not waiting long enough to see the results. The default RxJava schedulers are daemon threads and when the "main" thread ends, the whole application stops.

```java
PublishSubject<String> vehicleToFetch = PublishSubject.create();
vehicleToFetch
        .delay(2,TimeUnit.SECONDS)
        .window(10, TimeUnit.SECONDS, 5)
        .observeOn(Schedulers.io())
        .subscribe(w-> w.toList().subscribe(ws-> {
            ws.forEach(v -> {
                System.out.println(String.format("%s %d", v, Thread.currentThread().getId()));
                vehicleToFetch.onNext(v);
            });
        }));


Observable.just("v1","v2","v3","v4").subscribe(vehicleToFetch);

Thread.sleep(3000);
``` =||= @akarnokd Thanks.  I am calling `toList()` on a window observable ,not on `vehicleToFetch`, There is print if I change ` .window(10, TimeUnit.SECONDS, 5)` to `.window(10, TimeUnit.SECONDS, 4)`.

I am using a `CountDownLatch`(not show in code) to wait a long time. =||= Yes, because the window with limit 4 will call `onComplete` for you on the window that `toList()` consumes. With 5 there is noone to call `onComplete`. If you had a "v5" in that case, you'd see the printout again. =||= Why did it not call `onComplete` when the timeout is reached?  Does not this method mean either timeout or max count is reach will emit a window?  =||= Oh, I see it now. There is a bug in the operator that doesn't complete the old window if a new one is due to the timeout. I'll post a fix for it. =||= Closing via #5106. =||= It  worked after upgrade to 2.0.7,  but after three times timeout, there is no timeout anymore. =||= Do you have a new unit test for it? =||= You can use the same code , it will block after three new window emitted. =||= Odd. I'll look into it again. =||= Found a couple of remaining issues. See PR #5213; the example works with it properly for me. =||= ,0
5112,5110,2.x: Reactive-Streams compliance,There is an [ongoing effort](https://github.com/reactive-streams/reactive-streams-jvm/pull/339) to clarify the reasons behind the [Reactive-Streams](https://github.com/reactive-streams/reactive-streams-jvm/) rules. In the hopes that the rules could be relaxed without too much compatibility problems, I brought up the case that we had to introduce the `strict()` operator to pass the TCK tests. The problematic rules are §1.3 and §3.9 that impose such requirements that add overhead to sequences.

This sparked a [separate discussion](https://github.com/reactive-streams/reactive-streams-jvm/issues/341) about the it was a good idea RxJava 2 exposes itself with the Reactive-Streams interfaces instead of hiding it behind a converter / exposure layer which decoupling allows - in theory - violating the exact rules as long as such violations are not visible by the consumer.

I doubt I could convince the maintainers of the specification (other than @smaldini) it is worth taking the relaxations even at the expense of temporary incompatibility in case vendor's don't relax their particular implementations.

RxJava 2 works with or without the "Reactive-Streams compliant" badge yet as a "brand", it is still advisable to have that badge.

### Suggested API changes

Ensuring conformance is a matter of applying the `StrictSubscriber` wrapper to the incoming `Subscriber` in `Flowable.subscribe`. Unfortunately, this slows down everything as there is only one way to consume a `Flowable` through `subscribe(Subscriber)` (the overloads all delegate to it).

To get the speed back, a new instance method would be introduced that all internal operators would use then on instead of `subscribe`. RxJava 1 has an extra entry point `unsafeSubscribe` to sidestep `SafeSubscriber` thus there is precedence for such alternate entry point.

The method could be called `subscribe` as well that takes a `FlowableSubscriber extends Subscriber`. `FlowableSubscriber`s textual definition can then weaken rules §1.3 and §3.9 inherited. Existing operators would then implement `FlowableSubscriber` in place of `Subscriber`.

I think all of this would be binary compatible change since only `Flowable` would get an extra method.

Suggestions welcome.,Is `FlowableSubscriber` a public type just like the non-RS observers?

I've been following the discussion too and I think this is a reasonable action to take. =||= Yes, `io.reactivex.FlowableSubscriber`. I don't think hiding it in `internal` is necessary. I'm currently preparing a PR to demonstrate the changes. =||= Closing via #5112. =||= ,0
5114,5111,2.x: Disposal of ObservableCombineLatest's observers?,When a ObservableCombineLatest is disposed, is there any particular reason why it does not dispose all of it's observers? i'm seeing `getAndIncrement()` be non-zero and that observer is not receiving any more events, so a memory leak is caused

https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java#L128,If there is no ongoing onNext, that should dispose the sources. Does your downstream block for any reason on onNext? =||= `Flowable` is implemented with an eager cancellation so I consider this to be a bug. I'll post a fix shortly. =||= Closing via #5114. =||= @akarnokd, thanks for the quick turnaround! would this also apply to [ObservableZip](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java#L118), as well? here is [FlowableZip](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java#L146)'s cancel() =||= Indeed. Would you like to submit a PR? =||= will do =||= ,0
5117,5108,ParallelFlowable, sequential and exception management,Hi,
I'm stuck on a problem which might or might not be an issue on the current version of the `ParallelFlowable`, or if it is a desired behaviour, it's not specified anywhere in the documentation.
In a few words, I'm having issues propagating errors from a `ParallelFlowable` to a single `Flowable` (when calling `sequential()`).
What I would expect is that any error generated during the execution of operators on the `ParallelFlowable` would be propagated to the subscriber on the Flowable.
What really happens is that the exception is not propagated, and it's thrown even if it's a checked exception.
Here is a code example:

```java
Flowable.just(request1, request2)
                .parallel() // parallel execution is needed
                .runOn(Schedulers.io())
                .map(request -> request.execute()) // execute() can throw an exception
                .sequential()
                .toList()
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(this::success, this::failure);
```
`failure(exception)` is not called, and the exception is actually thrown.

I've also tried this and the exception is still not propagated to the sequential Flowable:

```java
Flowable.just(request1, request2)
                .parallel() // parallel execution is needed
                .runOn(Schedulers.io())
                .flatMap(request -> {
                    try {
                        return Flowable.just(request.execute());
                    } catch (Exception e) {
                        return Flowable.error(e);
                    }
                }
                .sequential()
...
```

I'm using version 2.0.5 of RxJava on Android.

Thank you for your help.,The underlying problem is that `sequential` can only allow one `onError`. If multiple rails fail, one gets through and the others get sent to `RxJavaPlugins.onError`.

On one hand, this is a general property of RxJava 2 and requires you to setup a [global error handler](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling) based on what you consider fatal and what not.

On the other hand, the internals of the parallel operators don't leave much option. Currently, if a rail fails it cancels the upstream rail  (which cancels the original Flowable in the chain) and emits an onError. When the error reaches the `sequential` operator, the operator cancels the rest of the rails.

For a workaround, I suggest you switch back to a traditional parallel execution:

```java
Flowable<T> a = Flowable.just(request1).subscribeOn(Schedulers.computation()).map(...);
Flowable<T> b = Flowable.just(request2).subscribeOn(Schedulers.computation()).map(...);

Flowable<T> c = Flowable.mergeArrayDelayError(a, b);
```

I need more time to figure out a better way to support your failure mode. =||= Thank you @akarnokd for the super fast turnaround on this!
I'll go with `Flowable.mergeArrayDelayError()` for now, since it seems to behave as expected, and I look forward to check out the new solution with `ParallelFlowable`.
In general, when it comes to parallel computations there are three common scenarios to handle a failure and it would be good if developers were able to choose among all of them:
- Make all the computations fail when one of them fails
- Notify all successful computations until the failure, then fail all the others
- Notify all successful computations, before and after the failed computation =||= See #5202.

I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.
 =||= ,0
5121,5111,2.x: Disposal of ObservableCombineLatest's observers?,When a ObservableCombineLatest is disposed, is there any particular reason why it does not dispose all of it's observers? i'm seeing `getAndIncrement()` be non-zero and that observer is not receiving any more events, so a memory leak is caused

https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java#L128,If there is no ongoing onNext, that should dispose the sources. Does your downstream block for any reason on onNext? =||= `Flowable` is implemented with an eager cancellation so I consider this to be a bug. I'll post a fix shortly. =||= Closing via #5114. =||= @akarnokd, thanks for the quick turnaround! would this also apply to [ObservableZip](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java#L118), as well? here is [FlowableZip](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java#L146)'s cancel() =||= Indeed. Would you like to submit a PR? =||= will do =||= ,0
5123,5120,[1.2.6] throttleFirst doesn't emit item if user changed system time as past,I used throttleFirst operator for prevening duplicated click event like below
```
RxView.clicks(v).throttleFirst(500, TimeUnit.MILLISECONDS, AndroidSchedulers.mainThread())
```

It works well in general case. But if user changed system time as past after click view, thrrottleFist doesn't emit item. (In the android, user can change system time using settings application.)
Because, OperatorThrottleFirst's below routine. 
```
    @Override
    public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {
        return new Subscriber<T>(subscriber) {

            private long lastOnNext = -1;
            // ...
            @Override
            public void onNext(T v) {
                long now = scheduler.now();
                if (lastOnNext == -1 || now - lastOnNext >= timeInMilliseconds) {
                    lastOnNext = now;
                    subscriber.onNext(v);
                }
            }
```
I think (now - lastOnNext) become negative value, item should be emitted too. ,Would you like to post a fix? =||= Thank you for your feedback.  =||= I've restructured the issue and moved your comment into the top field. If you have the means, you are welcome to verify #5123. =||= Closing via #5123 & release 1.2.7 =||= ,0
5127,5126,2.x Flowable.flatMap maxConcurrency should be unbounded unless it is restricted,When more than 128 publishers that not all emit events causes miss of any further message that would be sent by subsequent publishers. This is due to the underlying implementation defaults to bufferSize() which is 128 https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Flowable.java#L8239

According to http://reactivex.io/RxJava/javadoc/io/reactivex/Flowable.html#flatMap(io.reactivex.functions.Function) 

> The outer Publisher is consumed in unbounded mode

Example to replicate the issue: (assumes that publishers is greater than 128 and that none of the first 128 publishers are emitting any message):

```
public Flowable<MyType> foo() {
      return publishers.flatMap(publisher -> {
        return publisher
            .subscribeTo("bar")
            .doOnSubscribe(s -> System.out.println(s))
            .doOnError(t -> System.out.println(t))
            .map(MyClass::someOperation)
            .takeUntil(publisher.onClose().toFlowable());
     });
}
```

At the moment the work around is to use the overloaded flatMap to set manually set maxConcurrency to be unbounded.,Hi and thanks for reporting. flatMap(Function) should be bounded and the javadoc is wrong due to copy-paste error from merge() which is unbounded. =||= The reason it was never bounded in v1 is that it causes these types of hidden system hangs that are very hard to debug. This seems like a dangerous behavior to have changed.  =||= Yes, you have to unbound `Flowable.flatMap` manually for your use case as it defaults to a fixed number of active inner `Publisher`s at once; this is a typical behavior for in-sequence operators that have an N:M relation between the input and output because `Flowable` is the backpressure-enabled, no-overflow base reactive type.

If you need unbounded behavior, consider using `Observable`. In v1, there was a *theoretical* problem when the same bounding on `merge` was attempted: GUI scenarios may merge more than 128 sources at once and bounding merge that late in the life of v1 could have caused unexpected hangs indeed.

The Javadoc has been fixed by and closing via #5127. =||= ,0
5133,5132,2.x v2.0.6 Single.merge produce UndeliverableError [Question],Sorry for code in kotlin.

```
    @Test fun singleMergeTest() {
        val illegalAccessError = IllegalAccessError()
        Single.merge<String>(listOf(
                Single.error(illegalAccessError),
                Single.error(illegalAccessError),
                Single.error(illegalAccessError)
        )).test().await().assertError(illegalAccessError)
    }

    @Test fun observableMergeTest() {
        val illegalAccessError = IllegalAccessError()
        Observable.merge<String>(listOf(
                Observable.error(illegalAccessError),
                Observable.error(illegalAccessError),
                Observable.error(illegalAccessError)
        )).test().await().assertError(illegalAccessError)
    }
```

First test produces `UndeliverableError` after execution but second one completes successfully without errors. Is it expected behaviour or a bug?,Thanks for reporting. This is indeed an inconsistency between `Observable` and the `Flowable`-based merges not stopping immediately when one of the inner sources fails and subscribing to the next inner source in synchronous mode. =||= Closing via #5133. =||= ,0
5136,5135,retryWhen method signature for with Completable and Single,When I attempt to use `retryWhen` to delay a retry with `Completable` or `Single` I receive an _incompatible types_ error, as demonstrated in the following code:
            
            Completable.error(new RuntimeException())
                    .retryWhen(new Function<Flowable<Throwable>, Publisher<Object>>() {
                        @Override
                        public Publisher<Object> apply(@io.reactivex.annotations.NonNull Flowable<Throwable> source) throws Exception {
                            return source.delay(5, TimeUnit.SECONDS); // <- Incompatible type error
                        }
                    });
            
            Single.error(new RuntimeException())
                    .retryWhen(new Function<Flowable<Throwable>, Publisher<Object>>() {
                        @Override
                        public Publisher<Object> apply(@io.reactivex.annotations.NonNull Flowable<Throwable> source) throws Exception {
                            return source.delay(5, TimeUnit.SECONDS); // <- Incompatible type error
                        }
                    });


However, there are no issues with `Observable` or `Flowable`:

            Observable.error(new RuntimeException())
                    .retryWhen(new Function<Observable<Throwable>, ObservableSource<?>>() {
                        @Override
                        public ObservableSource<?> apply(@io.reactivex.annotations.NonNull Observable<Throwable> source) throws Exception {
                            return source.delay(5, TimeUnit.SECONDS);
                        }
                    });
            Flowable.error(new RuntimeException())
                    .retryWhen(new Function<Flowable<Throwable>, Publisher<?>>() {
                        @Override
                        public Publisher<?> apply(@io.reactivex.annotations.NonNull Flowable<Throwable> source) throws Exception {
                            return source.delay(5, TimeUnit.SECONDS);
                        }
                    });

Looks like there is an issue with the return types for `apply`?,@akarnokd Sorry, I accidentally submitted the issue without my description.  Now fixed. This isn't a crosspost, but appears to be a bug. =||= You have the wrong return type argument in the first case. Either change it to `?` or `Throwable`. =||= @akarnokd  Aren't the `Completable` `runwith` Function argument and return types incompatible?

    public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler) 

So the following `retryWith` lambda:

        Completable.error(new RuntimeException())
                .retryWhen(throwableFlowable -> throwableFlowable.delay(5, TimeUnit.SECONDS); 

produces the error:

    Bad return type in lambda expression: Flowable<Throwable> cannot be converted to Publisher<Object>

 =||= Thanks, I see he issue now. Indeed, the Completable and Single signature for retryWhen is different from the others. `repeatWhen` is also off. Would you like to submit a PR? =||= Sure, I can do that.  

Question:  Should the function return type be `Publisher<?>` or `CompletableSource<?>` /  `SingleSource<?>` ?   `Flowable` and `Observable` differ in this regard. =||= I'd like to encourage you to think about that a bit. =||= Two hints:
- you'd want to retry multiple times
- you'd want to avoid ClassCastException on existing operator users =||= Closing via #5136. =||= @akarnokd I tried to use:

    .retryWhen(errors -> errors.flatMap(error -> Observable.timer(30, TimeUnit.SECONDS)))

On a `Transformer` for a ` Single` and I am getting this error:

>error: incompatible types: cannot infer type-variable(s) R (argument mismatch; bad return type in lambda expression Observable cannot be converted to Publisher) where R,T are type-variables: R extends Object declared in method flatMap(Function>) T extends Object declared in class Flowable

And the squiggly lines below error -> Observable.timer(30, TimeUnit.SECONDS) say:
> no instance(s) of type variable(s) R exist so that Observable conforms to Publisher

What am I doing wrong? Is this bug fixed? =||= Using `Flowable.timer` instead fixes this, is this something only related to `Single`? Because [this tutorial](http://blog.danlew.net/2016/01/25/rxjavas-repeatwhen-and-retrywhen-explained/) uses `Observable.timer` with no issues. =||= > What am I doing wrong?

Please check the signatures of operators so that you are using the right types: https://github.com/ReactiveX/RxJava#base-class-vs-base-type

> Because this tutorial uses Observable.timer with no issues.

That tutorial predates RxJava 2.

> is this something only related to Single

`retryWhen` and `repeatWhen` use `Publisher` as the redo signal by design so that we can leverage backpressure to only ask for one such redo signal at a time. With `Observable`, there is a chance a handler would simply dump a lot of signals at once and the operators may behaved unexpectedly. =||= Also do not cross post questions: https://stackoverflow.com/questions/50325533/type-error-on-retrywhen-with-delay =||= I thought about posting here the stackoverflow link, but many people just ignore links, I am glad you aren't one of those. Thank you very much for the explanation!  =||= ,0
5140,3917,replay(bufferSize, time, TimeUnit) not working - truncate should be called with replay?,The buffer only gets truncated when a new item is added. So any subscribers will always receive that last emission even if it's older than the time-limit. 

```
    'Observable<Long> retrofit = Observable.interval(2L, 2L, TimeUnit.SECONDS).take(10);

    ConnectableObservable<Long> connectableRetrofit;
    connectableRetrofit = retrofit.replay(1, 5, TimeUnit.SECONDS);


    System.out.println("Subscribing A");
    connectableRetrofit.subscribe(new Action1<Long>() {
        @Override
        public void call(Long aLong) {
            System.out.println("subscriber! A ========== " + aLong);
        }
    });

    System.out.println("Connecting!");
    connectableRetrofit.connect();

    Thread.sleep(10000L);


    System.out.println("Subscribing B");
    connectableRetrofit.subscribe(new Action1<Long>() {
        @Override
        public void call(Long aLong) {
            System.out.println("subscriber! B ========== " + aLong);
        }
    });

    Thread.sleep(30000L);


    System.out.println("Subscribing C");
    connectableRetrofit.subscribe(new Action1<Long>() {
        @Override
        public void call(Long aLong) {
            System.out.println("subscriber! C ========== " + aLong);
        }
    });`
```

Here subscriber C is subbing after 30 secs so you'd expect the buffer to have truncated the last value since the time-limit is 5 secs.

This is the output: 

> Subscribing A
> Connecting!
> subscriber! A ========== 0
> subscriber! A ========== 1
> subscriber! A ========== 2
> subscriber! A ========== 3
> subscriber! A ========== 4
> Subscribing B
> subscriber! B ========== 4
> subscriber! A ========== 5
> subscriber! B ========== 5
> subscriber! A ========== 6
> subscriber! B ========== 6
> subscriber! A ========== 7
> subscriber! B ========== 7
> subscriber! A ========== 8
> subscriber! B ========== 8
> subscriber! A ========== 9
> subscriber! B ========== 9
> Subscribing C
> subscriber! C ========== 9,True, replay starts from the current head which is only moved forward by `onNext`. I've been thinking about rewriting `ReplaySubject` to support backpressure; in that structure, when the child Subscriber picks up [the head](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/processors/ReplayProcessor.java#L975), we can skip old entries right there.

Question is, do we want this behavior change and whether the current behavior is expected by unit tests?
 =||= Good point. I think the current behavior is a conflict with the method description/purpose. So I'd say change, if not at least an update to the documentation. Maybe deprecate the current one? Being new to Rx I spent quite a while trying to figure out why this wasn't working. 
 =||= Also, could you recommend a workaround to achieve that behavior? Basically I wanted to do something like replay a network call within a specific time, and if it came out empty I'd repeat the call.
 =||= You can timestamp values before it reaches the ReplaySubject then use skipWhile(n -> n.timestamp < now - maxAge).

Otherwise, see #3918 for an updated ReplaySubject where stale data is skipped on subscription.
 =||= Sorry, I completely forgot about this. I'll post an PR to replay() and see what it takes to skip old entries.
 =||= See #4023 for a proposed fix for `replay()` itself.
 =||= Closing via #4023.
 =||= ,0
5140,5139,2.x: replay() seems to be still replaying old data for late subscribers, - Using RxJava 2.0.6

It seems [this issue](https://github.com/ReactiveX/RxJava/issues/3917) is still present in RxJava 2. When late subscribers `subscribe()` to a source with `replay(time, unit)` that has already expired, the source still emits the "expired emission" if `onNext()` is not called.

Posted this originally on [StackOverflow](http://stackoverflow.com/questions/42486432/rxjavas-replaytime-unit-is-replaying-expired-emissions-is-that-the-expect) but I'm now referencing it here because it seems to be an issue with the library.,Hi and thanks for reporting. Indeed this is a bug that was not resolved in 2.x:

```java
io.reactivex.schedulers.TestScheduler scheduler = new io.reactivex.schedulers.TestScheduler();
        
io.reactivex.Observable<Integer> source = io.reactivex.Observable.just(3)
                .replay(2, TimeUnit.SECONDS, scheduler)
                .autoConnect();

source.test().assertResult(3);

source.test().assertResult(3);

scheduler.advanceTimeBy(3, TimeUnit.SECONDS);

source.test().assertResult();
```

The timed versions of `Flowable.replay()`, `ReplayProcessor`, `Observable.replay()` and `ReplaySubject` are all affected.

 and appears to be partially broken in 1.x:

```java
rx.schedulers.TestScheduler scheduler = new rx.schedulers.TestScheduler();
        
rx.Observable<Integer> source = rx.Observable.just(1)
                .replay(2, TimeUnit.SECONDS, scheduler)
                .autoConnect();

source.test().assertResult(1);

source.test().assertResult(1);

scheduler.advanceTimeBy(3, TimeUnit.SECONDS);

source.test().assertResult();
```

fails on the last line with `Not completed!`.

I'll post the fixes for the respective versions shortly. =||= Closing via #5140 & #5141. =||= ,0
5141,5139,2.x: replay() seems to be still replaying old data for late subscribers, - Using RxJava 2.0.6

It seems [this issue](https://github.com/ReactiveX/RxJava/issues/3917) is still present in RxJava 2. When late subscribers `subscribe()` to a source with `replay(time, unit)` that has already expired, the source still emits the "expired emission" if `onNext()` is not called.

Posted this originally on [StackOverflow](http://stackoverflow.com/questions/42486432/rxjavas-replaytime-unit-is-replaying-expired-emissions-is-that-the-expect) but I'm now referencing it here because it seems to be an issue with the library.,Hi and thanks for reporting. Indeed this is a bug that was not resolved in 2.x:

```java
io.reactivex.schedulers.TestScheduler scheduler = new io.reactivex.schedulers.TestScheduler();
        
io.reactivex.Observable<Integer> source = io.reactivex.Observable.just(3)
                .replay(2, TimeUnit.SECONDS, scheduler)
                .autoConnect();

source.test().assertResult(3);

source.test().assertResult(3);

scheduler.advanceTimeBy(3, TimeUnit.SECONDS);

source.test().assertResult();
```

The timed versions of `Flowable.replay()`, `ReplayProcessor`, `Observable.replay()` and `ReplaySubject` are all affected.

 and appears to be partially broken in 1.x:

```java
rx.schedulers.TestScheduler scheduler = new rx.schedulers.TestScheduler();
        
rx.Observable<Integer> source = rx.Observable.just(1)
                .replay(2, TimeUnit.SECONDS, scheduler)
                .autoConnect();

source.test().assertResult(1);

source.test().assertResult(1);

scheduler.advanceTimeBy(3, TimeUnit.SECONDS);

source.test().assertResult();
```

fails on the last line with `Not completed!`.

I'll post the fixes for the respective versions shortly. =||= Closing via #5140 & #5141. =||= ,0
5146,5138,1.x: unsubscribeOn for Single?,RxJava version: v1.2.7

Although Single may be unsubscribed on a different thread than subscribed one, there seems to be no `unsubscribedOn` operator for Single.

It would be nice if there is a `Single#unsubscribeOn`.
I currently convert to Observable and use subscribeOn/unsubscribeOn methods for Observable, and then convert back to Single.,PR welcome. =||= Closing via #5146. =||= ,0
5156,4876,2.x: Add @NonNull annotation for Function/Predicate/etc.,One of the larger tasks when transitioning from 1 to 2 is removing the use of null. Right now there's no automated way to do it, but if we had `@NonNull` then we'd be able to use static analysis to find where we're returning null when we shouldn't be.

I'm not sure the best way to go about it - if we should include jsr305, use Java 8's NonNull, create our own, or something else.,We can't do external dependencies like jsr305 and I can't find `@NonNull` or `@NotNull` in Java 8's public API. We could introduce our own if your tools support custom annotations for this purpose. =||= It looks like Java 8 doesn't actually include it - it's part of a checker framework. More details [here](https://blogs.oracle.com/java-platform-group/entry/java_8_s_new_type).

Regardless, I'm specifically targeting IntelliJ's "Constant Conditions & Expressions" inspection and it looks like you can tell IntelliJ about which annotations should be considered non-null / nullable. So it would work if RxJava had its own `@NonNull` annotation included with the library (as long as developers are willing to do a little configuration on their end to accept it).

The only downside to not using jsr305 is that we can't use something like `@ParametersAreNonnullByDefault` which would be less verbose.

If people are on board with this, I could start implementing this (but it's a lot of busywork so I don't want to bother unless people want it). =||= Looks like there is an interest for new annotations, #4878, so it this has to be coordinated with that. I'm not sure about adding `@NonNull` to the functional interfaces though as it may add internal noise to RxJava. We could, however, annotate parameters and return types of the base reactive classes. =||= Hmm, I'm most concerned about the functional interfaces, actually. Those are the ones where the app may accidentally crash during execution unexpectedly.

Here's a contrived example:

```java
void main() {
    Observable.just("Dan")
        .map(new Function<String, String>() {
            @Override
            public String apply(String s) throws Exception {
                return usuallyDependableMethod(s);
            }
        })
        .subscribe();
}

String usuallyDependableMethod(String name) {
    return (Math.random() < .95) ? "Hello " + name : null;
}
```

I can imagine a lot of circumstances where coders don't even realize that `usuallyDependableMethod()` could sometimes return null (when it's not such an obvious problem). That's where static analysis would really help out. =||= Another +1 reason for this would be that Kotlin automatically changes variables to Not null as a language feature if they are annotated with `@NonNull` from JSR 305 along with the IntelliJ and Android equivalents. 

https://kotlinlang.org/docs/reference/java-interop.html#nullability-annotations

Therefore, Kotlin users using RxJava would have the benefit of knowing that their values in something like `onNext()` are not null.

@akarnokd Can you give a reason for not being able to pull in JSR 305 or some equivalent? Just curious. =||= Historically, RxJava is kept to a minimum dependency: 0 in v1 and 1 in v2 =||= I agree @dlew - in a larger code base, it's pretty easy to run into issues like this and there's no way to catch them until runtime.

If it's annotated, a handful of static analysis tools and IDEs can leverage this at compile time (even if it's a custom annotation within the library). =||= I have created a pull request with some changes:
https://github.com/ReactiveX/RxJava/pull/5051 =||= Closing via #5051 & #5055. Let us know if further annotations are necessary. =||= I recently had an issue where a null List<T> was accidentally passed into `Observable.fromIterable()`. Unfortunately that bug made it to production, but it would have been caught if the parameters are annotated. 

@akarnokd @dlew I believe it would be worth it add nullability annotations every where `ObjectHelper.requireNonNull(object, message)` is used to guard execution.

This would be a massive change and it will definitely break compilation in some Kotlin code bases, mine included. =||= Recent IntelliJ infers most nullability annotations for me in Java:

![image](https://user-images.githubusercontent.com/1269832/34566623-68b8c250-f15f-11e7-862f-70bd4cbedc05.png)

and in Kotlin but it doesn't post a warning (see [Kotlin](https://stackoverflow.com/a/45691968/61158)):

![image](https://user-images.githubusercontent.com/1269832/34567008-f3a3d994-f160-11e7-80fd-8bd2a75ab057.png)
 =||= Thanks for the quick reply. 

I haven't been able to get IntelliJ to infer nullability annotations. I've put together a [quick example of my problem](https://github.com/tevjef/RxJava/commit/ef33495a5b7885d524af6a6af0163140635d95f8).

The post you linked seems to address the problem of consuming Java types in Kotlin, rather than here where Kotlin types are consumed by Java. RxJava's `io.reactivex.annotations.NonNull` is [compatible](https://github.com/JetBrains/kotlin/blob/master/core/descriptors.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt#L48) with the Kotlin's compiler as such will cause a compiler error if a nullable Kotlin type is passed into a `@NonNull` Java parameter.

I apologize if this level of Kotlin support is outside of the scope of this project. 
 =||= > rather than here where Kotlin types are consumed by Java

I thought writing in Kotlin requires one to explicitly forfeit non-nullness. Have you been using this particular nullable `List` source elsewhere where it being `null` conveys additional information?

> I apologize if this level of Kotlin support is outside of the scope of this project.

We could add the `@NonNull` annotations, but for the sake of any other library out there, I'd also prefer IntelliJ had the same nullness warning in a Kotlin file (officially) that is already available for Java. =||= > Have you been using this particular nullable List source elsewhere where it being null conveys additional information?

The project was recently converted from RxJava 1.x -> 2.x and from Java to Kotlin in a short time span and this bug went unnoticed. As far as I can tell, `null` does not convey additional information in the stream. 

> I thought writing in Kotlin requires one to explicitly forfeit non-nullness. 

It's not necessarily the case if Java types are correctly annotated.
   =||= @akarnokd Is there any reason why return type of `Function` interface is not annotated with `@NonNull`? `BiFunction` and `Function3` - `Function9` return types are annotated with `@NonNull`. Does it break some contract? =||= Nulls that can't end up in a sequence are allowed, for example, in `groupBy` key selector and `distinct` selector. =||= > Nulls that can't end up in a sequence are allowed, for example, in groupBy key selector and distinct selector.

What do you think about creating annotation `@ReturnsNonNull` and annotate all `Function` interface usages where the nullable value is not allowed? Unfortunately, it will require changes in static analysis tools. Another option is to create `NonNullFunction` interface with `@NonNull` return type but imho breaking API to fix this isn't worth it. =||= Java 6 doesn't allow annotating type arguments that way. You'd need to break binary compatibility to introduce all combinations of possible nullness to the interfaces and use sites. =||= ,0
5161,4853,2.x: switchMapSingle and switchMapCompletable,Hey,

the addition of `flatMapSingle`/`flatMapCompletable` made the usage of `Single` and `Completable` way nicer in RxJava 2.
Do you consider adding `switchMapSingle`/`switchMapCompletable` to RxJava 2 as well?

Cheers,You mean 1.x? I have no plans for that and I don't want to keep 1.x alive for too long. I'd like to stop enhancing 1.x in 6 months and enter it into a bugfix-only mode. Otherwise 3rd party libraries may delay their upgrade way longer.
 =||= He wants `switchMapSingle` and `switchMapCompletable` for RxJava 2 just like there is `flatMapSingle` and `flatMapCompletable`
 =||= @vanniktech exactly
 =||= Ah right. No plans for extending any other xMap operator
 =||= But then `concatMap` also needs the variants in order to be consistent. To be honest I forgot about those when proposing `flatMapSingle / flatMapCompletable / flatMapMaybe` initially - #4667 

And then there's also `Maybe`. Plus `Observable` and `Flowable` are able of mapping so it's easily another 12 methods.
- Observable.switchMapSingle
- Observable.switchMapMaybe
- Observable.switchMapCompletable
- Observable.concatMapSingle
- Observable.concatMapMaybe
- Observable.concatMapCompletable
- Flowable.switchMapSingle
- Flowable.switchMapMaybe
- Flowable.switchMapCompletable
- Flowable.concatMapSingle
- Flowable.concatMapMaybe
- Flowable.concatMapCompletable
 =||= If it is not on the roadmap because you don't want to add any more xMap operators, then I understand.

But if it is due to lack of the time, would you consider accepting contributions on the topic?
 =||= Sure, but these operators are not easy.
 =||= Yes, I know, those are one of the hardest. 
Still, I will at least have a look and see if I can deliver a PR.

Cheers!
 =||= Any progress on this? =||= I'm happy to have a look at this one if @tomaszpolanski doesn't have time at the moment. =||= @davidmoten It would be great! My available time now is pretty limited.  =||= So the list of new operators is quite big. Currently:

* Observable.switchMapSingle
* Observable.switchMapMaybe
* Observable.switchMapCompletable
* Observable.concatMapSingle
* Observable.concatMapMaybe
* Observable.concatMapCompletable
* Flowable.switchMapSingle
* Flowable.switchMapMaybe
* Flowable.switchMapCompletable
* Flowable.concatMapSingle
* Flowable.concatMapMaybe
* Flowable.concatMapCompletable

I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one. An example would be `Observable.switchMapSingle`:

```java
public final <R> Observable<R> switchMapSingle(
    final Function<? super T, ? extends SingleSource<? extends R>> mapper) {
        Function<? super T, Observable<R>> mapper2 = t -> 
            {
                SingleSource<? extends R> source = mapper.apply(t);
                Single<? extends R> single;
                if (source instanceof Single) {
                    single = (Single<? extends R>) source;
                } else {
                    single = Single.unsafeCreate(source);
                }
               return (Observable<R>) single.toObservable();
            };
        return switchMap(mapper2, bufferSize());
    }
```

This is just to demo the idea, I wouldn't use an anonymous class and lambdas are just used for readability.

@akarnokd any interest in this?
 =||= > I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one.

Indeed.

> An example would be

If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in `io.reactivex.internal.operators.flowable.FlowableInternalHelper` and its respective variants.

> any interest in this?

I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted. =||= >If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in io.reactivex.internal.operators.flowable.FlowableInternalHelper and its respective variants.

Yep no problems. I've appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too.

>I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted.

Sure. I'll proceed with PRs with unit tests for the new operators and I'm happy to have a stab at dedicated operators after that. =||= What is expected behaviour for `Observable.switchMapMaybe` and `Observable.switchMapCompletable`? I can try to take care of it but I am not convinced what that method should return.
 =||= In the mean time, would it be correct to assume that an acceptable workaround for this is as follows?: **.toObservable()**

```
upstream.concatMap {
        someObservable().collect{...}.toObservable()
    }
``` =||= @feresr 
Probably yes, at this moment in few places inside my code i have this type of stucture. It is very weird and uncessesery code but it is understandable.
@akarnokd 
What do you think about method switchMapCompletable which emit Object or maybe some enum? On the other hand we can we can swallow information about stream and do not emit anything. =||= @marcinsus I don't fully understand your question. Use `switchMapCompletable().andThen(Single)` to emit something after the switch completed. =||= The problem he talks about is that switchMapCompletable does not exist. 

switchMapSingle returns an Observable of the Single type.

So technically switchMapCompletable should return Void. (Which it can't, because that has no instance.) So he asks if the signature should rather expose some `enum Nothing` or just an `Object` =||= An `Observable.switchMapCompletable` should return `Completable`. =||= You are right as `flatMapCompletable` returns a `Completable`.

But now I find it weird that 
`Observable.flatMapSingle<T>`returns an `Observable<T>`
but 
`Observable.flatMapCompletable` returns an `Completable`. =||= A stream of 5 elements flatMap'd to a stream of a single element still results in a stream of 5 elements. =||= I'm working on implementing `concatMapCompletable` across the reactive types.

I'm wondering if the library should also have implementations of
`concatMapDelayErrorCompletable`, `concatMapEagerCompletable`, `concatMapEagerDelayErrorCompletable`?


 =||= `concatMapEagerCompletable` is indistinguishable from `flatMapCompletable` because all sources run concurrently and their only output is a terminal event; no items have to be buffered until their turn. Also the `maxConcurrency == 1` gets you `concatMapCompletable` behavior. =||= Ahh yes that makes sense.  

So is there any reason to implement `concatMapCompletable` at all?  If so do you want it to just use flatMapCompletable() internally or should there be a new direct implementation (what I've been working on)? =||= Actually, `Observable.flatMapCompletable` doesn't have `maxConcurrency` overload thus there might be a reason to implement `concatMapCompletable`. =||= Ok I'll keep at it then =||= https://github.com/ReactiveX/RxJava/issues/4853#issuecomment-281541715

Did anything ever come of this?  =||= #5161 and #5649 added some operators. =||= So there are plans to implement the other operators, but not in any particular timeframe? =||= The listed operators can simply expressed with the existing default operators and `toObservable`/`toFlowable` in the lambda parameters. Unfortunately, very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function. Imagine, you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code. Kotlin's extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the RxJava library. The issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer, I'm not particularly interested myself in tackling these types of operators. =||= Closing via #5870, #5871, #5872, #5873, #5875. =||= ,0
5163,5160,2.x: Disposable returned from Single.subscribe() is not disposed after terminal event,When using Single.subscribe(onSuccess, onError) , the returned Disposable is not disposed after terminal event. However , for Observable, Flowable, Maybe and Completable , the results are all disposed.

Here is the test code: 
```java
@Test
public void testDisposable() throws Exception {

	Disposable disposable;

	disposable = Single.just(1).subscribe(
		next -> System.out.println("Single Success"),
		error -> System.out.println("Single Error")
	);

	System.out.println("Single Disposed: " + disposable.isDisposed());

	disposable = Observable.just(1).subscribe(
		next -> System.out.println("Observable Next"),
		error -> System.out.println("Observable Error"),
		() -> System.out.println("Observable Complete")
	);

	System.out.println("Observable Disposed: " + disposable.isDisposed());
}
```

Output:
```
Single Success
Single Disposed: false

Observable Next
Observable Complete
Observable Disposed: true
```

I found the Disposeable not lazySet to DISPOSED in  ConsumerSingleObserver compared with LambdaObserver. Is this a bug or there are some special reasons to do this?


```java
ConsumerSingleObserver

@Override
public void onSuccess(T value) {
	try {
		onSuccess.accept(value);
	} catch (Throwable ex) {
		Exceptions.throwIfFatal(ex);
		RxJavaPlugins.onError(ex);
	}
}
```

```java
LambdaObserver

@Override
public void onComplete() {
	if (!isDisposed()) {
		lazySet(DisposableHelper.DISPOSED);
		try {
			onComplete.run();
		} catch (Throwable e) {
			Exceptions.throwIfFatal(e);
			RxJavaPlugins.onError(e);
		}
	}
}
```

RxJava 2.0.6,Thanks for reporting. It looks like a simple oversight since the tests pass when I add the `lazySet`s. See #5163. =||= Closing via #5163. =||= Hello,

I am unable to understand the conclusion here. Is disposable supposed to be auto-disposed for Single? I wrote some code and i see it is not disposed. Is it the right behavior? =||= This issue has been closed and the fix has been available for a year now. What test did you write against which version? =||= Sorry I have been testing it wrong. My bad!. Thanks for quick response though. :)

 =||= ,0
5174,5150,2.x: eliminate all anyonymous inner classes,Currently, mostly the base reactive classes have been cleared of anonymous inner classes. Still, many stacktraces contain `SomeClass$1$2` that makes it difficult to figure out what that exact component was without having an IDE open.

I don't know if IDEs allow searching for anonymous inner classes and/or highlight them like warnings, thus the a reasonable way would be to scan the build directory for files containing the `$` pattern.

In addition, if there is an agreement, a new style-validation unit test could be added that does the same scanning at unit test time (ignoring `SomeClassTest`s) and warning/failing the build if any of such files was found.

PR welcome.,IntelliJ has "search structurally" function with predefined search for anonymous classes (`search structurally` -> `copy existing template` -> `anonymous classes`)
Also it's possible to create inspection from search. See `Preferences` -> `Editor` -> `Inspections` -> `General` -> `Structural Search Inspection` =||= Thanks. It shows about 115 places under `src/main/java`. =||= Hey guys, the issue is tagged with "PR welcome", so `i started working on it and removed all of them. Getting test errors due to naming violations. Early feedback is appreciated. https://github.com/SleimanJneidi/RxJava/tree/remove-anonymous-inner-classes =||= Hi and thanks for tackling this. See #5159 where I can comment on specific issues. =||= Looks like there are a bunch of copy-paste errors and the test hangs due to some unexpected code changes. I suggest you start over piece by piece and verifying after each java file the tests still pass. =||= Done. =||= ,0
5177,5150,2.x: eliminate all anyonymous inner classes,Currently, mostly the base reactive classes have been cleared of anonymous inner classes. Still, many stacktraces contain `SomeClass$1$2` that makes it difficult to figure out what that exact component was without having an IDE open.

I don't know if IDEs allow searching for anonymous inner classes and/or highlight them like warnings, thus the a reasonable way would be to scan the build directory for files containing the `$` pattern.

In addition, if there is an agreement, a new style-validation unit test could be added that does the same scanning at unit test time (ignoring `SomeClassTest`s) and warning/failing the build if any of such files was found.

PR welcome.,IntelliJ has "search structurally" function with predefined search for anonymous classes (`search structurally` -> `copy existing template` -> `anonymous classes`)
Also it's possible to create inspection from search. See `Preferences` -> `Editor` -> `Inspections` -> `General` -> `Structural Search Inspection` =||= Thanks. It shows about 115 places under `src/main/java`. =||= Hey guys, the issue is tagged with "PR welcome", so `i started working on it and removed all of them. Getting test errors due to naming violations. Early feedback is appreciated. https://github.com/SleimanJneidi/RxJava/tree/remove-anonymous-inner-classes =||= Hi and thanks for tackling this. See #5159 where I can comment on specific issues. =||= Looks like there are a bunch of copy-paste errors and the test hangs due to some unexpected code changes. I suggest you start over piece by piece and verifying after each java file the tests still pass. =||= Done. =||= ,0
5181,5172,1.2.7: replay(1).refCount() keeps latest value in memory even after everyone unsubscribes,Code sample:

```java
public class MainActivity extends AppCompatActivity {

    private Observable<Object> testObservable;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        testObservable = Observable.fromCallable(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                return new VeryBigObject();
            }
        })
        .replay(1)
        .refCount();

        //first subscription - callable and creation of VeryBigObject will be called
        Subscription subscription1 = testObservable.subscribe();
        //second subscription - cached value in OperatorReplay in onNext
        Subscription subscription2 = testObservable.subscribe();
        //first unsubscribe - cached value still in OperatorReplay as we have at least 1 subscriber for refCount
        subscription1.unsubscribe();
        //second unsubscribe - there are no subscribers so my guess is that there should be no cached value in OperatorReplay
        //as no one needs that object
        subscription2.unsubscribe();
        //but after everyone unsubscribe there is a reference to VeryBigObject
    }

    public static class VeryBigObject {
        //it's very big
    }

}
```

Problem: if I'm storing in field any Observable that contains replay(1).refCount() then this field will store hard reference to that latest value stored in replay buffer even if there are no subscriptions to that replay. This value takes memory and it is not good but maybe it's as-design. Also I think that this bug is actual for any replay(***) of any observables chain that have such operator.

Why am I sad: usually I use such construction to not calculate or get from disc some shared single-instance object so if there are at least one subscriber so that object is calculating on subscribe and other subscribers won't call calculation on subscribe but take already calculated value. 

Reference to VeryBigObject

        from `MainActivity` - this (root) object
        from `testObservable (Observable)` - field of MainActivity object stores Observable with replay
        from `onSubscribe (OnSubscribeRefCount)` - field of testObservable stores refCount()
        from `source (OperatorReplay)` - field of OnSubscribeRefCount stores ConnectableObservable of replay()
         from `current (AtomicReference)` - reference to current subscriber, it is only changing to not-null in connect() of OperatorReplay
         from `value (OperatorReplay$ReplaySubscriber)` - value of AtomicReference
         from `buffer (OperatorReplay$SizeBoundReplayBuffer)` - linked list of replay values with limit=1. after everyone unsubscribe it has size=2 index=2
         from `value (OperatorReplay$Node)` - head node of linked list - it's own node value (not from AtomicReference field) is null
         from `value (OperatorReplay$Node)` - next element of linked list from head - it stores VeryBigObject
         from `value (VeryBigObject)` - latest value of replay(1) before everyone unsubscribe,Try with `onTerminateDetach` before the `replay()`. =||= @akarnokd `onTerminateDetach` not helping :(
- without detach it is `SingleDelayedProducer` in `producer` field of `OperatorReplay$ReplaySubscriber` and it have reference to `OperatorReplay$ReplaySubscriber` in `child` field;
- with detach it is `OnSubscribeDetach$DetachProducer` in `producer` field and there is no reference from that but there is still reference from `value->current->source->onSubscribe->testObservable`;

I mean I think problem is that on creation before someone subscribed there was `null` value of `OperatorReplay->current` but after everyone unsubscribed `OperatorReplay` didn't back to initial state with `null` in that field so it continue holding reference to  `OperatorReplay$ReplaySubscriber` that was created on first subscription. and in `OperatorReplay$ReplaySubscriber` there is a buffer with leaked objects

if it could help there are heap .hprof files: (look for class `test.activities.MainActivity$VeryBigObject`)
- heap with `onTerminateDetach`: https://www.dropbox.com/s/5swiv6lk9oh8cnj/with_detach_2017.03.11_18.57.hprof?dl=0
- heap without `onTerminateDetach`: https://www.dropbox.com/s/j8hzxs7drqagxcr/without_detach_2017.03.11_18.5.hprof?dl=0

now few comments about `onTerminateDetach` - I saw it in discussion https://github.com/ReactiveX/RxJava/issues/4494 before.
and my opinion that `onTerminateDetach` won't help in described situation because on subscription of `replay()` it should subscribe to previous observable so it should be stored in `source` and if it is `Observable.just(millionValues)` then it should store `millionValues` to emit them to subscribers.
and I think if someone don't want to store it in memory then they could just use

`Observable.fromCallable(()->Observable.just(millionValues)).switchMap(justObservable->justObservable).last().replay()`
 or use
`Observable.switchOnNext(Observable.fromCallable(()->Observable.just(millionValues))).last().replay()` =||= I see. Could you do a final test: use `onTerminateDetach()` after `refCount()` as well (so 2 of them total) and make sure the `Subscription`s are nulled out before you take a heap dump? =||= code and 4 dumps: line 30 (1_before_first_subscribe), line 32 (2_after_second_subscribe), line 34 (3_after_second_unsubscribe) and 4_after_on_create
https://www.dropbox.com/sh/y77sjnhu6smlxfp/AACq2WyFLqqsQTIgrw0aNnNBa?dl=0 =||= In number 4. All I see is a small heap with barely anything in it:

![image](https://cloud.githubusercontent.com/assets/1269832/23825647/bcdb270a-068d-11e7-8257-c0090b64956a.png)


![image](https://cloud.githubusercontent.com/assets/1269832/23825643/ad14097c-068d-11e7-8a47-0b65c8c566fb.png)
 =||= Don't think that profiler thinks that it is a problem until I'll put `byte[1000000]` or something like that inside `VeryBigObject`
But problem is that in number 4 there is strong reference to `VeryBigObject` and in number 1 there is no such reference

![title](http://puu.sh/uElmV/90cf51abbe.png) =||= See #5181 for the fix. =||= Closing via #5181 & #5182. =||= thanks. fixed :D sry for late response =||= ,0
5182,5172,1.2.7: replay(1).refCount() keeps latest value in memory even after everyone unsubscribes,Code sample:

```java
public class MainActivity extends AppCompatActivity {

    private Observable<Object> testObservable;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        testObservable = Observable.fromCallable(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                return new VeryBigObject();
            }
        })
        .replay(1)
        .refCount();

        //first subscription - callable and creation of VeryBigObject will be called
        Subscription subscription1 = testObservable.subscribe();
        //second subscription - cached value in OperatorReplay in onNext
        Subscription subscription2 = testObservable.subscribe();
        //first unsubscribe - cached value still in OperatorReplay as we have at least 1 subscriber for refCount
        subscription1.unsubscribe();
        //second unsubscribe - there are no subscribers so my guess is that there should be no cached value in OperatorReplay
        //as no one needs that object
        subscription2.unsubscribe();
        //but after everyone unsubscribe there is a reference to VeryBigObject
    }

    public static class VeryBigObject {
        //it's very big
    }

}
```

Problem: if I'm storing in field any Observable that contains replay(1).refCount() then this field will store hard reference to that latest value stored in replay buffer even if there are no subscriptions to that replay. This value takes memory and it is not good but maybe it's as-design. Also I think that this bug is actual for any replay(***) of any observables chain that have such operator.

Why am I sad: usually I use such construction to not calculate or get from disc some shared single-instance object so if there are at least one subscriber so that object is calculating on subscribe and other subscribers won't call calculation on subscribe but take already calculated value. 

Reference to VeryBigObject

        from `MainActivity` - this (root) object
        from `testObservable (Observable)` - field of MainActivity object stores Observable with replay
        from `onSubscribe (OnSubscribeRefCount)` - field of testObservable stores refCount()
        from `source (OperatorReplay)` - field of OnSubscribeRefCount stores ConnectableObservable of replay()
         from `current (AtomicReference)` - reference to current subscriber, it is only changing to not-null in connect() of OperatorReplay
         from `value (OperatorReplay$ReplaySubscriber)` - value of AtomicReference
         from `buffer (OperatorReplay$SizeBoundReplayBuffer)` - linked list of replay values with limit=1. after everyone unsubscribe it has size=2 index=2
         from `value (OperatorReplay$Node)` - head node of linked list - it's own node value (not from AtomicReference field) is null
         from `value (OperatorReplay$Node)` - next element of linked list from head - it stores VeryBigObject
         from `value (VeryBigObject)` - latest value of replay(1) before everyone unsubscribe,Try with `onTerminateDetach` before the `replay()`. =||= @akarnokd `onTerminateDetach` not helping :(
- without detach it is `SingleDelayedProducer` in `producer` field of `OperatorReplay$ReplaySubscriber` and it have reference to `OperatorReplay$ReplaySubscriber` in `child` field;
- with detach it is `OnSubscribeDetach$DetachProducer` in `producer` field and there is no reference from that but there is still reference from `value->current->source->onSubscribe->testObservable`;

I mean I think problem is that on creation before someone subscribed there was `null` value of `OperatorReplay->current` but after everyone unsubscribed `OperatorReplay` didn't back to initial state with `null` in that field so it continue holding reference to  `OperatorReplay$ReplaySubscriber` that was created on first subscription. and in `OperatorReplay$ReplaySubscriber` there is a buffer with leaked objects

if it could help there are heap .hprof files: (look for class `test.activities.MainActivity$VeryBigObject`)
- heap with `onTerminateDetach`: https://www.dropbox.com/s/5swiv6lk9oh8cnj/with_detach_2017.03.11_18.57.hprof?dl=0
- heap without `onTerminateDetach`: https://www.dropbox.com/s/j8hzxs7drqagxcr/without_detach_2017.03.11_18.5.hprof?dl=0

now few comments about `onTerminateDetach` - I saw it in discussion https://github.com/ReactiveX/RxJava/issues/4494 before.
and my opinion that `onTerminateDetach` won't help in described situation because on subscription of `replay()` it should subscribe to previous observable so it should be stored in `source` and if it is `Observable.just(millionValues)` then it should store `millionValues` to emit them to subscribers.
and I think if someone don't want to store it in memory then they could just use

`Observable.fromCallable(()->Observable.just(millionValues)).switchMap(justObservable->justObservable).last().replay()`
 or use
`Observable.switchOnNext(Observable.fromCallable(()->Observable.just(millionValues))).last().replay()` =||= I see. Could you do a final test: use `onTerminateDetach()` after `refCount()` as well (so 2 of them total) and make sure the `Subscription`s are nulled out before you take a heap dump? =||= code and 4 dumps: line 30 (1_before_first_subscribe), line 32 (2_after_second_subscribe), line 34 (3_after_second_unsubscribe) and 4_after_on_create
https://www.dropbox.com/sh/y77sjnhu6smlxfp/AACq2WyFLqqsQTIgrw0aNnNBa?dl=0 =||= In number 4. All I see is a small heap with barely anything in it:

![image](https://cloud.githubusercontent.com/assets/1269832/23825647/bcdb270a-068d-11e7-8257-c0090b64956a.png)


![image](https://cloud.githubusercontent.com/assets/1269832/23825643/ad14097c-068d-11e7-8a47-0b65c8c566fb.png)
 =||= Don't think that profiler thinks that it is a problem until I'll put `byte[1000000]` or something like that inside `VeryBigObject`
But problem is that in number 4 there is strong reference to `VeryBigObject` and in number 1 there is no such reference

![title](http://puu.sh/uElmV/90cf51abbe.png) =||= See #5181 for the fix. =||= Closing via #5181 & #5182. =||= thanks. fixed :D sry for late response =||= ,0
5189,5185,2.x concatMapEager should accept 0 for prefetch,The documentation for `concatMapEager` states:
```java
@param prefetch hints about the number of expected source sequence values
```

Which leads me to assume that the following code should work:
```java
Observable.fromIterable(someCollection)
    .concatMapEager(this::performTask, 5, someCollection.size())
```

but it will fail if the collection is empty. Either the documentation should be updated to reflect that 0 is not a valid value or it should accept 0 (and perhaps set it to a default value internally).,Looks like there is a missing validation there as well. PR welcome. Plus, the parameter document should read something like:

`hints about the number of expected values from each inner ObservableSource` =||= On a second look, this is not a bug in the operator but perhaps the underdocumentation. Prefetch of 0 or negative has no meaning and if you think there won't be any value, use 1 as the prefetch amount. =||= Closing via #5189. =||= ,0
5195,5165,1.x: UnicastSubject does not replay onNext calls made prior to subscription if onError is also called prior to subscription.,I'm using RxJava 1.2.5. Consider this code:
```java
    UnicastSubject<String> s = UnicastSubject.create();
    s.onNext("1");
    s.onNext("2");
    s.onError(new Exception("uh oh"));
    s.subscribe(System.out::println, System.out::println);
```
This outputs:
java.lang.Exception: uh oh

However, the same code using RxJava 2.0.7 version of `UnicastSubject` outputs:
1
2
java.lang.Exception: uh oh

Which is the behavior I expected from 1.x.,Hi. In RxJava 1.x the UnicastSubject is fail-fast and in 2.x it is delay-error. Currently, there is no option for the other mode in either major version. =||= @akarnokd Ah, I see. Thanks for the clarification. Is that documented somewhere that I'm missing? The UnicastSubject docs for 1.x gave me the impression that all events will get replayed once it's subscribed to, regardless of whether or not there's an error event. I also didn't find it mentioned in the "What's Different in 2.0" wiki.

Also, I noticed you added the "PR welcome" label - Are you looking for PRs that add a way to optionally (and not by default) switch to the currently unsupported mode for each major version? Meaning, add a way to delay-error on 1.x and/or a way to fail-fast on 2.x. =||= > I also didn't find it mentioned in the "What's Different in 2.0" wiki.

This change was likely simply overlooked.

> added the "PR welcome" label

Yes. Keep the current defaults in each version and add two factory methods:

```java
public static <T> UnicastSubject<T> create(boolean delayError) {
    // ...
}
public static <T> UnicastSubject<T> create(int bufferSize, 
        Runnable onTerminate, boolean delayError) {
    // ...
}
``` =||= @akarnokd Got it, thanks. =||= Closing via #5195, #5217 and #5226. =||= ,0
5199,5154,2.x: ParallelFlowableTest > parallelismAndPrefetchAsync FAILED,```
io.reactivex.parallel.ParallelFlowableTest > parallelismAndPrefetchAsync FAILED
    java.lang.AssertionError: Value counts differ; Expected: 1048576, Actual: 619054 (latch = 1, values = 619054, errors = 0, completions = 0)
        at io.reactivex.observers.BaseTestConsumer.fail(BaseTestConsumer.java:146)
        at io.reactivex.observers.BaseTestConsumer.assertValueCount(BaseTestConsumer.java:443)
        at io.reactivex.parallel.ParallelFlowableTest.parallelismAndPrefetchAsync(ParallelFlowableTest.java:741)
```

Could be due to timeout on an overworked container instance.

Also the `BaseTestConsumer` may be extended to:

  - print the cancellation status which `awaitDone` sets
  - make `awaitDone` add an `onError` (requires synchronising the errors list) or a separate timeout flag that get's also printed.,Closing via #5199 =||= ,0
5199,5179,2.x: io.reactivex.completable.CompletableTest > doOnErrorNoError FAILED,```
io.reactivex.completable.CompletableTest > doOnErrorNoError FAILED
    org.junit.runners.model.TestTimedOutException: test timed out after 1000 milliseconds
```,Closing via #5199 =||= ,0
5202,5128,2.x: resilience in the parallel() operators,When the architecture of the `parallel()` subsystem was designed, the goal was to provide means for efficient parallel computations over recovering from failures in any or most of the parallel 'rails' in it. This resulted fail-fast implementation and little to no means (beyond `flatMap`) to prevent the death of the whole parallel computation due to a single failing component.

Adding the usual `onErrorResumeNext` or `retry` doesn't work because the core driver, `parallel()` can't support resubscription on its individual rails and even if, a failure behind a `runOn` almost certainly would drop any unprocessed elements in its queue.

The given toolset, `ParallelFlowable` already gives the opportunity to include resilience at the cost of overhead: `flatMap` and/or `concatMap`. As with the traditional flows, the inner `Flowable`s to these can have all sorts of operators not available on `parallel()` itself and are confined to the particular 'rail', thus `retry()`/`onErrorResumeNext` can be applied on a per item basis:

```java
Flowable.range(1, 100)
.parallel(20)
.runOn(Schedulers.io())
.concatMap(index -> api.getImage(index).onErrorResumeNext(Flowable.just(notAvailableImage)))
.sequential()
.observeOn(guiThread)
.subscribe(...)
```

On the other hand, parallel-`map`/`doOnNext` (among others) don't offer any ignore/resume option out of box and unless the developer applies `try-catch` to prevent crashing the 'rail'.

To enable finer gained control in this situation, I propose the following overloads:

- `enum FailureHandling`: stop, error, skip, retry
- `map(Function<T, R>, FailureHandling)`
- `map(Function<T, R>, Function<Throwable, FailureHandling>)`
- `filter(Predicate<T>, FailureHandling)`
- `filter(Predicate<T>, Function<Throwable, FailureHandling>)`
- `doOnNext(Action<T>, FailureHandling)`
- `doOnNext(Action<T>, Function<Throwable, FailureHandling>)`

They should cover the the cases where the `Function` hosts a blocking call (if there was a need for timed backoff, the `concatMap` approach is still available).

Thoughts?,Closing via #5202. =||= ,0
5207,5203,Is delaySubscription() interrupts the thread immediately as expected?,I ran the below test code with RxJava 2.0.7 and got a failure which succeeded with RxJava 1.x.

```java
    final TestObserver<Boolean> observer = TestObserver.create();
    Observable.<Boolean>create(emitter -> {
      emitter.onNext(Thread.interrupted());
      emitter.onComplete();
    })
        .delaySubscription(100, TimeUnit.MICROSECONDS)
        .subscribe(observer);
    observer.awaitTerminalEvent();
    observer.assertValue(false);
  }
```

If I put `subscribeOn()` before `delaySubscription()`, it does not fail.

I am not sure if it is as expected so want to know if it is the expected behaviour.

Here is some background of my issue: I am using RxJava 2.0.7 with Retrofit 2.2.0 and it seems Retrofit (precisely speaking, Okio, which is being used in OkHttp) throws an error when the thread is interrupted while it tries to read the HTTP response. I am trying to delay the HTTP call to achieve something like debounce() with delaySubscription() operator and encountered this issue. I have a workaround so just want to know if it is the expected behaviour.

Thank you for your support in advance.,This is an unexpected side-effect of cancelling the delay timer inside the `delaySubscription` operator. I'll post a fix for it shortly. =||= See #5207. =||= Thank you for your prompt work on this. Waiting for the next release including this fix. =||= Closing via #5207. =||= ,0
5208,5130,2.x: incorrect images,This is a container for identifying and tracking fixes to outdated or incorrent marble diagrams.

  - [x] [Single.flattenAsFlowable](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html#flattenAsFlowable(io.reactivex.functions.Function)): refers to flatMapIterable, no reordering of colors
  - [x] [Single.flattenAsObservable](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html#flattenAsObservable(io.reactivex.functions.Function)): refers to flatMapIterable, no reordering of colors
  - [x] [Flowable.flatMapIterable](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#flatMapIterable(io.reactivex.functions.Function)) + 4 no reordering of colors
  - [x] [Observable.flatMapIterable](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#flatMapIterable(io.reactivex.functions.Function)) + 2 no reordering of colors
  - [x] [Flowable.firstElement()](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#firstElement()), indicate cancellation after the first element, shift marbles so the 2nd element doesn't imply the completion like in `singleOrError`.
  - [x] [Observable.firstElement()](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#firstElement()), indicate cancellation after the first element, shift marbles so the 2nd element doesn't imply the completion like in `singleOrError`.,![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstElement.m.png)

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.s.png) =||= ![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsFlowable.png)

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsObservable.png) =||= ![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png)

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.o.png)

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.r.png)

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.o.r.png) =||= Closing. I think its better to track new findings and their fixes in separate issues. =||= ,0
5210,5148,2.x: improve documentation of the default consumer types,Describe their single-use nature. Explicitly mention `onStart`. Explicitly mention `dispose` or `cancel`. Maybe add code examples.

  - [x] `DisposableSubscriber`
  - [x] `DisposableCompletableObserver`
  - [x] `DisposableMaybeObserver`
  - [x] `DisposableSingleObserver`
  - [x] `DisposableObserver`
  - [x] `ResourceSubscriber` (also remove mention of `AsyncObserver`).
  - [x] `ResourceCompletableObserver`
  - [x] `ResourceMaybeObserver`
  - [x] `ResourceSingleObserver`
  - [x] `ResourceObserver`,See #5210. =||= Closing via #5210 =||= ,0
5213,5104,2.x : window(timespan, unit, count) always emit empty observable if not reach max count,This code will print nothing all the time.

```java
PublishSubject<String> vehicleToFetch = PublishSubject.create();
        vehicleToFetch
                .delay(2,TimeUnit.SECONDS)
                .window(10, TimeUnit.SECONDS, 5)
                .observeOn(Schedulers.io())
                .subscribe(w-> w.toList().subscribe(ws-> {
                    ws.forEach(v -> {
                        System.out.println(String.format("%s %d", v, Thread.currentThread().getId()));
                        vehicleToFetch.onNext(v);
                    });
                }));


        Observable.just("v1","v2","v3","v4")
                .subscribe(v->{
                    vehicleToFetch.onNext(v);
                });

```

I am using rxjava:2.0.6.,There are two problems with your code:

- You are using `toList` which requires a finite stream. Since you don't call `onComplete` on `vehicleToFetch` the sequence above won't print anything.
- You are probably not waiting long enough to see the results. The default RxJava schedulers are daemon threads and when the "main" thread ends, the whole application stops.

```java
PublishSubject<String> vehicleToFetch = PublishSubject.create();
vehicleToFetch
        .delay(2,TimeUnit.SECONDS)
        .window(10, TimeUnit.SECONDS, 5)
        .observeOn(Schedulers.io())
        .subscribe(w-> w.toList().subscribe(ws-> {
            ws.forEach(v -> {
                System.out.println(String.format("%s %d", v, Thread.currentThread().getId()));
                vehicleToFetch.onNext(v);
            });
        }));


Observable.just("v1","v2","v3","v4").subscribe(vehicleToFetch);

Thread.sleep(3000);
``` =||= @akarnokd Thanks.  I am calling `toList()` on a window observable ,not on `vehicleToFetch`, There is print if I change ` .window(10, TimeUnit.SECONDS, 5)` to `.window(10, TimeUnit.SECONDS, 4)`.

I am using a `CountDownLatch`(not show in code) to wait a long time. =||= Yes, because the window with limit 4 will call `onComplete` for you on the window that `toList()` consumes. With 5 there is noone to call `onComplete`. If you had a "v5" in that case, you'd see the printout again. =||= Why did it not call `onComplete` when the timeout is reached?  Does not this method mean either timeout or max count is reach will emit a window?  =||= Oh, I see it now. There is a bug in the operator that doesn't complete the old window if a new one is due to the timeout. I'll post a fix for it. =||= Closing via #5106. =||= It  worked after upgrade to 2.0.7,  but after three times timeout, there is no timeout anymore. =||= Do you have a new unit test for it? =||= You can use the same code , it will block after three new window emitted. =||= Odd. I'll look into it again. =||= Found a couple of remaining issues. See PR #5213; the example works with it properly for me. =||= ,0
5217,5165,1.x: UnicastSubject does not replay onNext calls made prior to subscription if onError is also called prior to subscription.,I'm using RxJava 1.2.5. Consider this code:
```java
    UnicastSubject<String> s = UnicastSubject.create();
    s.onNext("1");
    s.onNext("2");
    s.onError(new Exception("uh oh"));
    s.subscribe(System.out::println, System.out::println);
```
This outputs:
java.lang.Exception: uh oh

However, the same code using RxJava 2.0.7 version of `UnicastSubject` outputs:
1
2
java.lang.Exception: uh oh

Which is the behavior I expected from 1.x.,Hi. In RxJava 1.x the UnicastSubject is fail-fast and in 2.x it is delay-error. Currently, there is no option for the other mode in either major version. =||= @akarnokd Ah, I see. Thanks for the clarification. Is that documented somewhere that I'm missing? The UnicastSubject docs for 1.x gave me the impression that all events will get replayed once it's subscribed to, regardless of whether or not there's an error event. I also didn't find it mentioned in the "What's Different in 2.0" wiki.

Also, I noticed you added the "PR welcome" label - Are you looking for PRs that add a way to optionally (and not by default) switch to the currently unsupported mode for each major version? Meaning, add a way to delay-error on 1.x and/or a way to fail-fast on 2.x. =||= > I also didn't find it mentioned in the "What's Different in 2.0" wiki.

This change was likely simply overlooked.

> added the "PR welcome" label

Yes. Keep the current defaults in each version and add two factory methods:

```java
public static <T> UnicastSubject<T> create(boolean delayError) {
    // ...
}
public static <T> UnicastSubject<T> create(int bufferSize, 
        Runnable onTerminate, boolean delayError) {
    // ...
}
``` =||= @akarnokd Got it, thanks. =||= Closing via #5195, #5217 and #5226. =||= ,0
5223,5145,2.x: improve io.reactivex.schedulers.Schedulers documentation,  - [x] Better explain each scheduler type.
  - [x] Repeat system parameters for each scheduler type.
  - [x] Remove mentions of SchedulerLifecycle.
  - [x] Explain how `from` handles `Executor`, `ExecutorService` and `ScheduledExecutorService`.
  - [x] Explain getting back to the current thread requires a blocking scheduler.
  - [x] Mention the `SchedulerSupport` annotations.,See #5223. =||= Closing via #5223. =||= ,0
5225,5224,1.2.9: Completable not unsubscribe with onErrorResumeNext,I have completable that contains `merge` or `andThen`. 
Then I add `onErrorResumeNext` into sequence. In this case, If we unsubscribe the whole `subscription` when `com1` is not completed yet then `com2` won't be unsubscribed.

Code sample:
```java
        Completable com1 = Completable
                .fromAction(() -> {
                    try {
                        Thread.sleep(3000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    Log.d(TAG, "c1");
                })
                .doOnSubscribe(s1 -> Log.d(TAG, "com1 subscribe"))
                .doOnUnsubscribe(() -> Log.d(TAG, "com1 unsubscribe"));

        Completable com2 = Completable
                .fromAction(() -> {
                    try {
                        Thread.sleep(6000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    Log.d(TAG, "c2");
                })
                .doOnSubscribe(s2 -> Log.d(TAG, "com2 subscribe"))
                .doOnUnsubscribe(() -> Log.d(TAG, "com2 unsubscribe"));

        Subscription subscription =
                Completable.merge(
                        com1,
                        com2
                )
                        .subscribeOn(Schedulers.from(Executors.newSingleThreadExecutor()))
                        .onErrorResumeNext(throwable ->
                                Completable
                                        .fromAction(() -> Log.d(TAG, "error happened"))
                        )
                        .doOnSubscribe(s -> Log.d(TAG, "subscribe"))
                        .doOnUnsubscribe(() -> Log.d(TAG, "unsubscribe"))
                        .subscribe(
                                () -> Log.d(TAG, "onComplete "),
                                throwable -> Log.d(TAG, "onError " + throwable)
                        );

        Completable
                .fromAction(() -> {
                    subscription.unsubscribe();
                    Log.d(TAG,"whole subscription unsubscribe");
                })
                .delay(2, TimeUnit.SECONDS)
                .subscribe();
```
Result:
```
D: subscribe
D: com1 subscribe
D: whole subscription unsubscribe
D: c1
D: com2 subscribe
D: c2
D: onComplete 
```

Case without operator `onErrorResumeNext` :
```
D: subscribe
D: com1 subscribe
D: unsubscribe
D: com1 unsubscribe
D: whole subscription unsubscribe
D: c1
```,Closing via #5225. =||= ,0
5226,5165,1.x: UnicastSubject does not replay onNext calls made prior to subscription if onError is also called prior to subscription.,I'm using RxJava 1.2.5. Consider this code:
```java
    UnicastSubject<String> s = UnicastSubject.create();
    s.onNext("1");
    s.onNext("2");
    s.onError(new Exception("uh oh"));
    s.subscribe(System.out::println, System.out::println);
```
This outputs:
java.lang.Exception: uh oh

However, the same code using RxJava 2.0.7 version of `UnicastSubject` outputs:
1
2
java.lang.Exception: uh oh

Which is the behavior I expected from 1.x.,Hi. In RxJava 1.x the UnicastSubject is fail-fast and in 2.x it is delay-error. Currently, there is no option for the other mode in either major version. =||= @akarnokd Ah, I see. Thanks for the clarification. Is that documented somewhere that I'm missing? The UnicastSubject docs for 1.x gave me the impression that all events will get replayed once it's subscribed to, regardless of whether or not there's an error event. I also didn't find it mentioned in the "What's Different in 2.0" wiki.

Also, I noticed you added the "PR welcome" label - Are you looking for PRs that add a way to optionally (and not by default) switch to the currently unsupported mode for each major version? Meaning, add a way to delay-error on 1.x and/or a way to fail-fast on 2.x. =||= > I also didn't find it mentioned in the "What's Different in 2.0" wiki.

This change was likely simply overlooked.

> added the "PR welcome" label

Yes. Keep the current defaults in each version and add two factory methods:

```java
public static <T> UnicastSubject<T> create(boolean delayError) {
    // ...
}
public static <T> UnicastSubject<T> create(int bufferSize, 
        Runnable onTerminate, boolean delayError) {
    // ...
}
``` =||= @akarnokd Got it, thanks. =||= Closing via #5195, #5217 and #5226. =||= ,0
5247,5246,2.x: NullPointerException in FlowableToList$ToListSubscriber.onNext,Notices few of this crashes, is there any way to find from where they are coming?
```
Fatal Exception: java.lang.NullPointerException: Attempt to invoke interface method 'boolean java.util.Collection.add(java.lang.Object)' on a null object reference
       at io.reactivex.internal.operators.flowable.FlowableToList$ToListSubscriber.onNext(FlowableToList.java:71)
       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.tryOnNext(FlowableFilter.java:73)
       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.onNext(FlowableFilter.java:51)
       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapImmediate.innerNext(FlowableConcatMap.java:215)
       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapInner.onNext(FlowableConcatMap.java:592)
       at io.reactivex.internal.operators.flowable.FlowableFromIterable$IteratorSubscription.fastPath(FlowableFromIterable.java:181)
       at io.reactivex.internal.operators.flowable.FlowableFromIterable$BaseRangeSubscription.request(FlowableFromIterable.java:123)
       at io.reactivex.internal.subscriptions.SubscriptionArbiter.setSubscription(SubscriptionArbiter.java:96)
       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapInner.onSubscribe(FlowableConcatMap.java:585)
       at io.reactivex.internal.operators.flowable.FlowableFromIterable.subscribe(FlowableFromIterable.java:69)
       at io.reactivex.internal.operators.flowable.FlowableFromIterable.subscribeActual(FlowableFromIterable.java:47)
       at io.reactivex.Flowable.subscribe(Flowable.java:12901)
       at io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapImmediate.drain(FlowableConcatMap.java:343)
       at io.reactivex.internal.operators.flowable.FlowableConcatMap$BaseConcatMapSubscriber.onNext(FlowableConcatMap.java:158)
       at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.onNext(FlowableSubscribeOn.java:97)
       at io.reactivex.internal.subscriptions.DeferredScalarSubscription.complete(DeferredScalarSubscription.java:133)
       at io.reactivex.internal.operators.flowable.FlowableFromCallable.subscribeActual(FlowableFromCallable.java:44)
       at io.reactivex.Flowable.subscribe(Flowable.java:12901)
       at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run(FlowableSubscribeOn.java:82)
       at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)
       at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)
       at java.util.concurrent.FutureTask.run(FutureTask.java:237)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)
       at java.lang.Thread.run(Thread.java:761)
```,What version are you using? Could you share some code? =||= version 2.0.6
this is one of the examples
```
        Flowable<List<Team>> networkTask = Network.getUiClient().getTeams()
                .onErrorReturn(throwable -> new ArrayList<>())
                .concatMap(Flowable::fromIterable)
                .filter(team -> isValid(team))
                .toList().toFlowable();
```
 =||= I'd guess `Network.getUiClient().getTeams()` is a custom `Publisher` of some sorts because that particular exception can only happen if there is an `onNext` after an `onComplete` or `onError`. It would  be great if you could write a standalone unit test that reproduces the problem. =||= Behind ```Network.getUiClient().getTeams()``` and every other network call is Retrofit, beside that we have few database calls wraped in ```Flowable.fromCallable(db::getTeams);``` and no other custom ```Publisher```.
We see bug happening in production but we can't reproduce it and stacktrace don't give to much informations from where is coming from (Network API have ~50 endpoints).
Only thing that we know is that bug is affecting really small number of sessions. =||= There is a small race window between an `onNext()` and a `cancel()` that could cause this. I'll post a fix for this. =||= Closing via #5247. =||= ,0
5258,5249,1.x 2.x Use IDE friendly assertion failed statements ,Currently the assertItem prints by the following statements, focus on "_expected to be_"
```
private void assertItem(T expected, int i) {
        T actual = values.get(i);
        if (expected == null) {
            // check for null equality
            if (actual != null) {
                assertionError("Value at index: " + i + " expected to be [null] but was: [" + actual + "]\n");
            }
        } else if (!expected.equals(actual)) {
            assertionError("Value at index: " + i
                    + " expected to be [" + expected + "] (" + expected.getClass().getSimpleName()
                    + ") but was: [" + actual + "] (" + (actual != null ? actual.getClass().getSimpleName() : "null") + ")\n");

        }
    }
```

However, it does not match any of the IntelliJ assertion regex patterns, thus making it very difficult to visually compare expected and actual values. We forked `assertItem()` using one of the following patterns from [this](https://github.com/JetBrains/intellij-community/blob/3f7e93e20b7e79ba389adf593b3b59e46a3e01d1/plugins/testng/src/com/theoryinpractice/testng/model/TestProxy.java) and could immediately see the `<Click to see difference>` link in the IDE.,PR welcome. =||= @mtiidla is 2.x also affected? =||= @akarnokd Could you please choose the most pleasing pattern from the IntelliJ class I linked to? If you don't have any preference, then I would go with EXPECTED_BUT_WAS_PATTERN as JUnit4 is using it `"expected:<" + expected + "> but was:<" + actual + ">"`

@vanniktech The output is different, but also not recognized, for example the following code:
`Observable.just("Test").test().assertValue("test");`
produces: _Expected: test (class: String), Actual: Test (class: String)_ and there is no link presented by IntelliJ to compare the output. (I have also edited the Issue title with 2.x) =||= The JUnit pattern is fine with me. =||= ,0
5277,5276,Single's Disposable is not disposing.,I noticed that ```Disposable``` returned from ```Single::subscribe(final BiConsumer<? super T, ? super Throwable> onCallback)``` returns ```false``` from ```Disposable::isDisposed``` even after ```onCallback``` was called. Version of RxJava is 2.0.8. Code sample:
````
import io.reactivex.Single
import io.reactivex.disposables.Disposable
import io.reactivex.schedulers.Schedulers

fun main(args: Array<String>) {

    var disposable: Disposable? = null
    disposable = Single.just(34)
            .subscribeOn(Schedulers.computation())
            .observeOn(Schedulers.io())
            .subscribe { item, throwable ->
                println("1 ${disposable?.isDisposed}")
            }

    println("2 ${disposable?.isDisposed}")
    Thread.sleep(1000)
    println("3 ${disposable?.isDisposed}")

}

````

Output is:
````
2 false
1 false
3 false
````,Thanks for reporting. This is indeed an inconsistency with other methods. See #5277 for the fix. =||= Closing via #5277. =||= ,0
5296,5295,xMr/do on dispose javadoc,Thank you for contributing to RxJava. Before pressing the "Create Pull Request" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.,# [Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=h1) Report
> Merging [#5295](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=desc) into [2.x](https://codecov.io/gh/ReactiveX/RxJava/commit/5ab208308249f3387df62d1861ab04c75f0915de?src=pr&el=desc) will **increase** coverage by `<.01%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/ReactiveX/RxJava/pull/5295/graphs/tree.svg?width=650&src=pr&token=WtCc2hTjM2&height=150)](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree)

```diff
@@             Coverage Diff              @@
##                2.x    #5295      +/-   ##
============================================
+ Coverage     96.11%   96.11%   +<.01%     
- Complexity     5750     5758       +8     
============================================
  Files           628      628              
  Lines         41085    41085              
  Branches       5703     5703              
============================================
+ Hits          39487    39490       +3     
+ Misses          634      631       -3     
  Partials        964      964
```


| [Impacted Files](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree) | Coverage Δ | Complexity Δ | |
|---|---|---|---|
| [src/main/java/io/reactivex/Observable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvT2JzZXJ2YWJsZS5qYXZh) | `100% <ø> (ø)` | `506 <0> (ø)` | :arrow_down: |
| [src/main/java/io/reactivex/Completable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvQ29tcGxldGFibGUuamF2YQ==) | `100% <ø> (ø)` | `112 <0> (ø)` | :arrow_down: |
| [src/main/java/io/reactivex/Single.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvU2luZ2xlLmphdmE=) | `99.32% <ø> (ø)` | `131 <0> (ø)` | :arrow_down: |
| [src/main/java/io/reactivex/Maybe.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvTWF5YmUuamF2YQ==) | `100% <ø> (ø)` | `168 <0> (ø)` | :arrow_down: |
| [...ternal/operators/flowable/FlowableSampleTimed.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlU2FtcGxlVGltZWQuamF2YQ==) | `89.7% <0%> (-5.89%)` | `3% <0%> (ø)` | |
| [...vex/internal/subscriptions/SubscriptionHelper.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9TdWJzY3JpcHRpb25IZWxwZXIuamF2YQ==) | `94.36% <0%> (-5.64%)` | `34% <0%> (-2%)` | |
| [...in/java/io/reactivex/subjects/BehaviorSubject.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvc3ViamVjdHMvQmVoYXZpb3JTdWJqZWN0LmphdmE=) | `86.97% <0%> (-4.69%)` | `57% <0%> (+1%)` | |
| [...erators/completable/CompletableConcatIterable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlQ29uY2F0SXRlcmFibGUuamF2YQ==) | `95.91% <0%> (-4.09%)` | `2% <0%> (ø)` | |
| [...vex/internal/operators/flowable/FlowableTimer.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlVGltZXIuamF2YQ==) | `92.85% <0%> (-3.58%)` | `2% <0%> (ø)` | |
| [...x/internal/operators/maybe/MaybeSwitchIfEmpty.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL21heWJlL01heWJlU3dpdGNoSWZFbXB0eS5qYXZh) | `97.22% <0%> (-2.78%)` | `2% <0%> (ø)` | |
| ... and [34 more](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=tree-more) | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=footer). Last update [5ab2083...6c6c8f4](https://codecov.io/gh/ReactiveX/RxJava/pull/5295?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= ,0
5296,5283,Subscription not disposed after onComplete with RxJava 2.x,Hello
I am not sure this is an issue, I would rather say this is a question.
I have noticed a different behavior between RxJava 1.x and RxJava 2.x
When an observable is completed, with RxJava 1.x subscriptions get unsubscribed:
```
BehaviorSubject<Object> subject = BehaviorSubject.create();
Subscription subscription = subject.subscribe();
subject.onCompleted();
System.out.println(subscription.isUnsubscribed()); // display true
```

However with RxJava2, the subscription is not disposed when the observable is completed:
```
Disposable subscription = null;
@Test
public void test() {
    BehaviorSubject subject = BehaviorSubject.create();
    Observer<? super String> observer = new Observer<String>() {
        
        public void onSubscribe(Disposable d) {
            subscription = d;
        }

        ...
    };
    
    subject.subscribe(observer);
    subject.onComplete();
    System.out.println(subscription.isDisposed());  // display false
}
```

Is it a wanted behavior? If so is this behavior documented somewhere?
Thanks a lot for your help,Generally, if you don't dispose a disposable received via `onSubscribe` it may or may not report itself as disposed. The lambda version of the `subscribe()` does report itself disposed when it  calls the lambda for a terminal event.

In practice, there shouldn't be any reason to call `isDisposed` outside an operator or `create` method because it assumes synchronous termination, or worse, it is the reactive version of `Future.get()`.

In the reactive world, you react to termination via the appropriate onXXX method, compose in the continuation or simply side-effect via `doFinally`.

*Sidenote: One of the smaller but ever growing regret of mine is that I let `isDisposed` into the API, because I knew that will eventually trigger a bunch of inconsistency bug reports and correcting them adds more overhead. I'm glad the Reactive-Streams specification opted for no `isCancelled` method.*
 =||= Thanks a lot for your "reactivity" and your explanations!
I agree that *isCancelled* is less misleading. 
I have the feeling that I am not the only being confused: http://stackoverflow.com/questions/41826478/do-i-have-to-unsubscribe-from-completed-observable
   =||= Related question: `Observable.doOnDispose()` Javadoc mentions the following:
`"Note that terminal events trigger the action unless the {@code ObservableSource} is subscribed to via {@code unsafeSubscribe()}."`

Is this still true or should `.doFinally()`/`.doOnTerminate()` be the preferred option? =||= That's no longer true. The preferred operator is `doFinally` as it covers `onError`, `onComplete` and `dispose` as well.

Would you like to post a PR that removes that note? If so, please check the other base types for the equivalent operator as there might be copy-pasted all over the place. =||= Okay, thanks for clarifying. I can update the JavaDoc note later today. =||= ,0
5302,5300,2.x Single unsubscribeOn missing,Also, in order to match 2.x naming convertions that operator should be named `disposeOn`,Indeed that operator is missing from `Single` and available on the other types. Would you like to convert closest `MaybeUnsubscribeOn` over to it in a PR?

It is called `unsubscribeOn` for historical reasons and 
- to pair up with `subscribeOn`
- to have the same name across the types instead of `disposeOn` and `cancelOn`.

`unsubscribeOn` is the name of (concept of) the operation whereas `doOnCancel` and `doOnDispose` represent the signal types and appropriate method names within the API and as such were adjusted. =||= Thanks for fast feedback and explanation.

About PR: yes, I can do it.
However, I'm not too experienced programmer and can't promise anything about code quality and time =||= Oh, I understand. A certain code quality is expected here, plus RxJava 2.0.9 is scheduled to be released tomorrow. I'll do the PR then in a few hours. =||= Looks not too complicated. Can you give me 2-3 hours?  =||= I've done it. For exercise, see if you can do it yourself and compare it against #5302 to verify your approach. =||=  Done it same way, but without testing (oh, it's hardest thing to prove that my code works as expected) =||= ,0
5307,5243,2.1 API promotions,Planned release date: **April 29, 2017**

### Experimental to Standard

- `CheckReturnValue` (since 2.0.2)
- `Scheduler.when()` (since 2.0.1)
- `CompletableSubject` (since 2.0.5)
- `MaybeSubject` (since 2.0.5)
- `SingleSubject` (since 2.0.5)
- `TestSubscriber.requestMore()` (since 2.0.1)

#### `Completable`
- `cache()` (since 2.0.4)
- `doFinally()` (since 2.0.1)
- `hide()` (since 2.0.5)

#### `Flowable`

- `doAfterNext()` (since 2.0.1)
- `doFinally()` (since 2.0.1)
- `sample()` with emitLast option (since 2.0.5)

#### `Maybe`

- `doAfterSuccess()` (since 2.0.1)
- `doFinally()` (since 2.0.1)
- `flatMapSingleElement()` (since 2.0.2)

#### `Observable`

- `doAfterNext()` (since 2.0.1)
- `doFinally()` (since 2.0.1)
- `sample()` with emitLast option (since 2.0.5)

#### `Single`

- `doAfterSuccess()` (since 2.0.1)
- `doAfterTerminate()` (since 2.0.6)
- `doFinally()` (since 2.0.1)

#### `BaseTestConsumer`

- `assertNever()` (since 2.0.5) 2 overloads
- `assertNoTimeout()` (since 2.0.7)
- `assertTimeout()` (since 2.0.7)
- `awaitCount()` (since 2.0.7) 3 overloads
- `clearTimeout()` (since 2.0.7)
- `isTimeout()` (since 2.0.7)
- `TestWaitStrategy` (since 2.0.7)
- `withTag()` (since 2.0.7)

#### `RxJavaPlugins`

- `createComputationScheduler()` (since 2.0.5)
- `createIoScheduler()` (since 2.0.5)
- `createNewThreadScheduler()` (since 2.0.5)
- `createSingleScheduler()` (since 2.0.5)
- `getOnBeforeBlocking()` (since 2.0.5)
- `isFailOnBlockingScheduler()` (since 2.0.5)
- `onBeforeBlocking` (since 2.0.5)
- `setFailOnBlockingScheduler()` (since 2.0.5)
- `setOnBeforeBlocking()` (since 2.0.5)

### Beta to Standard

There are no components marked with `@Beta` in the 2.0.x version additions.

### Experimental to Beta

- `FlowableSubscriber` (since 2.0.7)
- `Flowable.parallel()` (since 2.0.5) 3 overloads
- `Flowable.subscribe(FlowableSubscriber)` (since 2.0.7)
- `OnErrorNotImplementedException` (since 2.0.6)
- `ProtocolViolationException` (since 2.0.6)
- `UndeliverableException` (since 2.0.6)
- `ParallelFlowable` (since 2.0.5)
- `RxJavaPlugins.getOnParallelAssembly()` (since 2.0.6)
- `RxJavaPlugins.onAssembly(ParallelFlowable)` (since 2.0.6)
- `RxJavaPlugins.setOnParallelAssembly()` (since 2.0.6)

### Leave as is

- `Observable.switchMapSingle()` (since 2.0.8 - experimental)
- `Observable.switchMapSingleDelayError()` (since 2.0.8 - experimental)
- `ParallelFailureHandling` (since 2.0.8 - experimental)
- `ParallelFlowable.doOnNext(Consumer, ParallelFailureHandling)` (since 2.0.8 - experimental)
- `ParallelFlowable.map(Consumer, ParallelFailureHandling)` (since 2.0.8 - experimental)
-` ParallelFlowable.filter(Consumer, ParallelFailureHandling)` (since 2.0.8 - experimental)
- `ParallelTransformer` (since 2.0.8 - experimental)
- `BehaviorProcessor.offer()` (since 2.0.8 - experimental)
- `PublishProcessor.offer()` (since 2.0.8 - experimental)
- `UnicastProcessor.create(boolean)` (since 2.0.8 -experimental) 2 overloads of fail-fast mode
- `UnicastSubject.create(boolean)` (since 2.0.8 -experimental) 2 overloads of fail-fast mode
- `Single.unsubscribeOn(Scheduler)` (since 2.0.9 - experimental)

### Remove

`Flowable.strict()` (since 2.0.5, deprecated in 2.0.7),What about the `@CheckReturnValue` annotation? Right now it's experimental. =||= Thanks, added to the experimental -> standard section. =||= I'd like to define what should happen with the `@since` tags and the old version number:

- the standard promotions will be updated to `@since 2.1`
- the experimental-beta promotions will be updated to `@since 2.1 - beta`
- the previous version value will be moved into just before the first param or return tag:

```java
/**
 * The operator ...
 * <p>History: 2.0.6 - experimental.
 * @param x ...
 * @since 2.1
 */
@CheckReturnValue
public final Flowable<R> operator(...)
```

This small addendum should help quickly pinpoint when certain features were added and were promoted without the need to scan through release logs, commits and PRs. =||= Closing via #5307. =||= ,0
5318,5201,1.3 API promotions,Planned release date for 1.3: **May 1st, 2017**

### Promote `Experimental` to stable:

- `rx.exceptions.AssemblyStackTraceException`
- `rx.functions.Cancellable`
- `rx.internal.observers.AssertableSubscriberObservable`
- `rx.internal.operators.FlatMapCompletable`
- `rx.internal.operators.FlatMapSingle`
- `rx.internal.schedulers.SchedulerWhen`
- `rx.internal.util.BackpressureDrainManager`
- `rx.internal.util.BlockingUtils` (the class and its single method)
- `rx.Completable.fromEmitter()`
- `rx.Completable.test()`
- `rx.CompletableEmitter`
- `rx.CompletableSubscriber`
- `rx.Emitter`
- `rx.Scheduler.when()`
- `rx.SingleEmitter`
- `rx.Single.fromEmitter`
- `rx.Single.merge(Observable<Single<T>>)` (2 overloads)
- `rx.Single.mergeDelayError(Observable<Single<T>>)` (2 overloads)
- `rx.Single.cache()`
- `rx.Single.to()`
- `rx.Single.doOnEach()`
- `rx.Single.doOnSuccess()`
- `rx.Single.test()`
- `rx.observers.AssertableSubscriber`
- `rx.observers.AsyncCompletableSubscriber`
- `rx.observers.SafeCompletableSubscriber`
- `rx.observers.TestSubscriber.getCompletions()`
- `rx.observers.TestSubscriber.awaitValueCount()`
- `rx.observers.TestSubscriber.assertValuesAndClear()`
- `rx.schedulers.Schedulers.reset()`
- `rx.plugins.RxJavaCompletableExecutionHook`
- `rx.plugins.RxJavaHooks`
- `rx.plugins.RxJavaPlugins.reset()`
- `rx.plugins.RxJavaPlugins.getCompletableExecutionHook()`
- `rx.plugins.RxJavaPlugins.registerCompletableExecutionHook()`
- `rx.plugins.RxJavaSchedulersHook.createComputationScheduler()` (2 overloads)
- `rx.plugins.RxJavaSchedulersHook.createIoScheduler()` (2 overloads)
- `rx.plugins.RxJavaSchedulersHook.createNewThreadScheduler()` (2 overloads)
- `rx.subjects.UnicastSubject`
- `rx.Observable.create(Action1<Emitter<T>>, Emitter.BackpressureStrategy)`
- `rx.Observable.unsafeCreate()`
- `rx.Observable.to()`
- `rx.Observable.zip(Observable[], FuncN)`
- `rx.Observable.flatMapCompletable()` (3 overloads)
- `rx.Observable.flatMapSingle()` (3 overloads)
- `rx.Observable.groupBy(Func1, Func1, Func1<Action1<K>, Map<K, Object>>)`
- `rx.Observable.onTerminateDetach()`
- `rx.Observable.rebatchRequests()`
- `rx.Observable.subscribeOn(Scheduler, boolean)`
- `rx.Observable.sorted()`
- `rx.Observable.sorted(Func2)`
- `rx.Observable.withLatestFrom()` (10 overloads)
- `rx.Observable.test()` (2 overloads)

### Promote `Beta` to stable:

- `rx.observable.BlockingObservable.subscribe()` (6 overloads)
- `rx.exceptions.CompositeException(Throwable...)`
- `rx.exceptions.Exceptions.throwOrReport()` (4 overloads)
- `rx.BackpressureOverflow`
- `rx.Single.onErrorResumeNext()` (3 overloads)
- `rx.Single.toCompletable()`
- `rx.Single.doOnError()`
- `rx.Single.doOnSubscribe()`
- `rx.Single.delay()` (2 overloads)
- `rx.Single.defer()`
- `rx.Single.doOnUnsubscribe()`
- `rx.Single.doAfterTerminate()`
- `rx.Single.flatMapCompletable()`
- `rx.Single.lift()`
- `rx.Single.toBlocking()`
- `rx.Single.using()` (2 overloads)
- `rx.Single.delaySubscription(Observable)`
- `rx.plugins.RxJavaErrorHandler.handleOnNextValueRendering()`
- `rx.plugins.RxJavaErrorHandler.render()`
- `rx.singles.BlockingSingle`
- `rx.Observable.toCompletable()`
- `rx.Observable.concatDelayError()` (10 overloads)
- `rx.Observable.mergeDelayError()`
- `rx.Observable.switchOnNextDelayError()`
- `rx.Observable.using(Func0, Func1, Action1, boolean)`
- `rx.Observable.concatMapDelayError()`
- `rx.Observable.delaySubscription(Observable)`
- `rx.Observable.distinctUntilChanged(Func2)`
- `rx.Observable.concatEager()` (12 overloads)
- `rx.Observable.concatMapEager()` (3 overloads)
- `rx.Observable.onBackpressureBuffer(long, Action0, BackpressureOverflow.Strategy)`
- `rx.Observable.switchMapDelayError()`
- `rx.Observable.toSortedList(int)`
- `rx.Observable.toSortedList(Func2, int)`
- `rx.observables.SyncOnSubscribe.createSingleState()` (2 overloads)
- `rx.observables.SyncOnSubscribe.createStateful()` (2 overloads)
- `rx.observables.SyncOnSubscribe.createStateless()` (2 overloads)
- `rx.Completable`


### Promote `Experimental` to `Beta`

- `rx.observable.AsyncOnSubscribe` (+ 7 of its factory methods)
- `rx.Observable.create(AsyncOnSubscribe<S, T>)`


### Leave as is

- `rx.Single.unsubscribeOn` (since 1.2.8)

### Remove `Experimental`

- `rx.Observable.fromEmitter()`,Closing via #5318. =||= ,0
5409,5382,2.x Single.delay documentation and implementation inconsistent,The documentation for Single.delay says that success or error signals will be delayed by the specified amount, but in fact errors are not delayed, only successes. I have no opinion on which one should be correct - I ran into it when mocking out the response for an incomplete backend to test a loading/error UI, e.g. `Single.error(...).delay(3, TimeUnit.SECONDS)`, and found that my errors never had a delay. It seems that Observable has both options, with a version of the method that has a boolean flag `delayError`.

https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Single.java#L1636
https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java#L66,Indeed there is no option for that in `Single` and `Maybe`. Would you like to submit a PR? =||= @akarnokd : I've submitted my first PR fixing this -> https://github.com/ReactiveX/RxJava/pull/5409 Kindly review and advice. Thanks. =||= Closing via #5409. =||= ,0
5419,5416,2.x: schedulePeriodically with non-positive period,Currently, the `Scheduler` and `Worker` API allows for non-positive periods on periodically scheduling but the underlying `ScheduledExecutorService`s don't. The javadoc doesn't specify any restrictions on period unlike `initialDelay` or `delay` where a non-positive value is considered to be an "execute without delay".

In theory, the default periodic logic could handle the case by executing such periodic tasks without any delay but I'm not certain the behavior is actually desired.

Related StackOverflow question: https://stackoverflow.com/questions/44555253/spring-boot-and-rxjava2-integration-nullpointerexception-actually-not

So the tw options I see are as follows:

1. throw IAE with non-positive periods with the related operators and require the Scheduler/Worker API to do the same
2. allow 0 period and introduce workarounds inside the Scheduler/Worker implementations.

I prefer option 1 as nobody seem to have encountered this specific issue before that would have rendered the code inoperable anyway due to a crash similar to the SO case.,It looks like the `Scheduler.Worker.schedulePeriodically` javadoc does specify the behavior for non-positive values:

>          * Note to implementors: non-positive {@code initialTime} and {@code period} should be regarded as
>          * non-delayed scheduling of the first and any subsequent executions.

>          * @param period
>          *            the time interval to wait each time in between executing the action; non-positive values
>          *            indicate no delay between repeated schedules

So in the case of the linked stackoverflow question its `NewThreadWorker` not following the contract specified by the javadoc. In addition there is the question whether the contract for `Scheduler.schedulePeriodicallyDirect` should be the same as `Schduler.Worker.schedulePeriodically`

The question then becomes either changing the contract for option 1 or more extensive testing of existing schedulers for option 2. =||= Thanks for your findings. If it says in the javadoc then the schedulers should honor it. I'll prepare a PR that fixes and checks for such behavior. =||= Closing via #5419. =||= ,0
5427,5426,[2.1.0] buffer(timespan, unit, count) emits duplicated items,The following code:

```
import io.reactivex.Observable;
import org.junit.Test;

import java.util.concurrent.TimeUnit;

public class BufferTest {
    @Test
    public void testBuffer() {
        Observable.range(0, 10)
                .map(n -> {
                    Thread.sleep(100);
                    return n;
                })
                .buffer(1, TimeUnit.SECONDS, 5)
                .subscribe(System.out::println);
    }
}

```
is expected to print something like:
[0, 1, 2, 3, 4]
[5, 6, 7, 8]
[9]

but try to run it several times and you can see that sometimes it prints out:
[0, 1, 2, 3, 4]
[5, 6, 7, 8, 9]
[5, 6, 7, 8, 9]
[]
where one of the bunches is duplicated.,Thanks for reporting. This is a bug in both `Observable` and `Flowable` operators. I'll post a fix shortly. =||= Closing via #5427. =||= ,0
5440,543,Support creating Observable from Android's Sensor.,Very early PR to get some guidance over API, testing, style and error handling.,[RxJava-pull-requests #476](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/476/) SUCCESS
This pull request looks good
 =||= This needs to be rebased as it conflicts with other changes committed.

@mttkay Can you weigh in on this?
 =||= You should not need a subject. Just Observable.create (whenever you think you need a subject, think again).

To handle @mironov-nsk remark, I would pass in a function from SensorEvent to T, you use that function to project the event to whatever you want to push into the stream.

```
public static Observable<float[]> fromSensor(SensorManager sensorManager, int type, int rate) {}
```

would become

```
 public static <T> Observable<T> fromSensor(SensorManager sensorManager, int type, int rate, Func1<SensorEvent, T> selector) {}
```
 =||= @mttkay When a user subscribes an Observable, he may forget to unsubscribe it which may be a resource leak issue in Android. I propose the following helper class to help users manage the Subscriptions related to a Context.
So the user can simply unsubscribe all of the Subscriptions at the onStop method.

``` java
public class AndroidSubscriptions {

    private static Map<Context, CompositeSubscription> contextSubscriptions = new HashMap<Context, CompositeSubscription>();

    public static synchronized void add(Context context,
            Subscription subscription) {
        CompositeSubscription parentSubscription = contextSubscriptions
                .get(context);
        if (parentSubscription == null) {
            parentSubscription = new CompositeSubscription();
            contextSubscriptions.put(context, parentSubscription);
        }
        parentSubscription.add(subscription);
    }

    public static synchronized void unsubscribe(Context context) {
        CompositeSubscription parentSubscription = contextSubscriptions
                .get(context);
        if (parentSubscription != null) {
            parentSubscription.unsubscribe();
            contextSubscriptions.remove(context);
        }
    }
}
```

Here I use static methods because I want to use  `AndroidSubscriptions.add` like the following codes:

``` java
public class OperationObserveFromAndroidSensor {

    public static Observable<float[]> observeFromAndroidSensor(
            final Context context, final SensorManager sensorManager, int type,
            final int rate) {
        final Sensor sensor = sensorManager.getDefaultSensor(type);
        if (sensor == null)
            throw new IllegalArgumentException("Unsupported sensor type.");

        return Observable.create(new OnSubscribeFunc<float[]>() {

            @Override
            public Subscription onSubscribe(
                    final Observer<? super float[]> observer) {
                final SensorEventListener listener = new SensorEventListener() {
                    @Override
                    public void onSensorChanged(SensorEvent event) {
                        observer.onNext(Arrays.copyOf(event.values,
                                event.values.length));
                    }

                    @Override
                    public void onAccuracyChanged(Sensor sensor, int accuracy) {
                        // TODO
                    }
                };
                sensorManager.registerListener(listener, sensor, rate);
                Subscription subscription = Subscriptions.create(new Action0() {

                    @Override
                    public void call() {
                        sensorManager.unregisterListener(listener);

                    }
                });
                AndroidSubscriptions.add(context, subscription);
                return subscription;
            }
        });
    }
}
```

What's your opinion?
 =||= I'm not sure I understand what problem this solves. Where do you release the composite subscription for a context? The wrapped subscriptions, while mapped to the same context, might have completely unrelated life cycles too. Moreover, keeping strong references to Context in a global, unsynchronized shared object is a bit of a red flag.
 =||=  The composite subscription for a context will be unsubscribed in Activity.onStop (or onDestroy?) method, like:

```
    @Override
    protected void onStop() {
        AndroidSubscriptions.unsubscribe(this);
        super.onStop();
    }
```
 =||= Basically, I want to collect all of the subscriptions related to a context. When the context is going to be destroyed, we can call `AndroidSubscriptions.unsubscribe(context)` to subscribe them. 
 =||= I see what you mean. Why not have the composite subscription as a member
field in your Activity class? That's what we do in our app. I still don't
see a case here for a shared static field in the library itself.

On Thu, Dec 12, 2013 at 10:20 AM, Shixiong Zhu notifications@github.comwrote:

> Basically, I want to collect all of the subscriptions related to a
> context. When the context is going to be destroyed, we can call
> AndroidSubscriptions.unsubscribe(context) to subscribe them.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/pull/543#issuecomment-30400740
> .
 =||= @mttkay You're right. I gave up this idea as I could not find any elegant way. I agree that managing the subscriptions is the app's job.
 =||= Since this can no longer be merged, can you close this and re-create a new one once the code is ready?
 =||= Closing out as it can't be merged and has been 15+ days since involvement ... please re-submit a new PR when this is ready.
 =||= ,0
5447,5442,2.x: Consumer contract is violated when using doOnEvent,The following code showcases the problem:
```java
Completable.complete()
  .doOnEvent(t -> {})
```
`t` in this case is annotated with `@NonNull` but it will be `null` since the completable completes.

This is a real pain in Kotlin since the following code crashes in runtime:
```kotlin
Completable.complete()
  .doOnEvent {}
```,BiConsumer is also violated when using `Single#subscribe`. Either value or throwable will be null. =||= Removing the annotation from `Consumer` may affect all other places where it is not-null. Can you override the annotation somehow at the call site?

@sakuna63 [BiConsumer](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/functions/BiConsumer.java#L29) doesn't have the annotations. =||= I just stumbled upon this while using Kotlin, too. However I wonder how a function argument annotated with `@NonNull` can ever be `null`? Even in Java this should be problematic as the contract is broken. =||= Maybe RxKotlin has/could have workarounds for these. /cc @thomasnield =||= Sorry, I read old source code. 
The annotations have already been removed at https://github.com/ReactiveX/RxJava/pull/5257 =||= This was introduced with #5023 =||= > Removing the annotation from Consumer may affect all other places where it is not-null. Can you override the annotation somehow at the call site?

@akarnokd If there's just one call that passes `null` to the function then *imho* the argument must be annotated with `@Nullable` and not `@NonNull`. What's the point of `@NonNull` when it can be `null`? =||= @akarnokd no, the problem cannot be remidied in kotlin which completely prevents the usage of that operator in kotlin. 
Removing the annotation won't make it nullable though, it would just mean that we don't know the nullability status which is the case too. Why is it important to keep it? I see very little harm in removing it and as @svenjacobs said the contract is broken in java too. If I were to null check it in java I would probably get lint warning telling me to remove the null check.
Ideally there should be multiple interfaces like @rharter suggested in the issue for BiFunction =||= If you can think you can resolve this with minimal changes, PR welcome. =||= By the way this issue emerged with the release of Kotlin 1.1.3. Although `@NonNull` has already been added months ago it seems that the compiler/runtime library of Kotlin 1.1.3 became stricter in regards to nullability. =||= Ah, that explains why I just recently starting having problems. =||= Huh, I thought implementing `Consumer` interface manually with correct nullability will help:

```kotlin
Completable
        .fromCallable {  }
        .doOnEvent(object : Consumer<Throwable> {
            override fun accept(t: Throwable?) { // Error: 'accept' overrides nothing
                println("event: $t")
            }
        })
        .subscribe()
```

But Kotlin compiler (1.1.3-eap34) does not even let such code to compile, so there is probably no clear way to solve this in Kotlin without using Java code. =||= Is `doOnEvent` the only operator that needs a `Consumer` that accepts Nullable data? If so, why remove `@NonNull` which is fairly useful annotation for most of the other operators? Why not have a different, let's say, `Consumer2` specifically for doOnEvent and such operators? =||= ,0
5449,544,ReplaySubject emits items received after onError,This snippet

``` scala
    val sub = ReplaySubject[Int]()

    sub.onNext(1)
    sub.onNext(2)
    sub.onError(new Exception("Kabloooy!")) // Gets moved to after onNext(3)
    sub.onNext(3)

    sub.subscribe(
      n => println("sub1: " + n),
      e => println("sub1: " + e.getMessage),
      () => println("sub1: completed")
    )

    println("done")
```

outputs

```
sub1: 1
sub1: 2
sub1: 3
sub1: Kabloooy!
done
```

but I would expect

```
sub1: 1
sub1: 2
sub1: Kabloooy!
done
```

since items received after onError should not be emitted by ReplaySubject.

(Thank you Dragisa Krsmanovic for pointing this out),Ben and I hacked on subjects earlier this week, all subjects are/were in pretty bad shape, but we'll fix it. 
 =||= ReplaySubject is the one I didn’t touch, I refactored Publish/Behavior/Async. I’ll put Replay on my TODO.
 =||= I think this is a trivial fix

``` java
    @Override
    public void onNext(T args)
    {
        synchronized (subscriptions) {
            if (isDone) {
                return;
            }
            history.add(args);
            for (Observer<? super T> observer : new ArrayList<Observer<? super T>>(subscriptions.values())) {
                observer.onNext(args);
            }
        }
    }
```
 =||= We should also make sure no additional,on errors,are propagated.

Sent from my iPad

> On Nov 30, 2013, at 4:52 AM, akarnokd notifications@github.com wrote:
> 
> I think this is a trivial fix
> 
> ```
> @Override
> public void onNext(T args)
> {
>     synchronized (subscriptions) {
>         if (isDone) {
>             return;
>         }
>         history.add(args);
>         for (Observer<? super T> observer : new ArrayList<Observer<? super T>>(subscriptions.values())) {
>             observer.onNext(args);
>         }
>     }
> }
> ```
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= ,0
5466,5461,2.x: FlowableTimeoutTimed enhancement,I'm debugging a production problem where a timeout did not fire so having a close look at `FlowableTimeoutTimed`. I notice in `TimeoutTimedSubscriber` that multiple terminal events can be emitted to the downstream subscriber in race between the scheduled timeout runnable and the `onError` and `onComplete` methods. The volatile `done` flag doesn't provide complete protection unless we turn it into an `AtomicBoolean` and use `compareAndSet`. 

The other thing I notice is that the `timer` field is accessed synchronously (only via `onSubscribe` and `onNext`) so rather than an `AtomicReference` can be a mutable field.

I can make PR if you think these are valid.
,The `onNext` method would need protection as well. =||= See [FlowableTimeoutTimed:51](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java#L51). =||= Ah good, thanks. And the `timer` field doesn't need to be `AtomicReference`?

BTW prod problem was external API not defined properly so all good. =||= You mean [this](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java#L191) and [this](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java#L232)? =||= Yep

On Tue, 4 Jul. 2017, 20:06 David Karnok, <notifications@github.com> wrote:

> You mean this
> <https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java#L191>
> and this
> <https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java#L232>
> ?
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/5461#issuecomment-312839275>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AATa60XJZUhH8eEth64QvWz2sD1DuFaFks5sKg6zgaJpZM4OMxK8>
> .
>
 =||= Yeah, doesn't really need AtomicReference in its current algorithm. =||= I'll fix =||= Btw, there is [a more modern algorithm](https://github.com/akarnokd/Reactive4.NET/blob/master/Reactive4.NET/operators/FlowableTimeout.cs) for this operator that doesn't need an additional layer of serialization. =||= Closing via #5466 =||= ,0
5470,5468,1.x Single#flatMapCompletable calls hooks onError when mapping to an error completeable,If you flatmap a Single into a Completeable, and the Completeable is an error, you will have the exception passed into the RxJavaHooks.onError global catch function as well as ending up with the Completeable Error you expect to see.

I have managed to get is down to the follow test case highlighting the problem,

```
@Test
    public void flatMapCompletableErrorCallsHooksErrorHandler() {
        AtomicBoolean wasHooksHandlerCalled = new AtomicBoolean();
        RxJavaHooks.setOnError(t -> wasHooksHandlerCalled.set(true));

        Completable c3  = Single.just(1)
                .flatMapCompletable(i -> Completable.error(new RuntimeException("some exception")));

        c3.get();

        assertThat(wasHooksHandlerCalled.get(), is(false)); //fails
    }
```

I did some digging and I think this is happening due to a bug in SafeCompletableSubscriber, where it calls  RxJavaHooks.onError(e) before it attempts to pass the error in to the wrapped subscribers onError method. ie

```
public void onError(Throwable e) {
        RxJavaHooks.onError(e);
        if (done) {
            return;
        }
        done = true;
        try {
            actual.onError(e);
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);

            throw new OnErrorFailedException(new CompositeException(e, ex));
        }
    }
```

Looking at SafeSubscriber, I think the correct behaviour is to only have the call to ` RxJavaHooks.onError(e);` happen inside the catch block, as no exception has leaked at the point where it is currently being called.,Actually, it is supposed to be inside the `if (done) { } ` block. Would you like to submit a PR? =||= Closing via #5470. =||= ,0
5476,5456,2.x: wrong return type in doc for F.reduce(seed, ...) and O.reduce(seed, ...),The `Flowable.reduce(T, BiFunction)` and `Observable.reduce(T, BiFunction)` JavaDocs' first sentence mentions the wrong return type.,Closing via #5476 =||= ,0
5486,5485,Update Maybe#defaultIfEmpty javadoc (#5480),Adds a link to Javadoc for `Maybe#defaultIfEmpty` method which has a surprising return type (#5480, #5417).,Forgot about the javadoc wording guards. I posted #5486 that includes your sentences and an updated validator. =||= ,0
5486,5480,Suggest Maybe#toSingle in Maybe#defaultIfEmpty documentation,Looking at http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html#defaultIfEmpty%28T%29, I was surprised to find it didn't return `Single`. Searching in closed issues found the answer: https://github.com/ReactiveX/RxJava/issues/5417. Perhaps documentation could be improved by explicitly mentioning `toSingle` as an alternative?,PR welcome. =||= Closing via #5486. =||= ,0
5507,3794,GC nepotism in linked data structures,There [was a post](http://psy-lob-saw.blogspot.hu/2016/03/gc-nepotism-and-linked-queues.html) just recently by @nitsanw warning about the problem called GC nepotism.

This affects our older copies of the JCTools queues, `MpscLinkedQueue` and `SpscLinkedArrayQueue`. There is an issue, #1735, about shading which would fix it, but that could happen in any time, even after some more small version changes.

In addition, the issue affects both the bounded versions of `replay()` and `ReplaySubject`. The problem there is that individual subscribers could be at any point in the linked-node sequence we can't just null out links when the operators move their head forward (trimming).

It might be possible to null out the right node by scanning the known child subscribers and chosing the earliest node any of them knows about. Unfortunately, this also requires back-references between nodes as well as node indexing, taking extra time and extra concurrency considerations.,Closing as mostly resolved where it was possible. =||= ,0
5507,5506,2.x: FlowableRefCountTest causing build failure,I'm getting a 50/50 success rate on building 2.x. Here is the test result:

```
java.lang.AssertionError: expected:<12> but was:<11>
	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:834)
	at org.junit.Assert.assertEquals(Assert.java:645)
	at org.junit.Assert.assertEquals(Assert.java:631)
	at io.reactivex.internal.operators.flowable.FlowableRefCountTest.testRefCountAsync(FlowableRefCountTest.java:83)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.GeneratedMethodAccessor10.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:109)
	at sun.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:377)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
	at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:748)
```,It is a flaky test and is quite sensitive to system load due to that 52 millisecond wait. Maybe it would be possible to sleep-loop over a `nextCount.get() == receivedCount.get() && nextCount.get() == 10` condition. =||= Closing via #5507. =||= ,0
5524,5319,2.x: Observable missing or incorrect images (tracking issue),- [x] [Observable.singleOrError()](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#singleOrError()): There is no default value and an empty source should result in an error.
- [x] `Observable.combineLatestDelayError(ObservableSource[], Function)`: missing diagram
- [x] `Observable.combineLatestDelayError(Function, int, ObservableSource...)`: missing diagram
- [x] `Observable.concatArrayEager`: missing diagram
- [x] `Observable.error`: should include the X in the operator body indicating it as being the parameter/return value
- [x] `Observable.fromFuture`: the operator name in the box
- [x] `Observable.fromIterable`: the operator name in the box
- [x] `Observable.fromPublisher`: missing diagram
- [x] `Observable.just`: the element should be a parameter inside the box, such outside elements imply a subject type external push.
- [x] `Observable.just(T, T)` +7: optionally tailor the diagram to the actual number of arguments, plus move the constant values inside the box
- [x] `Observable.rangeLong`: the operator name in the box
- [x] `Observable.switchOnNextDelayError`: the operator name in the box, indicator of an error getting delayed
- [x] `Observable.zipArray`: indicate there is a function instead of implying the output is an array containing one element from each source.
- [x] `Observable.zipIterable`: the operator name in the box
- [x] `Observable.all`: example of a false result
- [x] `Observable.ambWith`: the operator name in the box
- [x] `Observable.blockingFirst`: missing diagram
- [x] `Observable.blockingForEach`: the operator name in the box
- [x] `Observable.blockingIterable`: the operator name in the box, indicate that blocking may happen for each element
- [x] `Observable.blockingLast`: the operator name in the box
- [x] `Observable.blockingLast(T)`: the operator name in the box, indicate default in the box, fix labels
- [x] `Observable.blockingLatest`: missing diagram
- [x] `Observable.blockingMostRecent`: the operator name in the box
- [x] `Observable.blockingNext`: the operator name in the box
- [x] `Observable.blockingSingle`: the operator name in the box
- [x] `Observable.blockingSingle(T)`: the operator name in the box, indicate default in the box, fix labels
- [x] `Observable.toFuture()`: the operator name in the box, indicate multi-value, empty and error behavior
- [x] `Observable.blockingSubscribe`: missing diagram
- [x] `Observable.cacheWithInitialCapacity`: the operator name in the box
- [x] `Observable.collectInto`: the operator name in the box, indicate the shared collection
- [x] `Observable.concatMapCompletable`: missing diagram
- [x] `Observable.concatMapDelayError`: missing diagram
- [x] `Observable.concatMapEager`: missing diagram
- [x] `Observable.concatMapEagerDelayError`: missing diagram
- [x] `Observable.concatMapIterable`: missing diagram
- [x] `Observable.doAfterNext`: missing diagram
- [x] `Observable.doFinally`: missing diagram
- [x] `Observable.doOnDispose`: the operator name in the box
- [x] `Observable.doOnComplete`: indicate that the events pass through and the star is execute before the onComplete to downstream
- [x] `Observable.doOnError`: indicate that the events pass through and the star is execute before the onError to downstream
- [x] `Observable.doOnLifecycle`: change unsubscribe to dispose
- [x] `Observable.doOnNext`: indicate that the events pass through and the star is execute before the onNext to downstream
- [x] `Observable.doOnTerminate`: indicate that the events pass through and the star is execute before the onError or onComplete to downstream
- [x] `Observable.elementAt(long)`: example of empty source
- [x] `Observable.elementAt(long, T)`: example of empty source
- [x] `Observable.elementAtOrError(long)`: example of empty source
- [x] `Observable.firstElement`: diagram is stretched
- [x] `Observable.firstOrError`: the operator name in the box
- [x] `Observable.flatMap(Function, boolean, int)`: missing diagram
- [x] `Observable.flatMap(Function, boolean, int, int)`: missing diagram
- [x] `Observable.flatMap(Function, Function, Callable, int)`: missing diagram
- [x] `Observable.flatMap(Function, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, boolean, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, boolean, int, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, int)`: missing diagram
- [x] `Observable.flatMapCompletable()`: missing diagram
- [x] `Observable.flatMapIterable(Function)`: diagram looks stretched
- [x] `Observable.forEach()`: missing diagram
- [x] `Observable.forEachWhile()`: missing diagram
- [x] `Observable.hide()`: missing diagram - not sure how to represent this
- [x] `Observable.lastOrError()`: operator name in the box, error case example.
- [x] `Observable.onErrorReturn()`: indicate that the value is the result of a function call
- [x] `Observable.onErrorReturnItem()`: operator name in the box
- [x] `Observable.onTerminateDetach`: missing diagram
- [x] `Observable.publish(Function)`: there is no connect call, may need extensive redrawing
- [x] `Observable.reduceWith()`: operator name in the box
- [x] `Observable.repeat()` + overloads: indicate fresh subscriptions happen, not caching
- [x] `Observable.repeatUntil`: operator name in the box, indicate fresh subscriptions
- [x] `Observable.replay()` + overloads: remove publish
- [x] `Observable.replay(Function, ...)` overloads: may need extensive redrawing
- [x] `Observable.retry(long)` indicate limited retry effect
- [x] `Observable.retry(Predicate)` indicate predicate effect, show it in the box
- [x] `Observable.retry(long, Predicate)` indicate predicate, show them in the box
- [x] `Observable.retryUntil`: operator name in the box, show BooleanSupplier
- [x] `Observable.share()`: fix labels with unsubscribe
- [x] `Observable.singleElement`: example with empty source
- [x] `Observable.sorted`: missing diagram
- [x] `Observable.startWith(T)`: have a single item as start value
- [x] `Observable.startWithArray(T...)`: operator name
- [x] `Observable.subscribe` + overloads: missing diagram
- [x] [Observable.switchMapSingle](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#switchMapSingle(io.reactivex.functions.Function)): inner sources should have 1 item.
- [x] `Observable.switchMapDelayError` + indicate the error case
- [x] `Observable.toList(Callable)`: indicate the custom collection somehow?
- [x] `Observable.toFlowable()`: missing diagram
- [x] `Observable.unsubscribeOn()`: missing diagram
- [x] `Observable.zipWith()` + overloads: the diagram is in line with some text and appears pushed to the right
- [x] `Observable.test()`: missing diagram, can this be represented as diagram?
  
  ,PRs welcome. The most easy ones are those that require alignment/displayed size corrections. =||= Hi David, I'd love to help, what would I use to edit the diagrams? =||= If you are on Mac and you own OmniGraffle, there is a file for **all** traditional diagrams:
https://github.com/ReactiveX/reactivex.github.io/issues/223

I'm using Excel 2007+ on Windows to draw the newer diagrams and have a file [here](https://drive.google.com/open?id=0B4T7ZW3brESKQV9KaEF5YnpjM0k) you can use as basis for newer diagrams. I don't know if the open office variants could open this file or not, Google's viewer certainly doesn't show the drawings.

I suppose as a last resort you can draw in the open-office variants as well and post the PNGs in this issue. Uploading it requires access to the wiki git of RxJava. The target rendering is 640 pixels wide and as long as it needs to be.

The process is as follows:

- Draw diagram(s)
- Upload to git
- Modify Javadoc locally to point to the raw usercontent
- Verify and fix alignment/stretching
- Commit PR to RxJava itself =||= Is it `switchMapSingle` need a new diagram too? SingleResource can't emit 2 items. =||= Yes. I'll add it to the list above. =||= ## ConcatArrayEager

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.png) =||= ## Error

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.item.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.supplier.png) =||= ## fromFuture

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.noarg.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.scheduler.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.scheduler.png) =||= ## fromIterable

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromIterable.png) =||= Another option is to use free open-source multi-platform Inkscape. Templates here:

https://github.com/davidmoten/rxjava-marble-template =||= **startWith(T)**

![startwith t](https://user-images.githubusercontent.com/6715387/28749559-b5f451dc-74a1-11e7-9a24-db339a2da754.png)


 =||= **startWithArray(T...)**

![startwitharray](https://user-images.githubusercontent.com/6715387/28749281-5f23f834-7498-11e7-99a5-49033842ecb9.png)

 =||= Thanks. Could you make sure the operator box has its contents centered? =||= Sure. Going to edit them. =||= **sorted()**

Is it okay to add numbers to the marbles?

![sorted](https://user-images.githubusercontent.com/6715387/28749679-1660f5b2-74a6-11e7-909b-f9c6cb7ce2c5.png)


 =||= In this case yes, because it also demonstrates the self-comparable nature required (changing the order of colors is unlikely to convey the sorting aspect). For most of the other operators, the matching up of the color should be enough. =||= Not sure how you do these images, could you add shadows to the marbles, the time arrows and the vertical complete indicators? =||= I'm using @davidmoten's template. Going to edit them to add the shadows.  =||= sorted(): it would be better that the source marbles are at the beginning and the output is only happening after onComplete:

```
---5--3--1--4--2--|--------------
[            sorted()           ]
---------------------1-2-3-4-5-|-
``` =||= Added shadows and edited the `sorted()` operator. =||= **just(T)**

![just](https://user-images.githubusercontent.com/6715387/28749794-944aea34-74a9-11e7-9e52-43604442c87d.png)

 =||= **rangelong()**

![rangelong](https://user-images.githubusercontent.com/6715387/28749798-cf44b69c-74a9-11e7-853b-958018e492c4.png)
 =||= Thanks @leonardortlima ! The first 5 images is added via #5524. =||= Just noticed that `Single.filter` and `Maybe.filter` are also incorrect; they seem to be copied from `Observable.filter`. =||= Quite possibly the other base reactive classes have copy-paste diagrams. This issue tracks the fixes of `Observable` but if you want, I can open issues for the other classes individually. =||= ![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.2.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.3.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.4.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.5.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.6.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.7.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.8.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.9.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.10.png)

![switchOnNextDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchOnNextDelayError.png) =||= From #5668:

![singleelement](https://user-images.githubusercontent.com/4089934/31583261-a6da996a-b18f-11e7-8682-dffa647c7e4a.png) =||= ### zipIterable

![zipIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipIterable.o.png)

### ambWith

![ambWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ambWith.o.png)

### blockingForEach

![blockingForEach](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingForEach.o.png)

### blockingIterable

![blockingIterable](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingIterable.o.png)

### blockingLast

![blockingLast](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLast.o.png)

![blockingLast](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLastDefault.o.png)

### blockingMostRecent

![blockingMostRecent](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingMostRecent.o.png)

### blockingNext

![blockingNext](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingNext.o.png)

### blockingSingle

![blockingSingle](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingle.o.png)

![blockingSingle](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingleDefault.o.png)

### cacheWithInitialCapacity

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cacheWithInitialCapacity.o.png) =||= ### all

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.o.png)

### fromPublisher

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromPublisher.o.png)

### zipArray

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipArray.o.png) =||= ### blockingFirst

![blockingFirst](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.png)


![blockingFirst](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.default.png)

### toFuture


![toFuture](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFuture.o.png)


### blockingSubscribe

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.0.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.1.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.2.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.png)

### collectInto

![collectInto](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collectInto.o.png)

### doOnComplete

![doOnComplete](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.o.png)

### doOnError

![doOnError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.o.png)

### doOnLifecycle

![doOnLifecycle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnLifecycle.o.png)

### doOnNext

![doOnNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.o.png)

 =||= ### concatMapCompletable

![concatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapCompletable.o.png)

### concatMapDelayError

![concatMapDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapDelayError.o.png)

### concatMapEager

![concatMapEager](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEager.o.png)

### concatMapEagerDelayError

![concatMapEagerDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEagerDelayError.o.png)

### concatMapIterable

![concatMapIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapIterable.o.png)

### doAfterNext

![doAfterNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterNext.o.png)

### doFinally

![doFinally](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png) =||= ### doOnTerminate

![doOnTerminate](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.o.png)

### elementAt

![elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.o.png)
![elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtDefault.o.png)

### elementAtOrError

![elementAtOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrError.o.png)

### firstOrError

![firstOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.o.png)

### flatMap

![flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapDelayError.o.png)
![flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png)



 =||= ![flatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletable.o.png)

![flatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletableDelayError.o.png)

![forEach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEach.o.png)

![forEachWhile](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEachWhile.o.png)

![hide](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/hide.o.png) =||= ![lastOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png)
![onErrorReturn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.o.png)
![onErrorReturnItem](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturnItem.o.png)
![onTerminateDetach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onTerminateDetach.o.png)
![publish(Function)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishFunction.o.png)
![reduce(seed, f)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.o.png)
![reduceWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceWith.o.png)
![repeat()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatInf.o.png)
![repeat(long)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatCount.o.png)
![repeatUntil](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatUntil.o.png)
![replay()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.png)
![replay(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.n.png)  
![replay(int, long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nt.png)
![replay(int, long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nts.png)
![replay(int, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ns.png)
![replay(long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.t.png)
![replay(long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ts.png)
![replay(Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.s.png) =||= ![no arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.f.png)
![scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fs.png)
![bufferSize](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fn.png)
![bufferSize, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fns.png)
![time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ft.png)
![time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fts.png)
![bufferSize, time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnt.png)
![bufferSize, time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnts.png)
 =||= ![retry(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.n.png)
![retry(BiFunction)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.ne.png)
![retry(Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.e.png)
![retry(int, Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.nfe.png)
![retryUntil(BooleanSupplier)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryUntil.o.png)
![share](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.png)
![switchMapSingle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingle.o.png)
![switchMapSingleDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingleDelayError.o.png) =||= ![toList(Callable)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.o.c.png)
![toFlowable(BUFFER)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.buffer.png)
![toFlowable(DROP)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.drop.png)
![toFlowable(LATEST)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.latest.png)
![toFlowable(ERROR)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.error.png)
![toFlowable(MISSING)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.missing.png)
![unsubscribeOn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/unsubscribeOn.o.png)
 =||= ,0
5560,5558,2.x - CombineLatestDelayError throwing error before subscribing other observables,I am working on a piece of code where I basically have a cached value, which I want to combine with other data and update from the network.

My thought was using combineLatestDelayError and magic would happen! Except when the network is down... Even though I have valid values in both my observables I only end up getting the error.

I narrowed it down to a simple test case:
```java
    @Test
    public void combineLatestDelayErrorFailure() {
        final int result = Observable.combineLatestDelayError(
                Arrays.asList(
                        Observable.just(41).concatWith(Observable.error(new Exception("Failure"))),
                        Observable.just(1).delay(1, TimeUnit.SECONDS)
                ),
                ints -> ((int) ints[0]) + ((int) ints[1])
        ).blockingFirst();
        assertThat(result).isEqualTo(42);
    }
```

It always throws the Exception.

There is one point in the documentation about the calls being synchronous, though it is not clear to me how I could make changes to my observables to avoid that situation 😿,Thanks for reporting, this is a bug with the operator not properly considering the `DelayError` setting in this synchronous situation. I can't give you a simple workaround; you could try and materialize the failing source and the combiner function could throw it via `Exceptions.wrapOrThrow()`.

I'll post a fix for the operator shortly. =||= Closing via #5560. =||= Thanks @akarnokd I'll wait for the next release to have this fixed! =||= ,0
5568,5555,2.x: BaseObserver.assertOnlyValues(T...),I'd like to introduce `assertOnlyValues` to the `BaseObserver`. It's the counterpart to `assertResult(T...)` which does almost the same except for the fact that the type hasn't completed yet.

I'm open if anyone has a better function name. Internally it'd delegate to:

```java
  assertValues(values)
      .assertNoErrors()
      .assertNotComplete()
      .assertSubscribed();
```,assertResult will eventually fail so assertValues was generally enough. When there is a bug, you can apply the other methods on a case by case basis. =||= > assertResult will eventually fail so assertValues was generally enough.

Although `assertValues` does not check for errors nor it'll fail when the stream does complete. Basically with that method I want to test that the stream will stay alive and not terminate. =||= You can write this utility method in a class:

```java
public static <T, U extends BaseTestConsumer<T>> assertValuesOnly(U ts, T... values) {
    return ts.assertValues(values).assertNoErrors().assertNotComplete().assertSubscribed();
}
```

And IntelliJ will happily staticly import it. =||= I tend to agree with @vanniktech on this feature-request.

>When there is a bug, you can apply the other methods on a case by case basis.

It's usually too late because code was shipped…

>You can write this utility method in a class:

For sure, I'm also pretty sure @vanniktech uses Kotlin so he could add extension function.

Not a fan of naming though, but I see the pattern, `assertOnlyValues()` should fit test API design. =||= > For sure, I'm also pretty sure @vanniktech uses Kotlin so he could add extension function.

That's what I'm doing right now. However I still think a lot of other people could benefit from this and the cost of adding this is really low.

> Not a fan of naming though, but I see the pattern, assertOnlyValues() should fit test API design.

Open for any better name. =||= Okay, let's add it. 

I'd name it `assertValuesOnly` so it should show up right after `assertValues` in code completion. =||= ,0
5582,4544,Maybe.switchIfEmpty(Single) method,It would be nice to see a method like this:

public class Maybe<T> {
  public Single<T> switchIfEmpty(Single<T> single);
}

Semantically, if you switchIfEmpty to a Single from a Maybe, then it becomes a Single, as you are guaranteed either an error or a value.  It would just make it less verbose than doing this:

maybe.switchIfEmpty(single.toMaybe()).toSingle(),done....
 =||= I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.
 =||= ,0
5590,5569,2.x: Strawman proposal for uncaught exception configuration,This is a strawman example/proposal for configurable uncaught exception handling in RxJavaPlugins. This is in ref to #5234.

The two options are to defer to current thread's handler (the current implementation and remains the default) and an optional `throw` option that wraps the throwable into an `UncaughtRxJavaException` for developers to watch for separately (and rethrowing, which requires some sort of `RuntimeException` wrapping).

If the proposal is agreeable/after API design is in place, I can add tests.,# [Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=h1) Report
> Merging [#5569](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=desc) into [2.x](https://codecov.io/gh/ReactiveX/RxJava/commit/994c65d2e680cb820c8140890b37c8428aeb1263?src=pr&el=desc) will **decrease** coverage by `0.03%`.
> The diff coverage is `50%`.

[![Impacted file tree graph](https://codecov.io/gh/ReactiveX/RxJava/pull/5569/graphs/tree.svg?src=pr&height=150&width=650&token=WtCc2hTjM2)](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree)

```diff
@@             Coverage Diff              @@
##                2.x    #5569      +/-   ##
============================================
- Coverage     96.23%   96.19%   -0.04%     
- Complexity     5823     5825       +2     
============================================
  Files           631      632       +1     
  Lines         41421    41426       +5     
  Branches       5739     5740       +1     
============================================
- Hits          39861    39851      -10     
- Misses          616      625       +9     
- Partials        944      950       +6
```


| [Impacted Files](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree) | Coverage Δ | Complexity Δ | |
|---|---|---|---|
| [.../io/reactivex/plugins/UncaughtRxJavaException.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcGx1Z2lucy9VbmNhdWdodFJ4SmF2YUV4Y2VwdGlvbi5qYXZh) | `0% <0%> (ø)` | `0 <0> (?)` | |
| [.../main/java/io/reactivex/plugins/RxJavaPlugins.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcGx1Z2lucy9SeEphdmFQbHVnaW5zLmphdmE=) | `99.34% <66.66%> (-0.66%)` | `146 <1> (ø)` | |
| [...ava/io/reactivex/processors/BehaviorProcessor.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcHJvY2Vzc29ycy9CZWhhdmlvclByb2Nlc3Nvci5qYXZh) | `88.49% <0%> (-4.87%)` | `62% <0%> (ø)` | |
| [...l/operators/observable/ObservableFlatMapMaybe.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBNYXliZS5qYXZh) | `90.84% <0%> (-3.93%)` | `2% <0%> (ø)` | |
| [.../internal/operators/flowable/FlowableInterval.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlSW50ZXJ2YWwuamF2YQ==) | `94.44% <0%> (-2.78%)` | `3% <0%> (ø)` | |
| [...nternal/operators/observable/ObservableWindow.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZVdpbmRvdy5qYXZh) | `98% <0%> (-2%)` | `3% <0%> (ø)` | |
| [.../io/reactivex/disposables/CompositeDisposable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvZGlzcG9zYWJsZXMvQ29tcG9zaXRlRGlzcG9zYWJsZS5qYXZh) | `97.24% <0%> (-1.84%)` | `39% <0%> (-1%)` | |
| [...rnal/subscriptions/DeferredScalarSubscription.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc3Vic2NyaXB0aW9ucy9EZWZlcnJlZFNjYWxhclN1YnNjcmlwdGlvbi5qYXZh) | `98.46% <0%> (-1.54%)` | `28% <0%> (-1%)` | |
| [...vex/internal/operators/flowable/FlowableCache.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlQ2FjaGUuamF2YQ==) | `92.61% <0%> (-1.35%)` | `7% <0%> (ø)` | |
| [...ernal/operators/flowable/FlowableFromIterable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRnJvbUl0ZXJhYmxlLmphdmE=) | `95.18% <0%> (-1.07%)` | `5% <0%> (ø)` | |
| ... and [21 more](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=tree-more) | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=footer). Last update [994c65d...54ac1dd](https://codecov.io/gh/ReactiveX/RxJava/pull/5569?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= There is a way without changing the plugins:

```java
public class UncaughtCrash {
    
    @Before
    public void before() {
        RxJavaPlugins.setErrorHandler(e -> {
            Thread.currentThread().setUncaughtExceptionHandler((t, f) -> {
                Thread.currentThread().setUncaughtExceptionHandler(null);
                throw (InternalError)f;
            });
            throw new InternalError(e);
         });
    }
    
    @After
    public void after() {
        RxJavaPlugins.setErrorHandler(null);
    }
    
    @Test
    public void test1() {
        RxJavaPlugins.onError(new IOException());
    }
    
    @Test
    public void test2() {
        RxJavaPlugins.onError(new IOException());
    }
}
```

This will bypass the `try-catch` around the consumer invocation in `RxJavaPlugins`. =||= That's not a solution for application use though, which could interfere with crash reporting tools =||= > interfere with crash reporting tools

How? 

You can restore the previous handler:

```
    RxJavaPlugins.setErrorHandler(e -> {
        UncaughtExceptionHandler saved = Thread.currentThread().getUncaughtExceptionHandler();
        Thread.currentThread().setUncaughtExceptionHandler((t, f) -> {
            Thread.currentThread().setUncaughtExceptionHandler(saved);
            throw (InternalError)f;
        });
        throw new InternalError(e);
     });
```

or

```java
    RxJavaPlugins.setErrorHandler(e -> {
        UncaughtExceptionHandler saved = Thread.currentThread().getUncaughtExceptionHandler();
        Thread.currentThread().setUncaughtExceptionHandler((t, f) -> {
            saved.uncaughtException(t, f);
            throw (InternalError)f;
        });
        throw new InternalError(e);
     });
```
 =||= The first solution will get stuck in a cycle of try/catching before eventually bombing out in `CompositeException` due to duplicates found in the chain (but not without creating an extremely deep trace). The decorator _does_ get a chance in its catch clause, but not without the collateral above. If it adds any metadata, it is buried within hundreds of lines of stacktraces :/. This would present an immense problem for grouping in crash reporting tools as well

The second doesn't actually avoid the issue for an android environment because sending it to the saved handler first will just exit the process before the decorator has a chance to handle it in a catch clause again. =||= Could you provide an example runnable test that demonstrates the way you want to catch these exceptions? 

> stuck in a cycle of try/catching

`UncaughtRxJavaException` would exhibit the same problem. Both need an extra case in the [`throwIfFatal`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/exceptions/Exceptions.java#L66) helper.

/cc @JakeWharton =||= Can do. I'll be away from my computer tomorrow but will circle back here with it Monday =||= Here's a demo. https://github.com/hzsweers/rxuncaughtissue

Just click the button to see, result will be a long trace like this:

```
E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.example.rxuncaughtissue, PID: 5469
    java.lang.RuntimeException: io.reactivex.exceptions.UndeliverableException: java.lang.RuntimeException: io.reactivex.exceptions.CompositeException: 2 exceptions occurred. 
        at com.example.rxuncaughtissue.MainActivity$2.accept(MainActivity.java:46)
        at com.example.rxuncaughtissue.MainActivity$2.accept(MainActivity.java:32)
        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:355)
        at io.reactivex.Observable.subscribe(Observable.java:10910)
        at io.reactivex.Observable.subscribe(Observable.java:10889)
        at io.reactivex.Observable.subscribe(Observable.java:10767)
        at com.example.rxuncaughtissue.MainActivity.simulateError(MainActivity.java:50)
        at com.example.rxuncaughtissue.MainActivity.access$000(MainActivity.java:15)
        at com.example.rxuncaughtissue.MainActivity$1.onClick(MainActivity.java:26)
        at android.view.View.performClick(View.java:5637)
        at android.view.View$PerformClick.run(View.java:22429)
        at android.os.Handler.handleCallback(Handler.java:751)
        at android.os.Handler.dispatchMessage(Handler.java:95)
        at android.os.Looper.loop(Looper.java:154)
        at android.app.ActivityThread.main(ActivityThread.java:6119)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776)
     Caused by: io.reactivex.exceptions.UndeliverableException: java.lang.RuntimeException: io.reactivex.exceptions.CompositeException: 2 exceptions occurred. 
        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:349)
        at io.reactivex.Observable.subscribe(Observable.java:10910) 
        at io.reactivex.Observable.subscribe(Observable.java:10889) 
        at io.reactivex.Observable.subscribe(Observable.java:10767) 
        at com.example.rxuncaughtissue.MainActivity.simulateError(MainActivity.java:50) 
        at com.example.rxuncaughtissue.MainActivity.access$000(MainActivity.java:15) 
        at com.example.rxuncaughtissue.MainActivity$1.onClick(MainActivity.java:26) 
        at android.view.View.performClick(View.java:5637) 
        at android.view.View$PerformClick.run(View.java:22429) 
        at android.os.Handler.handleCallback(Handler.java:751) 
        at android.os.Handler.dispatchMessage(Handler.java:95) 
        at android.os.Looper.loop(Looper.java:154) 
        at android.app.ActivityThread.main(ActivityThread.java:6119) 
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776) 
     Caused by: java.lang.RuntimeException: io.reactivex.exceptions.CompositeException: 2 exceptions occurred. 
        at com.example.rxuncaughtissue.MainActivity$2.accept(MainActivity.java:46)
        at com.example.rxuncaughtissue.MainActivity$2.accept(MainActivity.java:32)
        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:355)
        at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77)
        at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63)
        at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:37)
        at io.reactivex.Observable.subscribe(Observable.java:10903)
        at io.reactivex.Observable.subscribe(Observable.java:10889) 
        at io.reactivex.Observable.subscribe(Observable.java:10767) 
        at com.example.rxuncaughtissue.MainActivity.simulateError(MainActivity.java:50) 
        at com.example.rxuncaughtissue.MainActivity.access$000(MainActivity.java:15) 
        at com.example.rxuncaughtissue.MainActivity$1.onClick(MainActivity.java:26) 
        at android.view.View.performClick(View.java:5637) 
        at android.view.View$PerformClick.run(View.java:22429) 
        at android.os.Handler.handleCallback(Handler.java:751) 
        at android.os.Handler.dispatchMessage(Handler.java:95) 
        at android.os.Looper.loop(Looper.java:154) 
        at android.app.ActivityThread.main(ActivityThread.java:6119) 
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776) 
     Caused by: io.reactivex.exceptions.CompositeException: 2 exceptions occurred. 
        at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) 
        at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63) 
        at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:37) 
        at io.reactivex.Observable.subscribe(Observable.java:10903) 
        at io.reactivex.Observable.subscribe(Observable.java:10889) 
        at io.reactivex.Observable.subscribe(Observable.java:10767) 
        at com.example.rxuncaughtissue.MainActivity.simulateError(MainActivity.java:50) 
        at com.example.rxuncaughtissue.MainActivity.access$000(MainActivity.java:15) 
        at com.example.rxuncaughtissue.MainActivity$1.onClick(MainActivity.java:26) 
        at android.view.View.performClick(View.java:5637) 
        at android.view.View$PerformClick.run(View.java:22429) 
        at android.os.Handler.handleCallback(Handler.java:751) 
        at android.os.Handler.dispatchMessage(Handler.java:95) 
        at android.os.Looper.loop(Looper.java:154) 
        at android.app.ActivityThread.main(ActivityThread.java:6119) 
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776) 
     Caused by: io.reactivex.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>
        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:359)
        at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) 
        at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63) 
        at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:37) 
        at io.reactivex.Observable.subscribe(Observable.java:10903) 
        at io.reactivex.Observable.subscribe(Observable.java:10889) 
        at io.reactivex.Observable.subscribe(Observable.java:10767) 
        at com.example.rxuncaughtissue.MainActivity.simulateError(MainActivity.java:50) 
        at com.example.rxuncaughtissue.MainActivity.access$000(MainActivity.java:15) 
        at com.example.rxuncaughtissue.MainActivity$1.onClick(MainActivity.java:26) 
        at android.view.View.performClick(View.java:5637) 
        at android.view.View$PerformClick.run(View.java:22429) 
        at android.os.Handler.handleCallback(Handler.java:751) 
        at android.os.Handler.dispatchMessage(Handler.java:95) 
        at android.os.Looper.loop(Looper.java:154) 
        at android.app.ActivityThread.main(ActivityThread.java:6119) 
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776) 
     Caused by: java.lang.RuntimeException: This gets buried
        at com.example.rxuncaughtissue.MainActivity.simulateError(MainActivity.java:49)
        at com.example.rxuncaughtissue.MainActivity.access$000(MainActivity.java:15) 
        at com.example.rxuncaughtissue.MainActivity$1.onClick(MainActivity.java:26) 
        at android.view.View.performClick(View.java:5637) 
        at android.view.View$PerformClick.run(View.java:22429) 
        at android.os.Handler.handleCallback(Handler.java:751) 
        at android.os.Handler.dispatchMessage(Handler.java:95) 
        at android.os.Looper.loop(Looper.java:154) 
        at android.app.ActivityThread.main(ActivityThread.java:6119) 
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776) 
     Caused by: java.lang.RuntimeException: Duplicate found in causal chain so cropping to prevent loop ...
        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:359)
        at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77)
        at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63)
        at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:37)
        at io.reactivex.Observable.subscribe(Observable.java:10903)
        at io.reactivex.Observable.subscribe(Observable.java:10889)
        at io.reactivex.Observable.subscribe(Observable.java:10767)
        at com.example.rxuncaughtissue.MainActivity.simulateError(MainActivity.java:50)
        at com.example.rxuncaughtissue.MainActivity.access$000(MainActivity.java:15) 
        at com.example.rxuncaughtissue.MainActivity$1.onClick(MainActivity.java:26) 
        at android.view.View.performClick(View.java:5637) 
        at android.view.View$PerformClick.run(View.java:22429) 
        at android.os.Handler.handleCallback(Handler.java:751) 
        at android.os.Handler.dispatchMessage(Handler.java:95) 
        at android.os.Looper.loop(Looper.java:154) 
        at android.app.ActivityThread.main(ActivityThread.java:6119) 
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776) 
``` =||= I see. Unless there is a free pass for the exception thrown, this PR would end up with the same complicated cause chain.

So if I understand correctly, you want the following two:

1. synchronous sequences should crash and a non-reactive try-catch should be able to grab the exception,
2. shim `Observable`s installed via assembly hooks should be able to try-catch around an `onError` call to a downstream and grab an exception bouncing back from the onError handler.

The first case, when inside an unit test, could be simulated via the `TestHelper.trackPluginErrors` previously mentioned. 

Otherwise and in option 2, the question is what would you even do about that undeliverable error?

Either way, you'd still have to get a free pass for that type of crash by modifying [`throwIfFatal`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/exceptions/Exceptions.java#L66) helper.

And finally, even if such behavior override would be added, I'd go for a static volatile flag instead of a system parameter so it can be enabled and disabled when testing the feature itself. =||= The first case can definitely be handled in tests, but I'm basically trying to write a tool to help with crash reporting by decorating the observer with this observer that, in the event of the delegate observer throwing an `OnErrorNotImplementedException`, would throw its own exception with a bunch of metadata up before crashing.

What modifications would need to go into throwIfFatal? Even if it's something as simple as letting OnErrorNotImplemented bubble up, it'd go a long way to detecting unhandled errors and being able to tie them to the point of subscription. 

Volatile flag sounds fine to me =||= > What modifications would need to go into throwIfFatal?

Another `if` with the `RuntimeException` or `Error` to be rethrown.

> letting `OnErrorNotImplemented` bubble up

Not a good idea as it is an established exception type and unexpected new behavior of it.

> in the event of the delegate observer throwing an `OnErrorNotImplementedException`

I'd think you are using the wrong hook then; `setObservableOnSubscribe` is called when subscribing where you could analyze the `LambdaObserver` for the default onError handler (it's a constant). For that, though, the `LambdaObserver` needs modification, perhaps by adding a public `isDefaultErrorConsumer`. This, however, would rely on otherwise discouraged access into the internal packages of RxJava.

Other option I see would be a new hook `RxJavaPlugins.setOnErrorNotImplementedConsumer(Function<Consumer<Throwable>, Consumer<Throwable>>)` where you could basically supply an `onError` handler to the `LambdaObserver` when `subscribe()` and `subscribe(Consumer<T>)` is invoked. =||= I think a key part of this is that it probably shouldn't be tied to `LambdaObserver`, since `OnErrorNotImplementedException` is public and developers could set their own observers with implementations that leverage it (and a throwing `onError` is the real case trying to be handled here). Custom observers are what we actually use as well, and what we would watch for in an onSubscribe hook to know when to decorate (as we wouldn't want to do it on all of rxjava's internal subscribes).

Not really sure how to proceed on this though :/

 =||= Actually, I think just knowing state about LambdaObserver would be suitable. It's probably not an unsafe assumption that if someone is actually implementing onError, they are responsible for their own implementation. =||= Any further thoughts on exposing LambdaObserver state? =||= Modifying `LambdaObserver` (and all the other types) sounds like an acceptable tradeoff. =||= Cool. I can start working on a PR. With regards to it being internal currently, would you want to make it public with `isDefaultErrorConsumer` then? Or maybe a higher level interface that it just implements while keeping the implementation internal? =||= Implementing an interface simplifies the detection of the feature but otherwise will make a method public on `LambdaObserver` anyway. 

I'd say let's add a `HasDefaultErrorConsumer` interface into the `io.reactivex.observers` package. =||= Sounds good, I'll start on that =||= Continued in #5590 =||= ,0
5600,5595,2.x: Documentation error in Observable for "any" operator,In v.2 javadoc for `Observable`, it is stated (in at least 2 places) that the `any()` operator returns an `Observable`. This appears to be wrong: it returns a `Single` (which is stated correctly in other places). The corresponding entry in the `Flowable` docs appears to be correct. ,Yes, there are a couple of such mistakes, i.e. `all` is wrong as well. Would you like to submit a PR? =||= TBH I don't know enough about GitHub to feel comfortable with creating/submitting PRs. Sorry.  =||= Perhaps someone else can pick it up. PR welcome. =||= Closing via #5600. =||= Got another one for you: in Observable, it's stated that isEmpty() returns an Observable when it's actually a Single. 

On Sep 14, 2017, at 07:24 AM, David Karnok <notifications@github.com> wrote:

Closed #5595.
—
You are receiving this because you authored the thread.
Reply to this email directly, view it on GitHub, or mute the thread.

 =||= Covered by #5600. =||= ,0
5609,5608,2.1.3 Observable#concatMapEager queue size issue,Hello,

I've got some issues with ConcatMapEager prefetch value. 

It seems that concatMapEager stops before the end of the Observable.

Here is a small example showing the issue : 

```java
Observable.range(1, 100000)
        .buffer(10)
        .concatMapEager(value -> Observable.just(value)
                .subscribeOn(Schedulers.io())
                .doOnNext(it -> Thread.sleep(ThreadLocalRandom.current().nextLong(10, 100))),
            6, 4)
        .blockingSubscribe(it -> System.out.println("Received : " + it));
```

This small code is supposed to write list of ints till 100000. It stops before finishing.

The code doesn't work for the default ConcatMapEager function either (prefetch = 128)
,Thanks for reporting. Fixed in #5609. =||= Closing via #5609. =||= ,0
5616,5382,2.x Single.delay documentation and implementation inconsistent,The documentation for Single.delay says that success or error signals will be delayed by the specified amount, but in fact errors are not delayed, only successes. I have no opinion on which one should be correct - I ran into it when mocking out the response for an incomplete backend to test a loading/error UI, e.g. `Single.error(...).delay(3, TimeUnit.SECONDS)`, and found that my errors never had a delay. It seems that Observable has both options, with a version of the method that has a boolean flag `delayError`.

https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Single.java#L1636
https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java#L66,Indeed there is no option for that in `Single` and `Maybe`. Would you like to submit a PR? =||= @akarnokd : I've submitted my first PR fixing this -> https://github.com/ReactiveX/RxJava/pull/5409 Kindly review and advice. Thanks. =||= Closing via #5409. =||= ,0
5637,5634,2.x: Javadoc errors,The `javadoc` tool in Java 8 is more strict and reports a couple of tag errors in the current build. These should be easy to fix. PR welcome:

```
:javadoc/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:2124: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:2151: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:2179: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:2209: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:2236: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:5620: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:5679: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:6912: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:6942: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:7094: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:7136: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:7396: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:8339: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:8375: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:8414: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:8508: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:8631: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:8674: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:8723: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:10114: error: text not allowed in <ul> element

     *     to signal the overflow to the producer.</li>j

                                                       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:10215: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:13129: error: self-closing element not allowed

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:13129: warning: empty <p> tag

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:13956: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:13998: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:16066: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:16114: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:16165: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/processors/BehaviorProcessor.java:37: warning: empty <p> tag

 * <p>

   ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/processors/PublishProcessor.java:43: warning: empty <p> tag

 * <p>

   ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/processors/ReplayProcessor.java:47: warning: empty <p> tag

 * <p>

   ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/subscribers/DefaultSubscriber.java:54: error: bad use of '>'

 *     .subscribe(new DefaultSubscriber&lt;Integer>() {

                                                  ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/subscribers/DisposableSubscriber.java:53: error: bad use of '>'

 *     .subscribeWith(new DisposableSubscriber&lt;Integer>() {

                                                         ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/subscribers/ResourceSubscriber.java:66: error: bad use of '>'

 *     .subscribeWith(new ResourceSubscriber&lt;Integer>() {

                                                       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/subscribers/ResourceSubscriber.java:69: error: bad use of '>'

 *                 .scheduleDirect(() -> System.out.println("Time!"),

                                       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/subjects/Subject.java:40: error: semicolon missing

     * &see {@link #hasComplete()}

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:5171: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:6246: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:6272: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:6401: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:6439: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:7442: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:7475: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:7557: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:7599: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:7691: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:7728: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:7769: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:10986: error: self-closing element not allowed

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:10986: warning: empty <p> tag

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:11762: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:11800: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/subjects/BehaviorSubject.java:35: warning: empty <p> tag

 * <p>

   ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Completable.java:210: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Maybe.java:466: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Maybe.java:840: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Maybe.java:2274: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Maybe.java:2304: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Maybe.java:3806: error: self-closing element not allowed

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Maybe.java:3806: warning: empty <p> tag

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Maybe.java:3829: error: self-closing element not allowed

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Maybe.java:3829: warning: empty <p> tag

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/subjects/PublishSubject.java:30: warning: empty <p> tag

 * <p>

   ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/subjects/ReplaySubject.java:35: warning: empty <p> tag

 * <p>

   ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Single.java:347: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Single.java:605: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Single.java:698: warning: empty <p> tag

     * <p>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Single.java:2404: error: self-closing element not allowed

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Single.java:2406: error: self-closing element not allowed

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Single.java:2416: error: self-closing element not allowed

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Single.java:2438: error: self-closing element not allowed

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Single.java:2440: error: self-closing element not allowed

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Single.java:2450: error: self-closing element not allowed

     * <p/>

       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Scheduler.java:202: error: bad use of '>'

     * Scheduler limitScheduler = Schedulers.computation().when(workers -> {

                                                                         ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Scheduler.java:220: error: bad use of '>'

     * Scheduler limitScheduler = Schedulers.computation().when(workers -> {

                                                                         ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Scheduler.java:233: error: bad use of '>'

     * Scheduler slowScheduler = Schedulers.computation().when(workers -> {

                                                                        ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Scheduler.java:235: error: bad use of '>'

     *  return Completable.concat(workers.map(actions -> {

                                                       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/DefaultObserver.java:43: error: bad use of '>'

 *     .subscribe(new DefaultObserver&lt;Integer>() {

                                                ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/DisposableCompletableObserver.java:39: error: bad use of '>'

 *     .subscribeWith(new DisposableMaybeObserver&lt;Integer>() {

                                                            ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/DisposableMaybeObserver.java:43: error: bad use of '>'

 *     .subscribeWith(new DisposableMaybeObserver&lt;Integer>() {

                                                            ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/DisposableObserver.java:44: error: bad use of '>'

 *     .subscribeWith(new DisposableObserver&lt;Integer>() {

                                                       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/DisposableSingleObserver.java:39: error: bad use of '>'

 *     .subscribeWith(new DisposableSingleObserver&lt;Integer>() {

                                                             ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/ResourceCompletableObserver.java:59: error: bad use of '>'

 *                 .scheduleDirect(() -> System.out.println("Time!"),

                                       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/ResourceMaybeObserver.java:60: error: bad use of '>'

 *     .subscribeWith(new ResourceMaybeObserver&lt;Integer>() {

                                                          ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/ResourceMaybeObserver.java:63: error: bad use of '>'

 *                 .scheduleDirect(() -> System.out.println("Time!"),

                                       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/ResourceObserver.java:55: error: bad use of '>'

 *     .subscribeWith(new ResourceObserver&lt;Integer>() {

                                                     ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/ResourceObserver.java:58: error: bad use of '>'

 *                 .scheduleDirect(() -> System.out.println("Time!"),

                                       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/ResourceSingleObserver.java:57: error: bad use of '>'

 *     .subscribeWith(new ResourceSingleObserver&lt;Integer>() {

                                                           ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/observers/ResourceSingleObserver.java:60: error: bad use of '>'

 *                 .scheduleDirect(() -> System.out.println("Time!"),

                                       ^

/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/package-info.java:43: error: unexpected end tag: </p>

 * </p>

 ```,Closing via #5637. =||= It's still open =||= ,0
5644,5618,JDK9: define a stable automatic module name with `Automatic-Module-Name` entry in MANIFEST,JDK9 is out and introduces a module system.

RxJava does not currently use modules. When we use it in a JDK9 modular application, Java turns the JAR into a so-called automatic module, whose name is derived from the JAR archive name. However, the default name does not follow the recommended module naming conventions (reverse-dns style, module name derived from the main exported package).

It is possible to specify a stable automatic module name through a `Automatic-Module-Name` manifest entry, while still targeting JDK8:

```
Automatic-Module-Name: io.reactivex
```

Selecting a stable module name is very important, because Java does not allow two modules to own the same package, and you may end up with a module hell. The naming issues are well-explained on Stephen Colebourne's blog:

 * http://blog.joda.org/2017/04/java-se-9-jpms-module-naming.html
 * http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html <- the explanation of module hell problem

And the comment of Mike Reinhold, chief Java architect:

> Strongly recommend that all modules be named according to the reverse Internet domain-name convention. A module's name should correspond to the name of its principal exported API package, which should also follow that convention. If a module does not have such a package, or if for legacy reasons it must have a name that does not correspond to one of its exported packages, then its name should at least start with the reversed form of an Internet domain with which the author is associated.,io.reactivex.rxjava2 would be better.

On Sun, Sep 24, 2017, 11:14 AM Tomasz Jędrzejewski <notifications@github.com>
wrote:

> JDK9 is out and introduces a module system.
>
> RxJava does not currently use modules. When we use it in a JDK9 modular
> application, Java turns the JAR into a so-called automatic module, whose
> name is derived from the JAR archive name. However, the default name does
> not follow the recommended module naming conventions (reverse-dns style,
> module name derived from the main exported package).
>
> It is possible to specify a stable automatic module name through a
> Automatic-Module-Name manifest entry, while still targeting JDK8:
>
> Automatic-Module-Name: io.reactivex
>
> Selecting a stable module name is very important, because Java does not
> allow two modules to own the same package, and you may end up with a module
> hell. The naming issues are well-explained on Stephen Colebourne's blog:
>
>    - http://blog.joda.org/2017/04/java-se-9-jpms-module-naming.html
>    - http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html
>    <- the explanation of module hell problem
>
> And the comment of Mike Reinhold, chief Java architect:
>
> Strongly recommend that all modules be named according to the reverse
> Internet domain-name convention. A module's name should correspond to the
> name of its principal exported API package, which should also follow that
> convention. If a module does not have such a package, or if for legacy
> reasons it must have a name that does not correspond to one of its exported
> packages, then its name should at least start with the reversed form of an
> Internet domain with which the author is associated.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/5618>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEQv68UhFi-hX8Vt_XfaYZE8M4YADks5slnHCgaJpZM4Ph64L>
> .
>
 =||= What is the automatic module name RxJava it receives now? What happens to those who are already using this auto-name in their projects? =||= The filename of the jar is used.

On Sun, Sep 24, 2017 at 11:34 AM David Karnok <notifications@github.com>
wrote:

> What is the automatic module name RxJava it receives now? What happens to
> those who are already using this auto-name in their projects?
>
> —
> You are receiving this because you commented.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/5618#issuecomment-331717722>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEES2c_67cR_p2IydyztcdK4klk5qfks5slnZwgaJpZM4Ph64L>
> .
>
 =||= Currently, to use Mockito you have to use the name derived from the JAR file:

```java
module com.example.foo {
   requires mockito.core;
}
```

If you change this name later to `org.mockito` (or even change the JAR name), and there will be other modular projects that use Mockito as a dependency under the old `mockito.core` name, you'll fall into a module hell, because Java will refuse to compile an application that tries to import both `mockito.core` and `org.mockito`. From JVM perspective, they will be two distinct modules with the same packages inside, which is illegal.

The second link provided in the original issue description contains a great explanation of the module hell problem. =||= I see another problem: RxJava 2 is located in `io.reactivex` package so RxJava 3 can't be in `io.reactivex` or any of its subpackages if we want to allow them to live side-by-side. =||= Actually, you can put RxJava 3 into a subpackage. `io.reactivex` and `io.reactivex.rxjava3` is not considered as a package split. It will be also possible to create a module named `io.reactivex.rxjava3`. =||= I see. Since this only affects a line in the generated manifest, PR welcome. =||= Closing via #5644. =||= ,0
5647,5642,Maybe.subscribeWith() has incorrect documentation,`Maybe.subscribeWith()` [documentation ](https://github.com/ReactiveX/RxJava/blob/v2.1.5-RC4/src/main/java/io/reactivex/Maybe.java#L3771-L3799) suggests that it returns a `Disposable` and contains this example (translated to Kotlin):

```kotlin
    val source = Maybe.just(1)
    val composite = CompositeDisposable()
    val ms = object : MaybeObserver<Int> {
      // ...
    }
    composite.add(source.subscribeWith(ms))
```

This code does not compile, because `MaybeObserver` does not implement `Disposable`.

Should the documentation suggest to use `DisposableMaybeObserver` here?
If yes, I can submit a PR.,Yes, `DisposableMaybeObserver` should be there. PR welcome. =||= Closing as PR got merged. =||= ,0
5649,4853,2.x: switchMapSingle and switchMapCompletable,Hey,

the addition of `flatMapSingle`/`flatMapCompletable` made the usage of `Single` and `Completable` way nicer in RxJava 2.
Do you consider adding `switchMapSingle`/`switchMapCompletable` to RxJava 2 as well?

Cheers,You mean 1.x? I have no plans for that and I don't want to keep 1.x alive for too long. I'd like to stop enhancing 1.x in 6 months and enter it into a bugfix-only mode. Otherwise 3rd party libraries may delay their upgrade way longer.
 =||= He wants `switchMapSingle` and `switchMapCompletable` for RxJava 2 just like there is `flatMapSingle` and `flatMapCompletable`
 =||= @vanniktech exactly
 =||= Ah right. No plans for extending any other xMap operator
 =||= But then `concatMap` also needs the variants in order to be consistent. To be honest I forgot about those when proposing `flatMapSingle / flatMapCompletable / flatMapMaybe` initially - #4667 

And then there's also `Maybe`. Plus `Observable` and `Flowable` are able of mapping so it's easily another 12 methods.
- Observable.switchMapSingle
- Observable.switchMapMaybe
- Observable.switchMapCompletable
- Observable.concatMapSingle
- Observable.concatMapMaybe
- Observable.concatMapCompletable
- Flowable.switchMapSingle
- Flowable.switchMapMaybe
- Flowable.switchMapCompletable
- Flowable.concatMapSingle
- Flowable.concatMapMaybe
- Flowable.concatMapCompletable
 =||= If it is not on the roadmap because you don't want to add any more xMap operators, then I understand.

But if it is due to lack of the time, would you consider accepting contributions on the topic?
 =||= Sure, but these operators are not easy.
 =||= Yes, I know, those are one of the hardest. 
Still, I will at least have a look and see if I can deliver a PR.

Cheers!
 =||= Any progress on this? =||= I'm happy to have a look at this one if @tomaszpolanski doesn't have time at the moment. =||= @davidmoten It would be great! My available time now is pretty limited.  =||= So the list of new operators is quite big. Currently:

* Observable.switchMapSingle
* Observable.switchMapMaybe
* Observable.switchMapCompletable
* Observable.concatMapSingle
* Observable.concatMapMaybe
* Observable.concatMapCompletable
* Flowable.switchMapSingle
* Flowable.switchMapMaybe
* Flowable.switchMapCompletable
* Flowable.concatMapSingle
* Flowable.concatMapMaybe
* Flowable.concatMapCompletable

I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one. An example would be `Observable.switchMapSingle`:

```java
public final <R> Observable<R> switchMapSingle(
    final Function<? super T, ? extends SingleSource<? extends R>> mapper) {
        Function<? super T, Observable<R>> mapper2 = t -> 
            {
                SingleSource<? extends R> source = mapper.apply(t);
                Single<? extends R> single;
                if (source instanceof Single) {
                    single = (Single<? extends R>) source;
                } else {
                    single = Single.unsafeCreate(source);
                }
               return (Observable<R>) single.toObservable();
            };
        return switchMap(mapper2, bufferSize());
    }
```

This is just to demo the idea, I wouldn't use an anonymous class and lambdas are just used for readability.

@akarnokd any interest in this?
 =||= > I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one.

Indeed.

> An example would be

If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in `io.reactivex.internal.operators.flowable.FlowableInternalHelper` and its respective variants.

> any interest in this?

I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted. =||= >If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in io.reactivex.internal.operators.flowable.FlowableInternalHelper and its respective variants.

Yep no problems. I've appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too.

>I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted.

Sure. I'll proceed with PRs with unit tests for the new operators and I'm happy to have a stab at dedicated operators after that. =||= What is expected behaviour for `Observable.switchMapMaybe` and `Observable.switchMapCompletable`? I can try to take care of it but I am not convinced what that method should return.
 =||= In the mean time, would it be correct to assume that an acceptable workaround for this is as follows?: **.toObservable()**

```
upstream.concatMap {
        someObservable().collect{...}.toObservable()
    }
``` =||= @feresr 
Probably yes, at this moment in few places inside my code i have this type of stucture. It is very weird and uncessesery code but it is understandable.
@akarnokd 
What do you think about method switchMapCompletable which emit Object or maybe some enum? On the other hand we can we can swallow information about stream and do not emit anything. =||= @marcinsus I don't fully understand your question. Use `switchMapCompletable().andThen(Single)` to emit something after the switch completed. =||= The problem he talks about is that switchMapCompletable does not exist. 

switchMapSingle returns an Observable of the Single type.

So technically switchMapCompletable should return Void. (Which it can't, because that has no instance.) So he asks if the signature should rather expose some `enum Nothing` or just an `Object` =||= An `Observable.switchMapCompletable` should return `Completable`. =||= You are right as `flatMapCompletable` returns a `Completable`.

But now I find it weird that 
`Observable.flatMapSingle<T>`returns an `Observable<T>`
but 
`Observable.flatMapCompletable` returns an `Completable`. =||= A stream of 5 elements flatMap'd to a stream of a single element still results in a stream of 5 elements. =||= I'm working on implementing `concatMapCompletable` across the reactive types.

I'm wondering if the library should also have implementations of
`concatMapDelayErrorCompletable`, `concatMapEagerCompletable`, `concatMapEagerDelayErrorCompletable`?


 =||= `concatMapEagerCompletable` is indistinguishable from `flatMapCompletable` because all sources run concurrently and their only output is a terminal event; no items have to be buffered until their turn. Also the `maxConcurrency == 1` gets you `concatMapCompletable` behavior. =||= Ahh yes that makes sense.  

So is there any reason to implement `concatMapCompletable` at all?  If so do you want it to just use flatMapCompletable() internally or should there be a new direct implementation (what I've been working on)? =||= Actually, `Observable.flatMapCompletable` doesn't have `maxConcurrency` overload thus there might be a reason to implement `concatMapCompletable`. =||= Ok I'll keep at it then =||= https://github.com/ReactiveX/RxJava/issues/4853#issuecomment-281541715

Did anything ever come of this?  =||= #5161 and #5649 added some operators. =||= So there are plans to implement the other operators, but not in any particular timeframe? =||= The listed operators can simply expressed with the existing default operators and `toObservable`/`toFlowable` in the lambda parameters. Unfortunately, very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function. Imagine, you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code. Kotlin's extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the RxJava library. The issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer, I'm not particularly interested myself in tackling these types of operators. =||= Closing via #5870, #5871, #5872, #5873, #5875. =||= ,0
5653,564,Different behaviors of `SequenceEqual` in Rx.Net and RxJava,Looks `SequenceEqual` in Rxjava is not correct. 

In Rx.Net, `SequenceEqual` returns an Observable which only has one element indicating if these two sequences are same. For example,

``` c#
            var o = Observable.SequenceEqual(Observable.Range(1, 100), Observable.Range(1, 100));
            var s = o.Subscribe(
                v => Console.WriteLine("Equal = " + v),
                e =>  Console.WriteLine(e),
                () => Console.WriteLine("onCompleted")
                );
            Console.WriteLine("Press any key...");
            Console.ReadKey();
```

Outputs:

<pre>
Equal = True
onCompleted
Press any key...
</pre>


But in RxJava, the following codes:

``` java
        Observable
                .sequenceEqual(Observable.range(1, 100),
                        Observable.range(1, 100)).toBlockingObservable()
                .forEach(new Action1<Boolean>() {
                    @Override
                    public void call(Boolean t1) {
                        System.out.println(t1);
                    }
                });
```

Output 100 `true`s.,I've noticed that using `zip` to pair up values is not the same behavior as in Rx.NET. In Rx.NET, the operator checks if the length of the streams are the same or not. Even if we don't want to do that, one could add a simple `all` operator after the zip:

``` java
public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, 
        Observable<? extends T> second, Func2<? super T, ? super T, Boolean> equality) {
    return zip(first, second, equality).all(Functions.<Boolean>identity());
}
```

Using the materialized view is not an option as errors need to be propagated directly and not compared (and generally, equals doesn't work on Throwables).
 =||= I can take this this weekend.
 =||= fixed in #575
 =||= ,0
5653,5641,2.x: TestNG log details,The skipped TestNG tests show up in the Travis-CI without the actual method name:

```
Gradle suite > Gradle test > io.reactivex.tck.ZipWithTckTest. SKIPPED
```

whereas the JUnit tests are fine:

```
io.reactivex.subscribers.SafeSubscriberWithPluginTest > testPluginExceptionWhenUnsubscribing2 SKIPPED
```

It would be great TestNG output would include the method name as well. PR welcome.,Closing via #5641. =||= ,0
5655,5077,Take Doesn't Reduce Large RequestN,When a child subscriber submits a large requestN value, such as Long.MAX_VALUE, the 'take' operator does not reduce it as expected. 

For example, in the following where a default subscribe happens and requests Long.MAX_VALUE up, it is expected that the `take(10)` would adjust the requested size to the max value that take will permit through.

```java
someFlowable.take(10).subscribe(s)
```

Here is a unit test:

```java
    @Test
    public void testDoesntRequestMoreThanNeededFromUpstream2() throws InterruptedException {
        final AtomicLong requests = new AtomicLong();
        TestSubscriber<Long> ts = new TestSubscriber<Long>();
        Flowable.interval(100, TimeUnit.MILLISECONDS)
            .doOnRequest(new LongConsumer() {
                @Override
                public void accept(long n) {
                    System.out.println(n);
                    requests.addAndGet(n);
            }})
            .take(2)
            .subscribe(ts);
        
        ts.awaitTerminalEvent();
        ts.assertComplete();
        ts.assertNoErrors();
        assertEquals(2, requests.get());
    }
```

This errors with:

```
java.lang.AssertionError: expected:<2> but was:<9223372036854775807>
	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:834)
	at org.junit.Assert.assertEquals(Assert.java:645)
	at org.junit.Assert.assertEquals(Assert.java:631)
	at io.reactivex.internal.operators.flowable.FlowableTakeTest.testDoesntRequestMoreThanNeededFromUpstream2(FlowableTakeTest.java:419)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
```

Is there a reason that `take` in RxJava 2 does not behave this way and reduce the requestN value to the limit?,If the downstream is requesting more than N, the operator requests unbounded so the upstream can go on a fast-path when it emits. Take will then stop the upstream at N and there is no overflow. If the downstream requested M < N, take will also just request M.

Try this:

```java
Flowable.interval(100, TimeUnit.MILLISECONDS)
            .doOnRequest(new LongConsumer() {
                @Override
                public void accept(long n) {
                    System.out.println(n);
                    requests.addAndGet(n);
            }})
            .take(2)
            .rebatchRequests(1)         // <-----------------------------------------
            .subscribe(ts);
``` =||= That doesn't make sense to me and differs from v1 behavior. If the upstream is across a network boundary that means someone has to know that take doesn't actually reduce the requested amount and therefore always needs to use both take and rebatch. 

I don't buy the argument that if downstream requests more that this should be done, as it is normal for the downstream subscriber to use the default value and take to be used to constrain the output. 

If unconstrained output was wanted I'd use an Observable, but I'm using Flowable so expect it to be constrained.  =||= > differs from v1 behavior

New major versions have the opportunity to change behavior on some level.

> If the upstream is across a network boundary that means someone has to know that take doesn't actually reduce the requested amount and therefore always needs to use both take and rebatch.

Is this for the ReactiveSocket library? As an IO boundary provider, you should never trust the downstream's request amount the same way as `observeOn` doesn't trust it and requests on its own pace. =||= No it's not for ReactiveSocket. But it's for Reactive Streams APIs that involve IO. 

I understand a major version can change behavior, but I don't understand why this would change. Please explain why the very small perf improvement in the source is worth changing this behavior? The point of Flowable is to constrain emission. If I wanted unconstrained I'd use Observable. 

Why should the source not be restricted to the maximum that take will accept for real world use cases and not just fabricated micro benchmarks? =||= > §3.17: A Subscription MUST support an unbounded number of calls to request and MUST support a demand (sum requested - sum delivered) up to 2^63-1 (java.lang.Long.MAX_VALUE). A demand equal or greater than 2^63-1 (java.lang.Long.MAX_VALUE) MAY be considered by the Publisher as “effectively unbounded”[3].

It is completely legal for an operator to go unbounded if it ensures the rest of the rules towards its downstream consumer. Running unbounded means less overhead from operators which means more time to process the actual items, especially those just came over from an async boundary (observeOn).

>  If I wanted unconstrained I'd use Observable

You are still thinking about requests as an end-to-end way of communicating with some server and sending a message to it requesting the next item based on consumption at the very end. Reactive-Streams backpressure is different. It is a negotiation between subsequent operators. Some may not interfere it, some might change the timing or amount, some might go unbounded. It is about honoring the downstream's amount and working out an amount for the upstream.

For example:

```java
source.observeOn(Schedulers.computation()).take(5).subscribe(...)
```
Will the `source` consumed in an unbounded manner just because `take(5)` goes unbounded? 

**No**. 

`take(5)` and `observeOn` negotiate that `observeOn` is free to emit as fast as it can and as many items as available because take can handle it. 

`source` and `observeOn` negotiate that due to the async boundary, batching is desired thus `observeOn` requests the default amount (128) and keeps requesting once `take` consumed what's already became available over the boundary. This requires `source` to honor that initial 128 and any subsequent requests (96). =||= > It is completely legal for an operator to go unbounded if it ensures the rest of the rules towards its downstream consumer. 

Yes I know that. I was involved in arguing for inclusion of that rule in the Reactive Streams spec and know the benefits. 

> You are still thinking about requests as an end-to-end way of communicating with some server and sending a message to it requesting the next item based on consumption at the very end. Reactive-Streams backpressure is different. 

No I'm not. Remember I was part of the founding group for Reactive Streams, so I understand the semantics. Early in the discussions it was assumed every operator hop was async, but we argued that hops could be synchronous and therefore would benefit from optimizations in the spec, such as rule 3.17 and 2.2. 

> Some may not interfere it, some might change the timing or amount, some might go unbounded. It is about honoring the downstream's amount and working out an amount for the upstream.

I understand that, and am not questioning that. I'm questioning a simple implementation choice, not a contractual or semantic problem. Everything that the `take` operator is doing is perfectly legal. I am purely questioning the decision to not alter the upstream `request(n)` as it seems a legitimate choice to reduce to the limit. 

But I won't bother attempting discussion any further. It's not important enough to me.  =||= thanks for raising this @benjchristensen. I wasn't aware of it. 

So I'm assuming then that if I've got some synchronous network requesting source (that can't effectively emit partially e.g. a web service request that returns a list of items) and I don't want that source to transfer an unnecessarily large list in reaction to a `take(2)` then I suppose I would have to do this:

```java
source.rebatchRequests(2).take(2);
```
This is certainly an uncommon use case for me but I did like that in RxJava 1.x upstream requests were constrained generally to what was required by downstream with the exception of a few well-known operators like `flatMap` and `observeOn`. Perhaps now I can't make any assumptions and when I want to constrain requests I need to use `rebatchRequests` in lots of places. We'll see how that goes I suppose. 
  =||= @akarnokd or @benjchristensen  can you reopen this issue? I think it needs more discussion. =||= The use case is fairly common for me. Consider this:

Library:

```java
public Flowable<Data> getDataFromNetwork(Input args) {
   return SomeFlowable(...)
               // ensure over network we do no more than request(128)
               .rebatchRequests(128);
}
```

Then a consumer that I don't control:

```java
getDataFromNetwork(...).take(10).subscribe(...)
```

In that case I would prefer to only request 10 items over the network, but in the `getDataFromNetwork` method I don't know what my consumers will request. And the consumer calling it doesn't and shouldn't know the implementation details. So, the way `take` is currently implemented, I will have to just request(128), start emitting over the network, over produce and asyhnchronously race a `cancel` back over the network. Most likely I will end up producing all 128, sending many or most of them over the network, and then dropping 118 of them on the floor.

 =||= Yep, I'm not a fan of that behaviour and I'm sure I'll encounter it tying together service calls as our organisation moves more logic behind services. There's a broader consideration here I suppose which is how much should users of the RxJava api know or expect of the request behaviour of operators. We don't really have a guiding principle in place that helps us here. For me I'd like to see operators only request what they need and where for performance considerations it makes sense to request in batches  (across async boundaries for instance) then it should be configurable. `flatMap` and `observeOn` are configurable in this regard. 

I've had a quick look through the list of operators and I've identified the operators that I'd prefer only requested what they need. To have constrained requesting behaviour on these operators as well as the ability to configure `flatMap`, `observeOn` and call `rebatchRequests` is enough control over request patterns for my needs.

Note that all these below request `Long.MAX_VALUE`:
```
elementAt
firstXXX
take
```
The operators above are the only operators I saw that have a definite upper bound that is less than `Long.MAX_VALUE` on the number of items required to complete.



 =||= Anything that has the `@BackpressureSupport(UNBOUNDED_IN)`, including `subscribe(Consumer)`. It is the duty of the `getDataFromNetwork(...)` to turn any downstream request pattern into a reasonable amount for its level, for example, by `rebatchRequests` internally. =||= @akarnokd is right the way we solve it on the same behavior with our network components (at least kafka, redis and netty ones) is to address the Network IO by prefetch at generator level. Basically backpressure certainly applies around boundaries and you shouldn't bind yourself into a request behavior downstream.

In the end the unbounded information is still valuable as you influence the rate of replenishing upstream. We talked about it with @akarnokd  last year already when we were experimenting with reactive-streams-commons and it we agreed then for the 3 libraries (including reactor) it seemed the right thing to do without failing the specification. So far we have one contention point with the RS spec which is to signal error if request is invalid/negative that we ignore until a special operator is used. 

That's the same question with aggregating operators for instance which are going to be unbounded given the implicit contract that no callback is blocking. Of course it could block if told otherwise by an explicit thread jump like observeOn which then falls into the category discussed above for the generator, prefetch fixed-size queue.  =||= > It is the duty of the getDataFromNetwork(...) to turn any downstream request pattern into a reasonable amount for its level, for example, by rebatchRequests internally.

This makes total sense that it must define the max, but when it is known that the downstream is requesting less, then it would be better if that information was passed upwards so requests are constrained all the way up the chain. 

Regarding the specific implementation of `take`, its current implementation makes total sense if optimizing for synchronous behavior and microbenchmarks. However, synchronous behavior is best served by `Iterable` or `java.util.Stream`. `Flowable` is intended for constrained emission over async boundaries. 

In practice, the cost of over-producing elements, and over-sending elements across async boundaries (network, threads, queues) is far higher than any optimization gained by sending `request(Long.MAX_VALUE)` to allow micro-optimizations. 

Thus, I suggest `take` is optimizing for the wrong thing and should instead focus on allowing the prevention of over-production across async boundaries - the very case `Flowable` is intended for. =||= >This makes total sense that it must define the max, but when it is known that the downstream is requesting less, then it would be better if that information was passed upwards so requests are constrained all the way up the chain.

I agree with this. The potentially bounded request from a `take` or the request of one from a `first` is valuable information that can help upstream do less. I understand the benefits of initiating a fast path in the upstream and allowing cancellation to chop it off  but this only applies for a particular category of Flowable and we are favouring this category too much.

It might be worth noting that `take(N)` will pass through requests smaller than N if it is not already unbounded so `getDataFromNetwork()` could conceivably get a lot of requests for 1 item for instance. This might seem like a problem for using requests to determine `getDataFromNetwork` fetch amounts but I don't think it is. I'm making operators in rxjava2-extras like `.rebatchRequests(min, max, constrainFirstRequest)` which would rebatch requests between min and max and according to the boolean parameter would allow the first request to be less than min (max always applies).

`getDataFromNetwork` might be defined like this:
```java
public Flowable<Data> getDataFromNetwork() {
   return SomeFlowable(...)
               // ensure over network we do no more than request(128)
               // first request is allowed through even if less than 10
               // later requests smaller than 10 will be rebatched to 10
               .rebatchRequests(10, 128, true);
}
```
and use cases like these below would all be quite efficient in terms of the network fetch if `take`,`first`,etc didn't go unbounded:

```java
//will fetch 1
getDataFromNetwork().first().subscribe();

//will fetch in batches of 128 
getDataFromNetwork().take(1000000).subscribe();

//will fetch 1, then 10, 10, 10, ...
getDataFromNetwork().take(100).rebatchRequests(1).subscribe(); 
```

This approach is helpful when calls to the network source may happen frequently overall from many client processes (distributed or not) but the individual subscriptions to `getDataFromNetwork()` are not that busy. =||= Let's assume `take` didn't request unbounded, the following setup would still result in an excessive network usage if the source doesn't adjusts request amounts:

```java
networkSource().take(1_000_000)
.subscribe(v -> { }, e -> { }, () -> { }, s -> s.request(1_000_000));
```

In RxJava, whenever there is a boundary, the operator adjusts its input request amounts to remain reasonable, such as `observeOn` and `flatMap`. `take` is not an async boundary, nor `reduce`, `map`, `first`, etc. =||= >Let's assume take didn't request unbounded, the following setup would still result in an excessive network usage if the source doesn't adjusts request amounts.

Yep I agree, but we use a different rebatching operator internal to `networkSource()` that offers more flexibility than the existing `rebatchRequests` and still limits the fetch amounts across the network.

I've implemented some new request limiting operators in [`rxjava2-extras`](https://github.com/davidmoten/rxjava2-extras) (`minRequest`, `maxRequest` and `rebatchRequests(min, max, constrainFirstRequestMin)` and another creation method called `fetchPagesByRequest` whose documentation has a fully worked [example](https://github.com/davidmoten/rxjava2-extras#fetchpagesbyrequest) of what I'm getting at. 

If there's viability to these new operators then review would be nice later (it's only a day old and I'll check it some more in the next week or two).

Critical to the argument is that I want support for sources that under-the-covers don't easily support streaming. This is a common situation especially for integrating legacy distributed services using RxJava. =||= Like @davidmoten I am doing rebatching myself before sending over the network as the built-in one is too limiting. I for example want:

- an initial request of 256
- subsequently maintain it at 64
- send lower request value if downstream requests lower (such as what I expect take to do) =||= @benjchristensen As you demonstrated publicly, you consider keeping behavioral compatibility very important and defended it to ensure continued interoperability. I have the same priority regarding changes to established behavior in RxJava 2 where I believe there was plenty of time before release anyone could bring up this problem, at which point and even now, I see the following compatible changes possible:

1) have a `FlowableTransformer`-based `take()` variant in a library outside RxJava 2,
2) have a new method with the behavior: for example, reintroduce `limit(n): limits both the request amount and items consumed from upstream` , or
3) have an overload with a parameter about the backpressure handling strategy.

@davidmoten 

In case you plan to implement any of the options, you may want to prepare for the following case setup:
```source.limit(150).observeOn(scheduler)```. 

If you want the 150 to be the upper bound of the sum of total requests sent to `source`, you need custom accounting because `observeOn` will first request 128 and once reaching the 96th item, another 96 is requested which would overshoot 150 unless capped by logic in `request()`. =||= >there was plenty of time before release 

Sort of. That enormous rewrite was never going to get a thorough review, people didn't have the time unfortunately. I'm also not sure if this issue was ever raised specifically and discussed in terms that would have sparked reaction. I went looking for it in old issues and PRs and couldn't find it (but might be there of course).

That's water under the bridge now of course. @akarnokd are you open to a breaking change on this one so that the default behaviour is not unbounded? I frankly doubt it would affect anyone at all and the only people that would have read and absorbed the backpressure annotations on `take` etc would probably have been as surprised as @benjchristensen and myself.

>In case you plan to implement any of the options, you may want to prepare for the following case setup:
source.limit(150).observeOn(scheduler).

Yeah thanks for that, I did handle request accounting in the operators in rxjava-extras as you describe when I wrote them weeks ago. If you (or anyone else) can review them terrific. I opened an issue at https://github.com/davidmoten/rxjava2-extras/issues/4. =||= > are you open to a breaking change

Not really, adding a new operator `limit` or `take(n, eager)` is a better option. =||= I'd prefer an overload on `take` (and I suppose on `first` and `elementAt`) =||= That doesn't really help the primary use case for me since the consumer doesn't know what the producer behavior is. They shouldn't have to know to do this or not, the producer should just receive the smallest possible request(n) value - and take is a clear indicator that no more than the take(n) value ever needs to be produced. 

The point of Flowable is flow control across async boundaries - preventing over production and buffering. 

If optimizing for synchronous execution is what I was looking for I'd use Iterable/Stream. If flow control was not needed, I'd use Observable.  =||= Closing via #5655. =||= ,0
5660,5657,RxJava 1.3 -- timeout not unsubscribing from original observable,Version -- 1.3.0 (did not see any release notes in the subsequent 1.3.x releases about this).

Not sure if this is the expected behavior or not, but when I use the operator:

```
timeout(long timeout, TimeUnit timeUnit, Observable<? extends T> other)
```

it seems that if the timeout occurs and we switch to mirroring the `other` observable the operator does not unsubscribe from the original observable.  Based on the documentation I was expecting that this would essentially execute a "switch" like behavior, which would result in the original observable being unsubscribed.

Here is some code that demonstrates what I'm seeing:

```
        Subject<Long, Long> subject = PublishSubject.create();
        Observable<Long> initialObservable = subject.share().map(value -> {
            System.out.println("Received value " + value);
            return value;
        });

        Observable<Long> timeoutObservable = initialObservable.map(value -> {
           System.out.println("Timeout received value " + value);
           return value;
        });

        TestSubscriber<Long> subscriber = new TestSubscriber<>();
        initialObservable.timeout(1, TimeUnit.SECONDS, timeoutObservable).subscribe(subscriber);
        subject.onNext(5L);
        Thread.sleep(1500);
        subject.onNext(10L);
        subject.onCompleted();

        subscriber.awaitTerminalEvent();
        subscriber.assertNoErrors();
        subscriber.assertValues(5L, 10L);
```

Here is the output:

```
Received value 5
Received value 10
Received value 10
Timeout received value 10
```

I was only expecting one `Received value 10`.,Inserting `this.unsubscribe();` before line 200 in `OperatorTimeoutBase` gives me the behavior I was expecting.  Of course I'm not enough of an RxJava internals expert to know what other, less desirable side effects this might have (though naively it seems that once the timeout subscriber marks itself as terminated, it pretty much gets out of the way). =||= Thanks for reporting. This seems to be a bug somewhere in that operator which I can't pinpoint, the 1.x architecture is awkward. See #5660 for the proposed fix. =||= Closing via #5660. =||= ,0
5669,5545,2.x: PublishProcessorAsPublisherTckTest FAILED,> io.reactivex.tck.PublishProcessorAsPublisherTckTest. FAILED
>    java.lang.AssertionError: Publisher signalled [16] elements, which is more than the signalled demand: 15 > expected [true] but found [false]

Probably due to one of the resource leaks in the 1.0.0 TCK.,Closing as TCK 1.0.1 seems to have resolved this type of problem. =||= It has reoccurred: https://travis-ci.org/ReactiveX/RxJava/builds/279042961#L2495 =||= Closing via #5669. =||= ,0
5677,5676,observeOn on Flowable.rangeLong does not emit values on provided scheduler,Operators fusion  in RxJava 2 is a really nice feature but I have found a case when an implementation of Flowable.rangeLong (and I assume there is similar behavior in neighbor standard flowables) fused together with operator observeOn() breaks the semantics of the operator observeOn().
Basically, no emissions from FlowableRangeLong flowable is done on the scheduler provided in observeOn() but rather on the thread which calls request() in the chain.
Here is the code snipped which reproduces the issue.

```java
import io.reactivex.Flowable;
import io.reactivex.FlowableSubscriber;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.Schedulers;
import org.reactivestreams.Subscription;

public class RxJavaFuseTest {
    public static void main(String[] args) {
        FlowableSubscriber sequentialSubscriber = new FlowableSubscriber() {
            private Subscription s;

            @Override
            public void onSubscribe(Subscription s) {
                this.s = s;
                this.s.request(1);
            }

            @Override
            public void onNext(Object x) {
                s.request(1);
            }

            @Override
            public void onError(Throwable e) {
                e.printStackTrace();
                System.exit(0);
            }

            @Override
            public void onComplete() {
                System.out.println("Completed");
                System.exit(0);
            }
        };

        Flowable.rangeLong(0, 10)
                .observeOn(RxJavaPlugins.createSingleScheduler(r -> new Thread(r, "producer")), false, 1)
                .doOnNext(aLong -> {
                    System.out.println(aLong + " emitting on " + Thread.currentThread().getName());
                })
                .parallel(2, 1)
                .runOn(Schedulers.computation(), 1)
                .doOnNext(aLong -> System.out.println(aLong + " processing on " + Thread.currentThread().getName()))
                .sequential()
                .subscribe(sequentialSubscriber);
    }
}
```

Output is as follows:

```
0 emitting on main
0 processing on RxComputationThreadPool-1
1 emitting on main
2 emitting on main
1 processing on RxComputationThreadPool-2
2 processing on RxComputationThreadPool-1
3 emitting on main
4 emitting on main
3 processing on RxComputationThreadPool-2
5 emitting on RxComputationThreadPool-2
5 processing on RxComputationThreadPool-2
4 processing on RxComputationThreadPool-1
6 emitting on RxComputationThreadPool-2
7 emitting on RxComputationThreadPool-2
6 processing on RxComputationThreadPool-2
7 processing on RxComputationThreadPool-1
8 emitting on RxComputationThreadPool-2
9 emitting on RxComputationThreadPool-2
8 processing on RxComputationThreadPool-2
9 processing on RxComputationThreadPool-1
Completed
```

Maybe I don't get something and have not read documentation carefully enough, but to me it looks like the fusion between operators breaks semantics of ObserveOn.

Moreover, while digging in the source code of related classes in RxJava, I have found suspicious code in the FlowableRangeLong.BaseRangeSubscription.poll() method: it's potentially can be called from different threads but field "index" is not guarded anyhow from contended access so can produce wrong values if instructions reordering or caching is in place on a processor.,Forgot to mention: it's about latest release 2.1.5 and I can't reproduce it  without going parallel() =||= Hi.

On one hand, using `observeOn` to pin such source to a particular thread is not the right operator. If you use `subscribeOn`, the correct emission thread is encountered in `doOnNext`.

On the other hand, preventing fusion via `hide()` before `parallel` can get the desired thread confinement effect. 

I'll post a fix to `parallel` indicating it is expected to be an async boundary so thread-sensitive operators such as `doOnNext` won't fuse. =||= Aha, that makes sense, thanks for the clarification! =||= See #5677 for the fix. =||= Many thanks for your quick reaction!
Does it make any sense what I have written at the bottom of my original message about possible memory visibility issues with FlowableRangeLong.BaseRangeSubscription.index field being modified in poll()? Or poll() is supposed to be called in a sync mode only? =||= The `QueueSubscription` interface [defines](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/fuseable/QueueSubscription.java#L20) the access mode. `poll` is called in a sequential manner so index update is not a problem.

Closing via #5677 =||= Yes it does but it doesnot say it cannot be called from different threads, so isn't it essential to add volatile keyword to it? =||= The term "sequential manner" means that if multiple threads would call `poll`, they have to take turns and do such calls in a non-overlapping manner, ensuring visibility of changes `poll` made. In `observeOn`, the `poll` is called from the guaranteed one thread at once drain loops. =||= Well but Java memory model has quite specific memory visibility guarantees and without volatile keyword, instruction reordering and caching can lead to inconsistent state of index variable vidible to other thread calling it right after another. Yes with correct behavior of observeOn its not an issue at all bit in other rare cases it could be isn't it? In fact I am noy using Flowable.range in production code and used it to give an example and its the way I learn RxJava 2 after couple of years living with version 1 :) =||= The parent queue interface was designed after the Single-Producer-Single-Consumer queues like those in JCTools. 

There, the requirement is that `poll` is called from a single thread at a time and the fused "queues" must honor this requirement. Since `index` in fused mode is only updated from within `poll` and poll is serialized by a pair of full barrier atomic add operations, any change to index will be written back into memory before an atomic decrement and read from it after the atomic increment of the drain loop. 

It works just the same as the non-fused `request` execution where the atomic transition from 0 to N is guaranteed to happen only to one thread and the atomic transition attempt from N back to 0 will enable a subsequent thread to do the 0 to N transition again. When doing the 0 to N transition, the next operation is to read the index and when doing N to 0, the prior operation is to write back the index. The full barriers of the atomics will make sure the change to index is visible to the next thread.

On rare cases, such as the `TestSubscriber`, `poll` is called from within `onNext` and `onNext` is required by the Reactive-Streams spec to be serialized the very same manner as `poll` requires it. =||= I do appreciate your detailed explanations.
I think I need to learn deeper memory barrier behavior for java volatiles and cache coherency protocols...
I was convinced that writing volatile variable leads to invalidation of corresponding individual cache lines and forbidding certain instruction reordering which not necessarily means ensuring volatile writes to other locally used non-volatile variables, so each of them has to be marked as volatile to ensure inter-thread visibility guarantees... =||= ,0
5696,5694,observeOn unsubscribes child observables/interrupts the thread,Hi,

The following test shows the use of `observeOn` in an observable chain interrupts the thread, cancelling child observables.

    import org.junit.Test;
    import rx.Completable;
    import rx.schedulers.Schedulers;

    import java.util.concurrent.CountDownLatch;

    public class InterruptTest {
        @Test
        public void testInterrupt() throws InterruptedException {
           final int count = 1000;
           CountDownLatch latch = new CountDownLatch(count);

            for (int i = 0; i < count; i++) {
                Completable.complete()
                    .subscribeOn(Schedulers.io())
                    .observeOn(Schedulers.io()) // The problem does not occur if you comment out this line
                    .andThen(Completable.fromAction(() -> {
                        try {
                            Thread.sleep(3000);
                        } catch (InterruptedException e) {
                            System.out.println("Interrupted!"); // This is output periodically
                        }
                    }))
                    .subscribe(() -> latch.countDown());
            }

            latch.await();
            testInterrupt();
        }
    }

The sleep is interrupted periodically printing "Interrupted!" while the test is running. The problem does not occur when the `observeOn` line is commented out.

We've tested this in RxJava 1.3.2 and 2.1.6 with the same results.,`andThen` and `concat` dispose the previous sources - which is unnecessary on its own - and thus a particular timing may cause the worker of the IO `Scheduler` to be disposed while it is serving the second `Completable`. =||= Fix in #5695. =||= Hi @akarnokd thanks for the fast response. Is there any chance we can get this fixed in 1.x as well? =||= Yes, but it may take an additional week to have it released. Besides, we would like to encourage people to switch to v2 as it's only 6 months till RxJava 1.x' end-of-life. =||= Closing via #5696 =||= ,0
5705,5698,2.x: Improper class name of ObservableFromCompletableTest,The class `io.reactivex.internal.operators.observable.ObservableFromCompletableTest` only tests `Observable.fromCallable`. Why the class name is **Completable**?,Probably just a misnamed test file. Would you like to fix it? =||= Because there already had a class `io.reactivex.internal.operators.observable.ObservableFromCallableTest`.
So, what the new name you recommend?
Or just merge the test cases into `ObservableFromCallableTest`? =||= Just copy over the test methods. =||= ,0
5718,5716,onComplete() is not getting called on the specified Scheduler,when I use `Observable.take(time, TimeUnit.SECONDS)`, if the result Observable stops due to timeout, `onComplete()` callback gets called on `computation` thread,  not the one that I've specified with `observeOn()`.

Here is a sample code:
```
Observable.just("one", "two")
        .observeOn(Schedulers.io())
        .take(0, TimeUnit.SECONDS)
        .subscribe(new Observer<String>() {
            @Override public void onSubscribe(Disposable d) {
                System.out.println("onSubscribe(), thread: " + Thread.currentThread().getName());
            }

            @Override public void onNext(String s) {
                System.out.println("onNext(), thread: " + Thread.currentThread().getName());
            }

            @Override public void onError(Throwable e) {
                System.out.println("onError(), thread: " + Thread.currentThread().getName());
            }

            @Override public void onComplete() {
                System.out.println("onComplete, thread: " + Thread.currentThread().getName());
            }
        });
```
And as the result you'll get `onComplete, thread: RxComputationThreadPool-1`.

If it's required for all callback methods to run on the specified thread per Reactive specifications, this would be a bug, and it happens on both RxJava 1.x and 2.x,`observeOn` lasts until the next async operator, in this case [take](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#take-long-java.util.concurrent.TimeUnit-). You can [specify](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#take-long-java.util.concurrent.TimeUnit-io.reactivex.Scheduler-) the Scheduler where `take` will time out. Alternatively, you can swap `take` and `observeOn` so events will end up on the desired thread. =||= Yeah, I looked into the code and figured what's causing that. However I believe this is kinda inconsistent behavior, (and probably wrong), since all `onNext()` calls are running on the specified scheduler, and all of the sudden `onComplete()` runs on another thread.

At least we should have this behavior documented. It's not known that `take()` **might** change thread for some callbacks! (`onError` is also possible to run on `computation`) =||= I also looked into the source code and figured why this is happening. 
Here is my quick (and probably naive!) fix that I did to just test my idea about the source of this issue.
I added an `if` to `Observable.take()`

```
public final Observable<T> take(long time, TimeUnit unit) {
  if (this instanceof ObservableObserveOn) 
    return takeUntil(timer(time, unit)).observeOn(((ObservableObserveOn) this).scheduler);
  else 
    return takeUntil(timer(time, unit));
}
``` =||= The operator behaves and expected. If the upstream completes before the time runs out, those events will be delivered on the upstream's thread. If there is a timeout, which is scheduled by a different Scheduler, the  terminal event will be delivered on that other thread. If you want to ensure events are delivered on the desired thread, apply `observeOn` just before that.

If you want, you can create a PR wich add a clause to the relevant operators' Javadoc (in both `Observable` and `Flowable` which explicitly states the completion triggered by the timeout may come from a different thread (depending on the Scheduler used) than the items came from. =||= Alright, I'll add it to doc. =||= Closing via #5718 and #5719. =||= ,0
5719,5716,onComplete() is not getting called on the specified Scheduler,when I use `Observable.take(time, TimeUnit.SECONDS)`, if the result Observable stops due to timeout, `onComplete()` callback gets called on `computation` thread,  not the one that I've specified with `observeOn()`.

Here is a sample code:
```
Observable.just("one", "two")
        .observeOn(Schedulers.io())
        .take(0, TimeUnit.SECONDS)
        .subscribe(new Observer<String>() {
            @Override public void onSubscribe(Disposable d) {
                System.out.println("onSubscribe(), thread: " + Thread.currentThread().getName());
            }

            @Override public void onNext(String s) {
                System.out.println("onNext(), thread: " + Thread.currentThread().getName());
            }

            @Override public void onError(Throwable e) {
                System.out.println("onError(), thread: " + Thread.currentThread().getName());
            }

            @Override public void onComplete() {
                System.out.println("onComplete, thread: " + Thread.currentThread().getName());
            }
        });
```
And as the result you'll get `onComplete, thread: RxComputationThreadPool-1`.

If it's required for all callback methods to run on the specified thread per Reactive specifications, this would be a bug, and it happens on both RxJava 1.x and 2.x,`observeOn` lasts until the next async operator, in this case [take](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#take-long-java.util.concurrent.TimeUnit-). You can [specify](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#take-long-java.util.concurrent.TimeUnit-io.reactivex.Scheduler-) the Scheduler where `take` will time out. Alternatively, you can swap `take` and `observeOn` so events will end up on the desired thread. =||= Yeah, I looked into the code and figured what's causing that. However I believe this is kinda inconsistent behavior, (and probably wrong), since all `onNext()` calls are running on the specified scheduler, and all of the sudden `onComplete()` runs on another thread.

At least we should have this behavior documented. It's not known that `take()` **might** change thread for some callbacks! (`onError` is also possible to run on `computation`) =||= I also looked into the source code and figured why this is happening. 
Here is my quick (and probably naive!) fix that I did to just test my idea about the source of this issue.
I added an `if` to `Observable.take()`

```
public final Observable<T> take(long time, TimeUnit unit) {
  if (this instanceof ObservableObserveOn) 
    return takeUntil(timer(time, unit)).observeOn(((ObservableObserveOn) this).scheduler);
  else 
    return takeUntil(timer(time, unit));
}
``` =||= The operator behaves and expected. If the upstream completes before the time runs out, those events will be delivered on the upstream's thread. If there is a timeout, which is scheduled by a different Scheduler, the  terminal event will be delivered on that other thread. If you want to ensure events are delivered on the desired thread, apply `observeOn` just before that.

If you want, you can create a PR wich add a clause to the relevant operators' Javadoc (in both `Observable` and `Flowable` which explicitly states the completion triggered by the timeout may come from a different thread (depending on the Scheduler used) than the items came from. =||= Alright, I'll add it to doc. =||= Closing via #5718 and #5719. =||= ,0
5729,5654,3.x: Proposal: `ObservableConverter` interface and friends,For the `compose()` operators, `ObservableTransformer` was introduced to allow for classes to implement multiple transformer interfaces for composite implementations. I'd like to propose doing the same for the `to()` operator by introducing `ObservableConverter` (and corresponding ones for others).  This would allow for composite converters as well.

If you're open to this, I can contribute a PR!,That would break binary compatibility and otherwise `to(Function<? super Observable<T>, R>)` isn't that much of a type mess as `lift` or `compose` is. =||= This would be an alternative to, not a replacement for. I'm not sure what type mess means, the larger issue is that you can't have something implement `Function` multiple times with different generics =||= A `to` overload will lead to type ambiguity when one writes `to(f -> somefunc(f))`. =||= ah, good point. Would you be against a different name? Like `convertTo`? Or would this be more of an RxJava 3.0 discussion? =||= Yes, 3.x API cleanup can include this type of change. I otherwise always have separate converters for the base reactive classes.

/cc @JakeWharton, @vanniktech, @artem-zinnatullin  =||= I remember we had the discussion about `to()` already in 2.0.0-RC days. The closed I could find is - https://github.com/ReactiveX/RxJava/pull/4672 - if I recall correctly it was decided to not change the `to` operator. 

I don't have a strong opinion about changing it in 3.x though. =||= In general, I'd like RxJava to have as less interfaces as possible, especially if generic ones like `Function` can be used instead.

But Java limitations kinda force us to have them here. So I'm ok if 3.x will have dedicated `*Converter` interfaces. =||= Retagged as 3.x. =||= I'd like to lean on this for a 2.x consideration again, seeing as 3.x discussion seems to be settling on "not necessary anytime soon". 

Proposal, to protect against ambiguity, would be to add a new `convert` or `convertTo` method, which retains the semantics while introducing the new interfaces to allow for composition.

The old `to()` methods could optionally be deprecated too to avoid confusion =||= Project reactor chose the `as()` [naming](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#as-java.util.function.Function-). It's short, which I like, and could be added without deprecating `to`.

```java
public <R> R as(ObservableConverter<T, R> converter);
public <R> R as(FlowableConverter<T, R> converter);
public <R> R as(SingleConverter<T, R> converter);
public <R> R as(MaybeConverter<T, R> converter);
public <R> R as(CompletableConverter<R> converter);
``` =||= I like it! Should I send a PR? =||= Sure. =||= Done in #5729 =||= This has to be still resolved in 3.x where I suggest having only `to()` with the custom interfaces just introduced. =||= Sounds good =||= Hi guys, I have a concern which related to this ticket. Here is my code: 

 ```
    inline fun <reified T> withSchedulers(subscribeOn: Scheduler, observeOn: Scheduler): T {
        when (T::class) {
            FlowableTransformer::class -> return FlowableTransformer<Any, Any> {
                it.subscribeOn(subscribeOn).observeOn(observeOn)
            } as T
            ObservableTransformer::class -> return ObservableTransformer<Any, Any> {
                it.subscribeOn(subscribeOn).observeOn(observeOn)
            } as T
            SingleTransformer::class -> return SingleTransformer<Any, Any> {
                it.subscribeOn(subscribeOn).observeOn(observeOn)
            } as T
            CompletableTransformer::class -> return CompletableTransformer {
                it.subscribeOn(subscribeOn).observeOn(observeOn)
            } as T
            MaybeTransformer::class -> return MaybeTransformer<Any, Any> {
                it.subscribeOn(subscribeOn).observeOn(observeOn)
            } as T
        }
        throw IllegalArgumentException("not a valid Transformer type")
    }
```

Are there any ways to reduce the boilerplate code? or any better approaches to achieve this? Or just write 5 functions for 5 types, something like `to` operator above?

Thanks.

 =||= Closing via #6514. =||= ,0
5740,5319,2.x: Observable missing or incorrect images (tracking issue),- [x] [Observable.singleOrError()](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#singleOrError()): There is no default value and an empty source should result in an error.
- [x] `Observable.combineLatestDelayError(ObservableSource[], Function)`: missing diagram
- [x] `Observable.combineLatestDelayError(Function, int, ObservableSource...)`: missing diagram
- [x] `Observable.concatArrayEager`: missing diagram
- [x] `Observable.error`: should include the X in the operator body indicating it as being the parameter/return value
- [x] `Observable.fromFuture`: the operator name in the box
- [x] `Observable.fromIterable`: the operator name in the box
- [x] `Observable.fromPublisher`: missing diagram
- [x] `Observable.just`: the element should be a parameter inside the box, such outside elements imply a subject type external push.
- [x] `Observable.just(T, T)` +7: optionally tailor the diagram to the actual number of arguments, plus move the constant values inside the box
- [x] `Observable.rangeLong`: the operator name in the box
- [x] `Observable.switchOnNextDelayError`: the operator name in the box, indicator of an error getting delayed
- [x] `Observable.zipArray`: indicate there is a function instead of implying the output is an array containing one element from each source.
- [x] `Observable.zipIterable`: the operator name in the box
- [x] `Observable.all`: example of a false result
- [x] `Observable.ambWith`: the operator name in the box
- [x] `Observable.blockingFirst`: missing diagram
- [x] `Observable.blockingForEach`: the operator name in the box
- [x] `Observable.blockingIterable`: the operator name in the box, indicate that blocking may happen for each element
- [x] `Observable.blockingLast`: the operator name in the box
- [x] `Observable.blockingLast(T)`: the operator name in the box, indicate default in the box, fix labels
- [x] `Observable.blockingLatest`: missing diagram
- [x] `Observable.blockingMostRecent`: the operator name in the box
- [x] `Observable.blockingNext`: the operator name in the box
- [x] `Observable.blockingSingle`: the operator name in the box
- [x] `Observable.blockingSingle(T)`: the operator name in the box, indicate default in the box, fix labels
- [x] `Observable.toFuture()`: the operator name in the box, indicate multi-value, empty and error behavior
- [x] `Observable.blockingSubscribe`: missing diagram
- [x] `Observable.cacheWithInitialCapacity`: the operator name in the box
- [x] `Observable.collectInto`: the operator name in the box, indicate the shared collection
- [x] `Observable.concatMapCompletable`: missing diagram
- [x] `Observable.concatMapDelayError`: missing diagram
- [x] `Observable.concatMapEager`: missing diagram
- [x] `Observable.concatMapEagerDelayError`: missing diagram
- [x] `Observable.concatMapIterable`: missing diagram
- [x] `Observable.doAfterNext`: missing diagram
- [x] `Observable.doFinally`: missing diagram
- [x] `Observable.doOnDispose`: the operator name in the box
- [x] `Observable.doOnComplete`: indicate that the events pass through and the star is execute before the onComplete to downstream
- [x] `Observable.doOnError`: indicate that the events pass through and the star is execute before the onError to downstream
- [x] `Observable.doOnLifecycle`: change unsubscribe to dispose
- [x] `Observable.doOnNext`: indicate that the events pass through and the star is execute before the onNext to downstream
- [x] `Observable.doOnTerminate`: indicate that the events pass through and the star is execute before the onError or onComplete to downstream
- [x] `Observable.elementAt(long)`: example of empty source
- [x] `Observable.elementAt(long, T)`: example of empty source
- [x] `Observable.elementAtOrError(long)`: example of empty source
- [x] `Observable.firstElement`: diagram is stretched
- [x] `Observable.firstOrError`: the operator name in the box
- [x] `Observable.flatMap(Function, boolean, int)`: missing diagram
- [x] `Observable.flatMap(Function, boolean, int, int)`: missing diagram
- [x] `Observable.flatMap(Function, Function, Callable, int)`: missing diagram
- [x] `Observable.flatMap(Function, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, boolean, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, boolean, int, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, int)`: missing diagram
- [x] `Observable.flatMapCompletable()`: missing diagram
- [x] `Observable.flatMapIterable(Function)`: diagram looks stretched
- [x] `Observable.forEach()`: missing diagram
- [x] `Observable.forEachWhile()`: missing diagram
- [x] `Observable.hide()`: missing diagram - not sure how to represent this
- [x] `Observable.lastOrError()`: operator name in the box, error case example.
- [x] `Observable.onErrorReturn()`: indicate that the value is the result of a function call
- [x] `Observable.onErrorReturnItem()`: operator name in the box
- [x] `Observable.onTerminateDetach`: missing diagram
- [x] `Observable.publish(Function)`: there is no connect call, may need extensive redrawing
- [x] `Observable.reduceWith()`: operator name in the box
- [x] `Observable.repeat()` + overloads: indicate fresh subscriptions happen, not caching
- [x] `Observable.repeatUntil`: operator name in the box, indicate fresh subscriptions
- [x] `Observable.replay()` + overloads: remove publish
- [x] `Observable.replay(Function, ...)` overloads: may need extensive redrawing
- [x] `Observable.retry(long)` indicate limited retry effect
- [x] `Observable.retry(Predicate)` indicate predicate effect, show it in the box
- [x] `Observable.retry(long, Predicate)` indicate predicate, show them in the box
- [x] `Observable.retryUntil`: operator name in the box, show BooleanSupplier
- [x] `Observable.share()`: fix labels with unsubscribe
- [x] `Observable.singleElement`: example with empty source
- [x] `Observable.sorted`: missing diagram
- [x] `Observable.startWith(T)`: have a single item as start value
- [x] `Observable.startWithArray(T...)`: operator name
- [x] `Observable.subscribe` + overloads: missing diagram
- [x] [Observable.switchMapSingle](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#switchMapSingle(io.reactivex.functions.Function)): inner sources should have 1 item.
- [x] `Observable.switchMapDelayError` + indicate the error case
- [x] `Observable.toList(Callable)`: indicate the custom collection somehow?
- [x] `Observable.toFlowable()`: missing diagram
- [x] `Observable.unsubscribeOn()`: missing diagram
- [x] `Observable.zipWith()` + overloads: the diagram is in line with some text and appears pushed to the right
- [x] `Observable.test()`: missing diagram, can this be represented as diagram?
  
  ,PRs welcome. The most easy ones are those that require alignment/displayed size corrections. =||= Hi David, I'd love to help, what would I use to edit the diagrams? =||= If you are on Mac and you own OmniGraffle, there is a file for **all** traditional diagrams:
https://github.com/ReactiveX/reactivex.github.io/issues/223

I'm using Excel 2007+ on Windows to draw the newer diagrams and have a file [here](https://drive.google.com/open?id=0B4T7ZW3brESKQV9KaEF5YnpjM0k) you can use as basis for newer diagrams. I don't know if the open office variants could open this file or not, Google's viewer certainly doesn't show the drawings.

I suppose as a last resort you can draw in the open-office variants as well and post the PNGs in this issue. Uploading it requires access to the wiki git of RxJava. The target rendering is 640 pixels wide and as long as it needs to be.

The process is as follows:

- Draw diagram(s)
- Upload to git
- Modify Javadoc locally to point to the raw usercontent
- Verify and fix alignment/stretching
- Commit PR to RxJava itself =||= Is it `switchMapSingle` need a new diagram too? SingleResource can't emit 2 items. =||= Yes. I'll add it to the list above. =||= ## ConcatArrayEager

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.png) =||= ## Error

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.item.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.supplier.png) =||= ## fromFuture

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.noarg.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.scheduler.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.scheduler.png) =||= ## fromIterable

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromIterable.png) =||= Another option is to use free open-source multi-platform Inkscape. Templates here:

https://github.com/davidmoten/rxjava-marble-template =||= **startWith(T)**

![startwith t](https://user-images.githubusercontent.com/6715387/28749559-b5f451dc-74a1-11e7-9a24-db339a2da754.png)


 =||= **startWithArray(T...)**

![startwitharray](https://user-images.githubusercontent.com/6715387/28749281-5f23f834-7498-11e7-99a5-49033842ecb9.png)

 =||= Thanks. Could you make sure the operator box has its contents centered? =||= Sure. Going to edit them. =||= **sorted()**

Is it okay to add numbers to the marbles?

![sorted](https://user-images.githubusercontent.com/6715387/28749679-1660f5b2-74a6-11e7-909b-f9c6cb7ce2c5.png)


 =||= In this case yes, because it also demonstrates the self-comparable nature required (changing the order of colors is unlikely to convey the sorting aspect). For most of the other operators, the matching up of the color should be enough. =||= Not sure how you do these images, could you add shadows to the marbles, the time arrows and the vertical complete indicators? =||= I'm using @davidmoten's template. Going to edit them to add the shadows.  =||= sorted(): it would be better that the source marbles are at the beginning and the output is only happening after onComplete:

```
---5--3--1--4--2--|--------------
[            sorted()           ]
---------------------1-2-3-4-5-|-
``` =||= Added shadows and edited the `sorted()` operator. =||= **just(T)**

![just](https://user-images.githubusercontent.com/6715387/28749794-944aea34-74a9-11e7-9e52-43604442c87d.png)

 =||= **rangelong()**

![rangelong](https://user-images.githubusercontent.com/6715387/28749798-cf44b69c-74a9-11e7-853b-958018e492c4.png)
 =||= Thanks @leonardortlima ! The first 5 images is added via #5524. =||= Just noticed that `Single.filter` and `Maybe.filter` are also incorrect; they seem to be copied from `Observable.filter`. =||= Quite possibly the other base reactive classes have copy-paste diagrams. This issue tracks the fixes of `Observable` but if you want, I can open issues for the other classes individually. =||= ![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.2.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.3.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.4.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.5.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.6.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.7.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.8.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.9.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.10.png)

![switchOnNextDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchOnNextDelayError.png) =||= From #5668:

![singleelement](https://user-images.githubusercontent.com/4089934/31583261-a6da996a-b18f-11e7-8682-dffa647c7e4a.png) =||= ### zipIterable

![zipIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipIterable.o.png)

### ambWith

![ambWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ambWith.o.png)

### blockingForEach

![blockingForEach](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingForEach.o.png)

### blockingIterable

![blockingIterable](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingIterable.o.png)

### blockingLast

![blockingLast](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLast.o.png)

![blockingLast](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLastDefault.o.png)

### blockingMostRecent

![blockingMostRecent](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingMostRecent.o.png)

### blockingNext

![blockingNext](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingNext.o.png)

### blockingSingle

![blockingSingle](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingle.o.png)

![blockingSingle](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingleDefault.o.png)

### cacheWithInitialCapacity

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cacheWithInitialCapacity.o.png) =||= ### all

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.o.png)

### fromPublisher

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromPublisher.o.png)

### zipArray

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipArray.o.png) =||= ### blockingFirst

![blockingFirst](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.png)


![blockingFirst](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.default.png)

### toFuture


![toFuture](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFuture.o.png)


### blockingSubscribe

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.0.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.1.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.2.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.png)

### collectInto

![collectInto](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collectInto.o.png)

### doOnComplete

![doOnComplete](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.o.png)

### doOnError

![doOnError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.o.png)

### doOnLifecycle

![doOnLifecycle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnLifecycle.o.png)

### doOnNext

![doOnNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.o.png)

 =||= ### concatMapCompletable

![concatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapCompletable.o.png)

### concatMapDelayError

![concatMapDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapDelayError.o.png)

### concatMapEager

![concatMapEager](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEager.o.png)

### concatMapEagerDelayError

![concatMapEagerDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEagerDelayError.o.png)

### concatMapIterable

![concatMapIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapIterable.o.png)

### doAfterNext

![doAfterNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterNext.o.png)

### doFinally

![doFinally](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png) =||= ### doOnTerminate

![doOnTerminate](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.o.png)

### elementAt

![elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.o.png)
![elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtDefault.o.png)

### elementAtOrError

![elementAtOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrError.o.png)

### firstOrError

![firstOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.o.png)

### flatMap

![flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapDelayError.o.png)
![flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png)



 =||= ![flatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletable.o.png)

![flatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletableDelayError.o.png)

![forEach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEach.o.png)

![forEachWhile](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEachWhile.o.png)

![hide](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/hide.o.png) =||= ![lastOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png)
![onErrorReturn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.o.png)
![onErrorReturnItem](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturnItem.o.png)
![onTerminateDetach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onTerminateDetach.o.png)
![publish(Function)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishFunction.o.png)
![reduce(seed, f)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.o.png)
![reduceWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceWith.o.png)
![repeat()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatInf.o.png)
![repeat(long)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatCount.o.png)
![repeatUntil](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatUntil.o.png)
![replay()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.png)
![replay(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.n.png)  
![replay(int, long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nt.png)
![replay(int, long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nts.png)
![replay(int, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ns.png)
![replay(long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.t.png)
![replay(long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ts.png)
![replay(Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.s.png) =||= ![no arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.f.png)
![scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fs.png)
![bufferSize](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fn.png)
![bufferSize, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fns.png)
![time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ft.png)
![time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fts.png)
![bufferSize, time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnt.png)
![bufferSize, time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnts.png)
 =||= ![retry(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.n.png)
![retry(BiFunction)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.ne.png)
![retry(Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.e.png)
![retry(int, Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.nfe.png)
![retryUntil(BooleanSupplier)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryUntil.o.png)
![share](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.png)
![switchMapSingle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingle.o.png)
![switchMapSingleDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingleDelayError.o.png) =||= ![toList(Callable)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.o.c.png)
![toFlowable(BUFFER)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.buffer.png)
![toFlowable(DROP)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.drop.png)
![toFlowable(LATEST)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.latest.png)
![toFlowable(ERROR)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.error.png)
![toFlowable(MISSING)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.missing.png)
![unsubscribeOn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/unsubscribeOn.o.png)
 =||= ,0
5743,5742,2.x: SingleFromCallable doesn't check isDisposed before calling onError or onSuccess.,I was investigating a bug and I noticed that `SingleFromCallable` doesn't check `isDisposed()` before calling `onError` or `onSuccess` when comparing it to `ObservableFromCallable`.

Should it be checking `isDisposed()`? If not, why not? Or is this a bug?

My code example where I'm getting this error is Android based:
I have a HomePresenter with this code:
```
void setActivity(Activity activity) {
	Timber.d(“HomePresenter attachActivity”);
	this.activity = activity;
}
```

```
void onStart() {
	Timber.d(“HomePresenter onStart”);
	disposables.add(api.getEmail()
		.subscribeOn(Schedulers.io())
		.observeOn(AndroidSchedulers.mainThread())
		.subscribe(email -> {
			Timber.d(“email was %s”, email);
			activity.setEmail(email);
		})
	);
```
```
void onStop() {
	Timber.d(“HomePresenter onStop”);
	disposables.clear();
	activity = null;
}
```

in the logs I see:
```
Lifecycle onStart HomeActivity
HomePresenter attachActivity
HomePresenter onStart
Lifecycle onStop HomeActivity
HomePresenter onStop
email was foo@bar.com
NullPointerException: attempt to invoke virtual method Activity.setEmail(String) on null object reference
```

It seems the subscription to the observable was cleared before the `onSuccess` method was called.

Or maybe I'm missing something else completely, anyways, thanks for the help :)
,Indeed it is inconsistent with the other operators. Would you like to submit a PR? The [`MaybeFromCallable`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/maybe/MaybeFromCallable.java) should give a hint about the proper implementation.

Otherwise, the NPE is due to the line `activity.setEmail(email);` where `activity` is null. Even if `isDisposed` would have been considered, there is a race between completion of the source and stopping the activity, thus you may end up with null `activity` anyway. =||= ,0
5745,5319,2.x: Observable missing or incorrect images (tracking issue),- [x] [Observable.singleOrError()](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#singleOrError()): There is no default value and an empty source should result in an error.
- [x] `Observable.combineLatestDelayError(ObservableSource[], Function)`: missing diagram
- [x] `Observable.combineLatestDelayError(Function, int, ObservableSource...)`: missing diagram
- [x] `Observable.concatArrayEager`: missing diagram
- [x] `Observable.error`: should include the X in the operator body indicating it as being the parameter/return value
- [x] `Observable.fromFuture`: the operator name in the box
- [x] `Observable.fromIterable`: the operator name in the box
- [x] `Observable.fromPublisher`: missing diagram
- [x] `Observable.just`: the element should be a parameter inside the box, such outside elements imply a subject type external push.
- [x] `Observable.just(T, T)` +7: optionally tailor the diagram to the actual number of arguments, plus move the constant values inside the box
- [x] `Observable.rangeLong`: the operator name in the box
- [x] `Observable.switchOnNextDelayError`: the operator name in the box, indicator of an error getting delayed
- [x] `Observable.zipArray`: indicate there is a function instead of implying the output is an array containing one element from each source.
- [x] `Observable.zipIterable`: the operator name in the box
- [x] `Observable.all`: example of a false result
- [x] `Observable.ambWith`: the operator name in the box
- [x] `Observable.blockingFirst`: missing diagram
- [x] `Observable.blockingForEach`: the operator name in the box
- [x] `Observable.blockingIterable`: the operator name in the box, indicate that blocking may happen for each element
- [x] `Observable.blockingLast`: the operator name in the box
- [x] `Observable.blockingLast(T)`: the operator name in the box, indicate default in the box, fix labels
- [x] `Observable.blockingLatest`: missing diagram
- [x] `Observable.blockingMostRecent`: the operator name in the box
- [x] `Observable.blockingNext`: the operator name in the box
- [x] `Observable.blockingSingle`: the operator name in the box
- [x] `Observable.blockingSingle(T)`: the operator name in the box, indicate default in the box, fix labels
- [x] `Observable.toFuture()`: the operator name in the box, indicate multi-value, empty and error behavior
- [x] `Observable.blockingSubscribe`: missing diagram
- [x] `Observable.cacheWithInitialCapacity`: the operator name in the box
- [x] `Observable.collectInto`: the operator name in the box, indicate the shared collection
- [x] `Observable.concatMapCompletable`: missing diagram
- [x] `Observable.concatMapDelayError`: missing diagram
- [x] `Observable.concatMapEager`: missing diagram
- [x] `Observable.concatMapEagerDelayError`: missing diagram
- [x] `Observable.concatMapIterable`: missing diagram
- [x] `Observable.doAfterNext`: missing diagram
- [x] `Observable.doFinally`: missing diagram
- [x] `Observable.doOnDispose`: the operator name in the box
- [x] `Observable.doOnComplete`: indicate that the events pass through and the star is execute before the onComplete to downstream
- [x] `Observable.doOnError`: indicate that the events pass through and the star is execute before the onError to downstream
- [x] `Observable.doOnLifecycle`: change unsubscribe to dispose
- [x] `Observable.doOnNext`: indicate that the events pass through and the star is execute before the onNext to downstream
- [x] `Observable.doOnTerminate`: indicate that the events pass through and the star is execute before the onError or onComplete to downstream
- [x] `Observable.elementAt(long)`: example of empty source
- [x] `Observable.elementAt(long, T)`: example of empty source
- [x] `Observable.elementAtOrError(long)`: example of empty source
- [x] `Observable.firstElement`: diagram is stretched
- [x] `Observable.firstOrError`: the operator name in the box
- [x] `Observable.flatMap(Function, boolean, int)`: missing diagram
- [x] `Observable.flatMap(Function, boolean, int, int)`: missing diagram
- [x] `Observable.flatMap(Function, Function, Callable, int)`: missing diagram
- [x] `Observable.flatMap(Function, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, boolean, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, boolean, int, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, int)`: missing diagram
- [x] `Observable.flatMapCompletable()`: missing diagram
- [x] `Observable.flatMapIterable(Function)`: diagram looks stretched
- [x] `Observable.forEach()`: missing diagram
- [x] `Observable.forEachWhile()`: missing diagram
- [x] `Observable.hide()`: missing diagram - not sure how to represent this
- [x] `Observable.lastOrError()`: operator name in the box, error case example.
- [x] `Observable.onErrorReturn()`: indicate that the value is the result of a function call
- [x] `Observable.onErrorReturnItem()`: operator name in the box
- [x] `Observable.onTerminateDetach`: missing diagram
- [x] `Observable.publish(Function)`: there is no connect call, may need extensive redrawing
- [x] `Observable.reduceWith()`: operator name in the box
- [x] `Observable.repeat()` + overloads: indicate fresh subscriptions happen, not caching
- [x] `Observable.repeatUntil`: operator name in the box, indicate fresh subscriptions
- [x] `Observable.replay()` + overloads: remove publish
- [x] `Observable.replay(Function, ...)` overloads: may need extensive redrawing
- [x] `Observable.retry(long)` indicate limited retry effect
- [x] `Observable.retry(Predicate)` indicate predicate effect, show it in the box
- [x] `Observable.retry(long, Predicate)` indicate predicate, show them in the box
- [x] `Observable.retryUntil`: operator name in the box, show BooleanSupplier
- [x] `Observable.share()`: fix labels with unsubscribe
- [x] `Observable.singleElement`: example with empty source
- [x] `Observable.sorted`: missing diagram
- [x] `Observable.startWith(T)`: have a single item as start value
- [x] `Observable.startWithArray(T...)`: operator name
- [x] `Observable.subscribe` + overloads: missing diagram
- [x] [Observable.switchMapSingle](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#switchMapSingle(io.reactivex.functions.Function)): inner sources should have 1 item.
- [x] `Observable.switchMapDelayError` + indicate the error case
- [x] `Observable.toList(Callable)`: indicate the custom collection somehow?
- [x] `Observable.toFlowable()`: missing diagram
- [x] `Observable.unsubscribeOn()`: missing diagram
- [x] `Observable.zipWith()` + overloads: the diagram is in line with some text and appears pushed to the right
- [x] `Observable.test()`: missing diagram, can this be represented as diagram?
  
  ,PRs welcome. The most easy ones are those that require alignment/displayed size corrections. =||= Hi David, I'd love to help, what would I use to edit the diagrams? =||= If you are on Mac and you own OmniGraffle, there is a file for **all** traditional diagrams:
https://github.com/ReactiveX/reactivex.github.io/issues/223

I'm using Excel 2007+ on Windows to draw the newer diagrams and have a file [here](https://drive.google.com/open?id=0B4T7ZW3brESKQV9KaEF5YnpjM0k) you can use as basis for newer diagrams. I don't know if the open office variants could open this file or not, Google's viewer certainly doesn't show the drawings.

I suppose as a last resort you can draw in the open-office variants as well and post the PNGs in this issue. Uploading it requires access to the wiki git of RxJava. The target rendering is 640 pixels wide and as long as it needs to be.

The process is as follows:

- Draw diagram(s)
- Upload to git
- Modify Javadoc locally to point to the raw usercontent
- Verify and fix alignment/stretching
- Commit PR to RxJava itself =||= Is it `switchMapSingle` need a new diagram too? SingleResource can't emit 2 items. =||= Yes. I'll add it to the list above. =||= ## ConcatArrayEager

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.png) =||= ## Error

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.item.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.supplier.png) =||= ## fromFuture

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.noarg.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.scheduler.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.scheduler.png) =||= ## fromIterable

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromIterable.png) =||= Another option is to use free open-source multi-platform Inkscape. Templates here:

https://github.com/davidmoten/rxjava-marble-template =||= **startWith(T)**

![startwith t](https://user-images.githubusercontent.com/6715387/28749559-b5f451dc-74a1-11e7-9a24-db339a2da754.png)


 =||= **startWithArray(T...)**

![startwitharray](https://user-images.githubusercontent.com/6715387/28749281-5f23f834-7498-11e7-99a5-49033842ecb9.png)

 =||= Thanks. Could you make sure the operator box has its contents centered? =||= Sure. Going to edit them. =||= **sorted()**

Is it okay to add numbers to the marbles?

![sorted](https://user-images.githubusercontent.com/6715387/28749679-1660f5b2-74a6-11e7-909b-f9c6cb7ce2c5.png)


 =||= In this case yes, because it also demonstrates the self-comparable nature required (changing the order of colors is unlikely to convey the sorting aspect). For most of the other operators, the matching up of the color should be enough. =||= Not sure how you do these images, could you add shadows to the marbles, the time arrows and the vertical complete indicators? =||= I'm using @davidmoten's template. Going to edit them to add the shadows.  =||= sorted(): it would be better that the source marbles are at the beginning and the output is only happening after onComplete:

```
---5--3--1--4--2--|--------------
[            sorted()           ]
---------------------1-2-3-4-5-|-
``` =||= Added shadows and edited the `sorted()` operator. =||= **just(T)**

![just](https://user-images.githubusercontent.com/6715387/28749794-944aea34-74a9-11e7-9e52-43604442c87d.png)

 =||= **rangelong()**

![rangelong](https://user-images.githubusercontent.com/6715387/28749798-cf44b69c-74a9-11e7-853b-958018e492c4.png)
 =||= Thanks @leonardortlima ! The first 5 images is added via #5524. =||= Just noticed that `Single.filter` and `Maybe.filter` are also incorrect; they seem to be copied from `Observable.filter`. =||= Quite possibly the other base reactive classes have copy-paste diagrams. This issue tracks the fixes of `Observable` but if you want, I can open issues for the other classes individually. =||= ![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.2.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.3.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.4.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.5.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.6.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.7.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.8.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.9.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.10.png)

![switchOnNextDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchOnNextDelayError.png) =||= From #5668:

![singleelement](https://user-images.githubusercontent.com/4089934/31583261-a6da996a-b18f-11e7-8682-dffa647c7e4a.png) =||= ### zipIterable

![zipIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipIterable.o.png)

### ambWith

![ambWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ambWith.o.png)

### blockingForEach

![blockingForEach](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingForEach.o.png)

### blockingIterable

![blockingIterable](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingIterable.o.png)

### blockingLast

![blockingLast](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLast.o.png)

![blockingLast](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLastDefault.o.png)

### blockingMostRecent

![blockingMostRecent](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingMostRecent.o.png)

### blockingNext

![blockingNext](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingNext.o.png)

### blockingSingle

![blockingSingle](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingle.o.png)

![blockingSingle](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingleDefault.o.png)

### cacheWithInitialCapacity

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cacheWithInitialCapacity.o.png) =||= ### all

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.o.png)

### fromPublisher

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromPublisher.o.png)

### zipArray

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipArray.o.png) =||= ### blockingFirst

![blockingFirst](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.png)


![blockingFirst](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.default.png)

### toFuture


![toFuture](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFuture.o.png)


### blockingSubscribe

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.0.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.1.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.2.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.png)

### collectInto

![collectInto](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collectInto.o.png)

### doOnComplete

![doOnComplete](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.o.png)

### doOnError

![doOnError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.o.png)

### doOnLifecycle

![doOnLifecycle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnLifecycle.o.png)

### doOnNext

![doOnNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.o.png)

 =||= ### concatMapCompletable

![concatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapCompletable.o.png)

### concatMapDelayError

![concatMapDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapDelayError.o.png)

### concatMapEager

![concatMapEager](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEager.o.png)

### concatMapEagerDelayError

![concatMapEagerDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEagerDelayError.o.png)

### concatMapIterable

![concatMapIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapIterable.o.png)

### doAfterNext

![doAfterNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterNext.o.png)

### doFinally

![doFinally](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png) =||= ### doOnTerminate

![doOnTerminate](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.o.png)

### elementAt

![elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.o.png)
![elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtDefault.o.png)

### elementAtOrError

![elementAtOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrError.o.png)

### firstOrError

![firstOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.o.png)

### flatMap

![flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapDelayError.o.png)
![flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png)



 =||= ![flatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletable.o.png)

![flatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletableDelayError.o.png)

![forEach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEach.o.png)

![forEachWhile](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEachWhile.o.png)

![hide](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/hide.o.png) =||= ![lastOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png)
![onErrorReturn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.o.png)
![onErrorReturnItem](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturnItem.o.png)
![onTerminateDetach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onTerminateDetach.o.png)
![publish(Function)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishFunction.o.png)
![reduce(seed, f)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.o.png)
![reduceWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceWith.o.png)
![repeat()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatInf.o.png)
![repeat(long)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatCount.o.png)
![repeatUntil](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatUntil.o.png)
![replay()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.png)
![replay(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.n.png)  
![replay(int, long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nt.png)
![replay(int, long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nts.png)
![replay(int, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ns.png)
![replay(long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.t.png)
![replay(long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ts.png)
![replay(Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.s.png) =||= ![no arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.f.png)
![scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fs.png)
![bufferSize](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fn.png)
![bufferSize, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fns.png)
![time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ft.png)
![time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fts.png)
![bufferSize, time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnt.png)
![bufferSize, time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnts.png)
 =||= ![retry(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.n.png)
![retry(BiFunction)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.ne.png)
![retry(Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.e.png)
![retry(int, Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.nfe.png)
![retryUntil(BooleanSupplier)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryUntil.o.png)
![share](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.png)
![switchMapSingle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingle.o.png)
![switchMapSingleDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingleDelayError.o.png) =||= ![toList(Callable)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.o.c.png)
![toFlowable(BUFFER)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.buffer.png)
![toFlowable(DROP)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.drop.png)
![toFlowable(LATEST)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.latest.png)
![toFlowable(ERROR)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.error.png)
![toFlowable(MISSING)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.missing.png)
![unsubscribeOn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/unsubscribeOn.o.png)
 =||= ,0
5755,5319,2.x: Observable missing or incorrect images (tracking issue),- [x] [Observable.singleOrError()](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#singleOrError()): There is no default value and an empty source should result in an error.
- [x] `Observable.combineLatestDelayError(ObservableSource[], Function)`: missing diagram
- [x] `Observable.combineLatestDelayError(Function, int, ObservableSource...)`: missing diagram
- [x] `Observable.concatArrayEager`: missing diagram
- [x] `Observable.error`: should include the X in the operator body indicating it as being the parameter/return value
- [x] `Observable.fromFuture`: the operator name in the box
- [x] `Observable.fromIterable`: the operator name in the box
- [x] `Observable.fromPublisher`: missing diagram
- [x] `Observable.just`: the element should be a parameter inside the box, such outside elements imply a subject type external push.
- [x] `Observable.just(T, T)` +7: optionally tailor the diagram to the actual number of arguments, plus move the constant values inside the box
- [x] `Observable.rangeLong`: the operator name in the box
- [x] `Observable.switchOnNextDelayError`: the operator name in the box, indicator of an error getting delayed
- [x] `Observable.zipArray`: indicate there is a function instead of implying the output is an array containing one element from each source.
- [x] `Observable.zipIterable`: the operator name in the box
- [x] `Observable.all`: example of a false result
- [x] `Observable.ambWith`: the operator name in the box
- [x] `Observable.blockingFirst`: missing diagram
- [x] `Observable.blockingForEach`: the operator name in the box
- [x] `Observable.blockingIterable`: the operator name in the box, indicate that blocking may happen for each element
- [x] `Observable.blockingLast`: the operator name in the box
- [x] `Observable.blockingLast(T)`: the operator name in the box, indicate default in the box, fix labels
- [x] `Observable.blockingLatest`: missing diagram
- [x] `Observable.blockingMostRecent`: the operator name in the box
- [x] `Observable.blockingNext`: the operator name in the box
- [x] `Observable.blockingSingle`: the operator name in the box
- [x] `Observable.blockingSingle(T)`: the operator name in the box, indicate default in the box, fix labels
- [x] `Observable.toFuture()`: the operator name in the box, indicate multi-value, empty and error behavior
- [x] `Observable.blockingSubscribe`: missing diagram
- [x] `Observable.cacheWithInitialCapacity`: the operator name in the box
- [x] `Observable.collectInto`: the operator name in the box, indicate the shared collection
- [x] `Observable.concatMapCompletable`: missing diagram
- [x] `Observable.concatMapDelayError`: missing diagram
- [x] `Observable.concatMapEager`: missing diagram
- [x] `Observable.concatMapEagerDelayError`: missing diagram
- [x] `Observable.concatMapIterable`: missing diagram
- [x] `Observable.doAfterNext`: missing diagram
- [x] `Observable.doFinally`: missing diagram
- [x] `Observable.doOnDispose`: the operator name in the box
- [x] `Observable.doOnComplete`: indicate that the events pass through and the star is execute before the onComplete to downstream
- [x] `Observable.doOnError`: indicate that the events pass through and the star is execute before the onError to downstream
- [x] `Observable.doOnLifecycle`: change unsubscribe to dispose
- [x] `Observable.doOnNext`: indicate that the events pass through and the star is execute before the onNext to downstream
- [x] `Observable.doOnTerminate`: indicate that the events pass through and the star is execute before the onError or onComplete to downstream
- [x] `Observable.elementAt(long)`: example of empty source
- [x] `Observable.elementAt(long, T)`: example of empty source
- [x] `Observable.elementAtOrError(long)`: example of empty source
- [x] `Observable.firstElement`: diagram is stretched
- [x] `Observable.firstOrError`: the operator name in the box
- [x] `Observable.flatMap(Function, boolean, int)`: missing diagram
- [x] `Observable.flatMap(Function, boolean, int, int)`: missing diagram
- [x] `Observable.flatMap(Function, Function, Callable, int)`: missing diagram
- [x] `Observable.flatMap(Function, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, boolean, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, boolean, int, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, int)`: missing diagram
- [x] `Observable.flatMapCompletable()`: missing diagram
- [x] `Observable.flatMapIterable(Function)`: diagram looks stretched
- [x] `Observable.forEach()`: missing diagram
- [x] `Observable.forEachWhile()`: missing diagram
- [x] `Observable.hide()`: missing diagram - not sure how to represent this
- [x] `Observable.lastOrError()`: operator name in the box, error case example.
- [x] `Observable.onErrorReturn()`: indicate that the value is the result of a function call
- [x] `Observable.onErrorReturnItem()`: operator name in the box
- [x] `Observable.onTerminateDetach`: missing diagram
- [x] `Observable.publish(Function)`: there is no connect call, may need extensive redrawing
- [x] `Observable.reduceWith()`: operator name in the box
- [x] `Observable.repeat()` + overloads: indicate fresh subscriptions happen, not caching
- [x] `Observable.repeatUntil`: operator name in the box, indicate fresh subscriptions
- [x] `Observable.replay()` + overloads: remove publish
- [x] `Observable.replay(Function, ...)` overloads: may need extensive redrawing
- [x] `Observable.retry(long)` indicate limited retry effect
- [x] `Observable.retry(Predicate)` indicate predicate effect, show it in the box
- [x] `Observable.retry(long, Predicate)` indicate predicate, show them in the box
- [x] `Observable.retryUntil`: operator name in the box, show BooleanSupplier
- [x] `Observable.share()`: fix labels with unsubscribe
- [x] `Observable.singleElement`: example with empty source
- [x] `Observable.sorted`: missing diagram
- [x] `Observable.startWith(T)`: have a single item as start value
- [x] `Observable.startWithArray(T...)`: operator name
- [x] `Observable.subscribe` + overloads: missing diagram
- [x] [Observable.switchMapSingle](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#switchMapSingle(io.reactivex.functions.Function)): inner sources should have 1 item.
- [x] `Observable.switchMapDelayError` + indicate the error case
- [x] `Observable.toList(Callable)`: indicate the custom collection somehow?
- [x] `Observable.toFlowable()`: missing diagram
- [x] `Observable.unsubscribeOn()`: missing diagram
- [x] `Observable.zipWith()` + overloads: the diagram is in line with some text and appears pushed to the right
- [x] `Observable.test()`: missing diagram, can this be represented as diagram?
  
  ,PRs welcome. The most easy ones are those that require alignment/displayed size corrections. =||= Hi David, I'd love to help, what would I use to edit the diagrams? =||= If you are on Mac and you own OmniGraffle, there is a file for **all** traditional diagrams:
https://github.com/ReactiveX/reactivex.github.io/issues/223

I'm using Excel 2007+ on Windows to draw the newer diagrams and have a file [here](https://drive.google.com/open?id=0B4T7ZW3brESKQV9KaEF5YnpjM0k) you can use as basis for newer diagrams. I don't know if the open office variants could open this file or not, Google's viewer certainly doesn't show the drawings.

I suppose as a last resort you can draw in the open-office variants as well and post the PNGs in this issue. Uploading it requires access to the wiki git of RxJava. The target rendering is 640 pixels wide and as long as it needs to be.

The process is as follows:

- Draw diagram(s)
- Upload to git
- Modify Javadoc locally to point to the raw usercontent
- Verify and fix alignment/stretching
- Commit PR to RxJava itself =||= Is it `switchMapSingle` need a new diagram too? SingleResource can't emit 2 items. =||= Yes. I'll add it to the list above. =||= ## ConcatArrayEager

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.png) =||= ## Error

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.item.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.supplier.png) =||= ## fromFuture

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.noarg.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.scheduler.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.scheduler.png) =||= ## fromIterable

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromIterable.png) =||= Another option is to use free open-source multi-platform Inkscape. Templates here:

https://github.com/davidmoten/rxjava-marble-template =||= **startWith(T)**

![startwith t](https://user-images.githubusercontent.com/6715387/28749559-b5f451dc-74a1-11e7-9a24-db339a2da754.png)


 =||= **startWithArray(T...)**

![startwitharray](https://user-images.githubusercontent.com/6715387/28749281-5f23f834-7498-11e7-99a5-49033842ecb9.png)

 =||= Thanks. Could you make sure the operator box has its contents centered? =||= Sure. Going to edit them. =||= **sorted()**

Is it okay to add numbers to the marbles?

![sorted](https://user-images.githubusercontent.com/6715387/28749679-1660f5b2-74a6-11e7-909b-f9c6cb7ce2c5.png)


 =||= In this case yes, because it also demonstrates the self-comparable nature required (changing the order of colors is unlikely to convey the sorting aspect). For most of the other operators, the matching up of the color should be enough. =||= Not sure how you do these images, could you add shadows to the marbles, the time arrows and the vertical complete indicators? =||= I'm using @davidmoten's template. Going to edit them to add the shadows.  =||= sorted(): it would be better that the source marbles are at the beginning and the output is only happening after onComplete:

```
---5--3--1--4--2--|--------------
[            sorted()           ]
---------------------1-2-3-4-5-|-
``` =||= Added shadows and edited the `sorted()` operator. =||= **just(T)**

![just](https://user-images.githubusercontent.com/6715387/28749794-944aea34-74a9-11e7-9e52-43604442c87d.png)

 =||= **rangelong()**

![rangelong](https://user-images.githubusercontent.com/6715387/28749798-cf44b69c-74a9-11e7-853b-958018e492c4.png)
 =||= Thanks @leonardortlima ! The first 5 images is added via #5524. =||= Just noticed that `Single.filter` and `Maybe.filter` are also incorrect; they seem to be copied from `Observable.filter`. =||= Quite possibly the other base reactive classes have copy-paste diagrams. This issue tracks the fixes of `Observable` but if you want, I can open issues for the other classes individually. =||= ![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.2.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.3.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.4.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.5.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.6.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.7.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.8.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.9.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.10.png)

![switchOnNextDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchOnNextDelayError.png) =||= From #5668:

![singleelement](https://user-images.githubusercontent.com/4089934/31583261-a6da996a-b18f-11e7-8682-dffa647c7e4a.png) =||= ### zipIterable

![zipIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipIterable.o.png)

### ambWith

![ambWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ambWith.o.png)

### blockingForEach

![blockingForEach](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingForEach.o.png)

### blockingIterable

![blockingIterable](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingIterable.o.png)

### blockingLast

![blockingLast](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLast.o.png)

![blockingLast](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLastDefault.o.png)

### blockingMostRecent

![blockingMostRecent](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingMostRecent.o.png)

### blockingNext

![blockingNext](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingNext.o.png)

### blockingSingle

![blockingSingle](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingle.o.png)

![blockingSingle](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingleDefault.o.png)

### cacheWithInitialCapacity

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cacheWithInitialCapacity.o.png) =||= ### all

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.o.png)

### fromPublisher

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromPublisher.o.png)

### zipArray

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipArray.o.png) =||= ### blockingFirst

![blockingFirst](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.png)


![blockingFirst](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.default.png)

### toFuture


![toFuture](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFuture.o.png)


### blockingSubscribe

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.0.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.1.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.2.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.png)

### collectInto

![collectInto](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collectInto.o.png)

### doOnComplete

![doOnComplete](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.o.png)

### doOnError

![doOnError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.o.png)

### doOnLifecycle

![doOnLifecycle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnLifecycle.o.png)

### doOnNext

![doOnNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.o.png)

 =||= ### concatMapCompletable

![concatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapCompletable.o.png)

### concatMapDelayError

![concatMapDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapDelayError.o.png)

### concatMapEager

![concatMapEager](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEager.o.png)

### concatMapEagerDelayError

![concatMapEagerDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEagerDelayError.o.png)

### concatMapIterable

![concatMapIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapIterable.o.png)

### doAfterNext

![doAfterNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterNext.o.png)

### doFinally

![doFinally](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png) =||= ### doOnTerminate

![doOnTerminate](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.o.png)

### elementAt

![elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.o.png)
![elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtDefault.o.png)

### elementAtOrError

![elementAtOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrError.o.png)

### firstOrError

![firstOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.o.png)

### flatMap

![flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapDelayError.o.png)
![flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png)



 =||= ![flatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletable.o.png)

![flatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletableDelayError.o.png)

![forEach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEach.o.png)

![forEachWhile](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEachWhile.o.png)

![hide](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/hide.o.png) =||= ![lastOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png)
![onErrorReturn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.o.png)
![onErrorReturnItem](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturnItem.o.png)
![onTerminateDetach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onTerminateDetach.o.png)
![publish(Function)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishFunction.o.png)
![reduce(seed, f)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.o.png)
![reduceWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceWith.o.png)
![repeat()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatInf.o.png)
![repeat(long)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatCount.o.png)
![repeatUntil](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatUntil.o.png)
![replay()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.png)
![replay(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.n.png)  
![replay(int, long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nt.png)
![replay(int, long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nts.png)
![replay(int, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ns.png)
![replay(long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.t.png)
![replay(long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ts.png)
![replay(Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.s.png) =||= ![no arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.f.png)
![scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fs.png)
![bufferSize](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fn.png)
![bufferSize, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fns.png)
![time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ft.png)
![time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fts.png)
![bufferSize, time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnt.png)
![bufferSize, time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnts.png)
 =||= ![retry(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.n.png)
![retry(BiFunction)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.ne.png)
![retry(Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.e.png)
![retry(int, Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.nfe.png)
![retryUntil(BooleanSupplier)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryUntil.o.png)
![share](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.png)
![switchMapSingle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingle.o.png)
![switchMapSingleDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingleDelayError.o.png) =||= ![toList(Callable)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.o.c.png)
![toFlowable(BUFFER)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.buffer.png)
![toFlowable(DROP)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.drop.png)
![toFlowable(LATEST)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.latest.png)
![toFlowable(ERROR)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.error.png)
![toFlowable(MISSING)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.missing.png)
![unsubscribeOn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/unsubscribeOn.o.png)
 =||= ,0
5766,5762,Use descriptive names in interfaces,Every time I implement one of these interfaces I rename 'e' to 'emitter'. This is repetitive and can be avoided with renaming the param in the interface.

```java
public interface SingleOnSubscribe<T> {

    /**
     * Called for each SingleObserver that subscribes.
     * @param e the safe emitter instance, never null
     * @throws Exception on error
     */
    void subscribe(@NonNull SingleEmitter<T> e) throws Exception;
}
```

This would be in line with naming in other interfaces, such as:

```java
public interface CompletableConverter<R> {

    /**
     * Applies a function to the upstream Completable and returns a converted value of type {@code R}.
     *
     * @param upstream the upstream Completable instance
     * @return the converted value
     */
    @NonNull
    R apply(@NonNull Completable upstream);
}
```

I am happy to do it myself, if you approve.,Why don't you use lambdas where you can specify the name of the parameter?

```java
Single.create(emitter -> { emitter.onSuccess(1); });
```

Besides, I'm not sure renaming the parameter wouldn't cause trouble with JVM languages where such change breaks existing code. =||= Not for kotlin. Named arguments are only supported from Kotlin compiled code where the Metadata annotation is present.  =||= Android Studio autogenerates the following with lambdas:
Single.create(e -> )

... which I repetitively rename to Single.create(emitter -> ) =||= I think not many languages have upgraded their adapters to v2 yet (or will ever) so let's change it and see who's complaining. =||= Closing via #5766 =||= ,0
5773,5772,Race condition with retryWhen()?,Here in this [sample project](https://github.com/EGecius/RxJava2_Demo/blob/master/app/src/test/java/com/egecius/rxjava2_demo_2/rx/retry/RetryExamplesTest.java) you can see that Single.retryWhen() produces inconsistent results, depending on timing:

- retryWhen() test method gets one less retry than expected
- retryWhenWithDelay() test method works as expected

My suspicion is that when we do not add a time delay, onComplete is called immediately after the last onNext() call and immediately terminates the stream with NoSuchElementException.,In some sense, there is a race condition with your retry flow. When an error is signalled, there should be a single response `onNext|onError|onComplete` from the transformation. However, with a `range()`, you'll have an `onNext` directly followed by `onComplete` which is interpreted by the operator as indication for stopping the entire sequence. Now if the upstream is synchronous, this will have only effect after the last retry. If the upstream is asynchronous, you'll get a non-deterministic cutoff.  =||= Yeah, I think I understand what you are saying. 

For us this behaviour of retryWhen() lead to a very difficult to understand bug. We spent about 3 days on it until we understood that this is how retryWhen() behaves.

The bug we had is that our stream would fail with UndeliverableException due to this behaviour. It fails on every last retry cycle. I suspect what happens is that the last onEvent() call triggers the last retry cycle, and then steam is immediately terminated. When our code tries to emit in the last retry cycle, the stream is already terminated and we fail with UndeliverableException.

It was so painful to understand it :) =||= as a temporary workaround to this problem, we have to add this to our code
```
                if (emitter.isDisposed()) {
                    return;
                }
``` =||= There exist a builder for `retryWhen` in [rxjava2-extras](https://github.com/davidmoten/rxjava2-extras/blob/master/src/main/java/com/github/davidmoten/rx2/RetryWhen.java), assuming your retry patterns can be expressed by it.

I'll post a JavaDoc clarification regarding the operator shortly. =||= I appreciate the suggestion to add javadoc. 

I do believe though that this may be a bit too complex to be expressed in JavaDoc, so that every user clearly understand what situation they may get themselves into. Ideally API should protect the user from getting themselves into a muddle :) Not sure if we can achieve that here but I suggest that we at least try. =||= @akarnokd but as I see in the doc, you say:
```
If the upstream to
 +     * the operator is asynchronous, signalling onNext followed by onComplete immediately may
 +     * result in the sequence to be completed immediately. Similarly, if this inner
 +     * {@code Publisher} signals {@code onError} or {@code onComplete} while the upstream is
 +     * active, the sequence is terminated with the same signal immediately.
```
In our case, the problem was that the sequence was not terminated in time. It signaled onError and then another call to the upstream would happen (upstream is async). I don't feel the new docs mention this. May be I don't understand it.  =||= Please provide a minimal and standalone unit test that reproduces your problem. =||= @akarnokd 
[Sample Project](https://github.com/EFGeorgiMirchev/rxjava_retry/blob/master/app/src/main/java/com/nmp90/rxjava_retry/MainActivity.java)
```

12-22 10:36:22.531 17681-17704/com.nmp90.rxjava_retry D/MainActivity: REQUEST
12-22 10:36:23.353 17681-17704/com.nmp90.rxjava_retry D/MainActivity: RETRY
12-22 10:36:26.357 17681-17704/com.nmp90.rxjava_retry D/MainActivity: REQUEST
12-22 10:36:26.579 17681-17704/com.nmp90.rxjava_retry D/MainActivity: RETRY
12-22 10:36:29.580 17681-17704/com.nmp90.rxjava_retry D/MainActivity: REQUEST
12-22 10:36:29.788 17681-17704/com.nmp90.rxjava_retry D/MainActivity: RETRY
12-22 10:36:30.790 17681-17722/com.nmp90.rxjava_retry D/MainActivity: ZIP COMPLETE
12-22 10:36:30.793 17681-17681/com.nmp90.rxjava_retry E/MainActivity: onError:                                                                
 java.util.NoSuchElementException
12-22 10:36:32.789 17681-17704/com.nmp90.rxjava_retry D/MainActivity: REQUEST
```

The problem is the last call to REQUEST after NoSuchElementException :+1: Any help is much appreciated. =||= Don't zip with a range(). See the new async example in #5773. =||= So the fix would be
```java
              .retryWhen(throwableFlowable -> {
                    AtomicInteger counter = new AtomicInteger();
                    return throwableFlowable
                            .takeWhile(e -> counter.getAndIncrement() < 3)
                            .flatMap(err -> {
                                if (err instanceof IOException) {
                                    Log.d(TAG, "RETRY");
                                    return Flowable.timer(1l, TimeUnit.SECONDS);
                                } else {
                                    Log.e(TAG, "ERROR", err);
                                    return Flowable.error(err);
                                }
                            }).doOnComplete(() -> Log.d(TAG, "ZIP COMPLETE"));
                })
```
Which actually does the job. 
```
12-22 10:53:31.823 19057-19075/com.nmp90.rxjava_retry D/MainActivity: REQUEST
12-22 10:53:32.674 19057-19075/com.nmp90.rxjava_retry D/MainActivity: RETRY
12-22 10:53:35.679 19057-19075/com.nmp90.rxjava_retry D/MainActivity: REQUEST
12-22 10:53:35.943 19057-19075/com.nmp90.rxjava_retry D/MainActivity: RETRY
12-22 10:53:38.946 19057-19075/com.nmp90.rxjava_retry D/MainActivity: REQUEST
12-22 10:53:39.189 19057-19075/com.nmp90.rxjava_retry D/MainActivity: RETRY
12-22 10:53:42.191 19057-19075/com.nmp90.rxjava_retry D/MainActivity: REQUEST
12-22 10:53:42.408 19057-19075/com.nmp90.rxjava_retry D/MainActivity: ZIP COMPLETE
12-22 10:53:42.412 19057-19057/com.nmp90.rxjava_retry E/MainActivity: onError: 
                                                                      java.util.NoSuchElementException
```

Thank you, I used `Flowable.range` because I think I saw it as an example on StackOverflow :smile:   =||= Closing via #5773. =||= ,0
5781,5779,2.x: Inconsistent behavior on throwing UndeliverableException in Observable.merge,Library version: 2.1.7

As stated in [RxJava2 Error Handling](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling), no `Throwable` should be silently swallowed in 2.x. `Throwable`s that cannot be delivered to a disposed downstream get redirected to `RxJavaPlugins`' errorHandler.

However, `Observable.merge` operator does not behave consistently in this case:
- If two different `PublishSubject`s are merged, and emit `onError` one after the other, the second exception **does not get delivered** to `RxJavaPlugins`' errorHandler.
- If one `PublishSubject` get merged with itself (after being filtered for example, which I expect to be a common scenario), and it emit single onError, the exception emitted **gets delivered** to both onError and `RxJavaPlugins`' errorHandler.

The snippet below

```java
public class MergeErrorsExample {
    public static void main(String[] args) {
        RxJavaPlugins.setErrorHandler((error) ->
                printError("RxJavaPlugins.errorHandler", error)
        );

        mergeTwoDifferentObservablesDoesNotThrowUndeliverable();
        mergeSameObservableThrowsUndeliverable();
        mergeSameObservableWithPublishThrowsUndeliverable();
    }

    static void mergeTwoDifferentObservablesDoesNotThrowUndeliverable() {
        System.out.println("Merge two different PublishSubjects DOES NOT throw UndeliverableException");
        PublishSubject<Object> ps1 = PublishSubject.create();
        PublishSubject<Object> ps2 = PublishSubject.create();

        Observable.merge(ps1, ps2).subscribe(
                (next) -> System.out.println("onNext " + next),
                (error) -> printError("onError", error),
                () -> System.out.println("onComplete")
        );

        ps1.onError(new RuntimeException("ps1 exception"));
        ps2.onError(new RuntimeException("ps2 exception"));
        System.out.println();
    }

    static void mergeSameObservableThrowsUndeliverable() {
        System.out.println("Merge same PublishSubject throws UndeliverableException");
        PublishSubject<Boolean> ps1 = PublishSubject.create();

        Observable.merge(
                ps1.filter((condition) -> condition),
                ps1.filter((condition) -> !condition)
        ).subscribe(
                (next) -> System.out.println("onNext " + next),
                (error) -> printError("onError", error),
                () -> System.out.println("onComplete")
        );

        ps1.onError(new RuntimeException("ps1 exception"));
        System.out.println();
    }

    static void mergeSameObservableWithPublishThrowsUndeliverable() {
        System.out.println("Merge same Observable with publish() throws UndeliverableException");
        Observable<Boolean> o1 = Observable.error(new RuntimeException("o1 exception"));

        o1.publish((observable) ->
                Observable.merge(
                        observable.filter((condition) -> condition),
                        observable.filter((condition) -> !condition)
                )
        ).subscribe(
                (next) -> System.out.println("onNext " + next),
                (error) -> printError("onError", error),
                () -> System.out.println("onComplete")
        );
        System.out.println();
    }

    private static void printError(String message, Throwable t) {
        System.out.println(message + ": [" + t.getClass().getSimpleName() + "] " + t.getMessage());
    }
}
```

produces 

```
Merge two different PublishSubjects DOES NOT throw UndeliverableException
onError: [RuntimeException] ps1 exception

Merge same PublishSubject throws UndeliverableException
onError: [RuntimeException] ps1 exception
RxJavaPlugins.errorHandler: [UndeliverableException] java.lang.RuntimeException: ps1 exception

Merge same Observable with publish() throws UndeliverableException
onError: [RuntimeException] o1 exception
RxJavaPlugins.errorHandler: [UndeliverableException] java.lang.RuntimeException: o1 exception
```

I'm still not sure which of the options is correct, as "splitting" an `Observable` and then merging it back seems to be a common pattern, which will always cause an `UndeliverableException` in `RxJavaPlugins`' errorHandler in case of onError. 
`Observable.mergeDelayErrors` is an option for "split-merge" pattern, but the user of it has to make sure he does not swallow an exception on one of the paths, or the exception will not be delivered to the downstream at all.

What do you think would be the correct behavior here?
Do you think it is possible to make `Observable.merge` not redirect an error to `RxJavaPlugins`' errorHandler in case of "split-merge" pattern?,Hi, here are the explanations:

- mergeTwoDifferentObservablesDoesNotThrowUndeliverable

The second `PublishSubject` gets unsubscribed before you call `onError` thus there is no `Observer` at that moment to receive an error. A `Subject` can't know if it will never be subscribed again thus signalling an undeliverable error is likely too much.

- mergeSameObservableThrowsUndeliverable

When the `PublishSubject` emits an error, it uses the last snapshot of available `Observer`s and tries to emit the error to them. Here, the second `Observer` gets unsubscribed during the emission loop, and therefore, the error gets routed to the plugin error handler.

- mergeSameObservableWithPublishThrowsUndeliverable

`publish()` operates with the same snapshot-emission logic as `PublishSubject` and the same effect applies.

> Do you think it is possible to make Observable.merge not redirect an error to RxJavaPlugins' errorHandler in case of "split-merge" pattern?

No, that's why `mergeDelayError` exists which will get you all errors in a composite. The other option is to not let the errors reach merge. If you want only the very first error and ignore the rest, you could use some additional logic:

```java
public static <T> Observable<T> mergeFirstErrorOnly(Observable<T>... sources) {
    return Observable.defer(() -> {
        AtomicBoolean once = new AtomicBoolean();
        PublishSubject<Void> errorSubject = PublishSubject.create();
        for (int i = 0; i < sources.length; i++) {
            sources[i] = sources[i].onErrorResumeNext(e -> {
                if (once.compareAndSet(false, true)) {
                    errorSubject.onError(e);
                }
                return Observable.empty();
            });
        }
        return Observable.merge(sources).takeUntil(errorSubject);
    });
}
``` =||= Hi @akarnokd,

Thanks for the detailed explanation!
`mergeDelayError` is indeed what we ended up with.

I now see that it is expected implementation-wise, however from "rxjava-user" point of view I did not expect that something as simple as 
```java
        o1.publish((observable) ->
                Observable.merge(
                        observable.filter((condition) -> condition),
                        observable.filter((condition) -> !condition)
                )
        )
```
would crash on Android (if no custom plugin error handler is installed). I would rather expect `merge` to behave similar to your `mergeFirstErrorOnly` implementation.

Do you think it is worth mentioning in the documentation of `merge` operator at least? =||= See #5780 and #5781 for the proposed JavaDoc improvements. =||= Closing via #5786. =||= Hi @akarnokd !

After some usage of the suggested mergeFirstErrorOnly we found that it still produces an UndeliverableException to the RxJavaPlugins' errorHandler if called from multiple threads. 
Below in the complete test that reproduces it:

```java
package com.test;

import io.reactivex.Observable;
import io.reactivex.ObservableSource;
import io.reactivex.disposables.Disposable;
import io.reactivex.functions.Consumer;
import io.reactivex.functions.Function;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subjects.PublishSubject;
import org.assertj.core.api.Assertions;
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicBoolean;

public class MergeFirstErrorOnlyTest {

    @Test
    public void mergeFirstErrorOnlyWithConcurrentUsage() {

        final List<Throwable> undeliverableExceptions = new ArrayList<>();

        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
            @Override
            public void accept(Throwable throwable) {
                undeliverableExceptions.add(throwable);
            }
        });

        for (int i = 0; i < 10000; ++i) {
            PublishSubject<String> subject1 = PublishSubject.create();
            PublishSubject<String> subject2 = PublishSubject.create();

            Disposable disposable = Observables
                    .mergeFirstErrorOnly(
                            subject1.observeOn(Schedulers.io()),
                            subject2.observeOn(Schedulers.io())
                    )
                    .subscribe(
                            new Consumer<String>() {
                                @Override
                                public void accept(String s) {
                                    // do nothing
                                }
                            },
                            new Consumer<Throwable>() {
                                @Override
                                public void accept(Throwable throwable) {
                                    // do nothing
                                }
                            }
                    );

            subject1.onError(new Exception("Exception 1"));
            subject2.onError(new Exception("Exception 2"));

            disposable.dispose();
        }

        if (!undeliverableExceptions.isEmpty()) {
            undeliverableExceptions.get(0).printStackTrace();
        }

        Assertions.assertThat(undeliverableExceptions).isEmpty();

        RxJavaPlugins.reset();
    }
}

class Observables {
    public static <T> Observable<T> mergeFirstErrorOnly(final Observable<T>... sources) {
        return Observable.defer(new Callable<ObservableSource<? extends T>>() {
            @Override
            public ObservableSource<? extends T> call() {
                final AtomicBoolean once = new AtomicBoolean();
                final PublishSubject<Void> errorSubject = PublishSubject.create();
                for (int i = 0; i < sources.length; i++) {
                    sources[i] = sources[i].onErrorResumeNext(new Function<Throwable, ObservableSource<? extends T>>() {
                        @Override
                        public ObservableSource<? extends T> apply(Throwable e) {
                            if (once.compareAndSet(false, true)) {
                                errorSubject.onError(e);
                            }
                            return Observable.empty();
                        }
                    });
                }
                return Observable.merge(Arrays.asList(sources)).takeUntil(errorSubject);
            }
        });
    }
}
```

The above fails with results similar to
```
java.lang.AssertionError: 
Expecting empty but was:<[io.reactivex.exceptions.UndeliverableException: java.lang.Exception: Exception 2,
    io.reactivex.exceptions.UndeliverableException: java.lang.Exception: Exception 2]>

	at com.test.MergeFirstErrorOnlyTest.mergeFirstErrorOnlyWithConcurrentUsage(MergeFirstErrorOnlyTest.java:68)
```

The exception itself looks like  
```
io.reactivex.exceptions.UndeliverableException: java.lang.Exception: Exception 2
	at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)
	at io.reactivex.subjects.PublishSubject$PublishDisposable.onError(PublishSubject.java:315)
	at io.reactivex.subjects.PublishSubject.onError(PublishSubject.java:245)
	at com.test.MergeFirstErrorOnlyTest.mergeFirstErrorOnlyWithConcurrentUsage(MergeFirstErrorOnlyTest.java:59)
```

For now I don't see a way to solve the issue completely using the current RxJava 2 API. 
Looks like the publish subject itself is missing something similar to `tryOnError`, WDYT? =||= Something like

```java
public final class PublishSubject<T> extends Subject<T> {
    
    public void tryOnError(Throwable t) {
        ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
        if (subscribers.get() == TERMINATED) {
            RxJavaPlugins.onError(t);
            return;
        }
        error = t;

        for (PublishDisposable<T> s : subscribers.getAndSet(TERMINATED)) {
            s.tryOnError(t);
        }
    }

    static final class PublishDisposable<T> extends AtomicBoolean implements Disposable {

        public void tryOnError(Throwable t) {
            if (!get()) {
                actual.onError(t);
            }
        }
    }
}
```

I can submit a PR if you're OK with the proposal.
Still, I totally understand that I might be missing some deeper implications of such change so please advise. =||= If you cancel a `PublishSubject` while it is about to emit an error, the global error handler is involved. Your racing test runs into this case. This property is described in [the JavaDoc](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/PublishSubject.html).

The implication of a `tryOnError` is that it reports false when the error was not delivered, but when there are more than one source, it is unclear what the result should be if some have not received the error. =||= Also looks like you are in control of those `Subject`s. In that case, don't error each individual subject, but use a separate one:

```java
PublishSubject ps1 = PublishSubject.create();
PublishSubject ps2 = PublishSubject.create();

AtomicBoolean once = new AtomicBoolean();
PublishSubject error = PublishSubject.create();

Observable.merge(ps1, ps2).takeUntil(error);

if (once.compareAndSet(false, true)) {
    error.onError(new RuntimeException());
}
```

This way, the merge cancelling the non-failing `ps1` and `ps2` won't signal error to the global handler. =||= OK, thanks, I see the point. 
Will indeed try to route errors from all streams to a single `PublishSubject`'s onError call, guarded by `AtomicBoolean`. =||= ,0
5781,578,A bug in apply(u:=>Unit) method of Subscription companion object fixed w...,...hich may cause multiple invocations of u, in a multithreaded, multi-unsubscribe situation.

Threads may be pre-empted after evaluation of condition (!unsubscribed.get()) which may result in two or more threads executing the consequent block more than once. A code that relies on single evaluation of u will fail if that case happens.,[RxJava-pull-requests #518](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/518/) SUCCESS
This pull request looks good
 =||= This was fixed by @headinthebox and can be seen here: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscription.scala#L68

Thank you @ugur-zongur for contributing!
 =||= ,0
5783,5782,Documentation error?,What does this mean in the [description](http://reactivex.io/RxJava/1.x/javadoc/rx/Observable.html#onTerminateDetach--) of `onTerminateDetach`? 

Returns:
an Observable which out references to the upstream producer and downstream Subscriber if the sequence is terminated or downstream unsubscribes

My guess: "nulls" belongs between "which" and "out",Yes, the word `nulls` out is missing there and also from`Flowable` and `Observable` in v2. I'll post a fix to v2 and you are welcome to post a fix for v1 if you want. =||= Closing via #5783 =||= ,0
5792,579,CRLF issues :-(,Cannot believe that it is 2013 and we are still having CRLF changes

I guess that @akarnokd is using Windows and I have trouble with CRLF in Async.java and friends.,Yes, I'm on Windows and using NetBeans 7.4 with default git settings. I thought all this line ending is automatically managed by github or the repo [as specified here](https://help.github.com/articles/dealing-with-line-endings).

So the question is, should I create a PR with fixed CRLF or will this be handled on the repo level?
 =||= I'll play with those Github settings to see if I can resolve it there.
 =||= ,0
5805,5319,2.x: Observable missing or incorrect images (tracking issue),- [x] [Observable.singleOrError()](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#singleOrError()): There is no default value and an empty source should result in an error.
- [x] `Observable.combineLatestDelayError(ObservableSource[], Function)`: missing diagram
- [x] `Observable.combineLatestDelayError(Function, int, ObservableSource...)`: missing diagram
- [x] `Observable.concatArrayEager`: missing diagram
- [x] `Observable.error`: should include the X in the operator body indicating it as being the parameter/return value
- [x] `Observable.fromFuture`: the operator name in the box
- [x] `Observable.fromIterable`: the operator name in the box
- [x] `Observable.fromPublisher`: missing diagram
- [x] `Observable.just`: the element should be a parameter inside the box, such outside elements imply a subject type external push.
- [x] `Observable.just(T, T)` +7: optionally tailor the diagram to the actual number of arguments, plus move the constant values inside the box
- [x] `Observable.rangeLong`: the operator name in the box
- [x] `Observable.switchOnNextDelayError`: the operator name in the box, indicator of an error getting delayed
- [x] `Observable.zipArray`: indicate there is a function instead of implying the output is an array containing one element from each source.
- [x] `Observable.zipIterable`: the operator name in the box
- [x] `Observable.all`: example of a false result
- [x] `Observable.ambWith`: the operator name in the box
- [x] `Observable.blockingFirst`: missing diagram
- [x] `Observable.blockingForEach`: the operator name in the box
- [x] `Observable.blockingIterable`: the operator name in the box, indicate that blocking may happen for each element
- [x] `Observable.blockingLast`: the operator name in the box
- [x] `Observable.blockingLast(T)`: the operator name in the box, indicate default in the box, fix labels
- [x] `Observable.blockingLatest`: missing diagram
- [x] `Observable.blockingMostRecent`: the operator name in the box
- [x] `Observable.blockingNext`: the operator name in the box
- [x] `Observable.blockingSingle`: the operator name in the box
- [x] `Observable.blockingSingle(T)`: the operator name in the box, indicate default in the box, fix labels
- [x] `Observable.toFuture()`: the operator name in the box, indicate multi-value, empty and error behavior
- [x] `Observable.blockingSubscribe`: missing diagram
- [x] `Observable.cacheWithInitialCapacity`: the operator name in the box
- [x] `Observable.collectInto`: the operator name in the box, indicate the shared collection
- [x] `Observable.concatMapCompletable`: missing diagram
- [x] `Observable.concatMapDelayError`: missing diagram
- [x] `Observable.concatMapEager`: missing diagram
- [x] `Observable.concatMapEagerDelayError`: missing diagram
- [x] `Observable.concatMapIterable`: missing diagram
- [x] `Observable.doAfterNext`: missing diagram
- [x] `Observable.doFinally`: missing diagram
- [x] `Observable.doOnDispose`: the operator name in the box
- [x] `Observable.doOnComplete`: indicate that the events pass through and the star is execute before the onComplete to downstream
- [x] `Observable.doOnError`: indicate that the events pass through and the star is execute before the onError to downstream
- [x] `Observable.doOnLifecycle`: change unsubscribe to dispose
- [x] `Observable.doOnNext`: indicate that the events pass through and the star is execute before the onNext to downstream
- [x] `Observable.doOnTerminate`: indicate that the events pass through and the star is execute before the onError or onComplete to downstream
- [x] `Observable.elementAt(long)`: example of empty source
- [x] `Observable.elementAt(long, T)`: example of empty source
- [x] `Observable.elementAtOrError(long)`: example of empty source
- [x] `Observable.firstElement`: diagram is stretched
- [x] `Observable.firstOrError`: the operator name in the box
- [x] `Observable.flatMap(Function, boolean, int)`: missing diagram
- [x] `Observable.flatMap(Function, boolean, int, int)`: missing diagram
- [x] `Observable.flatMap(Function, Function, Callable, int)`: missing diagram
- [x] `Observable.flatMap(Function, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, boolean, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, boolean, int, int)`: missing diagram
- [x] `Observable.flatMap(Function, BiFunction, int)`: missing diagram
- [x] `Observable.flatMapCompletable()`: missing diagram
- [x] `Observable.flatMapIterable(Function)`: diagram looks stretched
- [x] `Observable.forEach()`: missing diagram
- [x] `Observable.forEachWhile()`: missing diagram
- [x] `Observable.hide()`: missing diagram - not sure how to represent this
- [x] `Observable.lastOrError()`: operator name in the box, error case example.
- [x] `Observable.onErrorReturn()`: indicate that the value is the result of a function call
- [x] `Observable.onErrorReturnItem()`: operator name in the box
- [x] `Observable.onTerminateDetach`: missing diagram
- [x] `Observable.publish(Function)`: there is no connect call, may need extensive redrawing
- [x] `Observable.reduceWith()`: operator name in the box
- [x] `Observable.repeat()` + overloads: indicate fresh subscriptions happen, not caching
- [x] `Observable.repeatUntil`: operator name in the box, indicate fresh subscriptions
- [x] `Observable.replay()` + overloads: remove publish
- [x] `Observable.replay(Function, ...)` overloads: may need extensive redrawing
- [x] `Observable.retry(long)` indicate limited retry effect
- [x] `Observable.retry(Predicate)` indicate predicate effect, show it in the box
- [x] `Observable.retry(long, Predicate)` indicate predicate, show them in the box
- [x] `Observable.retryUntil`: operator name in the box, show BooleanSupplier
- [x] `Observable.share()`: fix labels with unsubscribe
- [x] `Observable.singleElement`: example with empty source
- [x] `Observable.sorted`: missing diagram
- [x] `Observable.startWith(T)`: have a single item as start value
- [x] `Observable.startWithArray(T...)`: operator name
- [x] `Observable.subscribe` + overloads: missing diagram
- [x] [Observable.switchMapSingle](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#switchMapSingle(io.reactivex.functions.Function)): inner sources should have 1 item.
- [x] `Observable.switchMapDelayError` + indicate the error case
- [x] `Observable.toList(Callable)`: indicate the custom collection somehow?
- [x] `Observable.toFlowable()`: missing diagram
- [x] `Observable.unsubscribeOn()`: missing diagram
- [x] `Observable.zipWith()` + overloads: the diagram is in line with some text and appears pushed to the right
- [x] `Observable.test()`: missing diagram, can this be represented as diagram?
  
  ,PRs welcome. The most easy ones are those that require alignment/displayed size corrections. =||= Hi David, I'd love to help, what would I use to edit the diagrams? =||= If you are on Mac and you own OmniGraffle, there is a file for **all** traditional diagrams:
https://github.com/ReactiveX/reactivex.github.io/issues/223

I'm using Excel 2007+ on Windows to draw the newer diagrams and have a file [here](https://drive.google.com/open?id=0B4T7ZW3brESKQV9KaEF5YnpjM0k) you can use as basis for newer diagrams. I don't know if the open office variants could open this file or not, Google's viewer certainly doesn't show the drawings.

I suppose as a last resort you can draw in the open-office variants as well and post the PNGs in this issue. Uploading it requires access to the wiki git of RxJava. The target rendering is 640 pixels wide and as long as it needs to be.

The process is as follows:

- Draw diagram(s)
- Upload to git
- Modify Javadoc locally to point to the raw usercontent
- Verify and fix alignment/stretching
- Commit PR to RxJava itself =||= Is it `switchMapSingle` need a new diagram too? SingleResource can't emit 2 items. =||= Yes. I'll add it to the list above. =||= ## ConcatArrayEager

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.png) =||= ## Error

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.item.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.supplier.png) =||= ## fromFuture

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.noarg.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.scheduler.png)
![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.scheduler.png) =||= ## fromIterable

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromIterable.png) =||= Another option is to use free open-source multi-platform Inkscape. Templates here:

https://github.com/davidmoten/rxjava-marble-template =||= **startWith(T)**

![startwith t](https://user-images.githubusercontent.com/6715387/28749559-b5f451dc-74a1-11e7-9a24-db339a2da754.png)


 =||= **startWithArray(T...)**

![startwitharray](https://user-images.githubusercontent.com/6715387/28749281-5f23f834-7498-11e7-99a5-49033842ecb9.png)

 =||= Thanks. Could you make sure the operator box has its contents centered? =||= Sure. Going to edit them. =||= **sorted()**

Is it okay to add numbers to the marbles?

![sorted](https://user-images.githubusercontent.com/6715387/28749679-1660f5b2-74a6-11e7-909b-f9c6cb7ce2c5.png)


 =||= In this case yes, because it also demonstrates the self-comparable nature required (changing the order of colors is unlikely to convey the sorting aspect). For most of the other operators, the matching up of the color should be enough. =||= Not sure how you do these images, could you add shadows to the marbles, the time arrows and the vertical complete indicators? =||= I'm using @davidmoten's template. Going to edit them to add the shadows.  =||= sorted(): it would be better that the source marbles are at the beginning and the output is only happening after onComplete:

```
---5--3--1--4--2--|--------------
[            sorted()           ]
---------------------1-2-3-4-5-|-
``` =||= Added shadows and edited the `sorted()` operator. =||= **just(T)**

![just](https://user-images.githubusercontent.com/6715387/28749794-944aea34-74a9-11e7-9e52-43604442c87d.png)

 =||= **rangelong()**

![rangelong](https://user-images.githubusercontent.com/6715387/28749798-cf44b69c-74a9-11e7-853b-958018e492c4.png)
 =||= Thanks @leonardortlima ! The first 5 images is added via #5524. =||= Just noticed that `Single.filter` and `Maybe.filter` are also incorrect; they seem to be copied from `Observable.filter`. =||= Quite possibly the other base reactive classes have copy-paste diagrams. This issue tracks the fixes of `Observable` but if you want, I can open issues for the other classes individually. =||= ![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.2.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.3.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.4.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.5.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.6.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.7.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.8.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.9.png)

![just(2)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.10.png)

![switchOnNextDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchOnNextDelayError.png) =||= From #5668:

![singleelement](https://user-images.githubusercontent.com/4089934/31583261-a6da996a-b18f-11e7-8682-dffa647c7e4a.png) =||= ### zipIterable

![zipIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipIterable.o.png)

### ambWith

![ambWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ambWith.o.png)

### blockingForEach

![blockingForEach](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingForEach.o.png)

### blockingIterable

![blockingIterable](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingIterable.o.png)

### blockingLast

![blockingLast](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLast.o.png)

![blockingLast](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLastDefault.o.png)

### blockingMostRecent

![blockingMostRecent](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingMostRecent.o.png)

### blockingNext

![blockingNext](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingNext.o.png)

### blockingSingle

![blockingSingle](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingle.o.png)

![blockingSingle](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingleDefault.o.png)

### cacheWithInitialCapacity

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cacheWithInitialCapacity.o.png) =||= ### all

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.o.png)

### fromPublisher

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromPublisher.o.png)

### zipArray

![cachecWithInitialCapacity](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipArray.o.png) =||= ### blockingFirst

![blockingFirst](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.png)


![blockingFirst](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.default.png)

### toFuture


![toFuture](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFuture.o.png)


### blockingSubscribe

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.0.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.1.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.2.png)

![blockingSubscribe](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.png)

### collectInto

![collectInto](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collectInto.o.png)

### doOnComplete

![doOnComplete](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.o.png)

### doOnError

![doOnError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.o.png)

### doOnLifecycle

![doOnLifecycle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnLifecycle.o.png)

### doOnNext

![doOnNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.o.png)

 =||= ### concatMapCompletable

![concatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapCompletable.o.png)

### concatMapDelayError

![concatMapDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapDelayError.o.png)

### concatMapEager

![concatMapEager](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEager.o.png)

### concatMapEagerDelayError

![concatMapEagerDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEagerDelayError.o.png)

### concatMapIterable

![concatMapIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapIterable.o.png)

### doAfterNext

![doAfterNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterNext.o.png)

### doFinally

![doFinally](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png) =||= ### doOnTerminate

![doOnTerminate](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.o.png)

### elementAt

![elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.o.png)
![elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtDefault.o.png)

### elementAtOrError

![elementAtOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrError.o.png)

### firstOrError

![firstOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.o.png)

### flatMap

![flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapDelayError.o.png)
![flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png)



 =||= ![flatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletable.o.png)

![flatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletableDelayError.o.png)

![forEach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEach.o.png)

![forEachWhile](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEachWhile.o.png)

![hide](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/hide.o.png) =||= ![lastOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png)
![onErrorReturn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.o.png)
![onErrorReturnItem](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturnItem.o.png)
![onTerminateDetach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onTerminateDetach.o.png)
![publish(Function)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishFunction.o.png)
![reduce(seed, f)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.o.png)
![reduceWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceWith.o.png)
![repeat()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatInf.o.png)
![repeat(long)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatCount.o.png)
![repeatUntil](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatUntil.o.png)
![replay()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.png)
![replay(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.n.png)  
![replay(int, long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nt.png)
![replay(int, long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nts.png)
![replay(int, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ns.png)
![replay(long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.t.png)
![replay(long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ts.png)
![replay(Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.s.png) =||= ![no arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.f.png)
![scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fs.png)
![bufferSize](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fn.png)
![bufferSize, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fns.png)
![time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ft.png)
![time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fts.png)
![bufferSize, time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnt.png)
![bufferSize, time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnts.png)
 =||= ![retry(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.n.png)
![retry(BiFunction)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.ne.png)
![retry(Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.e.png)
![retry(int, Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.nfe.png)
![retryUntil(BooleanSupplier)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryUntil.o.png)
![share](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.png)
![switchMapSingle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingle.o.png)
![switchMapSingleDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingleDelayError.o.png) =||= ![toList(Callable)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.o.c.png)
![toFlowable(BUFFER)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.buffer.png)
![toFlowable(DROP)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.drop.png)
![toFlowable(LATEST)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.latest.png)
![toFlowable(ERROR)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.error.png)
![toFlowable(MISSING)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.missing.png)
![unsubscribeOn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/unsubscribeOn.o.png)
 =||= ,0
5811,580,CRLF fixes,Issue #579

In case the manual mode is chosen.,[RxJava-pull-requests #519](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/519/) SUCCESS
This pull request looks good
 =||= I added the .gitattributes file in this commit: https://github.com/Netflix/RxJava/commit/4782588aa15a954ea053977d6b740127d31ee3f1 and then let Git renormalize itself as per https://help.github.com/articles/dealing-with-line-endings#re-normalizing-a-repository
 =||= ,0
5820,5819,RxJavaPlugins.java should not be reading all system properties,Hi,

I am working on 1.3.4 version of Rxjava jar and there are certain methods where RxJavaPlugins.java is trying to read all the system properties while getting hooks. Not all companies give access to their system properties on server. For example, we use tomcat and have catalina policy which restricts to properties mentioned there. Due to this, i am getting access denied exceptions.

I propose 2 solutions:
1. Remove system.getproperties() and it should be able to read only properties which are required to get the hooks
2. Provide an implementation via application property which doesn't look for implementation at all.

I am okay with either solution. Please help,It was a long time ago and I'm not sure we know what keys to look for, hence the full enumeration. Besides, v1 is nearly EOL so please consider upgrading to RxJava 2 which shouldn't have this problem. =||= It came to my thought that but we are not using rxjava dependency directly. This is being referenced as a compile dependency from spring-cloud-starter-hystrix jar. If rxjava 2.x is backward compatible, i can use it. But it looks like there are quite a few enhancements =||= Workaround posted in #5820. I assume the exception happens in the `entrySet` iteration and not in the `clone` line, right? =||= No, they actually happen in the following methods of RxJavaPlugins

getErrorHandler()
getObservableExecutionHook()
getSingleExecutionHook()
getCompletableExecutionHook()
getSchedulersHook()

These methods are being currently called as default implementations if custom handlers/hooks are not available. These methods search for "all system properties" first to look for implementation class defined in system property instead of looking for certain system properties. =||= Please post the full stacktrace of the exception you are getting. =||= ```
25-Jan-2018 03:28:55.941 SEVERE [localhost-startStop-1] org.apache.catalina.core.ContainerBase.addChildInternal ContainerBase.addChild: start:
org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/XXX]]
        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:167)
        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:752)
        at org.apache.catalina.core.ContainerBase.access$000(ContainerBase.java:129)
        at org.apache.catalina.core.ContainerBase$PrivilegedAddChild.run(ContainerBase.java:150)
        at org.apache.catalina.core.ContainerBase$PrivilegedAddChild.run(ContainerBase.java:140)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:726)
        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734)
        at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:986)
        at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1857)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'documentationPluginsBootstrapper' defined in URL [jar:file:/D:/dev/apache-tomcat-8.5.24/temp/0-contestgateway/WEB-INF/lib/springfox-spring-web-2.8.0.j
!/springfox/documentation/spring/web/plugins/DocumentationPluginsBootstrapper.class]: Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean
th name 'webMvcRequestHandlerProvider' defined in URL [jar:file:/D:/dev/apache-tomcat-8.5.24/temp/0-contestgateway/WEB-INF/lib/springfox-spring-web-2.8.0.jar!/springfox/documentation/spring/web/plugins/WebMvcRequestHandlerProvider.class]: Unsatisfied depende
y expressed through constructor parameter 1; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'endpointHandlerMapping' defined in class path resource [org/springframework/boot/actuate/autoconfigure/En
ointWebMvcManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMappi
]: Factory method 'endpointHandlerMapping' threw exception; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mvcEndpoints' defined in class path resource [org/springframework/boot/actuate/autoconfigu
/EndpointWebMvcManagementContextConfiguration.class]: Invocation of init method failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/spr
gframework/cloud/netflix/hystrix/HystrixCircuitBreakerConfiguration$HystrixWebConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ExceptionInInitializerError
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749)
        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)
        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543)
        at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122)
        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693)
        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360)
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:303)
        at org.springframework.boot.web.support.SpringBootServletInitializer.run(SpringBootServletInitializer.java:154)
        at org.springframework.boot.web.support.SpringBootServletInitializer.createRootApplicationContext(SpringBootServletInitializer.java:134)
        at org.springframework.boot.web.support.SpringBootServletInitializer.onStartup(SpringBootServletInitializer.java:87)
        at org.springframework.web.SpringServletContainerInitializer.onStartup(SpringServletContainerInitializer.java:169)
        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5196)
        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)
        ... 14 more
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'webMvcRequestHandlerProvider' defined in URL [jar:file:/D:/dev/apache-tomcat-8.5.24/temp/0-contestgateway/WEB-INF/lib/springfox-spring-web-2.8.0.jar!/
ringfox/documentation/spring/web/plugins/WebMvcRequestHandlerProvider.class]: Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'endpoi
HandlerMapping' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationE
eption: Failed to instantiate [org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping]: Factory method 'endpointHandlerMapping' threw exception; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean wi
name 'mvcEndpoints' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]: Invocation of init method failed; nested exception is org.springframework.beans.factory.BeanCreationExcep
on: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/springframework/cloud/netflix/hystrix/HystrixCircuitBreakerConfiguration$HystrixWebConfiguration.class]: Invocation of init method failed; nested exception is java.
ng.ExceptionInInitializerError
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749)
        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1316)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1282)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1180)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1096)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066)
        at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835)
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741)
        ... 36 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'endpointHandlerMapping' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]: Bea
instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping]: Factory method 'endpointHandlerMapping' threw exc
tion; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mvcEndpoints' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]
Invocation of init method failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/springframework/cloud/netflix/hystrix/HystrixCircuitBreak
Configuration$HystrixWebConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ExceptionInInitializerError
        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1173)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1067)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1316)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1282)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1180)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1096)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066)
        at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835)
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741)
        ... 53 more
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping]: Factory method 'endpointHandlerMapping' threw exception; nested exception is org.springframework.be
s.factory.BeanCreationException: Error creating bean with name 'mvcEndpoints' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]: Invocation of init method failed; nested excepti
is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/springframework/cloud/netflix/hystrix/HystrixCircuitBreakerConfiguration$HystrixWebConfiguration.class]: In
cation of init method failed; nested exception is java.lang.ExceptionInInitializerError
        at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189)
        at org.springframework.beans.factory.support.ConstructorResolver$3.run(ConstructorResolver.java:582)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:579)
        ... 69 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mvcEndpoints' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]: Invocation of
nit method failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/springframework/cloud/netflix/hystrix/HystrixCircuitBreakerConfiguration
ystrixWebConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ExceptionInInitializerError
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1628)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)
        at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.obtainBeanInstanceFromFactory(ConfigurationClassEnhancer.java:389)
        at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:361)
        at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f0fb20ab.mvcEndpoints(<generated>)
        at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration.endpointHandlerMapping(EndpointWebMvcManagementContextConfiguration.java:100)
        at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f0fb20ab.CGLIB$endpointHandlerMapping$0(<generated>)
        at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f0fb20ab$$FastClassBySpringCGLIB$$950684e.invoke(<generated>)
        at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)
        at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:358)
        at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f0fb20ab.endpointHandlerMapping(<generated>)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162)
        ... 72 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/springframework/cloud/netflix/hystrix/HystrixCircuitBreakerConfiguration$HystrixWebConfiguration.cla
]: Invocation of init method failed; nested exception is java.lang.ExceptionInInitializerError
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1628)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:519)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:508)
        at org.springframework.context.support.AbstractApplicationContext.getBeansOfType(AbstractApplicationContext.java:1188)
        at org.springframework.beans.factory.BeanFactoryUtils.beansOfTypeIncludingAncestors(BeanFactoryUtils.java:261)
        at org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints.afterPropertiesSet(MvcEndpoints.java:58)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$6.run(AbstractAutowireCapableBeanFactory.java:1677)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1674)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1624)
        ... 92 more
Caused by: java.lang.ExceptionInInitializerError
        at com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet.<init>(HystrixMetricsStreamServlet.java:59)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at java.lang.Class.newInstance(Class.java:442)
        at org.springframework.web.servlet.mvc.ServletWrappingController.afterPropertiesSet(ServletWrappingController.java:144)
        at org.springframework.cloud.netflix.endpoint.ServletWrappingEndpoint.afterPropertiesSet(ServletWrappingEndpoint.java:50)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$6.run(AbstractAutowireCapableBeanFactory.java:1677)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1674)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1624)
        ... 107 more
Caused by: java.security.AccessControlException: access denied ("java.util.PropertyPermission" "*" "read,write")
        at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)
        at java.security.AccessController.checkPermission(AccessController.java:884)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
        at java.lang.SecurityManager.checkPropertiesAccess(SecurityManager.java:1262)
        at java.lang.System.getProperties(System.java:630)
        at rx.plugins.RxJavaPlugins.getSchedulersHook(RxJavaPlugins.java:345)
        at rx.schedulers.Schedulers.<init>(Schedulers.java:57)
        at rx.schedulers.Schedulers.getInstance(Schedulers.java:46)
        at rx.schedulers.Schedulers.computation(Schedulers.java:123)
        at rx.Observable.interval(Observable.java:2070)
        at com.netflix.hystrix.metric.consumer.HystrixDashboardStream.<init>(HystrixDashboardStream.java:41)
        at com.netflix.hystrix.metric.consumer.HystrixDashboardStream.<clinit>(HystrixDashboardStream.java:69)
        ... 119 more
``` =||= Updated the PR. =||= Thank you so much for your quick response and fix =||= Closing via #5820. =||= ,0
5828,5827,replay(1) retains second-to-last emitted item,Version:  `2.x`: `2.1.9`

When using `Observable.replay(1)`, the second-to-last object emitted by the upstream observable is retained by the internal buffer. I would expect only the last object to be retained, and this is especially problematic if the objects are large, such as an Android `Bitmap` or `Activity`.

Sample code:

```kotlin
val subject = BehaviorSubject.create<Int>()
subject.onNext(1)
subject.onNext(2)
subject.onNext(3)
val replay = subject.replay(1)
replay.connect()
Assert.assertEquals(listOf(3), replay.test().values())
subject.onNext(4)
Assert.assertEquals(listOf(4), replay.test().values())
subject.onNext(5)
// replay.current.value.buffer.value.value contains 4
Assert.assertEquals(listOf(5), replay.test().values())
```,That's an unfortunate effect of the linked structure in `replay` and the facts that 1) discontinuity is not allowed and 2) observers subscribing concurrently should start somewhere.

That's why the `head` references a `Node` instance where the actual value is behind the `next` link. This way, observers can pick the head `Node` and when the time is right for them, start walking the links. Thus, a `replay(1)` will have two nodes with a previous node and one with the cached value. Nulling out the previous node doesn't work as `replay` can't know there isn't a late consumer still walking the links from a much earlier node.

If there wasn't any initial empty `Node`, observers would have to keep check somehow when the first item's `Node` gets created. Unfortunately, this potentially concurrent activity may lead to lost initial items for some observers.

The third option would be reference counting Nodes, which is very expensive and complicated.

If you need to cache the very latest, simply keep using the `BehaviorSubject`. =||= Thanks for the explanation. I suspected along those lines.

If a fix isn't viable, I think this is worth documenting, as it's counter-intuitive. =||= PR welcome. =||= There could be a less expensive approach by creating a fresh head node with link to the next cached item. This should allow late observers to capture the head node and follow the next links and the head would no longer reference the previous item:

```java
        void trim() {
            if (size > maxSize) {
                size--;
                Node<Object> h = head.get();
                Node<Object> n = new Node<Object>(null);
                n.lazySet(h.get());
                head = n;
            }
        }
```

The drawback is that there is now two nodes allocated per upstream item.

Note that there are 2 base type replays, 1 subject, 1 processor and 2 bounded replay modes, a total of 8 algorithms to adjust or document. =||= Closing via #5828. =||= ,0
5833,5832,2.x Observable onError does not dispose switchMap's inner ObservableSource,Hi, I'm facing an issue with Observable's switchMap/switchMapSingle where the inner source does not get disposed if the upstream emits an error. Happens on both version 2.1.6 and 2.1.9. Is this the expected behavior?

Observable version does not dispose the inner source
```        
        Observable
                .create(e -> {
                    e.onNext(true);
                    e.onError(new Throwable());
                })
                .switchMap(__ -> Observable
                        .timer(500L, TimeUnit.MILLISECONDS)
                        .doOnNext(System.out::println))
                .subscribe(__->{}, __->{});
        Thread.sleep(1000L);
```


While the Flowable version does dispose the inner source.

```        
        Flowable
                .create(e -> {
                    e.onNext(true);
                    e.onError(new Throwable());
                }, BackpressureStrategy.BUFFER)
                .switchMap(__ -> Flowable
                        .timer(500L, TimeUnit.MILLISECONDS)
                        .doOnNext(System.out::println))
                .subscribe(__->{}, __->{});
        Thread.sleep(1000L);
```,Thanks for reporting. This is a bug in the `Observable.switchMap` implementation. Fix posted in #5833. =||= ,0
5845,5350,RxJava 2: Observable.concatWith variants for Single, Completable & Maybe.,How do you guys feel about `concatWith` variants that take `Single`, `Completable` and `Maybe`. For now they could internally just use `toObservable()` and then maybe later receive custom implementations.,Another nice addition would be the `mergeWith()` as well. Given that this has received some upvotes would you consider adding those methods? =||= Use Kotlin? =||= I'm doing that right now however having custom implementations could improve performance since certain shortcuts can be taken. For instance knowing that Single can only emit once or error once unlike `Observable` / `Flowable` variants. =||= This can be closed now with #5845 & #5847  =||= ,0
5847,5350,RxJava 2: Observable.concatWith variants for Single, Completable & Maybe.,How do you guys feel about `concatWith` variants that take `Single`, `Completable` and `Maybe`. For now they could internally just use `toObservable()` and then maybe later receive custom implementations.,Another nice addition would be the `mergeWith()` as well. Given that this has received some upvotes would you consider adding those methods? =||= Use Kotlin? =||= I'm doing that right now however having custom implementations could improve performance since certain shortcuts can be taken. For instance knowing that Single can only emit once or error once unlike `Observable` / `Flowable` variants. =||= This can be closed now with #5845 & #5847  =||= ,0
5860,5763,2.x -- group by, custom map variant,We are using release 2.1.7.

As is noted in the "What's Different" page, the variant of `groupBy` that accepts a custom map factory is not currently part of the 2.x API.  We were relying on this to implement "eviction" of groups that haven't been seen for a "long time" (where "long" is user specified).  Our system maintains Flowable instances for its entire lifetime (which is hopefully weeks/months), so it is important to be able to reclaim resources as we go.

Anyway -- my questions are -- are the plans to bring this back?  Is there a suggested alternative for implementing the disposal of groups after a period of inactivity?  Any guidance would be appreciated.,It was a community contribution which was not ported to 2.x by the original author. You can timeout groups and switch to an empty flow:

```java
source.groupBy(v -> key(v))
.map(g -> g.timeout(5, TimeUnit.MINUTES, Observable.empty())
.flatMap(g -> /* the usual group processing */)
``` =||= Thanks, that should work nicely. =||= I was author of that contribution to 1.x #3931. Using `timeout` was discussed but it had problems. In particular you can lose emissions. If @akarnokd is in favour I can investigate adapting the `groupBy` operator to use a Map factory again. =||= Yes, PR welcome. =||= @davidmoten thanks for the info re: timeout dropping emissions.  We have essentially the same use case that you describe in #3931, so something that avoids that issue for Rx2 would be great. =||= Just looking at the PR now. @akarnokd do you have any advice for optimizing the RxJava 2.x compile experience in Eclipse (latest)? I just waited 5 min 40s for the project to compile after modifying some code and this happens frequently. 

PS Just realized I'm not using the Eclipse Gradle plugin for the project in Eclipse but rather running `./gradlew eclipse` and importing as an Eclipse project. What do you do @akarnokd? =||= None. The bug has been reported and hopefully we get it backported to 4.7. =||= Ok. You still using Eclipse for dev on RxJava? =||= Yes. I just do something else for 10 minutes while Eclipse is compiling. After that, as long as you don't touch the main classes, it's okay. =||= Eclipse slow compilation bug:

https://bugs.eclipse.org/bugs/show_bug.cgi?id=521438 =||= I'm using IntelliJ and it works without any problems. Also Android studio picks RxJava up correctly.  =||= Thanks @vanniktech, I might switch to that for RxJava contributions. =||= Closing via #5860. =||= Woohoo! Slow compilation of RxJava 2.x is fixed in Eclipse 4.7.3. =||= ,0
5863,5862,Step-by-step guide for writing a custom operator?,I've been trying, with limited success, to understand the discussion of creating custom 2.x operators. I think I get the section "Operator by extending a base reactive class", but what would really help for the "Operator targeting lift()" discussion is a _complete, design-through-usage_ example of creating an operator. Is this possible? 

Suggestion: a simple operator that transforms its input type, perhaps something like `.countCharacters()` that would accept a `String` and emit an `Integer` with the number of characters in the `String`. If possible, versions with and without backpressure would be extra helpful. ,This shouldn't be of any difficulty because the two modes are only a straighforward transformation away:

You write the operator:
```java
final class SomeOp<T> implements FlowableSubscriber<T>, Subscription {
   // etc
}
```

Optionally turn it into a liftable expression:
```java
FlowableOperator<T, T> op = downstream -> new SomeOp<>(downstream, params);

Flowable.range(1, 5).lift(op).subscribe(System.out::println);
```

Or turn it into a transformer:

```java
FlowableTransformer<T, T> ft = upstream -> new Flowable<T>() {
    @Override public void subscribeActual(Subscriber<? super T> downstream) {
        upstream.subscribe(new SomeOp<>(downstream, params));
    }
};

Flowable.range(1, 5).compose(ft).subscribe(System.out::println);
```

or use lifting and a transformer:

```java
FlowableTransformer<T, T> ft2 = upstream -> updstream.lift(op); 

Flowable.range(1, 5).compose(ft2).subscribe(System.out::println);
``` =||= You could also read [my blog](http://akarnokd.blogspot.hu/2017/03/java-9-flow-api-asynchronous-integer.html) and study the RxJava source code. =||= Thanks, I will certainly study. But sometimes, you know, there's just no substitute for a fully worked-out example. 

A large part of my problem is that the documentation of `.lift()` is essentially incomprehensible to me (it's remarkable that the javadoc literally begins with a warning to the reader against trying to understand it!). And this just isn't much help: 

> Lifts a function to the current Publisher and returns a new Publisher that when subscribed to will pass the values of the current Publisher through the Operator function.
> In other words, this allows chaining Subscribers together on a Publisher for acting on the values within the Publisher. 

Could someone please try to explain in simple terms what `lift()` actually does and how to use it? 

Final question: once I have created an operator, how do I "insert" it into the `Flowable` or other class so that I can reference it like the built-in operators? 
 =||= `lift()` allows you to access the downstream's `Subscriber` during the subscription phase and provide a new `Subscriber` that will be used in the subscription process going furhter upstream. Generally, this new `Subscriber` will wrap the downstream's `Subscriber` and forwards the `onNext`, `onError` and `onComplete` events directly or according to the emission pattern this so-called operator's business logic needs. In addition, such operator can intercept the flow control calls of `cancel` and `request` that would have travelled upstream and perform additional actions depending on the same business logic needs. The difficulty is to express such business logic properly. These can be so different that, for example, knowing how `map` can be implemented won't help you implement `observeOn`.

> it's remarkable that the javadoc literally begins with a warning to the reader against trying to understand it!

No, it warns the user about the complexities of using it and then suggests using existing operators, such as `map` for your `.countCharacters()`: `map(string -> string.length())`.

> I have created an operator, how do I "insert" it into the Flowable or other class so that I can reference it like the built-in operators?

You can't add a new operator to `Flowable` or the other base classes from the outside of RxJava as the Java language lacks the features to do so. You'd need extension methods which is available in Kotlin for example.

Therefore, you either write `FlowableTransformer`s or `FlowableOperator`s and use `compose` and `lift` respectively to use your custom operator in a sequence. The [RxJava 2 Extensions](https://github.com/akarnokd/RxJava2Extensions#flowabletransformersvalve) project demonstrates a lot of custom operators and their usage.

As a final note, I don't suggest you write operators if you are just learning RxJava, the target platform, the Java language or programming itself. =||= Please see PR #5863 for the suggested expansion of the JavaDoc of `lift`. =||= Closing via #5863. =||= ,0
5870,4853,2.x: switchMapSingle and switchMapCompletable,Hey,

the addition of `flatMapSingle`/`flatMapCompletable` made the usage of `Single` and `Completable` way nicer in RxJava 2.
Do you consider adding `switchMapSingle`/`switchMapCompletable` to RxJava 2 as well?

Cheers,You mean 1.x? I have no plans for that and I don't want to keep 1.x alive for too long. I'd like to stop enhancing 1.x in 6 months and enter it into a bugfix-only mode. Otherwise 3rd party libraries may delay their upgrade way longer.
 =||= He wants `switchMapSingle` and `switchMapCompletable` for RxJava 2 just like there is `flatMapSingle` and `flatMapCompletable`
 =||= @vanniktech exactly
 =||= Ah right. No plans for extending any other xMap operator
 =||= But then `concatMap` also needs the variants in order to be consistent. To be honest I forgot about those when proposing `flatMapSingle / flatMapCompletable / flatMapMaybe` initially - #4667 

And then there's also `Maybe`. Plus `Observable` and `Flowable` are able of mapping so it's easily another 12 methods.
- Observable.switchMapSingle
- Observable.switchMapMaybe
- Observable.switchMapCompletable
- Observable.concatMapSingle
- Observable.concatMapMaybe
- Observable.concatMapCompletable
- Flowable.switchMapSingle
- Flowable.switchMapMaybe
- Flowable.switchMapCompletable
- Flowable.concatMapSingle
- Flowable.concatMapMaybe
- Flowable.concatMapCompletable
 =||= If it is not on the roadmap because you don't want to add any more xMap operators, then I understand.

But if it is due to lack of the time, would you consider accepting contributions on the topic?
 =||= Sure, but these operators are not easy.
 =||= Yes, I know, those are one of the hardest. 
Still, I will at least have a look and see if I can deliver a PR.

Cheers!
 =||= Any progress on this? =||= I'm happy to have a look at this one if @tomaszpolanski doesn't have time at the moment. =||= @davidmoten It would be great! My available time now is pretty limited.  =||= So the list of new operators is quite big. Currently:

* Observable.switchMapSingle
* Observable.switchMapMaybe
* Observable.switchMapCompletable
* Observable.concatMapSingle
* Observable.concatMapMaybe
* Observable.concatMapCompletable
* Flowable.switchMapSingle
* Flowable.switchMapMaybe
* Flowable.switchMapCompletable
* Flowable.concatMapSingle
* Flowable.concatMapMaybe
* Flowable.concatMapCompletable

I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one. An example would be `Observable.switchMapSingle`:

```java
public final <R> Observable<R> switchMapSingle(
    final Function<? super T, ? extends SingleSource<? extends R>> mapper) {
        Function<? super T, Observable<R>> mapper2 = t -> 
            {
                SingleSource<? extends R> source = mapper.apply(t);
                Single<? extends R> single;
                if (source instanceof Single) {
                    single = (Single<? extends R>) source;
                } else {
                    single = Single.unsafeCreate(source);
                }
               return (Observable<R>) single.toObservable();
            };
        return switchMap(mapper2, bufferSize());
    }
```

This is just to demo the idea, I wouldn't use an anonymous class and lambdas are just used for readability.

@akarnokd any interest in this?
 =||= > I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one.

Indeed.

> An example would be

If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in `io.reactivex.internal.operators.flowable.FlowableInternalHelper` and its respective variants.

> any interest in this?

I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted. =||= >If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in io.reactivex.internal.operators.flowable.FlowableInternalHelper and its respective variants.

Yep no problems. I've appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too.

>I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted.

Sure. I'll proceed with PRs with unit tests for the new operators and I'm happy to have a stab at dedicated operators after that. =||= What is expected behaviour for `Observable.switchMapMaybe` and `Observable.switchMapCompletable`? I can try to take care of it but I am not convinced what that method should return.
 =||= In the mean time, would it be correct to assume that an acceptable workaround for this is as follows?: **.toObservable()**

```
upstream.concatMap {
        someObservable().collect{...}.toObservable()
    }
``` =||= @feresr 
Probably yes, at this moment in few places inside my code i have this type of stucture. It is very weird and uncessesery code but it is understandable.
@akarnokd 
What do you think about method switchMapCompletable which emit Object or maybe some enum? On the other hand we can we can swallow information about stream and do not emit anything. =||= @marcinsus I don't fully understand your question. Use `switchMapCompletable().andThen(Single)` to emit something after the switch completed. =||= The problem he talks about is that switchMapCompletable does not exist. 

switchMapSingle returns an Observable of the Single type.

So technically switchMapCompletable should return Void. (Which it can't, because that has no instance.) So he asks if the signature should rather expose some `enum Nothing` or just an `Object` =||= An `Observable.switchMapCompletable` should return `Completable`. =||= You are right as `flatMapCompletable` returns a `Completable`.

But now I find it weird that 
`Observable.flatMapSingle<T>`returns an `Observable<T>`
but 
`Observable.flatMapCompletable` returns an `Completable`. =||= A stream of 5 elements flatMap'd to a stream of a single element still results in a stream of 5 elements. =||= I'm working on implementing `concatMapCompletable` across the reactive types.

I'm wondering if the library should also have implementations of
`concatMapDelayErrorCompletable`, `concatMapEagerCompletable`, `concatMapEagerDelayErrorCompletable`?


 =||= `concatMapEagerCompletable` is indistinguishable from `flatMapCompletable` because all sources run concurrently and their only output is a terminal event; no items have to be buffered until their turn. Also the `maxConcurrency == 1` gets you `concatMapCompletable` behavior. =||= Ahh yes that makes sense.  

So is there any reason to implement `concatMapCompletable` at all?  If so do you want it to just use flatMapCompletable() internally or should there be a new direct implementation (what I've been working on)? =||= Actually, `Observable.flatMapCompletable` doesn't have `maxConcurrency` overload thus there might be a reason to implement `concatMapCompletable`. =||= Ok I'll keep at it then =||= https://github.com/ReactiveX/RxJava/issues/4853#issuecomment-281541715

Did anything ever come of this?  =||= #5161 and #5649 added some operators. =||= So there are plans to implement the other operators, but not in any particular timeframe? =||= The listed operators can simply expressed with the existing default operators and `toObservable`/`toFlowable` in the lambda parameters. Unfortunately, very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function. Imagine, you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code. Kotlin's extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the RxJava library. The issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer, I'm not particularly interested myself in tackling these types of operators. =||= Closing via #5870, #5871, #5872, #5873, #5875. =||= ,0
5871,4853,2.x: switchMapSingle and switchMapCompletable,Hey,

the addition of `flatMapSingle`/`flatMapCompletable` made the usage of `Single` and `Completable` way nicer in RxJava 2.
Do you consider adding `switchMapSingle`/`switchMapCompletable` to RxJava 2 as well?

Cheers,You mean 1.x? I have no plans for that and I don't want to keep 1.x alive for too long. I'd like to stop enhancing 1.x in 6 months and enter it into a bugfix-only mode. Otherwise 3rd party libraries may delay their upgrade way longer.
 =||= He wants `switchMapSingle` and `switchMapCompletable` for RxJava 2 just like there is `flatMapSingle` and `flatMapCompletable`
 =||= @vanniktech exactly
 =||= Ah right. No plans for extending any other xMap operator
 =||= But then `concatMap` also needs the variants in order to be consistent. To be honest I forgot about those when proposing `flatMapSingle / flatMapCompletable / flatMapMaybe` initially - #4667 

And then there's also `Maybe`. Plus `Observable` and `Flowable` are able of mapping so it's easily another 12 methods.
- Observable.switchMapSingle
- Observable.switchMapMaybe
- Observable.switchMapCompletable
- Observable.concatMapSingle
- Observable.concatMapMaybe
- Observable.concatMapCompletable
- Flowable.switchMapSingle
- Flowable.switchMapMaybe
- Flowable.switchMapCompletable
- Flowable.concatMapSingle
- Flowable.concatMapMaybe
- Flowable.concatMapCompletable
 =||= If it is not on the roadmap because you don't want to add any more xMap operators, then I understand.

But if it is due to lack of the time, would you consider accepting contributions on the topic?
 =||= Sure, but these operators are not easy.
 =||= Yes, I know, those are one of the hardest. 
Still, I will at least have a look and see if I can deliver a PR.

Cheers!
 =||= Any progress on this? =||= I'm happy to have a look at this one if @tomaszpolanski doesn't have time at the moment. =||= @davidmoten It would be great! My available time now is pretty limited.  =||= So the list of new operators is quite big. Currently:

* Observable.switchMapSingle
* Observable.switchMapMaybe
* Observable.switchMapCompletable
* Observable.concatMapSingle
* Observable.concatMapMaybe
* Observable.concatMapCompletable
* Flowable.switchMapSingle
* Flowable.switchMapMaybe
* Flowable.switchMapCompletable
* Flowable.concatMapSingle
* Flowable.concatMapMaybe
* Flowable.concatMapCompletable

I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one. An example would be `Observable.switchMapSingle`:

```java
public final <R> Observable<R> switchMapSingle(
    final Function<? super T, ? extends SingleSource<? extends R>> mapper) {
        Function<? super T, Observable<R>> mapper2 = t -> 
            {
                SingleSource<? extends R> source = mapper.apply(t);
                Single<? extends R> single;
                if (source instanceof Single) {
                    single = (Single<? extends R>) source;
                } else {
                    single = Single.unsafeCreate(source);
                }
               return (Observable<R>) single.toObservable();
            };
        return switchMap(mapper2, bufferSize());
    }
```

This is just to demo the idea, I wouldn't use an anonymous class and lambdas are just used for readability.

@akarnokd any interest in this?
 =||= > I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one.

Indeed.

> An example would be

If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in `io.reactivex.internal.operators.flowable.FlowableInternalHelper` and its respective variants.

> any interest in this?

I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted. =||= >If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in io.reactivex.internal.operators.flowable.FlowableInternalHelper and its respective variants.

Yep no problems. I've appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too.

>I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted.

Sure. I'll proceed with PRs with unit tests for the new operators and I'm happy to have a stab at dedicated operators after that. =||= What is expected behaviour for `Observable.switchMapMaybe` and `Observable.switchMapCompletable`? I can try to take care of it but I am not convinced what that method should return.
 =||= In the mean time, would it be correct to assume that an acceptable workaround for this is as follows?: **.toObservable()**

```
upstream.concatMap {
        someObservable().collect{...}.toObservable()
    }
``` =||= @feresr 
Probably yes, at this moment in few places inside my code i have this type of stucture. It is very weird and uncessesery code but it is understandable.
@akarnokd 
What do you think about method switchMapCompletable which emit Object or maybe some enum? On the other hand we can we can swallow information about stream and do not emit anything. =||= @marcinsus I don't fully understand your question. Use `switchMapCompletable().andThen(Single)` to emit something after the switch completed. =||= The problem he talks about is that switchMapCompletable does not exist. 

switchMapSingle returns an Observable of the Single type.

So technically switchMapCompletable should return Void. (Which it can't, because that has no instance.) So he asks if the signature should rather expose some `enum Nothing` or just an `Object` =||= An `Observable.switchMapCompletable` should return `Completable`. =||= You are right as `flatMapCompletable` returns a `Completable`.

But now I find it weird that 
`Observable.flatMapSingle<T>`returns an `Observable<T>`
but 
`Observable.flatMapCompletable` returns an `Completable`. =||= A stream of 5 elements flatMap'd to a stream of a single element still results in a stream of 5 elements. =||= I'm working on implementing `concatMapCompletable` across the reactive types.

I'm wondering if the library should also have implementations of
`concatMapDelayErrorCompletable`, `concatMapEagerCompletable`, `concatMapEagerDelayErrorCompletable`?


 =||= `concatMapEagerCompletable` is indistinguishable from `flatMapCompletable` because all sources run concurrently and their only output is a terminal event; no items have to be buffered until their turn. Also the `maxConcurrency == 1` gets you `concatMapCompletable` behavior. =||= Ahh yes that makes sense.  

So is there any reason to implement `concatMapCompletable` at all?  If so do you want it to just use flatMapCompletable() internally or should there be a new direct implementation (what I've been working on)? =||= Actually, `Observable.flatMapCompletable` doesn't have `maxConcurrency` overload thus there might be a reason to implement `concatMapCompletable`. =||= Ok I'll keep at it then =||= https://github.com/ReactiveX/RxJava/issues/4853#issuecomment-281541715

Did anything ever come of this?  =||= #5161 and #5649 added some operators. =||= So there are plans to implement the other operators, but not in any particular timeframe? =||= The listed operators can simply expressed with the existing default operators and `toObservable`/`toFlowable` in the lambda parameters. Unfortunately, very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function. Imagine, you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code. Kotlin's extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the RxJava library. The issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer, I'm not particularly interested myself in tackling these types of operators. =||= Closing via #5870, #5871, #5872, #5873, #5875. =||= ,0
5872,4853,2.x: switchMapSingle and switchMapCompletable,Hey,

the addition of `flatMapSingle`/`flatMapCompletable` made the usage of `Single` and `Completable` way nicer in RxJava 2.
Do you consider adding `switchMapSingle`/`switchMapCompletable` to RxJava 2 as well?

Cheers,You mean 1.x? I have no plans for that and I don't want to keep 1.x alive for too long. I'd like to stop enhancing 1.x in 6 months and enter it into a bugfix-only mode. Otherwise 3rd party libraries may delay their upgrade way longer.
 =||= He wants `switchMapSingle` and `switchMapCompletable` for RxJava 2 just like there is `flatMapSingle` and `flatMapCompletable`
 =||= @vanniktech exactly
 =||= Ah right. No plans for extending any other xMap operator
 =||= But then `concatMap` also needs the variants in order to be consistent. To be honest I forgot about those when proposing `flatMapSingle / flatMapCompletable / flatMapMaybe` initially - #4667 

And then there's also `Maybe`. Plus `Observable` and `Flowable` are able of mapping so it's easily another 12 methods.
- Observable.switchMapSingle
- Observable.switchMapMaybe
- Observable.switchMapCompletable
- Observable.concatMapSingle
- Observable.concatMapMaybe
- Observable.concatMapCompletable
- Flowable.switchMapSingle
- Flowable.switchMapMaybe
- Flowable.switchMapCompletable
- Flowable.concatMapSingle
- Flowable.concatMapMaybe
- Flowable.concatMapCompletable
 =||= If it is not on the roadmap because you don't want to add any more xMap operators, then I understand.

But if it is due to lack of the time, would you consider accepting contributions on the topic?
 =||= Sure, but these operators are not easy.
 =||= Yes, I know, those are one of the hardest. 
Still, I will at least have a look and see if I can deliver a PR.

Cheers!
 =||= Any progress on this? =||= I'm happy to have a look at this one if @tomaszpolanski doesn't have time at the moment. =||= @davidmoten It would be great! My available time now is pretty limited.  =||= So the list of new operators is quite big. Currently:

* Observable.switchMapSingle
* Observable.switchMapMaybe
* Observable.switchMapCompletable
* Observable.concatMapSingle
* Observable.concatMapMaybe
* Observable.concatMapCompletable
* Flowable.switchMapSingle
* Flowable.switchMapMaybe
* Flowable.switchMapCompletable
* Flowable.concatMapSingle
* Flowable.concatMapMaybe
* Flowable.concatMapCompletable

I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one. An example would be `Observable.switchMapSingle`:

```java
public final <R> Observable<R> switchMapSingle(
    final Function<? super T, ? extends SingleSource<? extends R>> mapper) {
        Function<? super T, Observable<R>> mapper2 = t -> 
            {
                SingleSource<? extends R> source = mapper.apply(t);
                Single<? extends R> single;
                if (source instanceof Single) {
                    single = (Single<? extends R>) source;
                } else {
                    single = Single.unsafeCreate(source);
                }
               return (Observable<R>) single.toObservable();
            };
        return switchMap(mapper2, bufferSize());
    }
```

This is just to demo the idea, I wouldn't use an anonymous class and lambdas are just used for readability.

@akarnokd any interest in this?
 =||= > I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one.

Indeed.

> An example would be

If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in `io.reactivex.internal.operators.flowable.FlowableInternalHelper` and its respective variants.

> any interest in this?

I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted. =||= >If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in io.reactivex.internal.operators.flowable.FlowableInternalHelper and its respective variants.

Yep no problems. I've appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too.

>I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted.

Sure. I'll proceed with PRs with unit tests for the new operators and I'm happy to have a stab at dedicated operators after that. =||= What is expected behaviour for `Observable.switchMapMaybe` and `Observable.switchMapCompletable`? I can try to take care of it but I am not convinced what that method should return.
 =||= In the mean time, would it be correct to assume that an acceptable workaround for this is as follows?: **.toObservable()**

```
upstream.concatMap {
        someObservable().collect{...}.toObservable()
    }
``` =||= @feresr 
Probably yes, at this moment in few places inside my code i have this type of stucture. It is very weird and uncessesery code but it is understandable.
@akarnokd 
What do you think about method switchMapCompletable which emit Object or maybe some enum? On the other hand we can we can swallow information about stream and do not emit anything. =||= @marcinsus I don't fully understand your question. Use `switchMapCompletable().andThen(Single)` to emit something after the switch completed. =||= The problem he talks about is that switchMapCompletable does not exist. 

switchMapSingle returns an Observable of the Single type.

So technically switchMapCompletable should return Void. (Which it can't, because that has no instance.) So he asks if the signature should rather expose some `enum Nothing` or just an `Object` =||= An `Observable.switchMapCompletable` should return `Completable`. =||= You are right as `flatMapCompletable` returns a `Completable`.

But now I find it weird that 
`Observable.flatMapSingle<T>`returns an `Observable<T>`
but 
`Observable.flatMapCompletable` returns an `Completable`. =||= A stream of 5 elements flatMap'd to a stream of a single element still results in a stream of 5 elements. =||= I'm working on implementing `concatMapCompletable` across the reactive types.

I'm wondering if the library should also have implementations of
`concatMapDelayErrorCompletable`, `concatMapEagerCompletable`, `concatMapEagerDelayErrorCompletable`?


 =||= `concatMapEagerCompletable` is indistinguishable from `flatMapCompletable` because all sources run concurrently and their only output is a terminal event; no items have to be buffered until their turn. Also the `maxConcurrency == 1` gets you `concatMapCompletable` behavior. =||= Ahh yes that makes sense.  

So is there any reason to implement `concatMapCompletable` at all?  If so do you want it to just use flatMapCompletable() internally or should there be a new direct implementation (what I've been working on)? =||= Actually, `Observable.flatMapCompletable` doesn't have `maxConcurrency` overload thus there might be a reason to implement `concatMapCompletable`. =||= Ok I'll keep at it then =||= https://github.com/ReactiveX/RxJava/issues/4853#issuecomment-281541715

Did anything ever come of this?  =||= #5161 and #5649 added some operators. =||= So there are plans to implement the other operators, but not in any particular timeframe? =||= The listed operators can simply expressed with the existing default operators and `toObservable`/`toFlowable` in the lambda parameters. Unfortunately, very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function. Imagine, you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code. Kotlin's extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the RxJava library. The issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer, I'm not particularly interested myself in tackling these types of operators. =||= Closing via #5870, #5871, #5872, #5873, #5875. =||= ,0
5873,4853,2.x: switchMapSingle and switchMapCompletable,Hey,

the addition of `flatMapSingle`/`flatMapCompletable` made the usage of `Single` and `Completable` way nicer in RxJava 2.
Do you consider adding `switchMapSingle`/`switchMapCompletable` to RxJava 2 as well?

Cheers,You mean 1.x? I have no plans for that and I don't want to keep 1.x alive for too long. I'd like to stop enhancing 1.x in 6 months and enter it into a bugfix-only mode. Otherwise 3rd party libraries may delay their upgrade way longer.
 =||= He wants `switchMapSingle` and `switchMapCompletable` for RxJava 2 just like there is `flatMapSingle` and `flatMapCompletable`
 =||= @vanniktech exactly
 =||= Ah right. No plans for extending any other xMap operator
 =||= But then `concatMap` also needs the variants in order to be consistent. To be honest I forgot about those when proposing `flatMapSingle / flatMapCompletable / flatMapMaybe` initially - #4667 

And then there's also `Maybe`. Plus `Observable` and `Flowable` are able of mapping so it's easily another 12 methods.
- Observable.switchMapSingle
- Observable.switchMapMaybe
- Observable.switchMapCompletable
- Observable.concatMapSingle
- Observable.concatMapMaybe
- Observable.concatMapCompletable
- Flowable.switchMapSingle
- Flowable.switchMapMaybe
- Flowable.switchMapCompletable
- Flowable.concatMapSingle
- Flowable.concatMapMaybe
- Flowable.concatMapCompletable
 =||= If it is not on the roadmap because you don't want to add any more xMap operators, then I understand.

But if it is due to lack of the time, would you consider accepting contributions on the topic?
 =||= Sure, but these operators are not easy.
 =||= Yes, I know, those are one of the hardest. 
Still, I will at least have a look and see if I can deliver a PR.

Cheers!
 =||= Any progress on this? =||= I'm happy to have a look at this one if @tomaszpolanski doesn't have time at the moment. =||= @davidmoten It would be great! My available time now is pretty limited.  =||= So the list of new operators is quite big. Currently:

* Observable.switchMapSingle
* Observable.switchMapMaybe
* Observable.switchMapCompletable
* Observable.concatMapSingle
* Observable.concatMapMaybe
* Observable.concatMapCompletable
* Flowable.switchMapSingle
* Flowable.switchMapMaybe
* Flowable.switchMapCompletable
* Flowable.concatMapSingle
* Flowable.concatMapMaybe
* Flowable.concatMapCompletable

I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one. An example would be `Observable.switchMapSingle`:

```java
public final <R> Observable<R> switchMapSingle(
    final Function<? super T, ? extends SingleSource<? extends R>> mapper) {
        Function<? super T, Observable<R>> mapper2 = t -> 
            {
                SingleSource<? extends R> source = mapper.apply(t);
                Single<? extends R> single;
                if (source instanceof Single) {
                    single = (Single<? extends R>) source;
                } else {
                    single = Single.unsafeCreate(source);
                }
               return (Observable<R>) single.toObservable();
            };
        return switchMap(mapper2, bufferSize());
    }
```

This is just to demo the idea, I wouldn't use an anonymous class and lambdas are just used for readability.

@akarnokd any interest in this?
 =||= > I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one.

Indeed.

> An example would be

If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in `io.reactivex.internal.operators.flowable.FlowableInternalHelper` and its respective variants.

> any interest in this?

I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted. =||= >If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in io.reactivex.internal.operators.flowable.FlowableInternalHelper and its respective variants.

Yep no problems. I've appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too.

>I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted.

Sure. I'll proceed with PRs with unit tests for the new operators and I'm happy to have a stab at dedicated operators after that. =||= What is expected behaviour for `Observable.switchMapMaybe` and `Observable.switchMapCompletable`? I can try to take care of it but I am not convinced what that method should return.
 =||= In the mean time, would it be correct to assume that an acceptable workaround for this is as follows?: **.toObservable()**

```
upstream.concatMap {
        someObservable().collect{...}.toObservable()
    }
``` =||= @feresr 
Probably yes, at this moment in few places inside my code i have this type of stucture. It is very weird and uncessesery code but it is understandable.
@akarnokd 
What do you think about method switchMapCompletable which emit Object or maybe some enum? On the other hand we can we can swallow information about stream and do not emit anything. =||= @marcinsus I don't fully understand your question. Use `switchMapCompletable().andThen(Single)` to emit something after the switch completed. =||= The problem he talks about is that switchMapCompletable does not exist. 

switchMapSingle returns an Observable of the Single type.

So technically switchMapCompletable should return Void. (Which it can't, because that has no instance.) So he asks if the signature should rather expose some `enum Nothing` or just an `Object` =||= An `Observable.switchMapCompletable` should return `Completable`. =||= You are right as `flatMapCompletable` returns a `Completable`.

But now I find it weird that 
`Observable.flatMapSingle<T>`returns an `Observable<T>`
but 
`Observable.flatMapCompletable` returns an `Completable`. =||= A stream of 5 elements flatMap'd to a stream of a single element still results in a stream of 5 elements. =||= I'm working on implementing `concatMapCompletable` across the reactive types.

I'm wondering if the library should also have implementations of
`concatMapDelayErrorCompletable`, `concatMapEagerCompletable`, `concatMapEagerDelayErrorCompletable`?


 =||= `concatMapEagerCompletable` is indistinguishable from `flatMapCompletable` because all sources run concurrently and their only output is a terminal event; no items have to be buffered until their turn. Also the `maxConcurrency == 1` gets you `concatMapCompletable` behavior. =||= Ahh yes that makes sense.  

So is there any reason to implement `concatMapCompletable` at all?  If so do you want it to just use flatMapCompletable() internally or should there be a new direct implementation (what I've been working on)? =||= Actually, `Observable.flatMapCompletable` doesn't have `maxConcurrency` overload thus there might be a reason to implement `concatMapCompletable`. =||= Ok I'll keep at it then =||= https://github.com/ReactiveX/RxJava/issues/4853#issuecomment-281541715

Did anything ever come of this?  =||= #5161 and #5649 added some operators. =||= So there are plans to implement the other operators, but not in any particular timeframe? =||= The listed operators can simply expressed with the existing default operators and `toObservable`/`toFlowable` in the lambda parameters. Unfortunately, very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function. Imagine, you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code. Kotlin's extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the RxJava library. The issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer, I'm not particularly interested myself in tackling these types of operators. =||= Closing via #5870, #5871, #5872, #5873, #5875. =||= ,0
5875,4853,2.x: switchMapSingle and switchMapCompletable,Hey,

the addition of `flatMapSingle`/`flatMapCompletable` made the usage of `Single` and `Completable` way nicer in RxJava 2.
Do you consider adding `switchMapSingle`/`switchMapCompletable` to RxJava 2 as well?

Cheers,You mean 1.x? I have no plans for that and I don't want to keep 1.x alive for too long. I'd like to stop enhancing 1.x in 6 months and enter it into a bugfix-only mode. Otherwise 3rd party libraries may delay their upgrade way longer.
 =||= He wants `switchMapSingle` and `switchMapCompletable` for RxJava 2 just like there is `flatMapSingle` and `flatMapCompletable`
 =||= @vanniktech exactly
 =||= Ah right. No plans for extending any other xMap operator
 =||= But then `concatMap` also needs the variants in order to be consistent. To be honest I forgot about those when proposing `flatMapSingle / flatMapCompletable / flatMapMaybe` initially - #4667 

And then there's also `Maybe`. Plus `Observable` and `Flowable` are able of mapping so it's easily another 12 methods.
- Observable.switchMapSingle
- Observable.switchMapMaybe
- Observable.switchMapCompletable
- Observable.concatMapSingle
- Observable.concatMapMaybe
- Observable.concatMapCompletable
- Flowable.switchMapSingle
- Flowable.switchMapMaybe
- Flowable.switchMapCompletable
- Flowable.concatMapSingle
- Flowable.concatMapMaybe
- Flowable.concatMapCompletable
 =||= If it is not on the roadmap because you don't want to add any more xMap operators, then I understand.

But if it is due to lack of the time, would you consider accepting contributions on the topic?
 =||= Sure, but these operators are not easy.
 =||= Yes, I know, those are one of the hardest. 
Still, I will at least have a look and see if I can deliver a PR.

Cheers!
 =||= Any progress on this? =||= I'm happy to have a look at this one if @tomaszpolanski doesn't have time at the moment. =||= @davidmoten It would be great! My available time now is pretty limited.  =||= So the list of new operators is quite big. Currently:

* Observable.switchMapSingle
* Observable.switchMapMaybe
* Observable.switchMapCompletable
* Observable.concatMapSingle
* Observable.concatMapMaybe
* Observable.concatMapCompletable
* Flowable.switchMapSingle
* Flowable.switchMapMaybe
* Flowable.switchMapCompletable
* Flowable.concatMapSingle
* Flowable.concatMapMaybe
* Flowable.concatMapCompletable

I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one. An example would be `Observable.switchMapSingle`:

```java
public final <R> Observable<R> switchMapSingle(
    final Function<? super T, ? extends SingleSource<? extends R>> mapper) {
        Function<? super T, Observable<R>> mapper2 = t -> 
            {
                SingleSource<? extends R> source = mapper.apply(t);
                Single<? extends R> single;
                if (source instanceof Single) {
                    single = (Single<? extends R>) source;
                } else {
                    single = Single.unsafeCreate(source);
                }
               return (Observable<R>) single.toObservable();
            };
        return switchMap(mapper2, bufferSize());
    }
```

This is just to demo the idea, I wouldn't use an anonymous class and lambdas are just used for readability.

@akarnokd any interest in this?
 =||= > I imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one.

Indeed.

> An example would be

If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in `io.reactivex.internal.operators.flowable.FlowableInternalHelper` and its respective variants.

> any interest in this?

I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted. =||= >If you do this, there is an unwritten guideline that the main base types should have no (anonymous) inner classes. It helped me a lot before not having to deal with Flowable$1$2 and similar entries. The go-to place for these are in io.reactivex.internal.operators.flowable.FlowableInternalHelper and its respective variants.

Yep no problems. I've appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too.

>I'm more interested in the direct implementations but at least the overall usefullness of the API extension could be vetted.

Sure. I'll proceed with PRs with unit tests for the new operators and I'm happy to have a stab at dedicated operators after that. =||= What is expected behaviour for `Observable.switchMapMaybe` and `Observable.switchMapCompletable`? I can try to take care of it but I am not convinced what that method should return.
 =||= In the mean time, would it be correct to assume that an acceptable workaround for this is as follows?: **.toObservable()**

```
upstream.concatMap {
        someObservable().collect{...}.toObservable()
    }
``` =||= @feresr 
Probably yes, at this moment in few places inside my code i have this type of stucture. It is very weird and uncessesery code but it is understandable.
@akarnokd 
What do you think about method switchMapCompletable which emit Object or maybe some enum? On the other hand we can we can swallow information about stream and do not emit anything. =||= @marcinsus I don't fully understand your question. Use `switchMapCompletable().andThen(Single)` to emit something after the switch completed. =||= The problem he talks about is that switchMapCompletable does not exist. 

switchMapSingle returns an Observable of the Single type.

So technically switchMapCompletable should return Void. (Which it can't, because that has no instance.) So he asks if the signature should rather expose some `enum Nothing` or just an `Object` =||= An `Observable.switchMapCompletable` should return `Completable`. =||= You are right as `flatMapCompletable` returns a `Completable`.

But now I find it weird that 
`Observable.flatMapSingle<T>`returns an `Observable<T>`
but 
`Observable.flatMapCompletable` returns an `Completable`. =||= A stream of 5 elements flatMap'd to a stream of a single element still results in a stream of 5 elements. =||= I'm working on implementing `concatMapCompletable` across the reactive types.

I'm wondering if the library should also have implementations of
`concatMapDelayErrorCompletable`, `concatMapEagerCompletable`, `concatMapEagerDelayErrorCompletable`?


 =||= `concatMapEagerCompletable` is indistinguishable from `flatMapCompletable` because all sources run concurrently and their only output is a terminal event; no items have to be buffered until their turn. Also the `maxConcurrency == 1` gets you `concatMapCompletable` behavior. =||= Ahh yes that makes sense.  

So is there any reason to implement `concatMapCompletable` at all?  If so do you want it to just use flatMapCompletable() internally or should there be a new direct implementation (what I've been working on)? =||= Actually, `Observable.flatMapCompletable` doesn't have `maxConcurrency` overload thus there might be a reason to implement `concatMapCompletable`. =||= Ok I'll keep at it then =||= https://github.com/ReactiveX/RxJava/issues/4853#issuecomment-281541715

Did anything ever come of this?  =||= #5161 and #5649 added some operators. =||= So there are plans to implement the other operators, but not in any particular timeframe? =||= The listed operators can simply expressed with the existing default operators and `toObservable`/`toFlowable` in the lambda parameters. Unfortunately, very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function. Imagine, you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code. Kotlin's extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the RxJava library. The issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer, I'm not particularly interested myself in tackling these types of operators. =||= Closing via #5870, #5871, #5872, #5873, #5875. =||= ,0
5886,5882,Update the algorithm Observable.timeout(time) & timeout(selector),Update the `Observable.timeout(time)` and the `Observable.timeout(selectors)` operators to the more modern atomic index tracking algorithm and get rid of `ObserverFullArbiter` and `FullArbiterObserver`.

Their `Flowable` counterparts have been updated in #5661.,nan,0
5887,5881,Incorrect upstream management in window(Observable) and window(Callable),While working on coverage improvements, I've noticed `Flowable.window(Publisher<B>)` and `Flowable.window(Callable<Publisher<B>>)` (plus their `Observable` counterpart) manage the upstream incorrectly as they don't cancel it when both the main output and the current window have been cancelled.,nan,0
5888,5881,Incorrect upstream management in window(Observable) and window(Callable),While working on coverage improvements, I've noticed `Flowable.window(Publisher<B>)` and `Flowable.window(Callable<Publisher<B>>)` (plus their `Observable` counterpart) manage the upstream incorrectly as they don't cancel it when both the main output and the current window have been cancelled.,nan,0
5895,5894,2.x: buffer documentation incorrect for onError behaviour,The documentation for most `buffer` operators reads as follows:

> When the source ObservableSource completes or encounters an error, the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource.

This is incorrect; none of the `buffer` operators emit their buffer before propagating an error:

```
@Override
public void onError(Throwable t) {
    buffer = null;
    actual.onError(t);
}
```

Note that this documentation was fixed in 1.x in #3561 (this is effectively a duplicate of issue #3560).,nan,0
5904,5903,Flowable.singleOrError() does not signal an exception if followed by flatMapPublisher,The following code demonstrates the expected behavior of Flowable.singleOrError() (as I understand it):
```
Flowable.empty()
    .singleOrError()
    .blockingGet(); // NoSuchElementException is thrown, as expected
```
    
However, if singleOrError() is immediately followed by Single.flatMapPublisher(...), the exception is lost:
```
Flowable.empty()
    .singleOrError()
    .flatMapPublisher(Flowable::just)
    .blockingSubscribe(); // No exception is thrown
```
    
Strangely, if anything is done between Flowable.singleOrError() and Single.flatMapPublisher(...), the exception is thrown as expected:
```
Flowable.empty()
    .singleOrError()
    .map(x -> x)
    .flatMapPublisher(Flowable::just)
    .blockingSubscribe(); // NoSuchElementException is thrown, as expected
```
    
This is with RxJava 2.1.10 and Reactive Streams 1.0.2.,Thanks for reporting and sharing code to reproduce the issue. The bug is in `singleOrError` triggered by a conversion back to `toFlowable`. Fix posted in #5904. =||= ,0
5906,590,SerialSubscription is missing isUnsubscribed,public class SerialSubscription implements Subscription {
    @Override
    public void unsubscribe() {...}}
    public void setSubscription(final Subscription subscription) {...}  
    public Subscription getSubscription() {...}
}

http://msdn.microsoft.com/en-us/library/system.reactive.disposables.serialdisposable_properties(v=vs.103).aspx,Fixed in https://github.com/Netflix/RxJava/pull/593
 =||= ,0
5917,5868,1.x: groupBy with evicting map factory fix,I'm preparing a PR to fix a bug with the operator `groupBy` where an evicting map factory is specified.

The problem with the operator extends as far as the method signature. This is what it is now:
```java
<K, R> Observable<GroupedObservable<K, R>> groupBy(
    Func1<? super T, ? extends K> keySelector,
    Func1<? super T, ? extends R> elementSelector, 
    Func1<Action1<K>, Map<K, Object>> evictingMapFactory) 
```
This is what it should be (the only change is `Action1<K>` becomes `Action1<Object>`:
```java
<K, R> Observable<GroupedObservable<K, R>> groupBy(
    Func1<? super T, ? extends K> keySelector,
    Func1<? super T, ? extends R> elementSelector, 
    Func1<Action1<Object>, Map<K, Object>> evictingMapFactory) 
```
and the javadoc will be changed to indicate that the value from the map should be passed to the `Action1` and not the key.

This is a breaking change. How do we want this to happen?

I've got a few options:

* replace the method (breaking change, move to 1.4)
* replace the method (breaking change, move to 2.0, that will be confusing!)
* deprecate the existing method and add `groupByV2`
* deprecate the existing method and throw a `DontCallMeException` and add `groupByV2`
* remove the existing method and add `groupByV2`

Any ideas/preferences? I'm ready to go with the PR but just need to decide the change in the API.,Yeah, too bad it is marked stable in 1.x. Did somebody run into a signature problem?

Deprecation but it should remain operational. Also I'd call the new method `groupByEvictable` or something like it, no version in method names. =||= >Yeah, too bad it is marked stable in 1.x. Did somebody run into a signature problem?

Nope, I ran into a logic problem (that I created) while reviewing the old code for transfer to the new code. In short the operator uses the map to lookup an evicted GroupedObservable by key but if it has been evicted then you can't get the GroupedObservable to complete. I haven't looked closely at this yet and am not sure how the old tests were working but I'll report back on this.  The new 2.x method uses a map that is contracted to report evictions by value, not key. I imported the new 2.x tests into 1.x and two failed on 1.x till I applied the 2.x technique.

>Deprecation but it should remain operational. Also I'd call the new method groupByEvictable or something like it, no version in method names.

Deal. I'll deprecate and make sure the existing method doesn't do anything nasty (possible memory leak by not completing an evicted GroupedObservable) and I lean towards `groupByEvicting` for the new method. =||= Closing via #5917. =||= ,0
5923,5916,2.x: Javadoc syntax error,```
:javadoc
/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:6519: error: text not allowed in <dl> element
     * <dl>
           ^
/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:6552: error: text not allowed in <dl> element
     * <dl>
           ^
/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:5955: error: text not allowed in <dl> element
     * <dl>
           ^
/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:5984: error: text not allowed in <dl> element
     * <dl>
```,Is there any way to fail the build when those errors / warnings are present? =||= There is a property for it in [build.gradle](https://github.com/ReactiveX/RxJava/blob/2.x/build.gradle#L82). I'd leave it on not failing though. =||= ,0
5924,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
5928,592,SerialSubscription and SingleAssignementSubscription naming, Subscriptions in general,SerialSubscription has

private static final Subscription UNSUBSCRIBED = new Subscription() {

SingleAssignmentSubscription has

private static final Subscription SENTINEL = new Subscription() {

for the same purpose.

Also, these use lockfree implementations, the other subscriptions use locks.

Perhaps someone can go over all subscriptions and implement them in the same style and using the same naming conventions.,I have to rebase my Subscription changes anyway, so I'll do the renaming to UNSUBSCRIBED_SENTINEL.
 =||= I may help again to use lock free strategy in other subscription implementations.
 =||= @akarnod 

You should be able to have serialsubscription inherit from multipleassignmentsubscription. The difference is that the latter unsubscribes when swapping in a new subscription. I think that would show the intent better and make the code more maintanable.

In fact, I think MultipleAssignmentSubscription itself can inherit from BooleanSubscription.
 =||= I don't know. I can create many PRs for all kinds of variants, but at the end @benjchristensen has to decide; I'd rather avoid look-and-feel development.
 =||= ,0
5935,5934,1.x OperatorTake seem to swallow Exceptions,We have a Observable that is transformed into a Single. Some unrelated changes caused a Exception in the `onSuccess` Action of the Subscriber. This exception seems to get lost. It neither gets propagated to the `onError` Action, nor to the `RxJavaHooks.setOnError` Action.

Sample that reproduces the problem:

```java
RxJavaHooks.setOnError(error -> System.out.println("got global error " + error));
Observable.just("1")
        .first()
        .toSingle()
        .subscribe(
                it -> {
                    System.out.println("going to throw");
                    throw new NullPointerException("bla");
                },
                error -> System.out.println("got error " + error)
        );

// Output:

going to throw

Process finished with exit code 0
```

If I change the sample to this it does propagate the error (removed the `first()` call):
```java
RxJavaHooks.setOnError(error -> System.out.println("got global error " + error));
Observable.just("1")
        .toSingle()
        .subscribe(
                it -> {
                    System.out.println("going to throw");
                    throw new NullPointerException("bla");
                },
                error -> System.out.println("got error " + error)
        );

// Output

going to throw
got error java.lang.NullPointerException: bla

Process finished with exit code 0

```

This is what I found out while debugging.
Exception is caught here:
https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OnSubscribeLift.java#L49-L55

`st` is in this case the OperatorTake:
https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorTake.java#L60-L70
it is already `completed`. So the `Throwable` is just ignored.

Could be related/the same as #3571.,Hi and thanks for reporting. Indeed 1.x was not too keen on reporting undeliverable errors. I'll post a fix shortly but note that support for 1.x will end on March 31 with a final release. =||= This can be closed now. =||= ,0
5947,5933,2.x -- groupBy with evicting map -- seeing inconsistent behavior when eviction occurs,I am using version 2.1.11.  I'm seeing what I believe to be a bug in the groupBy operator when configured to use an evicting map.  Here is a test that demonstrates what I'm seeing:

```java
    private static class TestTicker extends Ticker {
        long tick = 0;

        @Override
        public long read() {
            return tick;
        }
    }
    
    @Test
    public void testGroupByEviction() {
        FlowableProcessor<Integer> source = PublishProcessor.create();
        TestSubscriber<Integer> subscriber1 = new TestSubscriber<>();
        TestTicker testTicker = new TestTicker();

        Function<Consumer<Object>, Map<Object, Object>> mapFactory = action -> {
            return CacheBuilder.newBuilder()
                    .expireAfterAccess(5, TimeUnit.SECONDS)
                    .removalListener(notification -> {
                        try {
                            action.accept(notification.getValue());
                        } catch (Exception ex) {
                            throw new RuntimeException(ex);
                        }
                    }).ticker(testTicker).build().asMap();
        };

        final List<String> list = Collections.synchronizedList(new ArrayList<String>());
        Flowable<Integer> stream = source.doOnCancel(() -> list.add("Source canceled"))
                .groupBy(v -> v, Functions.identity(), false, Flowable.bufferSize(), mapFactory)
                .flatMap(group -> {
            return group
                    .doOnComplete(() -> list.add("Group completed"))
                    .doOnCancel(() -> list.add("Group canceled"));
        });
        stream.doOnCancel(() -> list.add("Outer group by canceled.")).subscribe(subscriber1);
        
        // Send 3 in the same group and wait for them to be seen
        source.onNext(1);
        source.onNext(1);
        source.onNext(1);
        subscriber1.awaitCount(3);
        
        // Advance time far enough to evict the group.
        // NOTE -- Comment this line out to make the test "pass".
        testTicker.tick = TimeUnit.SECONDS.toNanos(6);
        
        // Send more data in the group (triggering eviction and recreation)
        source.onNext(1);
        source.onNext(1);

        // Wait for the last 2 and then cancel the subscription
        subscriber1.awaitCount(5);
        subscriber1.cancel();

        // Observe the result.  Note that right now the result differs depending on whether eviction occurred or
        // not.  The observed sequence in that case is:  Group completed, Outer group by canceled., Group canceled.
        // The addition of the "Group completed" is actually fine, but the fact that the cancel doesn't reach the
        // source seems like a bug.  Commenting out the setting of "tick" above will produce the "expected" sequence.
        assertEquals(Arrays.asList(
                // "Group completed", -- this is here when eviction occurs
                "Outer group by canceled.", 
                "Group canceled",
                "Source canceled"  // This is *not* here when eviction occurs
        ), list);
    }
```

As you can see from this when a group eviction occurs and the root subscription is canceled, the cancel dose not propagate beyond the `groupBy` (it does when there is no eviction).  I think the reason for this is that after the eviction processing (line 188 of FlowableGroupBy) the groupCount is 3 when I believe it should be 2).  This leads the groupBy to conclude that there are 2 active groups when the cancel occurs, when in fact there is only one.  This doesn't happen when there is no eviction (you can see this by commenting out the line that updates "tick").,Yes, looks like eviction only happens when an upstream item is coming down. I think the same eviction logic could be run in `cancel()` as well:

```java
        @Override
        public void cancel() {
            // cancelling the main source means we don't want any more groups
            // but running groups still require new values
            if (cancelled.compareAndSet(false, true)) {

                if (evictedGroups != null) {
                    GroupedUnicast<K, V> evictedGroup;
                    while ((evictedGroup = evictedGroups.poll()) != null) {
                        evictedGroup.onComplete();
                    }
                }

                if (groupCount.decrementAndGet() == 0) {
                    s.cancel();
                }
            }
        }
```

/cc @davidmoten  =||= Thanks for the report, I'll fix tomorrow =||= Sorry for the delay. I'll try to tackle this in the coming weeks. =||= ,0
5948,5944,Canceling an Observable in RxJava 2.x,**Observable.fromFuture**'s javadoc says "Unlike 1.x, cancelling the Observable won't cancel the future. If necessary, one can use composition to achieve the cancellation effect: futureObservableSource.doOnCancel(() -> future.cancel(true));."

Flowable has this method and it works as expected like this:

```
    Disposable disposable = Flowable.fromFuture(response, Schedulers.io())
      .doOnCancel(() -> response.cancel(true))
      .subscribe();
```

But Observable seems to lack **doOnCancel** method, doesn't it?
Tested RxJava's version is 2.1.10.,Its equivalent is doOnDispose. A copy-paste error. PR welcome. =||= Hello,
Does someone work on this topic? I would like to start contributing, can I do it? =||= @RomanWuattier You can start working on this. =||= Closing via #5948. =||= ,0
5972,5971,concatMapSingle ignores some onNext events,**Version used: 2.1.12**

I have a collection of interfaces. They all define a method fetching a collection of items: `Single<List<Integer>> fetchItems()`. 
Some of them perform local computations, others a network call. When concatening using `concatMapSingle`, some of the singles are not subscribed at all.

Here is a test I do think should pass. A network call is faked here using a timer. If the timer is replaced with `Single.just` instead, the test is passing.

```java
@Test
public void test() {
  TestScheduler testScheduler = new TestScheduler();

  final Single<List<Integer>> first = Single.timer(2, TimeUnit.SECONDS, testScheduler).map(u -> Arrays.asList(1, 2, 3));
  final Single<List<Integer>> second = Single.just(Collections.emptyList());
  final Single<List<Integer>> third = Single.just(Collections.singletonList(4));
  final Single<List<Integer>> fourth = Single.just(Collections.singletonList(5));

  Single<List<Integer>> subject = Observable
    .fromIterable(Arrays.asList(first, second, third, fourth))
    .concatMapSingle(single -> single)
    .reduce(new ArrayList<>(), (seed, items) -> {
      seed.addAll(items);
      return seed;
    });

    TestObserver<List<Integer>> testObserver = subject.test();
    testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);

    testObserver.assertValue(list -> list.equals(Arrays.asList(1, 2, 3, 4, 5))); 
    // 5 is currently missing ; fourth was never subscribed in the first place
}
```

*It is my first issue on this repo, feel free to edit my PR if I am not respecting the contribution guidelines.*,Hi and thanks for reporting. This is a bug in the `concatMapSingle` operator. I'll post a fix shortly. =||= Fix in #5972. =||= Thanks, appreciate it! =||= ,0
5979,4856,Conflate Operator,RxJava should have conflate operator. I see we have sample, debounce etc but actually they are not equivalent to conflate . 

Conflate operator should behave as Sample if updates are faster than the given interval. But if updates stops and new update comes after a long period it should push immediately. Instead of waiting for sampling period. ,Is the behavior your after equivalent to zip(stream, interval())? I too
want such an operator and I was about to file an issue tomorrow. It finally
hit my three separate use cases bar for wanting it to be first party.

On Tue, Nov 15, 2016, 7:06 PM MajorMud notifications@github.com wrote:

> RxJava should have conflate operator. I see we have sample, debounce etc
> but actually they are not equivalent to conflate .
> 
> Conflate operator should behave as Sample if updates are faster than the
> given interval. But if updates stops and new update comes after a long
> period it should push immediately. Instead of waiting for sampling period.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4856, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEd0LKzKaRnG1inDQ8dVB6VichZr9ks5q-nNQgaJpZM4KzS88
> .
 =||= Not sure how would you achieve with zip. 

sample at timeout out interval if source is emitting too fast but if source is slower than the timeout interval emit right away. 

O.O.O.O.O...............O 
--->-->-->-->-->-->-->-->
----X-------X-------------X 
 =||= Is `throttleFirst` closer to what you are looking for?

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.png)
 =||= throttleFirst drops events. I believe this doesn't want that. It's like "at
most" every X interval.

On Tue, Nov 15, 2016, 8:25 PM George Campbell notifications@github.com
wrote:

> Is throttleFirst closer to what you are looking for?
> 
> https://camo.githubusercontent.com/fe3f3d248d4933e30866c27188277684b24cbef8/68747470733a2f2f7261772e6769746875622e636f6d2f77696b692f5265616374697665582f52784a6176612f696d616765732f72782d6f70657261746f72732f7468726f74746c6546697273742e706e67
> 
> —
> You are receiving this because you commented.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4856#issuecomment-260850974,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEQHZBk0SiHGv1w-cS-l-XTh92gBaks5q-oWvgaJpZM4KzS88
> .
 =||= throttleLast/Sample is what i want if source is publishing too fast but then publish the item right away don't wait for the sample timeout if it was published slower than then timeout interval. 

took stab at this  

https://github.com/mrudangit/HelloRxJava/blob/master/src/main/java/com/solutionarchitects/Conflation.java
 =||= How about this?
![image](https://cloud.githubusercontent.com/assets/406038/20335040/e0c40332-ab73-11e6-9238-17bd9ff8cbbc.png)
 =||= For my case I would need green before the blues. If that's not conflate
I'll file a separate issue.

On Tue, Nov 15, 2016, 8:43 PM George Campbell notifications@github.com
wrote:

> How about this?
> [image: image]
> https://cloud.githubusercontent.com/assets/406038/20335040/e0c40332-ab73-11e6-9238-17bd9ff8cbbc.png
> 
> —
> You are receiving this because you commented.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4856#issuecomment-260852854,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEeugJuqKqFvD7OH2pRXgKPqcpkyfks5q-ooGgaJpZM4KzS88
> .
 =||= I was being lazy about the timing of the end of yellow's timeout and cyan's arrival. I was mostly trying to highlight that this is `throttleFirstAndLastButNotLastIfItIsTheSameAsTheFirst`
- red is not emitted twice
- blue is emitted at the end of cyan's interval
 =||= Red should output at the end of first period, Green at the end of 2nd period, dark blue at the end of 3rd period , not at the start of period as shown. How to generate diagram. probably can explain that way better 
 =||= Was I misinterpreting this statement?

> publish the item right away don't wait for the sample timeout

That seems to conflict with

> Red should output at the end of first period

The diagram source file is an OmniGraffle in the wiki repo `https://github.com/ReactiveX/RxJava.wiki.git` the file is `images/rx-operators.graffle`
 =||= ![image](https://cloud.githubusercontent.com/assets/3153622/20335764/4afb379c-ab93-11e6-8959-4ee36ccfd066.png)
 =||= If I understand correctly, you need a throttleFirst but instead of dropping the incoming values in the period, you'd want to keep the latest and emit it immediately once the period ends, starting a new period. What should happen if there is an active period plus a latest element is waiting and the main source completes?
 =||= emit the last one emitted before onComplete 
yes want to throttle first 
but if there is inactivity more than the throttle period
when source emits emit right away bcos we already waited more than the throttle periods

so in my diagram yellow is emitted right away even though it falls between the throttle period because it wait one full throttle period before 
 =||= I think this operator should go into [rxjava-extras](https://github.com/davidmoten/rxjava-extras)/[RxJava2Extensions](https://github.com/akarnokd/RxJava2Extensions) as it seems to address the needs of a small set of developers only and possibly introduce confusion with `throttleFirst`. I'm sure @davidmoten and I will accept such operator if contributed.
 =||= Yes makes sense happy to contribute any guidelines please share advise 
 =||= Just clone the respective repo, create a new branch, pick a package (`hu.akarnokd.rxjava2.operators` for RxJava2Extensions, `com.github.davidmoten.rx.internal.operators` for rxjava-extras) write the operator, create the pull request and we will review it.
 =||= i cloned created a local branch 'conflateOperator' 

try to push get error . 


remote: Permission to akarnokd/RxJava2Extensions.git denied to mrudangit.
fatal: unable to access 'https://github.com/akarnokd/RxJava2Extensions.git/': The requested URL returned error: 403

 =||= Push to your own repository. =||= pushed to 
https://github.com/mrudangit/RxJava2Conflate
 =||= Now if you go to my repo, you should see the create PR option. =||= @mrudangit, in your latest drawing, shouldn't green be emitted (immediately), and then dark-blue, and light-blue, and then purple (delayed)? =||= yes it can be looked that way also 
to convey intent i did that way but yes the first one should be output immediately and the. delay as per interval 

 =||= Did you mean this operator & behavior: [ObservableConflate.java](https://gist.github.com/akarnokd/98a1a728a89e6f8dbd1efab104c2be0f)? =||= nice. as per test looks what it should do . will take it to spin. is it with Rxjava2 ? =||= RxJava 1.x =||= I've been looking for a non-lagging rate-limiting operator like the one described here for a while now, and couldn't find it. So, after some collaboration with our in-house experts (including @JakeWharton and @loganj), we came up with a `compose`-transformer (tested with RxJava 1.2.3):

```
public static <T> Transformer<T, T> adaptiveSample(long time, TimeUnit unit, Scheduler scheduler) {
  return source -> source
      .publish(shared -> concat(
          shared.take(1),
          shared.sample(time, unit, scheduler))
          .repeatWhen(a -> shared.debounce(time, unit, scheduler)));
}
```

This must be the most natural rate-limiting operator, because at any given moment of time it's as close to the source observable as possible, given the restriction of the rate-limiting time period. For example (time period == 4 chars):

```
source: -1-2-3-45------6-7-8-
output: -1---3---5-----6---8-
```

Notice how it emits immediately after a period of quiet, and then continues to sample while source is emitting at high rate. Thus, there is no unnecessary lag, as it "adapts" the sampling to the source, hence the name.

It could be used to rate-limit UI updates of an "unread message count", or to limit frequency of metadata refresh requests to server. Basically, it's what most people expect when they start looking at `sample`, `throttle`, `throttleFirst`, and similar operators.. which unfortunately do not work too well in real-world scenarios.

@mrudangit - could you try it and see if it works for you? =||= @valeriyo  looks good in testing. noticed one thing if i have more than 1 subscribers they are not getting same values. some get one published before etc.  in conflation done on publish side all the subscribers should get the same conflated output . 

@akarnokd  I am not able to compile in Java 8 / intellij .  =||= @mrudangit what is the compiler's error message? =||= I see. Oddly, Eclipse didn't complain. I have updated the gist. =||= I get this error. 
Error:(45, 17) java: name clash: call(rx.Subscriber<? super T>) in com.xxx.. overrides a method whose erasure is the same as another method, yet neither overrides the other
  first method:  call(T) in rx.functions.Func1
  second method: call(T) in rx.functions.Action1 =||= I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one. =||= I built my 3rd instance of this for a project (next time i'm stealing David's gist!). It seems to come up a lot when building UIs. You want to be notified immediately and then no frequently than X, unless more than X has passed in which case the next notification should be immediate. This is especially true as we have a lot of sources for UI which emit synchronously upon subscribe and then connect to some asynchronously updating source.

Sometimes I just compromise and do a `take(1)` and `throttleLast` merged despite it slowing down the async data.

I'm all for keeping RxJava small. There's plenty of custom one-off custom or composite operators I've had to build that I wouldn't want in the main lib. This one seems like it could make the cut for general applicability. I was able to find 2 other people in 10 minutes who had written versions of this (aside from the two others in this thread and me).

I'm not sure how we would determine whether or not something like this makes the cut. For me, it can be thought of as a variant of existing operators rather than something wildly new, it can't be created as a composite operator with acceptibly-low overhead (Valeriy's solution works, but it allocates quite a bit), and the use case seems non-rare (based on a small sample, no pun intended).

Would love to hear what others think. =||= Hi @JakeWharton,

Thanks for bringing this issue back to life :)

In my opinion, none of the built-in throttling operators are usable "as is" for many common tasks (including updating UI):
  * `throttleFirst` has no latency, but loses trailing items;
  * `throttleLast` has latency, and it's lossy w.r.t very last item;
  * `sample` has latency;
  * `debounce` has latency, and suffers from "starvation".

The middle two operators also maintain a "ticking" timer, which would wake up and re-schedule each and every interval, even if there is nothing to emit... hence, wasteful with bursty streams of events.

For these reasons, my opinion is that it would be way better to have one rate-limiting operator, which works (no latency, not lossy, no starvation, no unnecessary ticking timer) than have 4+ flawed ones ;)

Heck, it took me weeks, if not months to 1) realize that none of the built-in operators do what I want, 2) formulate the desired behavior, 3) search for solution online, give up, then consult, implement, and test - it shouldn't be so difficult!

By the way, here is the revised version, without `repeatWhen` (per #5414):
```
public static <T> Transformer<T, T> adaptiveSample(long time, TimeUnit unit, Scheduler scheduler) {
  return source -> source
      .publish(shared -> shared
          .debounce(time, unit, scheduler)
          .map(a -> 0)
          .startWith(0)
          .switchMap(a -> concat(shared.take(1), shared.sample(time, unit, scheduler))));
}
```

Regarding naming, I'm not sure that "conflate" is a good name... it's short, but it doesn't convey the meaning well enough. Maybe "rateLimit" or "naturalSample"... something more easily understandable?

Thanks for reading. =||= This is a bit old issue and I can't remember the exact pattern expected here. I guess we can add this to RxJava. For discoverability, I'd name it `throttleAndSample` so it appears along with the other `throttleX` operators. =||= ,0
6005,6004,2.x: Odd JavaDoc formatting,Since we switched to Java 8 compilation, the generated JavaDocs often lists method arguments misaligned, for example:

http://reactivex.io/RxJava/2.x/javadoc/snapshot/io/reactivex/flowables/ConnectableFlowable.html#refCount-long-java.util.concurrent.TimeUnit-

![image](https://user-images.githubusercontent.com/1269832/39810638-0647a292-5386-11e8-9656-28b2a23061bd.png)

Looks like the whole section is put into `<pre>` so those extra spaces break the layout:

```html
<pre><a href="../../../io/reactivex/annotations/CheckReturnValue.html" title="annotation in io.reactivex.annotations">@CheckReturnValue</a>
 <a href="../../../io/reactivex/annotations/SchedulerSupport.html" title="annotation in io.reactivex.annotations">@SchedulerSupport</a>(<a href="../../../io/reactivex/annotations/SchedulerSupport.html#value--">value</a>="io.reactivex:computation")
 <a href="../../../io/reactivex/annotations/BackpressureSupport.html" title="annotation in io.reactivex.annotations">@BackpressureSupport</a>(<a href="../../../io/reactivex/annotations/BackpressureSupport.html#value--">value</a>=<a href="../../../io/reactivex/annotations/BackpressureKind.html#PASS_THROUGH">PASS_THROUGH</a>)
public final&nbsp;<a href="../../../io/reactivex/Flowable.html" title="class in io.reactivex">Flowable</a>&lt;<a href="../../../io/reactivex/flowables/ConnectableFlowable.html" title="type parameter in ConnectableFlowable">T</a>&gt;&nbsp;refCount(long&nbsp;timeout,
                                                                                                                                                   <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html?is-external=true" title="class or interface in java.util.concurrent">TimeUnit</a>&nbsp;unit)</pre>
```

I wonder if it would be possible to avoid those.,Found this old post on SO: https://stackoverflow.com/q/30062846/61158 =||= ,0
6014,6012,Stops Integer boxing via null checks in Observable.concatEager,Replaces with verifyPositive as in other similar methods.

This seems to be a trivial change and makes this more consistent with other areas of the code. Let me know if it needs its own issue or any specific tests. Given the methods only accept primitive ints, and passing a null Integer would throw a runtime exception, I'm not sure there's anything needed outside of the already present testing.,# [Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/6012?src=pr&el=h1) Report
> Merging [#6012](https://codecov.io/gh/ReactiveX/RxJava/pull/6012?src=pr&el=desc) into [2.x](https://codecov.io/gh/ReactiveX/RxJava/commit/5f1ce20a1159a8464bfae2d8b2106039ac520eb2?src=pr&el=desc) will **decrease** coverage by `0.02%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/graphs/tree.svg?width=650&token=WtCc2hTjM2&height=150&src=pr)](https://codecov.io/gh/ReactiveX/RxJava/pull/6012?src=pr&el=tree)

```diff
@@             Coverage Diff              @@
##                2.x    #6012      +/-   ##
============================================
- Coverage     98.28%   98.26%   -0.03%     
+ Complexity     6161     6159       -2     
============================================
  Files           659      659              
  Lines         44522    44522              
  Branches       6201     6201              
============================================
- Hits          43757    43748       -9     
+ Misses          233      231       -2     
- Partials        532      543      +11
```


| [Impacted Files](https://codecov.io/gh/ReactiveX/RxJava/pull/6012?src=pr&el=tree) | Coverage Δ | Complexity Δ | |
|---|---|---|---|
| [src/main/java/io/reactivex/Observable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvT2JzZXJ2YWJsZS5qYXZh) | `100% <100%> (ø)` | `539 <2> (ø)` | :arrow_down: |
| [...l/operators/observable/ObservableFlatMapMaybe.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBNYXliZS5qYXZh) | `84.96% <0%> (-5.89%)` | `2% <0%> (ø)` | |
| [.../io/reactivex/internal/schedulers/IoScheduler.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9Jb1NjaGVkdWxlci5qYXZh) | `89.24% <0%> (-3.23%)` | `9% <0%> (ø)` | |
| [...rnal/operators/flowable/FlowableFlatMapSingle.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2Zsb3dhYmxlL0Zsb3dhYmxlRmxhdE1hcFNpbmdsZS5qYXZh) | `92.93% <0%> (-2.72%)` | `2% <0%> (ø)` | |
| [...tivex/internal/schedulers/TrampolineScheduler.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvc2NoZWR1bGVycy9UcmFtcG9saW5lU2NoZWR1bGVyLmphdmE=) | `96.1% <0%> (-2.6%)` | `6% <0%> (ø)` | |
| [...ternal/operators/completable/CompletableMerge.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbXBsZXRhYmxlL0NvbXBsZXRhYmxlTWVyZ2UuamF2YQ==) | `96.42% <0%> (-2.39%)` | `2% <0%> (ø)` | |
| [...a/io/reactivex/internal/util/QueueDrainHelper.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvdXRpbC9RdWV1ZURyYWluSGVscGVyLmphdmE=) | `97.91% <0%> (-2.09%)` | `56% <0%> (-2%)` | |
| [.../internal/disposables/ListCompositeDisposable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvZGlzcG9zYWJsZXMvTGlzdENvbXBvc2l0ZURpc3Bvc2FibGUuamF2YQ==) | `98% <0%> (-2%)` | `34% <0%> (-1%)` | |
| [.../io/reactivex/disposables/CompositeDisposable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvZGlzcG9zYWJsZXMvQ29tcG9zaXRlRGlzcG9zYWJsZS5qYXZh) | `98.14% <0%> (-1.86%)` | `39% <0%> (-1%)` | |
| [.../operators/observable/ObservableFlatMapSingle.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmFibGUvT2JzZXJ2YWJsZUZsYXRNYXBTaW5nbGUuamF2YQ==) | `90.29% <0%> (-1.5%)` | `2% <0%> (ø)` | |
| ... and [23 more](https://codecov.io/gh/ReactiveX/RxJava/pull/6012/diff?src=pr&el=tree-more) | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/6012?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/6012?src=pr&el=footer). Last update [5f1ce20...ed02bbf](https://codecov.io/gh/ReactiveX/RxJava/pull/6012?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= There is already a reflection based range check for the base classes so these null checks can be simply removed; the delegated calls should perform the verifyPositive calls already too. =||= Thanks for contribution. I've posted a broader solution to this problem in #6014. =||= ,0
6014,601,Version 0.16.0 Release Candidate,Following are the changes and release notes for 0.16.0. Since so much has changed for this release I want to give people a chance to review and try the code before releasing.

Changes:

---
### Version 0.16.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.16.0%22))
- [Pull 516](https://github.com/Netflix/RxJava/pull/516) rxjava-string module with StringObservable
- [Pull 533](https://github.com/Netflix/RxJava/pull/533) Operator: ToAsync
- [Pull 535](https://github.com/Netflix/RxJava/pull/535) Fix compilation errors due to referencing the Android support library directly
- [Pull 545](https://github.com/Netflix/RxJava/pull/545) Fixed Zip issue with infinite streams
- [Pull 539](https://github.com/Netflix/RxJava/pull/539) Zipping a finite and an infinite Observable
- [Pull 541](https://github.com/Netflix/RxJava/pull/541) Operator: SkipUntil
- [Pull 537](https://github.com/Netflix/RxJava/pull/537) Add scala adapters for doOnEach operator
- [Pull 560](https://github.com/Netflix/RxJava/pull/560) Add type variances for doOnEach actions
- [Pull 562](https://github.com/Netflix/RxJava/pull/562) Scala Adaptor Improvements
- [Pull 563](https://github.com/Netflix/RxJava/pull/563) Operator: GroupByUntil
- [Pull 561](https://github.com/Netflix/RxJava/pull/561) Revised Approach to Creating Observables in Scala
- [Pull 565](https://github.com/Netflix/RxJava/pull/565) Operator: GroupJoin v2
- [Pull 567](https://github.com/Netflix/RxJava/pull/567) Operator: Timestamp with Scheduler
- [Pull 568](https://github.com/Netflix/RxJava/pull/568) Use lock free strategy for several Subscription implementations
- [Pull 571](https://github.com/Netflix/RxJava/pull/571) Operator: Sample with Observable v2
- [Pull 572](https://github.com/Netflix/RxJava/pull/572) Multiple Subscriptions to ObserveOn
- [Pull 573](https://github.com/Netflix/RxJava/pull/573) Removed Opening and Closing historical artifacts
- [Pull 575](https://github.com/Netflix/RxJava/pull/575) Operator: SequenceEqual reimplementation
- [Pull 587](https://github.com/Netflix/RxJava/pull/587) Operator: LongCount
- [Pull 586](https://github.com/Netflix/RxJava/pull/586) Fix Concat to allow multiple observers
- [Pull 598](https://github.com/Netflix/RxJava/pull/598) New Scala Bindings
- [Pull 596](https://github.com/Netflix/RxJava/pull/596) Fix for buffer not stopping when unsubscribed
- [Pull 576](https://github.com/Netflix/RxJava/pull/576) Operators: Timer and Delay
- [Pull 593](https://github.com/Netflix/RxJava/pull/593) Lock-free subscriptions
- [Pull 599](https://github.com/Netflix/RxJava/pull/599) Refactor rx.concurrency to rx.schedulers
- [Pull 600](https://github.com/Netflix/RxJava/pull/600) BugFix: Replay Subject
- [Pull 594](https://github.com/Netflix/RxJava/pull/594) Operator: Start
- [Pull 604](https://github.com/Netflix/RxJava/pull/604) StringObservable.join
- [Pull 609](https://github.com/Netflix/RxJava/pull/609) Operation: Timer
- [Pull 612](https://github.com/Netflix/RxJava/pull/612) Operation: Replay (overloads)
- [Pull 628](https://github.com/Netflix/RxJava/pull/628) BugFix: MergeDelayError Synchronization
- [Pull 602](https://github.com/Netflix/RxJava/pull/602) BugFix: ObserveOn Subscription leak
- [Pull 631](https://github.com/Netflix/RxJava/pull/631) Make NewThreadScheduler create Daemon threads
- [Pull 651](https://github.com/Netflix/RxJava/pull/651) Subjects Refactor - Non-Blocking, Common Abstraction, Performance
- [Pull 661](https://github.com/Netflix/RxJava/pull/661) Subscriptions Rewrite
- [Pull 520](https://github.com/Netflix/RxJava/pull/520) BugFix: blocking/non-blocking `first`
- [Pull 621](https://github.com/Netflix/RxJava/pull/621) Scala: SerialSubscription & From
- [Pull 626](https://github.com/Netflix/RxJava/pull/626) BO.Latest, fixed: BO.next, BO.mostRecent, BO.toIterable
- [Pull 633](https://github.com/Netflix/RxJava/pull/633) BugFix: null in toList operator
- [Pull 635](https://github.com/Netflix/RxJava/pull/635) Conditional Operators
- [Pull 638](https://github.com/Netflix/RxJava/pull/638) Operations: DelaySubscription, TakeLast w/ time, TakeLastBuffer
- [Pull 659](https://github.com/Netflix/RxJava/pull/659) Missing fixes from the subject rewrite
- [Pull 688](https://github.com/Netflix/RxJava/pull/688) Fix SafeObserver handling of onComplete errors
- [Pull 690](https://github.com/Netflix/RxJava/pull/690) Fixed Scala bindings
- [Pull 693](https://github.com/Netflix/RxJava/pull/693) Kotlin M6.2
- [Pull 689](https://github.com/Netflix/RxJava/pull/689) Removed ObserverBase
- [Pull 664](https://github.com/Netflix/RxJava/pull/664) Operation: AsObservable
- [Pull 697](https://github.com/Netflix/RxJava/pull/697) Operations: Skip, SkipLast, Take with time
- [Pull 698](https://github.com/Netflix/RxJava/pull/698) Operations: Average, Sum
- [Pull 699](https://github.com/Netflix/RxJava/pull/699) Operation: Repeat
- [Pull 701](https://github.com/Netflix/RxJava/pull/701) Operation: Collect
- [Pull 707](https://github.com/Netflix/RxJava/pull/707) Module: rxjava-async-util
- [Pull 708](https://github.com/Netflix/RxJava/pull/708) BugFix: combineLatest
- [Pull 712](https://github.com/Netflix/RxJava/pull/712) Fix Scheduler Memory Leaks
- [Pull 714](https://github.com/Netflix/RxJava/pull/714) Module: rxjava-computation-expressions
- [Pull 715](https://github.com/Netflix/RxJava/pull/715) Add missing type hint to clojure example
- [Pull 717](https://github.com/Netflix/RxJava/pull/717) Scala: Added ConnectableObservable
- [Pull 723](https://github.com/Netflix/RxJava/pull/723) Deprecate multiple arity ‘from’
- [Pull 724](https://github.com/Netflix/RxJava/pull/724) Revert use of CurrentThreadScheduler for Observable.from
- [Pull 725](https://github.com/Netflix/RxJava/pull/725) Simpler computation/io naming for Schedulers
- [Pull 727](https://github.com/Netflix/RxJava/pull/727) ImmediateScheduler optimization for toObservableIterable

---
- This release includes breaking changes to Scala bindings. Details are below.
- The `rx.concurrency` package has been renamed to `rx.schedulers`. Existing classes still remain in `rx.concurrency` but are deprecated. Use of `rx.concurrency` should be migrated to `rx.schedulers` as these deprecated classes will be removed in a future release.
- Refactor of Subjects and Subscriptions to non-blocking implementations
- Many bug fixes, new operators and behavior changes to match Rx.Net.
- Deprecation of some operators due to renaming or eliminating duplicates
- New modules: rxjava-string, rxjava-async-util and rxjava-computation-expressions for operators deemed not applicable to the core library.

---
### Scala Release Notes

---

This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala
include all Rx types. In particular this release focuses on fleshing out the bindings for the `Subject` and `Scheduler`
types, as well as aligning the constructor functions for `Observable` with those in the RxJava.

Expect to see ongoing additions to make the Scala binding match the equivalent underlying Java API,
as well as minor changes in the existing API as we keep fine-tuning the experience on our way to a V1.0 release.
## Observer

In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the
companion object that takes an `rx.Observer` private to the Scala bindings package, thus properly hiding irrelevant
implementation details from the user-facing API. The `Observer[T]` trait now looks like a clean, native Scala type:

``` scala
trait Observer[-T] {
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def onCompleted(): Unit
}

object Observer {...}
```

To create an instance of a specific `Observer`, say  `Observer[SensorEvent]` in user code, you can create a new instance
of the `Observer` trait by implementing any of the methods that you care about:

``` scala
   val printObserver = new Observer[SensorEvent] {
      override def onNext(value: SensorEvent): Unit = {...value.toString...}
   }
```

 or you can use one of the overloads of the companion `Observer` object by passing in implementations of the `onNext`,
 `onError` or `onCompleted` methods.

Note that typically you do not need to create an `Observer` since all of the methods that accept an `Observer[T]`
(for instance `subscribe`) usually come with overloads that accept the individual methods
`onNext`, `onError`, and `onCompleted` and will automatically create an `Observer` for you under the covers.

While _technically_ it is a breaking change make the `asJavaObserver` property private, you should probably not have
touched `asJavaObserver` in the first place. If you really feel you need to access the underlying `rx.Observer`
call `toJava`.
## Observable

Just like for `Observer`, the `Observable` trait now also hides its `asJavaObservable` property and makes the constructor
function in the companion object that takes an `rx.Observable` private (but leaves the companion object itself public).
Again, while _technically_ this is a breaking change, this should not have any influence on user code.

``` scala
trait Observable[+T] {
    def subscribe(observer: Observer[T]): Subscription = {...}
    def apply(observer: Observer[T]): Subscription = {...}
    ...
}
object Observable {
   def create[T](func: Observer[T] => Subscription): Observable[T] = {...}
   ...
}
```

The major changes in `Observable` are wrt to the factory methods where too libral use of overloading of the `apply`
method hindered type inference and made Scala code look unnecessarily different than that in other language bindings.
All factory methods now have their own name corresponding to the Java and .NET operators
(plus overloads that take a `Scheduler`).
- `def from[T](future: Future[T]): Observable[T]`,
- `def from[T](iterable: Iterable[T]): Observable[T]`,
- `def error[T](exception: Throwable): Observable[T]`,
- `def empty[T]: Observable[T]`,
- `def items[T](items: T*): Observable[T],
- Extension method on `toObservable: Observable[T]` on `List[T]`.

In the _pre-release_ of this version, we expose both `apply` and `create` for the mother of all creation functions.
We would like to solicit feedback which of these two names is preferred
(or both, but there is a high probability that only one will be chosen).
- `def apply[T](subscribe: Observer[T]=>Subscription): Observable[T]`
- `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`
## Subject

The `Subject` trait now also hides the underlying Java `asJavaSubject: rx.subjects.Subject[_ >: T, _<: T]`
and takes only a single _invariant_ type parameter `T`. all existing implementations of `Subject` are parametrized
by a single type, and this reflects that reality.

``` scala
trait Subject[T] extends Observable[T] with Observer[T] {}
object Subject {
   def apply(): Subject[T] = {...}
}
```

For each kind of subject, there is a class with a private constructor and a companion object that you should use
to create a new kind of subject. The subjects that are available are:
- `AsyncSubject[T]()`,
- `BehaviorSubject[T](value)`,
- `Subject[T]()`,
- `ReplaySubject[T]()`.

The latter is still missing various overloads http://msdn.microsoft.com/en-us/library/hh211810(v=vs.103).aspx which
you can expect to appear once they are added to the underlying RxJava implementation.

Compared with release 0.15.1, the breaking changes in `Subject` for this release are
making `asJavaSubject` private, and collapsing its type parameters, neither of these should cause trouble,
and renaming `PublishSubject` to `Subject`.
## Schedulers

The biggest breaking change compared to the 0.15.1 release is giving `Scheduler` the same structure as the other types.
The trait itself remains unchanged, except that we made the underlying Java representation hidden as above.
as part of this reshuffling, the scheduler package has been renamed from `rx.lang.scala.concurrency`
to `rx.lang.scala.schedulers`. There is a high probability that this package renaming will also happen in RxJava.

``` scala
trait Scheduler {...}
```

In the previous release, you created schedulers by selecting them from the `Schedulers` object,
as in `Schedulers.immediate` or `Schedulers.newThread` where each would return an instance of the `Scheduler` trait.
However, several of the scheduler implementations have additional methods, such as the `TestScheduler`,
which already deviated from the pattern.

In this release, we changed this to make scheduler more like `Subject` and provide a family of schedulers
that you create using their factory function:
- `CurrentThreadScheduler()`,
- `ExecutorScheduler(executor)`,
- `ImmediateScheduler()`,
- `NewThreadScheduler()`,
- `ScheduledExecutorServiceScheduler(scheduledExecutorService)`,
- `TestScheduler()`,
- `ThreadPoolForComputationScheduler()`,
- `ThreadPoolForIOScheduler()`.

In the future we expect that this list will grow further with new schedulers as they are imported from .NET
(http://msdn.microsoft.com/en-us/library/system.reactive.concurrency(v=vs.103).aspx).

To make your code compile in the new release you will have to change all occurrences of `Schedulers.xxx`
into `XxxScheduler()`, and import `rx.lang.scala.schedulers` instead of `rx.lang.scala.schedulers`.
## Subscriptions

The `Subscription` trait in Scala now has `isUnsubscribed` as a member, effectively collapsing the old `Subscription`
and `BooleanSubscription`, and the latter has been removed from the public surface. Pending a bug fix in RxJava,
`SerialSubscription` implements its own `isUnsubscribed`.

``` scala
trait Subscription {
  def unsubscribe(): Unit = { ... }
  def isUnsubscribed: Boolean = ...
}

object Subscription {...}
```

 To create a `Subscription` use one of the following factory methods:
- `Subscription{...}`, `Subscription()`,
- `CompositeSubscription(subscriptions)`,
- `MultipleAssignmentSubscription()`,
- `SerialSubscription()`.
  
  In case you do feel tempted to call `new Subscription{...}` directly make sure you wire up `isUnsubscribed`
  and `unsubscribe()` properly, but for all practical purposes you should just use one of the factory methods.
## Notifications

All underlying wrapped `Java` types in the `Notification` trait are made private like all previous types. The companion
objects of `Notification` now have both constructor (`apply`) and extractor (`unapply`) functions:

``` scala
object Notification {...}
trait Notification[+T] {
   override def equals(that: Any): Boolean = {...}
   override def hashCode(): Int = {...}
   def apply[R](onNext: T=>R, onError: Throwable=>R, onCompleted: ()=>R): R = {...}
}
```

The nested companion objects of `Notification` now have both constructor (`apply`) and extractor (`unapply`) functions:

``` scala
object Notification {
   object OnNext { def apply(...){}; def unapply(...){...} }
   object OnError { def apply(...){}; def unapply(...){...} }
   object OnCompleted { def apply(...){}; def unapply(...){...} }
}
```

To construct a `Notification`, you import `rx.lang.scala.Notification._` and use `OnNext("hello")`,
or `OnError(new Exception("Oops!"))`, or `OnCompleted()`.

To pattern match on a notification you create a partial function like so: `case Notification.OnNext(v) => { ... v ... }`,
or you use the `apply` function to pass in functions for each possibility.

There are no breaking changes for notifications.
## Java Interop Helpers

Since the Scala traits _wrap_ the underlying Java types, yoo may occasionally will have to wrap an unwrap
between the two representations. The `JavaConversion` object provides helper functions of the form `toJavaXXX` and
`toScalaXXX` for this purpose, properly hiding how precisely the wrapped types are stored.
Note the (un)wrap conversions are defined as implicits in Scala, but in the unlikely event that you do need them
be kind to the reader of your code and call them explicitly.

``` scala
object JavaConversions {
  import language.implicitConversions

  implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <: T] = {...}
  implicit def toScalaNotification[T](s: rx.Notification[_ <: T]): Notification[T] = {...}
  implicit def toJavaSubscription(s: Subscription): rx.Subscription = {...}
  implicit def toScalaSubscription(s: rx.Subscription): Subscription = {...}
  implicit def scalaSchedulerToJavaScheduler(s: Scheduler): rx.Scheduler = {...}
  implicit def javaSchedulerToScalaScheduler(s: rx.Scheduler): Scheduler = {...}
  implicit def toJavaObserver[T](s: Observer[T]): rx.Observer[_ >: T] = {...}
  implicit def toScalaObserver[T](s: rx.Observer[_ >: T]): Observer[T] = {...}
  implicit def toJavaObservable[T](s: Observable[T]): rx.Observable[_ <: T] = {...}
  implicit def toScalaObservable[T](observable: rx.Observable[_ <: T]): Observable[T] = {...}
}
```,Items of discussion or that I would like to resolve before releasing:
- [ ] `ReplaySubject` has a different style from other `Subject` implementations. I'm not tied to either approach, nor am I sure that the idea of an `AbstractSubject` was the right way to go. 
- [ ] I'm not convinced that `Subject` implementations have correct thread-safety or concurrency behavior. For example, we synchronize on subscriptions but not event emission and I'm not sure whether that means we're vulnerable to losing events or not.
- [x] Yet more `observeOn` fixes/tweaks are needed. 
- [ ] I'd like to eliminate the `rx.util` dumping ground
  - [ ] Put exceptions into `rx.exceptions` or `rx.util.exceptions`?
  - [ ] Put functions into `rx.functions` or `rx.util.functions`?
  - [ ] Where does Range go? TimeInterval? Timestamped? perhaps in `rx.observables`?
  - [x] Why is Timestamped not camelCase whereas TimeInterval is?
- [ ] Should AbstractSubject be public? I think it should be package private, particularly as I don't necessarily agree with the approach (even though I wrote it).
- [ ] For consistency should we have `rx.operators` with classes named `OperatorXYZ` or `rx.operations` and classes named `OperationXYZ`?
- [ ] ObserverBase needs to be package private or moved into a non-advertised package like `rx.operators`
 =||= > Why is Timestamped not camelCase whereas TimeInterval is?

Because `timestamp` is a single word, like `java.sql.Timestamp`?
 =||= ObserveOn fixes: https://github.com/Netflix/RxJava/pull/602
 =||= > Because timestamp is a single word, like java.sql.Timestamp?

I guess you're right. Never mind :-)
 =||= I've looked at the `Subject` implementations and they seem to be incorrect due to the following reasons:
- the `AbstractSubject` allows the concurrent execution of onNext and onError/onCompleted calls, i.e, the emitNotification doesn't lock on `SUBSCRIPTION_LOCK`.
- `PublishSubject`, `AsyncSubject` and `BehaviorSubject` seem to overwrite the last notification value even after the termination condition as the call `state.currentValue.set(new Notification<T>(...));` is always executed in the subjects onXXX methods regardless of the state. New subscribers may observe various states when subscribing.
 =||= > the AbstractSubject allows the concurrent execution of onNext and onError/onCompleted calls

All of Rx allows this as it is up to the provider to obey the contract and not call them concurrently. That is why we don't  synchronize everything in Rx, for performance reasons.
 =||= Rx Design Guideline 6.8

> 6.8. Avoid serializing operators
> 
> As all Rx operators are bound to guideline 6.7, operators can safely assume that their inputs are serialized. Adding too much synchronization would clutter the code and can lead to performance degradation.
> 
> If an observable sequence is not following the Rx contract (see chapter 0), it is up to the developer writing the end-user application to fix the observable sequence by calling the Synchronize operator at the first place the developer gets a hold of the observable sequence. This way the scope of additional synchronization is limited to where it is needed.

Due to this, a `Subject` implementation should not need to synchronize `onNext`/`onCompleted`/`onError` calls. They do need to handle `subscribe`/`unsubscribe` concurrent access. 

It is however tricky to achieve both of these since we want to ensure we don't have race-conditions in observers subscribing and seeing the correct view of events. That said, we don't want to add unnecessary synchronization.

For example, on `PublishSubject` it is completely fine during a concurrent race between `onNext` and `subscribe` that it may or may not get that `onNext` event. That's the nature of concurrently subscribing to a hot `Observable`. 

We don't want to pay the overhead of synchronization on `onNext` just so that occasional `subscribe` events can occur.
 =||= /cc @akarnokd @headinthebox @zsxwing I am ready to release 0.16.0 after running it on a Netflix API production canary to assert performance and functionality of the core operators, schedulers, etc (at least of what we use, not new operators).

I'm blocked on a build issue that I can't solve until tomorrow at the office so will release sometime Tuesday hopefully.
 =||= ,0
6019,601,Version 0.16.0 Release Candidate,Following are the changes and release notes for 0.16.0. Since so much has changed for this release I want to give people a chance to review and try the code before releasing.

Changes:

---
### Version 0.16.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.16.0%22))
- [Pull 516](https://github.com/Netflix/RxJava/pull/516) rxjava-string module with StringObservable
- [Pull 533](https://github.com/Netflix/RxJava/pull/533) Operator: ToAsync
- [Pull 535](https://github.com/Netflix/RxJava/pull/535) Fix compilation errors due to referencing the Android support library directly
- [Pull 545](https://github.com/Netflix/RxJava/pull/545) Fixed Zip issue with infinite streams
- [Pull 539](https://github.com/Netflix/RxJava/pull/539) Zipping a finite and an infinite Observable
- [Pull 541](https://github.com/Netflix/RxJava/pull/541) Operator: SkipUntil
- [Pull 537](https://github.com/Netflix/RxJava/pull/537) Add scala adapters for doOnEach operator
- [Pull 560](https://github.com/Netflix/RxJava/pull/560) Add type variances for doOnEach actions
- [Pull 562](https://github.com/Netflix/RxJava/pull/562) Scala Adaptor Improvements
- [Pull 563](https://github.com/Netflix/RxJava/pull/563) Operator: GroupByUntil
- [Pull 561](https://github.com/Netflix/RxJava/pull/561) Revised Approach to Creating Observables in Scala
- [Pull 565](https://github.com/Netflix/RxJava/pull/565) Operator: GroupJoin v2
- [Pull 567](https://github.com/Netflix/RxJava/pull/567) Operator: Timestamp with Scheduler
- [Pull 568](https://github.com/Netflix/RxJava/pull/568) Use lock free strategy for several Subscription implementations
- [Pull 571](https://github.com/Netflix/RxJava/pull/571) Operator: Sample with Observable v2
- [Pull 572](https://github.com/Netflix/RxJava/pull/572) Multiple Subscriptions to ObserveOn
- [Pull 573](https://github.com/Netflix/RxJava/pull/573) Removed Opening and Closing historical artifacts
- [Pull 575](https://github.com/Netflix/RxJava/pull/575) Operator: SequenceEqual reimplementation
- [Pull 587](https://github.com/Netflix/RxJava/pull/587) Operator: LongCount
- [Pull 586](https://github.com/Netflix/RxJava/pull/586) Fix Concat to allow multiple observers
- [Pull 598](https://github.com/Netflix/RxJava/pull/598) New Scala Bindings
- [Pull 596](https://github.com/Netflix/RxJava/pull/596) Fix for buffer not stopping when unsubscribed
- [Pull 576](https://github.com/Netflix/RxJava/pull/576) Operators: Timer and Delay
- [Pull 593](https://github.com/Netflix/RxJava/pull/593) Lock-free subscriptions
- [Pull 599](https://github.com/Netflix/RxJava/pull/599) Refactor rx.concurrency to rx.schedulers
- [Pull 600](https://github.com/Netflix/RxJava/pull/600) BugFix: Replay Subject
- [Pull 594](https://github.com/Netflix/RxJava/pull/594) Operator: Start
- [Pull 604](https://github.com/Netflix/RxJava/pull/604) StringObservable.join
- [Pull 609](https://github.com/Netflix/RxJava/pull/609) Operation: Timer
- [Pull 612](https://github.com/Netflix/RxJava/pull/612) Operation: Replay (overloads)
- [Pull 628](https://github.com/Netflix/RxJava/pull/628) BugFix: MergeDelayError Synchronization
- [Pull 602](https://github.com/Netflix/RxJava/pull/602) BugFix: ObserveOn Subscription leak
- [Pull 631](https://github.com/Netflix/RxJava/pull/631) Make NewThreadScheduler create Daemon threads
- [Pull 651](https://github.com/Netflix/RxJava/pull/651) Subjects Refactor - Non-Blocking, Common Abstraction, Performance
- [Pull 661](https://github.com/Netflix/RxJava/pull/661) Subscriptions Rewrite
- [Pull 520](https://github.com/Netflix/RxJava/pull/520) BugFix: blocking/non-blocking `first`
- [Pull 621](https://github.com/Netflix/RxJava/pull/621) Scala: SerialSubscription & From
- [Pull 626](https://github.com/Netflix/RxJava/pull/626) BO.Latest, fixed: BO.next, BO.mostRecent, BO.toIterable
- [Pull 633](https://github.com/Netflix/RxJava/pull/633) BugFix: null in toList operator
- [Pull 635](https://github.com/Netflix/RxJava/pull/635) Conditional Operators
- [Pull 638](https://github.com/Netflix/RxJava/pull/638) Operations: DelaySubscription, TakeLast w/ time, TakeLastBuffer
- [Pull 659](https://github.com/Netflix/RxJava/pull/659) Missing fixes from the subject rewrite
- [Pull 688](https://github.com/Netflix/RxJava/pull/688) Fix SafeObserver handling of onComplete errors
- [Pull 690](https://github.com/Netflix/RxJava/pull/690) Fixed Scala bindings
- [Pull 693](https://github.com/Netflix/RxJava/pull/693) Kotlin M6.2
- [Pull 689](https://github.com/Netflix/RxJava/pull/689) Removed ObserverBase
- [Pull 664](https://github.com/Netflix/RxJava/pull/664) Operation: AsObservable
- [Pull 697](https://github.com/Netflix/RxJava/pull/697) Operations: Skip, SkipLast, Take with time
- [Pull 698](https://github.com/Netflix/RxJava/pull/698) Operations: Average, Sum
- [Pull 699](https://github.com/Netflix/RxJava/pull/699) Operation: Repeat
- [Pull 701](https://github.com/Netflix/RxJava/pull/701) Operation: Collect
- [Pull 707](https://github.com/Netflix/RxJava/pull/707) Module: rxjava-async-util
- [Pull 708](https://github.com/Netflix/RxJava/pull/708) BugFix: combineLatest
- [Pull 712](https://github.com/Netflix/RxJava/pull/712) Fix Scheduler Memory Leaks
- [Pull 714](https://github.com/Netflix/RxJava/pull/714) Module: rxjava-computation-expressions
- [Pull 715](https://github.com/Netflix/RxJava/pull/715) Add missing type hint to clojure example
- [Pull 717](https://github.com/Netflix/RxJava/pull/717) Scala: Added ConnectableObservable
- [Pull 723](https://github.com/Netflix/RxJava/pull/723) Deprecate multiple arity ‘from’
- [Pull 724](https://github.com/Netflix/RxJava/pull/724) Revert use of CurrentThreadScheduler for Observable.from
- [Pull 725](https://github.com/Netflix/RxJava/pull/725) Simpler computation/io naming for Schedulers
- [Pull 727](https://github.com/Netflix/RxJava/pull/727) ImmediateScheduler optimization for toObservableIterable

---
- This release includes breaking changes to Scala bindings. Details are below.
- The `rx.concurrency` package has been renamed to `rx.schedulers`. Existing classes still remain in `rx.concurrency` but are deprecated. Use of `rx.concurrency` should be migrated to `rx.schedulers` as these deprecated classes will be removed in a future release.
- Refactor of Subjects and Subscriptions to non-blocking implementations
- Many bug fixes, new operators and behavior changes to match Rx.Net.
- Deprecation of some operators due to renaming or eliminating duplicates
- New modules: rxjava-string, rxjava-async-util and rxjava-computation-expressions for operators deemed not applicable to the core library.

---
### Scala Release Notes

---

This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala
include all Rx types. In particular this release focuses on fleshing out the bindings for the `Subject` and `Scheduler`
types, as well as aligning the constructor functions for `Observable` with those in the RxJava.

Expect to see ongoing additions to make the Scala binding match the equivalent underlying Java API,
as well as minor changes in the existing API as we keep fine-tuning the experience on our way to a V1.0 release.
## Observer

In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the
companion object that takes an `rx.Observer` private to the Scala bindings package, thus properly hiding irrelevant
implementation details from the user-facing API. The `Observer[T]` trait now looks like a clean, native Scala type:

``` scala
trait Observer[-T] {
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def onCompleted(): Unit
}

object Observer {...}
```

To create an instance of a specific `Observer`, say  `Observer[SensorEvent]` in user code, you can create a new instance
of the `Observer` trait by implementing any of the methods that you care about:

``` scala
   val printObserver = new Observer[SensorEvent] {
      override def onNext(value: SensorEvent): Unit = {...value.toString...}
   }
```

 or you can use one of the overloads of the companion `Observer` object by passing in implementations of the `onNext`,
 `onError` or `onCompleted` methods.

Note that typically you do not need to create an `Observer` since all of the methods that accept an `Observer[T]`
(for instance `subscribe`) usually come with overloads that accept the individual methods
`onNext`, `onError`, and `onCompleted` and will automatically create an `Observer` for you under the covers.

While _technically_ it is a breaking change make the `asJavaObserver` property private, you should probably not have
touched `asJavaObserver` in the first place. If you really feel you need to access the underlying `rx.Observer`
call `toJava`.
## Observable

Just like for `Observer`, the `Observable` trait now also hides its `asJavaObservable` property and makes the constructor
function in the companion object that takes an `rx.Observable` private (but leaves the companion object itself public).
Again, while _technically_ this is a breaking change, this should not have any influence on user code.

``` scala
trait Observable[+T] {
    def subscribe(observer: Observer[T]): Subscription = {...}
    def apply(observer: Observer[T]): Subscription = {...}
    ...
}
object Observable {
   def create[T](func: Observer[T] => Subscription): Observable[T] = {...}
   ...
}
```

The major changes in `Observable` are wrt to the factory methods where too libral use of overloading of the `apply`
method hindered type inference and made Scala code look unnecessarily different than that in other language bindings.
All factory methods now have their own name corresponding to the Java and .NET operators
(plus overloads that take a `Scheduler`).
- `def from[T](future: Future[T]): Observable[T]`,
- `def from[T](iterable: Iterable[T]): Observable[T]`,
- `def error[T](exception: Throwable): Observable[T]`,
- `def empty[T]: Observable[T]`,
- `def items[T](items: T*): Observable[T],
- Extension method on `toObservable: Observable[T]` on `List[T]`.

In the _pre-release_ of this version, we expose both `apply` and `create` for the mother of all creation functions.
We would like to solicit feedback which of these two names is preferred
(or both, but there is a high probability that only one will be chosen).
- `def apply[T](subscribe: Observer[T]=>Subscription): Observable[T]`
- `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`
## Subject

The `Subject` trait now also hides the underlying Java `asJavaSubject: rx.subjects.Subject[_ >: T, _<: T]`
and takes only a single _invariant_ type parameter `T`. all existing implementations of `Subject` are parametrized
by a single type, and this reflects that reality.

``` scala
trait Subject[T] extends Observable[T] with Observer[T] {}
object Subject {
   def apply(): Subject[T] = {...}
}
```

For each kind of subject, there is a class with a private constructor and a companion object that you should use
to create a new kind of subject. The subjects that are available are:
- `AsyncSubject[T]()`,
- `BehaviorSubject[T](value)`,
- `Subject[T]()`,
- `ReplaySubject[T]()`.

The latter is still missing various overloads http://msdn.microsoft.com/en-us/library/hh211810(v=vs.103).aspx which
you can expect to appear once they are added to the underlying RxJava implementation.

Compared with release 0.15.1, the breaking changes in `Subject` for this release are
making `asJavaSubject` private, and collapsing its type parameters, neither of these should cause trouble,
and renaming `PublishSubject` to `Subject`.
## Schedulers

The biggest breaking change compared to the 0.15.1 release is giving `Scheduler` the same structure as the other types.
The trait itself remains unchanged, except that we made the underlying Java representation hidden as above.
as part of this reshuffling, the scheduler package has been renamed from `rx.lang.scala.concurrency`
to `rx.lang.scala.schedulers`. There is a high probability that this package renaming will also happen in RxJava.

``` scala
trait Scheduler {...}
```

In the previous release, you created schedulers by selecting them from the `Schedulers` object,
as in `Schedulers.immediate` or `Schedulers.newThread` where each would return an instance of the `Scheduler` trait.
However, several of the scheduler implementations have additional methods, such as the `TestScheduler`,
which already deviated from the pattern.

In this release, we changed this to make scheduler more like `Subject` and provide a family of schedulers
that you create using their factory function:
- `CurrentThreadScheduler()`,
- `ExecutorScheduler(executor)`,
- `ImmediateScheduler()`,
- `NewThreadScheduler()`,
- `ScheduledExecutorServiceScheduler(scheduledExecutorService)`,
- `TestScheduler()`,
- `ThreadPoolForComputationScheduler()`,
- `ThreadPoolForIOScheduler()`.

In the future we expect that this list will grow further with new schedulers as they are imported from .NET
(http://msdn.microsoft.com/en-us/library/system.reactive.concurrency(v=vs.103).aspx).

To make your code compile in the new release you will have to change all occurrences of `Schedulers.xxx`
into `XxxScheduler()`, and import `rx.lang.scala.schedulers` instead of `rx.lang.scala.schedulers`.
## Subscriptions

The `Subscription` trait in Scala now has `isUnsubscribed` as a member, effectively collapsing the old `Subscription`
and `BooleanSubscription`, and the latter has been removed from the public surface. Pending a bug fix in RxJava,
`SerialSubscription` implements its own `isUnsubscribed`.

``` scala
trait Subscription {
  def unsubscribe(): Unit = { ... }
  def isUnsubscribed: Boolean = ...
}

object Subscription {...}
```

 To create a `Subscription` use one of the following factory methods:
- `Subscription{...}`, `Subscription()`,
- `CompositeSubscription(subscriptions)`,
- `MultipleAssignmentSubscription()`,
- `SerialSubscription()`.
  
  In case you do feel tempted to call `new Subscription{...}` directly make sure you wire up `isUnsubscribed`
  and `unsubscribe()` properly, but for all practical purposes you should just use one of the factory methods.
## Notifications

All underlying wrapped `Java` types in the `Notification` trait are made private like all previous types. The companion
objects of `Notification` now have both constructor (`apply`) and extractor (`unapply`) functions:

``` scala
object Notification {...}
trait Notification[+T] {
   override def equals(that: Any): Boolean = {...}
   override def hashCode(): Int = {...}
   def apply[R](onNext: T=>R, onError: Throwable=>R, onCompleted: ()=>R): R = {...}
}
```

The nested companion objects of `Notification` now have both constructor (`apply`) and extractor (`unapply`) functions:

``` scala
object Notification {
   object OnNext { def apply(...){}; def unapply(...){...} }
   object OnError { def apply(...){}; def unapply(...){...} }
   object OnCompleted { def apply(...){}; def unapply(...){...} }
}
```

To construct a `Notification`, you import `rx.lang.scala.Notification._` and use `OnNext("hello")`,
or `OnError(new Exception("Oops!"))`, or `OnCompleted()`.

To pattern match on a notification you create a partial function like so: `case Notification.OnNext(v) => { ... v ... }`,
or you use the `apply` function to pass in functions for each possibility.

There are no breaking changes for notifications.
## Java Interop Helpers

Since the Scala traits _wrap_ the underlying Java types, yoo may occasionally will have to wrap an unwrap
between the two representations. The `JavaConversion` object provides helper functions of the form `toJavaXXX` and
`toScalaXXX` for this purpose, properly hiding how precisely the wrapped types are stored.
Note the (un)wrap conversions are defined as implicits in Scala, but in the unlikely event that you do need them
be kind to the reader of your code and call them explicitly.

``` scala
object JavaConversions {
  import language.implicitConversions

  implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <: T] = {...}
  implicit def toScalaNotification[T](s: rx.Notification[_ <: T]): Notification[T] = {...}
  implicit def toJavaSubscription(s: Subscription): rx.Subscription = {...}
  implicit def toScalaSubscription(s: rx.Subscription): Subscription = {...}
  implicit def scalaSchedulerToJavaScheduler(s: Scheduler): rx.Scheduler = {...}
  implicit def javaSchedulerToScalaScheduler(s: rx.Scheduler): Scheduler = {...}
  implicit def toJavaObserver[T](s: Observer[T]): rx.Observer[_ >: T] = {...}
  implicit def toScalaObserver[T](s: rx.Observer[_ >: T]): Observer[T] = {...}
  implicit def toJavaObservable[T](s: Observable[T]): rx.Observable[_ <: T] = {...}
  implicit def toScalaObservable[T](observable: rx.Observable[_ <: T]): Observable[T] = {...}
}
```,Items of discussion or that I would like to resolve before releasing:
- [ ] `ReplaySubject` has a different style from other `Subject` implementations. I'm not tied to either approach, nor am I sure that the idea of an `AbstractSubject` was the right way to go. 
- [ ] I'm not convinced that `Subject` implementations have correct thread-safety or concurrency behavior. For example, we synchronize on subscriptions but not event emission and I'm not sure whether that means we're vulnerable to losing events or not.
- [x] Yet more `observeOn` fixes/tweaks are needed. 
- [ ] I'd like to eliminate the `rx.util` dumping ground
  - [ ] Put exceptions into `rx.exceptions` or `rx.util.exceptions`?
  - [ ] Put functions into `rx.functions` or `rx.util.functions`?
  - [ ] Where does Range go? TimeInterval? Timestamped? perhaps in `rx.observables`?
  - [x] Why is Timestamped not camelCase whereas TimeInterval is?
- [ ] Should AbstractSubject be public? I think it should be package private, particularly as I don't necessarily agree with the approach (even though I wrote it).
- [ ] For consistency should we have `rx.operators` with classes named `OperatorXYZ` or `rx.operations` and classes named `OperationXYZ`?
- [ ] ObserverBase needs to be package private or moved into a non-advertised package like `rx.operators`
 =||= > Why is Timestamped not camelCase whereas TimeInterval is?

Because `timestamp` is a single word, like `java.sql.Timestamp`?
 =||= ObserveOn fixes: https://github.com/Netflix/RxJava/pull/602
 =||= > Because timestamp is a single word, like java.sql.Timestamp?

I guess you're right. Never mind :-)
 =||= I've looked at the `Subject` implementations and they seem to be incorrect due to the following reasons:
- the `AbstractSubject` allows the concurrent execution of onNext and onError/onCompleted calls, i.e, the emitNotification doesn't lock on `SUBSCRIPTION_LOCK`.
- `PublishSubject`, `AsyncSubject` and `BehaviorSubject` seem to overwrite the last notification value even after the termination condition as the call `state.currentValue.set(new Notification<T>(...));` is always executed in the subjects onXXX methods regardless of the state. New subscribers may observe various states when subscribing.
 =||= > the AbstractSubject allows the concurrent execution of onNext and onError/onCompleted calls

All of Rx allows this as it is up to the provider to obey the contract and not call them concurrently. That is why we don't  synchronize everything in Rx, for performance reasons.
 =||= Rx Design Guideline 6.8

> 6.8. Avoid serializing operators
> 
> As all Rx operators are bound to guideline 6.7, operators can safely assume that their inputs are serialized. Adding too much synchronization would clutter the code and can lead to performance degradation.
> 
> If an observable sequence is not following the Rx contract (see chapter 0), it is up to the developer writing the end-user application to fix the observable sequence by calling the Synchronize operator at the first place the developer gets a hold of the observable sequence. This way the scope of additional synchronization is limited to where it is needed.

Due to this, a `Subject` implementation should not need to synchronize `onNext`/`onCompleted`/`onError` calls. They do need to handle `subscribe`/`unsubscribe` concurrent access. 

It is however tricky to achieve both of these since we want to ensure we don't have race-conditions in observers subscribing and seeing the correct view of events. That said, we don't want to add unnecessary synchronization.

For example, on `PublishSubject` it is completely fine during a concurrent race between `onNext` and `subscribe` that it may or may not get that `onNext` event. That's the nature of concurrently subscribing to a hot `Observable`. 

We don't want to pay the overhead of synchronization on `onNext` just so that occasional `subscribe` events can occur.
 =||= /cc @akarnokd @headinthebox @zsxwing I am ready to release 0.16.0 after running it on a Netflix API production canary to assert performance and functionality of the core operators, schedulers, etc (at least of what we use, not new operators).

I'm blocked on a build issue that I can't solve until tomorrow at the office so will release sometime Tuesday hopefully.
 =||= ,0
6021,6015,Single.flatMapPublisher full implementation,I noticed `Single.flatMapPublisher` is implemented as `toFlowable().flatMapPublisher(...)` which subjects the one flowable to batched requests. I'd like to have requests go straight through to the one flowable. Can I contribute this operator?

The operator at the moment is at https://github.com/davidmoten/rxjava2-http/blob/master/src/main/java/org/davidmoten/rx2/io/internal/FlowableSingleFlatMapPublisher.java without fusion. I can add more tests, fusion (transitive as per `doOnEach`) and follow the projects's naming and visibility conventions.,Sure. =||= In case you haven't started yet, you may want to wait for #6017 so the changes can be benchmarked. =||= That's brilliant, thanks =||= A question about fusion. I notice that `timeout(Long, TimeUnit)` doesn't support fusion and I suspect the operator I'm writing is similar. The problem is that a subscription is handed to downstream while the Single emission is being calculated and the resultant mapped Flowable is unknown. Just after the subscription is handed to downstream (via `onSubscribe`) `requestFusion` is called but of course at that point the fusion characteristics of the mapped Flowable is unknown and `QueueFuseable.NONE` is returned. 

Should I chase fusion for this operator? Any suggestions?  =||= Fusion won't work here due to the delayed subscription to the Flowable. Don't bother with it. =||= Righto, ta. =||= ,0
6021,601,Version 0.16.0 Release Candidate,Following are the changes and release notes for 0.16.0. Since so much has changed for this release I want to give people a chance to review and try the code before releasing.

Changes:

---
### Version 0.16.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.16.0%22))
- [Pull 516](https://github.com/Netflix/RxJava/pull/516) rxjava-string module with StringObservable
- [Pull 533](https://github.com/Netflix/RxJava/pull/533) Operator: ToAsync
- [Pull 535](https://github.com/Netflix/RxJava/pull/535) Fix compilation errors due to referencing the Android support library directly
- [Pull 545](https://github.com/Netflix/RxJava/pull/545) Fixed Zip issue with infinite streams
- [Pull 539](https://github.com/Netflix/RxJava/pull/539) Zipping a finite and an infinite Observable
- [Pull 541](https://github.com/Netflix/RxJava/pull/541) Operator: SkipUntil
- [Pull 537](https://github.com/Netflix/RxJava/pull/537) Add scala adapters for doOnEach operator
- [Pull 560](https://github.com/Netflix/RxJava/pull/560) Add type variances for doOnEach actions
- [Pull 562](https://github.com/Netflix/RxJava/pull/562) Scala Adaptor Improvements
- [Pull 563](https://github.com/Netflix/RxJava/pull/563) Operator: GroupByUntil
- [Pull 561](https://github.com/Netflix/RxJava/pull/561) Revised Approach to Creating Observables in Scala
- [Pull 565](https://github.com/Netflix/RxJava/pull/565) Operator: GroupJoin v2
- [Pull 567](https://github.com/Netflix/RxJava/pull/567) Operator: Timestamp with Scheduler
- [Pull 568](https://github.com/Netflix/RxJava/pull/568) Use lock free strategy for several Subscription implementations
- [Pull 571](https://github.com/Netflix/RxJava/pull/571) Operator: Sample with Observable v2
- [Pull 572](https://github.com/Netflix/RxJava/pull/572) Multiple Subscriptions to ObserveOn
- [Pull 573](https://github.com/Netflix/RxJava/pull/573) Removed Opening and Closing historical artifacts
- [Pull 575](https://github.com/Netflix/RxJava/pull/575) Operator: SequenceEqual reimplementation
- [Pull 587](https://github.com/Netflix/RxJava/pull/587) Operator: LongCount
- [Pull 586](https://github.com/Netflix/RxJava/pull/586) Fix Concat to allow multiple observers
- [Pull 598](https://github.com/Netflix/RxJava/pull/598) New Scala Bindings
- [Pull 596](https://github.com/Netflix/RxJava/pull/596) Fix for buffer not stopping when unsubscribed
- [Pull 576](https://github.com/Netflix/RxJava/pull/576) Operators: Timer and Delay
- [Pull 593](https://github.com/Netflix/RxJava/pull/593) Lock-free subscriptions
- [Pull 599](https://github.com/Netflix/RxJava/pull/599) Refactor rx.concurrency to rx.schedulers
- [Pull 600](https://github.com/Netflix/RxJava/pull/600) BugFix: Replay Subject
- [Pull 594](https://github.com/Netflix/RxJava/pull/594) Operator: Start
- [Pull 604](https://github.com/Netflix/RxJava/pull/604) StringObservable.join
- [Pull 609](https://github.com/Netflix/RxJava/pull/609) Operation: Timer
- [Pull 612](https://github.com/Netflix/RxJava/pull/612) Operation: Replay (overloads)
- [Pull 628](https://github.com/Netflix/RxJava/pull/628) BugFix: MergeDelayError Synchronization
- [Pull 602](https://github.com/Netflix/RxJava/pull/602) BugFix: ObserveOn Subscription leak
- [Pull 631](https://github.com/Netflix/RxJava/pull/631) Make NewThreadScheduler create Daemon threads
- [Pull 651](https://github.com/Netflix/RxJava/pull/651) Subjects Refactor - Non-Blocking, Common Abstraction, Performance
- [Pull 661](https://github.com/Netflix/RxJava/pull/661) Subscriptions Rewrite
- [Pull 520](https://github.com/Netflix/RxJava/pull/520) BugFix: blocking/non-blocking `first`
- [Pull 621](https://github.com/Netflix/RxJava/pull/621) Scala: SerialSubscription & From
- [Pull 626](https://github.com/Netflix/RxJava/pull/626) BO.Latest, fixed: BO.next, BO.mostRecent, BO.toIterable
- [Pull 633](https://github.com/Netflix/RxJava/pull/633) BugFix: null in toList operator
- [Pull 635](https://github.com/Netflix/RxJava/pull/635) Conditional Operators
- [Pull 638](https://github.com/Netflix/RxJava/pull/638) Operations: DelaySubscription, TakeLast w/ time, TakeLastBuffer
- [Pull 659](https://github.com/Netflix/RxJava/pull/659) Missing fixes from the subject rewrite
- [Pull 688](https://github.com/Netflix/RxJava/pull/688) Fix SafeObserver handling of onComplete errors
- [Pull 690](https://github.com/Netflix/RxJava/pull/690) Fixed Scala bindings
- [Pull 693](https://github.com/Netflix/RxJava/pull/693) Kotlin M6.2
- [Pull 689](https://github.com/Netflix/RxJava/pull/689) Removed ObserverBase
- [Pull 664](https://github.com/Netflix/RxJava/pull/664) Operation: AsObservable
- [Pull 697](https://github.com/Netflix/RxJava/pull/697) Operations: Skip, SkipLast, Take with time
- [Pull 698](https://github.com/Netflix/RxJava/pull/698) Operations: Average, Sum
- [Pull 699](https://github.com/Netflix/RxJava/pull/699) Operation: Repeat
- [Pull 701](https://github.com/Netflix/RxJava/pull/701) Operation: Collect
- [Pull 707](https://github.com/Netflix/RxJava/pull/707) Module: rxjava-async-util
- [Pull 708](https://github.com/Netflix/RxJava/pull/708) BugFix: combineLatest
- [Pull 712](https://github.com/Netflix/RxJava/pull/712) Fix Scheduler Memory Leaks
- [Pull 714](https://github.com/Netflix/RxJava/pull/714) Module: rxjava-computation-expressions
- [Pull 715](https://github.com/Netflix/RxJava/pull/715) Add missing type hint to clojure example
- [Pull 717](https://github.com/Netflix/RxJava/pull/717) Scala: Added ConnectableObservable
- [Pull 723](https://github.com/Netflix/RxJava/pull/723) Deprecate multiple arity ‘from’
- [Pull 724](https://github.com/Netflix/RxJava/pull/724) Revert use of CurrentThreadScheduler for Observable.from
- [Pull 725](https://github.com/Netflix/RxJava/pull/725) Simpler computation/io naming for Schedulers
- [Pull 727](https://github.com/Netflix/RxJava/pull/727) ImmediateScheduler optimization for toObservableIterable

---
- This release includes breaking changes to Scala bindings. Details are below.
- The `rx.concurrency` package has been renamed to `rx.schedulers`. Existing classes still remain in `rx.concurrency` but are deprecated. Use of `rx.concurrency` should be migrated to `rx.schedulers` as these deprecated classes will be removed in a future release.
- Refactor of Subjects and Subscriptions to non-blocking implementations
- Many bug fixes, new operators and behavior changes to match Rx.Net.
- Deprecation of some operators due to renaming or eliminating duplicates
- New modules: rxjava-string, rxjava-async-util and rxjava-computation-expressions for operators deemed not applicable to the core library.

---
### Scala Release Notes

---

This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala
include all Rx types. In particular this release focuses on fleshing out the bindings for the `Subject` and `Scheduler`
types, as well as aligning the constructor functions for `Observable` with those in the RxJava.

Expect to see ongoing additions to make the Scala binding match the equivalent underlying Java API,
as well as minor changes in the existing API as we keep fine-tuning the experience on our way to a V1.0 release.
## Observer

In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the
companion object that takes an `rx.Observer` private to the Scala bindings package, thus properly hiding irrelevant
implementation details from the user-facing API. The `Observer[T]` trait now looks like a clean, native Scala type:

``` scala
trait Observer[-T] {
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def onCompleted(): Unit
}

object Observer {...}
```

To create an instance of a specific `Observer`, say  `Observer[SensorEvent]` in user code, you can create a new instance
of the `Observer` trait by implementing any of the methods that you care about:

``` scala
   val printObserver = new Observer[SensorEvent] {
      override def onNext(value: SensorEvent): Unit = {...value.toString...}
   }
```

 or you can use one of the overloads of the companion `Observer` object by passing in implementations of the `onNext`,
 `onError` or `onCompleted` methods.

Note that typically you do not need to create an `Observer` since all of the methods that accept an `Observer[T]`
(for instance `subscribe`) usually come with overloads that accept the individual methods
`onNext`, `onError`, and `onCompleted` and will automatically create an `Observer` for you under the covers.

While _technically_ it is a breaking change make the `asJavaObserver` property private, you should probably not have
touched `asJavaObserver` in the first place. If you really feel you need to access the underlying `rx.Observer`
call `toJava`.
## Observable

Just like for `Observer`, the `Observable` trait now also hides its `asJavaObservable` property and makes the constructor
function in the companion object that takes an `rx.Observable` private (but leaves the companion object itself public).
Again, while _technically_ this is a breaking change, this should not have any influence on user code.

``` scala
trait Observable[+T] {
    def subscribe(observer: Observer[T]): Subscription = {...}
    def apply(observer: Observer[T]): Subscription = {...}
    ...
}
object Observable {
   def create[T](func: Observer[T] => Subscription): Observable[T] = {...}
   ...
}
```

The major changes in `Observable` are wrt to the factory methods where too libral use of overloading of the `apply`
method hindered type inference and made Scala code look unnecessarily different than that in other language bindings.
All factory methods now have their own name corresponding to the Java and .NET operators
(plus overloads that take a `Scheduler`).
- `def from[T](future: Future[T]): Observable[T]`,
- `def from[T](iterable: Iterable[T]): Observable[T]`,
- `def error[T](exception: Throwable): Observable[T]`,
- `def empty[T]: Observable[T]`,
- `def items[T](items: T*): Observable[T],
- Extension method on `toObservable: Observable[T]` on `List[T]`.

In the _pre-release_ of this version, we expose both `apply` and `create` for the mother of all creation functions.
We would like to solicit feedback which of these two names is preferred
(or both, but there is a high probability that only one will be chosen).
- `def apply[T](subscribe: Observer[T]=>Subscription): Observable[T]`
- `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`
## Subject

The `Subject` trait now also hides the underlying Java `asJavaSubject: rx.subjects.Subject[_ >: T, _<: T]`
and takes only a single _invariant_ type parameter `T`. all existing implementations of `Subject` are parametrized
by a single type, and this reflects that reality.

``` scala
trait Subject[T] extends Observable[T] with Observer[T] {}
object Subject {
   def apply(): Subject[T] = {...}
}
```

For each kind of subject, there is a class with a private constructor and a companion object that you should use
to create a new kind of subject. The subjects that are available are:
- `AsyncSubject[T]()`,
- `BehaviorSubject[T](value)`,
- `Subject[T]()`,
- `ReplaySubject[T]()`.

The latter is still missing various overloads http://msdn.microsoft.com/en-us/library/hh211810(v=vs.103).aspx which
you can expect to appear once they are added to the underlying RxJava implementation.

Compared with release 0.15.1, the breaking changes in `Subject` for this release are
making `asJavaSubject` private, and collapsing its type parameters, neither of these should cause trouble,
and renaming `PublishSubject` to `Subject`.
## Schedulers

The biggest breaking change compared to the 0.15.1 release is giving `Scheduler` the same structure as the other types.
The trait itself remains unchanged, except that we made the underlying Java representation hidden as above.
as part of this reshuffling, the scheduler package has been renamed from `rx.lang.scala.concurrency`
to `rx.lang.scala.schedulers`. There is a high probability that this package renaming will also happen in RxJava.

``` scala
trait Scheduler {...}
```

In the previous release, you created schedulers by selecting them from the `Schedulers` object,
as in `Schedulers.immediate` or `Schedulers.newThread` where each would return an instance of the `Scheduler` trait.
However, several of the scheduler implementations have additional methods, such as the `TestScheduler`,
which already deviated from the pattern.

In this release, we changed this to make scheduler more like `Subject` and provide a family of schedulers
that you create using their factory function:
- `CurrentThreadScheduler()`,
- `ExecutorScheduler(executor)`,
- `ImmediateScheduler()`,
- `NewThreadScheduler()`,
- `ScheduledExecutorServiceScheduler(scheduledExecutorService)`,
- `TestScheduler()`,
- `ThreadPoolForComputationScheduler()`,
- `ThreadPoolForIOScheduler()`.

In the future we expect that this list will grow further with new schedulers as they are imported from .NET
(http://msdn.microsoft.com/en-us/library/system.reactive.concurrency(v=vs.103).aspx).

To make your code compile in the new release you will have to change all occurrences of `Schedulers.xxx`
into `XxxScheduler()`, and import `rx.lang.scala.schedulers` instead of `rx.lang.scala.schedulers`.
## Subscriptions

The `Subscription` trait in Scala now has `isUnsubscribed` as a member, effectively collapsing the old `Subscription`
and `BooleanSubscription`, and the latter has been removed from the public surface. Pending a bug fix in RxJava,
`SerialSubscription` implements its own `isUnsubscribed`.

``` scala
trait Subscription {
  def unsubscribe(): Unit = { ... }
  def isUnsubscribed: Boolean = ...
}

object Subscription {...}
```

 To create a `Subscription` use one of the following factory methods:
- `Subscription{...}`, `Subscription()`,
- `CompositeSubscription(subscriptions)`,
- `MultipleAssignmentSubscription()`,
- `SerialSubscription()`.
  
  In case you do feel tempted to call `new Subscription{...}` directly make sure you wire up `isUnsubscribed`
  and `unsubscribe()` properly, but for all practical purposes you should just use one of the factory methods.
## Notifications

All underlying wrapped `Java` types in the `Notification` trait are made private like all previous types. The companion
objects of `Notification` now have both constructor (`apply`) and extractor (`unapply`) functions:

``` scala
object Notification {...}
trait Notification[+T] {
   override def equals(that: Any): Boolean = {...}
   override def hashCode(): Int = {...}
   def apply[R](onNext: T=>R, onError: Throwable=>R, onCompleted: ()=>R): R = {...}
}
```

The nested companion objects of `Notification` now have both constructor (`apply`) and extractor (`unapply`) functions:

``` scala
object Notification {
   object OnNext { def apply(...){}; def unapply(...){...} }
   object OnError { def apply(...){}; def unapply(...){...} }
   object OnCompleted { def apply(...){}; def unapply(...){...} }
}
```

To construct a `Notification`, you import `rx.lang.scala.Notification._` and use `OnNext("hello")`,
or `OnError(new Exception("Oops!"))`, or `OnCompleted()`.

To pattern match on a notification you create a partial function like so: `case Notification.OnNext(v) => { ... v ... }`,
or you use the `apply` function to pass in functions for each possibility.

There are no breaking changes for notifications.
## Java Interop Helpers

Since the Scala traits _wrap_ the underlying Java types, yoo may occasionally will have to wrap an unwrap
between the two representations. The `JavaConversion` object provides helper functions of the form `toJavaXXX` and
`toScalaXXX` for this purpose, properly hiding how precisely the wrapped types are stored.
Note the (un)wrap conversions are defined as implicits in Scala, but in the unlikely event that you do need them
be kind to the reader of your code and call them explicitly.

``` scala
object JavaConversions {
  import language.implicitConversions

  implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <: T] = {...}
  implicit def toScalaNotification[T](s: rx.Notification[_ <: T]): Notification[T] = {...}
  implicit def toJavaSubscription(s: Subscription): rx.Subscription = {...}
  implicit def toScalaSubscription(s: rx.Subscription): Subscription = {...}
  implicit def scalaSchedulerToJavaScheduler(s: Scheduler): rx.Scheduler = {...}
  implicit def javaSchedulerToScalaScheduler(s: rx.Scheduler): Scheduler = {...}
  implicit def toJavaObserver[T](s: Observer[T]): rx.Observer[_ >: T] = {...}
  implicit def toScalaObserver[T](s: rx.Observer[_ >: T]): Observer[T] = {...}
  implicit def toJavaObservable[T](s: Observable[T]): rx.Observable[_ <: T] = {...}
  implicit def toScalaObservable[T](observable: rx.Observable[_ <: T]): Observable[T] = {...}
}
```,Items of discussion or that I would like to resolve before releasing:
- [ ] `ReplaySubject` has a different style from other `Subject` implementations. I'm not tied to either approach, nor am I sure that the idea of an `AbstractSubject` was the right way to go. 
- [ ] I'm not convinced that `Subject` implementations have correct thread-safety or concurrency behavior. For example, we synchronize on subscriptions but not event emission and I'm not sure whether that means we're vulnerable to losing events or not.
- [x] Yet more `observeOn` fixes/tweaks are needed. 
- [ ] I'd like to eliminate the `rx.util` dumping ground
  - [ ] Put exceptions into `rx.exceptions` or `rx.util.exceptions`?
  - [ ] Put functions into `rx.functions` or `rx.util.functions`?
  - [ ] Where does Range go? TimeInterval? Timestamped? perhaps in `rx.observables`?
  - [x] Why is Timestamped not camelCase whereas TimeInterval is?
- [ ] Should AbstractSubject be public? I think it should be package private, particularly as I don't necessarily agree with the approach (even though I wrote it).
- [ ] For consistency should we have `rx.operators` with classes named `OperatorXYZ` or `rx.operations` and classes named `OperationXYZ`?
- [ ] ObserverBase needs to be package private or moved into a non-advertised package like `rx.operators`
 =||= > Why is Timestamped not camelCase whereas TimeInterval is?

Because `timestamp` is a single word, like `java.sql.Timestamp`?
 =||= ObserveOn fixes: https://github.com/Netflix/RxJava/pull/602
 =||= > Because timestamp is a single word, like java.sql.Timestamp?

I guess you're right. Never mind :-)
 =||= I've looked at the `Subject` implementations and they seem to be incorrect due to the following reasons:
- the `AbstractSubject` allows the concurrent execution of onNext and onError/onCompleted calls, i.e, the emitNotification doesn't lock on `SUBSCRIPTION_LOCK`.
- `PublishSubject`, `AsyncSubject` and `BehaviorSubject` seem to overwrite the last notification value even after the termination condition as the call `state.currentValue.set(new Notification<T>(...));` is always executed in the subjects onXXX methods regardless of the state. New subscribers may observe various states when subscribing.
 =||= > the AbstractSubject allows the concurrent execution of onNext and onError/onCompleted calls

All of Rx allows this as it is up to the provider to obey the contract and not call them concurrently. That is why we don't  synchronize everything in Rx, for performance reasons.
 =||= Rx Design Guideline 6.8

> 6.8. Avoid serializing operators
> 
> As all Rx operators are bound to guideline 6.7, operators can safely assume that their inputs are serialized. Adding too much synchronization would clutter the code and can lead to performance degradation.
> 
> If an observable sequence is not following the Rx contract (see chapter 0), it is up to the developer writing the end-user application to fix the observable sequence by calling the Synchronize operator at the first place the developer gets a hold of the observable sequence. This way the scope of additional synchronization is limited to where it is needed.

Due to this, a `Subject` implementation should not need to synchronize `onNext`/`onCompleted`/`onError` calls. They do need to handle `subscribe`/`unsubscribe` concurrent access. 

It is however tricky to achieve both of these since we want to ensure we don't have race-conditions in observers subscribing and seeing the correct view of events. That said, we don't want to add unnecessary synchronization.

For example, on `PublishSubject` it is completely fine during a concurrent race between `onNext` and `subscribe` that it may or may not get that `onNext` event. That's the nature of concurrently subscribing to a hot `Observable`. 

We don't want to pay the overhead of synchronization on `onNext` just so that occasional `subscribe` events can occur.
 =||= /cc @akarnokd @headinthebox @zsxwing I am ready to release 0.16.0 after running it on a Netflix API production canary to assert performance and functionality of the core operators, schedulers, etc (at least of what we use, not new operators).

I'm blocked on a build issue that I can't solve until tomorrow at the office so will release sometime Tuesday hopefully.
 =||= ,0
6026,5988,2.x: Flowable.blockingSubscribe(lambdas) is unbounded and can lead to OOME,I can't remember why, but `Flowable.blockingSubscribe(Consumer,...)` uses unbounded requests, which can lead to `OutOfMemoryError` in both synchronous and asynchronous scenarios.

The problem was raised in [this StackOverflow question](https://stackoverflow.com/questions/50106725/rx-java2-floawable-rebatchrequests-doesnt-rebatch-requests) and apart from the obvious solutions, having such unbounded operator over an asynchronous boundary can be a problem regardless.

Possible resolutions:

- **Behavior change**: bound it to `bufferSize()` in 2.x
- (and/or) Introduce overload(s) with `prefetch` but leave the existing ones unbounded

Alternatively, this could be deferred until 3.x without worrying of the behavior change.,`Flowable.blockingSubscribe(Consumer,…)` is using `Functions.MaxRequestSubscription()` which could lead to `OutOfMemoryError`. Is it the issue?
In that case, I suggest to:
* Keep existing `Flowable.blockingSubscribe(Consumer,…)` unbounded
* Deprecate existing `Flowable.blockingSubscribe(Consumer,…)`
* Introduce new overloads with `bufferSize()` and `prefetch`

WDYT? Can I work on this? =||= Create a new overload:

`blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, int bufferSize)`

have a dedicated implementation servicing it and leave the other overloads unbounded. =||= ,0
6036,6025,2.x: error handling - exception swallowed after explicit .dispose().,Library verision : 2.1.7

The following code will silently swallow thrown exception without signalling to RxPlugins. 
```
        val subject = PublishSubject.create<Unit>()

        var disposable: Disposable? = null
        disposable = subject.subscribe(
                {
                    disposable?.dispose()
                    throw Exception("test")
                }
        )

        subject.onNext(Unit)
```

The same applies to BehaviourSubject, *Processor, but not SingleSubject or Observable.just (.range etc. ). Though sections about error handling are almost equal in [PublishSubject](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/PublishSubject.html) and [SingleSubject](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/SingleSubject.html).

The reason seems to be located in [LambdaObserver](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/observers/LambdaObserver.java), which doesn't signal onError if is disposed already.

Is it expected behaviour?,Indeed it does not. The tradeoff here is that your code explicitly indicated it doesn't want to handle further events yet there would be no opportunity to have `onError` not signal to the global error handler.

I'm open for discussion. =||= As for me the exception should still be thrown somewhere, as the code is still executed and doing something wrong. So if `.dispose()` is requested and `onError` can not be called - it seems to me that this corresponds 2.x error handling philosophy when the error falls directly into global handler. =||= Well, other implementations do route to the global error handler so for the sake of consistency, this should be fixed. PR welcome. =||= ,0
6049,6043,2.x: Observable.throttleWithTimeout is confusing,The documentation for `Observable.throttleWithTimeout()` implies that it's different from `debounce()` and invites to read about the differences:

> Information on debounce vs throttle:
> <a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation">Debounce and Throttle: visual explanation</a></li>
> <a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/">Debouncing: javascript methods</a></li>
> <a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/">Javascript - don't spam your server: debounce and throttle</a></li>

Of these links, the first one isn't available anymore and the last two are about JS.

Looking at the method's implementation, it becomes clear that in RxJava it's not different from `debounce` in any way:
```java
@CheckReturnValue
@SchedulerSupport(SchedulerSupport.COMPUTATION)
public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit) {
    return debounce(timeout, unit);
}
```

Do we really need both methods? If yes, could the documentation say explicitly that they are synonyms? Could these links to third-party websites be removed?,Yes, it is an alias so it can be more easily discovered along the `throttle` methods. `debounce` is a traditional ReactiveX naming and we kept it for historical reasons.

You can update the javadocs (on both `Flowable` and `Observable` if you want. PR welcome. =||= @akarnokd thanks for the clarification. Will open a PR soon :) =||= Closing via #6049 =||= ,0
6052,5980,2.x: subscribeActual() accidental public,Looks like the following `protected void subscribeActual()` implementations have unintentionally become public:

- [`PublishSubject`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/subjects/PublishSubject.java#L134)
- [`PublishProcessor`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/processors/PublishProcessor.java#L95)

There is no reason to call `subscribeActual` from outside of RxJava, however, making these `protected` counts as a breaking change. However, it should be extremely unlikey somebody was actually using these methods directy.

The question is: do we take the risk and fix the visibility in 2.x or it has to wait for 3.x?

Note that many operators are also having this method as public but those are not really accessible from the outside.,In this case I'd consider making the fix with version 2.2 =||= I don't know If this is still relevant, but I opened a PR for it, let me know if it helps =||= ,0
6053,5806,3.x: Maybe incorrect or missing marbles (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(Iterable)`: missing diagram
- [x] `concat(Publisher)`: missing diagram
- [x] `concat(Publisher, int)`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concatArrayDelayError`: indicate error delayed, 1 marble per source
- [x] `concatArrayEager`: missing diagram
- [x] `concatDelayError(Iterable)`: missing diagram
- [x] `concatDelayError(Publisher)`: missing diagram
- [x] `concatDelayError(Publisher, int)`: fix overlap/misalignment inside the operator box
- [x] `concatEager(Iterable)`: missing diagram
- [x] `concatEager(Publisher)`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: indicate callable returns the error
- [x] `fromAction`: missing diagram
- [x] `fromCompletable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture(Future)`: operator name in the box, indicate Future is the parameter
- [x] `fromFuture(Future, long, TimeUnit)`: operator name in the box, indicate Future is the parameter, indicate timeout
- [x] `fromRunnable`: missing diagram
- [x] `merge(Iterable)`: missing diagram
- [x] `merge(Publisher)`: missing diagram
- [x] `merge(Publisher, int)`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `mergeArrayDelayError`: one marble per Maybe source
- [x] `mergeDelayError(Iterable)`: one marble per Maybe source
- [x] `mergeDelayError(Publisher)`: one marble per Maybe source
- [x] `mergeDelayError(Maybe, Maybe, ...)`: one marble per Maybe source
- [x] `sequenceEqual` + 1: result should be `Single`.
- [x] `timer` + 1: result should be Maybe
- [x] `using` + 1: rework to indicate the created Maybe
- [x] `wrap`: missing marble
- [x] `zip(Iterable)`: one marble per Maybe source, result should be Maybe
- [x] `zip(Maybe, Maybe, ...)` + 8: one marble per Maybe source, result should be Maybe
- [x] `zipArray`: one marble per Maybe source, result should be Maybe
- [x] `ambWith`: one marble per Maybe source, result should be Maybe
- [x] ~~`as`: missing diagram~~ operator removed
- [x] `blockingGet` + 1: missing diagram
- [x] `cache`: one marble per Maybe source, result should be Maybe
- [x] `cast`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatMap`: indicate Maybe target, indicate empty source
- [x] `concatWith`: one marble per Maybe source, result should be Maybe, operator name, indicate other is a parameter
- [x] `contains`: one marble per Maybe source, result should be Single, empty case
- [x] `count`: one marble per maybe, operator name, result should be Single, empty case
- [x] `defaultIfEmpty`: non-empty case, result should be Maybe
- [x] `delay(time)` + 3: one marble per Maybe source, result should be Maybe
- [x] `delay(Publisher)`: one marble per Maybe, one signal by the Publisher, empty publisher case
- [x] `delaySubscription(Publisher)`: missing diagram
- [x] `delaySubscription(time)` + 1: one marble per Maybe source, result should be Maybe
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: operator name, one marble per Maybe, result should be Maybe
- [x] `doFinally`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnComplete`: one marble per Maybe, result should be Maybe
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnTerminate`: one marble per Maybe, result should be Maybe
- [x] `filter`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, Function, Callable)`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, BiFunction)`: one marble per Maybe, result should be Maybe
- [x] `flatMapObservable`: should be mapped into an Observable
- [x] `flatMapPublisher`: indicate backpressure
- [x] `flatMapSingle`: indicate empty maybe results in error
- [x] `flatMapSingleElement`: operator name, indicate empty maybe
- [x] `flatMapCompletable`: indicate empty maybe
- [x] `hide`: missing diagram
- [x] `ignoreElement`: operator name, one marble per Maybe, result should be Maybe
- [x] `isEmpty`: result should be Single
- [x] `mergeWith`: operator name, one marble per Maybe, indicate backpressure
- [x] `ofType`: one marble per Maybe
- [x] `onErrorComplete` + 1: missing diagram
- [x] `onErrorResumeNext`: one marble per Maybe, result should be Maybe
- [x] `onErrorResumeWith`: one marble per Maybe, result should be Maybe
- [x] `onErrorReturn`: one marble per Maybe, result should be Maybe, indicate callback
- [x] `onErrorReturnItem`: operator name, one marble per Maybe, result should be Maybe, indicate normal outcome
- [x] ~~`onExceptionResumeNext`: operator takes a Maybe source directlyˇ~~ operator removed
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat` + 1: one marble per source, indicate backpressure, indicate repeat conditions
- [x] `repeatUntil`: operator name, repeat condition, indicate backpressure
- [x] `repeatWhen`: one marble per Maybe, indicate backpressure
- [x] `retry` + 2: one marble per Maybe, result should be Maybe, indicate repeat conditions
- [x] `retry(int, Predicate)`: missing diagram
- [x] `retry(Predicate)`: missing diagram
- [x] `retryUntil`: missing diagram
- [x] `retryWhen`: one marble per Maybe, output should be Maybe
- [x] `switchIfEmpty` + 1: improve diagrams, indicate argument type
- [x] `takeUntil` + 1: one marble per Maybe, output should be Maybe
- [x] `timeout` + 3: one marble per Maybe, output should be Maybe
- [x] `timeout(MaybeSource)`: missing diagram
- [x] `timeout(MaybeSource, MaybeSource)`: missing diagram
- [x] `timeout(Publisher)`: missing diagram
- [x] `timeout(Publisher, MaybeSource)`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toObservable`: missing diagram
- [x] `toSingle` + 1: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `zipWith`: one marble per Maybe, output should be Maybe,Here is the Excel file I draw the diagrams in: https://drive.google.com/file/d/1di67kFJEuiLPyq14JlnV3vFl-muaCMfH/view?usp=sharing =||= ,0
6060,605,Subjects reimplemented.,Reimplemented all 4 kinds of subjects with the following properties:
- The `onNext`, `onError` and `onCompleted` are fully thread safe against subscription and unsubscription.
- A terminated subject won't accept any new events; `AsyncSubject`, `PublishSubject` and `BehaviorSubject` will re-emit just the very first exception when an observer subscribes to them.
- Emitting events to subscribed observers is done while holding the state lock. 
  - In Rx.NET when an event is received, the list of observers is retrieved while holding the lock, then outside the lock, the list is traversed and the events are propagated to the observers. Note however, if an observer unsubscribes right after the unlock and before the event propagation, it will still appear in the list and will receive the event. IMO, this is an undesired behavior.
  - The drawback of my solution is that it might be possible to deadlock the subjects, i.e., when an observer deliberately passes the source subject to another thread (which sends an event to the subject) and waits for its completion.
- Added the `Notification.acceptSafe` which will capture the exception of the `onNext` and propagate it through the `onError`. Its return value indicates if the observer can still be used after (i.e., no terminal event was delivered).
- Added the reusable state classes to `AbstractSubject`, although none of the subjects use this class any more.
- There is an `UnsubscribeTester` class, which seems to be out-of-place. Can this be moved into the test directory?,[RxJava-pull-requests #542](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/542/) SUCCESS
This pull request looks good
 =||= Holding the lock while dispatching events (i.e. executing arbitrary code) seems pretty dangerous. In my experience I've always ended up regretting it when I did this.
 =||= "... In Rx.NET when an event is received, the list of observers is retrieved while holding the lock, then outside the lock, the list is traversed and the events are propagated to the observers. Note however, if an observer unsubscribes right after the unlock and before the event propagation, it will still appear in the list and will receive the event. IMO, this is an undesired behavior ...".

Unsubscribing does a "best effort", don't hold the lock.
 =||= @akarnokd Thanks for this ... @headinthebox and I are reviewing and will end up with some merged/refactored form. So this specific PR won't be merged.
 =||= No problem.
 =||= Based on this discussion I've tried my hand in pull request https://github.com/Netflix/RxJava/pull/651

I'd appreciate your review.
 =||= Sure.
 =||= Closing as we ended up doing this in https://github.com/Netflix/RxJava/pull/651.

Thank you very much for the work on this and the significant performance gains you helped achieve!
 =||= ,0
6074,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6075,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6076,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6077,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6079,3708,Single and Completable takeUntil(),In reading the original PR for `Single`, I saw Ben was OK with adding a `takeUntil(Single/Observable)` operator for `Single` later. I was wondering if this was still the plan, and if you would be open to contributions on this front. Same with `Completable`.

One caveat that I've thought of is that there's a potentially conflicting contact with `Single` and `takeUntil()` in the sense that `takeUntil()` calls `onCompleted()` in observables, but `Single`s will actually go to `onError()` if `onCompleted()` is called before any events are emitted (and by extension `onSuccess()`). Not sure what the clear path would be, but it seems like `Single`s would have to only unsubscribe and not propagate any notifications, differing from `Observable`s and likely `Completable`s in this regard.,`Single.takeUntil` still has to emit an onSuccess or onError; you need to emit a `NoSuchElementException` from the other `Single.onSuccess`. Unsubscribing the main and not emitting anything is bad because it keeps the subscribers hanging. I don't think it is worth it.

`Completable.takeUntil` is just `completable.ambWith(other)`.
 =||= The completable makes sense. For `Single`, do you think there's a feasible way to do a sort of takeUntil-like behavior where it completes/unsubscribes on the emission of another observable/single? 

I'm working on some lifecycle handling for android, and a use case that's worked well in the past is to emit lifecycle events via behaviorsubject and then just `takeUntil(lifecycleSubject.filter(e -> e == DETACH))`. The idea is you want it to unsubscribe when the detach happens, and perhaps out of convenience we've always been using the fact that takeUntil would call onComplete and eventually cause it to unsubscribe. 
 =||= It seems like forcing an onSuccess or onError defeats the purpose of having a subscription that supports `unsubscribe` prior to that.
 =||= The best you can do with `takeUntil` is to signal an error, like `CancellationException` similar to how `Future` does.
 =||= I see. Would that be something you guys would be open to as PR? Or at least consider making `Single#lift()` public since it's still experimental? Otherwise it doesn't seem like it's possible in the current API. Could catch existing `NoSuchElementException`s but there'd be no way to know if it was due to completion or cancellation. 

Alternatively, would there be a simple way to potentially swallow that error upstream rather than force the subscriber to handle it?
 =||= We are open for PRs.
 =||= Closing via #3712
 =||= Actually this just reminded me, would we want `Single` and `Observable` overloads for `Completable`, or just use `amb` and call `toCompletable` on those when passing them in?
 =||= Maybe, submit a PR and let's see the opinions.
 =||= Will do, though likely not until this weekend or next week
 =||= ,0
6081,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6083,5789,2.x: Completable missing or incorrect marbles (tracking issue),- [x] `ambArray`: missing diagram
- [x] `amb`: missing diagram
- [x] `complete`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concat`: missing diagram
- [x] `create`: missing diaglam
- [x] `unsafeCreate`: missing diagram
- [x] `defer`: missing diagram
- [x] `error`: missing diagram
- [x] `fromAction`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromRunnable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `merge`: missing diagram
- [x] `mergeArrayDelayError`: missing diagram
- [x] `mergeDelayError`: missing diagram
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `andThen`: missing diagram
- [x] `as`: missing diagram
- [x] `blockingAwait`: missing diagram
- [x] `blockingGet`: missing diagram
- [x] `cache`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatWith`: missing diagram
- [x] `delay`: missing diagram
- [x] `doOnComplete`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnLifecycle`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnTerminate`: missing diagram
- [x] `doAfterTerminate`: missing diagram
- [x] `doFinally`: missing diagram
- [x] `lift`: missing diagram
- [x] `mergeWith`: missing diagram
- [x] `observeOn`: missing diagram
- [x] `onErrorComplete`: missing diagram
- [x] `onErrorResumeNext`: missing diagram
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `startWith`: missing diagram
- [x] `hide`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `subscribeOn`: missing diagram
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toMaybe`: wrong operator name in box
- [x] `toObservable`: use the old diagram of `toMaybe`
- [x] `toSingle`: missing diagram
- [x] `toSingleDefault`: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram,Done. =||= ,0
6084,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6085,5789,2.x: Completable missing or incorrect marbles (tracking issue),- [x] `ambArray`: missing diagram
- [x] `amb`: missing diagram
- [x] `complete`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concat`: missing diagram
- [x] `create`: missing diaglam
- [x] `unsafeCreate`: missing diagram
- [x] `defer`: missing diagram
- [x] `error`: missing diagram
- [x] `fromAction`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromRunnable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `merge`: missing diagram
- [x] `mergeArrayDelayError`: missing diagram
- [x] `mergeDelayError`: missing diagram
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `andThen`: missing diagram
- [x] `as`: missing diagram
- [x] `blockingAwait`: missing diagram
- [x] `blockingGet`: missing diagram
- [x] `cache`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatWith`: missing diagram
- [x] `delay`: missing diagram
- [x] `doOnComplete`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnLifecycle`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnTerminate`: missing diagram
- [x] `doAfterTerminate`: missing diagram
- [x] `doFinally`: missing diagram
- [x] `lift`: missing diagram
- [x] `mergeWith`: missing diagram
- [x] `observeOn`: missing diagram
- [x] `onErrorComplete`: missing diagram
- [x] `onErrorResumeNext`: missing diagram
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `startWith`: missing diagram
- [x] `hide`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `subscribeOn`: missing diagram
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toMaybe`: wrong operator name in box
- [x] `toObservable`: use the old diagram of `toMaybe`
- [x] `toSingle`: missing diagram
- [x] `toSingleDefault`: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram,Done. =||= ,0
6086,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6087,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6091,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6095,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6097,5789,2.x: Completable missing or incorrect marbles (tracking issue),- [x] `ambArray`: missing diagram
- [x] `amb`: missing diagram
- [x] `complete`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concat`: missing diagram
- [x] `create`: missing diaglam
- [x] `unsafeCreate`: missing diagram
- [x] `defer`: missing diagram
- [x] `error`: missing diagram
- [x] `fromAction`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromRunnable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `merge`: missing diagram
- [x] `mergeArrayDelayError`: missing diagram
- [x] `mergeDelayError`: missing diagram
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `andThen`: missing diagram
- [x] `as`: missing diagram
- [x] `blockingAwait`: missing diagram
- [x] `blockingGet`: missing diagram
- [x] `cache`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatWith`: missing diagram
- [x] `delay`: missing diagram
- [x] `doOnComplete`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnLifecycle`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnTerminate`: missing diagram
- [x] `doAfterTerminate`: missing diagram
- [x] `doFinally`: missing diagram
- [x] `lift`: missing diagram
- [x] `mergeWith`: missing diagram
- [x] `observeOn`: missing diagram
- [x] `onErrorComplete`: missing diagram
- [x] `onErrorResumeNext`: missing diagram
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `startWith`: missing diagram
- [x] `hide`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `subscribeOn`: missing diagram
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toMaybe`: wrong operator name in box
- [x] `toObservable`: use the old diagram of `toMaybe`
- [x] `toSingle`: missing diagram
- [x] `toSingleDefault`: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram,Done. =||= ,0
6098,5789,2.x: Completable missing or incorrect marbles (tracking issue),- [x] `ambArray`: missing diagram
- [x] `amb`: missing diagram
- [x] `complete`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concat`: missing diagram
- [x] `create`: missing diaglam
- [x] `unsafeCreate`: missing diagram
- [x] `defer`: missing diagram
- [x] `error`: missing diagram
- [x] `fromAction`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromRunnable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `merge`: missing diagram
- [x] `mergeArrayDelayError`: missing diagram
- [x] `mergeDelayError`: missing diagram
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `andThen`: missing diagram
- [x] `as`: missing diagram
- [x] `blockingAwait`: missing diagram
- [x] `blockingGet`: missing diagram
- [x] `cache`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatWith`: missing diagram
- [x] `delay`: missing diagram
- [x] `doOnComplete`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnLifecycle`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnTerminate`: missing diagram
- [x] `doAfterTerminate`: missing diagram
- [x] `doFinally`: missing diagram
- [x] `lift`: missing diagram
- [x] `mergeWith`: missing diagram
- [x] `observeOn`: missing diagram
- [x] `onErrorComplete`: missing diagram
- [x] `onErrorResumeNext`: missing diagram
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `startWith`: missing diagram
- [x] `hide`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `subscribeOn`: missing diagram
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toMaybe`: wrong operator name in box
- [x] `toObservable`: use the old diagram of `toMaybe`
- [x] `toSingle`: missing diagram
- [x] `toSingleDefault`: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram,Done. =||= ,0
6101,5789,2.x: Completable missing or incorrect marbles (tracking issue),- [x] `ambArray`: missing diagram
- [x] `amb`: missing diagram
- [x] `complete`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concat`: missing diagram
- [x] `create`: missing diaglam
- [x] `unsafeCreate`: missing diagram
- [x] `defer`: missing diagram
- [x] `error`: missing diagram
- [x] `fromAction`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromRunnable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `merge`: missing diagram
- [x] `mergeArrayDelayError`: missing diagram
- [x] `mergeDelayError`: missing diagram
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `andThen`: missing diagram
- [x] `as`: missing diagram
- [x] `blockingAwait`: missing diagram
- [x] `blockingGet`: missing diagram
- [x] `cache`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatWith`: missing diagram
- [x] `delay`: missing diagram
- [x] `doOnComplete`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnLifecycle`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnTerminate`: missing diagram
- [x] `doAfterTerminate`: missing diagram
- [x] `doFinally`: missing diagram
- [x] `lift`: missing diagram
- [x] `mergeWith`: missing diagram
- [x] `observeOn`: missing diagram
- [x] `onErrorComplete`: missing diagram
- [x] `onErrorResumeNext`: missing diagram
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `startWith`: missing diagram
- [x] `hide`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `subscribeOn`: missing diagram
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toMaybe`: wrong operator name in box
- [x] `toObservable`: use the old diagram of `toMaybe`
- [x] `toSingle`: missing diagram
- [x] `toSingleDefault`: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram,Done. =||= ,0
6116,6108,Gradle build error just as the error info from the part of README,Pls change the read me about the setup library into the project
The reason as below:
Configuration 'compile' is obsolete and has been replaced with 'implementation' and 'api'.
It will be removed at the end of 2018，pls see http://d.android.com/r/tools/update-dependency-configurations.html,
So pls use implementation instead of compile in the correct position...,I don't understand what you are talking about. We have `api` and `implementation` for some time now: https://github.com/ReactiveX/RxJava/blob/2.x/build.gradle#L67 =||= @akarnokd  I mean you should update the readme -about the set up library ,you write like that  compile :"",you should change it to - implement "",it works well =||= PR welcome. =||= I believe that @MarcSteven is referring to changing the project's README's ["Setting up the dependency"](https://github.com/ReactiveX/RxJava/blob/2.x/README.md#setting-up-the-dependency) section to use `api` or `implementation` instead of `compile`.

I'll open a PR, but I'm not super familiar with the differences between `api` and `implementation`. =||= ,0
6117,611,Serial subscription fix,Changed Scala bindings fro SerialSubscription to use underlying isUnsubscribed implementation,[RxJava-pull-requests #547](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/547/) ABORTED
 =||= ,0
6131,613,CombineLatest incorrect?,I've looked into the `OperationCombineLatest` implementation and I think it is incorrectly implemented:
- Doesn't seem to allow multiple observers on the same combiner as the Aggregator is per source observable and not per subscribing observer.
- I think the contract requires that no onNext value is lost on any of the source observers yet since they are not synchronized with each other, a source observer might overwrite its current value while the collection is running in `Aggregator.next()`.

Thoughts?

Edit: I was wrong with case 2; if one is faster than the others, that is not a problem.,Fixed in https://github.com/Netflix/RxJava/pull/708
 =||= ,0
6133,613,CombineLatest incorrect?,I've looked into the `OperationCombineLatest` implementation and I think it is incorrectly implemented:
- Doesn't seem to allow multiple observers on the same combiner as the Aggregator is per source observable and not per subscribing observer.
- I think the contract requires that no onNext value is lost on any of the source observers yet since they are not synchronized with each other, a source observer might overwrite its current value while the collection is running in `Aggregator.next()`.

Thoughts?

Edit: I was wrong with case 2; if one is faster than the others, that is not a problem.,Fixed in https://github.com/Netflix/RxJava/pull/708
 =||= ,0
6137,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6141,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6143,6082,concatArrayEagerDelayError documented but missing? 2.16,On 2.1.16 it is documented in the [wiki](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#1x-observable-to-2x-flowable) and on [readthedocs](https://rxjava-doc.readthedocs.io/en/latest/What's-different-in-2.0/#1x-observable-to-2x-flowable) that `concatArrayEagerDelayError` is new in RxJava 2 together with:

- [`concatArray`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Observable.java#L1259)
- [`concatArrayDelayError`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Observable.java#L1286)
- [`concatArrayEager`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Observable.java#L1315)

Those are all there, but `concatArrayEagerDelayError` doesn't seem to be implemented:

```kotlin
Observable.concatArrayEagerDelayError()
```

Am I perhaps missing something?,Looks like `concatArrayEagerDelayError` has not been exposed so far: https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Observable.java#L1341 =||= Yes, I've overlooked that, might've been because I'm on my laptop right now and it's chugging along slowly on those large files on GitHub.

Is the plan to expose this in the future? =||= No plans and there was no feature request for them. It would require 6~8 new methods: 

`{Flowable|Observable}.concatArrayEagerDelayError([tillTheEnd[, maxConcurrency [, prefetch]]], sources...)`

and at least 2 diagrams per base class. =||= I'm up for providing a PR if that's welcome. Thank you in advance for providing me with the methods that would need to be implemented. I haven't dabbled into the RxJava source, but I guess I can figure it out. What would I need to create the diagrams?

Looking at the [tests for concatArrayEager](https://github.com/ReactiveX/RxJava/blob/ab520503925bc9cdff47d6a4ceaf8b2209b61250/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java#L312), and [concatArrayDelayError](https://github.com/ReactiveX/RxJava/blob/ab520503925bc9cdff47d6a4ceaf8b2209b61250/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatTest.java#L779-L796). I assume that I only have to implement the tests like `concatArrayDelay` but for `concatArrayEagerDelayError`. =||= I draw them in Excel but others use OmniGraffle or Inkscape.

You can try making a PR. =||= Small update. I was on holiday and am currently studying for exams for another month so it'll be more than a month till I can get to this unfortunately. =||= I've done it and the necessary marbles in #6143. =||= Too bad for me, I was looking forward to it. :(

Great to have it exposed now though. =||= ,0
6145,614,Merge delay error doesn't synchronize onNext calls,The merge operation passes calls to the actual observer through an instance of SynchronizedObserver but merge delay error doesn't.  This is causing overlapping calls to onNext and all sorts of concurrency bugs in our server.,Saw errors in those in my tests yesterday as well. 
 =||= Fixed and merged.
 =||= ,0
6152,6151,`BaseTestConsumer#assertValueSet` doesn't verify that all listed values were received,[`BaseTestConsumer#assertValueSet`](https://github.com/ReactiveX/RxJava/blob/e8930c2830869f1089ac7627dda044e8d861fb6b/src/main/java/io/reactivex/observers/BaseTestConsumer.java#L567) is documented and implemented as:

```java
/**
 * Assert that the TestObserver/TestSubscriber received only the specified values in any order.
 * <p>This helps asserting when the order of the values is not guaranteed, i.e., when merging
 * asynchronous streams.
 *
 * @param expected the collection of values expected in any order
 * @return this
 */
@SuppressWarnings("unchecked")
public final U assertValueSet(Collection<? extends T> expected) {
    if (expected.isEmpty()) {
        assertNoValues();
        return (U)this;
    }
    for (T v : this.values) {
        if (!expected.contains(v)) {
            throw fail("Value not in the expected collection: " + valueAndClass(v));
        }
    }
    return (U)this;
}
```

Within our team we have several tests using `assertValueSet`, each attempting to assert that _all_ of the listed values are emitted. Today we found out that `assertValueSet` verifies a weaker condition, namely that no "unexpected" values are emitted. It does not verify that all listed values are emitted. This took us by surprise. If this is the intended behaviour, perhaps the documentation could be clarified on this point.

NB: the RxJava code base itself contains several tests using `assertValueSet`. Some of these also seem to assume the stronger interpretation (e.g. `FlowableFlatMapSingleTest#normalAsync`), while others would surely fail under the stronger semantics (e.g.`FlowableFlatMapSingleTest#takeAsync`).

NB2: I do observe that (nearly?) all tests in the RxJava code base invoking `assertValueSet` involve some form of nondeterminism, and a benefit of the current weaker semantics is that these tests are now less likely to fail on a system under heavy load. Still, as-is `assertValueSet` also passes if _no_ values are emitted; surely these tests wish to assert something more definitive?,It is meant to assert received values are all in the collection. You can make a stronger assumption by adding assertValueCount. =||= ,0
6155,580,CRLF fixes,Issue #579

In case the manual mode is chosen.,[RxJava-pull-requests #519](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/519/) SUCCESS
This pull request looks good
 =||= I added the .gitattributes file in this commit: https://github.com/Netflix/RxJava/commit/4782588aa15a954ea053977d6b740127d31ee3f1 and then let Git renormalize itself as per https://help.github.com/articles/dealing-with-line-endings#re-normalizing-a-repository
 =||= ,0
6167,614,Merge delay error doesn't synchronize onNext calls,The merge operation passes calls to the actual observer through an instance of SynchronizedObserver but merge delay error doesn't.  This is causing overlapping calls to onNext and all sorts of concurrency bugs in our server.,Saw errors in those in my tests yesterday as well. 
 =||= Fixed and merged.
 =||= ,0
6174,6173,2.x: The RxJavaPlugins JavaDocs HTML should be auto-cleaned up,Some method entries of the `RxJavaPlugins` JavaDocs HTML looks misaligned, just like some other components used to:

![image](https://user-images.githubusercontent.com/1269832/44617428-50c2b880-a862-11e8-8161-59d9ae051ffc.png)

The fix is trivial: add the respective file, `plugins/RxJavaPlugins.html` to the gradle code:

https://github.com/ReactiveX/RxJava/blob/2.x/gradle/javadoc_cleanup.gradle#L13

You can verify the outcome by running `./gradlew clean javadocCleanup` and checking the respective file in your browser.

(Note that probably there is no way to fix the long signature displays, only those unnecessary newlines).,nan,0
6175,6172,2.x: explain null plugin returns better,When an `onSubscribe` hook is installed and returns a null consumer, the current error report says:

```java
ObjectHelper.requireNonNull(observer, "Plugin returned null Observer");
```

At least an "a" is missing but perhaps it would be better to word it more detailed:

> "The RxJavaPlugins.onSubscribe hook returned a null Observer. Please check the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"

Of course, all reactive types should be updated and adapted to the appropriate types and method names.,I'm inexperienced but I would be a happy to try and help with this issue.  =||= Closing via #6175. =||= ,0
6187,6185,Possible concurrency issue with .refCount()? (2.2.0),First, I want to thank you for this wonderful library which I gladly use in many professional applications!

While I was writing a component for one of our company applications, I wrote a multithreaded stress test, because the component itself introduces shared state. Sometimes the test failed. Of course, I suspected my component to be the culprit. After further investigation I could completely rule out my own component and still reproduce the problem. 
I think there could be a problem with the `refCount()` operator.

Less words, more code:

The problem is reproducible with the following unit test (well, at least as reproducible as a test in a multithreaded manner can be...)

```
public void replayRefCountShallBeThreadSafe() {
        for (int i = 0; i < 10000; i++) {
            Observable<Object> observable = Observable.just(new Object()).replay(1).refCount();

            TestObserver<Object> observer1 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestObserver<Object> observer2 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            assertThat(observer1.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));
            assertThat(observer2.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));
        }
}
```

As you can see, I am repeating the logic 10000 times. This (mostly) guarantees that the test fails on my environment. One of the observers does NOT receive the completed event and therefore the `awaitTerminalEvent` times out.

On the other hand, the following unit test where I manually `.connect()` the `ConnectableObservable`  returned vom `.replay(1)` passes:

```
public void replayShallBeThreadSafe() {
        for (int i = 0; i < 10000; i++) {
            ConnectableObservable<Object> observable = Observable.just(new Object()).replay(1);
            Disposable connection = observable.connect();

            TestObserver<Object> observer1 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestObserver<Object> observer2 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            assertThat(observer1.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));
            assertThat(observer2.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));
            connection.dispose();
        }
}
```

Please tell me if I am missing something...

Version: RxJava 2.2.0
Tests are JUnit tests, with hamcrest assertions.

Thanks!
,Thanks for reporting. It does seem like a reconnection race as one observer goes out while another comes in. Also present in the `Flowable` version. I'll post a fix shortly. =||= Wow, that is what I call a fast response! :)
I am looking forward to the fix, thank you. 
If I can be of any help, just tell me. =||= ,0
6193,6179,Add an "Error handling" JavaDocs section to fromCallable & co,The operators of `fromCallable`, `fromAction` and `fromRunnable` in the reactive classes could use an `<dt><b>Error handling:</b></dt>` section in the JavaDocs describing the regular and canceled/disposed behavior.

> If the `{@link Callable/Action/Runnable}` throws an exception/exception/unchecked exception, the respective `{@link Throwable}` is delivered to the downstream via `{@link Subscriber/Observer/.../#onError()}`, except when the downstream has canceled/disposed this `{@code Flowable/Observable/Single/Maybe/Completable}` source. In this latter case, the Throwable is delivered to the global error handler via `{@link RxJavaPlugins#onError(Throwable)}` as `{@link io.reactivex.exceptions.UndeliverableException UndeliverableException}`.,nan,0
6197,6195,Flowable.reduce(BiFunction) does not signal NoSuchElementException,The JavaDocs of `Flowable.reduce(BiFunction)` incorrectly mentions that an empty source results in a `NoSuchElementException`. It returns a `Maybe` thus an empty source will result in an empty `Maybe`. The `Observable.reduce(BiFunction)` counterpart has the correct text.

The "If the source is empty, a NoSuchElementException is signaled." should be removed.,nan,0
6199,6196,Fix terminology of cancel/dispose in the JavaDocs,`Flowable`s can be **canceled** and the other reactive types can be **disposed**. Change the JavaDocs of these latter types accordingly (via careful find/replace):

- [ ] Observable
- [ ] Single
- [ ] Maybe
- [ ] Completable

(Note: `Flowable` is okay).,nan,0
6200,6198,toFuture incorrect diagram/description,Both `Flowable.toFuture` and `Observable.toFuture` describes the wrong behavior: If the source has more than one element, the outcome is actually `IndexOutOfBoundsException`.

In addition, the docs should mention the source has to terminate in order for the `Future` to terminate.

Plus, the [marble](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#toFuture--) should be updated to reflect the actual behavior (there is no dispose upon the first received item).

![image](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/toFuture.o.png),nan,0
6232,623,Clojure Observable/from converts list to to an observable of a single (list) value ,I'm trying out the [clojure example code](https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/rx_examples.clj#L28) and the results seem wrong.

With the following:

``` clojure
(defn hello
  [& args]
  (-> (Observable/from args)
    (.subscribe (rx/action [v] (println (str "Hello " v "!"))))))

(hello "Ben" "George")
```

I expected the observable to emit two distinct values, "Ben" and "George", before completing, resulting in one line of output per name.

However, the repl output is:

``` clojure
Hello ("Ben" "George")!
```

So it seems the entire `args` list is emitted as a single value. 

Tried 0.15.1 as well as current master at 7ec374c. clojure 1.5.1.,``` clojure
(defn hello
  [& args]
  (-> (Observable/from  '("Ben" "George") ) ; hardcode the list
    (.subscribe (rx/action [v] (println (str "Hello " v "!"))))))

(hello "Ben" "George")
```

Works fine. Very strange.
 =||= The Clojure compiler has many versions of `Observable/from` to choose from and here it picks the wrong one. You'll need to give it a hint:

``` clojure
(Observable/from ^java.lang.Iterable args)
```

that should do it.
 =||= Thanks, that works. Not cool though, it's reasonable to expect it to just work.
 =||= Welcome to Java interop with dynamic types.
 =||= :)
 =||= ,0
6241,623,Clojure Observable/from converts list to to an observable of a single (list) value ,I'm trying out the [clojure example code](https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/rx_examples.clj#L28) and the results seem wrong.

With the following:

``` clojure
(defn hello
  [& args]
  (-> (Observable/from args)
    (.subscribe (rx/action [v] (println (str "Hello " v "!"))))))

(hello "Ben" "George")
```

I expected the observable to emit two distinct values, "Ben" and "George", before completing, resulting in one line of output per name.

However, the repl output is:

``` clojure
Hello ("Ben" "George")!
```

So it seems the entire `args` list is emitted as a single value. 

Tried 0.15.1 as well as current master at 7ec374c. clojure 1.5.1.,``` clojure
(defn hello
  [& args]
  (-> (Observable/from  '("Ben" "George") ) ; hardcode the list
    (.subscribe (rx/action [v] (println (str "Hello " v "!"))))))

(hello "Ben" "George")
```

Works fine. Very strange.
 =||= The Clojure compiler has many versions of `Observable/from` to choose from and here it picks the wrong one. You'll need to give it a hint:

``` clojure
(Observable/from ^java.lang.Iterable args)
```

that should do it.
 =||= Thanks, that works. Not cool though, it's reasonable to expect it to just work.
 =||= Welcome to Java interop with dynamic types.
 =||= :)
 =||= ,0
6254,6253,Flaky test/operator: FlowableSampleTest backpressureOverflowWithOtherPublisher,```
io.reactivex.internal.operators.flowable.FlowableSampleTest > backpressureOverflowWithOtherPublisher FAILED
    java.lang.AssertionError: No errors (latch = 0, values = 0, errors = 0, completions = 1)
        at io.reactivex.observers.BaseTestConsumer.fail(BaseTestConsumer.java:189)
        at io.reactivex.observers.BaseTestConsumer.assertError(BaseTestConsumer.java:318)
        at io.reactivex.observers.BaseTestConsumer.assertError(BaseTestConsumer.java:303)
        at io.reactivex.observers.BaseTestConsumer.assertFailure(BaseTestConsumer.java:811)
        at io.reactivex.internal.operators.flowable.FlowableSampleTest.backpressureOverflowWithOtherPublisher(FlowableSampleTest.java:313)
```,nan,0
6258,625,observeOn doesn't behave as expected (Clojure),``` clojure
(ns rx.lang.clojure.examples.rx-examples
  (:require [rx.lang.clojure.interop :as rx])
  (:import rx.Observable
           rx.subscriptions.Subscriptions
           rx.schedulers.Schedulers
           java.util.concurrent.TimeUnit
))

(println (Thread/currentThread)) ; (*)
(-> (Observable/interval 100 TimeUnit/MILLISECONDS #_(Schedulers/currentThread)) 
    (.take 5)
    (.observeOn (Schedulers/currentThread))
    (.subscribe (rx/action [v]
                             ; this file is created, but the content do not match (*)
                            (spit "/tmp/tid.txt" (Thread/currentThread)) 
                           (println v))) ; this output never reaches the repl
    )
```

So, `Observable/interval` spawns a new thread and the subscribed callback is invoked in that thread by default. I need to use `observeOn` to ensure the cb
is invoked in the current thread so that the `println` output makes it to the repl.

`/tmp/tid.txt` does get created, so the cb _is_ called but the println output
never makes it to the repl.
If i schedule `Observable/interval` in the current thread (commented out) the
output is visible (though the repl hangs afterwards for some reason), but
the `observeOn` itself doesn't seem to do the job it's meant to.
The contents of /tmp/tid/txt don't match the current thread reported
by the println either.

Is this a bug or am I doing something wrong?,> (though the repl hangs afterwards for some reason)

I believe this is related to a bug where `CurrentThreadScheduler` can not be unsubscribed from since it is all single-threaded and thus not async and never returns the `Subscription` so `take(5)` is meaningless to it.

We should be able to unsubscribe from a `CurrentThread` scheduled `Observable` though and @headinthebox and I were looking at this last week to determine how to do so. We looked at the Rx.Net implementation and it's very non-elegant to make it work (thread-locals and other such fun). It's on my plate to tackle. In the meantime for anything that is infinite such as `interval` you'll want to use something with real concurrency such as `NewThread` or `Schedulers.threadPoolForComputation()`.

> The contents of /tmp/tid/txt don't match the current thread reported

The file contains this: `Thread[RxComputationThreadPool-6,5,main]` and that is correct since `interval` uses the thread-pool by default.

The `(Schedulers/currentThread)` `Scheduler` tells it to run on the "current" thread, whatever it is using a trampoline. It is the same as using `Immediate` which uses the "current" thread, except it does trampolining.

If you change to use `(Schedulers/immediate)` for the interval you'll get what you're expecting (and it will block on the current thread, sleeping for each interval since there is no concurrency):

``` clojure
(-> (Observable/interval 100 TimeUnit/MILLISECONDS (Schedulers/immediate)) 
    (.take 5)
    (.observeOn (Schedulers/currentThread))
    (.subscribe (rx/action [v]
                             ; this file is created, but the content do not match (*)
                            (spit "/tmp/tid.txt" (Thread/currentThread)) 
                           (println v))) ; this output never reaches the repl
    )

; outputs to file: Thread[nREPL-worker-2,5,main]
```

It now stays on the main thread and `observeOn` in effect does nothing since it is told to use `Schedulers/currentThread` so it stays on the main thread.

Generally `observeOn` is meant for moving the work from one thread to another, such as from a background worker thread to a UI thread for rendering. Using `observeOn` with `ImmediateScheduler` or `CurrentThreadScheduler` doesn't really make sense as it ends up being a pass-thru.
 =||= Thanks for the detailed answer.

The fact that Interval runs in the current thread by default is a little surprising, but I can live 
with that (and I'm guessing it's dictated by compat with .Net if nothing else).

The example you provided does get the output to the repl (it hangs, but that's expected now)
But I don't need the interval to run in the current thread, just the callback and I still haven't
found the secret handshake for that.

As I understand it observeOn determines where the cb is run. Since I wasn't getting
any output, I guessed that the cb ended up running on the wrong thread and made it explicit
where it should run. IIRC the default is that cb's are run in the same thread as the generated event?

Given your feedback,  I expected this to work:

```
(-> (Observable/interval 100 TimeUnit/MILLISECONDS (Schedulers/newThread)
    (.take 5)
    (.observeOn (Schedulers/immediate)) ; at least one of these should work, depending on 
    #_(.observeOn (Schedulers/currentThread)) ; the specific nature of
    #_(no-op) ; my misunderstanding
    (.subscribe (rx/action [v]
                             ; this file is created, but the content do not match (*)
                            (spit "/tmp/tid.txt" (Thread/currentThread)) 
                           (println v))) ; this output never reaches the repl
    )
```

Which I read as: the interval runs in a new thread (Forever, for now), while the `observeOn` call
ensures the cb is invoked in the current thread. That should reward me with output to the repl.

...It doesn't block, but no output is generated. 
 =||= > The fact that Interval runs in the current thread by default is a little surprising

The `interval` operator by default runs on a separate thread. You would you have to pass `Schedulers/immediate` or `Schedulers/currentThread` to make it run on the current thread.

> But I don't need the interval to run in the current thread, just the callback and I still haven't
> found the secret handshake for that.

ObserveOn has no way to automatically make something jump back to the "main" thread the REPL is on. That would require the main thread offering an event-loop or something to hook into and a `Scheduler` implementation that knows how to schedule work onto it similar to the Android and Swing modules which know how to schedule work into their UI event-loops.

> while the observeOn call ensures the cb is invoked in the current thread.

The `observeOn` operator schedules work on whatever `Scheduler` it is given. Think of it as moving the work from one thread to another (or one Scheduler to another).

Thus, it doesn't determine anything, it just puts the work where you tell it. 

Thus, in your code, `Observable.interval` and `take` are running on the new thread you tell it to use: `(Schedulers/newThread)` then you tell it to `observeOn` the `immediate` Scheduler which is a no-op and it will continue using the `(Schedulers/newThread)` you provided at the beginning so `subscribe` will still run on the new thread.

---

Here are two examples, one blocking another non-blocking:

``` clojure
(-> (Observable/interval 100 TimeUnit/MILLISECONDS)
    (.take 5)
    (.subscribe (rx/action [v]
               (println "non-blocking" v (java.lang.Thread/currentThread)))))


(-> (Observable/interval 100 TimeUnit/MILLISECONDS)
  (.take 5)
  (.toBlockingObservable)
  (.forEach (rx/action [v] (println "blocking" v (java.lang.Thread/currentThread)))))
```

The REPL shows this:

```
(-> (Observable/interval 100 TimeUnit/MILLISECONDS)
  (.take 5)
  (.toBlockingObservable)
  (.forEach (rx/action [v] (println "blocking" v (java.lang.Thread/currentThread)))))
nil
(-> (Observable/interval 100 TimeUnit/MILLISECONDS)
    (.take 5)
    (.subscribe (rx/action [v]
               (println "non-blocking" v (java.lang.Thread/currentThread)))))
#<SafeObservableSubscription rx.operators.SafeObservableSubscription@5034037e>
```

The console shows this:

```
blocking 0 #<Thread Thread[RxComputationThreadPool-4,5,main]>
blocking 1 #<Thread Thread[RxComputationThreadPool-4,5,main]>
blocking 2 #<Thread Thread[RxComputationThreadPool-4,5,main]>
blocking 3 #<Thread Thread[RxComputationThreadPool-4,5,main]>
blocking 4 #<Thread Thread[RxComputationThreadPool-4,5,main]>
non-blocking 0 #<Thread Thread[RxComputationThreadPool-2,5,main]>
non-blocking 1 #<Thread Thread[RxComputationThreadPool-2,5,main]>
non-blocking 2 #<Thread Thread[RxComputationThreadPool-2,5,main]>
non-blocking 3 #<Thread Thread[RxComputationThreadPool-2,5,main]>
non-blocking 4 #<Thread Thread[RxComputationThreadPool-2,5,main]>
```

If I want it to emit to the REPL I would need to have it all run on the REPL thread, then I get this:

```
(-> (Observable/interval 100 TimeUnit/MILLISECONDS (Schedulers/currentThread))
    (.take 5)
    (.subscribe (rx/action [v]
               (println "non-blocking" v (java.lang.Thread/currentThread)))))
non-blocking 0 #<Thread Thread[nREPL-worker-2,5,main]>
non-blocking 1 #<Thread Thread[nREPL-worker-2,5,main]>
non-blocking 2 #<Thread Thread[nREPL-worker-2,5,main]>
non-blocking 3 #<Thread Thread[nREPL-worker-2,5,main]>
non-blocking 4 #<Thread Thread[nREPL-worker-2,5,main]>
```

This then causes the bug with `CurrentThreadScheduler` that it never unsubscribes and hangs the REPL.

I don't know enough about how the Clojure REPL works (I'm a beginner with Clojure) to know if there is a way to hook a `Scheduler` into it. If so that would be a great contribution to the rxjava-clojure module. 

Now to see how `observeOn` behaves ...

``` clojure
(-> (Observable/interval 100 TimeUnit/MILLISECONDS) ; run on default which is Schedulers.threadPoolForComputation()
    (.take 5)
    ; print out the value and what thread it is on before doing `observeOn`
    (.doOnNext (rx/action [v] (println "interval emitted" v "on thread" (java.lang.Thread/currentThread))))
    (.observeOn (Schedulers/newThread)) ; move it to a new thread from here onwords
    (.subscribe (rx/action [v]
               ; receive the output and show what thread it is one
               (println "  -> output" v "on thread" (java.lang.Thread/currentThread)))))
```

The REPL shows:

```
(-> (Observable/interval 100 TimeUnit/MILLISECONDS) ; run on default which is Schedulers.threadPoolForComputation()
    (.take 5)
    ; print out the value and what thread it is on before doing `observeOn`
    (.doOnNext (rx/action [v] (println "interval emitted" v "on thread" (java.lang.Thread/currentThread))))
    (.observeOn (Schedulers/newThread)) ; move it to a new thread from here onwords
    (.subscribe (rx/action [v]
               ; receive the output and show what thread it is one
               (println "  -> output" v "on thread" (java.lang.Thread/currentThread)))))
#<SafeObservableSubscription rx.operators.SafeObservableSubscription@6df85c2c>
```

The console shows:

```
interval emitted 0 on thread #<Thread Thread[RxComputationThreadPool-6,5,main]>
  -> output 0 on thread #<Thread Thread[RxNewThreadScheduler-4,5,main]>
interval emitted 1 on thread #<Thread Thread[RxComputationThreadPool-6,5,main]>
  -> output 1 on thread #<Thread Thread[RxNewThreadScheduler-4,5,main]>
interval emitted 2 on thread #<Thread Thread[RxComputationThreadPool-6,5,main]>
  -> output 2 on thread #<Thread Thread[RxNewThreadScheduler-4,5,main]>
interval emitted 3 on thread #<Thread Thread[RxComputationThreadPool-6,5,main]>
  -> output 3 on thread #<Thread Thread[RxNewThreadScheduler-4,5,main]>
interval emitted 4 on thread #<Thread Thread[RxComputationThreadPool-6,5,main]>
  -> output 4 on thread #<Thread Thread[RxNewThreadScheduler-4,5,main]>
```

If I want to emit something to the REPL without using `println` I can return a `List` containing the output like this:

``` clojure
(-> (Observable/interval 100 TimeUnit/MILLISECONDS) ; run on default which is Schedulers.threadPoolForComputation()
    (.take 5)
    (.observeOn (Schedulers/newThread)) ; move it to a new thread from here onwords
    (.map (rx/fn [v]
               ; receive the output and show what thread it is one
               (str "  -> output " v " on thread " (java.lang.Thread/currentThread))))
    (.toList)
    (.toBlockingObservable)
    (.single))
```

This now returns the `ArrayList` in the REPL:

```
(-> (Observable/interval 100 TimeUnit/MILLISECONDS) ; run on default which is Schedulers.threadPoolForComputation()
    (.take 5)
    (.observeOn (Schedulers/newThread)) ; move it to a new thread from here onwords
    (.map (rx/fn [v]
               ; receive the output and show what thread it is one
               (str "  -> output " v " on thread " (java.lang.Thread/currentThread))))
    (.toList)
    (.toBlockingObservable)
    (.single))
#<ArrayList [  -> output 0 on thread Thread[RxNewThreadScheduler-8,5,main],   -> output 1 on thread Thread[RxNewThreadScheduler-8,5,main],   -> output 2 on thread Thread[RxNewThreadScheduler-8,5,main],   -> output 3 on thread Thread[RxNewThreadScheduler-8,5,main],   -> output 4 on thread Thread[RxNewThreadScheduler-8,5,main]]>
```

Hope this is helpful.
 =||= /cc @daveray in case you can provide better insight (particularly regarding REPL/console output)
 =||= That's a fantastic answer.

Noting that `doOnNext` is a recent addition, I needed to pull and recompile.

I realize now part of the issue is that I use emacs/cider so println output in another thread ends 
up in the nrepl buffer rather then the repl buffer where I expected it.

Yes, it doesn't make sense to ask for work to be schedueled in the currentThread without something
there to process schedueled work, my bad.

Still puzzled by how in your last example the result gets returned to the current thread.
does each call after `observeOn` block the current thread in turn? is `.single` magical?

In any case that was very helpful and realizing the behavior I described is not a bug,
I'll close this now.

Thanks again.
 =||= > Still puzzled by how in your last example the result gets returned to the current thread.
> does each call after observeOn block the current thread in turn? is .single magical?

It's the call to `(.toBlockingObservable)` that makes it block. Anytime you want to go from non-blocking to blocking you can use `toBlockingObservable` which then exposes a variety of blocking operators. They are useful when doing unit tests, playing around, REPLs etc or when bridging from async to sync in a mixed codebase.
 =||= See here for more info about `BlockingObservable`: https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators
 =||= Right, but everything you've shown me so far suggests that the blocking observable will still
live in another thread. I can only hope that I'm not the only person who finds all this quite subtle,
I'll read up on it rather then taking up more of your time. truly admire your dedication. 

Happy new year.
 =||= Yes, it happens on the background thread where it is scheduled. The `toBlockingObservable` doesn't change that. It just blocks and returns type `T` instead of `Observable<T>` or `Subscription`. 

Outside of a REPL it might make more sense where the assignment is explicit.

``` groovy
// this returns a non-blocking Observable and is lazy, so not running yet
Observable<Long> i = Observable.interval(100, TimeUnit.MILLISECONDS).take(5);

// this executes the above and returns a Subscription and does so asynchronously (non-blocking)
Subscription s = i.subscribe({ v -> println(v)});

// or I can block and fetch the last value
long lastValue = i.toBlockingObservable().last();
```

The `toBlockingObservable` does not change where the work is done, but it blocks the current thread to wait for the value which then is assigned and unblocks the current thread which then has it.

This is what the REPL is doing in my example where it gets the list of values returned to the REPL thread itself and it blocks the REPL thread until the value is returned.

The return type explains what is going on.
 =||= ,0
6260,6226,Wiki: Add generate() examples to Creating-Observables.md,Wiki target:

https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md

See JavaDocs:

http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#generate-io.reactivex.functions.Consumer- +subsequent overloads

Related: #6132,nan,0
6269,6268,2.x: firstOrError call on dispose twice,In  RxJava (2.2.2) if I use the next code the `onDispose` callback is called twice. I have already changed the code to not use this approach bc the `s.onNext` inside the subscribe is pretty obscure, but I report it just in case this can affect more cases. Looks like firstOrError (actually ObservableElementAtSingle) can call upstream cancelation twice.

Code that produces the problem:
```java
BehaviorSubject<Integer> s = BehaviorSubject.create();
s.doOnLifecycle(d -> out.println("subscribe"), () -> { out.println("dispose"); s.onNext(2); })
        .firstOrError().subscribe().dispose();
```
Console output:
```
subscribe
dispose
dispose
```,This is kind of an awkward reentrance problem. I'll have to investigate which components need to suppress dispose calls. =||= ,0
6275,627,Add a parallel execution function for processing a single emitted item over different parallel fucntions,We have the following use case.  We create an observable which emits a single value.  This value passes through a couple of standard Rx map functions sequentially.  After the sequential functions it then needs to have multiple validation functions to be executed concurrently.  These are slow operations, since they require I/O with external systems.  If we can perform them in parallel, we can significantly reduce our users's perceived execution time.

Note that this is different than the current parallel and parallelMap functions.  These perform the same function over multiple emitted items.  I need to perform multiple different functions in parallel over a single emitted value.  It seems that the last step might need to be a zip or similar so that the user can provide an aggregation function and then emit a single value from the result of the parallel aggregation.

Thoughts?,Are you looking for something like this?

``` java
static void sleep(long ms) {
    System.out.println("Sleeping for " + ms + " ms on thread " + Thread.currentThread().getId());
    try {
        Thread.sleep(ms);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

static Observable<Boolean> doExpensiveTestsInParallel(Observable<Integer> obs) {
    return obs.flatMap(new Func1<Integer, Observable<Boolean>>() {
        public Observable<Boolean> call(final Integer i) {
            Func0<Boolean> expensiveTest1 = new Func0<Boolean>() {
                public Boolean call() { sleep(200); return i > 30; }
            };
            Func0<Boolean> expensiveTest2 = new Func0<Boolean>() {
                public Boolean call() { sleep(100); return i % 5 == 2; }
            };
            Func0<Boolean> expensiveTest3 = new Func0<Boolean>() {
                public Boolean call() { sleep(300); return i < 100; }
            };

            return Observable.merge(
                Observable.start(expensiveTest1, Schedulers.threadPoolForIO()),
                Observable.start(expensiveTest2, Schedulers.threadPoolForIO()),
                Observable.start(expensiveTest3, Schedulers.threadPoolForIO())
            ).all(Functions.<Boolean>identity());
        }
    });
}
```
 =||= That's very close.  However in my case the functions themselves are quite complex and touch a lot of integration points.  Rather than have them as embedded functions, I create classes that implements Func1 or Action1.  Therefore, I need the ability to have both Func1 or Action1 to be invoked.  This allows us to unit test each of our complex functions or actions, and receive the input as an argument to the "call" method.
 =||= You can see an example of how we do this at Netflix here: https://speakerdeck.com/benjchristensen/rxjava-goto-aarhus-2013?slide=142

Inside a `flatMap` we kick off multiple async calls (you can do computation whereas we do IO) and then merge or zip them together. Use merge if you don't care about their ordering or getting them back all at once.
 =||= ,0
6278,627,Add a parallel execution function for processing a single emitted item over different parallel fucntions,We have the following use case.  We create an observable which emits a single value.  This value passes through a couple of standard Rx map functions sequentially.  After the sequential functions it then needs to have multiple validation functions to be executed concurrently.  These are slow operations, since they require I/O with external systems.  If we can perform them in parallel, we can significantly reduce our users's perceived execution time.

Note that this is different than the current parallel and parallelMap functions.  These perform the same function over multiple emitted items.  I need to perform multiple different functions in parallel over a single emitted value.  It seems that the last step might need to be a zip or similar so that the user can provide an aggregation function and then emit a single value from the result of the parallel aggregation.

Thoughts?,Are you looking for something like this?

``` java
static void sleep(long ms) {
    System.out.println("Sleeping for " + ms + " ms on thread " + Thread.currentThread().getId());
    try {
        Thread.sleep(ms);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

static Observable<Boolean> doExpensiveTestsInParallel(Observable<Integer> obs) {
    return obs.flatMap(new Func1<Integer, Observable<Boolean>>() {
        public Observable<Boolean> call(final Integer i) {
            Func0<Boolean> expensiveTest1 = new Func0<Boolean>() {
                public Boolean call() { sleep(200); return i > 30; }
            };
            Func0<Boolean> expensiveTest2 = new Func0<Boolean>() {
                public Boolean call() { sleep(100); return i % 5 == 2; }
            };
            Func0<Boolean> expensiveTest3 = new Func0<Boolean>() {
                public Boolean call() { sleep(300); return i < 100; }
            };

            return Observable.merge(
                Observable.start(expensiveTest1, Schedulers.threadPoolForIO()),
                Observable.start(expensiveTest2, Schedulers.threadPoolForIO()),
                Observable.start(expensiveTest3, Schedulers.threadPoolForIO())
            ).all(Functions.<Boolean>identity());
        }
    });
}
```
 =||= That's very close.  However in my case the functions themselves are quite complex and touch a lot of integration points.  Rather than have them as embedded functions, I create classes that implements Func1 or Action1.  Therefore, I need the ability to have both Func1 or Action1 to be invoked.  This allows us to unit test each of our complex functions or actions, and receive the input as an argument to the "call" method.
 =||= You can see an example of how we do this at Netflix here: https://speakerdeck.com/benjchristensen/rxjava-goto-aarhus-2013?slide=142

Inside a `flatMap` we kick off multiple async calls (you can do computation whereas we do IO) and then merge or zip them together. Use merge if you don't care about their ordering or getting them back all at once.
 =||= ,0
6287,6279,Expose the Keep-Alive value of the IO Scheduler as System property.,Currently, the Keep-Alive is 60 seconds constant: [IoScheduler.java#L37](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java#L37). 

The configuration could be done via `Integer.getInteger()` similar to how `priority` is configurable: [L52](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java#L52).

The documentation of [Schedulers.java#L32](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/schedulers/Schedulers.java#L32) and [Schedulers.java#L158](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/schedulers/Schedulers.java#L158) should also describe this option.,nan,0
6287,627,Add a parallel execution function for processing a single emitted item over different parallel fucntions,We have the following use case.  We create an observable which emits a single value.  This value passes through a couple of standard Rx map functions sequentially.  After the sequential functions it then needs to have multiple validation functions to be executed concurrently.  These are slow operations, since they require I/O with external systems.  If we can perform them in parallel, we can significantly reduce our users's perceived execution time.

Note that this is different than the current parallel and parallelMap functions.  These perform the same function over multiple emitted items.  I need to perform multiple different functions in parallel over a single emitted value.  It seems that the last step might need to be a zip or similar so that the user can provide an aggregation function and then emit a single value from the result of the parallel aggregation.

Thoughts?,Are you looking for something like this?

``` java
static void sleep(long ms) {
    System.out.println("Sleeping for " + ms + " ms on thread " + Thread.currentThread().getId());
    try {
        Thread.sleep(ms);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

static Observable<Boolean> doExpensiveTestsInParallel(Observable<Integer> obs) {
    return obs.flatMap(new Func1<Integer, Observable<Boolean>>() {
        public Observable<Boolean> call(final Integer i) {
            Func0<Boolean> expensiveTest1 = new Func0<Boolean>() {
                public Boolean call() { sleep(200); return i > 30; }
            };
            Func0<Boolean> expensiveTest2 = new Func0<Boolean>() {
                public Boolean call() { sleep(100); return i % 5 == 2; }
            };
            Func0<Boolean> expensiveTest3 = new Func0<Boolean>() {
                public Boolean call() { sleep(300); return i < 100; }
            };

            return Observable.merge(
                Observable.start(expensiveTest1, Schedulers.threadPoolForIO()),
                Observable.start(expensiveTest2, Schedulers.threadPoolForIO()),
                Observable.start(expensiveTest3, Schedulers.threadPoolForIO())
            ).all(Functions.<Boolean>identity());
        }
    });
}
```
 =||= That's very close.  However in my case the functions themselves are quite complex and touch a lot of integration points.  Rather than have them as embedded functions, I create classes that implements Func1 or Action1.  Therefore, I need the ability to have both Func1 or Action1 to be invoked.  This allows us to unit test each of our complex functions or actions, and receive the input as an argument to the "call" method.
 =||= You can see an example of how we do this at Netflix here: https://speakerdeck.com/benjchristensen/rxjava-goto-aarhus-2013?slide=142

Inside a `flatMap` we kick off multiple async calls (you can do computation whereas we do IO) and then merge or zip them together. Use merge if you don't care about their ordering or getting them back all at once.
 =||= ,0
6297,629,ToBlockingObservable wraps exception so I can't handle it with try catch,```
try {

Result result = api.getResult(params)
                        .toBlockingObservable()
                        .last();   
} catch (final Throwable e) {
 // cannot catch MyException here because it wrapped with RuntimeException spawned by blockingobservable

   if (e instanceof MyException) {
   }
}
```,Checked exceptions need to be wrapped as the Iterable interface doesn't allow throwing implementations. Therefore, anything that is not subclass of RuntimeException (or Error) is wrapped into a RuntimeException. Use `getCause()` to extract the MyException.
 =||= Using onErrorReturn or other error handling methods of Observable and only blocking at the very end would be better style, since you can use your error handling logic for both non-blocking and blocking code.
 =||= @akarnokd Thanks, I think that should be highlight in docs, because it's not obvious.
@samuelgruetter nice tip!
 =||= It doesn't wrap `RuntimeException` only if it is a checked `Exception`. So is the exception you were expecting a checked `Exception`? If it was a `RuntimeException` then it should have thrown it and your catch would work otherwise we have a bug.
 =||= ,0
6303,6302,Javadoc: Flowable::zipWith image is displayed incorrectly,There is a small problem with the images in the current Javadoc (2.2.3) of the following operators:

- [`Flowable::zipWith(Publisher, BiFunction)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#zipWith-org.reactivestreams.Publisher-io.reactivex.functions.BiFunction-)
- [`Flowable::zipWith(Publisher, BiFunction, boolean)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#zipWith-org.reactivestreams.Publisher-io.reactivex.functions.BiFunction-boolean-)
- [`Flowable::zipWith(Publisher, BiFunction, boolean, int)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#zipWith-org.reactivestreams.Publisher-io.reactivex.functions.BiFunction-boolean-int-)

If the Javadoc is viewed on a wide screen, the images are displayed on the right side instead of the left. I have a screenshot attached where the problem can be seen.

The problem can be resolved by adding `<p>` before the image element.

![screenshot_2018-11-11 flowable rxjava javadoc 2 2 3](https://user-images.githubusercontent.com/12369767/48316512-ec073680-e5e4-11e8-8d20-566b63d32a3e.png),PR welcome =||= ,0
6305,6299,Javadoc: Explain explicitly that the Emitter methods should be called non-concurrently with generate,The Javadocs of the `generate` methods as well the `Emitter` interface should explicitly mention that the methods should be called non-concurrently. Generate can be found in both `Flowable` and `Observable`.

#### generate:

```html
<p>
Note that the {@link Emitter#onNext}, {@link Emitter#onError} and 
{@link Emitter#onComplete} methods provided to the function should be called synchronously,
never concurrently and only while the method is executing. Calling them from multiple threads 
or outside the function call is not supported and leads to an undefined behavior.
```

#### Emitter:

```html
<p>
Note that the {@link Emitter#onNext}, {@link Emitter#onError} and 
{@link Emitter#onComplete} methods provided to the function should be called synchronously,
never concurrently. Calling them from multiple threads is not supported and leads to an 
undefined behavior.
```,I believe calling from multiple threads is supported if there is a happens-before relationship between calls. Perhaps this:
```
<p>
Note that there must be a <i>happens-before</i> relationship between calls to the {@link Emitter#onNext}, {@link Emitter#onError} and 
{@link Emitter#onComplete} methods. Calling those methods from multiple threads without establishing that relationship is not supported and leads to undefined behavior.
``` =||= Fundamentally, the calls should not escape the callback method and one would have to block the callback if the `onNext` happens asynchronously to the method. Still you can only call it once and the blocking implicitly establishes this relationship. =||= Sounds good, thanks @akarnokd  =||= ,0
6308,6289,Javadoc: explain Flowable.groupBy should be consumed on all of its outputs,In order for `Flowable.groupBy` to remain bounded in memory, it uses a prefetch and consumption-based replenishment strategy: when a group has consumed an item, a new item is requested from the source of `groupBy`.

Since a new item may create a fresh group, the only way to move forward is to have that group consumed as well. For this, the `GroupedFlowable` itself has to reach some operator and get subscribed to.

The typical use is with `flatMap` that will subscribe to the groups and keeps consuming them, however, `flatMap` by default works in a limited concurrency mode. It means as long as the groups themselves don't complete, `flatMap` won't accept a newer group, and thus that group will not get consumed, resulting in a potential livelock. The solution is to have a larger max-concurrency as there are number of groups expected, potentially going unbounded with `flatMap` completely.

This is not an issue with `Observable.groupBy` because there is no backpressure and non-consumed groups can't hinder active groups.

I suggest extending the JavaDocs of all `Flowable.groupBy` about this property, something along the lines of:

```html
<p>
Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise, 
the unconsumed groups may starve other groups due to the internal backpressure
coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using 
{@link #flatMap} or {@link #concatMapEager} and overriding the default maximum concurrency 
value to be greater or equal to the expected number of groups, possibly using 
{@link Integer.MAX_VALUE} if the number of expected groups is unknown.
```

(Please when writing the `{@link #}`s out, pick the shortest overload of the respective method that also includes the `maxConcurrency` parameter. Your IDE's content assist should help you in this regard.),Ah, this has been done in #6308. Closing. =||= ,0
6311,6290,Javadoc: explain that distinctUntilChanged requires non-mutating data to work as expected,`distinctUntilChanged` keeps the last value/key (depending on the overload) so it can compare it agains the newer value/key via `Object.equals`. However, if the value/key is mutable and gets mutated in between elements, the operator may not work as expected and filter out the seemingly same data:

```java
PublishSubject<List<Integer>> subject = PublishSubject.create();
List<Integer> list = new ArrayList<Integer>();
list.add(1);

subject.distinctUntilChanged().subscribe(System.out::println);

subject.onNext(list);
// prints [1]

list.add(2);

subject.onNext(list);
// does not print anything, but [1, 2] was expected.
```

In the example, the same reference is passed to `distinctUntilChanged` thus two subsequent items evaluate as same. This mistake by the user is also very common on Android and with text components using a mutable `CharSequence`.

I suggest adding a section to every `distinctUntilChanged` variant explaining the situation in short, something along the lines:

```
<p>
Note that if the element type of the flow is mutable, the comparison of the previous and current 
item may yield unexpected results if the items are mutated externally. Common cases are mutable
{@code CharSequence}s or {@code List}s where subsequent objects are actually the same 
references modified before/after {@code distinctUntilChanged}. It is recommended mutable data is
converted to an immutable one, such as `map(CharSequence::toString)` or 
`map(Collections::unmodifiableList)` for example, to avoid the situation.
```,Nice. Never actually thought of this case. Very valid. :tada: 

Few questions before the PR. 
1. This should reflect on withLatestForm variants for `Observable` & `Flowable` types right?
2. Additionally, will it be okay to link this issue to the doc for clarity? =||= Hi.

1. It's about the `distinctUntilChanged` where this mutation is most obviously affecting a flow. All overloads in both `Observable` and `Flowable` should be updated.
2. We don't link to issues in the main javadoc. =||= ,0
6313,630,Exception in onCompleted() not propagate to onError(),When an exception occurred in onCompleted() the exception is not propagate to onError().

Code of rx.operators.SafeObserver

```
    @Override
    public void onCompleted() {
        if (isFinished.compareAndSet(false, true)) {
            try {
                actual.onCompleted();
            } catch (Throwable e) {
                // handle errors if the onCompleted implementation fails, not just if the Observable fails
                onError(e);
            }
            // auto-unsubscribe
            subscription.unsubscribe();
        }
    }
```

In our case isFinished is already TRUE, so onError does nothing.

```
 @Override
    public void onError(Throwable e) {
        if (isFinished.compareAndSet(false, true)) {
           ...
        }
    }
```,That's intentional. According to Rx Contract, A observer should not receive both onCompleted and onError. You need to handle the exception in onCompleted by yourself.

![2013-12-17 7 38 00](https://f.cloud.github.com/assets/1000778/1763512/eab38080-670f-11e3-819b-385674e19cbb.png)
 =||= Ok the contract is clear.

So, I don't understand why in **SafeObserver** there is this code

```
catch (Throwable e) {
    // handle errors if the onCompleted implementation fails, not just if the Observable fails
    onError(e);
}
```

It's in contradiction with the grammar and because **isFinished** is set to **true** so this call is _useless_.

Why not call a global errorHandler or something like that in the _catch_ ?

I don't understand.

Regards,
Ronan.
 =||= Ha, yep that code is pretty useless. Kind of funny ... I'll submit a fix shortly.
 =||= ,0
6321,632,NewThreadScheduler thread exhaustion,The current implementation of `NewThreadScheduler` creates a new ThreadPoolExecutor for each non-recursive schedule invocation. The pool is never terminated (except when the application terminates), therefore, pools no longer in use still keep one thread active (blocked on waiting for the next task which can't arrive). If too many pools are created, the operating system might run out of fresh threads, causing "native thread creation failed" throughout the application. To demonstrate the problem, here is a small test case:

``` java
public class NewThreadSchedulerTest {
    @Test
    public void testExhaustion() throws InterruptedException {
        Scheduler s = Schedulers.newThread();
        BlockingObservable<Integer> source = Observable.from(1)
                .subscribeOn(s).toBlockingObservable();
        for (int i = 0; i < 10000; i++) {
            Assert.assertEquals((Integer)1, source.single());
        }
    }
}
```

(This test fails on my Windows 7 x86 after about 4000 iterations.)

Its equivalent Rx.NET code, however, works fine:

``` C#
class Program {
        static void Main(string[] args) {
            IScheduler s = NewThreadScheduler.Default;
            IObservable<int> source = Observable.ToObservable(new int[] { 1 }, s)
                    .SubscribeOn(s);
            int sum = 0;
            for (int i = 0; i < 10000; i++) {
                sum += source.Single();
                Thread.Sleep(1);
                if (i % 256 == 0) {
                    Console.Write(i);
                    Console.Write(": ");
                    Console.WriteLine(sum);
                }
            }
        }
    }
```

The program's thread count remains about 15. (It seems that RxNET uses vanilla threads in combination with some kind of CurrentThreadScheduler in it and has an explicit option to quit if no more tasks are queued or pending).

I've tried to fix NewThreadScheduler by setting a keepalive on the thread pool, but unfortunately it breaks the `OperationParallelMergeTest` because a restarted thread in the thread pool will get a different identifier. I've tried adding wip counter to capture when to terminate the pool, but didn't work (probably due escaped scheduler reference is invoked outside the callback function/action).

Any ideas?,I think the issue is two-fold:

1) NewThreadScheduler does not shutdown the executor in the subscription it returns

2) BlockingObservable does not obey guideline 4.3 and unsubscribe when it completes. Generally we rely upon a user provided Observer and the SafeObserver doing this, but BlockingObservable never receives a user provided Observer.

```
4.3. Assume resources are cleaned up after an OnError or OnCompleted
message
Paragraph 4.1 states that no more messages should arrive after an OnError or OnCompleted message. This makes it possible to cleanup any resource used by the subscription the moment an OnError or OnCompleted arrives. Cleaning up resources immediately will make sure that any side-effect occurs in a predictable fashion. It also makes sure that the runtime can reclaim these resources.
Sample
Observable.Using(
() => new FileStream(@"d:\temp\test.txt", FileMode.Create), fs => Observable.Range(0, 10000)
.Select(v => Encoding.ASCII.GetBytes(v.ToString()))
            .WriteToStream(fs))
        .Subscribe();
In this sample the Using operator creates a resource that will be disposed upon unsubscription. The Rx contract for cleanup ensures that unsubscription will be called automatically once an OnError or OnCompleted message is sent.
```
 =||= I'm working on this.
 =||= I've confirmed it's what I thought ... the `BlockingObservable` doesn't call `unsubscribe` when `onComplete`/`onError` happen and thus the resources are not freed. The example code works fine if `BlockingObservable` is not involved and a normal async `subscribe` is used.
 =||= Before fixing BO, would it be possible to merge our PRs changing the same files so we don't have to rebase everything again?

Unfortunately, there is no good way to detect if an iteration has stopped in Java. We can have a forEach overload that takes a predicate.
 =||= Yeah I can merge it. I intend on working more on this tonight, just haven't had time to finish it during my day hours.

For an iteration stopping, isn't it sufficient to know that we have exited that block of code and just have the 'completion marker' style thing invoked right after we exit the iteration?
 =||= When Java 7 introduced the `DirectoryStream`, they faced a similar issue: one would need to call `close` on the Iterator but then you can't use for-each loop for enumeration. The solution was to have `DirectoryStream` `Closeable` and return only a single `Iterator`, therefore, this pattern is established:

``` java
try (DirectoryStream ds = list("*")) {
   for (Path p : ds) {
      if (p.toString().endsWith(".xml")) {
         break;
      }
   }
}
```

We can have a `BlockingObservable.onetimeIterable()` returning an `IterableUnsubscribable` instance and require a similar pattern.

Alternatively, the following forEach overload could do the trick:

``` java
BlockingObservable.forEachUntil(Func1<T, Boolean> breakoutConsumer);
```

Where the function `breakoutConsumer` should return true if it wishes to continue the loop.
 =||= That seems to solve a different problem, breaking out of a `forEach` loop on an infinite stream as opposed to knowing when it completes. 

The `takeUntil` operator already enables conditionally breaking an infinite stream, `forEachUntil` is just merging those together. 

What exactly is the use case you were referring to for this statement => "there is no good way to detect if an iteration has stopped in Java"?
 =||= The `TakeUntil` seems to be appropriate, but we still need a BO.await() to run to run through the results and block.

A case:

``` java
public Integer one() {
return Observable.from(1).subscibeOn(Schedulers.threadPoolForComputation())
.repeat().toBlockingObservable().toIterable().iterator().next();
}
```

We don't have the IDisposable in Java, which seems to handle exactly these issues.
 =||= What is the issue in that code example other than the one we already know that causes `BlockingObservable` to not correctly unsubscribe?
 =||= Up to the `toBlockingObservable()`, it is an infinite stream of 1s. We take the first value of this stream and leave the whole thing. There is no way the BO can detect that nothing is iterating it further and can't stop because the upstream won't complete. One would need a way to tell the Iterator to stop.
 =||= I'd argue that .next() on an infinite iterator is bad code. Same way that calling `toList()` on an infinite stream is bad code.
 =||= Yes, if you know that it is an infinite iterator. The example could feature a 

``` java
range(1, 10000000).scheduleOn(Schedulers.threadPoolForComputation())
.toBlockingObservable().toIterable().iterator().next()
```

which it is finite yet wasteful. We could return a subclass of `Iterable` and `Iterator` that allow unsubscribing. When someone uses the `StoppableIterable` and `StoppableIterator` without calling stop, that is definitely a bad code. When you have just the `Iterable`, there is no contract or way to do the stopping. Similar problem appeared with Streams in the Lambda-dev recently.
 =||= Closing this as the original test case now passes as expected.
 =||= ,0
6324,6323,"Problem Solving Examples in RxJava" not written in Java,The examples in the "Problem Solving Examples in RxJava" section of the wiki do not seem to be written in Java.

https://github.com/ReactiveX/RxJava/wiki/Problem-Solving-Examples-in-RxJava,Indeed, many of the wiki pages remained from the early days where this repo was poliglot. You are welcome to turn them into Java (8) examples. =||= Hello hello, can i take care this? =||= @hoangnam2261 Sure! =||= Closing via #6324 =||= ,0
6359,6358,2.x: Disposable already set! using delaySubscription with takeUntil/repeatWhen,Issue encountered in: io.reactivex.rxjava2:rxjava:2.2.4

When using a combination of takeUntil/repeatWhen operators on an Observable with delaySubscription operator applied, it is possible to encounter a ProtocolViolationException: Disposable already set! thrown by RepeatWhenObserver#onSubscribe. It appears that if delaySubscription uses an ObservableSource which rapidly/concurrently emits multiple notifications a rare race condition leads to a double subscription issue.

I am not sure if this issue is a user error (take(1) on ObservableSource supplied to delaySubscription alleviates it) or a bug in RxJava however the following, slow unit test demonstrates it:

```java

    @Test
    public void delaySubscriptionWithRepeatWhen() {
        List<Throwable> errors = TestHelper.trackPluginErrors();

        ExecutorService executor = Executors.newFixedThreadPool(2);
        try {
            Observable<Object> subscriptionSignal = Observable.merge(
                    Observable.just(new Object()).delay(0, TimeUnit.MILLISECONDS),
                    Observable.just(new Object()).delay(0, TimeUnit.MILLISECONDS)
            );

            final Subject<Boolean> boolStream = PublishSubject.<Boolean>create().toSerialized();

            Observable<Boolean> brokenStream = boolStream
                    .delaySubscription(subscriptionSignal)
                    .takeUntil(new Predicate<Boolean>()  {
                        @Override
                        public boolean test(Boolean state) throws Exception {
                            return state;
                        }
                    })
                    .repeatWhen(new Function<Observable<Object>, ObservableSource<?>>() {
                        @Override
                        public ObservableSource<?> apply(Observable<Object> objectObservable) throws Exception {
                            return boolStream.filter(new Predicate<Boolean>() {
                                @Override
                                public boolean test(Boolean state) throws Exception {
                                    return !state;
                                }
                            });
                        }
                    });

            final Random random = new Random();
            for (int i = 0; i < 1000000; i++) {
                final TestObserver<Boolean> testObserver = brokenStream.test();
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        boolStream.onNext(random.nextBoolean());
                        testObserver
                                .assertNoErrors()
                                .dispose();
                    }
                });
                if (!errors.isEmpty()) {
                    fail("Uncaught fatal errors: " + errors);
                }
            }
        } finally {
            executor.shutdown();
            try {
                executor.awaitTermination(30, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
            }
        }
    }
```,I've tried the test provided but didn't get any protocol violations with 2.2.5. Please provide a stacktrace of the actual error. =||= @akarnokd here is the stacktrace:

```
java.lang.AssertionError: Uncaught fatal errors: io.reactivex.exceptions.ProtocolViolationException: Disposable already set!
	at io.reactivex.internal.disposables.DisposableHelper.reportDisposableSet(DisposableHelper.java:156)
	at io.reactivex.internal.disposables.DisposableHelper.setOnce(DisposableHelper.java:82)
	at io.reactivex.internal.operators.observable.ObservableRepeatWhen$RepeatWhenObserver.onSubscribe(ObservableRepeatWhen.java:95)
	at io.reactivex.internal.operators.observable.ObservableTakeUntilPredicate$TakeUntilPredicateObserver.onSubscribe(ObservableTakeUntilPredicate.java:49)
	at io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther.subscribeActual(ObservableDelaySubscriptionOther.java:39)
	at io.reactivex.Observable.subscribe(Observable.java:12246)
	at io.reactivex.internal.operators.observable.ObservableTakeUntilPredicate.subscribeActual(ObservableTakeUntilPredicate.java:32)
	at io.reactivex.Observable.subscribe(Observable.java:12246)
	at io.reactivex.internal.operators.observable.ObservableRepeatWhen$RepeatWhenObserver.subscribeNext(ObservableRepeatWhen.java:151)
	at io.reactivex.internal.operators.observable.ObservableRepeatWhen.subscribeActual(ObservableRepeatWhen.java:60)
	at io.reactivex.Observable.subscribe(Observable.java:12246)
	at io.reactivex.Observable.test(Observable.java:15441)
	at io.reactivex.internal.operators.observable.ObservableDelayTest.delaySubscriptionWithRepeatWhen(ObservableDelayTest.java:1020)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

``` =||= Thanks. This is a race condition due to that flooding "repeat" signal and `active` set to false before the previous `Disposable` is cleared. The `retryWhen` is implemented correctly in this regard. I'll post a fix shortly. =||= ,0
6364,636,Operators BO.chunkify, BO.collect, O.forIterable,Issue #634

Any suggestions for a name instead of `forIterable`?,[RxJava-pull-requests #566](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/566/) SUCCESS
This pull request looks good
 =||= Split into two.
 =||= ,0
6370,636,Operators BO.chunkify, BO.collect, O.forIterable,Issue #634

Any suggestions for a name instead of `forIterable`?,[RxJava-pull-requests #566](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/566/) SUCCESS
This pull request looks good
 =||= Split into two.
 =||= ,0
6375,637,Why subscribe with single action for onNext design to crush if error happened?,Why subscribe with single action for onNext designed to crush if error happened? I thought that missing of onError should just silently fail.

observable1.subscribe(new Action1<MyResult>() {}); // will crush if onError is called

What is preferred way to subscribe if I want silently fail onError? Using my own observer?,I can't tell the reason, but we have the following overload:

`Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError)`

where you can specify your error handler. Alternatively, you need to implement `Observer<T>` to get all 3 kinds of events.
 =||= I don't see this as being any different than writing regular code without a try/catch and then a RuntimeException being thrown. If error handling is ignored and a RuntimeException occurs it will throw.

Absence of an error handler should not mean "swallow errors silently and fail without any way of knowing something happened". That results in very non-obvious bugs and bad system operations. If errors want to be swallowed that needs to be a conscious choice.

Two simple approaches that come to mind for swallowing errors are:

1) An empty handler can be passed in (such as to the overload @akarnokd mentioned) or a fully qualified implementation of `Observer` with the `onError` method doing nothing. 

Using the overloads though allows code such as:

``` groovy
observableWithError.subscribe({ value -> println(value)}, {throwable -> /* do nothing */})
```

2) Use the `onErrorResumeNext` operator in your sequence and make it return `Observable.empty()`

``` groovy
observableWithError.onErrorResumeNext(Observable.empty()).subscribe({ value -> println(value)})
```

Hope this helps.
 =||= Is this answered sufficiently or do you still think something is done wrong?
 =||= @benjchristensen Yeah. I thinks it's clear now. Thanks a lot!
 =||= ,0
6377,6288,Javadoc: expand debounce() docs to explain possible interruption,`debounce` schedules a timeout which then emits the last item if no newer item arrives in the meantime. However, if the processing takes too long, a newer item may arrive and the previous task will get disposed, possibly interrupting the long running work.

The `Flowable.debounce` and `Observable.debounce` JavaDocs should mention this property for clarity, something along the lines:

```html
<p>
Delivery of the item after the grace period happens on the (default|given) {@code Scheduler}'s 
{@code Worker} which if takes too long, a newer item may arrive from the upstream, causing the 
{@code Worker}'s task to get disposed, which may also interrupt any downstream blocking operation
(yielding an {@code InterruptedException}). It is recommended processing items
that may take long time to be moved to another thread via {@link #observeOn} applied after 
{@code debounce} itself.
```,nan,0
6386,6379,Add doOnTerminate to Single/Maybe for consistency,As mentioned in #5814, there is no `doOnTerminate` operator on `Single` or `Maybe`, but there is on `Observable`, `Flowable` and `Completable`. There doesn't seem to be any reason for this inconsistency, other than it's just an omission. 

Yes, you can workaround this using `donOnEvent`, but can we instead get this operator added just for API consistency?,Okay, PR welcome. =||= @akarnokd, I would like to contribute to this feature, is this issue free to work on? However, even though it seems pretty straightforward, I'm new to this project and it may take some time for me to submit a final PR, is it acceptable? I don't want to block if it's an urgent need and can be done by somebody else in a faster manner. Thanks. =||= Nobody has started working on this to my knowledge. I suggest you do it either way so you gain experience with doing PRs as well as creating RxJava operators. =||= Thanks for the tip. Will do. =||= ,0
6405,640,Scala Publish,The current Scala bindings for publish are as follows:

  def publish: (() => Subscription, Observable[T]) = {
    val javaCO = asJavaObservable.publish()
    (() => javaCO.connect(), toScalaObservable[T](javaCO))
  }

This has a couple of downsides
- It forces every caller has to invent names for the two pieces, whereas they already have  names given by the callee.
  
  val (foo, bar) = baz.publish()

vs

  val bar = baz.publish()
  bar.subscribe(..)
  bar.connect
- It hides the fact that publish returns a connectable observable, so you cannot call refcount.
- Why split up a nice object into a tuple of unrelated things. Maybe that makes sense if you want to pass the two pieces around separately, but that is typically not the case of connectable observables.

If I don't hear anyone screaming loudly, I am going to change this to mimic the Java signature.,When I came up with this `(() => Subscription, Observable)` pattern, the Scala Observable extended `AnyVal`, so it was final and I could not make a `ConnectableObservable` extending it. But now this problem is gone, so I think it makes sense to replace `(() => Subscription, Observable)` by `ConnectableObservable` (of course, not only in `publish`, but also in `multicast` and `replay`).

There's a similar situation with `groupBy`: In Java, we have a `GroupedObservable<K, T>`, and in Scala we have a `Observable[(K, Observable[T])]`. Here, however, I wouldn't change anything, because an Observable emitting tuples which map keys to Observables makes more sense than claiming that the key is part of the Observable, and also, the tuples allow nice for comprehensions like `for ((key, obs) <- o.groupBy(...))`.
 =||= @headinthebox @samuelgruetter Has this been resolved?
 =||= Should be resolved in #1160
 =||= ,0
6408,6276,flattenAsFlowable wrong wording in Javadocs,The wording of `Single.flattenAsFlowable` is a bit off:

> "Returns a Flowable that **merges each item emitted by the source Single with the values in an Iterable corresponding to that item that is generated by a selector.**"

In contrast, `flattenAsObservable` is somewhat better:

> "Returns an Observable that maps a success value into an Iterable and emits its items."

I'd say something along the lines of:

"Maps the success value of the upstream `{@code Single}` into an `{@link Iterable}` and emits its items as an `{@link Observable}` sequence."

The `Maybe` variants have the same issues (they were copy-pasted back then).,Hi @akarnokd  I would like to start working on this. Could you please give me some heads up ?  =||= > Could you please give me some heads up ?

Nobody has started working on this yet so go ahead. =||= @dilantha111 Have you finished working on this? =||= @freakomonk  Nope. Just got some other things coming up. If you are willing to do that, please go ahead. At the moment stuck with some other stuffs.  =||= @dilantha111 Since I have finished some other issue as my first bug, I don't think its fair for me to take this up too. So leaving it open for others to take it. =||= @freakomonk Unfortunately, people are not lining up to work on issues right now so I suggest you do as much as you like and not worry about taking away opportunities. =||= @akarnokd Sure David. Will take it up tomorrow. =||= @akarnokd I would like to work on this =||= @thiyagu-7 Sure! =||= ,0
6432,6430,2.x "d is null" message for CompositeDisposable add and addall,Affects version: 2.2.7 (and before)

Message "d is null" for errors in CompositeDisposable's add and addall methods is not very helpfull.,nan,0
6436,6435,Wiki improve: Observable.fromArray(),Hey guys just  a little suggestion over the use of
 `Observable.fromArray()` 
in wiki pages,
 seems to have used the
 `Observable.fromIterable(list);` instead of `Observable.fromArray(array);`
Here is link to page 
https://github.com/ReactiveX/RxJava/wiki/Creating-Observables#fromarray
Please change if applicable thanks.,Hi, you can post a PR against https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md =||= I would like to add that there are more issues on that wiki page that could be resolved along with the mentioned problem:

- Missing parentheses in the second [`just`](https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md#just) example: `error.printStackTrace` instead of `error.printStackTrace()`.
- [`fromFuture`](https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md#fromfuture-example), [`create`](https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md#create-example): `Executors.newSingleThreadedScheduledExecutor()` instead of `Executors.newSingleThreadScheduledExecutor()`.
- [`range`](https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md#range-example): typo `erro`. `Char` should be `Character`.
- [`error`](https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md#error-example): variable `error` is defined twice. =||= hey @akarnokd  i just opened a PR with included suggestions from @lorenzpahl also.
https://github.com/ReactiveX/RxJava/pull/6436
Please merge them.
Thanks 😃  =||= ,0
6452,6451,Unnecessary dependency on Schedulers.trampoline() for non-time-based refcount operator,In the constructor of `ObservableRefCount` that takes `ConnectableObservable<T> source` as the argument, we set `timeout` to `0L`. In that specific use case of `ObservableRefCount`, `scheduler` is never needed. It's only referenced in `cancel()` method but if `timeout` is 0, it won't be triggered at all because there is early return. I am wondering if we could avoid referencing `Schedulers.trampoline()` in that specific use case of `ObservableRefCount` to keep the dependency clear.

https://github.com/ReactiveX/RxJava/blob/4a78cfcbf2f0d7008042c15ea8bb6797fcd2b06e/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java#L48-L50
https://github.com/ReactiveX/RxJava/blob/4a78cfcbf2f0d7008042c15ea8bb6797fcd2b06e/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java#L92-L112
The reasons are the following:

1. In projects that don't depend on `Schedulers` class, if there is no reference to `Schedulers`, the whole `Schedulers` can be stripped out of the library after optimizations (e.g., proguard). With constructor that references `Schedulers`, the optimizer can't properly strip it out. In our quick test of our Android app, we were able to reduce the RxJava library size dependency from 51KB to 37KB (after optimization but before compression) by simply avoiding access to `Schedulers` in `ObservableRefCount`.
2. In terms of modularity, `ObservableRefCount` is just an operator so it by itself should probably not have dependency on what available pool of schedulers (`Schedulers`) there are. It should just know that there is some `Scheduler` that could be passed to `ObservableRefCount` when `ObservableRefCount` needs it.
,Yes, it can be replaced by `null`. PR welcome. =||= ,0
6458,6402,Error in documentation of Observable .retry(n) ,There appears to be an error in the 2.x Javadoc for the `retry( n )` operator of `Observable`. `n` is referred to as "number of retry attempts before failing" but the accompanying marble diagram shows only a single retry when `retry(2)` is called. 

Does `n` indicate the total number of subscriptions including the first one? ,Hello. You could write a small program to find it out and if there is a documentation mistake, you are welcome to post a PR. =||= My test program (below) shows that the `n` argument does NOT include the initial attempt to subscribe, thus `retry( 10 )` gives a total of 11 subscriptions. 

The easiest doc fix would be to change the large `retry(2)` in the marble diagram to `retry(1)` but I have no facility for doing that. (The Javadoc for `Single` doesn't include a marble diagram, but the text description is correct.) 

```
Disposable retryDisp = Observable.error( new SocketTimeoutException() )

                .doOnSubscribe( disp -> System.out.println( "Subscribe count is now " + ++subCount ) )

                .doOnError( err -> System.out.println( "Error count is now " + ++errCount ) )

                .retry( 10 )  // gives a total of 11 subscriptions & 11 errors

                .subscribe(
                        item -> System.out.println( "We never see this" ),
                        err -> System.out.println( "Without this we get a 'missing error handler' crash" )
                );
``` =||= Does anyone work on this issue?
Also, the function parameter `times` is described as "the number of times to repeat" and could be mixed with the `repeat` operator. I think that's an opportunity to improve the Javadoc of `public final Observable<T> retry(long times, Predicate<? super Throwable> predicate)` at the same time. =||= @RomanWuattier Nobody seems to work on this so you are welcome if you want. =||= Closing via #5458. =||= ,0
6461,6460,fromArray to report Element at index $i is null,Currently, `Observable.fromArray` says `The $i th element is null`, which is a bit misleading as `i` is the element index. Update the error message to `The element at index $i is null`. The `Flowable` version should be updated if necessary. Note that the null checks appear multiple places.,Closing via #6461 =||= ,0
6469,646,Operator BO.forEachFuture,Issue #634

I tried to find a random place in BO but it is likely this or the other PRs will not merge one after another.,[RxJava-pull-requests #578](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/578/) SUCCESS
This pull request looks good
 =||= In Rx.Net it had clean design with `Task` and `async/await`. In Java we don't. This (and other similar pull requests) don't make much sense and are greatly complicating the API.

In Java the `Future`/`FutureTask`/`Callable`/`Runnable`/`CompletableFuture` set of classes do not play well with the non-blocking/reactive style of Rx, nor is there good conformity across JVM languages (Scala, Groovy, Clojure with different concurrency models and libraries) or even Java libraries (such as Guava and Akka).

I think that all of these additions you are proposing related to `java.util.concurrent` interop should be pushed into a separate contrib module and not part of core. Perhaps `rxjava-contrib/rxjava-java-future` or something along those lines?

In short, the goal is to keep rxjava-core focused on the basics of `Observable` and non-blocking operators. Interop with the various different approaches to concurrency should be kept separate. In retrospect even the `Async.java` stuff should likely be moved out to this new contrib module. 
 =||= Yes, a contrib module would be much cleaner.
 =||= Great, I'm glad we agree. I'll setup the module for you.
 =||= Merge these into https://github.com/Netflix/RxJava/pull/696 instead.
 =||= ,0
6480,6479,Example in readme gives me compilation error,I'm trying the examples provided in the readme file and in specifically [this one](https://github.com/ReactiveX/RxJava#dependent-sub-flows) I got a compilation error in the map() method (Cannot return a void result)  :

```
Flowable<Inventory> inventorySource = warehouse.getInventoryAsync();

inventorySource.flatMap(inventoryItem ->
    erp.getDemandAsync(inventoryItem.getId())
    .map(demand 
        -> System.out.println("Item " + inventoryItem.getName() + " has demand " + demand));
  )
  .subscribe();
```
It should be something like this, isn't?:
```
        inventorySource
                .flatMap(inventoryItem -> demandService
                        .getDemandAsync(inventoryItem.getId())
                        .map(demand -> "Item " + inventoryItem.getName()
                                + " has demand " + demand.getQtd()))
                .subscribe(System.out::println);
```,Yes. PR welcome. =||= Closing via #6480. =||= ,0
6483,6481,Maybe.count doc typo,![Screenshot from 2019-05-20 10-07-12](https://user-images.githubusercontent.com/4783372/57992533-467ad580-7ae7-11e9-8e17-6964b841c8b5.png)

Says here that it "returns a Maybe" when in fact it returns a Single.,PR welcome. =||= ,0
6488,648,Reentrant scheduling2,Revised version of PR #643.
- Added `scheduleRunnable()` overloads to `Scheduler` directly to avoid constant wrapping between `Runnable` and `Action0`.
- Removed the helper interface.
- Reworked `ReentrantScheduler` to work with a parent scheduler directly.
- Replaced `ForwardSubscription` with `IncrementalSubscription` as the first one didn't correctly managed the orderly nature of swapping subscriptions: an unfortunate thread scheduling could have swapped in an older subscription before a new subscription.

In my opinion, the `Scheduler` and its implementations should use `Runnable` as the internal unit of work instead of `Action0`. Since the `Executor`s require `Runnable` anyway, less wrapping means less memory and better performance. The `Scheduler` interface can retain the `Action0` overloads but no other implementation should need to deal with them.,[RxJava-pull-requests #582](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/582/) SUCCESS
This pull request looks good
 =||= This seems like it's a bug inside current Schedulers as recursion should work without memory leaks. Here is the histogram showing the leak:

```
JVM version is 24.45-b08
Iterating over heap. This may take a while...
Object Histogram:

num       #instances    #bytes  Class description
--------------------------------------------------------------------------
1:      1488649 83360752    java.lang.Object[]
2:      2976652 47626432    java.util.concurrent.atomic.AtomicReference
3:      1488325 47626400    rx.schedulers.DiscardableAction
4:      1488324 47626368    java.util.concurrent.FutureTask
5:      1488330 35719920    java.util.ArrayList
6:      1488324 35719776    rx.subscriptions.CompositeSubscription$State
7:      1488456 23815296    java.lang.Integer
8:      1488326 23813216    java.util.concurrent.atomic.AtomicBoolean
9:      1488326 23813216    rx.operators.SafeObservableSubscription
10:     1488325 23813200    rx.subscriptions.CompositeSubscription
11:     1488324 23813184    rx.subscriptions.Subscriptions$3
12:     7036    905920  * MethodKlass
13:     7036    813896  * ConstMethodKlass
14:     499 567648  * ConstantPoolKlass
15:     499 348832  * InstanceKlassKlass
16:     447 339168  * ConstantPoolCacheKlass
17:     2051    148592  char[]
18:     702 106856  byte[]
19:     569 68872   java.lang.Class
20:     830 52568   * System ObjArray
21:     2027    48648   java.lang.String
22:     769 44128   short[]
23:     124 40800   * MethodDataKlass
24:     785 31400   java.util.TreeMap$Entry
25:     53  28408   * ObjArrayKlassKlass
26:     138 9936    java.lang.reflect.Field
27:     218 6976    java.util.concurrent.ConcurrentHashMap$HashEntry
28:     192 6568    java.lang.String[]
29:     138 4416    java.util.HashMap$Entry
30:     8   4288    * TypeArrayKlassKlass
31:     178 4272    java.util.LinkedList$Node
32:     116 3712    java.util.Hashtable$Entry
33:     97  3104    java.util.LinkedList
34:     193 3088    java.lang.Object
35:     46  2944    java.net.URL
36:     30  2848    java.util.HashMap$Entry[]
37:     66  2704    java.util.concurrent.ConcurrentHashMap$HashEntry[]
38:     66  2640    java.util.concurrent.ConcurrentHashMap$Segment
39:     72  2304    java.util.concurrent.locks.ReentrantLock$NonfairSync
40:     11  2288    * KlassKlass
41:     38  1824    sun.util.locale.LocaleObjectCache$CacheEntry
42:     36  1728    java.util.HashMap
43:     5   1696    int[]
44:     36  1440    java.util.LinkedHashMap$Entry
45:     18  1296    java.lang.reflect.Constructor
46:     16  1280    java.util.WeakHashMap$Entry[]
47:     1   1040    java.lang.Integer[]
48:     26  1040    java.lang.ref.SoftReference
49:     6   992 java.util.Hashtable$Entry[]
50:     16  896 java.util.WeakHashMap
51:     21  840 java.lang.ref.Finalizer
```

I will dig in to where this leak is occurring. We should not need new subscription or scheduler types to solve this, otherwise anything using schedulers is broken. 

Code in Java 6 for proving the leak as modified from the original Java 8 bug report:

``` java
/**
     * Generates an observable sequence by iterating a state from an initial
     * state until the condition returns false.
     */
    public static <TState, R> OnSubscribeFunc<R> generate(
            final TState initialState,
            final Func1<TState, Boolean> condition,
            final Func1<TState, TState> iterate,
            final Func1<TState, R> resultSelector,
            final Scheduler scheduler) {
        return new OnSubscribeFunc<R>() {
            @Override
            public Subscription onSubscribe(final Observer<? super R> observer) {
                return scheduler.schedule(initialState, new Func2<Scheduler, TState, Subscription>() {
                    @Override
                    public Subscription call(Scheduler s, TState state) {
                        boolean hasNext;
                        try {
                            hasNext = condition.call(state);
                        } catch (Throwable t) {
                            observer.onError(t);
                            return Subscriptions.empty();
                        }
                        if (hasNext) {
                            R result;
                            try {
                                result = resultSelector.call(state);
                            } catch (Throwable t) {
                                observer.onError(t);
                                return Subscriptions.empty();
                            }
                            observer.onNext(result);

                            TState nextState;
                            try {
                                nextState = iterate.call(state);
                            } catch (Throwable t) {
                                observer.onError(t);
                                return Subscriptions.empty();
                            }

                            return s.schedule(nextState, this);
                        }
                        observer.onCompleted();
                        return Subscriptions.empty();
                    }
                });
            }
        };
    }

    public static void main(String[] args) throws Exception {

//        Thread.sleep(10000);

        Observable<Integer> source = Observable.create(generate(
                0, new Func1<Integer, Boolean>() {

                    @Override
                    public Boolean call(Integer t1) {
                        return true;
                    }
                },
                new Func1<Integer, Integer>() {

                    @Override
                    public Integer call(Integer t) {
                        return t + 1;
                    }
                },
                new Func1<Integer, Integer>() {

                    @Override
                    public Integer call(Integer t) {
                        return t;
                    }
                }, Schedulers.newThread()));

        final CountDownLatch latch = new CountDownLatch(1);
        Subscription s = source.subscribe(new Observer<Integer>() {

            @Override
            public void onCompleted() {
                latch.countDown();
            }

            @Override
            public void onError(Throwable e) {
                e.printStackTrace();
                latch.countDown();
            }

            @Override
            public void onNext(Integer v) {
                if (v % 100000 == 0) {
                    System.out.println(v);
                }
                if (v >= 10000000) {
                    latch.countDown();
                }
            }
        });

        latch.await();

        System.out.println("Wait done.");

        s.unsubscribe();

        System.out.println("Unsubscribe done.");
    }
```

@headinthebox will try in .Net
 =||= This memory leak is fixed in https://github.com/Netflix/RxJava/pull/712
 =||= ,0
6505,6501,publish().refCount() race may leave observers hanging,This test eventually times out because one of the sources will not complete or trigger a reconnection:

```java
for (int i = 0; i < 10_000; i++) {
    Observable<Integer> observable = Observable.just(1).publish().refCount();

    TestObserver<Integer> observer1 = observable
        .subscribeOn(Schedulers.computation())
        .test();

        TestObserver<Integer> observer2 = observable
        .subscribeOn(Schedulers.computation())
        .test();

    observer1
        .withTag("observer1 " + i)
        .awaitDone(5, TimeUnit.SECONDS)
        .assertNoErrors()
        .assertComplete();

    observer2
        .withTag("observer2 " + i)
        .awaitDone(5, TimeUnit.SECONDS)
        .assertNoErrors()
        .assertComplete();
}
```

(Originally reported as a [comment](https://github.com/ReactiveX/RxJava/pull/6187#issuecomment-501879711).),In our anecdotal case, it's an observable that gets disposed and therefore cancels the HTTP request, while the next subscriber receives the immediately-canceled stream from the first subscriber.

Something like:

    val apiRequest: Observable<Foo> = retrofit.apiRequest()...share()

    // subscriber 1, main thread:
    val disposable = apiRequest....subscribeOn(Schedulers.io()).subscribe(...)
    ...
    disposable.dispose()
    
    // subscriber 2, also main thread:
    val disposable = apiRequest....subsribeOn(Schedulers.io()).subscribe(...)

Subscriber 1 for one reason or another, disposes before the API request responds.  Nearly the same time as the first one disposing, Subscriber 2 subscribes, and only receives the InterruptedIOException from the first request being canceled.

As I understood, when the first subscriber disposes, it should cancel the API request and also removes itself as a subscriber, so the refCount() should cause the upstream observable to dispose.  When the 2nd subscriber attaches, it should be starting a brand new request to the upstream API source, rather than receiving the first error.

So it's slightly different because it's not actually a timeout (as if the stream had zero events), it's actually receiving the error from the first subscriber's canceled attempt. =||= We were able to track down the part of our code that was triggering this issue, but I still believe that it is a race condition in `.share()`. Where your original suspicion was "one of the observers connect right between onNext and onComplete", in our case RefCount is dispatching the dispose/cancel upstream to the original request, but is not decrementing the RefCount quickly enough, so that the 2nd request is coming in as if it is refCount=2, even though it has already terminated the upstream (and therefore should have already become refCount=0 and the ConnectableObservable should already have been disconnected).

In our case (Android), we had 2 separate Fragments being added approximately simultaneously. Fragment 1 makes a request for configuration (which is implemented with `share()` and intended to be shared across multiple requests for the same configs), and then shortly after also disposes that request (this was a mistake, and that's what has been fixed on our end -- short version is, we were using `CompositeDisposable.clear()`, but we should have only been disposing a _single_ unrelated observable).  Fragment 2 also makes the same request for configurations.

As a result of CompositeDisposable.clear(), Fragment 1's config request got disposed, and rather than allowing Fragment 2's request to continue operating due to the refCount, Fragment 2 only receives the OkHttp InterruptedIOException from the canceled operation and never receives a completed successful response. =||= share() is generally tricky, even without this bug, because people have a sense of it staying alive a bit longer and also receiving onNext events in time, which is not guaranteed with it. You could try using `replay(1).refCount()` or `publish().refCount(1, TimeUnit.SECONDS)` to give it some wiggle room until I find a way to fix this bug (my attempts this far have broken other unit tests so it may take a few days). =||= This is a tough one.

What happens is that the termination happens when a new observer subscribes, which makes `refCount=2` but the new observer gets assigned to a fresh publishing instance, ready to be connected. However, the refCount's termination management sees `refCount=2` and won't reset nor will it reconnect. If it reset though, that would clear the new observer and still result in a hang too.

This could be resolved if a late observer wasn't assigned to a fresh publishing instance, but receive the terminal signal instead (thus making refCount get down to zero and reset/reconnect). Unfortunately, this is a behavior change that, in addition, requires API change to allow manual resetting for those who work with `ConnectableObservable` directly. I already planned to resolve the underlying issue in 3.x: #5628

I'll keep thinking about this problem, until then, you could use the workarounds above, or use `timeout().retry()` to detect the hang and make it cancel/reconnect. =||= I tried using `.retry()` and the problem with that seemed to be that the `.share()` caused it to keep the existing InterruptedIOException error, so it just kept re-emitting the same error on each retry.

I don't think I tried `.replay(1).refCount()`, but that is worth testing - thanks!  I thought I was avoiding replay for some some reason, but now I can't think of any reason why I would need to avoid that... =||= ,0
6519,6501,publish().refCount() race may leave observers hanging,This test eventually times out because one of the sources will not complete or trigger a reconnection:

```java
for (int i = 0; i < 10_000; i++) {
    Observable<Integer> observable = Observable.just(1).publish().refCount();

    TestObserver<Integer> observer1 = observable
        .subscribeOn(Schedulers.computation())
        .test();

        TestObserver<Integer> observer2 = observable
        .subscribeOn(Schedulers.computation())
        .test();

    observer1
        .withTag("observer1 " + i)
        .awaitDone(5, TimeUnit.SECONDS)
        .assertNoErrors()
        .assertComplete();

    observer2
        .withTag("observer2 " + i)
        .awaitDone(5, TimeUnit.SECONDS)
        .assertNoErrors()
        .assertComplete();
}
```

(Originally reported as a [comment](https://github.com/ReactiveX/RxJava/pull/6187#issuecomment-501879711).),In our anecdotal case, it's an observable that gets disposed and therefore cancels the HTTP request, while the next subscriber receives the immediately-canceled stream from the first subscriber.

Something like:

    val apiRequest: Observable<Foo> = retrofit.apiRequest()...share()

    // subscriber 1, main thread:
    val disposable = apiRequest....subscribeOn(Schedulers.io()).subscribe(...)
    ...
    disposable.dispose()
    
    // subscriber 2, also main thread:
    val disposable = apiRequest....subsribeOn(Schedulers.io()).subscribe(...)

Subscriber 1 for one reason or another, disposes before the API request responds.  Nearly the same time as the first one disposing, Subscriber 2 subscribes, and only receives the InterruptedIOException from the first request being canceled.

As I understood, when the first subscriber disposes, it should cancel the API request and also removes itself as a subscriber, so the refCount() should cause the upstream observable to dispose.  When the 2nd subscriber attaches, it should be starting a brand new request to the upstream API source, rather than receiving the first error.

So it's slightly different because it's not actually a timeout (as if the stream had zero events), it's actually receiving the error from the first subscriber's canceled attempt. =||= We were able to track down the part of our code that was triggering this issue, but I still believe that it is a race condition in `.share()`. Where your original suspicion was "one of the observers connect right between onNext and onComplete", in our case RefCount is dispatching the dispose/cancel upstream to the original request, but is not decrementing the RefCount quickly enough, so that the 2nd request is coming in as if it is refCount=2, even though it has already terminated the upstream (and therefore should have already become refCount=0 and the ConnectableObservable should already have been disconnected).

In our case (Android), we had 2 separate Fragments being added approximately simultaneously. Fragment 1 makes a request for configuration (which is implemented with `share()` and intended to be shared across multiple requests for the same configs), and then shortly after also disposes that request (this was a mistake, and that's what has been fixed on our end -- short version is, we were using `CompositeDisposable.clear()`, but we should have only been disposing a _single_ unrelated observable).  Fragment 2 also makes the same request for configurations.

As a result of CompositeDisposable.clear(), Fragment 1's config request got disposed, and rather than allowing Fragment 2's request to continue operating due to the refCount, Fragment 2 only receives the OkHttp InterruptedIOException from the canceled operation and never receives a completed successful response. =||= share() is generally tricky, even without this bug, because people have a sense of it staying alive a bit longer and also receiving onNext events in time, which is not guaranteed with it. You could try using `replay(1).refCount()` or `publish().refCount(1, TimeUnit.SECONDS)` to give it some wiggle room until I find a way to fix this bug (my attempts this far have broken other unit tests so it may take a few days). =||= This is a tough one.

What happens is that the termination happens when a new observer subscribes, which makes `refCount=2` but the new observer gets assigned to a fresh publishing instance, ready to be connected. However, the refCount's termination management sees `refCount=2` and won't reset nor will it reconnect. If it reset though, that would clear the new observer and still result in a hang too.

This could be resolved if a late observer wasn't assigned to a fresh publishing instance, but receive the terminal signal instead (thus making refCount get down to zero and reset/reconnect). Unfortunately, this is a behavior change that, in addition, requires API change to allow manual resetting for those who work with `ConnectableObservable` directly. I already planned to resolve the underlying issue in 3.x: #5628

I'll keep thinking about this problem, until then, you could use the workarounds above, or use `timeout().retry()` to detect the hang and make it cancel/reconnect. =||= I tried using `.retry()` and the problem with that seemed to be that the `.share()` caused it to keep the existing InterruptedIOException error, so it just kept re-emitting the same error on each retry.

I don't think I tried `.replay(1).refCount()`, but that is worth testing - thanks!  I thought I was avoiding replay for some some reason, but now I can't think of any reason why I would need to avoid that... =||= ,0
6519,5628,3.x: ConnectableObservable redesign,### Problem

The `CompletableObservable` (and `CompletableFlowable`) implementors, `publish` and `replay` in RxJava 1.x and 2.x are inconsistent in their terminal behavior.

When `publish` terminates, its `CompletableObservable` will appear as fresh to the new subscribers. This has the drawback that such subscribers may hang as `connect` may be never called again.

In contrast, `replay` will stay terminated along with any cached items and new subscribers can still get those events. The drawback here is that a new `connect` will clear the internal storage and start the consumption of the main source while not giving any chance to subscribers to prepare and receive that stream of events from the start if the replay is bounded.

Dealing with this inconsistency currently requires `refCount` to trigger a reset on an unofficial channel: casting the `CompletableObserver` into `Disposable` if possible and disposing it when the count reaches zero again.

### Suggested solution

I suggest changing the API to include an explicit `reset()` method and changing the logic to have 3 states:

**fresh** --> `connect()` --> **running** --> `onComplete()`/`onError()` --> **terminated** --> `reset()` --> **fresh**

and possibly:

**terminated** --> `connect()` --> **running**

In the **fresh** state, consumers can pile up and be ready to receive events. An atomic state change to **running** will begin streaming events until a terminal event is reached, at which point the state atomically changes to **terminated**. Consumers subscribing in this state will always receive the terminal event, and in case of `replay`, the cached items as well.

A call to `reset()` will clear the internal storage of the `ConnectableObservable` and start out as **fresh** again, allowing new consumers to gather around and get all fresh events from the beginning.

It is possible to support the call to `connect` in the **terminated** state to skip the **fresh** state. Preventing this transition, however, may be more involved as `connect()` should communicate this to be illegal transition someway as well as the need for a soft way for checking if `connect` is to succeed or not. Note that calling `connect` on a running `ConnectableObservable` is a no-op in 1.x and 2.x.,Hey @akarnokd. When are you planning to start working on that? I believe we may collaborate on that so I will port the same design to Reactor 3?

cc/ @smaldini =||= Closing via #6519 =||= ,0
6519,589,Migrate Language Adaptors to Top Level Projects of RxLANG,As we approach 1.0 and based on the experience of working on the language adaptors it is going to make sense to let the adaptors move to a first-class level and be named RxScala, RxClojure, RxGroovy etc instead of RxJava-Scala, RxJava-Clojure, etc.

This should also mean they become top level projects of their own with a single dependency on RxJava.

This does not need to be done immediately, but probably as we hit the 1.0 Release Candidate stage.

Two reasons for this are:
- don't tie the naming to the "Java" portion of the core function implementations
- decouple release and versioning cycles (particularly important for Scala where it is typical to maintain branches for the different Scala versions such as 2_10 and 2_11)

Anyone else agree or disagree?,Agree. But as you said, it needn't be done immediately, but would be good to do it for 1.0 Release Candidate.
 =||= Done.
 =||= Before people start working on the new repos, I'd like to suggest that we keep the git history. According to https://help.github.com/articles/splitting-a-subfolder-out-into-a-new-repository, this seems to be very simple, and the advantages of keeping the history are considerable.
 =||= Cool command! 
 =||= see https://github.com/ReactiveX/RxScala/issues/1#issuecomment-52638206
 =||= Happy to have someone with strong Git foo do this.
 =||= I made all the changes to repos this morning to retain history.
 =||= ,0
6522,6520,Issus about Flowable concatMapDelayError,RxJava version 2.2.9.

I feel doubt about `Flowable#concatMapDelayError`, when I use `Flowable#fromCallable`

The following code:
```java
   Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)
        .concatMapDelayError(new Function<Integer, Flowable<Integer>>() {
          @Override public Flowable<Integer> apply(final Integer integer) throws Exception {
            return Flowable.fromCallable(new Callable<Integer>() {
              @Override public Integer call() throws Exception {
                if (integer >= 100) {
                  throw new NullPointerException("test null exp");
                }
                return integer;
              }
            });
          }
        })
        .subscribe(new Consumer<Integer>() {
          @Override public void accept(Integer integer) throws Exception {
            Log.e(TAG, "test-->complete-" + integer);
          }
        }, new Consumer<Throwable>() {
          @Override public void accept(Throwable throwable) throws Exception {
            Log.e(TAG, "test-->error-" + throwable);
          }
        });

```

The following output:
```
  test-->complete-1
  test-->complete-2
  test-->complete-3
  test-->error-java.lang.NullPointerException: test null exp
```


It do not delay error. But I use `Observable` is success delayed the error, And I use `Flowable#create` is success delayed the error.

The following code:
```java
    Observable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)
        .concatMapDelayError(new Function<Integer, Observable<Integer>>() {
          @Override public Observable<Integer> apply(final Integer integer) throws Exception {
            return Observable.fromCallable(new Callable<Integer>() {
              @Override public Integer call() throws Exception {
                if (integer >= 100) {
                  throw new NullPointerException("test null exp");
                }
                return integer;
              }
            });
          }
        })
        .subscribe(new Consumer<Integer>() {
          @Override public void accept(Integer integer) throws Exception {
            Log.e(TAG, "test-->complete-" + integer);
          }
        }, new Consumer<Throwable>() {
          @Override public void accept(Throwable throwable) throws Exception {
            Log.e(TAG, "test-->error-" + throwable);
          }
        });
```

The following output:
```
  test-->complete-1
  test-->complete-2
  test-->complete-3
  test-->complete-23
  test-->complete-32
  test-->error-io.reactivex.exceptions.CompositeException: 4 exceptions occurred. 
```

The following code:
```java
    Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)
        .concatMapDelayError(new Function<Integer, Flowable<Integer>>() {
          @Override public Flowable<Integer> apply(final Integer integer) throws Exception {
            return Flowable.create(new FlowableOnSubscribe<Integer>() {
              @Override public void subscribe(FlowableEmitter<Integer> emitter) throws Exception {
                if (integer >= 100) {
                  throw new NullPointerException("test null exp");
                }
                emitter.onNext(integer);
                emitter.onComplete();
              }
            }, BackpressureStrategy.BUFFER);
          }
        })
        .subscribe(new Consumer<Integer>() {
          @Override public void accept(Integer integer) throws Exception {
            Log.e(TAG, "test-->complete-" + integer);
          }
        }, new Consumer<Throwable>() {
          @Override public void accept(Throwable throwable) throws Exception {
            Log.e(TAG, "test-->error-" + throwable);
          }
        });
```

The following output:
```
  test-->complete-1
  test-->complete-2
  test-->complete-3
  test-->complete-23
  test-->complete-32
  test-->error-io.reactivex.exceptions.CompositeException: 4 exceptions occurred. 
```,Thanks for reporting. This is a bug in the operator cutting short because of internal shortcuts not considering the error-delay property. I'll post a fix shortly. =||= Thanks, appreciate it! =||= ,0
6523,6520,Issus about Flowable concatMapDelayError,RxJava version 2.2.9.

I feel doubt about `Flowable#concatMapDelayError`, when I use `Flowable#fromCallable`

The following code:
```java
   Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)
        .concatMapDelayError(new Function<Integer, Flowable<Integer>>() {
          @Override public Flowable<Integer> apply(final Integer integer) throws Exception {
            return Flowable.fromCallable(new Callable<Integer>() {
              @Override public Integer call() throws Exception {
                if (integer >= 100) {
                  throw new NullPointerException("test null exp");
                }
                return integer;
              }
            });
          }
        })
        .subscribe(new Consumer<Integer>() {
          @Override public void accept(Integer integer) throws Exception {
            Log.e(TAG, "test-->complete-" + integer);
          }
        }, new Consumer<Throwable>() {
          @Override public void accept(Throwable throwable) throws Exception {
            Log.e(TAG, "test-->error-" + throwable);
          }
        });

```

The following output:
```
  test-->complete-1
  test-->complete-2
  test-->complete-3
  test-->error-java.lang.NullPointerException: test null exp
```


It do not delay error. But I use `Observable` is success delayed the error, And I use `Flowable#create` is success delayed the error.

The following code:
```java
    Observable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)
        .concatMapDelayError(new Function<Integer, Observable<Integer>>() {
          @Override public Observable<Integer> apply(final Integer integer) throws Exception {
            return Observable.fromCallable(new Callable<Integer>() {
              @Override public Integer call() throws Exception {
                if (integer >= 100) {
                  throw new NullPointerException("test null exp");
                }
                return integer;
              }
            });
          }
        })
        .subscribe(new Consumer<Integer>() {
          @Override public void accept(Integer integer) throws Exception {
            Log.e(TAG, "test-->complete-" + integer);
          }
        }, new Consumer<Throwable>() {
          @Override public void accept(Throwable throwable) throws Exception {
            Log.e(TAG, "test-->error-" + throwable);
          }
        });
```

The following output:
```
  test-->complete-1
  test-->complete-2
  test-->complete-3
  test-->complete-23
  test-->complete-32
  test-->error-io.reactivex.exceptions.CompositeException: 4 exceptions occurred. 
```

The following code:
```java
    Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)
        .concatMapDelayError(new Function<Integer, Flowable<Integer>>() {
          @Override public Flowable<Integer> apply(final Integer integer) throws Exception {
            return Flowable.create(new FlowableOnSubscribe<Integer>() {
              @Override public void subscribe(FlowableEmitter<Integer> emitter) throws Exception {
                if (integer >= 100) {
                  throw new NullPointerException("test null exp");
                }
                emitter.onNext(integer);
                emitter.onComplete();
              }
            }, BackpressureStrategy.BUFFER);
          }
        })
        .subscribe(new Consumer<Integer>() {
          @Override public void accept(Integer integer) throws Exception {
            Log.e(TAG, "test-->complete-" + integer);
          }
        }, new Consumer<Throwable>() {
          @Override public void accept(Throwable throwable) throws Exception {
            Log.e(TAG, "test-->error-" + throwable);
          }
        });
```

The following output:
```
  test-->complete-1
  test-->complete-2
  test-->complete-3
  test-->complete-23
  test-->complete-32
  test-->error-io.reactivex.exceptions.CompositeException: 4 exceptions occurred. 
```,Thanks for reporting. This is a bug in the operator cutting short because of internal shortcuts not considering the error-delay property. I'll post a fix shortly. =||= Thanks, appreciate it! =||= ,0
6525,6518,3.x: remove `test` from `testXXX` method names, create a validator.,A lot of test methods were named like `testXXX` in the 0.x-1.x era and we didn't want to change those for 2.x. Now is the time to get rid of the redundant naming from all test methods.

In addition, a validator should be added that checks all test Java files and reports if it finds the pattern `void\s+test[a-zA-Z0-9]` in any file. See [this validator](https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/validators/CheckLocalVariablesInTests.java) for an example of finding and checking source code files.,Closing via #6525 & #6528. =||= ,0
6528,6518,3.x: remove `test` from `testXXX` method names, create a validator.,A lot of test methods were named like `testXXX` in the 0.x-1.x era and we didn't want to change those for 2.x. Now is the time to get rid of the redundant naming from all test methods.

In addition, a validator should be added that checks all test Java files and reports if it finds the pattern `void\s+test[a-zA-Z0-9]` in any file. See [this validator](https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/validators/CheckLocalVariablesInTests.java) for an example of finding and checking source code files.,Closing via #6525 & #6528. =||= ,0
6532,647,Operation Generate + Timed,Issue #49

I hope the `Func1<TState, Long>, TimeUnit` will suffice.

I kept the absolute time variant in the `OperationGenerate` and in tests but haven't exposed them in `Observable`.,[RxJava-pull-requests #581](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/581/) SUCCESS
This pull request looks good
 =||= As per @headinthebox this is really only used in demos and super complicated and thus should not be added to RxJava. 

Anything that can be done via `generate` should instead be done inside `Observable.create(OnSubscribeFunc f)` optionally with a `Scheduler.
 =||= ,0
6533,564,Different behaviors of `SequenceEqual` in Rx.Net and RxJava,Looks `SequenceEqual` in Rxjava is not correct. 

In Rx.Net, `SequenceEqual` returns an Observable which only has one element indicating if these two sequences are same. For example,

``` c#
            var o = Observable.SequenceEqual(Observable.Range(1, 100), Observable.Range(1, 100));
            var s = o.Subscribe(
                v => Console.WriteLine("Equal = " + v),
                e =>  Console.WriteLine(e),
                () => Console.WriteLine("onCompleted")
                );
            Console.WriteLine("Press any key...");
            Console.ReadKey();
```

Outputs:

<pre>
Equal = True
onCompleted
Press any key...
</pre>


But in RxJava, the following codes:

``` java
        Observable
                .sequenceEqual(Observable.range(1, 100),
                        Observable.range(1, 100)).toBlockingObservable()
                .forEach(new Action1<Boolean>() {
                    @Override
                    public void call(Boolean t1) {
                        System.out.println(t1);
                    }
                });
```

Output 100 `true`s.,I've noticed that using `zip` to pair up values is not the same behavior as in Rx.NET. In Rx.NET, the operator checks if the length of the streams are the same or not. Even if we don't want to do that, one could add a simple `all` operator after the zip:

``` java
public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, 
        Observable<? extends T> second, Func2<? super T, ? super T, Boolean> equality) {
    return zip(first, second, equality).all(Functions.<Boolean>identity());
}
```

Using the materialized view is not an option as errors need to be propagated directly and not compared (and generally, equals doesn't work on Throwables).
 =||= I can take this this weekend.
 =||= fixed in #575
 =||= ,0
6534,634,More operators in Rx.Net, I extracted the method names from RxJava and Rx.Net and compared them. I find some operators in Rx.Net(version 2.0.20823.0) do not appear in the MSDN. Do we need to implement them before 1.0? Here is the list:
- [x]  any (exist, isEmpty)
- [x]  **asobservable** (#641)
- [x]  **case** (#635)
- [ ]  ~~catch~~ (onErrorResumeNext is what we use, this was for F# computation expressions)
- [x]  **chunkify** (#636)
- [x]  **collect** (#636)
- [ ]  ~~deferasync~~ (not applicable as we don't have `Task` or async/await)
- [x]  **delaysubscription** (#638)
- [x]  do (doOnEach)
- [x]  **dowhile** (#635)
- [x]  finally (finallyDo)
- [x]  **firstasync** (#520)
- [x]  **firstordefaultasync** (firstOrDefault)
- [x]  **for** (#636)
- [x]  foreach (BlockingObservable.forEach)
- [ ]  ~~foreachasync~~ (BlockingObservable.forEach since we don't  have `Task` or async/await)
- [ ]  ~~fromasync~~ (from with Schedulers does this)
- [x]  ~~fromasyncpattern~~ (won't implement)
- [x]  ~~fromevent~~ (won't implement)
- [x]  ~~fromeventpattern~~ (won't implement)
- [x]  **generate** (#519)
- [x]  ~~getenumerator~~ (won't implement)
- [x]  **if** (#635)
- [x]  lastasync (last)
- [x]  lastordefault (BlockingObservable.lastOrDefault)
- [x]  **lastordefaultasync** (#520)
- [x]  **latest** (#626)
- [x]  mostrecent (BlockingObservable.mostRecent)
- [x]  next (BlockingObservable.next)
- [x]  refcount (ConnectableObservable.refCount)
- [x]  **repeat** (#518)
- [x]  return (from, just)
- [x]  select (map)
- [x]  selectmany (flatMap)
- [x]  single (BlockingObservable.single)
- [x]  **singleasync** (#520)
- [x]  singleordefault (BlockingObservable.singleOrDefault)
- [x]  **singleordefaultasync** (#520)
- [ ]  ~~startasync~~
- [x]  switch (switchOnNext)
- [x]  **takelastbuffer** (#638)
- [x]  throttle (debounce)
- [x]  throw (error)
- [x]  toarray (unnecessary)
- [x]  toasync (Async.toAsync)
- [x]  todictionary (toMap)
- [x]  toenumerable (BlockingObservable.toIterable)
- [x]  ~~toevent~~ (won't implement)
- [x]  ~~toeventpattern~~ (won't implement)
- [x]  tolookup (toMultimap)
- [x]  toobservable (from)
- [ ]  ~~wait~~ (BlockingObservable.last())
- [x]  **while** (#635)

**strong** means someone is working on it.
~~strikethrough~~ means it won't be implememted.,Nice list.

Catch -> onErrorResumeNext (?)
FromAsyncPattern: won't implement (#46)
Generate -> PR available (#519) still debating on return type
LastOrDefault -> BO.lastOrDefault (?)
MostRecent -> BO.mostRecent
Repeat -> PR available (#518)
StartAsync -> start  (?)
Switch -> switchOnNext (?)
Throttle -> debounce

I don't recognize the rest.
 =||= Updated.

StartAsync is not the `start` operator:

```
    //
    // Summary:
    //     Invokes the asynchronous function, surfacing the result through an observable
    //     sequence.  The CancellationToken is shared by all subscriptions on the resulting
    //     observable sequence. See the remarks section for more information.
    //
    // Parameters:
    //   functionAsync:
    //     Asynchronous function to run.
    //
    // Type parameters:
    //   TResult:
    //     The type of the result returned by the asynchronous function.
    //
    // Returns:
    //     An observable sequence exposing the function's result value, or an exception.
    //
    // Exceptions:
    //   System.ArgumentNullException:
    //     functionAsync is null.
    //
    // Remarks:
    //      The function is started immediately, not during the subscription of the
    //     resulting sequence.  Multiple subscriptions to the resulting sequence can
    //     observe the function's result.  If any subscription to the resulting sequence
    //     is disposed, the CancellationToken is set. The observer associated to the
    //     disposed subscription won't see the TaskCanceledException, but other observers
    //     will. You can protect against this using the Catch operator.  Be careful
    //     when handing out the resulting sequence because of this behavior. The most
    //     common use is to have a single subscription to the resulting sequence, which
    //     controls the CancellationToken state. Alternatively, you can control subscription
    //     behavior using multicast operators.
    public static IObservable<TResult> StartAsync<TResult>(Func<CancellationToken, Task<TResult>> functionAsync);
```
 =||= Here is what's missing and what they generally do:
- [x] **AsObservable**: "Hides the identity of an observable sequence."
- [x] **Case**: "Uses a selector to determine which source to return", i.e., in onSubscribe, a Func0 selector is called and an Observable looked up in a map, then subscribed to it.
- [x] **Chunkify**: "Produces an enumerable sequence of consecutive (possibly empty) chunks of the source sequence.", i.e., implemented as `source.collect(() -> new ArrayList, (lst, x) -> {lst.add(x); return lst;}, u -> new ArrayList)`.
- [x] **Collect**: "Produces an enumerable sequence that returns elements collected/aggregated from the source sequence between consecutive iterations.". For example, you start out with an empty list, and each onNext adds to the list. Once the `iterator.next()` takes the current list, it is replaced by a fresh list. Depending on the frequency of `next()` you might get lists with various sizes.
- [x] **DeferAsync**: "Returns an observable sequence that starts the specified asynchronous factory function whenever a new observer subscribes." Implemented as Defer(() -> StartAsync(factory).Merge()) where factory is a `Func0<Task<IObservable<TValue>>>`.
- [x] **DelaySubscription**: "Time shifts the observable sequence by delaying the subscription with the specified relative time duration.". Does not timeshift the unsubscribe.
- [x] **DoWhile**: "Repeats the given source as long as the specified condition holds, where the condition is evaluated after each repeated source completed.". I.e., repeat only if condition holds: `do { subscribe & run } while (condition)`
- [x] **For**: "Concatenates the observable sequences obtained by running the resultSelector for each element in the given enumerable source.". The difference from a plain concat is that the source iterable is consumed on demand rather than all at once.
- [x] **ForEachAsync**: "Invokes an action for each element in the observable sequence, and returns a Task object that will get signaled when the sequence terminates.", like making a whole sequence of observations into a big Future. Dual of fromFuture & toAsync in some sense.
- [x] **FromAsync**: "Converts to asynchronous function into an observable sequence. Each subscription to the resulting sequence causes the function to be started. The CancellationToken passed to the asynchronous function is tied to the observable sequence's subscription that triggered the function's invocation and can be used for best-effort cancellation.". Implemented as `Defer(() -> StartAsync(functionAsync))` where functionAsync is `Func<Task<TResult>>` or `Func<CancellationToken, Task<TResult>>`.
- [x] **If**: "If the specified condition evaluates true, select the thenSource sequence. Otherwise, select the elseSource sequence.". Condition is evaluated on subscription.
- [x] **GroupBy** with capacity overloads (v2.2)
- [x] **GroupByUntil** with capacity overloads (v2.2)
- [x] **SingleAsync**: "Returns the only element of an observable sequence, and reports an exception if there is not exactly one element in the observable sequence." Returns an observable with a single element or exception.
- [x] **SingleOrDefaultAsync**: "Returns the only element of an observable sequence, or a default value if the observable sequence is empty; this method reports an exception if there is more than one element in the observable sequence."
- [x] **StartAsync**: see [comment](https://github.com/Netflix/RxJava/issues/634#issuecomment-30827770) above.
- [x] **TakeLast** overload with time window (i.e., return the last 2 seconds worth of source values once it finishes).
- [x] **TakeLastBuffer**: "Returns a list with the specified number of contiguous elements from the end of an observable sequence." Has time based overloads. Almost like takeLast but emits a single list of elements. 
- [x] **Wait**: "Waits for the observable sequence to complete and returns the last element of the sequence. If the sequence terminates with an OnError notification, the exception is throw." Returns T. Looks like a `source.takeLast(1).toBlockingObservable().single()`.
- [x] **While**: "Repeats the given source as long as the specified condition holds, where the condition is evaluated before each repeated source is subscribed to." I.e., `while(condition) { subscribe }`.
 =||= @zsxwing or anyone else; do you want to do some of these? I'll do them in batches do I don't have to rebase and restart from master all the time. I'll start with `DoWhile`, `While`, `If`, `Case`.
 =||= Continuing with `Chunkify`, `Collect`, `Wait` and `For`.

Update: Wait is practically BO.last(). Since we don't usually do aliases, I'll skip Wait.
 =||= Next: `DeferSubscription`, `TakeLast`, `TakeLastBuffer`.
 =||= I can add SingleAsync and SingleOrDefaultAsync in PR #520 directly.
 =||= Do we really need DeferAsync, ForEachAsync, FromAsync, StartAsync? We have no CancellationToken in Java.
 =||= It appears to me that CancellationToken is used for cancelling tasks, basically a similar way you would use FutureTask and check its isCancelled(), but since these tokens come from the outside, you can signal cancellations to multiple tasks at once. Since we have the `Subscription` infrastructure for that, I'd vote for not implementing those variants.
 =||= Doing `AsObservable`, `GroupBy` and `GroupByUntil` variants.
 =||= Anyone want to implement all the TestSchedulers?

(CancellationToken is really only useful when you have async await).
 =||= A can take those as well, unless someone else beats me to it while I do the ops mentioned above.
 =||= Doing lastasync and lastordefaultasync
 =||= @headinthebox what features do you miss from the current `TestScheduler`? I'm looking at Rx.NET sources of VirtualScheduler, TestScheduler and HistoricalScheduler, but it is not apparent to me what the functional requirements are.

Never mind, I'll start doing it. Btw, I'm starting to require the enhancements of my PRs to avoid feature duplication...
 =||= These are done:

Switch -> switchOnNext (?)
Throttle -> debounce

The "async" ones don't use the async suffix in RxJava since the non-async ones are on `BlockingObservable` instead. Thus some of those in the list are already implemented just without the async suffix.
 =||= @zsxwing How is the `lastasync` operator you say you're doing different than `last` (https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L5740) that is already implemented? It is non-blocking.

We have `last` and `takeLast`.

```
last() 
          Returns an Observable that emits the last item emitted by the source or an IllegalArgumentException if the source Observable is empty.

takeLast(int count) 
          Returns an Observable that emits only the last count items emitted by the source Observable.
```

Difference between `takeLast(1)` and `last()` just being the `IllegalArgumentException` on `take`. You were involved in both of these I though so I'm confused why we're pursuing `lastasync`.
 =||= What is a use case for `asObservable` to "hide identity"?
 =||= Rx.NET uses it all around the place to hide subjects. @headinthebox might explain it better.
 =||= Interesting, though what value is there in "hiding" it? If it is returned as an `Observable`, not a `Subject` people will use it as an `Observable`. Is it to prevent people reflecting or inspecting a type and then interacting with the `Subject`?
 =||= Yup, as @benjchristensen says, it is to prevent downcasting etc. In .NET people are pretty paranoid about this. Say you have a method that returns an Iterable<T>, but really it is an Array<T>. Now that opens a potential (security) hole since the caller can use the Iterable as a an Array. 
 =||= > @zsxwing How is the lastasync operator you say you're doing different than last (https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L5740) that is already implemented? It is non-blocking.

Sorry. Forget it. We just need to add `LastOrDefaultAsync`. Hope this comment (https://github.com/Netflix/RxJava/pull/520#issuecomment-30936173) can make these operators clear. If no problem, I can add this table to the wiki.
 =||= Looking into `DeferAsync`, `StartAsync` and `SingleAsync`.
 =||= > Looking into DeferAsync, StartAsync and SingleAsync.

SingleAsync has already done in #520
 =||= Doing ForEachAsync and FromAsync and probably will amend PR #645.
 =||= The `fromAsync` behavior seems to be covered in `from` overloads that take a `Scheduler`, such as this: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L753
 =||= No, this FromAsync is a completely different operation: it uses a factory to get a future of a value which is then observed; per subscriber.
 =||= Already added the table to the wiki:
https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#appendix-similar-blocking-and-non-blocking-operators

On Thu, Dec 19, 2013 at 5:57 PM, Shixiong Zhu notifications@github.comwrote:

> @zsxwing https://github.com/zsxwing How is the lastasync operator you
> say you're doing different than last (
> https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L5740)
> that is already implemented? It is non-blocking.
> 
> Sorry. Forgot it. We just need to add LastOrDefaultAsync. Hope this
> comment (#520 (comment)https://github.com/Netflix/RxJava/pull/520#issuecomment-30936173)
> can make these operators clear. If no problem, I can add this table to the
> wiki.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/634#issuecomment-30983749
> .

## 

David M. Gross
PLP Consulting
 =||= @headinthebox and I reviewed the list. All remaining items have been struck out as they should not be implemented.

Great work getting all the others done!
 =||= ,0
6538,644,Throw the checked exception without declaring it.,It uses the deprecated method Thread.stop(Throwable) to throw an exception without declaring it.,The non-deprecated way of doing this, if I understand your goal, is the so-called "SneakyThrow" approach: http://stackoverflow.com/questions/14038649/java-sneakythrow-of-exceptions-type-erasure
 =||= [RxJava-pull-requests #574](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/574/) FAILURE
Looks like there's a problem with this pull request
 =||= I saw that one but this way seems so much simpler.
 =||= This looks like a [very dangerous thing](http://docs.oracle.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html). In addition, are basically killing the current thread, which could be a thread of a thread pool and incur a thread-recreation fee as well. 
 =||= That's what throwing any exception does.  The real danger is that a user incorrectly assumes that because a checked exception isn't declared that only subclasses RuntimeException can be thrown.
 =||= I'm not convinced we should be attempting 'sneaky throw' at all. In Java people do not expect checked exceptions to be thrown without declaration. I don't like checked exceptions but I like confusing and non-obvious behavior less. 

Is the problem of RuntimeException wrapping for BlockingObservable serious enough to fight against the language?

Are there other major libraries that do this?
 =||= I didn't even consider the idea of a sneaky throw until I ran into it with Java calling a Groovy closure. Not that Groovy is anything to aspire to.
 =||= > Not that Groovy is anything to aspire to.

Ha!
 =||= I feel that this comment is the key to this discussion:

> The real danger is that a user incorrectly assumes that because a checked exception isn't declared that only subclasses RuntimeException can be thrown.

My opinion is that we should not try and do a sneaky throw as the least surprising thing we can do it wrap an `Exception`/`Throwable` in a `RuntimeException` and everyone will catch it instead of them getting `Exception`/`Throwable` thrown past their `try/catch` block and blowing up their app.

Does anyone have a strong reason to pursue this "sneaky throw" approach in light of this perspective?

I will close this out in the next couple days if I hear nothing to convince otherwise.
 =||= ,0
6544,6543,3.x: Fix Schedulers.from(Executor, boolean) version tag,It should say `@since 3.0.0` as it has been promoted.

https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/schedulers/Schedulers.java#L403,Closing via #6544 =||= ,0
6556,6551,Disambiguous some method call sites when calling from Kotlin ,I vaguely remember that we already had a discussion about this but I don't know which conclusion was drawn. Observable.onErrorResumeNext is ambiguous when calling from Kotlin.

<img width="1370" alt="Screenshot 2019-06-30 at 12 09 33" src="https://user-images.githubusercontent.com/5759366/60395175-f18f9d80-9b2f-11e9-93cf-fd8d3f8081d3.png">

Since 3.x is a thing do we want to rename these methods. Similar to what we did with `startWith` (even though there was no type inference problem).,Yes, 3.x is a good place fix such ambiguities. My ideas are `onErrorResume(ObservableSource)` or `onErrorResumeWith(ObservableSource)`. PR welcome. =||= Those names sound good to me. I believe the onErrorReturn should also be renamd then. =||= A few questions:

- Do you want to change `Maybe.onErrorResumeNext(MaybeSource)` as well? 
- To what should `Observable.onErrorReturn(Function valueSupplier)` be renamed? 
- Do you want to rename `Maybe.onErrorReturn(Function valueSupplier)` as well?
- What about `Single.onErrorReturn(Function resumeFunction)?`
- Is it ok to do all of this in the same PR?
 =||= > Do you want to change Maybe.onErrorResumeNext(MaybeSource) as well?

Yes, every class where `onErrorResumeNext` has a source type and a function.

> To what should Observable.onErrorReturn(Function valueSupplier) be renamed?

There is no ambiguity there as the other is called `onErrorReturnItem`

> Do you want to rename Maybe.onErrorReturn(Function valueSupplier) as well?

There is no ambiguity there either.

> What about Single.onErrorReturn(Function resumeFunction)?

There is no ambiguity there either.

> Is it ok to do all of this in the same PR?

You can rename multiple things within the same PR. =||= @akarnokd Thanks for the clarification. 

Out of curiosity, @vanniktech was there a reason besides ambiguity that made you suggest renaming the `onErrorReturn`s? =||= @akarnokd Is there a reason `Single.onErrorResumeNext(final Single<? extends T> resumeSingleInCaseOfError)` takes a `Single` and not a `SingleSource` like the other methods? 

I've made the change and run all the tests for this method and all of them pass. 

If there's no reason and it's ok with you I'd be happy to make the change since I'm in the area anyway.  =||= Looks like an API mistake. You can change that too (and see if other places need fixing as well). =||= ,0
6559,6558,2.x/3.x - NPE when debouncing empty source,Hey there!
I've faced with an issue when debouncing empty source it leads NPE. Here is simple test which demonstrates a problem:
```
@Test
public void debounceOnEmpty() {
    Observable.empty().debounce(new Function<Object, ObservableSource<Object>>() {
        @Override
        public ObservableSource<Object> apply(Object o) {
            return Observable.just(new Object());
        }
    }).subscribe();
}
```

Issue also touches `Flowable` in the same way. RxJava version is 2.2.7 however it is also reproducible for latest 3.x.

I am going to create PR with a fix soon for both of versions, let's keep this ticket to track a state of the issue.,Closing via #6559 & #6560. =||= ,0
6560,6558,2.x/3.x - NPE when debouncing empty source,Hey there!
I've faced with an issue when debouncing empty source it leads NPE. Here is simple test which demonstrates a problem:
```
@Test
public void debounceOnEmpty() {
    Observable.empty().debounce(new Function<Object, ObservableSource<Object>>() {
        @Override
        public ObservableSource<Object> apply(Object o) {
            return Observable.just(new Object());
        }
    }).subscribe();
}
```

Issue also touches `Flowable` in the same way. RxJava version is 2.2.7 however it is also reproducible for latest 3.x.

I am going to create PR with a fix soon for both of versions, let's keep this ticket to track a state of the issue.,Closing via #6559 & #6560. =||= ,0
6564,6554,Remove onExceptionResumeNext?,[JavaDocs](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#onExceptionResumeNext-org.reactivestreams.Publisher-)

I don't remember ever needing, asked for or recommended this operator? The difference from `onErrorResumeNext` is that anything that's not extending `Exception` can pass through. I believe it was added to support some internal Netflix operation. It can be emulated via `onErrorResumeNext`: 

```java
source.onErrorResumeNext(
    error -> error instanceof Exception 
        ? fallback : Obserable.error(error))
```,Never used onExceptionResumeNext. =||= It was rather more confusing.
 =||= ,0
6564,655,Skip, SkipLast, Take, TakeLast with time,Issue #653,[RxJava-pull-requests #588](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/588/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #589](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/589/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #592](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/592/) SUCCESS
This pull request looks good
 =||= What is the reason for the `drain` concept? I know it exists in .Net but I don't believe we need this in Java.

I can imagine concern with not wanting a Timer thread to do long-running work, but we don't have that issue with our `Scheduler` implementations. We always have the time aspects of our schedulers running on separate threads (such as `GenericScheduledExecutorService` in the case of `NewThreadScheduler` so we don't block time events.
 =||= I think it was added to avoid scheduling onNext calls individually but rather emit everything in one go. I haven't found any other places where this kind of overload was present in Rx.NET. Should I remove that overload? Are the other variants okay to stay?
 =||= I'll resubmit this since it conflicts with master anyway.
 =||= ,0
6577,6576,ObservableBlockingSubscribe compares BlockingObserver.TERMINATED with wrong object,The `ObservableBlockingSubscribe.observe` function appears to compare the `o` variable, i.e. the `ObservableSource`, which shouldn't ever change, with `BlockingObserver.TERMINATED`. This will probably never be true. The intention was likely to use `v` instead of `o`, in:

https://github.com/ReactiveX/RxJava/blob/a38268c738af7ae1ca50dc4af2bfbb5713361411/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java#L64 

Since this appears to be somewhat redundant with `bs.isDisposed()`, this probably does not cause any issues.,Yes, it should be `v == BlockingObserver.TERMINATED`. PR welcome. =||= ,0
6589,658,BehaviorSubject Race Condition,Need to investigate the `BehaviorSubject` as it likely has the same problem as Rx.Net as reported here: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying

Note that `Subjects` were just re-implemented but kept the same behavior and for the `BehaviorSubject` the race between returning the current value and subscribing for subsequent values appears to be wrong.

Use case:

```
onNext: 1 2 3 4 5 6 7 8 9
Observer: subscribe between 3 & 4 ... should receive 3 4 5 6 7 8 9
```

The likely bug is that in a race it could receive `3 6 7 8 9`,There are a few missing suggestions that I didn't have in my PR which also involves BehaviorSubject. I'll take a look at this as well.

Edit: Yes, this can happen. If an observer subscribes, it immediately gets the current value, then it is eventually added to the state object via `addObserver`, which add could be delayed and values lost.

Edit 2: How to avoid it:
- One would need to block onNext while a subscription is happening, which would negate the improvements. 
- Include the lastNotification in the state so a new observed value triggers a state replace similar to when an observer subscribes. However, one would need 2 states: active and modifying: this avoids using a lock similar to how `AbstractAtomicSubscription` allows complex operations in the mutating state.

I thought about the queue/drain suggestion in the article, but I can't see it solving the value skip problem; (it surely acts against reordering if there happen to be concurrent onNext calls - but we don't allow / ignore those by contract).
 =||= The queue/drain approach can be adapted to also ensure you don't miss notifications. All you have to do is _queue the subscription as well_. (Queue/drain is a fully general synchronization mechanism akin to using an actor.)

Note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread, but it can be fixed by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribing.

So a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:

```
initialValueSent = false
missedDrainCount = 0
create drain queue Q for subscription
sync(this) {
    add observer to {
        enqueue new value onto Q
        sync(Q) {
            // other threads must not push initial value
            if (!initialValueSent) {
                missedDrainCount++
            }
        }
        tryDrain Q
    }

    enqueue current value onto Q
}
// forward value to caller before returning (and perhaps some later values too)
tryDrain Q

// --- allow other threads to forward future values ---
sync(Q) {
    initialValueSent = true;
}
// in case observers were enqueueing while we set the flag
// (pretty sure reading missedDrainCount is safe to touch without locking now...)
// (this can be done without the loop, but requires modifying the Q to drain N)
while (missedDrainCount-- > 0) {
    tryDrain Q
}
```

I think that's right... just off the top of my head, though.
 =||= If you're willing to allow the initial value to thread-hop, it's a lot simpler of course:

```
subscribe:
    enqueue {
        add observer
    }
    tryDrain
send:
    enqueue {
        send to all observers
    }
    tryDrain
```

(assuming you're using the queue as your only synchronization mechanism. If you're also using locks, you probably need to lock around the enqueues)

_edit_ fixed enqueueing inside add observer instead of inside send
 =||= I think this is still an unsolved problem. Do we still want to put effort into this?
 =||= I was thinking about trying to solve it similar to the `groupBy` solution but haven't spent the time to determine if it can be made to work.
 =||= I've implemented a potential fix [here](https://github.com/akarnokd/RxJava/blob/BehaviorSubjectTimeGapFix/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java) but can't create a PR right now due to a github 500 error.  A simple publish benchmark for PublishSubject is 83 MOps/s, BehaviorSubject (new) ~47MOps/s, BehaviorSubject (master) is ~48 MOps/sec.
 =||= Fix just merged.
 =||= ,0
6594,658,BehaviorSubject Race Condition,Need to investigate the `BehaviorSubject` as it likely has the same problem as Rx.Net as reported here: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying

Note that `Subjects` were just re-implemented but kept the same behavior and for the `BehaviorSubject` the race between returning the current value and subscribing for subsequent values appears to be wrong.

Use case:

```
onNext: 1 2 3 4 5 6 7 8 9
Observer: subscribe between 3 & 4 ... should receive 3 4 5 6 7 8 9
```

The likely bug is that in a race it could receive `3 6 7 8 9`,There are a few missing suggestions that I didn't have in my PR which also involves BehaviorSubject. I'll take a look at this as well.

Edit: Yes, this can happen. If an observer subscribes, it immediately gets the current value, then it is eventually added to the state object via `addObserver`, which add could be delayed and values lost.

Edit 2: How to avoid it:
- One would need to block onNext while a subscription is happening, which would negate the improvements. 
- Include the lastNotification in the state so a new observed value triggers a state replace similar to when an observer subscribes. However, one would need 2 states: active and modifying: this avoids using a lock similar to how `AbstractAtomicSubscription` allows complex operations in the mutating state.

I thought about the queue/drain suggestion in the article, but I can't see it solving the value skip problem; (it surely acts against reordering if there happen to be concurrent onNext calls - but we don't allow / ignore those by contract).
 =||= The queue/drain approach can be adapted to also ensure you don't miss notifications. All you have to do is _queue the subscription as well_. (Queue/drain is a fully general synchronization mechanism akin to using an actor.)

Note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread, but it can be fixed by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribing.

So a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:

```
initialValueSent = false
missedDrainCount = 0
create drain queue Q for subscription
sync(this) {
    add observer to {
        enqueue new value onto Q
        sync(Q) {
            // other threads must not push initial value
            if (!initialValueSent) {
                missedDrainCount++
            }
        }
        tryDrain Q
    }

    enqueue current value onto Q
}
// forward value to caller before returning (and perhaps some later values too)
tryDrain Q

// --- allow other threads to forward future values ---
sync(Q) {
    initialValueSent = true;
}
// in case observers were enqueueing while we set the flag
// (pretty sure reading missedDrainCount is safe to touch without locking now...)
// (this can be done without the loop, but requires modifying the Q to drain N)
while (missedDrainCount-- > 0) {
    tryDrain Q
}
```

I think that's right... just off the top of my head, though.
 =||= If you're willing to allow the initial value to thread-hop, it's a lot simpler of course:

```
subscribe:
    enqueue {
        add observer
    }
    tryDrain
send:
    enqueue {
        send to all observers
    }
    tryDrain
```

(assuming you're using the queue as your only synchronization mechanism. If you're also using locks, you probably need to lock around the enqueues)

_edit_ fixed enqueueing inside add observer instead of inside send
 =||= I think this is still an unsolved problem. Do we still want to put effort into this?
 =||= I was thinking about trying to solve it similar to the `groupBy` solution but haven't spent the time to determine if it can be made to work.
 =||= I've implemented a potential fix [here](https://github.com/akarnokd/RxJava/blob/BehaviorSubjectTimeGapFix/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java) but can't create a PR right now due to a github 500 error.  A simple publish benchmark for PublishSubject is 83 MOps/s, BehaviorSubject (new) ~47MOps/s, BehaviorSubject (master) is ~48 MOps/sec.
 =||= Fix just merged.
 =||= ,0
6595,658,BehaviorSubject Race Condition,Need to investigate the `BehaviorSubject` as it likely has the same problem as Rx.Net as reported here: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying

Note that `Subjects` were just re-implemented but kept the same behavior and for the `BehaviorSubject` the race between returning the current value and subscribing for subsequent values appears to be wrong.

Use case:

```
onNext: 1 2 3 4 5 6 7 8 9
Observer: subscribe between 3 & 4 ... should receive 3 4 5 6 7 8 9
```

The likely bug is that in a race it could receive `3 6 7 8 9`,There are a few missing suggestions that I didn't have in my PR which also involves BehaviorSubject. I'll take a look at this as well.

Edit: Yes, this can happen. If an observer subscribes, it immediately gets the current value, then it is eventually added to the state object via `addObserver`, which add could be delayed and values lost.

Edit 2: How to avoid it:
- One would need to block onNext while a subscription is happening, which would negate the improvements. 
- Include the lastNotification in the state so a new observed value triggers a state replace similar to when an observer subscribes. However, one would need 2 states: active and modifying: this avoids using a lock similar to how `AbstractAtomicSubscription` allows complex operations in the mutating state.

I thought about the queue/drain suggestion in the article, but I can't see it solving the value skip problem; (it surely acts against reordering if there happen to be concurrent onNext calls - but we don't allow / ignore those by contract).
 =||= The queue/drain approach can be adapted to also ensure you don't miss notifications. All you have to do is _queue the subscription as well_. (Queue/drain is a fully general synchronization mechanism akin to using an actor.)

Note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread, but it can be fixed by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribing.

So a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:

```
initialValueSent = false
missedDrainCount = 0
create drain queue Q for subscription
sync(this) {
    add observer to {
        enqueue new value onto Q
        sync(Q) {
            // other threads must not push initial value
            if (!initialValueSent) {
                missedDrainCount++
            }
        }
        tryDrain Q
    }

    enqueue current value onto Q
}
// forward value to caller before returning (and perhaps some later values too)
tryDrain Q

// --- allow other threads to forward future values ---
sync(Q) {
    initialValueSent = true;
}
// in case observers were enqueueing while we set the flag
// (pretty sure reading missedDrainCount is safe to touch without locking now...)
// (this can be done without the loop, but requires modifying the Q to drain N)
while (missedDrainCount-- > 0) {
    tryDrain Q
}
```

I think that's right... just off the top of my head, though.
 =||= If you're willing to allow the initial value to thread-hop, it's a lot simpler of course:

```
subscribe:
    enqueue {
        add observer
    }
    tryDrain
send:
    enqueue {
        send to all observers
    }
    tryDrain
```

(assuming you're using the queue as your only synchronization mechanism. If you're also using locks, you probably need to lock around the enqueues)

_edit_ fixed enqueueing inside add observer instead of inside send
 =||= I think this is still an unsolved problem. Do we still want to put effort into this?
 =||= I was thinking about trying to solve it similar to the `groupBy` solution but haven't spent the time to determine if it can be made to work.
 =||= I've implemented a potential fix [here](https://github.com/akarnokd/RxJava/blob/BehaviorSubjectTimeGapFix/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java) but can't create a PR right now due to a github 500 error.  A simple publish benchmark for PublishSubject is 83 MOps/s, BehaviorSubject (new) ~47MOps/s, BehaviorSubject (master) is ~48 MOps/sec.
 =||= Fix just merged.
 =||= ,0
6599,6597,using Observable#mergeWith(CompletableSource), upstream occurs an error, but the ComletableSource won't be disposed,using Observable#mergeWith(CompletableSource), upstream occurs an error, but the ComletableSource won't be disposed.

```java
Observable.create(new ObservableOnSubscribe<Object>() {
    @Override
    public void subscribe(ObservableEmitter<Object> emitter) throws Exception {
        Schedulers.io().scheduleDirect(
            () -> emitter.tryOnError(new Throwable("occurs error")),
            1, TimeUnit.SECONDS);
        }
    })
    .mergeWith(
        Completable.create(emmit ->
            emmit.setCancellable(() -> System.out.println("mergeWith dispose"))
         )
         .doOnSubscribe(dis -> System.out.println("mergeWith doOnSubscribe"))
    )
    .subscribe(ob -> {}, System.out::println);
```
the result is :
```
mergeWith doOnSubscribe
java.lang.Throwable: occurs error
```

but if add 'toObservable()' 
```
Observable.create(new ObservableOnSubscribe<Object>() {
            @Override
            public void subscribe(ObservableEmitter<Object> emitter) throws Exception {
                Schedulers.io().scheduleDirect(() -> emitter.tryOnError(new Throwable("occurs error")), 1, TimeUnit.SECONDS);
            }
        })
                .mergeWith(Completable.create(emmit ->
                        emmit.setCancellable(() -> System.out.println("mergeWith dispose")))
                        .doOnSubscribe(dis -> System.out.println("mergeWith doOnSubscribe")).toObservable())
                .subscribe(ob -> {}, System.out::println);
```

the result is: 
```
mergeWith doOnSubscribe
mergeWith dispose
java.lang.Throwable: occurs error
```

The 'dispose' will be invoked。
In case of first,it will produce a memory leak.
Is that a bug?,Thanks for reporting. This is indeed a bug with those `mergeWith` operators. =||= Thank you for all your efforts =||= ,0
6600,6583,3.x: Have all unit tests extend a base test class,By adding a common base class, we can enable a "global" timeout and a per-class log output that prevents Travis CI to stop the build and also not flood the log with all methods:

```java
package io.reactivex.testsupport;

public abstract class RxJavaTest {
  @Rule
  protected Timeout globalTimeout = new Timeout(5, TimeUnit.MINUTES);

  @Test
  @Ignore
  public final void announce() {
  }
}
```

This way, we no longer have to rely on the random ignores scattered along the codebase. This baseclass-ignore may seem unnecessarily complicated, but unfortunately, I was unable to create a working setting via [Gradle's test runner](https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.logging.TestLogging.html).,Hey, I see the interest having a global timeout in a base class. Please note that in Junit4, the timeout parameter on `@Test` annotation does not override the Timeout Rule. This can be an issue when a test requires a custom timeout.
Also, I don't understand the `announce` test. Do you expect every ignored test to be transferred in the class `RxJavaTest`? =||= No problem, default 2-5 minutes should work. Travis kills the build if no standard output is happening for 10 minutes. Announce should create a log print often. Ignore should be reevaluated in place and deleted if no longer needed. =||= Thanks, I'll submit a PR. =||= Hey,
There are a few remaining things to close the issue.
First, I did not delete ignored tests for the fusion operator.
Second, I don't know what should be done to fix those non-deterministic and thread starvation tests:
* https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/observers/SerializedObserverTest.java#L263
* https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/observers/SerializedObserverTest.java#L353
* https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/subscribers/SerializedSubscriberTest.java#L265
* https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/subscribers/SerializedSubscriberTest.java#L355

Also, I did not update Technology Compatibility Kit (TCK) tests. =||= Don't worry about them. Thanks for your diligent work! =||= ,0
6601,6576,ObservableBlockingSubscribe compares BlockingObserver.TERMINATED with wrong object,The `ObservableBlockingSubscribe.observe` function appears to compare the `o` variable, i.e. the `ObservableSource`, which shouldn't ever change, with `BlockingObserver.TERMINATED`. This will probably never be true. The intention was likely to use `v` instead of `o`, in:

https://github.com/ReactiveX/RxJava/blob/a38268c738af7ae1ca50dc4af2bfbb5713361411/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java#L64 

Since this appears to be somewhat redundant with `bs.isDisposed()`, this probably does not cause any issues.,Yes, it should be `v == BlockingObserver.TERMINATED`. PR welcome. =||= ,0
6602,658,BehaviorSubject Race Condition,Need to investigate the `BehaviorSubject` as it likely has the same problem as Rx.Net as reported here: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying

Note that `Subjects` were just re-implemented but kept the same behavior and for the `BehaviorSubject` the race between returning the current value and subscribing for subsequent values appears to be wrong.

Use case:

```
onNext: 1 2 3 4 5 6 7 8 9
Observer: subscribe between 3 & 4 ... should receive 3 4 5 6 7 8 9
```

The likely bug is that in a race it could receive `3 6 7 8 9`,There are a few missing suggestions that I didn't have in my PR which also involves BehaviorSubject. I'll take a look at this as well.

Edit: Yes, this can happen. If an observer subscribes, it immediately gets the current value, then it is eventually added to the state object via `addObserver`, which add could be delayed and values lost.

Edit 2: How to avoid it:
- One would need to block onNext while a subscription is happening, which would negate the improvements. 
- Include the lastNotification in the state so a new observed value triggers a state replace similar to when an observer subscribes. However, one would need 2 states: active and modifying: this avoids using a lock similar to how `AbstractAtomicSubscription` allows complex operations in the mutating state.

I thought about the queue/drain suggestion in the article, but I can't see it solving the value skip problem; (it surely acts against reordering if there happen to be concurrent onNext calls - but we don't allow / ignore those by contract).
 =||= The queue/drain approach can be adapted to also ensure you don't miss notifications. All you have to do is _queue the subscription as well_. (Queue/drain is a fully general synchronization mechanism akin to using an actor.)

Note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread, but it can be fixed by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribing.

So a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:

```
initialValueSent = false
missedDrainCount = 0
create drain queue Q for subscription
sync(this) {
    add observer to {
        enqueue new value onto Q
        sync(Q) {
            // other threads must not push initial value
            if (!initialValueSent) {
                missedDrainCount++
            }
        }
        tryDrain Q
    }

    enqueue current value onto Q
}
// forward value to caller before returning (and perhaps some later values too)
tryDrain Q

// --- allow other threads to forward future values ---
sync(Q) {
    initialValueSent = true;
}
// in case observers were enqueueing while we set the flag
// (pretty sure reading missedDrainCount is safe to touch without locking now...)
// (this can be done without the loop, but requires modifying the Q to drain N)
while (missedDrainCount-- > 0) {
    tryDrain Q
}
```

I think that's right... just off the top of my head, though.
 =||= If you're willing to allow the initial value to thread-hop, it's a lot simpler of course:

```
subscribe:
    enqueue {
        add observer
    }
    tryDrain
send:
    enqueue {
        send to all observers
    }
    tryDrain
```

(assuming you're using the queue as your only synchronization mechanism. If you're also using locks, you probably need to lock around the enqueues)

_edit_ fixed enqueueing inside add observer instead of inside send
 =||= I think this is still an unsolved problem. Do we still want to put effort into this?
 =||= I was thinking about trying to solve it similar to the `groupBy` solution but haven't spent the time to determine if it can be made to work.
 =||= I've implemented a potential fix [here](https://github.com/akarnokd/RxJava/blob/BehaviorSubjectTimeGapFix/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java) but can't create a PR right now due to a github 500 error.  A simple publish benchmark for PublishSubject is 83 MOps/s, BehaviorSubject (new) ~47MOps/s, BehaviorSubject (master) is ~48 MOps/sec.
 =||= Fix just merged.
 =||= ,0
6604,658,BehaviorSubject Race Condition,Need to investigate the `BehaviorSubject` as it likely has the same problem as Rx.Net as reported here: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying

Note that `Subjects` were just re-implemented but kept the same behavior and for the `BehaviorSubject` the race between returning the current value and subscribing for subsequent values appears to be wrong.

Use case:

```
onNext: 1 2 3 4 5 6 7 8 9
Observer: subscribe between 3 & 4 ... should receive 3 4 5 6 7 8 9
```

The likely bug is that in a race it could receive `3 6 7 8 9`,There are a few missing suggestions that I didn't have in my PR which also involves BehaviorSubject. I'll take a look at this as well.

Edit: Yes, this can happen. If an observer subscribes, it immediately gets the current value, then it is eventually added to the state object via `addObserver`, which add could be delayed and values lost.

Edit 2: How to avoid it:
- One would need to block onNext while a subscription is happening, which would negate the improvements. 
- Include the lastNotification in the state so a new observed value triggers a state replace similar to when an observer subscribes. However, one would need 2 states: active and modifying: this avoids using a lock similar to how `AbstractAtomicSubscription` allows complex operations in the mutating state.

I thought about the queue/drain suggestion in the article, but I can't see it solving the value skip problem; (it surely acts against reordering if there happen to be concurrent onNext calls - but we don't allow / ignore those by contract).
 =||= The queue/drain approach can be adapted to also ensure you don't miss notifications. All you have to do is _queue the subscription as well_. (Queue/drain is a fully general synchronization mechanism akin to using an actor.)

Note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread, but it can be fixed by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribing.

So a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:

```
initialValueSent = false
missedDrainCount = 0
create drain queue Q for subscription
sync(this) {
    add observer to {
        enqueue new value onto Q
        sync(Q) {
            // other threads must not push initial value
            if (!initialValueSent) {
                missedDrainCount++
            }
        }
        tryDrain Q
    }

    enqueue current value onto Q
}
// forward value to caller before returning (and perhaps some later values too)
tryDrain Q

// --- allow other threads to forward future values ---
sync(Q) {
    initialValueSent = true;
}
// in case observers were enqueueing while we set the flag
// (pretty sure reading missedDrainCount is safe to touch without locking now...)
// (this can be done without the loop, but requires modifying the Q to drain N)
while (missedDrainCount-- > 0) {
    tryDrain Q
}
```

I think that's right... just off the top of my head, though.
 =||= If you're willing to allow the initial value to thread-hop, it's a lot simpler of course:

```
subscribe:
    enqueue {
        add observer
    }
    tryDrain
send:
    enqueue {
        send to all observers
    }
    tryDrain
```

(assuming you're using the queue as your only synchronization mechanism. If you're also using locks, you probably need to lock around the enqueues)

_edit_ fixed enqueueing inside add observer instead of inside send
 =||= I think this is still an unsolved problem. Do we still want to put effort into this?
 =||= I was thinking about trying to solve it similar to the `groupBy` solution but haven't spent the time to determine if it can be made to work.
 =||= I've implemented a potential fix [here](https://github.com/akarnokd/RxJava/blob/BehaviorSubjectTimeGapFix/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java) but can't create a PR right now due to a github 500 error.  A simple publish benchmark for PublishSubject is 83 MOps/s, BehaviorSubject (new) ~47MOps/s, BehaviorSubject (master) is ~48 MOps/sec.
 =||= Fix just merged.
 =||= ,0
6607,658,BehaviorSubject Race Condition,Need to investigate the `BehaviorSubject` as it likely has the same problem as Rx.Net as reported here: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying

Note that `Subjects` were just re-implemented but kept the same behavior and for the `BehaviorSubject` the race between returning the current value and subscribing for subsequent values appears to be wrong.

Use case:

```
onNext: 1 2 3 4 5 6 7 8 9
Observer: subscribe between 3 & 4 ... should receive 3 4 5 6 7 8 9
```

The likely bug is that in a race it could receive `3 6 7 8 9`,There are a few missing suggestions that I didn't have in my PR which also involves BehaviorSubject. I'll take a look at this as well.

Edit: Yes, this can happen. If an observer subscribes, it immediately gets the current value, then it is eventually added to the state object via `addObserver`, which add could be delayed and values lost.

Edit 2: How to avoid it:
- One would need to block onNext while a subscription is happening, which would negate the improvements. 
- Include the lastNotification in the state so a new observed value triggers a state replace similar to when an observer subscribes. However, one would need 2 states: active and modifying: this avoids using a lock similar to how `AbstractAtomicSubscription` allows complex operations in the mutating state.

I thought about the queue/drain suggestion in the article, but I can't see it solving the value skip problem; (it surely acts against reordering if there happen to be concurrent onNext calls - but we don't allow / ignore those by contract).
 =||= The queue/drain approach can be adapted to also ensure you don't miss notifications. All you have to do is _queue the subscription as well_. (Queue/drain is a fully general synchronization mechanism akin to using an actor.)

Note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread, but it can be fixed by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribing.

So a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:

```
initialValueSent = false
missedDrainCount = 0
create drain queue Q for subscription
sync(this) {
    add observer to {
        enqueue new value onto Q
        sync(Q) {
            // other threads must not push initial value
            if (!initialValueSent) {
                missedDrainCount++
            }
        }
        tryDrain Q
    }

    enqueue current value onto Q
}
// forward value to caller before returning (and perhaps some later values too)
tryDrain Q

// --- allow other threads to forward future values ---
sync(Q) {
    initialValueSent = true;
}
// in case observers were enqueueing while we set the flag
// (pretty sure reading missedDrainCount is safe to touch without locking now...)
// (this can be done without the loop, but requires modifying the Q to drain N)
while (missedDrainCount-- > 0) {
    tryDrain Q
}
```

I think that's right... just off the top of my head, though.
 =||= If you're willing to allow the initial value to thread-hop, it's a lot simpler of course:

```
subscribe:
    enqueue {
        add observer
    }
    tryDrain
send:
    enqueue {
        send to all observers
    }
    tryDrain
```

(assuming you're using the queue as your only synchronization mechanism. If you're also using locks, you probably need to lock around the enqueues)

_edit_ fixed enqueueing inside add observer instead of inside send
 =||= I think this is still an unsolved problem. Do we still want to put effort into this?
 =||= I was thinking about trying to solve it similar to the `groupBy` solution but haven't spent the time to determine if it can be made to work.
 =||= I've implemented a potential fix [here](https://github.com/akarnokd/RxJava/blob/BehaviorSubjectTimeGapFix/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java) but can't create a PR right now due to a github 500 error.  A simple publish benchmark for PublishSubject is 83 MOps/s, BehaviorSubject (new) ~47MOps/s, BehaviorSubject (master) is ~48 MOps/sec.
 =||= Fix just merged.
 =||= ,0
6609,660,Hopefully fixed missing notifications if part of the subscription is del...,...ayed.

Fix suggestion to issue #658.

Basically it is a "spin-lock" between onNext and the subscription. It has the additional effect of locking out concurrent subscriptions, but these would most likely clash on the state-swap anyway.,[RxJava-pull-requests #594](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/594/) SUCCESS
This pull request looks good
 =||= Added test case to illustrate the underlying issue. If I comment out the new mutating part, it will fail typically with values (3, 7, 8, 9) != (3, 4, 5, 6, 7, 8, 9)
 =||= [RxJava-pull-requests #595](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/595/) SUCCESS
This pull request looks good
 =||= I'll have to spend more time on this one later to think through.
 =||= Okay.
 =||= ,0
6612,6611,3.x: Revise AtomicThrowable.addThrowable usage,Currently, many (if not all?) usage of `addThrowable` is as follows:

```java
if (errors.addThrowable(ex)) {
   // do something with the error case
} else {
    RxJavaPlugins.onError(ex);
}
```

The plugin error call could be inlined into the method call and renamed to `tryAddThrowable` to ensure all usage places are updated correctly.,Hey, do you need help doing this?  =||= Each usage location has to be reevaluated and there are thousands of those. It would be easier if I do them. =||= ,0
6612,658,BehaviorSubject Race Condition,Need to investigate the `BehaviorSubject` as it likely has the same problem as Rx.Net as reported here: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying

Note that `Subjects` were just re-implemented but kept the same behavior and for the `BehaviorSubject` the race between returning the current value and subscribing for subsequent values appears to be wrong.

Use case:

```
onNext: 1 2 3 4 5 6 7 8 9
Observer: subscribe between 3 & 4 ... should receive 3 4 5 6 7 8 9
```

The likely bug is that in a race it could receive `3 6 7 8 9`,There are a few missing suggestions that I didn't have in my PR which also involves BehaviorSubject. I'll take a look at this as well.

Edit: Yes, this can happen. If an observer subscribes, it immediately gets the current value, then it is eventually added to the state object via `addObserver`, which add could be delayed and values lost.

Edit 2: How to avoid it:
- One would need to block onNext while a subscription is happening, which would negate the improvements. 
- Include the lastNotification in the state so a new observed value triggers a state replace similar to when an observer subscribes. However, one would need 2 states: active and modifying: this avoids using a lock similar to how `AbstractAtomicSubscription` allows complex operations in the mutating state.

I thought about the queue/drain suggestion in the article, but I can't see it solving the value skip problem; (it surely acts against reordering if there happen to be concurrent onNext calls - but we don't allow / ignore those by contract).
 =||= The queue/drain approach can be adapted to also ensure you don't miss notifications. All you have to do is _queue the subscription as well_. (Queue/drain is a fully general synchronization mechanism akin to using an actor.)

Note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread, but it can be fixed by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribing.

So a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:

```
initialValueSent = false
missedDrainCount = 0
create drain queue Q for subscription
sync(this) {
    add observer to {
        enqueue new value onto Q
        sync(Q) {
            // other threads must not push initial value
            if (!initialValueSent) {
                missedDrainCount++
            }
        }
        tryDrain Q
    }

    enqueue current value onto Q
}
// forward value to caller before returning (and perhaps some later values too)
tryDrain Q

// --- allow other threads to forward future values ---
sync(Q) {
    initialValueSent = true;
}
// in case observers were enqueueing while we set the flag
// (pretty sure reading missedDrainCount is safe to touch without locking now...)
// (this can be done without the loop, but requires modifying the Q to drain N)
while (missedDrainCount-- > 0) {
    tryDrain Q
}
```

I think that's right... just off the top of my head, though.
 =||= If you're willing to allow the initial value to thread-hop, it's a lot simpler of course:

```
subscribe:
    enqueue {
        add observer
    }
    tryDrain
send:
    enqueue {
        send to all observers
    }
    tryDrain
```

(assuming you're using the queue as your only synchronization mechanism. If you're also using locks, you probably need to lock around the enqueues)

_edit_ fixed enqueueing inside add observer instead of inside send
 =||= I think this is still an unsolved problem. Do we still want to put effort into this?
 =||= I was thinking about trying to solve it similar to the `groupBy` solution but haven't spent the time to determine if it can be made to work.
 =||= I've implemented a potential fix [here](https://github.com/akarnokd/RxJava/blob/BehaviorSubjectTimeGapFix/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java) but can't create a PR right now due to a github 500 error.  A simple publish benchmark for PublishSubject is 83 MOps/s, BehaviorSubject (new) ~47MOps/s, BehaviorSubject (master) is ~48 MOps/sec.
 =||= Fix just merged.
 =||= ,0
6620,6569,3.x: unbounded requests from first, take and others,In 2.x we talked about some surprising request patterns from operators like `first`, `take` and others where despite only one or a limited number of items being needed, Long.MAX_VALUE was requested of upstream and then cancelled after the desired number arrived (#5077). I believe this was a micro-optimization performance boost that improved the Scrabble benchmarks. Any change to the pattern was rejected based on it being a breaking API change.

In essence I'd like us not to be opinionated about the effect on the upstream of over-requesting (particularly over a network boundary). By over-requesting we are fundamentally *losing information that can be useful to optimizing upstream processing*. An example that springs to mind is that requesting a large number may be translated to an api call to a remote upstream that does a full sort (O(nlogn)) whereas requesting only one can be implemented upstream with a max scan (O(n)). This of course assumes one and only request to create the stream so is not a run-of-the-mill streaming case. I'd also suggest we are not opinionated about the ability of upstream to respond to cancellation (upstream may be performing cpu intensive actions in third-party libraries that aren't cancellable).

I think the effect on the benchmarks of reverting to naturally bounded requests where obvious (`first`, `take`, etc) will be very small.

 Can we revisit this one for 3.x?,Okay, let's make limit the default and change first/single. 

What about the lambda subscribe? =||= Thanks @akarnokd, so I'm suggesting we constrain upstream requests for:

* `elementAt`
* `elementAtOrError`
* `first` (calls `elementAt`)
* `firstOrError` (calls `elementAt`)
* `take`
* `single(default)`
* `singleOrError`
* `blockingSingle(default)` calls `single(default)`
* `blockingSingle` (calls `singleOrError`)

`limit` can then be an alias for `take`.

>What about the lambda subscribe?

You've lost me, what are you referring to?


 =||= There is no reason to have `limit` separately then.

[lambda subscribe](https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/Flowable.java#L14925) requests max value. =||= >lambda subscribe requests max value.

Yes, that seems reasonable to me. Why would it be otherwise?  =||= > There is no reason to have limit separately then.

ok by me =||= You were worrying about overrequesting over the network boundary. A straight `subscribe` would do that too for your case. I'm fine with it as is. =||= >You were worrying about overrequesting over the network boundary. A straight subscribe would do that too for your case. I'm fine with it as is.

I'm fine with it also. =||= Would you like a PR for these changes? You are welcome to do it yourself if you want to, but I can help if useful. =||= I'm still waiting for #6589 but you can go ahead and create a PR. =||= I'm happy to wait for #6589 before starting the PR =||= ,0
6626,6625,2.x Calling hasNext() on a disposed blocking iterator hangs forever,Calling `hasNext()` on a a blocking iterator never returns if the iterator has been disposed. 

Tested on 2.2.11

To reproduce:
```
Iterator<Integer> iterator = Flowable.fromArray(1, 2, 3).delay(1, TimeUnit.SECONDS).blockingIterable().iterator();

System.out.println("start");
((Disposable)iterator).dispose();
iterator.hasNext(); //Hangs forever
```,Indeed, if you "hack" into that Iterator it won't work properly as it implementing Disposable is not part of the public intended API. I'll see what I can do about it in 2.x. For 3.x, it probably needs some redesign to work with try-with-resources for example. =||= Closing via #6626 & #6627. =||= ,0
6627,6625,2.x Calling hasNext() on a disposed blocking iterator hangs forever,Calling `hasNext()` on a a blocking iterator never returns if the iterator has been disposed. 

Tested on 2.2.11

To reproduce:
```
Iterator<Integer> iterator = Flowable.fromArray(1, 2, 3).delay(1, TimeUnit.SECONDS).blockingIterable().iterator();

System.out.println("start");
((Disposable)iterator).dispose();
iterator.hasNext(); //Hangs forever
```,Indeed, if you "hack" into that Iterator it won't work properly as it implementing Disposable is not part of the public intended API. I'll see what I can do about it in 2.x. For 3.x, it probably needs some redesign to work with try-with-resources for example. =||= Closing via #6626 & #6627. =||= ,0
6629,6608,ReplaySubject and buffer with debounce not emitting values after first subscription,The issue described below started with version 2.2.10 and continues with 2.2.11. It works with 2.2.7 through 2.2.9.

I have a test where a set a `ReplaySubject` like so:

```
locationPublisher = ReplaySubject.create()
locationPublisher.onNext(mockLocation)
locationPublisher.onComplete()

locationObservable = locationPublisher.share()
```

Then, I subscribe twice to the observable (I'm simplifying the test case just to demonstrate the bug):
```
        locationObservable
            .buffer(locationObservable.debounce(5, TimeUnit.SECONDS))
            .test()
            .assertValueCount(2)


        locationObservable
            .buffer(locationObservable.debounce(5, TimeUnit.SECONDS))
            .test()
            .assertValueCount(2)
```
When I run the above test, it fails on the second test subscription on RxJava 2.2.10 or 2.2.11:
> java.lang.AssertionError: Value counts differ; expected: 2 but was: 1 (latch = 0, values = 1, errors = 0, completions = 1)
Expected :2 
Actual   :1 (latch = 0, values = 1, errors = 0, completions = 1),Hi and thanks for reporting. This is a bug in `refCount` affecting both 2.x and 3.x.

What happens is that when the source subject completes, it completes `buffer`, which then cancels the boundary source, which makes the `refCount` think it still has 1 subscriber active and doesn't reset the source.

The operator is a bit delicate so I have to work out the correct state transitions and not break tests... =||= Hi. I can't seem to reproduce this with 2.2.11. Could you check if the following test passes for you on 2.2.11?

```java

@Test
public void upstreamTerminationTriggersAnotherCancel() throws Exception {
    ReplaySubject<Integer> rs = ReplaySubject.create();
    rs.onNext(1);
    rs.onComplete();

    Observable<Integer> shared = rs.share();

    shared
    .buffer(shared.debounce(5, TimeUnit.SECONDS))
    .test()
    .assertValueCount(2);

    shared
    .buffer(shared.debounce(5, TimeUnit.SECONDS))
    .test()
    .assertValueCount(2);
}
``` =||= Yes, I just created a new project with Android Studio and added only RxJava as a new dependency and your test above.

It fails on versions 2.2.10 and 2.2.11 put passes on 2.2.9. =||= ,0
6629,6608,ReplaySubject and buffer with debounce not emitting values after first subscription,The issue described below started with version 2.2.10 and continues with 2.2.11. It works with 2.2.7 through 2.2.9.

I have a test where a set a `ReplaySubject` like so:

```
locationPublisher = ReplaySubject.create()
locationPublisher.onNext(mockLocation)
locationPublisher.onComplete()

locationObservable = locationPublisher.share()
```

Then, I subscribe twice to the observable (I'm simplifying the test case just to demonstrate the bug):
```
        locationObservable
            .buffer(locationObservable.debounce(5, TimeUnit.SECONDS))
            .test()
            .assertValueCount(2)


        locationObservable
            .buffer(locationObservable.debounce(5, TimeUnit.SECONDS))
            .test()
            .assertValueCount(2)
```
When I run the above test, it fails on the second test subscription on RxJava 2.2.10 or 2.2.11:
> java.lang.AssertionError: Value counts differ; expected: 2 but was: 1 (latch = 0, values = 1, errors = 0, completions = 1)
Expected :2 
Actual   :1 (latch = 0, values = 1, errors = 0, completions = 1),Hi and thanks for reporting. This is a bug in `refCount` affecting both 2.x and 3.x.

What happens is that when the source subject completes, it completes `buffer`, which then cancels the boundary source, which makes the `refCount` think it still has 1 subscriber active and doesn't reset the source.

The operator is a bit delicate so I have to work out the correct state transitions and not break tests... =||= Hi. I can't seem to reproduce this with 2.2.11. Could you check if the following test passes for you on 2.2.11?

```java

@Test
public void upstreamTerminationTriggersAnotherCancel() throws Exception {
    ReplaySubject<Integer> rs = ReplaySubject.create();
    rs.onNext(1);
    rs.onComplete();

    Observable<Integer> shared = rs.share();

    shared
    .buffer(shared.debounce(5, TimeUnit.SECONDS))
    .test()
    .assertValueCount(2);

    shared
    .buffer(shared.debounce(5, TimeUnit.SECONDS))
    .test()
    .assertValueCount(2);
}
``` =||= Yes, I just created a new project with Android Studio and added only RxJava as a new dependency and your test above.

It fails on versions 2.2.10 and 2.2.11 put passes on 2.2.9. =||= ,0
6635,663,BO.collect and BO.chunkify,Refactored BO.collect and BO.chunkify out of PR #636

Mentioned in issue #634,[RxJava-pull-requests #597](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/597/) FAILURE
Looks like there's a problem with this pull request
 =||= There is a compilation issue with master in file OperationTakeLast due to the removal of SingleAssignmentSubscription.
 =||= [RxJava-pull-requests #598](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/598/) FAILURE
Looks like there's a problem with this pull request
 =||= This looks good ... though we have discovered that Java 8 Stream has a collect interface and we're considering whether we should change to match it on both the `Observable` and `BlockingObservable` versions instead of exactly matching Rx.Net in this case.
 =||= /cc @headinthebox for API review.
 =||= Take a look at the `collect` operator here: https://github.com/Netflix/RxJava/commit/fd6dd169e6e119f72d65042f3adb947623ae2766
 =||= Closing this out as it will need to be recreated and discussed again.

@akarnokd  and @headinthebox please coordinate.
 =||= ,0
6637,663,BO.collect and BO.chunkify,Refactored BO.collect and BO.chunkify out of PR #636

Mentioned in issue #634,[RxJava-pull-requests #597](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/597/) FAILURE
Looks like there's a problem with this pull request
 =||= There is a compilation issue with master in file OperationTakeLast due to the removal of SingleAssignmentSubscription.
 =||= [RxJava-pull-requests #598](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/598/) FAILURE
Looks like there's a problem with this pull request
 =||= This looks good ... though we have discovered that Java 8 Stream has a collect interface and we're considering whether we should change to match it on both the `Observable` and `BlockingObservable` versions instead of exactly matching Rx.Net in this case.
 =||= /cc @headinthebox for API review.
 =||= Take a look at the `collect` operator here: https://github.com/Netflix/RxJava/commit/fd6dd169e6e119f72d65042f3adb947623ae2766
 =||= Closing this out as it will need to be recreated and discussed again.

@akarnokd  and @headinthebox please coordinate.
 =||= ,0
6650,6569,3.x: unbounded requests from first, take and others,In 2.x we talked about some surprising request patterns from operators like `first`, `take` and others where despite only one or a limited number of items being needed, Long.MAX_VALUE was requested of upstream and then cancelled after the desired number arrived (#5077). I believe this was a micro-optimization performance boost that improved the Scrabble benchmarks. Any change to the pattern was rejected based on it being a breaking API change.

In essence I'd like us not to be opinionated about the effect on the upstream of over-requesting (particularly over a network boundary). By over-requesting we are fundamentally *losing information that can be useful to optimizing upstream processing*. An example that springs to mind is that requesting a large number may be translated to an api call to a remote upstream that does a full sort (O(nlogn)) whereas requesting only one can be implemented upstream with a max scan (O(n)). This of course assumes one and only request to create the stream so is not a run-of-the-mill streaming case. I'd also suggest we are not opinionated about the ability of upstream to respond to cancellation (upstream may be performing cpu intensive actions in third-party libraries that aren't cancellable).

I think the effect on the benchmarks of reverting to naturally bounded requests where obvious (`first`, `take`, etc) will be very small.

 Can we revisit this one for 3.x?,Okay, let's make limit the default and change first/single. 

What about the lambda subscribe? =||= Thanks @akarnokd, so I'm suggesting we constrain upstream requests for:

* `elementAt`
* `elementAtOrError`
* `first` (calls `elementAt`)
* `firstOrError` (calls `elementAt`)
* `take`
* `single(default)`
* `singleOrError`
* `blockingSingle(default)` calls `single(default)`
* `blockingSingle` (calls `singleOrError`)

`limit` can then be an alias for `take`.

>What about the lambda subscribe?

You've lost me, what are you referring to?


 =||= There is no reason to have `limit` separately then.

[lambda subscribe](https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/Flowable.java#L14925) requests max value. =||= >lambda subscribe requests max value.

Yes, that seems reasonable to me. Why would it be otherwise?  =||= > There is no reason to have limit separately then.

ok by me =||= You were worrying about overrequesting over the network boundary. A straight `subscribe` would do that too for your case. I'm fine with it as is. =||= >You were worrying about overrequesting over the network boundary. A straight subscribe would do that too for your case. I'm fine with it as is.

I'm fine with it also. =||= Would you like a PR for these changes? You are welcome to do it yourself if you want to, but I can help if useful. =||= I'm still waiting for #6589 but you can go ahead and create a PR. =||= I'm happy to wait for #6589 before starting the PR =||= ,0
6652,665,GroupByUntil with maxGroups,Split from #641

Purpose: limit the active groups to a certain number. If new group is opened, the oldest group is closed.,[RxJava-pull-requests #600](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/600/) FAILURE
Looks like there's a problem with this pull request
 =||= Why not remove the one that got a notification last? Not sure if this specific behavior particularly useful.
 =||= I don't know. I think it matches Rx.NET's signature but I can't really look into `ConcurrentDictionary`. It is possible the capacity is just for the initial capacity of the map and has nothing to do with limiting the groups.
 =||= @akarnokd Since we already have `groupByUntil` in `Observable`, what is the reason for adding more overloads with `maxGroups`? Where is this use case and signature coming from?

The stated reason is:

> Purpose: limit the active groups to a certain number. If new group is opened, the oldest group is closed.

However, that is an arbitrary decision on how to "clear out the cache" and one that would need different eviction policies. If this is going to be pursued it needs something more thorough than just a `maxGroups`. 

As for `ConcurrentDictionary` limiting groups, there is no evidence to that from looking at the API. It seems it will keep growing, at least to the max Integer size for number of keys. Also, `ConcurrentDictionary` is a implementation detail, not part of the `groupByUntil` contract.

Is it correct that you're trying to create a `groupByUntil` variant that provides a cache eviction policy? If so, why, and how should it behave if the `key` shows up again? 
 =||= Closing based on discussion above ...

> I guess this PR can be ignored.
 =||= ,0
6657,665,GroupByUntil with maxGroups,Split from #641

Purpose: limit the active groups to a certain number. If new group is opened, the oldest group is closed.,[RxJava-pull-requests #600](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/600/) FAILURE
Looks like there's a problem with this pull request
 =||= Why not remove the one that got a notification last? Not sure if this specific behavior particularly useful.
 =||= I don't know. I think it matches Rx.NET's signature but I can't really look into `ConcurrentDictionary`. It is possible the capacity is just for the initial capacity of the map and has nothing to do with limiting the groups.
 =||= @akarnokd Since we already have `groupByUntil` in `Observable`, what is the reason for adding more overloads with `maxGroups`? Where is this use case and signature coming from?

The stated reason is:

> Purpose: limit the active groups to a certain number. If new group is opened, the oldest group is closed.

However, that is an arbitrary decision on how to "clear out the cache" and one that would need different eviction policies. If this is going to be pursued it needs something more thorough than just a `maxGroups`. 

As for `ConcurrentDictionary` limiting groups, there is no evidence to that from looking at the API. It seems it will keep growing, at least to the max Integer size for number of keys. Also, `ConcurrentDictionary` is a implementation detail, not part of the `groupByUntil` contract.

Is it correct that you're trying to create a `groupByUntil` variant that provides a cache eviction policy? If so, why, and how should it behave if the `key` shows up again? 
 =||= Closing based on discussion above ...

> I guess this PR can be ignored.
 =||= ,0
6664,6663,3.x: Observable.groupBy test failures,Two tests fail randomly on CI:

This is probably failing because some non-atomicity bug in determining a group has been abandoned?
```
io.reactivex.rxjava3.internal.operators.observable.ObservableGroupByTest > firstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenSubscribesOnAndDelaysAndThenCompletes FAILED
    java.lang.AssertionError: expected:<6> but was:<5>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:834)
        at org.junit.Assert.assertEquals(Assert.java:645)
        at org.junit.Assert.assertEquals(Assert.java:631)
        at io.reactivex.rxjava3.internal.operators.observable.ObservableGroupByTest.firstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenSubscribesOnAndDelaysAndThenCompletes(ObservableGroupByTest.java:765)
```

and this fails because dispose still doesn't get propagated to upstream.

```
io.reactivex.rxjava3.internal.operators.observable.ObservableGroupByTest > cancelOverFlatmapRace()
      at assertFalse("Round " + i, ps.hasObservers());
```

I can't make these tests fail on my machine at all so the GroupBy logic has to be rechecked. The `Flowable` variants have not failed (yet).,I've run the changes with the build matrix and no failures popped up. Closing for now. =||= ,0
6668,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6699,6683,Update README.md,Thank you for contributing to RxJava. Before pressing the "Create Pull Request" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.,# [Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/6683?src=pr&el=h1) Report
> Merging [#6683](https://codecov.io/gh/ReactiveX/RxJava/pull/6683?src=pr&el=desc) into [3.x](https://codecov.io/gh/ReactiveX/RxJava/commit/118f40551140f423cfe093e19833ba592a842ee2?src=pr&el=desc) will **decrease** coverage by `<.01%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/graphs/tree.svg?width=650&token=WtCc2hTjM2&height=150&src=pr)](https://codecov.io/gh/ReactiveX/RxJava/pull/6683?src=pr&el=tree)

```diff
@@             Coverage Diff              @@
##                3.x    #6683      +/-   ##
============================================
- Coverage     98.18%   98.17%   -0.01%     
+ Complexity     6192     6188       -4     
============================================
  Files           677      677              
  Lines         44657    44657              
  Branches       6170     6170              
============================================
- Hits          43845    43841       -4     
+ Misses          291      290       -1     
- Partials        521      526       +5
```


| [Impacted Files](https://codecov.io/gh/ReactiveX/RxJava/pull/6683?src=pr&el=tree) | Coverage Δ | Complexity Δ | |
|---|---|---|---|
| [.../operators/flowable/FlowableBlockingSubscribe.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvZmxvd2FibGUvRmxvd2FibGVCbG9ja2luZ1N1YnNjcmliZS5qYXZh) | `93.02% <0%> (-4.66%)` | `10% <0%> (-1%)` | |
| [...rnal/operators/flowable/FlowableFlatMapSingle.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvZmxvd2FibGUvRmxvd2FibGVGbGF0TWFwU2luZ2xlLmphdmE=) | `93.02% <0%> (-3.49%)` | `2% <0%> (ø)` | |
| [...rxjava3/internal/observers/QueueDrainObserver.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vYnNlcnZlcnMvUXVldWVEcmFpbk9ic2VydmVyLmphdmE=) | `97.43% <0%> (-2.57%)` | `21% <0%> (-1%)` | |
| [.../internal/disposables/ListCompositeDisposable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9kaXNwb3NhYmxlcy9MaXN0Q29tcG9zaXRlRGlzcG9zYWJsZS5qYXZh) | `98% <0%> (-2%)` | `34% <0%> (-1%)` | |
| [...ternal/operators/observable/ObservablePublish.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2YWJsZS9PYnNlcnZhYmxlUHVibGlzaC5qYXZh) | `97.29% <0%> (-1.81%)` | `16% <0%> (-1%)` | |
| [...operators/observable/ObservableMergeWithMaybe.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2YWJsZS9PYnNlcnZhYmxlTWVyZ2VXaXRoTWF5YmUuamF2YQ==) | `99.09% <0%> (-0.91%)` | `2% <0%> (ø)` | |
| [...nternal/operators/observable/ObservableCreate.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2YWJsZS9PYnNlcnZhYmxlQ3JlYXRlLmphdmE=) | `98.29% <0%> (-0.86%)` | `2% <0%> (ø)` | |
| [...a3/internal/operators/flowable/FlowableReplay.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvZmxvd2FibGUvRmxvd2FibGVSZXBsYXkuamF2YQ==) | `91.97% <0%> (-0.83%)` | `19% <0%> (ø)` | |
| [.../operators/maybe/MaybeFlatMapIterableFlowable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvbWF5YmUvTWF5YmVGbGF0TWFwSXRlcmFibGVGbG93YWJsZS5qYXZh) | `95.9% <0%> (-0.82%)` | `2% <0%> (ø)` | |
| [...ternal/operators/observable/ObservableFlatMap.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2YWJsZS9PYnNlcnZhYmxlRmxhdE1hcC5qYXZh) | `89.29% <0%> (-0.67%)` | `3% <0%> (ø)` | |
| ... and [10 more](https://codecov.io/gh/ReactiveX/RxJava/pull/6683/diff?src=pr&el=tree-more) | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/6683?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/6683?src=pr&el=footer). Last update [118f405...68102a7](https://codecov.io/gh/ReactiveX/RxJava/pull/6683?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= Replaced by #6699 =||= ,0
6700,6697,3.x: update javadoc for observeOn to mention its eagerness,`Flowable.observeOn` and `Observable.observeOn` try to do as much event delivery as they can.
Add a section explaining this property to all these multi-valued `observeOn` overloads:

"This operator keeps emitting as many signals as it can on the given Scheduler's Worker thread, which may result in a longer than expected occupation of this thread. In other terms, it does not allow per-signal fairness in case the worker runs on a shared underlying thread. If such fairness and signal/work interleaving is preferred, use the `delay` operator with zero time instead."

Also link to the `@see #delay(long,TimeUnit,Scheduler)`.,Hi! Do we only need to add the quoted message in both classes? I can do it if it is ok. =||= > I can do it if it is ok.

Sure.

> Do we only need to add the quoted message in both classes?

`Single`, `Maybe` and `Completable` can signal only one event and thus can't exhibit the property described. =||= Hi @akarnokd! Just one silly question: 

When you say 

> Add a section explaining this property to all these multi-valued observeOn overloads

You mean all but `observeOn(Scheduler scheduler)`, right?

In any case, I just created a PR with what I understood was required. Please, if there is something wrong let me know to fix it.

Thanks  =||= @akarnokd could you take a look at this?
https://github.com/Polidea/RxAndroidBle/issues/628
You can just test my last example, your suggestion to use `delay()` did not help me solve the problem. =||= ,0
6714,671,API Design Review: Aggregate and Math Functions,Several operators on `rx.Observable` are intended for aggregation and potentially dangerous on long-running or infinite Observables. Similar to how blocking operators were moved to `BlockingObservable` it has been suggested that aggregation operators be collected into an `AggregateObservable` or something similarly named. This could be further broken into `AggregateObservable` and `NumberObservable` for ones specifically operating on numbers as the type would be `<? extends Number>` rather than `<T>`.

Some of these operators include:
- average*
- max (add maxBy (keySelector))
- min (add minBy)
- sum*
- contains
- count
- longCount
- toList
- reduce

/cc @headinthebox and @jhusain,Average, min, max and sum went into rxjava-math. Do we want to move the rest too? From the rest, I would rarely want to count the elements in a stream.
 =||= Agreed, we should not lead people towards reducing streams to single values.
 =||= We still have:
- contains
- count
- longCount
- toList
- reduce

@headinthebox @akarnokd  Should we leave these?

It seems that `toList` and `reduce` would be pretty jarring to remove. People get what they ask for on those. The `contains` and `count` are trivial and don't bother me being in the API.

I suggest we leave these 4.
 =||= Except for .ToList which I do often use, I'm happy to remove the others, but happy to keep them as well.
 =||= I think we just leave them. They don't bother me. Closing this out.
 =||= ,0
6715,671,API Design Review: Aggregate and Math Functions,Several operators on `rx.Observable` are intended for aggregation and potentially dangerous on long-running or infinite Observables. Similar to how blocking operators were moved to `BlockingObservable` it has been suggested that aggregation operators be collected into an `AggregateObservable` or something similarly named. This could be further broken into `AggregateObservable` and `NumberObservable` for ones specifically operating on numbers as the type would be `<? extends Number>` rather than `<T>`.

Some of these operators include:
- average*
- max (add maxBy (keySelector))
- min (add minBy)
- sum*
- contains
- count
- longCount
- toList
- reduce

/cc @headinthebox and @jhusain,Average, min, max and sum went into rxjava-math. Do we want to move the rest too? From the rest, I would rarely want to count the elements in a stream.
 =||= Agreed, we should not lead people towards reducing streams to single values.
 =||= We still have:
- contains
- count
- longCount
- toList
- reduce

@headinthebox @akarnokd  Should we leave these?

It seems that `toList` and `reduce` would be pretty jarring to remove. People get what they ask for on those. The `contains` and `count` are trivial and don't bother me being in the API.

I suggest we leave these 4.
 =||= Except for .ToList which I do often use, I'm happy to remove the others, but happy to keep them as well.
 =||= I think we just leave them. They don't bother me. Closing this out.
 =||= ,0
6720,195,Unwrap AtomicObservableSubscription?,As far as I can tell, any custom subscription that is passed to `subscribe` gets `wrap`ped in an AtomicObservableSubscription unless `trusted` is true, a flag which can't be controlled from outside.

Since AOS doesn't have an `unwrap` method, how can I pass custom subscriptions in a type safe manner?

Rationale is being able to maintain extra state about a subscription _in_ the subscription.,An Observable by design doesn't expose state so that it can be composed (wrapped) exactly as this is doing. For example, Observable.synchronize() could be used to wrap an Observable before vending it out for use if the Observable was thought to not be thread-safe. This is part of the principles of being functional and monadic.

All state within the Func1 implementation that gets converted into an Observable should be self-contained.

So what is your use case that is causing you to want to reach back into the Observable implementation itself and how are you trying to do that?
 =||= Not sure if it makes a difference, but small correction: we don't want to track state in the Observable, we want to track state in the subscription, which is what the client holds on to.

The reason we want to do this is that on Android we need to deal with component life cycles and need to attach/detach observers to prevent resource leaks, or terminate observable sequence midway through.

I see there is a `BooleanSubscription` which helps terminating loops by checking the subscription for `isUnsubscribed`, which is similar to what we want to do. How would you even use this? Anything I get in return from `subscribe` is wrapped away in an AtomicObservableSubscription.
 =||= The state is always hidden behind the Observable or Subscription interfaces - not leaked out. 

Thus, your Func1 implementation (that becomes and Observable) would return an implementation of Subscription that works with your function correctly to signal an unsubscribe. This is important because the sequences of Observables can be composed n-levels and an unsubscribe will be propagated up the sequence and each Observable then does with it what its implementation dictates - but nothing external ever knows the implementation or tries to reach inside it.

Here's an example of how BooleanSubscription is used:
 https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/VideoExample.groovy#L110

``` groovy
Observable<VideoList> getListOfLists(userId) {
    return Observable.create({ observer -> 
        BooleanSubscription subscription = new BooleanSubscription();
        try {
            // this will happen on a separate thread as it requires a network call
            executor.execute({
                    // simulate network latency
                    Thread.sleep(180);
                    for(i in 0..15) {
                        if(subscription.isUnsubscribed()) {
                            break;
                        }
                        try {
                            //println("****** emitting list: " + i)
                            observer.onNext(new VideoList(i))
                        }catch(Exception e) {
                            observer.onError(e);
                        }
                    }
                    observer.onCompleted();
            })
        }catch(Exception e) {
            observer.onError(e);
        }
        return subscription;
    })
}
```

As for multiple observers subscribing/unsubscribing, that is definitely what Multicast/Publish is all about (https://github.com/Netflix/RxJava/issues/15 and https://github.com/Netflix/RxJava/issues/65) as discussed on Twitter: https://twitter.com/mttkay/status/310819293166178304

It's near the top of the todo list but if you need this functionality sooner than I or someone else is getting to it, perhaps you can try tackling them as they are the right way to handle these issues of state.
 =||= Thanks for clarifying! Have to admit that I'm still getting into the whole mindset of functional programming in Java (the lack of supportive language constructs doesn't help), and it's hard to do it in a clean way when introducing something like Rx into a grown code base. But we're getting there. No rush on the implementation of Multicast, but sure, I'll give it a shot when you guys are too busy!
 =||= Yes, it took myself and my teammates a month or two to adapt our thinking to it and several times we tried breaking the model before we starting thinking functionally. Also the lack of lambdas/closures in Java (until Java8 which I eagerly await) is why we predominantly use RxJava in other languages that support them.
 =||= ,0
6729,6728,Add javadoc on ActionDisposable, correction of dangling javadoc comme…,Javadoc corrections :
- add javadoc on ActionDisposable
- correction of dangling javadoc comments
- remove of unnecessary '@see' (on same method)

Issue #4535.,# [Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/6728?src=pr&el=h1) Report
> Merging [#6728](https://codecov.io/gh/ReactiveX/RxJava/pull/6728?src=pr&el=desc) into [3.x](https://codecov.io/gh/ReactiveX/RxJava/commit/33a498d4c1d48e4cefd9899b246bdbb6d6cae57d?src=pr&el=desc) will **decrease** coverage by `0.01%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/graphs/tree.svg?width=650&token=WtCc2hTjM2&height=150&src=pr)](https://codecov.io/gh/ReactiveX/RxJava/pull/6728?src=pr&el=tree)

```diff
@@             Coverage Diff             @@
##               3.x    #6728      +/-   ##
===========================================
- Coverage     98.1%   98.09%   -0.02%     
  Complexity    6189     6189              
===========================================
  Files          677      677              
  Lines        44663    44663              
  Branches      6171     6171              
===========================================
- Hits         43818    43812       -6     
- Misses         304      308       +4     
- Partials       541      543       +2
```


| [Impacted Files](https://codecov.io/gh/ReactiveX/RxJava/pull/6728?src=pr&el=tree) | Coverage Δ | Complexity Δ | |
|---|---|---|---|
| [.../main/java/io/reactivex/rxjava3/core/Flowable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9jb3JlL0Zsb3dhYmxlLmphdmE=) | `100% <ø> (ø)` | `559 <0> (ø)` | :arrow_down: |
| [src/main/java/io/reactivex/rxjava3/core/Maybe.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9jb3JlL01heWJlLmphdmE=) | `100% <ø> (ø)` | `172 <0> (ø)` | :arrow_down: |
| [...ain/java/io/reactivex/rxjava3/core/Observable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9jb3JlL09ic2VydmFibGUuamF2YQ==) | `100% <ø> (ø)` | `537 <0> (ø)` | :arrow_down: |
| [...operators/flowable/BlockingFlowableMostRecent.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvZmxvd2FibGUvQmxvY2tpbmdGbG93YWJsZU1vc3RSZWNlbnQuamF2YQ==) | `100% <ø> (ø)` | `2 <0> (ø)` | :arrow_down: |
| [...rc/main/java/io/reactivex/rxjava3/core/Single.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9jb3JlL1NpbmdsZS5qYXZh) | `100% <ø> (ø)` | `148 <0> (ø)` | :arrow_down: |
| [...eactivex/rxjava3/disposables/ActionDisposable.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9kaXNwb3NhYmxlcy9BY3Rpb25EaXNwb3NhYmxlLmphdmE=) | `100% <ø> (ø)` | `2 <0> (ø)` | :arrow_down: |
| [...ators/observable/BlockingObservableMostRecent.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2YWJsZS9CbG9ja2luZ09ic2VydmFibGVNb3N0UmVjZW50LmphdmE=) | `100% <ø> (ø)` | `2 <0> (ø)` | :arrow_down: |
| [.../operators/observable/ObservableFlatMapSingle.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2YWJsZS9PYnNlcnZhYmxlRmxhdE1hcFNpbmdsZS5qYXZh) | `88.88% <0%> (-5.56%)` | `2% <0%> (ø)` | |
| [...ernal/operators/flowable/FlowableFlatMapMaybe.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvZmxvd2FibGUvRmxvd2FibGVGbGF0TWFwTWF5YmUuamF2YQ==) | `91.14% <0%> (-3.13%)` | `2% <0%> (ø)` | |
| [...nternal/operators/observable/ObservableCreate.java](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9pby9yZWFjdGl2ZXgvcnhqYXZhMy9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2YWJsZS9PYnNlcnZhYmxlQ3JlYXRlLmphdmE=) | `97.43% <0%> (-1.71%)` | `2% <0%> (ø)` | |
| ... and [19 more](https://codecov.io/gh/ReactiveX/RxJava/pull/6728/diff?src=pr&el=tree-more) | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/6728?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/ReactiveX/RxJava/pull/6728?src=pr&el=footer). Last update [33a498d...c0a91b8](https://codecov.io/gh/ReactiveX/RxJava/pull/6728?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= Superseeded by #6729. =||= ,0
6729,672,API Design Review: DelaySubscription,What is the `delaySubscription` operator for and should we delete it?

/cc @headinthebox and @jhusain,@headinthebox Should we keep this?
 =||= This one comes from .NET; I never use it myself, I think it is mostly useful for testing where you can delay the subscription to fuzz.
 =||= Skipping it then ... 
 =||= ,0
6730,5806,3.x: Maybe incorrect or missing marbles (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(Iterable)`: missing diagram
- [x] `concat(Publisher)`: missing diagram
- [x] `concat(Publisher, int)`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concatArrayDelayError`: indicate error delayed, 1 marble per source
- [x] `concatArrayEager`: missing diagram
- [x] `concatDelayError(Iterable)`: missing diagram
- [x] `concatDelayError(Publisher)`: missing diagram
- [x] `concatDelayError(Publisher, int)`: fix overlap/misalignment inside the operator box
- [x] `concatEager(Iterable)`: missing diagram
- [x] `concatEager(Publisher)`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: indicate callable returns the error
- [x] `fromAction`: missing diagram
- [x] `fromCompletable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture(Future)`: operator name in the box, indicate Future is the parameter
- [x] `fromFuture(Future, long, TimeUnit)`: operator name in the box, indicate Future is the parameter, indicate timeout
- [x] `fromRunnable`: missing diagram
- [x] `merge(Iterable)`: missing diagram
- [x] `merge(Publisher)`: missing diagram
- [x] `merge(Publisher, int)`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `mergeArrayDelayError`: one marble per Maybe source
- [x] `mergeDelayError(Iterable)`: one marble per Maybe source
- [x] `mergeDelayError(Publisher)`: one marble per Maybe source
- [x] `mergeDelayError(Maybe, Maybe, ...)`: one marble per Maybe source
- [x] `sequenceEqual` + 1: result should be `Single`.
- [x] `timer` + 1: result should be Maybe
- [x] `using` + 1: rework to indicate the created Maybe
- [x] `wrap`: missing marble
- [x] `zip(Iterable)`: one marble per Maybe source, result should be Maybe
- [x] `zip(Maybe, Maybe, ...)` + 8: one marble per Maybe source, result should be Maybe
- [x] `zipArray`: one marble per Maybe source, result should be Maybe
- [x] `ambWith`: one marble per Maybe source, result should be Maybe
- [x] ~~`as`: missing diagram~~ operator removed
- [x] `blockingGet` + 1: missing diagram
- [x] `cache`: one marble per Maybe source, result should be Maybe
- [x] `cast`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatMap`: indicate Maybe target, indicate empty source
- [x] `concatWith`: one marble per Maybe source, result should be Maybe, operator name, indicate other is a parameter
- [x] `contains`: one marble per Maybe source, result should be Single, empty case
- [x] `count`: one marble per maybe, operator name, result should be Single, empty case
- [x] `defaultIfEmpty`: non-empty case, result should be Maybe
- [x] `delay(time)` + 3: one marble per Maybe source, result should be Maybe
- [x] `delay(Publisher)`: one marble per Maybe, one signal by the Publisher, empty publisher case
- [x] `delaySubscription(Publisher)`: missing diagram
- [x] `delaySubscription(time)` + 1: one marble per Maybe source, result should be Maybe
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: operator name, one marble per Maybe, result should be Maybe
- [x] `doFinally`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnComplete`: one marble per Maybe, result should be Maybe
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnTerminate`: one marble per Maybe, result should be Maybe
- [x] `filter`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, Function, Callable)`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, BiFunction)`: one marble per Maybe, result should be Maybe
- [x] `flatMapObservable`: should be mapped into an Observable
- [x] `flatMapPublisher`: indicate backpressure
- [x] `flatMapSingle`: indicate empty maybe results in error
- [x] `flatMapSingleElement`: operator name, indicate empty maybe
- [x] `flatMapCompletable`: indicate empty maybe
- [x] `hide`: missing diagram
- [x] `ignoreElement`: operator name, one marble per Maybe, result should be Maybe
- [x] `isEmpty`: result should be Single
- [x] `mergeWith`: operator name, one marble per Maybe, indicate backpressure
- [x] `ofType`: one marble per Maybe
- [x] `onErrorComplete` + 1: missing diagram
- [x] `onErrorResumeNext`: one marble per Maybe, result should be Maybe
- [x] `onErrorResumeWith`: one marble per Maybe, result should be Maybe
- [x] `onErrorReturn`: one marble per Maybe, result should be Maybe, indicate callback
- [x] `onErrorReturnItem`: operator name, one marble per Maybe, result should be Maybe, indicate normal outcome
- [x] ~~`onExceptionResumeNext`: operator takes a Maybe source directlyˇ~~ operator removed
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat` + 1: one marble per source, indicate backpressure, indicate repeat conditions
- [x] `repeatUntil`: operator name, repeat condition, indicate backpressure
- [x] `repeatWhen`: one marble per Maybe, indicate backpressure
- [x] `retry` + 2: one marble per Maybe, result should be Maybe, indicate repeat conditions
- [x] `retry(int, Predicate)`: missing diagram
- [x] `retry(Predicate)`: missing diagram
- [x] `retryUntil`: missing diagram
- [x] `retryWhen`: one marble per Maybe, output should be Maybe
- [x] `switchIfEmpty` + 1: improve diagrams, indicate argument type
- [x] `takeUntil` + 1: one marble per Maybe, output should be Maybe
- [x] `timeout` + 3: one marble per Maybe, output should be Maybe
- [x] `timeout(MaybeSource)`: missing diagram
- [x] `timeout(MaybeSource, MaybeSource)`: missing diagram
- [x] `timeout(Publisher)`: missing diagram
- [x] `timeout(Publisher, MaybeSource)`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toObservable`: missing diagram
- [x] `toSingle` + 1: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `zipWith`: one marble per Maybe, output should be Maybe,Here is the Excel file I draw the diagrams in: https://drive.google.com/file/d/1di67kFJEuiLPyq14JlnV3vFl-muaCMfH/view?usp=sharing =||= ,0
6732,5788,3.x: Single incorrect or missing images (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


,I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= ,0
6737,1828,Backpressure: Window by Size,The `window` operators that use time or Observable boundaries do not participate in backpressure ... they act as "temporal" operators for flow control and not reactive pull. The `window(int size)` variant however seems like it should work with reactive pull backpressure and behave similarly to `groupBy`. 

In other words, it can be applied to a cold observable and correctly compose backpressure to emit windows and items within each window at a controlled rate. 

Any thoughts or opinions on this?,Yes, anything with count sounds like a slamdunk to participate in back-pressure. In fact, I can imagine we would ask for chunks the size of the window.
 =||= I'll try and get this done in time. 
 =||= I'm probably not going to get this in for 1.0.0 so it will have to come during the 1.0.x releases.
 =||= In layman's terms, this feature request is a sliding window for the latest up to N elements over T time, right?

I'm going through the documentation and haven't found anything similar, and it's a common use component in this environments.
 =||= @pakoito no, this is adding reactive pull backpressure to already existing functionality. 

Go ahead and open a new issue with your use case if the operators are not working for you (see http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler) )
 =||= That operator is what I was after, thank you. I would add to the documentation/example that the windows for that case can overlap, unlike other count based window/buffer operations.
 =||= > The window(int size) variant however seems like it should work with reactive pull backpressure and behave similarly to groupBy.

I think it's more like `buffer`. Only support to request the number of `Window`s., but don't support backpressure for each Window Observable. Right? 
 =||= I actually see this one as more similar to `groupBy` as it needs to provide backpressure on all windows, otherwise there isn't any backpressure.
 =||= Is this in the works? @zsxwing PR #1862 was closed do you want to revive it?
 =||= I'm busy with other work and may not go back to work on this one soon. If someone is interested in the issue, please go head.
 =||= Window supports backpressure on the outer Observable as of 1.0.14 and there is a PR that adds backpressure support to the inner observable: #3150.
 =||= Backpressure support added + there is a subsequent fix to this, #3678
 =||= Closing via #3678.
 =||= ,0
6737,1823,Native Java Agent for "Async Call Stacks",Speaking with Tal Weiss at QConSF (@takipi https://www.takipi.com) it sounds like there may be some efficient approaches to capturing the callstack as longs (using C in native code) at each async invocation point in an `Observable` sequence so that in event of `onError` we could rebuild the stacktrace (paying the cost only then) and end up with more useful error information that normal stack traces offer in async and composed systems like Rx. 

This could enhance what we can do with https://github.com/ReactiveX/RxJavaDebug but also allow an "RxException" that contains the graph and callstack at each method invocation point along the way. It won't necessarily be a simple stack since an Observable can split and merge, but we should be able to either capture the full graph or the path to the error.,This would be amazing. Would it work on Android though? I assume not, due
to it not being the JVM.

Perhaps a native extension could also be developed on android.
On 6 Nov 2014 08:02, "Ben Christensen" notifications@github.com wrote:

> Speaking with Tal Weiss at QConSF (@takipi https://github.com/takipi
> https://www.takipi.com) it sounds like there may be some efficient
> approaches to capturing the callstack as longs (using C in native code) at
> each async invocation point in an Observable sequence so that in event of
> onError we could rebuild the stacktrace (paying the cost only then) and
> end up with more useful error information that normal stack traces offer in
> async and composed systems like Rx.
> 
> This could enhance what we can do with
> https://github.com/ReactiveX/RxJavaDebug but also allow an "RxException"
> that contains the graph and callstack at each method invocation point along
> the way. It won't necessarily be a simple stack since an Observable can
> split and merge, but we should be able to either capture the full graph or
> the path to the error.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1823.
 =||= I doubt this particular option would be available on Android. I don't know enough about Dalvik at this time to understand options. If Dalvik exposes hooks or APIs that allow this type of thing we could definitely take advantage of it. 
 =||= What is the trick to do that?
 =||= More on this topic can be found here: http://www.takipiblog.com/double-agent-java-vs-native-agents/

It goes beyond my skill set so can only conceptually discuss it. Apparently the concept is:
- at each call site capture a pointer to memory in C with the callstack information
- store this pointer in the Java object (Observable operator instance?)
- if debug occurs (manually or via onError) read through the pointers and capture the callstacks for each operator
- build a "callstack graph" for the Observable chain (expensive, memory allocation, getting code lines etc)
- if more than x seconds passes free up the memory of those callstacks in C that are being referenced by pointers

Apparently this can be done very efficiently in C++ deep in the JVM with a native agent. In Java however it is quite expensive to call `Thread.getStackTrace()` as it done many native calls and allocates a large array of strings, so we definitely don't want to be doing that on every operator invocation in the happy path.
 =||= PR is welcome, although it might be better to have such tool in a separate project - not sure how we'd build and release a separate agent jar with the current infrastructure.
 =||= Android does have NDK (C and C++) with JNI access too. 
 =||= Closing as very old and being a complicated topic. Other async solutions also struggle with this and I haven't seen any solution for the either despite the support from their major IDE vendor. =||= ,0
6737,1821,Execution stops after ~1024 events,Why does the following code stop executing after roughly 1024 events? Am I doing something wrong? 

I'm using rxjava-scala 0.20.2, and Scala 2.11.1

```
import rx.lang.scala.Observable
import rx.lang.scala.Subject
import rx.lang.scala.Subscriber
import rx.lang.scala.schedulers.NewThreadScheduler

object ThreadsObserveOn {
  def main(args: Array[String]) {
    val obs = Observable((s: Subscriber[Int]) => {
        var i = 0
        while (true) {
          s.onNext(i)
          i = i + 1
        }
    })
    obs.observeOn(NewThreadScheduler()).subscribe(println(_))
    readLine()
  }
}
```

Edit: Removed the new thread from the example.,First of all, never use new Thread, but instead use a scheduler.
That said, you have run into a back-pressure issue.
The println is probably too slow to keep up with the producer.
 =||= Hi Erik, thanks for your quick reply! I removed the usage of a new thread, and it does not seem to change the behavior. I also noticed that when I remove the "observeOn" everything works, and back-pressure is not an issue for many millions of iterations. The following example works as I would have expected:

```
import rx.lang.scala.Observable
import rx.lang.scala.Subject
import rx.lang.scala.Subscriber
import rx.lang.scala.schedulers.NewThreadScheduler

object ThreadsObserveOn {
  def main(args: Array[String]) {
    val obs = Observable((s: Subscriber[Int]) => {
        var i = 0
        while (true) {
          s.onNext(i)
          i = i + 1
        }
    })
    obs.subscribe(println(_))
    readLine()
  }
}
```
 =||= The `Observable` created here is not "backpressure aware" and emits more than `observeOn` has requested. That is why you get the exception:

```
0
Exception in thread "RxNewThreadScheduler-1" java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:50)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Caused by: rx.exceptions.OnErrorNotImplementedException
    at rx.Observable$31.onError(Observable.java:7204)
    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:127)
    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:96)
    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:147)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:177)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:65)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:153)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)
    ... 7 more
Caused by: rx.exceptions.MissingBackpressureException
    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:222)
    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:115)
    at rx.lang.scala.Subscriber$$anon$2.onNext(Subscriber.scala:70)
    at ThreadsObserveOn$$anonfun$1.apply(ThreadsObserveOn.scala:10)
    at ThreadsObserveOn$$anonfun$1.apply(ThreadsObserveOn.scala:8)
    at rx.lang.scala.ImplicitFunctionConversions$$anon$1.call(ImplicitFunctionConversions.scala:53)
    at rx.lang.scala.ImplicitFunctionConversions$$anon$1.call(ImplicitFunctionConversions.scala:51)
    at rx.Observable$1.call(Observable.java:145)
    at rx.Observable$1.call(Observable.java:137)
    at rx.Observable.subscribe(Observable.java:7463)
    at rx.Observable.subscribe(Observable.java:7195)
    at rx.lang.scala.Observable$class.subscribe(Observable.scala:188)
    at rx.lang.scala.JavaConversions$$anon$3.subscribe(JavaConversions.scala:53)
    at ThreadsObserveOn$.main(ThreadsObserveOn.scala:15)
    at ThreadsObserveOn.main(ThreadsObserveOn.scala)
```

Your `Observable` implementation is spinning as fast as it can and not using the `Producer` to work with backpressure and is thus a "hot" source. 

To consume data from a hot source such as this you would have to choose to buffer, throttle, sample or drop data if the producer is faster than the consumer (which it is when going via an async boundary such as `observeOn`).

Or you can make it support backpressure which can be done by using `subscriber.setProducer` inside the onSubscribe function. 

Here is the implementation of the `range` operator in Java that supports backpressure: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OnSubscribeRange.java
 =||= Ok, thanks! I will look into providing for back-pressure. I have just run the example with 0.20.2, 0.20.0-RC6, and 0.20.6, but I haven't got the MissingBackpressureException on my machine? It just blocks after ~1024 events. What versions of Scala & RxJava are you using? 
 =||= Add an onError handler and you'll see it, or upgrade to the latest version (0.22 of RxScala) and RxJava 1.0.0 as it fixed an issue where an async operator like observeOn could fail silently when an onError handler was not provided. 
 =||= Add the error handler like this:

``` scala
import rx.lang.scala.Observable
import rx.lang.scala.Subject
import rx.lang.scala.Subscriber
import rx.lang.scala.schedulers.NewThreadScheduler

object ThreadsObserveOn {
  def main(args: Array[String]) {
    val obs = Observable((s: Subscriber[Int]) => {
        var i = 0
        while (true) {
          s.onNext(i)
          i = i + 1
        }
    })
    obs.subscribe(println(_), _.printStackTrace())
    readLine()
  }
}
```
 =||= Ok, I will see if I can easily upgrade to the newest versions. Thanks again, you have been a great help!
 =||= ,0
6737,1820,Can we optimize RxRingBuffer#SIZE == 1024 ?,The default capacity of 1024 for RxRingBuffers can be significant on memory constrained environments like Android. Also, IndexedRingBuffer#SIZE == 512

Could RxRingBuffer#SIZE be smaller, made dynamic ( auto-sizing ), or user configurable? ,Yes we can, I always intended to have a solution for Android but never got around to it.

> made dynamic ( auto-sizing )

I don't really like this approach as one reason for the ring buffer is to allow object pooling since allocating and deallocating arrays/queues/lists/nodes was killing high-throughput systems until I put in place this current model.

Also, auto-sizing doesn't make sense to me with backpressure, as when backpressure is needed it would end up growing to whatever the max size is that has been set anyways, so you'd end up growing it to whatever that limit is.

Do you have a suggested solution for auto-sizing that doesn't have those issues?

> Could RxRingBuffer#SIZE be smaller

Perhaps, it works as small as 1 (though that somewhat defeats the purpose). I found 256/512/1024 to be reasonable defaults. I'm open to changing the overall default to 512 instead of 1024.

> user configurable

This is a viable option that would should probably enable. It would need to be a global default (such as via a System property) that is hit once on initialization then used for all of them (due to object pooling).

We can also special case Android to default to something lower (such as 32?) and maybe even look at the client/server JRE and run 128 for client and 512/1024 for server.

What do you suggest?
 =||= Probably a lower default for Android would be good ( with a system property to override, increase/decrease ). 

I would have to try it out on our app, but 8 or 16 would probably work as an Android default.
Maybe start with user configurable and then let Android users try it out and make recommendations. 

As an aside, I think ArrayList defaults to capacity 0 on Android ( as opposed to 10 in some other environments ). 
 =||= ,0
6737,1828,Backpressure: Window by Size,The `window` operators that use time or Observable boundaries do not participate in backpressure ... they act as "temporal" operators for flow control and not reactive pull. The `window(int size)` variant however seems like it should work with reactive pull backpressure and behave similarly to `groupBy`. 

In other words, it can be applied to a cold observable and correctly compose backpressure to emit windows and items within each window at a controlled rate. 

Any thoughts or opinions on this?,Yes, anything with count sounds like a slamdunk to participate in back-pressure. In fact, I can imagine we would ask for chunks the size of the window.
 =||= I'll try and get this done in time. 
 =||= I'm probably not going to get this in for 1.0.0 so it will have to come during the 1.0.x releases.
 =||= In layman's terms, this feature request is a sliding window for the latest up to N elements over T time, right?

I'm going through the documentation and haven't found anything similar, and it's a common use component in this environments.
 =||= @pakoito no, this is adding reactive pull backpressure to already existing functionality. 

Go ahead and open a new issue with your use case if the operators are not working for you (see http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler) )
 =||= That operator is what I was after, thank you. I would add to the documentation/example that the windows for that case can overlap, unlike other count based window/buffer operations.
 =||= > The window(int size) variant however seems like it should work with reactive pull backpressure and behave similarly to groupBy.

I think it's more like `buffer`. Only support to request the number of `Window`s., but don't support backpressure for each Window Observable. Right? 
 =||= I actually see this one as more similar to `groupBy` as it needs to provide backpressure on all windows, otherwise there isn't any backpressure.
 =||= Is this in the works? @zsxwing PR #1862 was closed do you want to revive it?
 =||= I'm busy with other work and may not go back to work on this one soon. If someone is interested in the issue, please go head.
 =||= Window supports backpressure on the outer Observable as of 1.0.14 and there is a PR that adds backpressure support to the inner observable: #3150.
 =||= Backpressure support added + there is a subsequent fix to this, #3678
 =||= Closing via #3678.
 =||= ,0
6737,1823,Native Java Agent for "Async Call Stacks",Speaking with Tal Weiss at QConSF (@takipi https://www.takipi.com) it sounds like there may be some efficient approaches to capturing the callstack as longs (using C in native code) at each async invocation point in an `Observable` sequence so that in event of `onError` we could rebuild the stacktrace (paying the cost only then) and end up with more useful error information that normal stack traces offer in async and composed systems like Rx. 

This could enhance what we can do with https://github.com/ReactiveX/RxJavaDebug but also allow an "RxException" that contains the graph and callstack at each method invocation point along the way. It won't necessarily be a simple stack since an Observable can split and merge, but we should be able to either capture the full graph or the path to the error.,This would be amazing. Would it work on Android though? I assume not, due
to it not being the JVM.

Perhaps a native extension could also be developed on android.
On 6 Nov 2014 08:02, "Ben Christensen" notifications@github.com wrote:

> Speaking with Tal Weiss at QConSF (@takipi https://github.com/takipi
> https://www.takipi.com) it sounds like there may be some efficient
> approaches to capturing the callstack as longs (using C in native code) at
> each async invocation point in an Observable sequence so that in event of
> onError we could rebuild the stacktrace (paying the cost only then) and
> end up with more useful error information that normal stack traces offer in
> async and composed systems like Rx.
> 
> This could enhance what we can do with
> https://github.com/ReactiveX/RxJavaDebug but also allow an "RxException"
> that contains the graph and callstack at each method invocation point along
> the way. It won't necessarily be a simple stack since an Observable can
> split and merge, but we should be able to either capture the full graph or
> the path to the error.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1823.
 =||= I doubt this particular option would be available on Android. I don't know enough about Dalvik at this time to understand options. If Dalvik exposes hooks or APIs that allow this type of thing we could definitely take advantage of it. 
 =||= What is the trick to do that?
 =||= More on this topic can be found here: http://www.takipiblog.com/double-agent-java-vs-native-agents/

It goes beyond my skill set so can only conceptually discuss it. Apparently the concept is:
- at each call site capture a pointer to memory in C with the callstack information
- store this pointer in the Java object (Observable operator instance?)
- if debug occurs (manually or via onError) read through the pointers and capture the callstacks for each operator
- build a "callstack graph" for the Observable chain (expensive, memory allocation, getting code lines etc)
- if more than x seconds passes free up the memory of those callstacks in C that are being referenced by pointers

Apparently this can be done very efficiently in C++ deep in the JVM with a native agent. In Java however it is quite expensive to call `Thread.getStackTrace()` as it done many native calls and allocates a large array of strings, so we definitely don't want to be doing that on every operator invocation in the happy path.
 =||= PR is welcome, although it might be better to have such tool in a separate project - not sure how we'd build and release a separate agent jar with the current infrastructure.
 =||= Android does have NDK (C and C++) with JNI access too. 
 =||= Closing as very old and being a complicated topic. Other async solutions also struggle with this and I haven't seen any solution for the either despite the support from their major IDE vendor. =||= ,0
6744,6696,2.x: Surprising scheduler behaviour,# Brief description
Given a shared upstream and two flows using `.observeOn()` before `.filter()` may change the original emission order.

# RxJava Version
`2.2.13`

# Code sample
```
private val subject = PublishSubject.create<Int>().toSerialized()
private val singleScheduler = Schedulers.single()

fun filterSubjectForIdOnScheduler(id: Int): Observable<Int> {
    return subject
        .observeOn(singleScheduler)
        .filter {
            Log.e("filter", "id = $id value = $it")
            it == id
        }
}

fun main() {
    Observable.merge(
        filterSubjectForIdOnScheduler(1),
        filterSubjectForIdOnScheduler(2)
    )
        .subscribe { Log.e("subscribe", "value = $it") }

    subject.onNext(2)
    subject.onNext(1)
}
```

# Actual (surprising) result
```
14491-14855 E/filter: id = 1 value = 2
14491-14855 E/filter: id = 1 value = 1
14491-14855 E/subscribe: value = 1
14491-14855 E/filter: id = 2 value = 2
14491-14855 E/subscribe: value = 2
14491-14855 E/filter: id = 2 value = 1
```

# Expected result
```
14491-14855 E/filter: id = 1 value = 2
14491-14855 E/filter: id = 2 value = 2
14491-14855 E/subscribe: value = 2
14491-14855 E/filter: id = 1 value = 1
14491-14855 E/subscribe: value = 1
14491-14855 E/filter: id = 2 value = 1
```

# Notes
1. The code originally used a `Schedulers.from(Executors.newSingleThreadExecutor())` — I thought that somehow the executors may be optimised in a way that batches individual runnables and cycles them before cycling the queue of observers. I found `Schedulers.single()` which states (emphasis mine):
>      * Returns a default, shared, single-thread-backed {@link Scheduler} instance for work
>      * requiring >>>strongly-sequential<<< execution on the same background thread.
2. Instead of using `.observeOn()` calling via `scheduleDirect` yields expected results:
```
singleScheduler.scheduleDirect { subject.onNext(2) }
singleScheduler.scheduleDirect { subject.onNext(1) }
// or
singleScheduler.scheduleDirect {
    subject.onNext(2)
    subject.onNext(1)
}
```
3. It seems that the scheduler has two queues. One for emissions and one for observers. The emissions queue seems to be cycled before the queue of observers where sequential processing seemingly would need different priority of cycling (notify all observers about the first emission before proceeding to a next one).

# Question
Is the actual result an expected one?
If so — could you explain why? Is it possible to alter the flow without reordering operators and achieve expected results?,`observeOn` keeps the single thread occupied as long as it sees work, in this case, the values 2 and 1 in quick succession. Try `delay(0)` which schedules events individually. =||= > Try `delay(0)` which schedules events individually.

Do you mean `.delay(0, TimeUnit.SECONDS)`? I have tried adding it before and after `.observeOn()` but it seems to work the same. =||= Replace `observeOn` with `delay(0, TimeUnit.SECONDS)`. =||= Using `.delay(0, TimeUnit.SECONDS, singleScheduler)` instead of `.observeOn(singleScheduler)` changed the behaviour to one that matches the expected result.

For me this looks awkward — as a user I would like to observe on a specified scheduler in sequential order. Currently it seems to violate [Law of least surprise](https://en.wikipedia.org/wiki/Principle_of_least_astonishment). How do you think? Or maybe current implementation has some obvious performance advantage that I am unaware of? =||= `observeOn` is designed to do as much work in a drain run as possible. 

Reactive concurrency is complicated and scheduling is an orthogonal concept (when vs. where), hence a perfectly sequential scheduler used with an operator can result in non-intuitive event signaling pattern downstream. Also your type of lockstepping and coordination is rare. =||= Is this well described somewhere so I could study the topic a bit more?

> Reactive concurrency is complicated and scheduling is an orthogonal concept (when vs. where), hence a perfectly sequential scheduler used with an operator can result in non-intuitive event signaling pattern downstream.

Should this be mentioned somewhere? It looks like an important gotcha.

> Also your type of lockstepping and coordination is rare.

I use this approach to relief the calling thread as quickly as possible since it is bound to native code and prone to break the underlying system that I do not control (here modelled as the `subject`). =||= See [my blog](http://akarnokd.blogspot.com/2015/05/operator-concurrency-primitives.html) and the [operator writing guide](https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0).

> Should this be mentioned somewhere?

The `observeOn` Javadoc can be updated to mention its eagerness. =||= A helper question — do you know why schedulers are designed this way by default (instead of being basically equivalent to `.delay(0, timeUnit, scheduler)`? =||= Scheduler is an abstraction over crossing an asynchronous boundary by providing methods to run work somewhere. It doesn't know what or how much work it means. `observeOn` is designed to be low overhead (both time and allocation) when moving data between threads. `delay` has to schedule each item individually which adds a lot of allocation. =||= I think this topic is cleared and appropriate [Javadoc change has landed](https://github.com/ReactiveX/RxJava/pull/6700) so I am closing. Thank you very much for the help.

I do have some other questions about surface'ing reactive and non-reactive world. 
1. Difference in how `Observable`s are subscribed and disposed when using `.subscribeOn()` and without it — in the first situation the `Observable` may or may not be subscribed depending on a race condition and in the second it will always be subscribed. Funny thing is that `TestScheduler` seems to work as no `.subscribeOn()` is present rather than other schedulers.
2. `UndeliverableException` — this is something that is seemingly impossible to mitigate in a multi-threaded environment as there always may be a race condition under which the `Observer` will already be unsubscribed.

I would like to discuss those matters or find a way to learn on how to deal with them. Should I create separate issues or...? =||= 1. `subscribeOn` always signals `onSubscribe` but the subscription towards the upstream should be properly depend on when `TestScheduler::triggerActions()` is invoked.
2. I don't think there is anything to discuss about this. Errors must not get lost upon disposing and Rx can't decide which to ignore. https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling =||= 1. Apparently there are some optimisations which make `observable.subscribeOn().subscribe().dispose()` subscribing/not subscribing to the `observable` depending on a race condition. I see some weird behaviour in my tests but I assume I got something wrong. Will dig deeper and keep you posted if I find something funny.
2. I know this, I was hoping that it may be somehow handled by the code that uses RxJava 2. Current design does not allow for using RxJava 2 as an implementation detail. It cannot really be encapsulated due to static handlers. =||= ,0
6745,674,API Design Review: rx.join.ObserverBase,The `rx.join.ObserverBase` class should not be public as part of the rxjava-core API.

It needs to be deleted or made private. It replicates behavior of `SafeObserver` which is also kept private. 

/cc @headinthebox and @jhusain,nan,0
6748,674,API Design Review: rx.join.ObserverBase,The `rx.join.ObserverBase` class should not be public as part of the rxjava-core API.

It needs to be deleted or made private. It replicates behavior of `SafeObserver` which is also kept private. 

/cc @headinthebox and @jhusain,nan,0
6754,675,API Design Review: Zip Overload Without Function,While reviewing the `zip` operators it was suggested we add an overload that returns `Observable<List<R>>` and doesn't take a function. It would allow zipping without explicitly defining a function. If we had tuples we would return those. Since we don't we'll return `List<R>`.

/cc @headinthebox and @jhusain,More precisely, this transposes iterable<observable<T>> to observable<list<t>> 
 =||= Do we still want this overload?
 =||= Not for me.
 =||= Closing ... not important and additive so it can always be done later.
 =||= ,0
6756,675,API Design Review: Zip Overload Without Function,While reviewing the `zip` operators it was suggested we add an overload that returns `Observable<List<R>>` and doesn't take a function. It would allow zipping without explicitly defining a function. If we had tuples we would return those. Since we don't we'll return `List<R>`.

/cc @headinthebox and @jhusain,More precisely, this transposes iterable<observable<T>> to observable<list<t>> 
 =||= Do we still want this overload?
 =||= Not for me.
 =||= Closing ... not important and additive so it can always be done later.
 =||= ,0
6762,676,API Design Review: SafeObserver via Reflection or Marker Interface	,The `SafeObserver` wrapper is applied to all `Observer` implementations passed into `Observable.subscribe` by users but it is not applied to any `Observer` implementations that originate from within the `rx.operators` package.

This is so we achieve the desired safety and error handling while not paying the cost of wrapping trusted `Observer` implementations from internal operators.

Today it uses reflection to look at the package the `Observer` originates from. It then caches this information for performance.  

See here: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L238 and here:  https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L6822

It is not pretty but it works.

The other way is we could put marker interfaces such as `TrustedObserver` on all `Observer` implementations we use in `rx.operators` or elsewhere that should not be wrapped.

Pros:
- doesn't involve reflection
- obvious
- can be used by non-internal operators

Cons:
- marker interfaces require remembering to put them where they should be
- they can be put where they're not supposed to be
- can be used by non-internal operators and misused
- they are an extra type to maintain in the public API serving little value

Neither approach is pretty. Is there another approach? If not, which of these two is preferable and why?

/cc @headinthebox and @jhusain,Since `Observable` code changes often enough those links will become wrong so here is the valid code:

``` java
/**
     * Whether a given {@link Function} is an internal implementation inside
     * rx.* packages or not.
     * <p>
     * For why this is being used see
     * https://github.com/Netflix/RxJava/issues/216 for discussion on
     * "Guideline 6.4: Protect calls to user code from within an operator"
     * 
     * Note: If strong reasons for not depending on package names comes up then
     * the implementation of this method can change to looking for a marker
     * interface.
     * 
     * @param o
     * @return {@code true} if the given function is an internal implementation,
     *         and {@code false} otherwise.
     */
    private boolean isInternalImplementation(Object o) {
        if (o == null) {
            return true;
        }
        // prevent double-wrapping (yeah it happens)
        if (o instanceof SafeObserver) {
            return true;
        }

        Class<?> clazz = o.getClass();
        if (internalClassMap.containsKey(clazz)) {
            //don't need to do reflection
            return internalClassMap.get(clazz);
        } else {
            // we treat the following package as "internal" and don't wrap it
            Package p = o.getClass().getPackage(); // it can be null
            Boolean isInternal = (p != null && p.getName().startsWith("rx.operators"));
            internalClassMap.put(clazz, isInternal);
            return isInternal;
        }
    }
```

``` java
if (isInternalImplementation(observer)) {
                Subscription s = onSubscribeFunction.onSubscribe(observer);
                if (s == null) {
                    // this generally shouldn't be the case on a 'trusted' onSubscribe but in case it happens
                    // we want to gracefully handle it the same as SafeObservableSubscription does
                    return hook.onSubscribeReturn(this, Subscriptions.empty());
                } else {
                    return hook.onSubscribeReturn(this, s);
                }
            } else {
                SafeObservableSubscription subscription = new SafeObservableSubscription();
                subscription.wrap(onSubscribeFunction.onSubscribe(new SafeObserver<T>(subscription, observer)));
                return hook.onSubscribeReturn(this, subscription);
            }
```
 =||= FWIW, I'd lean toward option 2. (Wouldn't this still result in using reflection though, since you'd have to check for the annotation at runtime?)

> marker interfaces require remembering to put them where they should be

True. Is this something that could be caught using static analysis?

> they can be put where they're not supposed to be

But so can any class level annotation. And it can be made only applicable to classes via the target property. I don't see this being an issue really.

> can be used by non-internal operators and misused

Sure. Then again, whoever misuses this to mark a misbehaving observer as trusted is only shooting themselves in the foot? You get what you ask for :-) 

> they are an extra type to maintain in the public API serving little value

Are you referring to the marker interface? What's the maintenance overhead though, apart from having to remember applying it to internal observers?

Would be interested in hearing what others have to say
 =||= Another option I've become more comfortable with (and that @headinthebox prefers) is that we add `Observable.unsafeSubscribe` that `Operator` implementations can use and it does what it says ... subscribe without any "safety" wrapping. It would directly invoke the inner `OnSubscribe` function.
 =||= Yes, that's what I would prefer. ^F for "unsafe" during code reviews to spot where people may shoot themselves in the foot that don't know what they are doing, but allow full power in case you need to implement a new operator.
 =||= I see. I would find it a bit odd though to find unsafeSubscribe invocations
throughout my client code, even when I know it's safe. It would raise eye
brows for people not as familiar with the peculiarities of the library.
 =||= Do you create operators that act on nested Observables? Examples are `repeat`, `retry`, `merge`.

Those are the only scenario where an `unsafeSubscribe` is needed. Otherwise, normal `Operator` implementations like `map`, `take`, `filter`, etc do not need to.
 =||= Here is an example location where it is doing an "unsafe subscribe": https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorRepeat.java?source=c#L80

Whereas in `map` you'll see it never subscribes because it is a `Subscriber` -> `Subscriber` transformation that gets lifted into the `Observable`: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorMap.java
 =||= I intend on doing this in 0.18 along with `Scheduler` changes. Do my last explanations make sense, or is there still concern about this change?

The only time when this will need to be used is when implementing operators that do nested subscriptions. 
 =||= +1

On Mon, Mar 31, 2014 at 7:34 PM, Ben Christensen
notifications@github.comwrote:

> I intend on doing this in 0.18 along with Scheduler changes. Do my last
> explanations make sense, or is there still concern about this change?
> 
> The only time when this will need to be used is when implementing
> operators that do nested subscriptions.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/676#issuecomment-39117035
> .
 =||= Thanks for the positive confirmation @mttkay ... I'll proceed with this.
 =||= Completed in https://github.com/Netflix/RxJava/pull/1010
 =||= ,0
6764,1815,Put on subscriber.onStart in an interface. ,It would be nice to have the onStart functionality, but not have to inherit implementation from Subscriber. 

Maybe onStart could be moved to an interface ( e.g. StartableObserver extends Observer ) and then Subscriber could implement StartableObserver.,What are you trying to achieve?
 =||= This came up while I was implementing an add-on on top of RxJava. I did find another solution.  

Essentially, I want to be able to have a fully custom Subscriber implementation ( not having to use any of the logic in the Subscriber abstract class ), but still being able to take advantage of onStart. 
 =||= What use case is unable to be achieved by extending `Subscriber`? It is an abstract class by design and we have consciously avoided adding more types.
 =||= Is this question still something you'd like to discuss?
 =||= Closing due to inactivity. If you have further questions, please reopen this issue or create a new one.
 =||= ,0
6764,1845,RxRingBuffer Concurrent Unsubscribe Non-ThreadSafe,rx-java version 0.20.6

```
java.lang.NullPointerException
        at rx.internal.util.RxRingBuffer.poll(RxRingBuffer.java:282)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.drainAll(OperatorMerge.java:723)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.drainQueue(OperatorMerge.java:744)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.access$300(OperatorMerge.java:505)
        at rx.internal.operators.OperatorMerge$MergeSubscriber$1.call(OperatorMerge.java:376)
        at rx.internal.operators.OperatorMerge$MergeSubscriber$1.call(OperatorMerge.java:369)
        at rx.internal.util.IndexedRingBuffer.forEach(IndexedRingBuffer.java:281)
        at rx.internal.util.IndexedRingBuffer.forEach(IndexedRingBuffer.java:247)
        at rx.internal.util.SubscriptionIndexedRingBuffer.forEach(SubscriptionIndexedRingBuffer.java:131)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainChildrenQueues(OperatorMerge.java:331)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.drainQueuesIfNeeded(OperatorMerge.java:308)
        at rx.internal.operators.OperatorMerge$MergeSubscriber.access$400(OperatorMerge.java:96)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:674)
        at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:528)
        at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)
        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:105)
        at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:96)
        at rx.internal.operators.OperatorSubscribeOn$1$1$1$1.request(OperatorSubscribeOn.java:88)
        at rx.Subscriber.setProducer(Subscriber.java:150)
        at rx.internal.operators.OperatorSubscribeOn$1$1$1.setProducer(OperatorSubscribeOn.java:81)
        at rx.Subscriber.setProducer(Subscriber.java:144)
        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)
        at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:33)
        at rx.Observable.subscribe(Observable.java:8680)
        at ********************
        at ********************
        at rx.Observable.unsafeSubscribe(Observable.java:8591)
        at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
        at rx.schedulers.ExecutorScheduler$ExecutorAction.run(ExecutorScheduler.java:173)
        at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(ExecutorScheduler.java:99)
        at java.util.concurrent.ForkJoinTask$AdaptedRunnable.exec(ForkJoinTask.java:1265)
        at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:334)
        at java.util.concurrent.ForkJoinWorkerThread.execTask(ForkJoinWorkerThread.java:604)
        at java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:784)
        at java.util.concurrent.ForkJoinPool.work(ForkJoinPool.java:646)
        at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:398)
```,Are you able to reproduce this and can you provide a unit test?

Does this also occur with RxJava 1.0.0-rc.10? 
 =||= I was able to consistently reproduce this bug with the following:

https://gist.github.com/laktech/5bba374f394d12956210

and here is the stack trace for the unit test:

https://gist.github.com/laktech/dcac7edb94fde2d037a6

It fails on both 0.20.6 and 1.0.0-rc.10. Succeeds on 0.19.6.
 =||= Thanks. I'll look at this.
 =||= The queue is null on that line, so either it was released before, or the pool didn't provide one at start or there is a visibility issue because it is not volatile.
 =||= > I was able to consistently reproduce this bug with the following:

Thank you, very helpful. It fails every time for me ... but if I remove `subscribeOn` it works so there is a race condition somewhere. 

Working on this now.
 =||= The code can be fixed by removing the nested `subscribe` and composing things:

``` java
    private Observable<Integer> keysObservable() {
        return Observable.range(0, 10000).flatMap(new Func1<Integer, Observable<Integer>>() {

            @Override
            public Observable<Integer> call(final Integer t1) {
                return Observable.from(listItems(1)).subscribeOn(executorScheduler);

//                return Observable.create(new OnSubscribe<Integer>() {
//
//                    @Override
//                    public void call(Subscriber<? super Integer> t2) {
//                        Observable.from(listItems(1)).subscribe(t2);
//                    }
//                }).subscribeOn(executorScheduler);
            }
        });
    }
```

I am still trying to figure out if there is a way to handle the RxRingBuffer issue when it gets unsubscribed prematurely.
 =||= This is going to have to be done in 1.0.x as it's going to take some thought and work.

This is an edge case so I'm comfortable continuing with 1.0 as is since this code has spent a couple months being used.

@laktech I suggest you adopt the composition approach shown in my previous comment and avoid using `subscribe` to compose things together. It chains subscriptions together which can have unexpected results. The composition operators like `merge` (used by `flatMap`) take care of this and use `unsafeSubscribe` to chain subscriptions through.

I'll come back to this and try to figure out a way for RxRingBuffer to behave safely with concurrent unsubscribe while not killing the performance. 
 =||= @benjchristensen Thanks for looking into this.

Are there any semantical differences between using `subscribe` and the composition approach? My motivation to invoke `subscribe` was to ensure `listFiles(1)` was 1) invoked for each subscriber and 2) not called until there was a subscriber, which is very explicit with `subscribe`. It seems easy to test but thought I'd just ask :-P
 =||= Semantically no, it will get invoked the same as what is being done via the manual `Observable.create`.`subscribe`. If you change the `subscribe` to `unsafeSubscribe` you'll get the correct behavior without the over-eager unsubscribe which is causing the issues.
 =||= Great, thanks for the work-around.
 =||= Reading code again, the `listFiles(1)` is slightly more eager in the composed version and will happen on the emitting thread rather than the `subscribeOn` thread since it happens inside the `flatMap` rather than the `subscribeOn`. 

So if you want to solve that you could use `defer`:

``` java
return Observable.defer(() -> Observable.from(listItems(1))).subscribeOn(executorScheduler);
```

In my test this moves the `listItems` from the main thread to the scheduler thread.
 =||= I've tried to fix this but apart from making the NPE go away by reading queue once everywhere and not adding the RxRingBuffer to the InnerSubscription to be unsubscribed, I'm lost. What I would like to do is to call queue.unsubscribe if the inner subscription receives an onError or onCompleted, but due to backpressure, I'm not certain if putting it into drainRequested and drainAll is enough.

https://gist.github.com/akarnokd/fc1f2e1946bb39e8794a
 =||= Fixed in 1.0.5.
 =||= ,0
6764,1815,Put on subscriber.onStart in an interface. ,It would be nice to have the onStart functionality, but not have to inherit implementation from Subscriber. 

Maybe onStart could be moved to an interface ( e.g. StartableObserver extends Observer ) and then Subscriber could implement StartableObserver.,What are you trying to achieve?
 =||= This came up while I was implementing an add-on on top of RxJava. I did find another solution.  

Essentially, I want to be able to have a fully custom Subscriber implementation ( not having to use any of the logic in the Subscriber abstract class ), but still being able to take advantage of onStart. 
 =||= What use case is unable to be achieved by extending `Subscriber`? It is an abstract class by design and we have consciously avoided adding more types.
 =||= Is this question still something you'd like to discuss?
 =||= Closing due to inactivity. If you have further questions, please reopen this issue or create a new one.
 =||= ,0
6764,1818,Concat Breaks with Double onCompleted,This unit tests causes `concat` to never complete:

``` java
    @Test
    public void testConcatWithNonCompliantSourceDoubleOnComplete() {
        Observable<String> o = Observable.create(new OnSubscribe<String>() {

            @Override
            public void call(Subscriber<? super String> s) {
                s.onNext("hello");
                s.onCompleted();
                s.onCompleted();
            }

        });

        TestSubscriber<String> ts = new TestSubscriber<String>();
        Observable.concat(o, o).subscribe(ts);
        ts.awaitTerminalEvent(500, TimeUnit.MILLISECONDS);
        ts.assertTerminalEvent();
        ts.assertNoErrors();
        ts.assertReceivedOnNext(Arrays.asList("hello", "hello"));
    }
```

This was found by @mattrjacobs ,nan,0
6764,1842,Actioni,Missing doc comments for `Action0` ..`Action 3`

```
Action0  
Action1<T1>  
Action2<T1,T2>   
Action3<T1,T2,T3>
```,I'm not really sure what is important to document about these. Could
someone who understands the purpose and reasoning behind these take a first
stab at the javadocs for them?

On Mon, Nov 10, 2014 at 10:54 AM, headinthebox notifications@github.com
wrote:

> Assigned #1842 https://github.com/ReactiveX/RxJava/issues/1842 to
> @DavidMGross https://github.com/DavidMGross.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1842#event-190960766.

## 

David M. Gross
PLP Consulting
 =||= These are missing, the others say "A i-argument action." That's plenty.
 =||= ,0
6764,1841,Exception Doc Comments,Sorry for the copy&paste, but that shows all doc comments for exceptions. My proposal would be to make the descriptions uniform and start each with "Represents ..."

~~CompositeException~~  
~~An Exception that is a composite of one or more other Exceptions.~~

CompositeException  
Represents an an exception that is a composite of one or more other Exceptions.

~~MissingBackpressureException
MissingBackpressureException indicates that a Subscriber or operator attempted to apply reactive pull
 backpressure to an Observable that does not implement it.~~

MissingBackpressureException  
Represents an exception that indicates that a Subscriber or operator attempted to apply reactive pull backpressure to an Observable that does not implement it.

~~OnErrorFailedException
Used to re-throw errors thrown from Observer.onError(Throwable).~~

OnErrorFailedException  
Represents an exception used to re-throw errors thrown from Observer.onError(Throwable).

~~OnErrorNotImplementedException  
Used to re-throw Observer.onError(Throwable) when an implementation doesn't exist~~.

OnErrorNotImplementedException  
Represents and exception used to re-throw Observer.onError(Throwable) when an implementation doesn't exist.

OnErrorThrowable  
Represents a Throwable that an Observable might notify its subscribers of, but that then can be handled by an operator that is designed to recover from or react appropriately to such an error.

OnErrorThrowable.OnNextValue  
Represents an exception that was encountered while trying to emit an item from an Observable, and tries to preserve that item for future use and/or reporting.,nan,0
6764,1839,[Request] New buffer operator with timespan, timeshift and count,```
public final Observable<java.util.List<T>> buffer(long timespan,
                                   long timeshift,
                                   java.util.concurrent.TimeUnit unit,
                                   __int count__)
```

Returns an Observable that emits buffers of items it collects from the source Observable. The resulting Observable starts a new buffer periodically, as determined by the timeshift argument, and on the specified scheduler. It emits each buffer after a fixed timespan, specified by the timespan argument. **It only emits if count items have been found during the timespan.**,Form your description, this sounds exactly like: `buffer(...).filter(b => b.length == count)`
 =||= Correct, but bundling it into one, as window already does, if I understand correctly.
 =||= That is not what that version of `window` does, that emits either when the time is up, or when the count is reached.
 =||= Then this is not an issue.
 =||= ,0
6764,1839,[Request] New buffer operator with timespan, timeshift and count,```
public final Observable<java.util.List<T>> buffer(long timespan,
                                   long timeshift,
                                   java.util.concurrent.TimeUnit unit,
                                   __int count__)
```

Returns an Observable that emits buffers of items it collects from the source Observable. The resulting Observable starts a new buffer periodically, as determined by the timeshift argument, and on the specified scheduler. It emits each buffer after a fixed timespan, specified by the timespan argument. **It only emits if count items have been found during the timespan.**,Form your description, this sounds exactly like: `buffer(...).filter(b => b.length == count)`
 =||= Correct, but bundling it into one, as window already does, if I understand correctly.
 =||= That is not what that version of `window` does, that emits either when the time is up, or when the count is reached.
 =||= Then this is not an issue.
 =||= ,0
6764,1795,Question regarding `retryWhen` source observable errors,One thing I'd like to be able to do is catch any final errors and report them. Right now, `retryWhen` will cause the subscriber to ignore 100% of the errors (unless the observable passed to `retryWhen` sends an `onError`, of course). `retry` and `retryWhen`, at least in one of my use cases in a user-facing application, mean "let's wait a sec, or try to fix something, and then try again".  If this collection of retry attempts completely fails, it'd be nice to know that, instead of just ending up with a `onCompleted` which doesn't tell me whether the thing I'm potentially retrying ultimately succeeded or failed altogether.

Is there another way of accomplishing this?,After thinking about this some more, I think it's actually reasonable for `retryWhen`'s arguments to determine when to quit, like the example mostly shows. The missing ingredient in my use case was to just bubble the error back up from within, instead of a `onCompleted`. Not sure why I didn't think of that earlier.
 =||= ,0
6764,1818,Concat Breaks with Double onCompleted,This unit tests causes `concat` to never complete:

``` java
    @Test
    public void testConcatWithNonCompliantSourceDoubleOnComplete() {
        Observable<String> o = Observable.create(new OnSubscribe<String>() {

            @Override
            public void call(Subscriber<? super String> s) {
                s.onNext("hello");
                s.onCompleted();
                s.onCompleted();
            }

        });

        TestSubscriber<String> ts = new TestSubscriber<String>();
        Observable.concat(o, o).subscribe(ts);
        ts.awaitTerminalEvent(500, TimeUnit.MILLISECONDS);
        ts.assertTerminalEvent();
        ts.assertNoErrors();
        ts.assertReceivedOnNext(Arrays.asList("hello", "hello"));
    }
```

This was found by @mattrjacobs ,nan,0
6764,1841,Exception Doc Comments,Sorry for the copy&paste, but that shows all doc comments for exceptions. My proposal would be to make the descriptions uniform and start each with "Represents ..."

~~CompositeException~~  
~~An Exception that is a composite of one or more other Exceptions.~~

CompositeException  
Represents an an exception that is a composite of one or more other Exceptions.

~~MissingBackpressureException
MissingBackpressureException indicates that a Subscriber or operator attempted to apply reactive pull
 backpressure to an Observable that does not implement it.~~

MissingBackpressureException  
Represents an exception that indicates that a Subscriber or operator attempted to apply reactive pull backpressure to an Observable that does not implement it.

~~OnErrorFailedException
Used to re-throw errors thrown from Observer.onError(Throwable).~~

OnErrorFailedException  
Represents an exception used to re-throw errors thrown from Observer.onError(Throwable).

~~OnErrorNotImplementedException  
Used to re-throw Observer.onError(Throwable) when an implementation doesn't exist~~.

OnErrorNotImplementedException  
Represents and exception used to re-throw Observer.onError(Throwable) when an implementation doesn't exist.

OnErrorThrowable  
Represents a Throwable that an Observable might notify its subscribers of, but that then can be handled by an operator that is designed to recover from or react appropriately to such an error.

OnErrorThrowable.OnNextValue  
Represents an exception that was encountered while trying to emit an item from an Observable, and tries to preserve that item for future use and/or reporting.,nan,0
6764,1842,Actioni,Missing doc comments for `Action0` ..`Action 3`

```
Action0  
Action1<T1>  
Action2<T1,T2>   
Action3<T1,T2,T3>
```,I'm not really sure what is important to document about these. Could
someone who understands the purpose and reasoning behind these take a first
stab at the javadocs for them?

On Mon, Nov 10, 2014 at 10:54 AM, headinthebox notifications@github.com
wrote:

> Assigned #1842 https://github.com/ReactiveX/RxJava/issues/1842 to
> @DavidMGross https://github.com/DavidMGross.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1842#event-190960766.

## 

David M. Gross
PLP Consulting
 =||= These are missing, the others say "A i-argument action." That's plenty.
 =||= ,0
6764,1795,Question regarding `retryWhen` source observable errors,One thing I'd like to be able to do is catch any final errors and report them. Right now, `retryWhen` will cause the subscriber to ignore 100% of the errors (unless the observable passed to `retryWhen` sends an `onError`, of course). `retry` and `retryWhen`, at least in one of my use cases in a user-facing application, mean "let's wait a sec, or try to fix something, and then try again".  If this collection of retry attempts completely fails, it'd be nice to know that, instead of just ending up with a `onCompleted` which doesn't tell me whether the thing I'm potentially retrying ultimately succeeded or failed altogether.

Is there another way of accomplishing this?,After thinking about this some more, I think it's actually reasonable for `retryWhen`'s arguments to determine when to quit, like the example mostly shows. The missing ingredient in my use case was to just bubble the error back up from within, instead of a `onCompleted`. Not sure why I didn't think of that earlier.
 =||= ,0
6764,1839,[Request] New buffer operator with timespan, timeshift and count,```
public final Observable<java.util.List<T>> buffer(long timespan,
                                   long timeshift,
                                   java.util.concurrent.TimeUnit unit,
                                   __int count__)
```

Returns an Observable that emits buffers of items it collects from the source Observable. The resulting Observable starts a new buffer periodically, as determined by the timeshift argument, and on the specified scheduler. It emits each buffer after a fixed timespan, specified by the timespan argument. **It only emits if count items have been found during the timespan.**,Form your description, this sounds exactly like: `buffer(...).filter(b => b.length == count)`
 =||= Correct, but bundling it into one, as window already does, if I understand correctly.
 =||= That is not what that version of `window` does, that emits either when the time is up, or when the count is reached.
 =||= Then this is not an issue.
 =||= ,0
6765,6695,3.x release vs. Java 8 support on Android ,Recently, the news came that [Android Studio 4 will support](https://developer.android.com/studio/preview/features#j8-desugar) a so-called "desugaring" of Java 8 APIs (i.e., some kind of auto-backport for target devices not supporting newer API levels as I understand). This would allow RxJava 3 to increase the baseline support to Java 8 on its surface API:

- `Stream` support
- Stream `Collector`s support
- `Optional` support
- `CompletableFuture` support
- Use site non-null annotations

Some features won't be supported:

- `java.time.Duration`: allocates, we'll stick to time+unit
- `java.util.function`: these can't throw `Throwable`s, overloads would create bloat and/or ambiguity

The main issue with Android's Java 8 support is timing related to the pledged release schedule of RxJava 3.x, **end of December 2019**. AGP 4 may not release for months, inclining us to:

- Wait for AGP's release, effectively parking RxJava 3 for months as release candidate. Drawback: AGP may slip a lot.
- Release on schedule with Java 6 baseline. Drawback: AGP may release shortly after and thus
  - we'd be stuck on 3.x for years;
  - we'd have to start working on 4.x undermining 3.x in a sense, also adding more maintenance burden;
  - we release 3.1 with baseline 8, abandoning 3.0 and possibly violating some pledge;
- Release on schedule with Java 8 baseline. Drawback: 3.x improvements won't be available to many at release.
- Release on schedule with Java 8 bytecode output but no 8 API use, add those in 3.1. Drawback: despite best efforts, this could cause problems with existing desugaring/tooling.

The same issue is likely to arise with the next step, Java 9 support on Android. From our perspective, support for the Flow.* interfaces would be just enough as none of the other 9 features would work (VarHandles - field reflection anomalies?, Cleaner - portable?, Modules?). Beyond 9, the next major change to RxJava would have to come due to value types (no version ETA yet). Loom/Fibers is likely simply an API expansion, not a fundamental change.

Suggestions, ideas welcome. ,Just some of my thoughts.

I'm not a fan of the 1st option, because literally nobody wins. People can still use RxJava 2 before AGP 4 comes out. I think the 3rd option makes a lot more sense than the 1st.

For Java 9 support, only supporting Flow.* interfaces to me doesn't justify requiring Java 9, as interoperating between the interfaces is pretty easy.

If I had to pick an option, I'd stick with Java 6. I've been using RxJava 2 with Java 8 on the server side, and not supporting Java 8 out-of-the-box does not feel like much of a hindrance, since the interop library is pretty nice and easy to use. Also, not requiring Java 8 is IMO one of the distinguishing features of RxJava vs Reactor Core.

I'm also okay with supporting Java 8 from the start and releasing on schedule. If RxJava 3 is set to support Java 8, it makes no sense to me to delay the initial release or to release it without Java 8 features. =||= In my opinion, if Java 6 is a must then go with RxJava2. The best option to me seems to be the third, although it means postponing some improvements that may come up gradually in the form of patches.

And maybe Java 11 would be a better choice than Java 9 in the future? Just thinking out loud... =||= > And maybe Java 11 would be a better choice than Java 9 in the future? Just thinking out loud...

I think requiring a newer Java version only makes sense if that version has features that are beneficial to RxJava. For Java 8 it's `Stream`s, `CompletableFuture`s, etc. For Java 9 it's `Flow.*` and potentially `Cleaner`? I don't think Java 11 has anything worthwhile. =||= +1 for option 3 =||= From Android's perspective, you do not need to wait for desguaring to ship to use the types mentioned.

 * `Stream`: Presumably this would only exist as a static factory for creating an `Observable`/`Flowable` from a `Stream` in which case this would only be callable on API 24+.
 * `Collector`: This would exist as a blocking consumer member method on `Observable`/`Flowable` which would only be callable on API 24+
 * `CompletableFuture`: Factory methods and conversion method for `Completable` and `Single` which would only be callable on API 24+
 * `Optional`: Not sure what this would be used for. Factory method for `Maybe`? If so, would only be callable on API 24+
 * `TYPE_USE` annotations: Have been removed by the build tooling for at least a year or two.

As long as none of the critical path uses these types and they're only used as leaf sources created by factories or leaf converters implemented as operators the rest of the API will work fine and these types will only be usable on API 24+.

When desugaring does ship, these APIs will magically work on older APIs without any change necessary. There is no need to wait for it to launch.

As to `Duration`, while you shouldn't use it internally because it allocates, it's still _very_ useful for APIs that accept timeouts or intervals so that you can carry the scalar and unit as a single value and store it as a type-safe constant. Internally, RxJava can immediately convert it to millis or its preferred unit. This, also could still be used today provided it's done as overloads which immediately convert into long. Those APIs would only work on API 26+ until desugaring launches when they'd become magically available on older versions.

So, basically, I vote 3 as well. =||= > As to `Duration`, while you shouldn't use it internally because it allocates, it's still very useful for APIs that accept timeouts or intervals so that you can carry the scalar and unit as a single value and store it as a type-safe constant. Internally, RxJava can immediately convert it to millis or its preferred unit. This, also could still be used today provided it's done as overloads which immediately convert into long. Those APIs would only work on API 26+ until desugaring launches when they'd become magically available on older versions.

As an example, OkHttp does this:

https://github.com/square/okhttp/blob/7e4870537e33e2f0c4ea39f97b3a7d41a6ba0711/okhttp/src/main/java/okhttp3/OkHttpClient.kt#L829-L846 =||= +1 to everything Jake mentioned. It's quite standard to compile against Java 8 in Android projects these days since the original introduction of Desugar. Android's linter protects against usage of any Java 8 APIs that wouldn't be covered under desugar, so there's no danger for consumers either as long as they're just top-level conversion APIs like Jake described above. =||= What do you mean by "leaf"? The following API integrations would be possible with Java 8:

```java
public static <T> Flowable<T> fromStream(Stream<T> stream);

public static <T> Flowable<T> fromCompletionStage(CompletionStage<T> cs);

public static <T> Flowable<T> fromOptional(Optional<T> option);

// -----

public Stream<T> blockingToStream();

public CompletionStage<T> firstElementStage();

public CompletionStage<T> firstOrErrorStage();

public CompletionStage<T> singleElementStage();

public CompletionStage<T> singleOrErrorStage();

public CompletionStage<T> lastElementStage();

public CompletionStage<T> lastOrErrorStage();

public <T, A, C, R> Single<R> collect(Collector<T, A, C, R> collector);

public <R> Flowable<R> mapOptional(Function<T, Optional<R>> mapper);

public <R> Flowable<R> flatMapStream(Function<T, Stream<R>> mapper);
```

So 3 static methods 10 instance methods with otherwise isolated implementations (existing operators wouldn't use Java 8 features such as `Objects` or Java 8 types, nor the backing implementations of these).

One risk is Java 8's `Objects` by the way, as a Java 8 compiler sometimes inserts it into the compiled output even though the source didn't mention it (example: #5966). =||= I'm pretty sure `Objects` is available on Java 7. Also, wasn't https://github.com/ReactiveX/RxJava/pull/5966 caused by [error-prone](https://github.com/google/error-prone)? =||= `Objects.requireNonNull` has also been desugared automatically since AGP 3.0. =||= I have cobbled together a [small library](https://github.com/akarnokd/jdk-8-android-desugar-check) that uses Java 8 API and features. 

I've created a basic Android Studio 3.5.2 project using it from maven local and kept modifying the `compileSdkVersion`, `minSdkVersion` and `targetSdkVersion` to 14, 24 and 29.
- 14: Methods with `Stream`, `CompletionStage`, `Duration` and `Optional` won't compile
- 24: Methods with `Duration` won't compile
- 29: okay

Also tried AS 4 canary 5
- 14: `CompletableFuture` gives IDE error (minSdk >= 24 required), the project deploys successfully but fails at runtime with missing class. `CompletionStage` interface gives no error but its methods do.
- 24: okay
- 29: okay =||= > What do you mean by "leaf"?

Having no internal callers. All of your listed examples above seem like they fit the bill. As long as these operators and factories are not used internally (unless by overloads/similar functionality), they'll simply be unused for people who cannot use those types due to the NewApi lint check. =||= If I try the library with a `JavaVersion.VERSION_1_7` android project, not calling any of the JDK 8 APIs, I get the error

> The dependency contains Java 8 bytecode. Please enable desugaring by adding the following to build [...]

requiring the compile options set to 1.8. Is such version leap on a project otherwise not using Java 8 dependencies or features going to be fine? =||= It is becoming common for libraries to do this nowadays, yes. Java 8 is ancient at this point, and the fact that the Android tooling has not made it the default is ridiculous. OkHttp did it 9 months ago and it's one of the most popular libraries on the platform: https://developer.squareup.com/blog/okhttp-3-13-requires-android-5/. =||= Okay. Let's upgrade to RxJava 8 baseline and release without delaying too much. =||= Progress tracked in #6776. =||= ,0
6773,676,API Design Review: SafeObserver via Reflection or Marker Interface	,The `SafeObserver` wrapper is applied to all `Observer` implementations passed into `Observable.subscribe` by users but it is not applied to any `Observer` implementations that originate from within the `rx.operators` package.

This is so we achieve the desired safety and error handling while not paying the cost of wrapping trusted `Observer` implementations from internal operators.

Today it uses reflection to look at the package the `Observer` originates from. It then caches this information for performance.  

See here: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L238 and here:  https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L6822

It is not pretty but it works.

The other way is we could put marker interfaces such as `TrustedObserver` on all `Observer` implementations we use in `rx.operators` or elsewhere that should not be wrapped.

Pros:
- doesn't involve reflection
- obvious
- can be used by non-internal operators

Cons:
- marker interfaces require remembering to put them where they should be
- they can be put where they're not supposed to be
- can be used by non-internal operators and misused
- they are an extra type to maintain in the public API serving little value

Neither approach is pretty. Is there another approach? If not, which of these two is preferable and why?

/cc @headinthebox and @jhusain,Since `Observable` code changes often enough those links will become wrong so here is the valid code:

``` java
/**
     * Whether a given {@link Function} is an internal implementation inside
     * rx.* packages or not.
     * <p>
     * For why this is being used see
     * https://github.com/Netflix/RxJava/issues/216 for discussion on
     * "Guideline 6.4: Protect calls to user code from within an operator"
     * 
     * Note: If strong reasons for not depending on package names comes up then
     * the implementation of this method can change to looking for a marker
     * interface.
     * 
     * @param o
     * @return {@code true} if the given function is an internal implementation,
     *         and {@code false} otherwise.
     */
    private boolean isInternalImplementation(Object o) {
        if (o == null) {
            return true;
        }
        // prevent double-wrapping (yeah it happens)
        if (o instanceof SafeObserver) {
            return true;
        }

        Class<?> clazz = o.getClass();
        if (internalClassMap.containsKey(clazz)) {
            //don't need to do reflection
            return internalClassMap.get(clazz);
        } else {
            // we treat the following package as "internal" and don't wrap it
            Package p = o.getClass().getPackage(); // it can be null
            Boolean isInternal = (p != null && p.getName().startsWith("rx.operators"));
            internalClassMap.put(clazz, isInternal);
            return isInternal;
        }
    }
```

``` java
if (isInternalImplementation(observer)) {
                Subscription s = onSubscribeFunction.onSubscribe(observer);
                if (s == null) {
                    // this generally shouldn't be the case on a 'trusted' onSubscribe but in case it happens
                    // we want to gracefully handle it the same as SafeObservableSubscription does
                    return hook.onSubscribeReturn(this, Subscriptions.empty());
                } else {
                    return hook.onSubscribeReturn(this, s);
                }
            } else {
                SafeObservableSubscription subscription = new SafeObservableSubscription();
                subscription.wrap(onSubscribeFunction.onSubscribe(new SafeObserver<T>(subscription, observer)));
                return hook.onSubscribeReturn(this, subscription);
            }
```
 =||= FWIW, I'd lean toward option 2. (Wouldn't this still result in using reflection though, since you'd have to check for the annotation at runtime?)

> marker interfaces require remembering to put them where they should be

True. Is this something that could be caught using static analysis?

> they can be put where they're not supposed to be

But so can any class level annotation. And it can be made only applicable to classes via the target property. I don't see this being an issue really.

> can be used by non-internal operators and misused

Sure. Then again, whoever misuses this to mark a misbehaving observer as trusted is only shooting themselves in the foot? You get what you ask for :-) 

> they are an extra type to maintain in the public API serving little value

Are you referring to the marker interface? What's the maintenance overhead though, apart from having to remember applying it to internal observers?

Would be interested in hearing what others have to say
 =||= Another option I've become more comfortable with (and that @headinthebox prefers) is that we add `Observable.unsafeSubscribe` that `Operator` implementations can use and it does what it says ... subscribe without any "safety" wrapping. It would directly invoke the inner `OnSubscribe` function.
 =||= Yes, that's what I would prefer. ^F for "unsafe" during code reviews to spot where people may shoot themselves in the foot that don't know what they are doing, but allow full power in case you need to implement a new operator.
 =||= I see. I would find it a bit odd though to find unsafeSubscribe invocations
throughout my client code, even when I know it's safe. It would raise eye
brows for people not as familiar with the peculiarities of the library.
 =||= Do you create operators that act on nested Observables? Examples are `repeat`, `retry`, `merge`.

Those are the only scenario where an `unsafeSubscribe` is needed. Otherwise, normal `Operator` implementations like `map`, `take`, `filter`, etc do not need to.
 =||= Here is an example location where it is doing an "unsafe subscribe": https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorRepeat.java?source=c#L80

Whereas in `map` you'll see it never subscribes because it is a `Subscriber` -> `Subscriber` transformation that gets lifted into the `Observable`: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorMap.java
 =||= I intend on doing this in 0.18 along with `Scheduler` changes. Do my last explanations make sense, or is there still concern about this change?

The only time when this will need to be used is when implementing operators that do nested subscriptions. 
 =||= +1

On Mon, Mar 31, 2014 at 7:34 PM, Ben Christensen
notifications@github.comwrote:

> I intend on doing this in 0.18 along with Scheduler changes. Do my last
> explanations make sense, or is there still concern about this change?
> 
> The only time when this will need to be used is when implementing
> operators that do nested subscriptions.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/676#issuecomment-39117035
> .
 =||= Thanks for the positive confirmation @mttkay ... I'll proceed with this.
 =||= Completed in https://github.com/Netflix/RxJava/pull/1010
 =||= ,0
6775,6776,3.x: [Java 8] Add operators supporting the newer platform [tracking issue],This issue tracks the new, Java 8-related operators to be implemented.

- [x] `Flowable.fromOptional`
- [x] `Flowable.fromStream`
- [x] `Flowable.fromCompletionStage`
- [x] `Flowable.mapOptional`
- [x] `Flowable.collect(Collector)`
- [x] `Flowable.firstStage`
- [x] `Flowable.singleStage`
- [x] `Flowable.lastStage`
- [x] `Flowable.firstOrErrorStage`
- [x] `Flowable.singleOrErrorStage`
- [x] `Flowable.lastOrErrorStage`
- [x] `Flowable.blockingStream` + 1
- [x] `Flowable.flatMapStream` + 1
- [x] `Flowable.concatMapStream` + 1
-----
- [x] `Observable.fromOptional`
- [x] `Observable.fromStream`
- [x] `Observable.fromCompletionStage`
- [x] `Observable.mapOptional`
- [x] `Observable.collect(Collector)`
- [x] `Observable.firstStage`
- [x] `Observable.singleStage`
- [x] `Observable.lastStage`
- [x] `Observable.firstOrErrorStage`
- [x] `Observable.singleOrErrorStage`
- [x] `Observable.lastOrErrorStage`
- [x] `Observable.blockingStream` + 1
- [x] `Observable.flatMapStream`
- [x] `Observable.concatMapStream`
-----
- [x] `Maybe.fromOptional`
- [x] `Maybe.fromCompletionStage`
- [x] `Maybe.mapOptional`
- [x] `Maybe.toCompletionStage()` + 1
- [x] `Maybe.flattenStreamAsFlowable`
- [x] `Maybe.flattenStreamAsObservable`
-----
- [x] `Single.fromCompletionStage`
- [x] `Single.mapOptional` returns `Maybe<T>`
- [x] `Single.toCompletionStage()`
- [x] `Single.flattenStreamAsFlowable`
- [x] `Single.flattenStreamAsObservable`
-----
- [x] `Completable.fromCompletionStage`
- [x] `Completable.toCompletionStage`
-----
- [x] `ParallelFlowable.mapOptional`
- [x] `ParallelFlowable.flatMapStream`
- [x] `ParallelFlowable.collect(Collector)` returns `Flowable`,~How about eliminating the plural sibling classes and moving their static factories onto the main class? For example, the factories on `Disposables` can be moved to `Disposable`.~

Nevermind this isn't operator-related. I'll just send a PR! =||= Will Android desugaring be able to work with that? =||= Yep. Supported since AGP 3.2 well over a year now. =||= The previously `???` marked entries will be better implemented externally for now (RxJavaExtensions). =||= ,0
6779,6776,3.x: [Java 8] Add operators supporting the newer platform [tracking issue],This issue tracks the new, Java 8-related operators to be implemented.

- [x] `Flowable.fromOptional`
- [x] `Flowable.fromStream`
- [x] `Flowable.fromCompletionStage`
- [x] `Flowable.mapOptional`
- [x] `Flowable.collect(Collector)`
- [x] `Flowable.firstStage`
- [x] `Flowable.singleStage`
- [x] `Flowable.lastStage`
- [x] `Flowable.firstOrErrorStage`
- [x] `Flowable.singleOrErrorStage`
- [x] `Flowable.lastOrErrorStage`
- [x] `Flowable.blockingStream` + 1
- [x] `Flowable.flatMapStream` + 1
- [x] `Flowable.concatMapStream` + 1
-----
- [x] `Observable.fromOptional`
- [x] `Observable.fromStream`
- [x] `Observable.fromCompletionStage`
- [x] `Observable.mapOptional`
- [x] `Observable.collect(Collector)`
- [x] `Observable.firstStage`
- [x] `Observable.singleStage`
- [x] `Observable.lastStage`
- [x] `Observable.firstOrErrorStage`
- [x] `Observable.singleOrErrorStage`
- [x] `Observable.lastOrErrorStage`
- [x] `Observable.blockingStream` + 1
- [x] `Observable.flatMapStream`
- [x] `Observable.concatMapStream`
-----
- [x] `Maybe.fromOptional`
- [x] `Maybe.fromCompletionStage`
- [x] `Maybe.mapOptional`
- [x] `Maybe.toCompletionStage()` + 1
- [x] `Maybe.flattenStreamAsFlowable`
- [x] `Maybe.flattenStreamAsObservable`
-----
- [x] `Single.fromCompletionStage`
- [x] `Single.mapOptional` returns `Maybe<T>`
- [x] `Single.toCompletionStage()`
- [x] `Single.flattenStreamAsFlowable`
- [x] `Single.flattenStreamAsObservable`
-----
- [x] `Completable.fromCompletionStage`
- [x] `Completable.toCompletionStage`
-----
- [x] `ParallelFlowable.mapOptional`
- [x] `ParallelFlowable.flatMapStream`
- [x] `ParallelFlowable.collect(Collector)` returns `Flowable`,~How about eliminating the plural sibling classes and moving their static factories onto the main class? For example, the factories on `Disposables` can be moved to `Disposable`.~

Nevermind this isn't operator-related. I'll just send a PR! =||= Will Android desugaring be able to work with that? =||= Yep. Supported since AGP 3.2 well over a year now. =||= The previously `???` marked entries will be better implemented externally for now (RxJavaExtensions). =||= ,0
6780,6772,3.x: [Java 8] Add Disposables.fromAutoCloseable,Similar to the other `Disposables.fromX`, add a variant that wraps an `AutoCloseable`.,nan,0
6780,677,API Design Review: Replay Selector T -> R without ConnectableObservable,Why are there `replay` overloads that:
- convert from T to R like a `map` operator?
- return `Observable` instead of `ConnectableObservable`?

``` java
public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector)
```

It seems that someone should just use `observable.map(T -> R).replay()` and that it should always return `ConnectableObservable`.

/cc @headinthebox and @jhusain,I never understood this operator, and the current implementation works different than Rx.NET.

``` java
public class ReplayMulticast {
    public static void main(String[] args) {
        Observable<Integer> source = Observable.from(1, 2, 3, 4)
                .doOnNext(v -> { 
                    System.out.println("Sideeffect"); 
                });

        Observable<Integer> result = source.replay(o -> o.take(2));

        for (int i = 1; i < 3; i++) {
            System.out.printf("- %d -%n", i);
            result.subscribe(System.out::println, Throwable::printStackTrace, 
                    () -> System.out.println("Done")
            );
        }
    }
}
```

that prints

```
- 1 -
Sideeffect
1
Sideeffect
2
Done
Sideeffect
Sideeffect
- 2 -
Sideeffect
1
Sideeffect
2
Done
Sideeffect
Sideeffect
```

An infinite stream would never stop.

Rx.NET prints

```
- 1 -
Sideeffect
1
Sideeffect
2
Done
- 2 -
Sideeffect
1
Sideeffect
2
Done
```

Regardless, I don't get the operator.
 =||= Replay has way to many overloads ... (personally I never use replay, so I am not the right person to ask which ones to keep :-)
 =||= @headinthebox Now is the time for a review of these and deleting any if we want to. 
 =||= Can you specify which ones so we don't confuse each other on subjective non-obvious decisions?
 =||= Here are all the overloads.

The ones that create a `ConnectableObservable`:

```
ConnectableObservable<T> replay()
ConnectableObservable<T> replay(int bufferSize) 
ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit)
ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit, Scheduler scheduler)
ConnectableObservable<T> replay(int bufferSize, Scheduler scheduler)
ConnectableObservable<T> replay(long time, TimeUnit unit)
ConnectableObservable<T> replay(long time, TimeUnit unit, Scheduler scheduler)
ConnectableObservable<T> replay(Scheduler scheduler)
```

And the corresponding ones that take a function and create a  regular observable:

```
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector)
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize) 
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, int bufferSize, long time, TimeUnit unit)
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler)
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final Scheduler scheduler) 
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, long time, TimeUnit unit) 
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final long time, final TimeUnit unit, final Scheduler scheduler)
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final Scheduler scheduler)
```

These latter ones are similar to the `Publish` overload that takes a function `Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector)` where the source observable is published _inside_ the function.

If you like `replay` (which I personally don't, in fact I have not used it in the last 2 years) all the overloads make sense. So, unfortunately, I guess that if we keep replay, we need all of them.
 =||= @akarnokd The .NET behavior is the correct one. When you call `source.replay(replayedSource -> replayedSource.take(2))` the function gets a private copy source.replay() that it can use. Since `source` is finite, it should replay the side effects and take the first two elements.
 =||= @headinthebox thanks, I suspected so. Luckily, the issue I mentioned above was fixed and RxJava should behave as Rx.NET now.
 =||= @akarnokd great! and @benjchristensen sorry for not being able to prune this bunch, but it makes Rx extra `super` :-)
 =||= Closing out ... review has decided that what we have is what we want.

Thanks @akarnokd and @headinthebox 
 =||= ,0
6783,6776,3.x: [Java 8] Add operators supporting the newer platform [tracking issue],This issue tracks the new, Java 8-related operators to be implemented.

- [x] `Flowable.fromOptional`
- [x] `Flowable.fromStream`
- [x] `Flowable.fromCompletionStage`
- [x] `Flowable.mapOptional`
- [x] `Flowable.collect(Collector)`
- [x] `Flowable.firstStage`
- [x] `Flowable.singleStage`
- [x] `Flowable.lastStage`
- [x] `Flowable.firstOrErrorStage`
- [x] `Flowable.singleOrErrorStage`
- [x] `Flowable.lastOrErrorStage`
- [x] `Flowable.blockingStream` + 1
- [x] `Flowable.flatMapStream` + 1
- [x] `Flowable.concatMapStream` + 1
-----
- [x] `Observable.fromOptional`
- [x] `Observable.fromStream`
- [x] `Observable.fromCompletionStage`
- [x] `Observable.mapOptional`
- [x] `Observable.collect(Collector)`
- [x] `Observable.firstStage`
- [x] `Observable.singleStage`
- [x] `Observable.lastStage`
- [x] `Observable.firstOrErrorStage`
- [x] `Observable.singleOrErrorStage`
- [x] `Observable.lastOrErrorStage`
- [x] `Observable.blockingStream` + 1
- [x] `Observable.flatMapStream`
- [x] `Observable.concatMapStream`
-----
- [x] `Maybe.fromOptional`
- [x] `Maybe.fromCompletionStage`
- [x] `Maybe.mapOptional`
- [x] `Maybe.toCompletionStage()` + 1
- [x] `Maybe.flattenStreamAsFlowable`
- [x] `Maybe.flattenStreamAsObservable`
-----
- [x] `Single.fromCompletionStage`
- [x] `Single.mapOptional` returns `Maybe<T>`
- [x] `Single.toCompletionStage()`
- [x] `Single.flattenStreamAsFlowable`
- [x] `Single.flattenStreamAsObservable`
-----
- [x] `Completable.fromCompletionStage`
- [x] `Completable.toCompletionStage`
-----
- [x] `ParallelFlowable.mapOptional`
- [x] `ParallelFlowable.flatMapStream`
- [x] `ParallelFlowable.collect(Collector)` returns `Flowable`,~How about eliminating the plural sibling classes and moving their static factories onto the main class? For example, the factories on `Disposables` can be moved to `Disposable`.~

Nevermind this isn't operator-related. I'll just send a PR! =||= Will Android desugaring be able to work with that? =||= Yep. Supported since AGP 3.2 well over a year now. =||= The previously `???` marked entries will be better implemented externally for now (RxJavaExtensions). =||= ,0
6786,6767,3.x: [Java 8] Use diamond <> where possible in unit tests.,The upgrade to Java 8 caused more than 4,000 locations to report as diamond capable, including regular classes and tests.

In the first round, fix the unit test files, but beware:
- Do not change the non-test files yet. (Avoid conflict with other cleanups and Java 8 additions.)
- Do not change the existing tests' functional interface usages to lambdas. (Undoing lambdaification is extremely painful because tools guess the inner class types wrong almost always.)
- On a rare occasion, the warning is wrong in the IDE and breaks the Gradle compilation with javac.

I'd appreciate this to be split between several PRs or ~100 file changes per PR tops to still be able to review them on GitHub.,Hello! I've made several PR's with ~100 file changes in each, more detailed information is in PR's. =||= Done. =||= ,0
6787,6767,3.x: [Java 8] Use diamond <> where possible in unit tests.,The upgrade to Java 8 caused more than 4,000 locations to report as diamond capable, including regular classes and tests.

In the first round, fix the unit test files, but beware:
- Do not change the non-test files yet. (Avoid conflict with other cleanups and Java 8 additions.)
- Do not change the existing tests' functional interface usages to lambdas. (Undoing lambdaification is extremely painful because tools guess the inner class types wrong almost always.)
- On a rare occasion, the warning is wrong in the IDE and breaks the Gradle compilation with javac.

I'd appreciate this to be split between several PRs or ~100 file changes per PR tops to still be able to review them on GitHub.,Hello! I've made several PR's with ~100 file changes in each, more detailed information is in PR's. =||= Done. =||= ,0
6788,6767,3.x: [Java 8] Use diamond <> where possible in unit tests.,The upgrade to Java 8 caused more than 4,000 locations to report as diamond capable, including regular classes and tests.

In the first round, fix the unit test files, but beware:
- Do not change the non-test files yet. (Avoid conflict with other cleanups and Java 8 additions.)
- Do not change the existing tests' functional interface usages to lambdas. (Undoing lambdaification is extremely painful because tools guess the inner class types wrong almost always.)
- On a rare occasion, the warning is wrong in the IDE and breaks the Gradle compilation with javac.

I'd appreciate this to be split between several PRs or ~100 file changes per PR tops to still be able to review them on GitHub.,Hello! I've made several PR's with ~100 file changes in each, more detailed information is in PR's. =||= Done. =||= ,0
6789,6767,3.x: [Java 8] Use diamond <> where possible in unit tests.,The upgrade to Java 8 caused more than 4,000 locations to report as diamond capable, including regular classes and tests.

In the first round, fix the unit test files, but beware:
- Do not change the non-test files yet. (Avoid conflict with other cleanups and Java 8 additions.)
- Do not change the existing tests' functional interface usages to lambdas. (Undoing lambdaification is extremely painful because tools guess the inner class types wrong almost always.)
- On a rare occasion, the warning is wrong in the IDE and breaks the Gradle compilation with javac.

I'd appreciate this to be split between several PRs or ~100 file changes per PR tops to still be able to review them on GitHub.,Hello! I've made several PR's with ~100 file changes in each, more detailed information is in PR's. =||= Done. =||= ,0
6791,676,API Design Review: SafeObserver via Reflection or Marker Interface	,The `SafeObserver` wrapper is applied to all `Observer` implementations passed into `Observable.subscribe` by users but it is not applied to any `Observer` implementations that originate from within the `rx.operators` package.

This is so we achieve the desired safety and error handling while not paying the cost of wrapping trusted `Observer` implementations from internal operators.

Today it uses reflection to look at the package the `Observer` originates from. It then caches this information for performance.  

See here: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L238 and here:  https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L6822

It is not pretty but it works.

The other way is we could put marker interfaces such as `TrustedObserver` on all `Observer` implementations we use in `rx.operators` or elsewhere that should not be wrapped.

Pros:
- doesn't involve reflection
- obvious
- can be used by non-internal operators

Cons:
- marker interfaces require remembering to put them where they should be
- they can be put where they're not supposed to be
- can be used by non-internal operators and misused
- they are an extra type to maintain in the public API serving little value

Neither approach is pretty. Is there another approach? If not, which of these two is preferable and why?

/cc @headinthebox and @jhusain,Since `Observable` code changes often enough those links will become wrong so here is the valid code:

``` java
/**
     * Whether a given {@link Function} is an internal implementation inside
     * rx.* packages or not.
     * <p>
     * For why this is being used see
     * https://github.com/Netflix/RxJava/issues/216 for discussion on
     * "Guideline 6.4: Protect calls to user code from within an operator"
     * 
     * Note: If strong reasons for not depending on package names comes up then
     * the implementation of this method can change to looking for a marker
     * interface.
     * 
     * @param o
     * @return {@code true} if the given function is an internal implementation,
     *         and {@code false} otherwise.
     */
    private boolean isInternalImplementation(Object o) {
        if (o == null) {
            return true;
        }
        // prevent double-wrapping (yeah it happens)
        if (o instanceof SafeObserver) {
            return true;
        }

        Class<?> clazz = o.getClass();
        if (internalClassMap.containsKey(clazz)) {
            //don't need to do reflection
            return internalClassMap.get(clazz);
        } else {
            // we treat the following package as "internal" and don't wrap it
            Package p = o.getClass().getPackage(); // it can be null
            Boolean isInternal = (p != null && p.getName().startsWith("rx.operators"));
            internalClassMap.put(clazz, isInternal);
            return isInternal;
        }
    }
```

``` java
if (isInternalImplementation(observer)) {
                Subscription s = onSubscribeFunction.onSubscribe(observer);
                if (s == null) {
                    // this generally shouldn't be the case on a 'trusted' onSubscribe but in case it happens
                    // we want to gracefully handle it the same as SafeObservableSubscription does
                    return hook.onSubscribeReturn(this, Subscriptions.empty());
                } else {
                    return hook.onSubscribeReturn(this, s);
                }
            } else {
                SafeObservableSubscription subscription = new SafeObservableSubscription();
                subscription.wrap(onSubscribeFunction.onSubscribe(new SafeObserver<T>(subscription, observer)));
                return hook.onSubscribeReturn(this, subscription);
            }
```
 =||= FWIW, I'd lean toward option 2. (Wouldn't this still result in using reflection though, since you'd have to check for the annotation at runtime?)

> marker interfaces require remembering to put them where they should be

True. Is this something that could be caught using static analysis?

> they can be put where they're not supposed to be

But so can any class level annotation. And it can be made only applicable to classes via the target property. I don't see this being an issue really.

> can be used by non-internal operators and misused

Sure. Then again, whoever misuses this to mark a misbehaving observer as trusted is only shooting themselves in the foot? You get what you ask for :-) 

> they are an extra type to maintain in the public API serving little value

Are you referring to the marker interface? What's the maintenance overhead though, apart from having to remember applying it to internal observers?

Would be interested in hearing what others have to say
 =||= Another option I've become more comfortable with (and that @headinthebox prefers) is that we add `Observable.unsafeSubscribe` that `Operator` implementations can use and it does what it says ... subscribe without any "safety" wrapping. It would directly invoke the inner `OnSubscribe` function.
 =||= Yes, that's what I would prefer. ^F for "unsafe" during code reviews to spot where people may shoot themselves in the foot that don't know what they are doing, but allow full power in case you need to implement a new operator.
 =||= I see. I would find it a bit odd though to find unsafeSubscribe invocations
throughout my client code, even when I know it's safe. It would raise eye
brows for people not as familiar with the peculiarities of the library.
 =||= Do you create operators that act on nested Observables? Examples are `repeat`, `retry`, `merge`.

Those are the only scenario where an `unsafeSubscribe` is needed. Otherwise, normal `Operator` implementations like `map`, `take`, `filter`, etc do not need to.
 =||= Here is an example location where it is doing an "unsafe subscribe": https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorRepeat.java?source=c#L80

Whereas in `map` you'll see it never subscribes because it is a `Subscriber` -> `Subscriber` transformation that gets lifted into the `Observable`: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorMap.java
 =||= I intend on doing this in 0.18 along with `Scheduler` changes. Do my last explanations make sense, or is there still concern about this change?

The only time when this will need to be used is when implementing operators that do nested subscriptions. 
 =||= +1

On Mon, Mar 31, 2014 at 7:34 PM, Ben Christensen
notifications@github.comwrote:

> I intend on doing this in 0.18 along with Scheduler changes. Do my last
> explanations make sense, or is there still concern about this change?
> 
> The only time when this will need to be used is when implementing
> operators that do nested subscriptions.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/676#issuecomment-39117035
> .
 =||= Thanks for the positive confirmation @mttkay ... I'll proceed with this.
 =||= Completed in https://github.com/Netflix/RxJava/pull/1010
 =||= ,0
6797,677,API Design Review: Replay Selector T -> R without ConnectableObservable,Why are there `replay` overloads that:
- convert from T to R like a `map` operator?
- return `Observable` instead of `ConnectableObservable`?

``` java
public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector)
```

It seems that someone should just use `observable.map(T -> R).replay()` and that it should always return `ConnectableObservable`.

/cc @headinthebox and @jhusain,I never understood this operator, and the current implementation works different than Rx.NET.

``` java
public class ReplayMulticast {
    public static void main(String[] args) {
        Observable<Integer> source = Observable.from(1, 2, 3, 4)
                .doOnNext(v -> { 
                    System.out.println("Sideeffect"); 
                });

        Observable<Integer> result = source.replay(o -> o.take(2));

        for (int i = 1; i < 3; i++) {
            System.out.printf("- %d -%n", i);
            result.subscribe(System.out::println, Throwable::printStackTrace, 
                    () -> System.out.println("Done")
            );
        }
    }
}
```

that prints

```
- 1 -
Sideeffect
1
Sideeffect
2
Done
Sideeffect
Sideeffect
- 2 -
Sideeffect
1
Sideeffect
2
Done
Sideeffect
Sideeffect
```

An infinite stream would never stop.

Rx.NET prints

```
- 1 -
Sideeffect
1
Sideeffect
2
Done
- 2 -
Sideeffect
1
Sideeffect
2
Done
```

Regardless, I don't get the operator.
 =||= Replay has way to many overloads ... (personally I never use replay, so I am not the right person to ask which ones to keep :-)
 =||= @headinthebox Now is the time for a review of these and deleting any if we want to. 
 =||= Can you specify which ones so we don't confuse each other on subjective non-obvious decisions?
 =||= Here are all the overloads.

The ones that create a `ConnectableObservable`:

```
ConnectableObservable<T> replay()
ConnectableObservable<T> replay(int bufferSize) 
ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit)
ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit, Scheduler scheduler)
ConnectableObservable<T> replay(int bufferSize, Scheduler scheduler)
ConnectableObservable<T> replay(long time, TimeUnit unit)
ConnectableObservable<T> replay(long time, TimeUnit unit, Scheduler scheduler)
ConnectableObservable<T> replay(Scheduler scheduler)
```

And the corresponding ones that take a function and create a  regular observable:

```
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector)
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize) 
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, int bufferSize, long time, TimeUnit unit)
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler)
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final Scheduler scheduler) 
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, long time, TimeUnit unit) 
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final long time, final TimeUnit unit, final Scheduler scheduler)
Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final Scheduler scheduler)
```

These latter ones are similar to the `Publish` overload that takes a function `Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector)` where the source observable is published _inside_ the function.

If you like `replay` (which I personally don't, in fact I have not used it in the last 2 years) all the overloads make sense. So, unfortunately, I guess that if we keep replay, we need all of them.
 =||= @akarnokd The .NET behavior is the correct one. When you call `source.replay(replayedSource -> replayedSource.take(2))` the function gets a private copy source.replay() that it can use. Since `source` is finite, it should replay the side effects and take the first two elements.
 =||= @headinthebox thanks, I suspected so. Luckily, the issue I mentioned above was fixed and RxJava should behave as Rx.NET now.
 =||= @akarnokd great! and @benjchristensen sorry for not being able to prune this bunch, but it makes Rx extra `super` :-)
 =||= Closing out ... review has decided that what we have is what we want.

Thanks @akarnokd and @headinthebox 
 =||= ,0
6799,6794,3.x: XProcessor.offer to throw NPE instead of signaling it,Change the behavior to align with the standard `onXXX` methods.,nan,0
6800,678,API Design Review: Java 8 Stream Naming Conventions,Let's compare against the Java 8 Streams API and try to match as closely to it as possible. We can add aliases where it makes sense and possibly deprecate and migrate to their names if they are better.

The idea is to support Java developers as they use the Stream API and then want to move to async and be as similar as possible.

It should try and achieve the "[Principle of Least Surprise](http://en.wikipedia.org/wiki/Principle_of_least_astonishment)" for developers.

Ideally someone could have code written for the Stream API and just swap out the `Stream` for an `Observable` and it "just work".

/cc @headinthebox and @jhusain
/cc @bondolo (from Oracle) if you have any thoughts on this,Unless one uses call-site lambdas, "just swapping" won't work due base functional type mismatch:

``` java
stream.filter(v -> v % 2 == 0)
observable.filter(v -> v % 2 == 0)
// but
Predicate<Integer> p = v -> v % 2 == 0
stream.filter(p);
observable.filter(p); // type mismatch
observable.filter(p::test);
```

Some renames/matches of functionality

| Stream API | Observable API |
| --- | --- |
| `filter` | `where` |
| `mapToInt` | primitive observable ??? |
| `sorted` | N/A |
| `peek` | ??? |
| `limit` | `take(n)` |
| `forEach` | `doOnEach` |
| `toArray` | `toBlockingObservable().toList().toArray()` |
| `anyMatch` | `exists().toBlockingObservable().single()` |
| `count` | `count().toBlockingObservable().single()` |
| `allMatch` | `all().toBlockingObservable().single()` |
| `noneMatch` | `all(not()).toBlockingObservable().single()` |
| `findFirst` | `materialize().toBlockingObservable().first()` |
| `findAny` | N/A, would be identical to `findFirst` |

Some `Stream` methods exit the stream, this is why there are that many `toBlockingObservable` calls in the table.
 =||= Keep the .Net naming and usage intact much as possible. Any language specific idioms can core exit with this.

This would help towards less confusion and easy portability in case you maintain a .net API also. 

This can be extended to the other language bindings also. E.g. idiomatic Scala API should ideally not hide the .Net of F# usage (as in this case F# being closer to Scala / Clojure than C#) but co exist with the idiomatic language version.
 =||= I sympathize with the plight of the cross-platform RX user - I am one.  However I strongly disagree with the idea of using non-idiomatic names just to make porting code between platforms easier. We tried that with RxJS, and it caused no end of confusion. There are many RX users who use RX across platforms. However there is a much larger potential audience that does not yet use RX, will very likely be exposed to Streams, and will approach reactive programming for the first time in the next two years. 

J

Dictated using voice recognition. Please forgive the typos.

> On Dec 27, 2013, at 6:29 AM, Suminda Dharmasena notifications@github.com wrote:
> 
> Keep the .Net naming and usage intact much as possible. Any language specific idioms can core exit with this.
> 
> This would help towards less confusion and easy portability in case you maintain a .net API also.
> 
> This can be extended to the other language bindings also. E.g. idiomatic Scala API should ideally not hide the .Net of F# usage (as in this case F# being closer to Scala / Clojure than C#)
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= What I say is use idiomatic names wherever possible but leave the more familiar naming and usage also. The idiomatic changes would be a few so there will be little overhead.
 =||= Best is that if there is a possibility / feasibility coordinate across the Rx implementations and the .net project is also open source so there is coherence and API convergence.
 =||= These are the only ones that seem worth considering:

| Stream API | Observable API |
| --- | --- |
| `filter` | `where` |
| `limit` | `take(n)` |
| `forEach` | `doOnEach` |

We have already done `filter`. I am okay with aliasing `take` and `limit`. 

The `forEach` name may also be good. The question then is whether it's a synonym with `doOnEach` or `subscribe(Action1<T>)`. I think it's the later, as someone shouldn't need to `forEach(f).subscribe()`.

Should we alias `subscribe` with `forEach`?

``` java
void forEach(Action1<? super T>)
void forEach(Action1<? super T>, Action1<Throwable>)
void forEach(Action1<? super T>, Action1<Throwable>, Action0)
```
 =||= @benjchristensen I agree with the latter, especially people coming from java 8 streams, it's not obvious that in Rx you then have to subscribe in addition.
 =||= OK with forEach, I think RxJs has that as well.
 =||= Let's move ahead with this.
 =||= Completed in https://github.com/Netflix/RxJava/pull/1232
 =||= ``` java
    public static void main(String[] args) {
        Observable.from(1, 2, 3).forEach(System.out::println);
        Observable.from(1, 2, 3).toBlocking().forEach(System.out::println);

        Observable.from(1, 2, 3).limit(2).forEach(System.out::println);
    }
```
 =||= Note that in JavaScript this method removes the data from the monad.

That said, we should definitely match the stream APIs closely as possible for Java 8.

Dictated using voice recognition. Please forgive the typos.

> On May 20, 2014, at 9:14 AM, headinthebox notifications@github.com wrote:
> 
> OK with forEach, I think RxJs has that as well.
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= We have both the non-blocking and blocking forms of `forEach` now. The blocking one removes it from the monad.

``` java
Observable.from(1, 2, 3).forEach(System.out::println);
Observable.from(1, 2, 3).toBlocking().forEach(System.out::println);
```
 =||= Makes sense.
 =||= ,0
6801,679,API Design Review: Timer/Interval,It seems `timer` is almost replicating `interval` but doing so with a non-obvious name. An operator named `timer` suggests it's related to scheduling work in the future, but it's actually about a stream of numbers.

Let's consider removing `timer` and improving `interval` to achieve what it does.

Perhaps we can also have a better name for simply getting an infinite stream of numbers (with or without time involved). Perhaps an obvious name like `Observable.numbers` or something equally apparent?

/cc @headinthebox and @jhusain,We also should consider the example of`Observable.range(start, count)`. It seems like it should also be capable of doing `Observable.range(start)` and just start at a value and keep counting, but then it's not really a `range`, but that's what we want to do and don't have the ability to do.
 =||= Timer has the ability to determine when it first fires, set an interval (just like interval). So perhaps we should remove interval. 

Sent from my iPad

> On Dec 23, 2013, at 9:47 PM, Ben Christensen notifications@github.com wrote:
> 
> It seems timer is almost replicating interval but doing so with a non-obvious name. An operator named timer suggests it's related to scheduling work in the future, but it's actually about a stream of numbers.
> 
> Let's consider removing timer and improving interval to achieve what it does.
> 
> Perhaps we can also have a better name for simply getting an infinite stream of numbers (with or without time involved). Perhaps an obvious name like Observable.numbers or something equally apparent?
> 
> /cc @headinthebox and @jhusain
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= Interval was removed by one of my PRs, so I guess this is settled.
 =||= They are still there right now:

``` java
/**
     * Returns an Observable that emits a sequential number every specified interval of time.
     * <p>
     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/interval.png">
     * 
     * @param interval
     *            interval size in time units (see below)
     * @param unit
     *            time units to use for the interval size
     * @return an Observable that emits a sequential number each time interval
     * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#wiki-interval">RxJava Wiki: interval()</a>
     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229027.aspx">MSDN: Observable.Interval</a>
     */
    public final static Observable<Long> interval(long interval, TimeUnit unit) {
        return create(new OperatorTimerPeriodically(interval, interval, unit, Schedulers.computation()));
    }

    /**
     * Returns an Observable that emits a sequential number every specified interval of time, on a
     * specified Scheduler.
     * <p>
     * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/interval.s.png">
     * 
     * @param interval
     *            interval size in time units (see below)
     * @param unit
     *            time units to use for the interval size
     * @param scheduler
     *            the Scheduler to use for scheduling the items
     * @return an Observable that emits a sequential number each time interval
     * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#wiki-interval">RxJava Wiki: interval()</a>
     * @see <a href="http://msdn.microsoft.com/en-us/library/hh228911.aspx">MSDN: Observable.Interval</a>
     */
    public final static Observable<Long> interval(long interval, TimeUnit unit, Scheduler scheduler) {
        return create(new OperatorTimerPeriodically(interval, interval, unit, scheduler));
    }
```
 =||= I meant they use the same implementation as the `timer` methods and now serve as aliases.
 =||= Oh :-)
 =||= Should we keep `interval` and `timer` in the API?
 =||= Programmers coming from other flavors of Rx may expect to discover `interval`.
 =||= Don't see why not.
 =||= Leaving as is ...
 =||= ,0
6805,6776,3.x: [Java 8] Add operators supporting the newer platform [tracking issue],This issue tracks the new, Java 8-related operators to be implemented.

- [x] `Flowable.fromOptional`
- [x] `Flowable.fromStream`
- [x] `Flowable.fromCompletionStage`
- [x] `Flowable.mapOptional`
- [x] `Flowable.collect(Collector)`
- [x] `Flowable.firstStage`
- [x] `Flowable.singleStage`
- [x] `Flowable.lastStage`
- [x] `Flowable.firstOrErrorStage`
- [x] `Flowable.singleOrErrorStage`
- [x] `Flowable.lastOrErrorStage`
- [x] `Flowable.blockingStream` + 1
- [x] `Flowable.flatMapStream` + 1
- [x] `Flowable.concatMapStream` + 1
-----
- [x] `Observable.fromOptional`
- [x] `Observable.fromStream`
- [x] `Observable.fromCompletionStage`
- [x] `Observable.mapOptional`
- [x] `Observable.collect(Collector)`
- [x] `Observable.firstStage`
- [x] `Observable.singleStage`
- [x] `Observable.lastStage`
- [x] `Observable.firstOrErrorStage`
- [x] `Observable.singleOrErrorStage`
- [x] `Observable.lastOrErrorStage`
- [x] `Observable.blockingStream` + 1
- [x] `Observable.flatMapStream`
- [x] `Observable.concatMapStream`
-----
- [x] `Maybe.fromOptional`
- [x] `Maybe.fromCompletionStage`
- [x] `Maybe.mapOptional`
- [x] `Maybe.toCompletionStage()` + 1
- [x] `Maybe.flattenStreamAsFlowable`
- [x] `Maybe.flattenStreamAsObservable`
-----
- [x] `Single.fromCompletionStage`
- [x] `Single.mapOptional` returns `Maybe<T>`
- [x] `Single.toCompletionStage()`
- [x] `Single.flattenStreamAsFlowable`
- [x] `Single.flattenStreamAsObservable`
-----
- [x] `Completable.fromCompletionStage`
- [x] `Completable.toCompletionStage`
-----
- [x] `ParallelFlowable.mapOptional`
- [x] `ParallelFlowable.flatMapStream`
- [x] `ParallelFlowable.collect(Collector)` returns `Flowable`,~How about eliminating the plural sibling classes and moving their static factories onto the main class? For example, the factories on `Disposables` can be moved to `Disposable`.~

Nevermind this isn't operator-related. I'll just send a PR! =||= Will Android desugaring be able to work with that? =||= Yep. Supported since AGP 3.2 well over a year now. =||= The previously `???` marked entries will be better implemented externally for now (RxJavaExtensions). =||= ,0
6814,681,API Design Review: defaultIfEmpty(Observable),There is a `defaultIfEmpty` that returns value `T`. Should we have one that accepts an `Observable<T>` as a default to subscribe to? It would be like `onEmptyResumeNext(Observable<T>)` similar to `onErrorResumeNext(Observable<T>)`.

/cc @headinthebox and @jhusain,There are several operators have a default value, e.g., `singleOrDefault`, `firstOrDefault`, `lastOrDefault`, `elementAtOrDefault`. Can we add an overload that accepts a function to generate the default value? Like,

``` Java
public final Observable<T> singleOrDefault(Func0<T> defaultValue)
```

Is's helpful for rxjava-scala to implement the call-by-name version of these operators.

Here is `firstOrElse` in rxjava-scala,

``` Scala
  def firstOrElse[U >: T](default: => U): Observable[U] = {
    this.take(1).foldLeft[Option[U]](None)((v: Option[U], e: U) => Some(e)).map({
      case Some(element) => element
      case None => default
    })
  }
```

If we have the function overload of `firstOrDefault`, we can implement it like

``` Scala
  def firstOrElse[U >: T](default: => U): Observable[U] = {
    asJavaObservable.firstOrDefault( () => default )
  }
```

/cc @samuelgruetter
 =||= Seems like `onEmptyReturn(T t)` and `onEmptyResumeNext(Observable<T> o)` would be better naming conventions. But since we already have `defaultIfEmpty` do we want:
- `defaultIfEmpty(T t)`
- `defaultIfEmpty(Observable<T> t)`
 =||= Closing as not important. We can always revisit this in the future if it comes interesting again.
 =||= ,0
6817,681,API Design Review: defaultIfEmpty(Observable),There is a `defaultIfEmpty` that returns value `T`. Should we have one that accepts an `Observable<T>` as a default to subscribe to? It would be like `onEmptyResumeNext(Observable<T>)` similar to `onErrorResumeNext(Observable<T>)`.

/cc @headinthebox and @jhusain,There are several operators have a default value, e.g., `singleOrDefault`, `firstOrDefault`, `lastOrDefault`, `elementAtOrDefault`. Can we add an overload that accepts a function to generate the default value? Like,

``` Java
public final Observable<T> singleOrDefault(Func0<T> defaultValue)
```

Is's helpful for rxjava-scala to implement the call-by-name version of these operators.

Here is `firstOrElse` in rxjava-scala,

``` Scala
  def firstOrElse[U >: T](default: => U): Observable[U] = {
    this.take(1).foldLeft[Option[U]](None)((v: Option[U], e: U) => Some(e)).map({
      case Some(element) => element
      case None => default
    })
  }
```

If we have the function overload of `firstOrDefault`, we can implement it like

``` Scala
  def firstOrElse[U >: T](default: => U): Observable[U] = {
    asJavaObservable.firstOrDefault( () => default )
  }
```

/cc @samuelgruetter
 =||= Seems like `onEmptyReturn(T t)` and `onEmptyResumeNext(Observable<T> o)` would be better naming conventions. But since we already have `defaultIfEmpty` do we want:
- `defaultIfEmpty(T t)`
- `defaultIfEmpty(Observable<T> t)`
 =||= Closing as not important. We can always revisit this in the future if it comes interesting again.
 =||= ,0
6826,6825,2.x: Unexpected Flowable.flatMap(...) behavior while handling an upstream error,Hi,
 
I've discovered an unexpected behavior of the Flowable.flatMap() operator leading to a possible subscription leak. Localized my problem in the following scenario:
1. RxJava version 2.2.16.
2. Given a simple Rx chain of flowable1.flatMap(value -> flowable2).
3. flowable1 emits a value (so that flatMap subscribes to flowable2).
4. flowable1 emits an error.
Expected result: flatMap disposes flowable2 upon handling the upstream error.
Actual result: flowable2 remains subscribed after the entire Rx chain terminates because of the error.

Replacing the flatMap operator with concatMap fixes the problem (such a replacement is valid in my case). However I decided to raise this issue because such behavior of flatMap looks quite odd to me. Could somebody from RxJava team confirm whether my expectation is valid and the observed behavior is a defect?

I've reproduced this issue in a code snippet: https://gist.github.com/eugene-zolotko/b24cbc436bc0eab2ed5de539b9e4e312
I'm expecting this code to produce "flowable2 cancelled" output. But got "flowable2 error" instead, plus error2 gets thrown as UndeliverableException because it occurs after the entire chain is terminated.,Sources emitting an error are considered cancelled so it is completely legal to not call cancel on them. Use `doFinally` to cleanup upon all sorts of termination or cancellation. =||= Thank you for looking into this. But I'm afraid I wasn't specific enough in my question above. In the following code snippet I expected error2 to never get emitted because error1 terminates the entire flow sooner that flowable2 emits error2. However error2 actually fired (triggered an UndeliverableException). 

```
    final Exception error1 = new Exception("1");
    final Flowable<Integer> flowable1 = Flowable.just(1).delay(1, TimeUnit.SECONDS)
        .concatWith(Flowable.<Integer>error(error1).delaySubscription(1, TimeUnit.SECONDS));

    final Exception error2 = new Exception("2");
    final Flowable<Object> flowable2 =
        Flowable.error(error2).delaySubscription(2, TimeUnit.SECONDS)
            .doOnCancel(() -> System.out.println("flowable2 cancelled"))
            .doOnError(error -> System.out.println("flowable2 error"));

    flowable1.flatMap(i -> flowable2).test()
        .awaitDone(4, TimeUnit.SECONDS)
        .assertError(error1);
```

So my questions are: 
1. Is this an expected behavior? 2. Is there a way to avoid throwing error2 as an UndeliverableException  (except for intercepting it with RxJavaPlugins.setErrorHandler)? 3. What's the reason of the difference in behavior between flatMap and concatMap is such conditions? =||= 1. No, the inner sequence should get cancelled. I'll investigate this further.
2. Suppressing the error via `onErrorX` or not let RxJava know about the error in the first place
3. Should work the same. =||= Closing via #6826 & #6827. =||= Thank you very much for your support. =||= ,0
6827,6825,2.x: Unexpected Flowable.flatMap(...) behavior while handling an upstream error,Hi,
 
I've discovered an unexpected behavior of the Flowable.flatMap() operator leading to a possible subscription leak. Localized my problem in the following scenario:
1. RxJava version 2.2.16.
2. Given a simple Rx chain of flowable1.flatMap(value -> flowable2).
3. flowable1 emits a value (so that flatMap subscribes to flowable2).
4. flowable1 emits an error.
Expected result: flatMap disposes flowable2 upon handling the upstream error.
Actual result: flowable2 remains subscribed after the entire Rx chain terminates because of the error.

Replacing the flatMap operator with concatMap fixes the problem (such a replacement is valid in my case). However I decided to raise this issue because such behavior of flatMap looks quite odd to me. Could somebody from RxJava team confirm whether my expectation is valid and the observed behavior is a defect?

I've reproduced this issue in a code snippet: https://gist.github.com/eugene-zolotko/b24cbc436bc0eab2ed5de539b9e4e312
I'm expecting this code to produce "flowable2 cancelled" output. But got "flowable2 error" instead, plus error2 gets thrown as UndeliverableException because it occurs after the entire chain is terminated.,Sources emitting an error are considered cancelled so it is completely legal to not call cancel on them. Use `doFinally` to cleanup upon all sorts of termination or cancellation. =||= Thank you for looking into this. But I'm afraid I wasn't specific enough in my question above. In the following code snippet I expected error2 to never get emitted because error1 terminates the entire flow sooner that flowable2 emits error2. However error2 actually fired (triggered an UndeliverableException). 

```
    final Exception error1 = new Exception("1");
    final Flowable<Integer> flowable1 = Flowable.just(1).delay(1, TimeUnit.SECONDS)
        .concatWith(Flowable.<Integer>error(error1).delaySubscription(1, TimeUnit.SECONDS));

    final Exception error2 = new Exception("2");
    final Flowable<Object> flowable2 =
        Flowable.error(error2).delaySubscription(2, TimeUnit.SECONDS)
            .doOnCancel(() -> System.out.println("flowable2 cancelled"))
            .doOnError(error -> System.out.println("flowable2 error"));

    flowable1.flatMap(i -> flowable2).test()
        .awaitDone(4, TimeUnit.SECONDS)
        .assertError(error1);
```

So my questions are: 
1. Is this an expected behavior? 2. Is there a way to avoid throwing error2 as an UndeliverableException  (except for intercepting it with RxJavaPlugins.setErrorHandler)? 3. What's the reason of the difference in behavior between flatMap and concatMap is such conditions? =||= 1. No, the inner sequence should get cancelled. I'll investigate this further.
2. Suppressing the error via `onErrorX` or not let RxJava know about the error in the first place
3. Should work the same. =||= Closing via #6826 & #6827. =||= Thank you very much for your support. =||= ,0
6837,6828,3.x: Inline Observable.concatMapIterable and flatMapIterable,They can be implemented more efficiently than relying on `concatMap` or `flatMap`, similarly to how `Flowable` implements them.

In addition, the `bufferSize` overloads make no sense as the operation is completely synchronous and nothing is to be buffered. (In comparison, `Flowable.concatMapIterable` has to buffer the upstream items because the downstream may not be ready to consume the iterable.),nan,0
6838,682,API Design Review: Share,Similar to how we have the `Observable.cache` operator as an easy to understand helper over `multicast`/`replay`, it is suggested to use `Observable.share` for the `multicast`/`publish` as a shortcut to `Observable.publish().refCount()` which is typically rather non-obvious and non-discoverable for people new to the library. 

The suggestion is that `Observable.share` would meet the majority of `multicast` use cases for sharing an `Observable` not needing the complexity of handling the `ConnectableObservable` directly or knowing to use `refCount()`.

It would also match with RxJS: https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeshare

/cc @headinthebox @jhusain and @mattpodwysocki ,@headinthebox and @akarnokd Do you like the idea of `share()` being a cover for `.publish().refCount()`?

Note that RxJS already does this.
 =||= Adding it isn't a big deal but I can't comment on whether the name `share` is discoverable enough. I'd like to hear from users who had trouble with publish.refcount being inconvenient. 
 =||= My only insight into this is that I often see the question/struggle of how to use `publish()` and `connect()` and `refCount()` is always a surprise.
 =||= I'm fine, as you mention RxJs has this. They also have pluck, which sounds cool :-)

Personally I like to be explicit but  I can see the value of share. 
 =||= (Oops, github ui fooled me into accidentally closing)
 =||= @headinthebox @benjchristensen yeah, we gave it some thought before we committed to it, but in the long run it was worth it.
 =||= Thanks for the insight @mattpodwysocki Let's proceed with this. It leaves us with `cache()` and `share()` as the most common multicasting use cases, and the rest for the more complicated scenarios.
 =||= What is `cache()` in this respect?  `replay().refCount()` or something else?
 =||= It's just `ReplaySubject` without `refCount`. Once it is subscribed to once, it receives all values from the origin and caches them all and replays them all back to whoever subscribes. 

Thus, it is a big massive memory leak if used incorrectly (but that's how `toList` and default `replaySubject` are anyways).

This is most commonly used in request/response style network calls where it is a single or finite response expected.

Code: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorCache.java
 =||= Done in https://github.com/Netflix/RxJava/pull/1231
 =||= I do a lot of RX training and every time I have to teach connectable observable I lose a third of the room. That's frustrating because Cache and Share meet more than 90% of all use cases.

I think we should follow the principle that only complete subscriptions are cached.  A cached observable has two states:
1. Uncached
2. Cached

In the uncached state, the observable is similar to a share() observable. Concurrent subscribers should share a single ref counted subscription. The only difference is that late concurrent subscribers are "caught up" by immediately getting the contents of the buffer.

Once in an onCompleted or onError message is received, the cached observable goes into the cached state. At this point the observable behaves exactly like a replay subject, never issuing another call to the underlying data source. The data itself is cashed within the ReplaySubject should not go away ever, until all references to the cached observable are freed. This is what users expect, rather than the cached data being tied to a particular subscription as in replay().refCount().

If all concurrent subscribers unsubscribe before the subscription has completed, the data in the cash should be purged and the observable should return to the uncached state.

J

Dictated using voice recognition. Please forgive the typos.

> On May 20, 2014, at 9:24 AM, Ben Christensen notifications@github.com wrote:
> 
> It's just ReplaySubject without refCount. Once it is subscribed to once, it receives all values from the origin and caches them all and replays them all back to whoever subscribes.
> 
> Thus, it is a big massive memory leak if used incorrectly (but that's how toList and default replaySubject are anyways).
> 
> This is most commonly used in request/response style network calls where it is a single or finite response expected.
> 
> Code: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorCache.java
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= > The data itself is cashed within the ReplaySubject should not go away ever, until all references to the cached observable are freed.

Yes, this is how we implemented `cache()`. It lets garbage collection free it, we don't proactively do anything the way `refCount` does, as it's not what people expect here.

> If all concurrent subscribers unsubscribe before the subscription has completed, the data in the cash should be purged and the observable should return to the uncached state.

This isn't as obvious. That would mean it could be resubscribed to and re-execute the work, which would be surprising to people. This could happen all the time if they are using `take(n)` as it would never `onComplete` and always be unsubscribed.

The `cache()` operator caches the entire origin. If it's an infinite stream, it won't work well, and something like `take` will need to be done BEFORE the `cache()` operator is applied.
 =||= ,0
6839,683,API Design Review: Conditionals,Discussion with @headinthebox suggests that the conditional operators really don't belong in RxJava (at least not the core) as they were added to Rx.Net for very specific use cases in F#. 

These include `ifThen`, `switchCase`, `doWhile`, `whileDo`.

Are there reasons to keep these? If so do we move them out of `Observable` or should we delete them?

/cc @headinthebox and @jhusain,http://msdn.microsoft.com/en-us/library/dd233182.aspx 

I don't know of anyone using this for real in Rx.NET.
 =||= These could be moved into a `rxjava-contrib/rxjava-dotnet-legacy` package along with those ops that have been added just to match Rx.Net.
 =||= These can be used for CEP scenarios to reason over multiple streams. It is best that they stay in some form or other as Java does not have anonymous classes like C# where they could be easily avoided by joining fields into a anonymous class. They are more needed in the JVM implementation than in .net.

Ideally the senarios should be expanded in RxJava.
 =||= @sirinath can you give a concrete example? I don't see the connection between these operators which are intended to overload imperative control structures in F# computation expressions and anonymous types.
 =||= If this is extended to accept an observable sequence as the condition / selector then it would be more useful.

Say I want to buy using signal A if vol is greater than a certain threshold plus some other computationally expensive conditions and signal B otherwise only if I am trading that instrument for the day and I only trade 0.5% of instruments.

The current form is somewhat useful if we want to certain set of signals at start of the day but this is something you can do otherwise eagerly at a cost. Also it would be useful if the conditional is also an observable sequence as you can select between streams than at subscription. Using Linq you can aggregate multiple items into anonymous class and select what is needed at the end from this in a further query. This is more difficult though possible in Java than C# hence it will be good to have the conditional functionality extended for other use cases.

More powerful it would be if you have linq Expressions. This is also possible through Commons JCI or directly using Janino. Perhaps at a later stage.
 =||= Also the conditions or index can be extended to a function to take 1 item from each stream and return the appropriate values (boolean / index) for item selection. If not subscribers the condition is not evaluated and if possible each item can be discarded from the streams.

This would be a more convinient way to use this functionality.
 =||= @sirinath Could you provide a concrete example? I am not sure that I understand what you are after precisely.
 =||= Migrating conditionals to a contrib module: https://github.com/Netflix/RxJava/pull/714
 =||= Here is a link to documentation on their usage: http://weblogs.asp.net/podwysocki/archive/2010/06/18/introduction-to-the-reactive-extensions-for-javascript-conditionals.aspx
 =||= @headinthebox 

Add an extra overload with Func<bool, TResult, TResult> condition for if and Func<TValue, TResult[]> selector ... etc.

if(
(a, b) -> !a.equals(obj1) && b.equals(obj2),
strm1,
strm2)

this case condition is evaluated as needed but for each element coming in
 =||= @headinthebox 

In a nutshell the extension will help combination and generation. Something you can consider for the main implementation also.
 =||= ,0
6840,676,API Design Review: SafeObserver via Reflection or Marker Interface	,The `SafeObserver` wrapper is applied to all `Observer` implementations passed into `Observable.subscribe` by users but it is not applied to any `Observer` implementations that originate from within the `rx.operators` package.

This is so we achieve the desired safety and error handling while not paying the cost of wrapping trusted `Observer` implementations from internal operators.

Today it uses reflection to look at the package the `Observer` originates from. It then caches this information for performance.  

See here: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L238 and here:  https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L6822

It is not pretty but it works.

The other way is we could put marker interfaces such as `TrustedObserver` on all `Observer` implementations we use in `rx.operators` or elsewhere that should not be wrapped.

Pros:
- doesn't involve reflection
- obvious
- can be used by non-internal operators

Cons:
- marker interfaces require remembering to put them where they should be
- they can be put where they're not supposed to be
- can be used by non-internal operators and misused
- they are an extra type to maintain in the public API serving little value

Neither approach is pretty. Is there another approach? If not, which of these two is preferable and why?

/cc @headinthebox and @jhusain,Since `Observable` code changes often enough those links will become wrong so here is the valid code:

``` java
/**
     * Whether a given {@link Function} is an internal implementation inside
     * rx.* packages or not.
     * <p>
     * For why this is being used see
     * https://github.com/Netflix/RxJava/issues/216 for discussion on
     * "Guideline 6.4: Protect calls to user code from within an operator"
     * 
     * Note: If strong reasons for not depending on package names comes up then
     * the implementation of this method can change to looking for a marker
     * interface.
     * 
     * @param o
     * @return {@code true} if the given function is an internal implementation,
     *         and {@code false} otherwise.
     */
    private boolean isInternalImplementation(Object o) {
        if (o == null) {
            return true;
        }
        // prevent double-wrapping (yeah it happens)
        if (o instanceof SafeObserver) {
            return true;
        }

        Class<?> clazz = o.getClass();
        if (internalClassMap.containsKey(clazz)) {
            //don't need to do reflection
            return internalClassMap.get(clazz);
        } else {
            // we treat the following package as "internal" and don't wrap it
            Package p = o.getClass().getPackage(); // it can be null
            Boolean isInternal = (p != null && p.getName().startsWith("rx.operators"));
            internalClassMap.put(clazz, isInternal);
            return isInternal;
        }
    }
```

``` java
if (isInternalImplementation(observer)) {
                Subscription s = onSubscribeFunction.onSubscribe(observer);
                if (s == null) {
                    // this generally shouldn't be the case on a 'trusted' onSubscribe but in case it happens
                    // we want to gracefully handle it the same as SafeObservableSubscription does
                    return hook.onSubscribeReturn(this, Subscriptions.empty());
                } else {
                    return hook.onSubscribeReturn(this, s);
                }
            } else {
                SafeObservableSubscription subscription = new SafeObservableSubscription();
                subscription.wrap(onSubscribeFunction.onSubscribe(new SafeObserver<T>(subscription, observer)));
                return hook.onSubscribeReturn(this, subscription);
            }
```
 =||= FWIW, I'd lean toward option 2. (Wouldn't this still result in using reflection though, since you'd have to check for the annotation at runtime?)

> marker interfaces require remembering to put them where they should be

True. Is this something that could be caught using static analysis?

> they can be put where they're not supposed to be

But so can any class level annotation. And it can be made only applicable to classes via the target property. I don't see this being an issue really.

> can be used by non-internal operators and misused

Sure. Then again, whoever misuses this to mark a misbehaving observer as trusted is only shooting themselves in the foot? You get what you ask for :-) 

> they are an extra type to maintain in the public API serving little value

Are you referring to the marker interface? What's the maintenance overhead though, apart from having to remember applying it to internal observers?

Would be interested in hearing what others have to say
 =||= Another option I've become more comfortable with (and that @headinthebox prefers) is that we add `Observable.unsafeSubscribe` that `Operator` implementations can use and it does what it says ... subscribe without any "safety" wrapping. It would directly invoke the inner `OnSubscribe` function.
 =||= Yes, that's what I would prefer. ^F for "unsafe" during code reviews to spot where people may shoot themselves in the foot that don't know what they are doing, but allow full power in case you need to implement a new operator.
 =||= I see. I would find it a bit odd though to find unsafeSubscribe invocations
throughout my client code, even when I know it's safe. It would raise eye
brows for people not as familiar with the peculiarities of the library.
 =||= Do you create operators that act on nested Observables? Examples are `repeat`, `retry`, `merge`.

Those are the only scenario where an `unsafeSubscribe` is needed. Otherwise, normal `Operator` implementations like `map`, `take`, `filter`, etc do not need to.
 =||= Here is an example location where it is doing an "unsafe subscribe": https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorRepeat.java?source=c#L80

Whereas in `map` you'll see it never subscribes because it is a `Subscriber` -> `Subscriber` transformation that gets lifted into the `Observable`: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorMap.java
 =||= I intend on doing this in 0.18 along with `Scheduler` changes. Do my last explanations make sense, or is there still concern about this change?

The only time when this will need to be used is when implementing operators that do nested subscriptions. 
 =||= +1

On Mon, Mar 31, 2014 at 7:34 PM, Ben Christensen
notifications@github.comwrote:

> I intend on doing this in 0.18 along with Scheduler changes. Do my last
> explanations make sense, or is there still concern about this change?
> 
> The only time when this will need to be used is when implementing
> operators that do nested subscriptions.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/676#issuecomment-39117035
> .
 =||= Thanks for the positive confirmation @mttkay ... I'll proceed with this.
 =||= Completed in https://github.com/Netflix/RxJava/pull/1010
 =||= ,0
6843,6819,3.x: Change "the source Publisher" in Flowable javadocs to "the current Flowable",In instance methods of `Flowable`, the source should be referred to as `the current {@code Flowable}`. Currently, it is `the source {@link Publisher}` due to previous copy-paste and search/replace mistakes.

Similarly, `the resulting {@code Publisher}` should be `the resulting {@code Flowable}`.

(Watch out for line breaks in the javadocs when searching for these as patterns).

----
`(?s)(the|a)\s*\*?\s*(source|upstream|resulting)\s*\*?\s*(\{\@code|\{\@link)? Publisher`
`(?s)this\s*\*?\s*(\{\@code|\{\@link)? Publisher`
`(?s)new\s*\*?\s*(\{\@code)?\s*Publisher`,Fixed in #6835 =||= ,0
6843,682,API Design Review: Share,Similar to how we have the `Observable.cache` operator as an easy to understand helper over `multicast`/`replay`, it is suggested to use `Observable.share` for the `multicast`/`publish` as a shortcut to `Observable.publish().refCount()` which is typically rather non-obvious and non-discoverable for people new to the library. 

The suggestion is that `Observable.share` would meet the majority of `multicast` use cases for sharing an `Observable` not needing the complexity of handling the `ConnectableObservable` directly or knowing to use `refCount()`.

It would also match with RxJS: https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeshare

/cc @headinthebox @jhusain and @mattpodwysocki ,@headinthebox and @akarnokd Do you like the idea of `share()` being a cover for `.publish().refCount()`?

Note that RxJS already does this.
 =||= Adding it isn't a big deal but I can't comment on whether the name `share` is discoverable enough. I'd like to hear from users who had trouble with publish.refcount being inconvenient. 
 =||= My only insight into this is that I often see the question/struggle of how to use `publish()` and `connect()` and `refCount()` is always a surprise.
 =||= I'm fine, as you mention RxJs has this. They also have pluck, which sounds cool :-)

Personally I like to be explicit but  I can see the value of share. 
 =||= (Oops, github ui fooled me into accidentally closing)
 =||= @headinthebox @benjchristensen yeah, we gave it some thought before we committed to it, but in the long run it was worth it.
 =||= Thanks for the insight @mattpodwysocki Let's proceed with this. It leaves us with `cache()` and `share()` as the most common multicasting use cases, and the rest for the more complicated scenarios.
 =||= What is `cache()` in this respect?  `replay().refCount()` or something else?
 =||= It's just `ReplaySubject` without `refCount`. Once it is subscribed to once, it receives all values from the origin and caches them all and replays them all back to whoever subscribes. 

Thus, it is a big massive memory leak if used incorrectly (but that's how `toList` and default `replaySubject` are anyways).

This is most commonly used in request/response style network calls where it is a single or finite response expected.

Code: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorCache.java
 =||= Done in https://github.com/Netflix/RxJava/pull/1231
 =||= I do a lot of RX training and every time I have to teach connectable observable I lose a third of the room. That's frustrating because Cache and Share meet more than 90% of all use cases.

I think we should follow the principle that only complete subscriptions are cached.  A cached observable has two states:
1. Uncached
2. Cached

In the uncached state, the observable is similar to a share() observable. Concurrent subscribers should share a single ref counted subscription. The only difference is that late concurrent subscribers are "caught up" by immediately getting the contents of the buffer.

Once in an onCompleted or onError message is received, the cached observable goes into the cached state. At this point the observable behaves exactly like a replay subject, never issuing another call to the underlying data source. The data itself is cashed within the ReplaySubject should not go away ever, until all references to the cached observable are freed. This is what users expect, rather than the cached data being tied to a particular subscription as in replay().refCount().

If all concurrent subscribers unsubscribe before the subscription has completed, the data in the cash should be purged and the observable should return to the uncached state.

J

Dictated using voice recognition. Please forgive the typos.

> On May 20, 2014, at 9:24 AM, Ben Christensen notifications@github.com wrote:
> 
> It's just ReplaySubject without refCount. Once it is subscribed to once, it receives all values from the origin and caches them all and replays them all back to whoever subscribes.
> 
> Thus, it is a big massive memory leak if used incorrectly (but that's how toList and default replaySubject are anyways).
> 
> This is most commonly used in request/response style network calls where it is a single or finite response expected.
> 
> Code: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorCache.java
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= > The data itself is cashed within the ReplaySubject should not go away ever, until all references to the cached observable are freed.

Yes, this is how we implemented `cache()`. It lets garbage collection free it, we don't proactively do anything the way `refCount` does, as it's not what people expect here.

> If all concurrent subscribers unsubscribe before the subscription has completed, the data in the cash should be purged and the observable should return to the uncached state.

This isn't as obvious. That would mean it could be resubscribed to and re-execute the work, which would be surprising to people. This could happen all the time if they are using `take(n)` as it would never `onComplete` and always be unsubscribed.

The `cache()` operator caches the entire origin. If it's an infinite stream, it won't work well, and something like `take` will need to be done BEFORE the `cache()` operator is applied.
 =||= ,0
6844,684,API Design Review: DelayError,The `mergeDelayError` operator has been in RxJava from very early and evolved out of experience with the Netflix API use cases. It is not from Rx.Net.

It has proved very valuable and it has been suggested that this pattern be expanded to other combinatorial operators where lazily handling errors is sometimes appropriate.

These include:
- `concatDelayError`
- `combineLatestDelayError`
- `switchLatestDelayError`

Are there others? Any reason not to do this?

/cc @headinthebox and @jhusain,Talking about these operators. In the .NET version there is an overload that limits the amount of concurrency http://msdn.microsoft.com/en-us/library/hh211914(v=vs.103).aspx while merging, which does not seem to be present in RxJava.
 =||= I can take this overload of merge this weekend.
 =||= Still open to do. Related to this is `flatMapDelayError`: https://github.com/Netflix/RxJava/issues/301
 =||= @zsxwing would be great. We should also make sure that the same consistency is applied for `mergeMap`, i.e. I want the same overloads on `concatMap` (maybe I should open a new issue for that?)
 =||= Do we still want these versions?
 =||= I do.
 =||= Okay, 
- `combineLatestDelayError` is implemented operator-vise, just needs exposure.
- for `concatDelayError`, concat needs full rewrite anyway
- `switchLatestDelayError` is `switchOnNext` with error delay I presume.
 =||= See #3759 for `concatDelayError`.
 =||= See #3763 for `combineLatestDelayError`.
 =||= See #3765 for `switchOnNextDelayError`.
 =||= Operators have been added. Let us know if there are some more required.
 =||= ,0
6846,6830,3.x: Remove duplicate unit tests that check null arguments on standard operators,The `ParamValidationCheckerTest` verifies the `null` checks on arguments so there is no longer need for individual unit test methods doing it too. These kinds tests should be identifiable by `expected = NullPointerException.class` or `catch (NullPointerException`

- [x] `Flowable`
- [x] `Observable`
- [x] `Maybe`
- [x] `Single`
- [x] `Completable`
- [x] `ParallelFlowable`,nan,0
6847,683,API Design Review: Conditionals,Discussion with @headinthebox suggests that the conditional operators really don't belong in RxJava (at least not the core) as they were added to Rx.Net for very specific use cases in F#. 

These include `ifThen`, `switchCase`, `doWhile`, `whileDo`.

Are there reasons to keep these? If so do we move them out of `Observable` or should we delete them?

/cc @headinthebox and @jhusain,http://msdn.microsoft.com/en-us/library/dd233182.aspx 

I don't know of anyone using this for real in Rx.NET.
 =||= These could be moved into a `rxjava-contrib/rxjava-dotnet-legacy` package along with those ops that have been added just to match Rx.Net.
 =||= These can be used for CEP scenarios to reason over multiple streams. It is best that they stay in some form or other as Java does not have anonymous classes like C# where they could be easily avoided by joining fields into a anonymous class. They are more needed in the JVM implementation than in .net.

Ideally the senarios should be expanded in RxJava.
 =||= @sirinath can you give a concrete example? I don't see the connection between these operators which are intended to overload imperative control structures in F# computation expressions and anonymous types.
 =||= If this is extended to accept an observable sequence as the condition / selector then it would be more useful.

Say I want to buy using signal A if vol is greater than a certain threshold plus some other computationally expensive conditions and signal B otherwise only if I am trading that instrument for the day and I only trade 0.5% of instruments.

The current form is somewhat useful if we want to certain set of signals at start of the day but this is something you can do otherwise eagerly at a cost. Also it would be useful if the conditional is also an observable sequence as you can select between streams than at subscription. Using Linq you can aggregate multiple items into anonymous class and select what is needed at the end from this in a further query. This is more difficult though possible in Java than C# hence it will be good to have the conditional functionality extended for other use cases.

More powerful it would be if you have linq Expressions. This is also possible through Commons JCI or directly using Janino. Perhaps at a later stage.
 =||= Also the conditions or index can be extended to a function to take 1 item from each stream and return the appropriate values (boolean / index) for item selection. If not subscribers the condition is not evaluated and if possible each item can be discarded from the streams.

This would be a more convinient way to use this functionality.
 =||= @sirinath Could you provide a concrete example? I am not sure that I understand what you are after precisely.
 =||= Migrating conditionals to a contrib module: https://github.com/Netflix/RxJava/pull/714
 =||= Here is a link to documentation on their usage: http://weblogs.asp.net/podwysocki/archive/2010/06/18/introduction-to-the-reactive-extensions-for-javascript-conditionals.aspx
 =||= @headinthebox 

Add an extra overload with Func<bool, TResult, TResult> condition for if and Func<TValue, TResult[]> selector ... etc.

if(
(a, b) -> !a.equals(obj1) && b.equals(obj2),
strm1,
strm2)

this case condition is evaluated as needed but for each element coming in
 =||= @headinthebox 

In a nutshell the extension will help combination and generation. Something you can consider for the main implementation also.
 =||= ,0
6853,6832,3.x: Validate argument naming consistency between base class methods,Operator argument naming should match between base classes on the same operators.

For example `Observable::buffer(boundary)` vs. `Flowable::buffer(boundaryIndicator)`.

Source-level comparison would be too complicated so reflection can be used for this, provided the class saves the argument names. Javac 8 has this option that must be enabled in the IDE and in `build.gradle`:

```groovy
[compileJava, compileTestJava]*.options*.compilerArgs << "-parameters"

tasks.withType(JavaCompile) {
    options.compilerArgs << "-parameters";
}
```

An extra test is preferrable to remind users enabling this option:

```java
    void method(int paramName) {
        // deliberately empty
    }

    @Test
    public void javacParametersEnabled() throws Exception {
        assertEquals("Please enable saving parameter names via the -parameters javac argument",
                "paramName",
                getClass()
                .getDeclaredMethod("method", Integer.TYPE)
                .getParameters()[0].getName());
    }
```
There are some common operator names across all base classes, these should match as well.,nan,0
6856,685,API Design Review: better name for "just"?,The `just` operator seems misplaced and non-discoverable. The `from` operator is preferable but we can't have `from(T, Scheduler)` because if `T` is `Object` then `from(Object, Scheduler)` can't be disambiguated from `from(Object, Object)`.

Ideas on a new name or different approach?

/cc @headinthebox and @jhusain,We can always do Observable.repeat(x).take(1), or Observable.repeat(x,1). That was the argument for not including "return" in C# Enumerable.
 =||= I think it's too late to remove `just` ... and it works.

The two primary entry points are `Observable.from()` and `Observable.just()`.
 =||= ,0
6857,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6857,6855,3.x: [Wiki] Enhance Operator-Matrix generation with anchors and explanations,https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

I've turned the column headers to images rotated 90 degrees so the table doesn't overflow the wiki layout.

The `src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java` should be updated accordingly, plus:

- Add HTML anchors to the rows so they can be navigated to via `#methodName`
- Add `<sup>[N](#note-N)</sup>` to absent entries and a list of notes below the table explaining why. For this, the reason mapping has to be added to the generator.,Closing via #6857 =||= ,0
6860,682,API Design Review: Share,Similar to how we have the `Observable.cache` operator as an easy to understand helper over `multicast`/`replay`, it is suggested to use `Observable.share` for the `multicast`/`publish` as a shortcut to `Observable.publish().refCount()` which is typically rather non-obvious and non-discoverable for people new to the library. 

The suggestion is that `Observable.share` would meet the majority of `multicast` use cases for sharing an `Observable` not needing the complexity of handling the `ConnectableObservable` directly or knowing to use `refCount()`.

It would also match with RxJS: https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeshare

/cc @headinthebox @jhusain and @mattpodwysocki ,@headinthebox and @akarnokd Do you like the idea of `share()` being a cover for `.publish().refCount()`?

Note that RxJS already does this.
 =||= Adding it isn't a big deal but I can't comment on whether the name `share` is discoverable enough. I'd like to hear from users who had trouble with publish.refcount being inconvenient. 
 =||= My only insight into this is that I often see the question/struggle of how to use `publish()` and `connect()` and `refCount()` is always a surprise.
 =||= I'm fine, as you mention RxJs has this. They also have pluck, which sounds cool :-)

Personally I like to be explicit but  I can see the value of share. 
 =||= (Oops, github ui fooled me into accidentally closing)
 =||= @headinthebox @benjchristensen yeah, we gave it some thought before we committed to it, but in the long run it was worth it.
 =||= Thanks for the insight @mattpodwysocki Let's proceed with this. It leaves us with `cache()` and `share()` as the most common multicasting use cases, and the rest for the more complicated scenarios.
 =||= What is `cache()` in this respect?  `replay().refCount()` or something else?
 =||= It's just `ReplaySubject` without `refCount`. Once it is subscribed to once, it receives all values from the origin and caches them all and replays them all back to whoever subscribes. 

Thus, it is a big massive memory leak if used incorrectly (but that's how `toList` and default `replaySubject` are anyways).

This is most commonly used in request/response style network calls where it is a single or finite response expected.

Code: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorCache.java
 =||= Done in https://github.com/Netflix/RxJava/pull/1231
 =||= I do a lot of RX training and every time I have to teach connectable observable I lose a third of the room. That's frustrating because Cache and Share meet more than 90% of all use cases.

I think we should follow the principle that only complete subscriptions are cached.  A cached observable has two states:
1. Uncached
2. Cached

In the uncached state, the observable is similar to a share() observable. Concurrent subscribers should share a single ref counted subscription. The only difference is that late concurrent subscribers are "caught up" by immediately getting the contents of the buffer.

Once in an onCompleted or onError message is received, the cached observable goes into the cached state. At this point the observable behaves exactly like a replay subject, never issuing another call to the underlying data source. The data itself is cashed within the ReplaySubject should not go away ever, until all references to the cached observable are freed. This is what users expect, rather than the cached data being tied to a particular subscription as in replay().refCount().

If all concurrent subscribers unsubscribe before the subscription has completed, the data in the cash should be purged and the observable should return to the uncached state.

J

Dictated using voice recognition. Please forgive the typos.

> On May 20, 2014, at 9:24 AM, Ben Christensen notifications@github.com wrote:
> 
> It's just ReplaySubject without refCount. Once it is subscribed to once, it receives all values from the origin and caches them all and replays them all back to whoever subscribes.
> 
> Thus, it is a big massive memory leak if used incorrectly (but that's how toList and default replaySubject are anyways).
> 
> This is most commonly used in request/response style network calls where it is a single or finite response expected.
> 
> Code: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorCache.java
> 
> —
> Reply to this email directly or view it on GitHub.
 =||= > The data itself is cashed within the ReplaySubject should not go away ever, until all references to the cached observable are freed.

Yes, this is how we implemented `cache()`. It lets garbage collection free it, we don't proactively do anything the way `refCount` does, as it's not what people expect here.

> If all concurrent subscribers unsubscribe before the subscription has completed, the data in the cash should be purged and the observable should return to the uncached state.

This isn't as obvious. That would mean it could be resubscribed to and re-execute the work, which would be surprising to people. This could happen all the time if they are using `take(n)` as it would never `onComplete` and always be unsubscribed.

The `cache()` operator caches the entire origin. If it's an infinite stream, it won't work well, and something like `take` will need to be done BEFORE the `cache()` operator is applied.
 =||= ,0
6862,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6864,6863,3.x: Maybe.delay has no `delayError` option unlike `Single`,It defaults to always delay an error.,nan,0
6867,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6867,5806,3.x: Maybe incorrect or missing marbles (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(Iterable)`: missing diagram
- [x] `concat(Publisher)`: missing diagram
- [x] `concat(Publisher, int)`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concatArrayDelayError`: indicate error delayed, 1 marble per source
- [x] `concatArrayEager`: missing diagram
- [x] `concatDelayError(Iterable)`: missing diagram
- [x] `concatDelayError(Publisher)`: missing diagram
- [x] `concatDelayError(Publisher, int)`: fix overlap/misalignment inside the operator box
- [x] `concatEager(Iterable)`: missing diagram
- [x] `concatEager(Publisher)`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: indicate callable returns the error
- [x] `fromAction`: missing diagram
- [x] `fromCompletable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture(Future)`: operator name in the box, indicate Future is the parameter
- [x] `fromFuture(Future, long, TimeUnit)`: operator name in the box, indicate Future is the parameter, indicate timeout
- [x] `fromRunnable`: missing diagram
- [x] `merge(Iterable)`: missing diagram
- [x] `merge(Publisher)`: missing diagram
- [x] `merge(Publisher, int)`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `mergeArrayDelayError`: one marble per Maybe source
- [x] `mergeDelayError(Iterable)`: one marble per Maybe source
- [x] `mergeDelayError(Publisher)`: one marble per Maybe source
- [x] `mergeDelayError(Maybe, Maybe, ...)`: one marble per Maybe source
- [x] `sequenceEqual` + 1: result should be `Single`.
- [x] `timer` + 1: result should be Maybe
- [x] `using` + 1: rework to indicate the created Maybe
- [x] `wrap`: missing marble
- [x] `zip(Iterable)`: one marble per Maybe source, result should be Maybe
- [x] `zip(Maybe, Maybe, ...)` + 8: one marble per Maybe source, result should be Maybe
- [x] `zipArray`: one marble per Maybe source, result should be Maybe
- [x] `ambWith`: one marble per Maybe source, result should be Maybe
- [x] ~~`as`: missing diagram~~ operator removed
- [x] `blockingGet` + 1: missing diagram
- [x] `cache`: one marble per Maybe source, result should be Maybe
- [x] `cast`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatMap`: indicate Maybe target, indicate empty source
- [x] `concatWith`: one marble per Maybe source, result should be Maybe, operator name, indicate other is a parameter
- [x] `contains`: one marble per Maybe source, result should be Single, empty case
- [x] `count`: one marble per maybe, operator name, result should be Single, empty case
- [x] `defaultIfEmpty`: non-empty case, result should be Maybe
- [x] `delay(time)` + 3: one marble per Maybe source, result should be Maybe
- [x] `delay(Publisher)`: one marble per Maybe, one signal by the Publisher, empty publisher case
- [x] `delaySubscription(Publisher)`: missing diagram
- [x] `delaySubscription(time)` + 1: one marble per Maybe source, result should be Maybe
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: operator name, one marble per Maybe, result should be Maybe
- [x] `doFinally`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnComplete`: one marble per Maybe, result should be Maybe
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnTerminate`: one marble per Maybe, result should be Maybe
- [x] `filter`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, Function, Callable)`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, BiFunction)`: one marble per Maybe, result should be Maybe
- [x] `flatMapObservable`: should be mapped into an Observable
- [x] `flatMapPublisher`: indicate backpressure
- [x] `flatMapSingle`: indicate empty maybe results in error
- [x] `flatMapSingleElement`: operator name, indicate empty maybe
- [x] `flatMapCompletable`: indicate empty maybe
- [x] `hide`: missing diagram
- [x] `ignoreElement`: operator name, one marble per Maybe, result should be Maybe
- [x] `isEmpty`: result should be Single
- [x] `mergeWith`: operator name, one marble per Maybe, indicate backpressure
- [x] `ofType`: one marble per Maybe
- [x] `onErrorComplete` + 1: missing diagram
- [x] `onErrorResumeNext`: one marble per Maybe, result should be Maybe
- [x] `onErrorResumeWith`: one marble per Maybe, result should be Maybe
- [x] `onErrorReturn`: one marble per Maybe, result should be Maybe, indicate callback
- [x] `onErrorReturnItem`: operator name, one marble per Maybe, result should be Maybe, indicate normal outcome
- [x] ~~`onExceptionResumeNext`: operator takes a Maybe source directlyˇ~~ operator removed
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat` + 1: one marble per source, indicate backpressure, indicate repeat conditions
- [x] `repeatUntil`: operator name, repeat condition, indicate backpressure
- [x] `repeatWhen`: one marble per Maybe, indicate backpressure
- [x] `retry` + 2: one marble per Maybe, result should be Maybe, indicate repeat conditions
- [x] `retry(int, Predicate)`: missing diagram
- [x] `retry(Predicate)`: missing diagram
- [x] `retryUntil`: missing diagram
- [x] `retryWhen`: one marble per Maybe, output should be Maybe
- [x] `switchIfEmpty` + 1: improve diagrams, indicate argument type
- [x] `takeUntil` + 1: one marble per Maybe, output should be Maybe
- [x] `timeout` + 3: one marble per Maybe, output should be Maybe
- [x] `timeout(MaybeSource)`: missing diagram
- [x] `timeout(MaybeSource, MaybeSource)`: missing diagram
- [x] `timeout(Publisher)`: missing diagram
- [x] `timeout(Publisher, MaybeSource)`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toObservable`: missing diagram
- [x] `toSingle` + 1: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `zipWith`: one marble per Maybe, output should be Maybe,Here is the Excel file I draw the diagrams in: https://drive.google.com/file/d/1di67kFJEuiLPyq14JlnV3vFl-muaCMfH/view?usp=sharing =||= ,0
6868,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6868,5806,3.x: Maybe incorrect or missing marbles (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(Iterable)`: missing diagram
- [x] `concat(Publisher)`: missing diagram
- [x] `concat(Publisher, int)`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concatArrayDelayError`: indicate error delayed, 1 marble per source
- [x] `concatArrayEager`: missing diagram
- [x] `concatDelayError(Iterable)`: missing diagram
- [x] `concatDelayError(Publisher)`: missing diagram
- [x] `concatDelayError(Publisher, int)`: fix overlap/misalignment inside the operator box
- [x] `concatEager(Iterable)`: missing diagram
- [x] `concatEager(Publisher)`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: indicate callable returns the error
- [x] `fromAction`: missing diagram
- [x] `fromCompletable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture(Future)`: operator name in the box, indicate Future is the parameter
- [x] `fromFuture(Future, long, TimeUnit)`: operator name in the box, indicate Future is the parameter, indicate timeout
- [x] `fromRunnable`: missing diagram
- [x] `merge(Iterable)`: missing diagram
- [x] `merge(Publisher)`: missing diagram
- [x] `merge(Publisher, int)`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `mergeArrayDelayError`: one marble per Maybe source
- [x] `mergeDelayError(Iterable)`: one marble per Maybe source
- [x] `mergeDelayError(Publisher)`: one marble per Maybe source
- [x] `mergeDelayError(Maybe, Maybe, ...)`: one marble per Maybe source
- [x] `sequenceEqual` + 1: result should be `Single`.
- [x] `timer` + 1: result should be Maybe
- [x] `using` + 1: rework to indicate the created Maybe
- [x] `wrap`: missing marble
- [x] `zip(Iterable)`: one marble per Maybe source, result should be Maybe
- [x] `zip(Maybe, Maybe, ...)` + 8: one marble per Maybe source, result should be Maybe
- [x] `zipArray`: one marble per Maybe source, result should be Maybe
- [x] `ambWith`: one marble per Maybe source, result should be Maybe
- [x] ~~`as`: missing diagram~~ operator removed
- [x] `blockingGet` + 1: missing diagram
- [x] `cache`: one marble per Maybe source, result should be Maybe
- [x] `cast`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatMap`: indicate Maybe target, indicate empty source
- [x] `concatWith`: one marble per Maybe source, result should be Maybe, operator name, indicate other is a parameter
- [x] `contains`: one marble per Maybe source, result should be Single, empty case
- [x] `count`: one marble per maybe, operator name, result should be Single, empty case
- [x] `defaultIfEmpty`: non-empty case, result should be Maybe
- [x] `delay(time)` + 3: one marble per Maybe source, result should be Maybe
- [x] `delay(Publisher)`: one marble per Maybe, one signal by the Publisher, empty publisher case
- [x] `delaySubscription(Publisher)`: missing diagram
- [x] `delaySubscription(time)` + 1: one marble per Maybe source, result should be Maybe
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: operator name, one marble per Maybe, result should be Maybe
- [x] `doFinally`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnComplete`: one marble per Maybe, result should be Maybe
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnTerminate`: one marble per Maybe, result should be Maybe
- [x] `filter`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, Function, Callable)`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, BiFunction)`: one marble per Maybe, result should be Maybe
- [x] `flatMapObservable`: should be mapped into an Observable
- [x] `flatMapPublisher`: indicate backpressure
- [x] `flatMapSingle`: indicate empty maybe results in error
- [x] `flatMapSingleElement`: operator name, indicate empty maybe
- [x] `flatMapCompletable`: indicate empty maybe
- [x] `hide`: missing diagram
- [x] `ignoreElement`: operator name, one marble per Maybe, result should be Maybe
- [x] `isEmpty`: result should be Single
- [x] `mergeWith`: operator name, one marble per Maybe, indicate backpressure
- [x] `ofType`: one marble per Maybe
- [x] `onErrorComplete` + 1: missing diagram
- [x] `onErrorResumeNext`: one marble per Maybe, result should be Maybe
- [x] `onErrorResumeWith`: one marble per Maybe, result should be Maybe
- [x] `onErrorReturn`: one marble per Maybe, result should be Maybe, indicate callback
- [x] `onErrorReturnItem`: operator name, one marble per Maybe, result should be Maybe, indicate normal outcome
- [x] ~~`onExceptionResumeNext`: operator takes a Maybe source directlyˇ~~ operator removed
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat` + 1: one marble per source, indicate backpressure, indicate repeat conditions
- [x] `repeatUntil`: operator name, repeat condition, indicate backpressure
- [x] `repeatWhen`: one marble per Maybe, indicate backpressure
- [x] `retry` + 2: one marble per Maybe, result should be Maybe, indicate repeat conditions
- [x] `retry(int, Predicate)`: missing diagram
- [x] `retry(Predicate)`: missing diagram
- [x] `retryUntil`: missing diagram
- [x] `retryWhen`: one marble per Maybe, output should be Maybe
- [x] `switchIfEmpty` + 1: improve diagrams, indicate argument type
- [x] `takeUntil` + 1: one marble per Maybe, output should be Maybe
- [x] `timeout` + 3: one marble per Maybe, output should be Maybe
- [x] `timeout(MaybeSource)`: missing diagram
- [x] `timeout(MaybeSource, MaybeSource)`: missing diagram
- [x] `timeout(Publisher)`: missing diagram
- [x] `timeout(Publisher, MaybeSource)`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toObservable`: missing diagram
- [x] `toSingle` + 1: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `zipWith`: one marble per Maybe, output should be Maybe,Here is the Excel file I draw the diagrams in: https://drive.google.com/file/d/1di67kFJEuiLPyq14JlnV3vFl-muaCMfH/view?usp=sharing =||= ,0
6869,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6869,5806,3.x: Maybe incorrect or missing marbles (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(Iterable)`: missing diagram
- [x] `concat(Publisher)`: missing diagram
- [x] `concat(Publisher, int)`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concatArrayDelayError`: indicate error delayed, 1 marble per source
- [x] `concatArrayEager`: missing diagram
- [x] `concatDelayError(Iterable)`: missing diagram
- [x] `concatDelayError(Publisher)`: missing diagram
- [x] `concatDelayError(Publisher, int)`: fix overlap/misalignment inside the operator box
- [x] `concatEager(Iterable)`: missing diagram
- [x] `concatEager(Publisher)`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: indicate callable returns the error
- [x] `fromAction`: missing diagram
- [x] `fromCompletable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture(Future)`: operator name in the box, indicate Future is the parameter
- [x] `fromFuture(Future, long, TimeUnit)`: operator name in the box, indicate Future is the parameter, indicate timeout
- [x] `fromRunnable`: missing diagram
- [x] `merge(Iterable)`: missing diagram
- [x] `merge(Publisher)`: missing diagram
- [x] `merge(Publisher, int)`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `mergeArrayDelayError`: one marble per Maybe source
- [x] `mergeDelayError(Iterable)`: one marble per Maybe source
- [x] `mergeDelayError(Publisher)`: one marble per Maybe source
- [x] `mergeDelayError(Maybe, Maybe, ...)`: one marble per Maybe source
- [x] `sequenceEqual` + 1: result should be `Single`.
- [x] `timer` + 1: result should be Maybe
- [x] `using` + 1: rework to indicate the created Maybe
- [x] `wrap`: missing marble
- [x] `zip(Iterable)`: one marble per Maybe source, result should be Maybe
- [x] `zip(Maybe, Maybe, ...)` + 8: one marble per Maybe source, result should be Maybe
- [x] `zipArray`: one marble per Maybe source, result should be Maybe
- [x] `ambWith`: one marble per Maybe source, result should be Maybe
- [x] ~~`as`: missing diagram~~ operator removed
- [x] `blockingGet` + 1: missing diagram
- [x] `cache`: one marble per Maybe source, result should be Maybe
- [x] `cast`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatMap`: indicate Maybe target, indicate empty source
- [x] `concatWith`: one marble per Maybe source, result should be Maybe, operator name, indicate other is a parameter
- [x] `contains`: one marble per Maybe source, result should be Single, empty case
- [x] `count`: one marble per maybe, operator name, result should be Single, empty case
- [x] `defaultIfEmpty`: non-empty case, result should be Maybe
- [x] `delay(time)` + 3: one marble per Maybe source, result should be Maybe
- [x] `delay(Publisher)`: one marble per Maybe, one signal by the Publisher, empty publisher case
- [x] `delaySubscription(Publisher)`: missing diagram
- [x] `delaySubscription(time)` + 1: one marble per Maybe source, result should be Maybe
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: operator name, one marble per Maybe, result should be Maybe
- [x] `doFinally`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnComplete`: one marble per Maybe, result should be Maybe
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnTerminate`: one marble per Maybe, result should be Maybe
- [x] `filter`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, Function, Callable)`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, BiFunction)`: one marble per Maybe, result should be Maybe
- [x] `flatMapObservable`: should be mapped into an Observable
- [x] `flatMapPublisher`: indicate backpressure
- [x] `flatMapSingle`: indicate empty maybe results in error
- [x] `flatMapSingleElement`: operator name, indicate empty maybe
- [x] `flatMapCompletable`: indicate empty maybe
- [x] `hide`: missing diagram
- [x] `ignoreElement`: operator name, one marble per Maybe, result should be Maybe
- [x] `isEmpty`: result should be Single
- [x] `mergeWith`: operator name, one marble per Maybe, indicate backpressure
- [x] `ofType`: one marble per Maybe
- [x] `onErrorComplete` + 1: missing diagram
- [x] `onErrorResumeNext`: one marble per Maybe, result should be Maybe
- [x] `onErrorResumeWith`: one marble per Maybe, result should be Maybe
- [x] `onErrorReturn`: one marble per Maybe, result should be Maybe, indicate callback
- [x] `onErrorReturnItem`: operator name, one marble per Maybe, result should be Maybe, indicate normal outcome
- [x] ~~`onExceptionResumeNext`: operator takes a Maybe source directlyˇ~~ operator removed
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat` + 1: one marble per source, indicate backpressure, indicate repeat conditions
- [x] `repeatUntil`: operator name, repeat condition, indicate backpressure
- [x] `repeatWhen`: one marble per Maybe, indicate backpressure
- [x] `retry` + 2: one marble per Maybe, result should be Maybe, indicate repeat conditions
- [x] `retry(int, Predicate)`: missing diagram
- [x] `retry(Predicate)`: missing diagram
- [x] `retryUntil`: missing diagram
- [x] `retryWhen`: one marble per Maybe, output should be Maybe
- [x] `switchIfEmpty` + 1: improve diagrams, indicate argument type
- [x] `takeUntil` + 1: one marble per Maybe, output should be Maybe
- [x] `timeout` + 3: one marble per Maybe, output should be Maybe
- [x] `timeout(MaybeSource)`: missing diagram
- [x] `timeout(MaybeSource, MaybeSource)`: missing diagram
- [x] `timeout(Publisher)`: missing diagram
- [x] `timeout(Publisher, MaybeSource)`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toObservable`: missing diagram
- [x] `toSingle` + 1: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `zipWith`: one marble per Maybe, output should be Maybe,Here is the Excel file I draw the diagrams in: https://drive.google.com/file/d/1di67kFJEuiLPyq14JlnV3vFl-muaCMfH/view?usp=sharing =||= ,0
6870,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6871,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6873,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6874,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6875,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6876,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6876,580,CRLF fixes,Issue #579

In case the manual mode is chosen.,[RxJava-pull-requests #519](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/519/) SUCCESS
This pull request looks good
 =||= I added the .gitattributes file in this commit: https://github.com/Netflix/RxJava/commit/4782588aa15a954ea053977d6b740127d31ee3f1 and then let Git renormalize itself as per https://help.github.com/articles/dealing-with-line-endings#re-normalizing-a-repository
 =||= ,0
6877,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6879,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6881,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6882,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6884,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6885,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6886,6852,3.x: Missing operators (tracking issue),https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`),Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= ,0
6886,5806,3.x: Maybe incorrect or missing marbles (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(Iterable)`: missing diagram
- [x] `concat(Publisher)`: missing diagram
- [x] `concat(Publisher, int)`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concatArrayDelayError`: indicate error delayed, 1 marble per source
- [x] `concatArrayEager`: missing diagram
- [x] `concatDelayError(Iterable)`: missing diagram
- [x] `concatDelayError(Publisher)`: missing diagram
- [x] `concatDelayError(Publisher, int)`: fix overlap/misalignment inside the operator box
- [x] `concatEager(Iterable)`: missing diagram
- [x] `concatEager(Publisher)`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: indicate callable returns the error
- [x] `fromAction`: missing diagram
- [x] `fromCompletable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture(Future)`: operator name in the box, indicate Future is the parameter
- [x] `fromFuture(Future, long, TimeUnit)`: operator name in the box, indicate Future is the parameter, indicate timeout
- [x] `fromRunnable`: missing diagram
- [x] `merge(Iterable)`: missing diagram
- [x] `merge(Publisher)`: missing diagram
- [x] `merge(Publisher, int)`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `mergeArrayDelayError`: one marble per Maybe source
- [x] `mergeDelayError(Iterable)`: one marble per Maybe source
- [x] `mergeDelayError(Publisher)`: one marble per Maybe source
- [x] `mergeDelayError(Maybe, Maybe, ...)`: one marble per Maybe source
- [x] `sequenceEqual` + 1: result should be `Single`.
- [x] `timer` + 1: result should be Maybe
- [x] `using` + 1: rework to indicate the created Maybe
- [x] `wrap`: missing marble
- [x] `zip(Iterable)`: one marble per Maybe source, result should be Maybe
- [x] `zip(Maybe, Maybe, ...)` + 8: one marble per Maybe source, result should be Maybe
- [x] `zipArray`: one marble per Maybe source, result should be Maybe
- [x] `ambWith`: one marble per Maybe source, result should be Maybe
- [x] ~~`as`: missing diagram~~ operator removed
- [x] `blockingGet` + 1: missing diagram
- [x] `cache`: one marble per Maybe source, result should be Maybe
- [x] `cast`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatMap`: indicate Maybe target, indicate empty source
- [x] `concatWith`: one marble per Maybe source, result should be Maybe, operator name, indicate other is a parameter
- [x] `contains`: one marble per Maybe source, result should be Single, empty case
- [x] `count`: one marble per maybe, operator name, result should be Single, empty case
- [x] `defaultIfEmpty`: non-empty case, result should be Maybe
- [x] `delay(time)` + 3: one marble per Maybe source, result should be Maybe
- [x] `delay(Publisher)`: one marble per Maybe, one signal by the Publisher, empty publisher case
- [x] `delaySubscription(Publisher)`: missing diagram
- [x] `delaySubscription(time)` + 1: one marble per Maybe source, result should be Maybe
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: operator name, one marble per Maybe, result should be Maybe
- [x] `doFinally`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnComplete`: one marble per Maybe, result should be Maybe
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnTerminate`: one marble per Maybe, result should be Maybe
- [x] `filter`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, Function, Callable)`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, BiFunction)`: one marble per Maybe, result should be Maybe
- [x] `flatMapObservable`: should be mapped into an Observable
- [x] `flatMapPublisher`: indicate backpressure
- [x] `flatMapSingle`: indicate empty maybe results in error
- [x] `flatMapSingleElement`: operator name, indicate empty maybe
- [x] `flatMapCompletable`: indicate empty maybe
- [x] `hide`: missing diagram
- [x] `ignoreElement`: operator name, one marble per Maybe, result should be Maybe
- [x] `isEmpty`: result should be Single
- [x] `mergeWith`: operator name, one marble per Maybe, indicate backpressure
- [x] `ofType`: one marble per Maybe
- [x] `onErrorComplete` + 1: missing diagram
- [x] `onErrorResumeNext`: one marble per Maybe, result should be Maybe
- [x] `onErrorResumeWith`: one marble per Maybe, result should be Maybe
- [x] `onErrorReturn`: one marble per Maybe, result should be Maybe, indicate callback
- [x] `onErrorReturnItem`: operator name, one marble per Maybe, result should be Maybe, indicate normal outcome
- [x] ~~`onExceptionResumeNext`: operator takes a Maybe source directlyˇ~~ operator removed
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat` + 1: one marble per source, indicate backpressure, indicate repeat conditions
- [x] `repeatUntil`: operator name, repeat condition, indicate backpressure
- [x] `repeatWhen`: one marble per Maybe, indicate backpressure
- [x] `retry` + 2: one marble per Maybe, result should be Maybe, indicate repeat conditions
- [x] `retry(int, Predicate)`: missing diagram
- [x] `retry(Predicate)`: missing diagram
- [x] `retryUntil`: missing diagram
- [x] `retryWhen`: one marble per Maybe, output should be Maybe
- [x] `switchIfEmpty` + 1: improve diagrams, indicate argument type
- [x] `takeUntil` + 1: one marble per Maybe, output should be Maybe
- [x] `timeout` + 3: one marble per Maybe, output should be Maybe
- [x] `timeout(MaybeSource)`: missing diagram
- [x] `timeout(MaybeSource, MaybeSource)`: missing diagram
- [x] `timeout(Publisher)`: missing diagram
- [x] `timeout(Publisher, MaybeSource)`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toObservable`: missing diagram
- [x] `toSingle` + 1: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `zipWith`: one marble per Maybe, output should be Maybe,Here is the Excel file I draw the diagrams in: https://drive.google.com/file/d/1di67kFJEuiLPyq14JlnV3vFl-muaCMfH/view?usp=sharing =||= ,0
6887,685,API Design Review: better name for "just"?,The `just` operator seems misplaced and non-discoverable. The `from` operator is preferable but we can't have `from(T, Scheduler)` because if `T` is `Object` then `from(Object, Scheduler)` can't be disambiguated from `from(Object, Object)`.

Ideas on a new name or different approach?

/cc @headinthebox and @jhusain,We can always do Observable.repeat(x).take(1), or Observable.repeat(x,1). That was the argument for not including "return" in C# Enumerable.
 =||= I think it's too late to remove `just` ... and it works.

The two primary entry points are `Observable.from()` and `Observable.just()`.
 =||= ,0
6888,6865,3.x: Check Maybe/Single/Completable operators delegating to Flowable ops,Some operators in `Maybe`, `Single` and `Completable` are delegating to `Flowable` operators that may not be the best fit. For example:

```java
    public static <T> Flowable<T> merge(@NonNull Publisher<@NonNull ? extends MaybeSource<? extends T>> sources, int maxConcurrency) {
        Objects.requireNonNull(sources, "sources is null");
        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");
        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));
    }
```

Can now be:

```java
       return RxJavaPlugins.onAssembly(new FlowableFlatMapMaybe<>(sources, Functions.identity(), false, maxConcurrency)
```

But, since `FlowableFlatMapMaybe` takes a `Flowable<T>`, not a `Publisher<T>`, a new simple class should be created (`FlowableFlatMapMaybePublisher`) that takes a `Publisher<T>` but reuses the internals of `FlowableFlatMapMaybe`.,nan,0
6890,6872,3.x: Create a tool that scans the java sources and checks marble dimensions,Create a manually runnable tool (in `internal.util`) that walks through the java sources of the base classes, parses out the `<img width="" height="" src=""/>`, downloads the referenced image and verifies that `height` is set properly. 

More specifically, `round(640.0/image.width * image.height)` and prints a fake stacktrace element to the particular line and the right amount. It is recommended the download is somewhat rate-limited (1 per 100ms) because the sheer number of images. The same reason applies why this isn't an unit test to be. Use `TestHelper.findSource()` to locate the source java.
,nan,0
6891,6878,3.x: Swap Maybe.flatMapSingle and Maybe.flatMapSingleElement ?,Currently, `flatMapSingle` returns `Single` and signals `NoSuchElementException` if the source `Maybe` is empty. `flatMapSingleElement` remains `Maybe`.

I'd consider renaming `flatMapSingle` to `flatMapSingleOrError` and `flatMapSingleElement` to `flatMapSingle` as I think a default `Maybe` -> `Maybe` transformer should better match the other such transformers.

Alternatively, drop `flatMapSingle` and rename `flatMapSingleElement` to `flatMapSingle` so that the original behavior could be achieved via `flatMapSingle.toSingle())`.,Personally I'm in favor of dropping the old `flatMapSingle` and renaming `flatMapSingleElement`, because I found the behavior of the old `flatMapSingle` surprising at first, and using `toSingle().flatMap()` is more readable. =||= Let's drop `flatMapSingle` and rename `flatMapSingleElement`. 

@slisaasquatch would you like to post a PR? If so, please keep the unit tests and use `flatMapSingle().toSingle()`. =||= ,0
6893,6892,3.x: Reenable XFlatMapTest.maybeSingle,There is a small behavior difference between `Flowable.flatMap` and `Maybe.flatMapSingle` that made the test fail. Namely, the effect of disposing before the function returns the inner source.,nan,0
6893,5806,3.x: Maybe incorrect or missing marbles (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(Iterable)`: missing diagram
- [x] `concat(Publisher)`: missing diagram
- [x] `concat(Publisher, int)`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concatArrayDelayError`: indicate error delayed, 1 marble per source
- [x] `concatArrayEager`: missing diagram
- [x] `concatDelayError(Iterable)`: missing diagram
- [x] `concatDelayError(Publisher)`: missing diagram
- [x] `concatDelayError(Publisher, int)`: fix overlap/misalignment inside the operator box
- [x] `concatEager(Iterable)`: missing diagram
- [x] `concatEager(Publisher)`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: indicate callable returns the error
- [x] `fromAction`: missing diagram
- [x] `fromCompletable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture(Future)`: operator name in the box, indicate Future is the parameter
- [x] `fromFuture(Future, long, TimeUnit)`: operator name in the box, indicate Future is the parameter, indicate timeout
- [x] `fromRunnable`: missing diagram
- [x] `merge(Iterable)`: missing diagram
- [x] `merge(Publisher)`: missing diagram
- [x] `merge(Publisher, int)`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `mergeArrayDelayError`: one marble per Maybe source
- [x] `mergeDelayError(Iterable)`: one marble per Maybe source
- [x] `mergeDelayError(Publisher)`: one marble per Maybe source
- [x] `mergeDelayError(Maybe, Maybe, ...)`: one marble per Maybe source
- [x] `sequenceEqual` + 1: result should be `Single`.
- [x] `timer` + 1: result should be Maybe
- [x] `using` + 1: rework to indicate the created Maybe
- [x] `wrap`: missing marble
- [x] `zip(Iterable)`: one marble per Maybe source, result should be Maybe
- [x] `zip(Maybe, Maybe, ...)` + 8: one marble per Maybe source, result should be Maybe
- [x] `zipArray`: one marble per Maybe source, result should be Maybe
- [x] `ambWith`: one marble per Maybe source, result should be Maybe
- [x] ~~`as`: missing diagram~~ operator removed
- [x] `blockingGet` + 1: missing diagram
- [x] `cache`: one marble per Maybe source, result should be Maybe
- [x] `cast`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatMap`: indicate Maybe target, indicate empty source
- [x] `concatWith`: one marble per Maybe source, result should be Maybe, operator name, indicate other is a parameter
- [x] `contains`: one marble per Maybe source, result should be Single, empty case
- [x] `count`: one marble per maybe, operator name, result should be Single, empty case
- [x] `defaultIfEmpty`: non-empty case, result should be Maybe
- [x] `delay(time)` + 3: one marble per Maybe source, result should be Maybe
- [x] `delay(Publisher)`: one marble per Maybe, one signal by the Publisher, empty publisher case
- [x] `delaySubscription(Publisher)`: missing diagram
- [x] `delaySubscription(time)` + 1: one marble per Maybe source, result should be Maybe
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: operator name, one marble per Maybe, result should be Maybe
- [x] `doFinally`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnComplete`: one marble per Maybe, result should be Maybe
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnTerminate`: one marble per Maybe, result should be Maybe
- [x] `filter`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, Function, Callable)`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, BiFunction)`: one marble per Maybe, result should be Maybe
- [x] `flatMapObservable`: should be mapped into an Observable
- [x] `flatMapPublisher`: indicate backpressure
- [x] `flatMapSingle`: indicate empty maybe results in error
- [x] `flatMapSingleElement`: operator name, indicate empty maybe
- [x] `flatMapCompletable`: indicate empty maybe
- [x] `hide`: missing diagram
- [x] `ignoreElement`: operator name, one marble per Maybe, result should be Maybe
- [x] `isEmpty`: result should be Single
- [x] `mergeWith`: operator name, one marble per Maybe, indicate backpressure
- [x] `ofType`: one marble per Maybe
- [x] `onErrorComplete` + 1: missing diagram
- [x] `onErrorResumeNext`: one marble per Maybe, result should be Maybe
- [x] `onErrorResumeWith`: one marble per Maybe, result should be Maybe
- [x] `onErrorReturn`: one marble per Maybe, result should be Maybe, indicate callback
- [x] `onErrorReturnItem`: operator name, one marble per Maybe, result should be Maybe, indicate normal outcome
- [x] ~~`onExceptionResumeNext`: operator takes a Maybe source directlyˇ~~ operator removed
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat` + 1: one marble per source, indicate backpressure, indicate repeat conditions
- [x] `repeatUntil`: operator name, repeat condition, indicate backpressure
- [x] `repeatWhen`: one marble per Maybe, indicate backpressure
- [x] `retry` + 2: one marble per Maybe, result should be Maybe, indicate repeat conditions
- [x] `retry(int, Predicate)`: missing diagram
- [x] `retry(Predicate)`: missing diagram
- [x] `retryUntil`: missing diagram
- [x] `retryWhen`: one marble per Maybe, output should be Maybe
- [x] `switchIfEmpty` + 1: improve diagrams, indicate argument type
- [x] `takeUntil` + 1: one marble per Maybe, output should be Maybe
- [x] `timeout` + 3: one marble per Maybe, output should be Maybe
- [x] `timeout(MaybeSource)`: missing diagram
- [x] `timeout(MaybeSource, MaybeSource)`: missing diagram
- [x] `timeout(Publisher)`: missing diagram
- [x] `timeout(Publisher, MaybeSource)`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toObservable`: missing diagram
- [x] `toSingle` + 1: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `zipWith`: one marble per Maybe, output should be Maybe,Here is the Excel file I draw the diagrams in: https://drive.google.com/file/d/1di67kFJEuiLPyq14JlnV3vFl-muaCMfH/view?usp=sharing =||= ,0
6897,5806,3.x: Maybe incorrect or missing marbles (tracking issue),- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(Iterable)`: missing diagram
- [x] `concat(Publisher)`: missing diagram
- [x] `concat(Publisher, int)`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concatArrayDelayError`: indicate error delayed, 1 marble per source
- [x] `concatArrayEager`: missing diagram
- [x] `concatDelayError(Iterable)`: missing diagram
- [x] `concatDelayError(Publisher)`: missing diagram
- [x] `concatDelayError(Publisher, int)`: fix overlap/misalignment inside the operator box
- [x] `concatEager(Iterable)`: missing diagram
- [x] `concatEager(Publisher)`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: indicate callable returns the error
- [x] `fromAction`: missing diagram
- [x] `fromCompletable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture(Future)`: operator name in the box, indicate Future is the parameter
- [x] `fromFuture(Future, long, TimeUnit)`: operator name in the box, indicate Future is the parameter, indicate timeout
- [x] `fromRunnable`: missing diagram
- [x] `merge(Iterable)`: missing diagram
- [x] `merge(Publisher)`: missing diagram
- [x] `merge(Publisher, int)`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `mergeArrayDelayError`: one marble per Maybe source
- [x] `mergeDelayError(Iterable)`: one marble per Maybe source
- [x] `mergeDelayError(Publisher)`: one marble per Maybe source
- [x] `mergeDelayError(Maybe, Maybe, ...)`: one marble per Maybe source
- [x] `sequenceEqual` + 1: result should be `Single`.
- [x] `timer` + 1: result should be Maybe
- [x] `using` + 1: rework to indicate the created Maybe
- [x] `wrap`: missing marble
- [x] `zip(Iterable)`: one marble per Maybe source, result should be Maybe
- [x] `zip(Maybe, Maybe, ...)` + 8: one marble per Maybe source, result should be Maybe
- [x] `zipArray`: one marble per Maybe source, result should be Maybe
- [x] `ambWith`: one marble per Maybe source, result should be Maybe
- [x] ~~`as`: missing diagram~~ operator removed
- [x] `blockingGet` + 1: missing diagram
- [x] `cache`: one marble per Maybe source, result should be Maybe
- [x] `cast`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatMap`: indicate Maybe target, indicate empty source
- [x] `concatWith`: one marble per Maybe source, result should be Maybe, operator name, indicate other is a parameter
- [x] `contains`: one marble per Maybe source, result should be Single, empty case
- [x] `count`: one marble per maybe, operator name, result should be Single, empty case
- [x] `defaultIfEmpty`: non-empty case, result should be Maybe
- [x] `delay(time)` + 3: one marble per Maybe source, result should be Maybe
- [x] `delay(Publisher)`: one marble per Maybe, one signal by the Publisher, empty publisher case
- [x] `delaySubscription(Publisher)`: missing diagram
- [x] `delaySubscription(time)` + 1: one marble per Maybe source, result should be Maybe
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: operator name, one marble per Maybe, result should be Maybe
- [x] `doFinally`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnComplete`: one marble per Maybe, result should be Maybe
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnTerminate`: one marble per Maybe, result should be Maybe
- [x] `filter`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, Function, Callable)`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, BiFunction)`: one marble per Maybe, result should be Maybe
- [x] `flatMapObservable`: should be mapped into an Observable
- [x] `flatMapPublisher`: indicate backpressure
- [x] `flatMapSingle`: indicate empty maybe results in error
- [x] `flatMapSingleElement`: operator name, indicate empty maybe
- [x] `flatMapCompletable`: indicate empty maybe
- [x] `hide`: missing diagram
- [x] `ignoreElement`: operator name, one marble per Maybe, result should be Maybe
- [x] `isEmpty`: result should be Single
- [x] `mergeWith`: operator name, one marble per Maybe, indicate backpressure
- [x] `ofType`: one marble per Maybe
- [x] `onErrorComplete` + 1: missing diagram
- [x] `onErrorResumeNext`: one marble per Maybe, result should be Maybe
- [x] `onErrorResumeWith`: one marble per Maybe, result should be Maybe
- [x] `onErrorReturn`: one marble per Maybe, result should be Maybe, indicate callback
- [x] `onErrorReturnItem`: operator name, one marble per Maybe, result should be Maybe, indicate normal outcome
- [x] ~~`onExceptionResumeNext`: operator takes a Maybe source directlyˇ~~ operator removed
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat` + 1: one marble per source, indicate backpressure, indicate repeat conditions
- [x] `repeatUntil`: operator name, repeat condition, indicate backpressure
- [x] `repeatWhen`: one marble per Maybe, indicate backpressure
- [x] `retry` + 2: one marble per Maybe, result should be Maybe, indicate repeat conditions
- [x] `retry(int, Predicate)`: missing diagram
- [x] `retry(Predicate)`: missing diagram
- [x] `retryUntil`: missing diagram
- [x] `retryWhen`: one marble per Maybe, output should be Maybe
- [x] `switchIfEmpty` + 1: improve diagrams, indicate argument type
- [x] `takeUntil` + 1: one marble per Maybe, output should be Maybe
- [x] `timeout` + 3: one marble per Maybe, output should be Maybe
- [x] `timeout(MaybeSource)`: missing diagram
- [x] `timeout(MaybeSource, MaybeSource)`: missing diagram
- [x] `timeout(Publisher)`: missing diagram
- [x] `timeout(Publisher, MaybeSource)`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toObservable`: missing diagram
- [x] `toSingle` + 1: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `zipWith`: one marble per Maybe, output should be Maybe,Here is the Excel file I draw the diagrams in: https://drive.google.com/file/d/1di67kFJEuiLPyq14JlnV3vFl-muaCMfH/view?usp=sharing =||= ,0
6899,6880,3.x: Add concatEagerDelayError across,`concatEager` [is available](https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#concatEager) but its delay-error variant is missing.,nan,0
6921,692,How to map exceptions?,I have Observable<MyResult> that could produce onError with Exception1. I want to remap it so I can handle Exception1 and rethrow my own Exception2.

What is the proper way to do it?,You need to implement your own Observer and perform the remapping there:

``` java
final Observer<Object> actual = ...
Observable.error(new Exception()).subscribe(new Observer<Object>() {
   public void onNext(Object a) { actual.onNext(a); }
   public void onCompleted() { actual.onCompleted(); }
   public void onError(Throwable e) {
      if (e instanceof Exception) {
         actual.onError(new RuntimeException(e);
      }
   }
});
```

If you need to do this regularly, you can have your own operator for it:

``` java
public class MapException {
    public static <T, E extends Exception> Observable<T> mapException(
        final Observable<T> source, final Func1<? super Throwable, E> errorSelector) {
        return Observable.create(new OnSubscribeFunc<T>() {
            @Override
            public Subscription onSubscribe(final Observer<? super T> t1) {
                Observer<T> o = new Observer<T>() {
                    @Override public void onNext(T args) { t1.onNext(args); }
                    @Override public void onError(Throwable e) {
                       E f;
                        try {
                         f = errorSelector.call(e);
                        } catch (Throwable t) {
                            t1.onError(t);
                            return;
                        }
                        t1.onError(f);
                    }
                    @Override public void onCompleted() { t1.onCompleted(); }
                };
                return source.subscribe(o);
            }
        });
    }
    public static void main(String[] args) throws InterruptedException {
        Func1<Throwable, IOException> ioe = new Func1<Throwable, IOException>() {
            @Override
            public IOException call(Throwable t1) {
                return new IOException(t1.getMessage(), t1.getCause());
            }
        };

        Observable<Integer> source = mapException(concat(from(1, 2, 3), error(
            new RuntimeException("Forced failure!"))), ioe);

        final CountDownLatch latch = new CountDownLatch(1);

        source.subscribe(new Action1<Object>() {
            @Override
            public void call(Object t1) {
                System.out.println(t1);
            }
        }, new Action1<Throwable>() {
            @Override
            public void call(Throwable t1) {
                t1.printStackTrace();
                latch.countDown();
            }
        }, new Action0() {
            @Override
            public void call() {
                latch.countDown();
            }
        });
        latch.await(10, TimeUnit.SECONDS);
    }
}
```
 =||= You can use 'onErrorResumeNext': http://netflix.github.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.util.functions.Func1)

Inside the function perform your conditional logic and return Observables as appropriate, such as using 'Observable.error' with your new Exception. 
 =||= @benjchristensen When I return converted exception it seems some sort of recursion calls are made and I receive my exceptions many times.
 =||= This works for me as expected:

``` java
public class MapException2 {
    public static void main(String[] args) throws InterruptedException {
        Observable<Integer> source = concat(from(1, 2, 3), 
            error(new RuntimeException("Forced failure")));

        Observable<Integer> result = source.onErrorResumeNext(e -> 
            concat(from(4, 5, 6), error(new IOException(e.getMessage(), e.getCause())))
        );

        result.subscribe(System.out::println, Throwable::printStackTrace);

        Thread.sleep(1000);
    }
}
```

prints the numbers 1 - 6 and an IOException stacktrace.
 =||= @akarnokd 

I ran into that problem on RxJava 2.

Could you take a look a this implementation and tell me if this is implemented properly?

```kotlin
class ObservableMapError<T : Any>(private val source: Observable<T>, private val errorMapper: (Throwable) -> Throwable) : Observable<T>() {

  override fun subscribeActual(observer: Observer<in T>) {
    source.subscribe(MapErrorObserver(observer, errorMapper))
  }

  class MapErrorObserver<T : Any>(val actual: Observer<in T>, val errorMapper: (Throwable) -> Throwable) : Observer<T>, Disposable {

    private var source: Disposable? = null

    override fun onSubscribe(s: Disposable) {
      if (DisposableHelper.validate(source, s)) {
        this.source = s
        actual.onSubscribe(this)
      }
    }

    override fun dispose() {
      source!!.dispose()
    }

    override fun isDisposed(): Boolean = source!!.isDisposed

    override fun onNext(t: T) {
      actual.onNext(t)
    }

    override fun onError(t: Throwable) {
      val mapped = errorMapper(t)
      actual.onError(mapped)
    }

    override fun onComplete() {
      actual.onComplete()
    }
  }
}
``` =||= Almost. I wouldn't trust `errorMapper(t)` to not throw thus I'd wrap it into try-catch and call the `actual.onError` with a composite of the original and this latter exception. =||= @akarnokd I ran into same problem on RxJava2 maybe it is worth to add those operators to Single, Observable, Flowable, Completable as official ones? =||= I still don't think so. =||= I did the following:
```
                .onErrorResumeNext { Single.error(Exception()) }
```

Is this something wrong?
 =||= ,0
6935,1881,Scan/Reduce Overloads & Type Erasure,I think the recent additions to `scan`/`reduce` may cause issues

``` java
scan(R, Func2<R, ? super T, R>)
scan(Func0<R>, Func2<R, ? super T, R>)
```

The `Func0` passed in looks like it can be treated like an `Object` and considered ambiguous and match with `R` instead of `Func0`.

Here is a compilation error:

```
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project learnrxjava: Compilation failure: Compilation failure:
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[10,32] reference to reduce is ambiguous
[ERROR] both method <R>reduce(R,rx.functions.Func2<R,? super T,R>) in rx.Observable and method <R>reduce(rx.functions.Func0<R>,rx.functions.Func2<R,? super T,R>) in rx.Observable match
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[10,39] incompatible types: cannot infer type-variable(s) R
[ERROR] (argument mismatch; java.lang.Object is not a functional interface)
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[17,32] reference to scan is ambiguous
[ERROR] both method <R>scan(R,rx.functions.Func2<R,? super T,R>) in rx.Observable and method <R>scan(rx.functions.Func0<R>,rx.functions.Func2<R,? super T,R>) in rx.Observable match
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[17,37] incompatible types: cannot infer type-variable(s) R
[ERROR] (argument mismatch; java.lang.Object is not a functional interface)
[ERROR] -> [Help 1]
```

Here is example code: https://github.com/jhusain/learnrxjava/blob/master/src/main/java/learnrxjava/examples/ScanVsReduceExample.java

``` java
package learnrxjava.examples;

import java.util.ArrayList;

import rx.Observable;

public class ScanVsReduceExample {

    public static void main(String... args) {
        Observable.range(0, 10).reduce(() -> new ArrayList<Integer>(), (list, i) -> {
            list.add(i);
            return list;
        }).forEach(System.out::println);

        System.out.println("... vs ...");

        Observable.range(0, 10).scan(() -> new ArrayList<Integer>(), (list, i) -> {
            list.add(i);
            return list;
        }).forEach(System.out::println);
    }
}
```

It looks like we need to do one of 3 things:

1) Remove one of several things:

``` java
scan(R, Func2<R, ? super T, R>)
scan(Func0<R>, Func2<R, ? super T, R>)
```

2) Rename one of them

3) Add an extra argument so arity solves it.

I actually think the most correct thing to do is remove `scan(R, Func2<R, ? super T, R>)` since an initial value is most often intended for mutable state in `scan`/`reduce`. 

cc @headinthebox as this is a last minute API fix we need prior to Monday for 1.0,I'd be happy with `Func<0>` as the only way, but then we have to do the same for `reduce` and anything else that takes a seed.
 =||= BTW, if we do this, then we should consider generalizing to returning `S` since we are side-effecting `R`, so it does not matter to return return the mutable state variable since that is passed in by the implementation.

`scan(Func0<R>, Func2<R, ? super T, S>)`
 =||= I have submitted #1883 to fix the ambiguity that happens with lambdas. 

I have changed `scan`, `reduce` and `collect`. I don't see anywhere else that needs to change.
 =||= I'm going to pull the factory overload until 1.1 so we make sure we get this right. 
 =||= Fixed in #1884 by deleting the ambiguous new factory overloads for `scan` and `reduce` and modifying `collect` to support the mutable case with a seed factory and side-affection action.
 =||= ,0
6935,1878,defaultIfEmpty(Observable<T> t),Went to use `defaultIfEmpty` and found it only accepts a single value .... instead of an `Observable` which means I can't pass in an `Observable.error`.

It would be very helpful to have `defaultIfEmpty(Observable<T> t)`,+1. Then `tail` in RxScala can be implemented by `o.defaultIfEmpty(Observable.error(new UnsupportedOperationException("tail of empty list"))).drop(1)`
 =||= Maybe `switchIfEmpty` would be a better name.
 =||= ,0
6935,1858,Zip all overloads,zip(java.lang.Iterable<? extends Observable<?>> ws, FuncN<? extends R> zipFunction)
Returns an Observable that emits the results of a **function of your choosing**

function of your choosing ==> combiner function,nan,0
6935,1868,Improve Lifecycle Docs,Based on a Twitter conversation we may need to improve docs around lifecycle: https://twitter.com/benjchristensen/status/532570727111983104,For future reference:
https://twitter.com/benjchristensen/status/532559357851226112

On Wed, Nov 12, 2014 at 8:31 AM, Ben Christensen notifications@github.com
wrote:

> Based on a Twitter conversation we may need to improve docs around
> lifecycle:
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1868.

## 

David M. Gross
PLP Consulting
 =||= Closing for now as it is not clear what lifecycle docs is this about. =||= ,0
6935,1867,usage of 2 buffers with both a timespan and a count,The usage of 2 RxJava buffers with both a timespan and a count will eventually make the events be emitted at a very slow rate to the subscriber.
The observed rate will be as slow as 1 item per whatever is the second buffer timespan.

Please see the following Gist for the JUnit code demonstrating the issue.
https://gist.github.com/YannRobert/32921e8e88c62c5af1f9,Putting on 1.0.x though we might be able to get this in for 1.0.

Thank you for the report and sample code. 
 =||= fixed in 1.0.0-RC12
 =||= ,0
6935,1862,Backpressure suppport for Window by size,For #1828. Extracted Producers from OperatorBufferWithSize and reused them in OperatorWindowWithSize.,nan,0
6935,1881,Scan/Reduce Overloads & Type Erasure,I think the recent additions to `scan`/`reduce` may cause issues

``` java
scan(R, Func2<R, ? super T, R>)
scan(Func0<R>, Func2<R, ? super T, R>)
```

The `Func0` passed in looks like it can be treated like an `Object` and considered ambiguous and match with `R` instead of `Func0`.

Here is a compilation error:

```
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project learnrxjava: Compilation failure: Compilation failure:
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[10,32] reference to reduce is ambiguous
[ERROR] both method <R>reduce(R,rx.functions.Func2<R,? super T,R>) in rx.Observable and method <R>reduce(rx.functions.Func0<R>,rx.functions.Func2<R,? super T,R>) in rx.Observable match
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[10,39] incompatible types: cannot infer type-variable(s) R
[ERROR] (argument mismatch; java.lang.Object is not a functional interface)
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[17,32] reference to scan is ambiguous
[ERROR] both method <R>scan(R,rx.functions.Func2<R,? super T,R>) in rx.Observable and method <R>scan(rx.functions.Func0<R>,rx.functions.Func2<R,? super T,R>) in rx.Observable match
[ERROR] /Users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/ScanVsReduceExample.java:[17,37] incompatible types: cannot infer type-variable(s) R
[ERROR] (argument mismatch; java.lang.Object is not a functional interface)
[ERROR] -> [Help 1]
```

Here is example code: https://github.com/jhusain/learnrxjava/blob/master/src/main/java/learnrxjava/examples/ScanVsReduceExample.java

``` java
package learnrxjava.examples;

import java.util.ArrayList;

import rx.Observable;

public class ScanVsReduceExample {

    public static void main(String... args) {
        Observable.range(0, 10).reduce(() -> new ArrayList<Integer>(), (list, i) -> {
            list.add(i);
            return list;
        }).forEach(System.out::println);

        System.out.println("... vs ...");

        Observable.range(0, 10).scan(() -> new ArrayList<Integer>(), (list, i) -> {
            list.add(i);
            return list;
        }).forEach(System.out::println);
    }
}
```

It looks like we need to do one of 3 things:

1) Remove one of several things:

``` java
scan(R, Func2<R, ? super T, R>)
scan(Func0<R>, Func2<R, ? super T, R>)
```

2) Rename one of them

3) Add an extra argument so arity solves it.

I actually think the most correct thing to do is remove `scan(R, Func2<R, ? super T, R>)` since an initial value is most often intended for mutable state in `scan`/`reduce`. 

cc @headinthebox as this is a last minute API fix we need prior to Monday for 1.0,I'd be happy with `Func<0>` as the only way, but then we have to do the same for `reduce` and anything else that takes a seed.
 =||= BTW, if we do this, then we should consider generalizing to returning `S` since we are side-effecting `R`, so it does not matter to return return the mutable state variable since that is passed in by the implementation.

`scan(Func0<R>, Func2<R, ? super T, S>)`
 =||= I have submitted #1883 to fix the ambiguity that happens with lambdas. 

I have changed `scan`, `reduce` and `collect`. I don't see anywhere else that needs to change.
 =||= I'm going to pull the factory overload until 1.1 so we make sure we get this right. 
 =||= Fixed in #1884 by deleting the ambiguous new factory overloads for `scan` and `reduce` and modifying `collect` to support the mutable case with a seed factory and side-affection action.
 =||= ,0
6935,1858,Zip all overloads,zip(java.lang.Iterable<? extends Observable<?>> ws, FuncN<? extends R> zipFunction)
Returns an Observable that emits the results of a **function of your choosing**

function of your choosing ==> combiner function,nan,0
6944,6883,3.x: Marbles should have a proper background,The transparent ones look terrible with dark-themed IDEs or non-light background:

![image](https://user-images.githubusercontent.com/1269832/73169180-d69ffe80-40fb-11ea-9893-ba14ca1a2bee.png)

Only looks fine in Eclipse:

![image](https://user-images.githubusercontent.com/1269832/73169164-ce47c380-40fb-11ea-97f7-52157da366e4.png)

Write a program that goes through the images in `https://github.com/ReactiveX/RxJava.wiki.git` `images/rx-operators`, checks if the image has transparency, draw it onto a white background then save it as `originalName.v3.png` (because some of those are linked all around). Find the filename in the source code and replace them.,I'd like to do this if it's fine. =||= @tomislavhofman Sure! =||= While we're waiting for my internet to do the heavy lifting

Here are some fun facts:

- There were 749 images with transparent background ( which now have corresponding .v3.png with white background )

- RxJava project contains 45 .md files and 1855 .java files

- A total of 842 occurrences of transparent .pngs has been found across 18 files in total ( 5 located in /docs/ and 13 in /src/ )
    1. First place, Flowable.java and 373 changes
    2. Trailing second, Observable.java with 351 changes
    3. Third place has been taken by Single.java which was updated in 72 places.

Here's a very bare and unsorted log of changes made to RxJava source code https://pastebin.com/qMvUFc1n

- [x] Images with white background
- [x] Found and replaced in source code


On a side note, if my 2nd attempt to push the wiki changes onto my fork fails. Would you be okay with me uploading just the updated images somewhere and you can update the wiki yourself? It's a difference between 100ish MB and 1GB.
<img width="688" alt="Screenshot 2020-04-02 at 11 32 53" src="https://user-images.githubusercontent.com/19726609/78233241-b9115b80-74d5-11ea-81c8-89a59320ae50.png"> 😶

If that doesn't work for you I'll just try again.

Once the wiki files are updated I'll submit the pull request for links updates. =||= You won't be able to push to the wiki or create a PR for the wiki part. Can you upload the files into this issue via attachment(s)? =||= Oh, and I thought I was being clever by researching and discovering how to make a PR to github wiki...

I'll attach the files below =||= Okay, I've uploaded all 749 images to a comment in this thread which I haven't posted yet...

How should I approach posting them, I'm a bit confused here, it is a lot of images.

**edit:** should I strip the image tag and post urls only? =||= No no. Zip about ~100 images~ at once and then attach each of them to a comment.

Edit, looks like the limit is 10 MB only. =||= How about you upload the code that does the image transformation? =||= ```Java
    private static void makeNonTransparentCopyOfImages(final List<File> files, final File outputFolder) {
        int index = 0;
        for (final File file : files) {
            if (!file.getName().contains(".png")) {
                continue;
            }
            try {
                BufferedImage image = ImageIO.read(file);
                int width = image.getWidth();
                int height = image.getHeight();
                if (image.getColorModel().hasAlpha()) {
                    BufferedImage background = new BufferedImage(width, height, image.getType());
                    Graphics2D g2 = background.createGraphics();
                    g2.setColor(Color.WHITE);
                    g2.fillRect(0, 0, width, height);
                    BufferedImage combined = new BufferedImage(width, height, image.getType());
                    Graphics g = combined.getGraphics();
                    g.drawImage(background, 0, 0, null);
                    g.drawImage(image, 0, 0, null);
                    ImageIO.write(combined, "PNG", new File(outputFolder, file.getName().replace(".png", ".v3.png")));
                } else {
                    System.out.println("Non transparent image: " + index + " - " + file.getName());
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            index++;
        }
    }
``` =||= Created PR (#6944) which should be safe to merge once images have been uploaded. =||= ,0
6956,695,API Design Review,My thoughts on the API Design Review. Try to be faithful to the MS implementation much as possible where feasible. Any enhancements can also live along side the core implementation. 

With other language bindings also coming from MS, it is good that there are consistency among the implementations.

So idiomatic Rx comes before any other implementations. Idiomatic \* can core exist along side the standard Rx usage.,/cc @headinthebox @jhusain @mattpodwysocki
 =||= > Try to be faithful to the MS implementation much as possible where feasible

Of course.
 =||= ,0
6960,6947,2.x: open for grabs: backport #6946,Fix for the scalar-queue max-concurrency issue already fixed for 3.x in #6946.,nan,0
6969,696,New contrib module: rxjava-async-util,Home for async utility functions with juc.Future, Actions, Functions etc that don’t need to be in rxjava-core.

As per discussions at:
- https://github.com/Netflix/RxJava/pull/646#issuecomment-31147005
- https://github.com/Netflix/RxJava/pull/645#issuecomment-31146492
- https://github.com/Netflix/RxJava/pull/622#issuecomment-31144128

/cc @akarnokd,@akarnokd Do you want to extend this branch and merge the various PRs in to it that belong here?

If you don't like the name go ahead and propose something, I couldn't think of anything better but only spent a couple minutes on this.

I want something generic enough to cover the various utilities. At the same time I feel this name may be too broad as these utilities may not apply at all to other JVM languages, but that's probably fine as that's why it's a contrib module.
 =||= [RxJava-pull-requests #613](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/613/) FAILURE
Looks like there's a problem with this pull request
 =||= Thanks @benjchristensen the name is okay. I'll update and resubmit the relevant PRs. Should `Observable.from(Future)` and its overloads from before be moved into this module?
 =||= Leave `Observable.from(Future)` in `Observable` for now. We'll need to do a deprecation process on those if we remove them.
 =||= I'm closing this PR as you will take my branch and re-submit a new one.
 =||= I'm sorry I don't quite understand. I check out your branch then, once all ops are added, I submit a PR against RXJava/master?
 =||= Yes.
 =||= ,0
6996,6987,3.x: Suppress undeliverables in some tests,Some tests trigger a lot of undeliverable exceptions flooding the console output. Example:

```
at io.reactivex.rxjava3.internal.subscribers.FutureSubscriberTest
    .onErrorCancelRace(FutureSubscriberTest.java:178)

at io.reactivex.rxjava3.internal.operators.observable.ObservableWindowWithObservableTest
    .disposeMainBoundaryErrorRace(ObservableWindowWithObservableTest.java:590)
```

These are generally irrelevant from those particular tests and should be safely ignored. The difficulty is, locating these tests if the console doesn't retain too many lines.

To resolve the issue, perhaps the easiest way is to write a `TestHelper.withUndeliverableSuppressed(Action)` method and keep wrapping the problematic test bodies.,nan,0
7027,1013,[scala] PublishSubject is inaccessible,``` scala
private [scala] object PublishSubject {
  def apply[T](): PublishSubject[T] =  new PublishSubject[T](rx.subjects.PublishSubject.create[T]())
}
```

There's no way to create it. I believe this object should be public?,Publish subject is the default subject and can be accessed via:

```
rx.lang.scala.Subject
```

See: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subject.scala
 =||= Still, what is the point of preventing access?

On April 12, 2014 11:38:22 AM EEST, Ross Lawley notifications@github.com wrote:

> Publish subject is the default subject and can be accessed via:
> 
>    rx.lang.scala.Subject
> 
> See:
> https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subject.scala
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Netflix/RxJava/issues/1013#issuecomment-40275240

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.
 =||= Access is not at all prevented, just a different name, leveraging the fact that Scala has traits; in .NET: ISubject --> Subject, in RxJava: Subject --> PublishSubject, in Scala: Subject. 
 =||= It is not prevented per se, but is awfully counterintuitive. I looked up the appropriate subject type from github docs, try to create it and can't while all the other type of subjects can be instantiated.

And I don't see how this serves any purpose. Lets say PublishSubject can be instantiated via its object and not Subject object. What is the downside of that?

The downside of current situation is that you get confused people like me. I guess there should be an upside to that as well, but I don't see it. Could you point it out?

On April 12, 2014 12:28:12 PM EEST, headinthebox notifications@github.com wrote:

> Access is not at all prevented, just a different name, leveraging the
> fact that Scala has traits; in .NET: ISubject --> Subject, in RxJava:
> Subject --> PublishSubject, in Scala: Subject. 
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Netflix/RxJava/issues/1013#issuecomment-40276043

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.
 =||= One type instead of two. Less is better. Same for Subscriptions. The fact that we are forced to call Subject "PublishSubject" in RxJava is just horrible. Names are the most precious resource in designing APIs.
 =||= Ok, it's your project so it's your call.

However the least that can be done is a comment in code and docs that in scala PublishSubject needs to be instantiated via Subject.

Do you agree?

On April 12, 2014 12:54:37 PM EEST, headinthebox notifications@github.com wrote:

> One type instead of two. Less is better. Same for Subscriptions. The
> fact that we are forced to call Subject "PublishSubject" in RxJava is
> just horrible. Names are the most precious resource in designing APIs.
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Netflix/RxJava/issues/1013#issuecomment-40276479

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.
 =||= Makes sense; but IMHO ideally, you should consider the Scala API by itself, not mirroring it to the RxJava one. Same for all other languages such as Rx .NET, RxJS, ... What is called Foo there can be called Baz here. Case in point Select <-> map, or Where <-> filter, or Subject <-> PublishSubject.  
 =||= Yes, but I tried to find scala docs for subjects and couldn't find them.

If they exist they need better visibility. Perhaps a link in the wiki near each section?

On April 12, 2014 1:48:29 PM EEST, headinthebox notifications@github.com wrote:

> Makes sense; but IMHO ideally, you should consider the Scala API by
> itself, not mirroring it to the RxJava one. Same for all other
> languages such as Rx .NET, RxJS, ... What is called Foo there can be
> called Baz here. Case in point Select <-> map, or Where <-> filter, or
> Subject <-> PublishSubject.  
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Netflix/RxJava/issues/1013#issuecomment-40277392

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.
 =||= I agree with @arturaz, I didn't find anything that would imply that `Subject` -> `PublishSubject`. I'm not a Scala architecture expert so I can't provide much input in that respect, all I can say is, from a user standpoint, it was a bit confusing seeing that all the other `Subject`s had public access while `PublishSubject` didn't. I guess I could've looked in the scala package instead of the scala.subjects package. Just my $0.02.
 =||= Done in https://github.com/Netflix/RxJava/pull/1216
 =||= ,0
7027,1958,sample/throttleLast doesn't call unsubscribe,In the following code, I would expect the "cleanup" message to be printed three times, but on the last case (o1.throttleLast(...)) it isn't.

``` groovy
 def o = rx.Observable.create({ subscriber ->
        subscriber.add(Subscriptions.create({ println "cleanup" }))
    })

    o.subscribe({})
        .unsubscribe() // prints

    o.take(1)
        .subscribe({})
        .unsubscribe();  // prints

    o.throttleLast(1, TimeUnit.MILLISECONDS)
        .subscribe({})
        .unsubscribe() // doesn't print
```

Reported by juanedi in http://stackoverflow.com/questions/27428757/unsubscriptions-not-cascading-back-to-base-observable-in-rxjava,nan,0
7027,1949,MissingBackpressureException,when i create  an Observable like this,i always get 'MissingBackpressureException'.
and that method works well on '0.19.6'

```
@Override
    public Observable<Object> getXXX() {
        return Observable.create(new Observable.OnSubscribe<Object>() {
            @Override
            public void call(Subscriber<? super Object> subscriber) {
                try {
                   for(int i;i<100;i++){
                    subscriber.onNext(null);
                  }
                    subscriber.onCompleted();
                } catch (Exception e) {
                    subscriber.onError(e);
                }
            }
        }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());
    }
```,You have a fast producer (the Observable) which is decoupled, due to the `subscribeOn`/`observeOn` operators, from a relatively slow consumer (the Observer). Also, your Observable doesn't support backpressure, hence the `MissingBackpressureException`. 

You should either change your Observable to support backpressure, or add operators to calm down the producer. The [wiki](https://github.com/ReactiveX/RxJava/wiki/Backpressure) shows some techniques to accomplish this.
 =||= so, i can not to improve it with Backpressure Subscriber?
 =||= What do you mean by Backpressure Subscriber?
 =||= Since you mention that your code worked fine with Rx version `0.19.6` (which didn't have backpressure support yet), you should be able to go back to the old situation by adding the `onBackpressureBuffer` operator after the `Observable.create`.
 =||= @GeorgiKhomeriki   thx, i got it.
@benjchristensen  thx,  i mean to implement an subscriber  witch can request reactive pull backpressure.
Sorry,i didnt fully understand the ‘backpressure’.
 =||= Yes, you'll want to implement a subscriber that uses `request` but the source needs to support it. The `onBackpressure*` operators are there to add strategies to sources that don't natively support reactive pull.
 =||= ,0
7027,1948,Prevent livelock on Scheduler?,Hi folks,

we are observing an interesting phenomenon in the wild: imagine code like this:

``` java
        openBucket(bk1)
            .upsert(doc)
            .flatMap(jsonStringDocument ->
                openBucket(bk2).upsert(doc))
            .timeout(timeOut, TimeUnit.SECONDS)
            .toBlocking()
            .single();
```

It's not so important what it does (opening a database, writing a doc, when this is finished opening another db nested and writing another document).

The problem is that in the flatMap, and inside the openBucket, we're pushing both on the same computation scheduler, which leads to a livelock and a timeout eventually. We found that if we have less than 4 computation threads this shows up, might be coincidence.

So the question is: is there a way to avoid that livelock case? Because technically even if the user uses .observeOn() he would need to move it off the computation scheduler?

To me, it looks like the opeBucket task is queued up behind the flatMap task, but of course it never gets done. Note that there are some other computation threads idling around.,forget it folks, problem solved ;)
 =||= though shall not block on the computation pool!
 =||= > though shall not block on the computation pool!

:-)
 =||= ,0
7027,1945,Fix the 'isUnsubscribed' issue for Subscrptions.empty(),As per #1943,Test?
 =||= > Test?

Done
 =||= ,0
7027,1942,OperatorMerge does not request enough #1941,Looks to me that an inner request count is needed and tracked so that more can be requested from the inner observable if required. Review from anyone familiar with `OperatorMerge` very welcome as I'm not that familiar with its current incarnation and it's a tricky place!

Just one unit test included but I imagine more would be nice.,ci build failure looks to be unrelated: #1703 
 =||= more changes to come on this and I think I can make the unit test deterministically fail on the existing code base. 
 =||= abandoning this PR because requests to the InnerSubscriber must be coordinated by the MergeSubscriber.
 =||= ,0
7027,1940,ReplaySubject race condition: subscribers not always triggered?,_Assumptions_
Based on my casual look at the ReplaySubject source (namely, the obvious traces of thread safety in the implementations of the two fields in ReplaySubject) and the existence of tests like https://github.com/ReactiveX/RxJava/blob/1.x/src/test/java/rx/subjects/ReplaySubjectConcurrencyTest.java, it looks like ReplaySubject is designed to be thread safe.

_What I'm doing_
Concurrently adding a subscription to a `ReplaySubject` and supplying a value to it with `onNext` when `subscribeOn(schedulerThatUsesAnotherThread)` is in effect. See the two test methods in repro test case at https://bitbucket.org/marshallpierce/rxjava-replaysubject-race for cases with and without `subscribeOn`.

_Expected behavior_
The provided `Action0` should always have `onNext` invoked regardless of how it was scheduled. Even if the scheduling ends up happening after the subject's `onNext` is called, my understanding of `ReplaySubject` is that the point is that it should always replay everything regardless of when the subscription happens.

_Observed behavior_
Every once in a while (a few times out of thousands), the subscriber does _not_ get called.

Am I not using the API correctly, or is ReplaySubject always supposed to replay everything to all subscribers regardless of concurrency when subscribing / providing values?,Hello! Let me answer your question since I'm the author-ity on the subject (pun intended :).

What happens is that since the actual subscription happens on a different thread, that thread might be delayed for some reason and the latch releasing the subj.onNext emission might happen just before the observer becomes visible to the subject. Now unfortunately we don't have an operator that calls you back after the subscription happened (doOnSubscribe calls you before), just debug hooks which affect all subscribe() calls. However, you can implement your custom operator:

``` java
class OnSubscribeAfter<T> implements OnSubscribe<T> {
    final Observable<T> source;
    final Action0 subscribeHappened;
    public OnSubscribeAfter(Observable<T> source, Action0 subscribeHappened) {
        this.source = source;
        this.subscribeHappened = subscribeHappened;
    }
    @Override 
    public void call(Subscriber<? super T> child) {
        source.subscribe(child);
        subscribeHappened.call();
    }
}

Observable.create(new OnSubscribeAfter<>(subj, () -> { latch.countDown(); }))
.subscribeOn(...).observeOn().etc
```

Note that it must be placed before any subscribeOn call.
 =||= Thanks for the clarification. Am I missing something about ReplaySubject, though? Isn't the point that it plays back everything, even emissions that happened before you added a subscription? Seems to me that regardless of who wins the race to subscribe first or emit data first, the subscriber should fire either because it was subscribed temporally before the emission or because ReplaySubject replayed it.
 =||= You are right, there is a small race between the emission and the subscription: the emission gets into the buffer but a concurrent subscription might not pick that value up before it becomes visible to the subject. In that case, only the second emission triggers the delivery of the first. I'll work on the fix.

Edit: BehaviorSubject works as expected.
 =||= Hello. The fix for this bug should be in 1.0.4. Can you confirm it works for you?
 =||= Yep, my tests pass now. Thanks!
 =||= ,0
7027,1934,Request hook,Adding the ability to track `request(n)` events with the RxJavaDebug hooks.
And a fix for #1933,There is a subtle anomaly regarding sending onCompleted after unsubscription when window(), take and merge() is used because a terminating upstream will never send onCompleted so the merge itself will never complete. See #1880. So since by contract unsubscription is best effort, receiving a few events after the fact is perfectly okay and the relevant operators such as take will take the necessary steps to not let things slip by.

I also wanted to mention that maybe a diagnostic operator would be better: you could then check request behavior at specific locations and not deal with all irrelevant rest.
 =||= @akarnokd this is a completely synchronous test case so the best effort should be the expected behavior.  Point operators are great when you already know where the problem is.
 =||= ,0
7027,1931,AbstractOnSubscribe to help implement backpressure-respecting,observables.

Proposed implementation for #1930. See tests for use cases.,Great stuff! I knocked up some backpressure support a couple of days ago for RxJavaString and was quite bothered by the DRY aspect. This will make implementing `OnSubscribe` way easier let alone getting backpressure support for free. Thanks!
 =||= Just so I remember, an unrelated test failure:

rx.schedulers.TrampolineSchedulerTest > testSequenceOfDelayedActions FAILED
    org.mockito.exceptions.verification.VerificationInOrderFailure: 
    Verification in order failure
    Wanted but not invoked:
    action0.call();
    -> at rx.schedulers.AbstractSchedulerTests.testSequenceOfDelayedActions(AbstractSchedulerTests.java:220)
    Wanted anywhere AFTER following interaction:
    action0.call();
    -> at rx.schedulers.SleepingAction.call(SleepingAction.java:53)

I wonder if this is the queue capacity bug of the JCTools queues we adapted.
 =||= Few enhancement options:
- SubscriptionState could be a producer as well, no need for separate class.
- there is no point in refcounting a null custom state and thus overhead could be reduced.

In addition, there is a potential bug when a next call doesn't produce an event nor does it unsubscribe. With backpressure present, this may stop producing altogether; without backpressure, it may loop indefinitely. This comes up whne phasing is needed by the state machine the programmer implements. So either we detect phase change but no events, we just loop again; or we throw an exception stating the lack of event emissions or explicit unsubscription.
 =||= Can you give an example for the method

`AbstractOnSubscribe.onSubscribe(Subscriber<? super T> subscriber)`

where an overriding implementation uses the subscriber?
 =||= The subscriber is not accessible in next by default to make sure developers only interact with the abstraction, but there might be a case you somehow need the Subscriber, or you need to add some things to unsubscribe if downstream unsubscribes. That might be a Scheduler.Worker, another Subscriber to another Observable. Now with the lambda convenience cases, I just forgot about this by accident. I'll make the fixes in a day.
 =||= Re the potential bug, what about making `next` even simpler by not including a reference to the subscriber (or the abstraction) at all:

``` java
Optional<T> next(S state);
```

The `Iterable<T>` use case would look like:

``` java
@Override
public Optional<T> next(Iterator<T> state) {
    if (state.hasNext())
        return Optional.of(state.next());
    else 
       return Optional.absent();
}
```
 =||= Had another look at your use cases and I see that we would have less flexibility like with calling `onComplete` straight after the `it.next` call in your `Iterator<T>` example. Nevertheless it might be an attractive simplification in a class like `AbstractOnSubscribeSimple`.
 =||= AbstractIterable doesn't seem to give the possibility to have custom state per iterator() calls, so I wanted to work around that. Your iterator example has some limitations, namely you can only produce one response per call and you need to wrap/unwrap things which leads to really unnecessary GC.

What I've said about free backpressure with AbstractIterable is still true. If you can express your iterative computation with it, then there is no need to use AOS.
 =||= This looks really useful, and the docs in the code are great. 

Would you mind rebasing the commits since this is brand new stuff and could be cleanly committed as a single commit?

Thank you for marking it as Experimental as it would be good to get feedback and allow changes before we commit to it.

Is there anything we can learn from generators? (see https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/generators.md)

/cc @headinthebox as I think it would be good to have your input on this. 
 =||= On my TODO!
 =||= Please ignore my previous comments. I just misunderstood the meaning of `phase`.
 =||= > Is there anything we can learn from generators?

Without language support, you are at a loss.
 =||= Seems like a useful addition; I agree about making it available as experimental so we can evolve it.
 =||= > Without language support, you are at a loss.

I know we can't do what real generator implementations do with `yield`. Are the signatures of generators completely affected by the use of `yield` and thus not at all useful to this exploration?
 =||= > Seems like a useful addition; I agree about making it available as experimental so we can evolve it.

Good, glad there is alignment. I'm going to merge #1946 so we can start using and iterating. 
 =||= ,0
7027,1923,onErrorResumeNext should continue regardless of completion,Isn't onErrorResumeNext supposed to continue to the next observable regardless of wether the first one terminates with completion or error?

According to the Rx.NET docs: http://msdn.microsoft.com/en-us/library/hh229821(v=vs.103).aspx
"Continues an observable sequence that is terminated normally or by an exception with the next observable sequence."

Is this a bug or is it by design? If so, are there any equivalents to this behaviour in RxJava?,@mariusgreve I'm not sure what you are referring to exactly. Once the source emits an onError event, it is not allowed to emit anything else by Rx contract. So the resuming would start fresh from a downstream perspective, but the originating observable still failed. You can only make it emit items again if you resubscribe.

Do you have an example that you'd like to see work?
 =||= @daschl Please see the explanation here: http://www.introtorx.com/content/v1.0.10621.0/11_AdvancedErrorHandling.html#OnErrorResumeNext

Let's say you have this:

```
Observable.create(new Observable.OnSubscribe<String>() {
    @Override
    public void call(Subscriber<? super String> subscriber) {
        subscriber.onNext("One");
        subscriber.onCompleted();
    }
}).onErrorResumeNext(Observable.create(new Observable.OnSubscribe<String>() {
    @Override
    public void call(Subscriber<? super String> subscriber) {
        subscriber.onNext("Two");
        subscriber.onCompleted();
    }
})).subscribe(new Observer<String>() {
    @Override
    public void onCompleted() {
        System.out.println("onCompleted");
    }

    @Override
    public void onError(Throwable e) {
        System.out.println("onError");
    }

    @Override
    public void onNext(String s) {
        System.out.println("onNext: " + s);
    }
});
```

This will then print

```
onNext: One
onCompleted
```

But I want it to continue to the next one and also print `onNext: Two` in the same way it would have with `concatWith`.

If I change line 5 to `subscriber.onError(null);` it will continue to the next one and print

```
onNext: One
onNext: Two
onCompleted
```

as expected.

According to the documentation for Rx.NET it should've printed both `onNext: One` and `onNext: Two` in both cases.
 =||= It's because Rx.Net defined `onErrorResumeNext` in a very odd way that is contrary to its name.

It says "resumeNext" with a given `Observable` when "onError" is invoked, yet that's not what it does.

These kinds of contradictions amongst others were fixed in RxJava. Another example is how Rx.Net uses `throttle` to mean `debounce` which is greatly confusing. 

You can use `onErrorResumeNext` + `concatWith` to swallow errors and concat:

``` java
        Observable.create(new Observable.OnSubscribe<String>() {
            @Override
            public void call(Subscriber<? super String> subscriber) {
                subscriber.onNext("One");
                subscriber.onCompleted();
            }
        })
        .onErrorResumeNext(Observable.empty())
        .concatWith(Observable.just("Two"))
        .subscribe(new Observer<String>() {
            @Override
            public void onCompleted() {
                System.out.println("onCompleted");
            }

            @Override
            public void onError(Throwable e) {
                System.out.println("onError");
            }

            @Override
            public void onNext(String s) {
                System.out.println("onNext: " + s);
            }
        });
```
 =||= @benjchristensen Thank you for clarifying. So it's by design in RxJava then, which makes more sense given the name.

Your example is exactly what I was after!
 =||= ,0
7027,1908,Pursue Elimination of RingBuffer Pooling,The use of object pooling significantly complicates the `unsubscribe` behavior and when it is safe to release. This issue is to track research on how we can eliminate pooling to improve or fix correctness while still maintaining good performance (and memory allocation and GC behavior).

The `merge` and `observeOn` use cases are good to track performance and already have JMH benchmarks in place. 

Here is how to run the tests:

```
./gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*OperatorMergePerf.*'
./gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*OperatorObserveOnPerf.*'
```

Here are results for `merge` and `observeOn` comparing use of pooled `SpmcArrayQueue` vs `SynchronizedQueue` (a synchronized LinkedList).

The `**` markers indicate where performance degradation happened.

```
Merge

Benchmark                                          (size)   Mode   Samples   RingBuffer  ||   LinkedList
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5448592.507  ||  5332264.735    5358807.217
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    54425.611  ||    52385.763      52409.485
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       52.477  ||       53.928         54.128
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    92792.488  ||   103554.112     104711.192
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.957  ||        4.194          4.143
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4608856.070  ||  4294087.613    4688656.691
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   431920.261  ||   451007.165     333391.274**
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    52309.410  ||    49952.664      50057.346
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5815289.623  ||  5558593.305    5575812.189
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       52.525  ||       49.788         49.567
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    77640.706  ||    79530.128      79472.088
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3000.748  ||     2358.716**     2397.035**
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5397752.619  ||  5282943.171    5361848.221
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    29257.005  ||    34150.793      35196.066
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.506  ||       25.827**       26.517**
```

```
ObserveOn

Benchmark                                         (size)   Mode   Samples   RingBuffer  ||    LinkedList       LinkedList
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5   109192.288  ||    111037.202       110112.152
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     6952.955  ||      2846.331**       2821.400**
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       12.267  ||         9.988**         10.063**
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 16430666.170  ||  16284869.881     16504292.796
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   153431.778  ||    158892.599       157288.399
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      150.061  ||       159.481          149.546
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    16899.056  ||     16111.396        16532.411
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     7262.566  ||      5742.547**       5504.293**
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       13.520  ||        10.364**          9.954**
```

The `SynchronizedQueue` was only ever intended for use by environments without `sun.misc.Unsafe` (such as Android) so it is worth exploring other alternatives that don't involve a ring buffer (and allocation overhead) but are thread-safe for the single-produce-multi-consumer use cases the RxRingBuffer is used in (and then rename to RxQueue or something like that).,Possible linked list implementations:
- https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/MpscLinkedQueue.java
- https://github.com/JCTools/JCTools/issues/39
 =||= Here are some tests with `MpscLinkedQueue` and `SpscLinkedQueue` with `merge` and `observeOn`.

```
Merge

Benchmark                                          (size)   Mode   Samples  SpmcArrayQueue  ||     Synchronized LinkedList    ||  MpscLinkedQueue7^
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5     5448592.507  ||  5332264.735    5358807.217    ||       5280793.113
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5       54425.611  ||    52385.763      52409.485    ||         51982.505
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5          52.477  ||       53.928         54.128    ||            59.971
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5       92792.488  ||   103554.112     104711.192    ||        104769.406
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5           4.957  ||        4.194          4.143    ||             4.750
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5     4608856.070  ||  4294087.613    4688656.691    ||       4274735.897
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5      431920.261  ||   451007.165     333391.274**  ||        440251.858
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5       52309.410  ||    49952.664      50057.346    ||         49188.282
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5     5815289.623  ||  5558593.305    5575812.189    ||       5576949.872
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5          52.525  ||       49.788         49.567    ||            51.102
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5       77640.706  ||    79530.128      79472.088    ||         75433.006
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5        3000.748  ||     2358.716**     2397.035**  ||          2881.911
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5     5397752.619  ||  5282943.171    5361848.221    ||       5445358.040
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5       29257.005  ||    34150.793      35196.066    ||         34305.563
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5          35.506  ||       25.827**       26.517**  ||            33.594

^MpscLinkedQueue7 => This can be used by merge and observeOn.  Currently unbounded and needs to be bounded.



ObserveOn


Benchmark                                         (size)   Mode   Samples SpmcArrayQueue  ||        Synchronized LinkedList    || MpscLinkedQueue7^ || SpscLinkedQueue^
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5     109192.288  ||    111037.202       110112.152    ||       106683.693  ||      109647.796
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5       6952.955  ||      2846.331**       2821.400**  ||         6280.963  ||        7117.558
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5         12.267  ||         9.988**         10.063**  ||           12.667  ||          13.786
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5   16430666.170  ||  16284869.881     16504292.796    ||     15826734.130  ||    16052912.021
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5     153431.778  ||    158892.599       157288.399    ||       153065.062  ||      155336.587
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5        150.061  ||       159.481          149.546    ||          153.177  ||         152.810
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5      16899.056  ||     16111.396        16532.411    ||        14405.399  ||       15836.574
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5       7262.566  ||      5742.547**       5504.293**  ||         7081.180  ||        8112.809
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5         13.520  ||        10.364**          9.954**  ||           12.881  ||          14.937


^MpscLinkedQueue7 => This could be used since observeOn supports single-consumer. Currently unbounded and needs to be bounded.
^SpscLinkedQueue7 => This could be used since observeOn supports single-producer, single-consumer. Currently unbounded and needs to be bounded.
```

JMC while running `merge` tests for 60 seconds:

![screen shot 2014-11-29 at 8 47 43 pm](https://cloud.githubusercontent.com/assets/813492/5236831/3006bb10-7809-11e4-98dc-0c2c78749187.png)

We can't use these queues as-is since they are single-consumer and we need multi-consumer for `merge`. Also, `observeOn` is showing some test failures. 

However, the results do suggest that we can get a data structure to achieve performance without object pooling. 
 =||= Here is an example of what we don't want as far as object-allocation.

`observeOn` using JCTools linked list (good):

![observeon-jctools-linkedlist](https://cloud.githubusercontent.com/assets/813492/5236838/e082ccea-7809-11e4-88eb-d0b439df8d27.png)

`observeOn` using JCTools array queue without pooling (bad):

![observeon-jctools-arrayqueue](https://cloud.githubusercontent.com/assets/813492/5236839/ece56a10-7809-11e4-964c-6372a3e0eb97.png)

Note the massive object allocation.
 =||= It's quite odd Spsc is failing since everything should be serialized, i.e., only 1 thread offering values to the internal queues at a time and only 1 thread collecting from all queues, right? Thread hopping should not affect Spsc. I can only speculate, but when I did some backpressure-related code lately, I often didn't get the consumption phase right at first: the case where upstream produces and downstream requests at the same time, both may end up in the drain loop. This is why I used the emitting flag in onBackpressureBlock or in backpressure-aware ReplaySubject.
 =||= Yes it should work and the other spsc/mpsc queue impls work so it suggests an issue with those impls (they aren't yet officially released). 
 =||= @benjchristensen with which params are you running jmh + jfr?
 =||= I manually attach JFR after the test passes the warmup and hits the first iteration. I increase the integration time to some longer number (been doing 25 seconds) so it runs far longer than the 60 seconds I capture via JFR.

```
./gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 25 .*OperatorObserveOnPerf.*'
```

I start flight recording when the first iteration starts:

```
# Run progress: 0.00% complete, ETA 00:19:30
# Warmup: 5 iterations, 1 s each
# Measurement: 5 iterations, 25 s each
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: rx.operators.OperatorObserveOnPerf.observeOnComputation
# Parameters: (size = 1)
# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/bin/java
# VM options: -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -Xmx512m -Dfile.encoding=UTF-8
# Fork: 1 of 1
# Warmup Iteration   1: 76564.389 ops/s
# Warmup Iteration   2: 105044.060 ops/s
# Warmup Iteration   3: 108520.068 ops/s
# Warmup Iteration   4: 108104.151 ops/s
# Warmup Iteration   5: 109615.544 ops/s
Iteration   1:
```

![screen shot 2014-11-30 at 11 03 48 am](https://cloud.githubusercontent.com/assets/813492/5238883/b02797e8-7880-11e4-94df-f71ec1ae27aa.png)

![screen shot 2014-11-30 at 11 03 56 am](https://cloud.githubusercontent.com/assets/813492/5238885/bdca1efc-7880-11e4-8c9e-5b5bd32e9213.png)
 =||= > some unit tests failing with this that need to be debugged

Just a silly oversight on my part. These are unbounded queues and our use cases requires them to be bounded. Thus, the `offer` never returns false so we never hit the backpressure exception:

``` java
        if (!queue.offer(on.next(o))) {
            throw new MissingBackpressureException();
        }
```

If we use one of these unbounded queues we'll need to add the overhead of tracking the size, or modify the queue implementation to correctly do that for us. 
 =||= ConcurrentLinkedQueue takes a performance hit compared with the JCTools implementations for `observeOn`:

```
ObserveOn

Benchmark                                         (size)  SpmcArrayQueue  ||   ConcurrentLinkedQueue
r.o.OperatorObserveOnPerf.observeOnComputation         1      109192.288  ||              110221.988
r.o.OperatorObserveOnPerf.observeOnComputation      1000        6952.955  ||                6016.298**
r.o.OperatorObserveOnPerf.observeOnComputation   1000000          12.267  ||                  10.748**
r.o.OperatorObserveOnPerf.observeOnImmediate           1    16430666.170  ||            16245304.118
r.o.OperatorObserveOnPerf.observeOnImmediate        1000      153431.778  ||              156059.398
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000         150.061  ||                 155.667
r.o.OperatorObserveOnPerf.observeOnNewThread           1       16899.056  ||               16700.144
r.o.OperatorObserveOnPerf.observeOnNewThread        1000        7262.566  ||                6813.449**
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000          13.520  ||                  10.655**
```

It's okay for `merge`:

```
Benchmark                                          (size)  SpmcArrayQueue  ||  MpscLinkedQueue7^  ||  ConcurrentLinkedQueue
r.o.OperatorMergePerf.merge1SyncStreamOfN               1     5448592.507  ||       5280793.113   ||            5292601.594
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000       54425.611  ||         51982.505   ||              51990.637
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000          52.477  ||            59.971   ||                 59.967
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1       92792.488  ||        104769.406   ||             103669.636
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000           4.957  ||             4.750   ||                  4.074
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1     4608856.070  ||       4274735.897   ||            4360997.158
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100      431920.261  ||        440251.858   ||             438544.154
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000       52309.410  ||         49188.282   ||              49382.440
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1     5815289.623  ||       5576949.872   ||            5577426.641
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000          52.525  ||            51.102   ||                 49.899
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1       77640.706  ||         75433.006   ||              78623.524
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000        3000.748  ||          2881.911   ||               2696.428
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1     5397752.619  ||       5445358.040   ||            5346115.873
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000       29257.005  ||         34305.563   ||              34051.746
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000          35.506  ||            33.594   ||                 35.157
```
 =||= I modified `RxRingBuffer` to use its own counter for bounding the links lists and am now using `SpscLinkedQueue`

The only unit test failing is `RxRingBufferSpmcTest.testConcurrency` which is a valid failure since I am only using an spsc queue.

Scroll to the right to see the `SpscLinkedQueue+Size` values:

```
Merge

Benchmark                                          (size)  SpmcArrayQueue  ||     Synchronized LinkedList    ||  MpscLinkedQueue7^  ||  ConcurrentLinkedQueue  || SpscLinkedQueue+Size
r.o.OperatorMergePerf.merge1SyncStreamOfN               1     5448592.507  ||  5332264.735    5358807.217    ||       5280793.113   ||            5292601.594  ||          5332726.909
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000       54425.611  ||    52385.763      52409.485    ||         51982.505   ||              51990.637  ||            49268.224
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000          52.477  ||       53.928         54.128    ||            59.971   ||                 59.967  ||               50.742
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1       92792.488  ||   103554.112     104711.192    ||        104769.406   ||             103669.636  ||           104210.342
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000           4.957  ||        4.194          4.143    ||             4.750   ||                  4.074  ||                4.688
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1     4608856.070  ||  4294087.613    4688656.691    ||       4274735.897   ||            4360997.158  ||          4888816.598
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100      431920.261  ||   451007.165     333391.274**  ||        440251.858   ||             438544.154  ||           445969.294
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000       52309.410  ||    49952.664      50057.346    ||         49188.282   ||              49382.440  ||            49817.351
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1     5815289.623  ||  5558593.305    5575812.189    ||       5576949.872   ||            5577426.641  ||          5707051.084
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000          52.525  ||       49.788         49.567    ||            51.102   ||                 49.899  ||               43.819**
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1       77640.706  ||    79530.128      79472.088    ||         75433.006   ||              78623.524  ||            78480.286
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000        3000.748  ||     2358.716**     2397.035**  ||          2881.911   ||               2696.428  ||             2627.181*
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1     5397752.619  ||  5282943.171    5361848.221    ||       5445358.040   ||            5346115.873  ||          5352179.516
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000       29257.005  ||    34150.793      35196.066    ||         34305.563   ||              34051.746  ||            35081.657
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000          35.506  ||       25.827**       26.517**  ||            33.594   ||                 35.157  ||               35.378


^MpscLinkedQueue7 => This can be used by merge and observeOn.  Currently unbounded and needs to be bounded.



ObserveOn


Benchmark                                         (size)  SpmcArrayQueue  ||        Synchronized LinkedList    || MpscLinkedQueue7^ || SpscLinkedQueue^  || ConcurrentLinkedQueue   || SpscLinkedQueue+Size
r.o.OperatorObserveOnPerf.observeOnComputation         1      109192.288  ||    111037.202       110112.152    ||       106683.693  ||      109647.796   ||            110221.988   ||           105952.032
r.o.OperatorObserveOnPerf.observeOnComputation      1000        6952.955  ||      2846.331**       2821.400**  ||         6280.963  ||        7117.558   ||              6016.298** ||             6615.249
r.o.OperatorObserveOnPerf.observeOnComputation   1000000          12.267  ||         9.988**         10.063**  ||           12.667  ||          13.786   ||                10.748** ||               11.381
r.o.OperatorObserveOnPerf.observeOnImmediate           1    16430666.170  ||  16284869.881     16504292.796    ||     15826734.130  ||    16052912.021   ||          16245304.118   ||         16294413.530
r.o.OperatorObserveOnPerf.observeOnImmediate        1000      153431.778  ||    158892.599       157288.399    ||       153065.062  ||      155336.587   ||            156059.398   ||           157113.031
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000         150.061  ||       159.481          149.546    ||          153.177  ||         152.810   ||               155.667   ||              157.675
r.o.OperatorObserveOnPerf.observeOnNewThread           1       16899.056  ||     16111.396        16532.411    ||        14405.399  ||       15836.574   ||             16700.144   ||            15718.673
r.o.OperatorObserveOnPerf.observeOnNewThread        1000        7262.566  ||      5742.547**       5504.293**  ||         7081.180  ||        8112.809   ||              6813.449** ||             7248.917
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000          13.520  ||        10.364**          9.954**  ||           12.881  ||          14.937   ||                10.655** ||               12.344


^MpscLinkedQueue7 => This could be used since observeOn supports single-consumer. Currently unbounded and needs to be bounded.
^SpscLinkedQueue7 => This could be used since observeOn supports single-producer, single-consumer. Currently unbounded and needs to be bounded.
```

observeOn Flight Recorder

1.0.1

![observeon-1 0 1](https://cloud.githubusercontent.com/assets/813492/5239162/be5d01a8-788b-11e4-9fbf-93324edb3691.png)

Modified to use SPSC Linked List

![observeon-spsc](https://cloud.githubusercontent.com/assets/813492/5239164/c7513a7c-788b-11e4-8840-0e169da74f62.png)

merge Flight Recorder

1.0.1

![merge-1 0 1](https://cloud.githubusercontent.com/assets/813492/5239166/d8dd8944-788b-11e4-96d4-85c39259a418.png)

Modified to use SPSC Linked List

![merge-spsc](https://cloud.githubusercontent.com/assets/813492/5239165/d716f726-788b-11e4-8953-440768dfa2a9.png)

The flight recorder stuff, particularly for `merge` needs more evaluation. 

It does seem though that the trade-offs in performance and object allocation are not severe and thus probably warrants the change to allow avoiding object pooling. 

I'll submit a PR with the changes for evaluation and further experimentation. 
 =||= PR https://github.com/ReactiveX/RxJava/pull/1909 contains the code for the previous perf tests. 
 =||= A note while we're working on this ... whatever decision we make here I think should target 1.1 since it will affect memory and GC behavior so is larger than a patch. 

I also want to give enough time to really think through this ... sleeping on whatever solutions we work on since this is very nuanced and the tradeoffs need to be thought through. 
 =||= I've been exploring weak and phantom references tonight while exploring whether it's possible to continue using object pooling but without manual release. I have it working, and performance is good, but at high velocity on JMH tests the ReferenceQueue is filling up in an unbounded manner. 

Anyone have good experience using WeakReferences for an object pool with high throughput? 

I wish there was a better way to get a callback from the WeakReference than it being put into a ReferenceQueue.
 =||= The problem with pooling is that it can now become the congestion point: multiple threads might want to grab an element from the pool at the same time.

The alternative is reference counting:

``` java
public void onNext(Object o) {
   Queue<Object> q = queue;
   if (q != null && q.acquire()) { // i.e., cas 1 -> 2
      q.offer(o);
      q.release(); // i.e., decrementAndGet
   }
}
public void unsubscribe() {
   Queue<Object> q = queue;
   if (q != null) {
        queue = null;
        q.release();
   } 
}
```

Could be achieved via AtomicInteger. When borrowed, the queue starts out in 1. Use toggles this between 1 and 2. If an unsubscription happens, the party that goes from 1 to 0 will put the queue back into the pool. The drawback is that now you have extra bookkeeping which may halve the throughput in RxRingBufferPerf.
 =||= > The problem with pooling is that it can now become the congestion point: multiple threads might want to grab an element from the pool at the same time.

Sure, but if it's a concurrent queue, which it is, then that contention should not be severe. It's using an `MpmcArrayQueue` optimized for performance. 

I agree it is a point of contention, but if that contention is cheaper than the object allocation/collection then it's a net win. 

> reference counting

This could work but is effectively synchronizing unsubscribe and queue usage (cheaper than mutex, but still a form of synchronizing) which definitely has a cost, both performance and cognitive every time this queue is used. Hence us pursuing either a solution that doesn't need to be pooled, or my pursuit of weak references so the release to the pool is automated. 
 =||= I think false sharing isn't really an issue by us because how te queus are used: the producer is likely to win the drain race and emit data, or the queue is practically full and only 1 element is put for each 1 element taken (request(1) in merge and observeOn) and the two sides are far away to each other and no false sharing happens. So an unpadded queue of 128 capacity takes up 1024+16+32 bytes nicely fitting in L1. The padded version takes 65k.
 =||= I have some some benchmarking on different solutions that have been posted, including removing the pooling altogether and here are the numbers. Note that we now have a queue size of 128, not 1024 like we used to.

```
Benchmark                                                                 (nextRuns)  (size)            1.x                   No Pool          2PhaseArrayQueue    branch rxqueue-spsc 
r.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A     100     288851.474  |    464395.527  161% ++  |    288585.686  100%    |    128859.372 45% --
r.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A   10000       1053.102  |      1122.418  107%     |       988.942  94%     |      1033.768 98%
r.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A     100     130035.705  |    219530.470  169% ++  |    129688.488  100%    |    122350.438 94%
r.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A   10000        394.109  |       408.761  104%     |       372.060  94%     |       382.935 97%
r.internal.RxRingBufferPerf.spmcCreateUseAndDestroy1                             N/A     N/A   26400373.503  |   4011739.109  15% --   |   3904652.414  15% --  |  10354119.555 39% --
r.internal.RxRingBufferPerf.spmcRingBufferAddRemove1                             N/A     N/A   41947289.772  |  40889056.084  97%      | 167128945.622  398% ++ |  39302492.472 94%
r.internal.RxRingBufferPerf.spscCreateUseAndDestroy1                             N/A     N/A   26625817.275  |   4041119.853  15% --   |  10543005.986  40% --  |   9844380.252 37% --
r.internal.RxRingBufferPerf.spscRingBufferAddRemove1                             N/A     N/A   42376557.425  |  39384117.892  93%      |  50678693.611  120% ++ |  40440515.140 95%
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A       1     323419.496  |    314150.913  97%      |    306704.864  95%     |     56413.217 17% --
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A    1000        325.685  |       320.644  98%      |       312.976  96%     |        75.440 23% --
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A 1000000          0.318  |         0.318  100%     |         0.311  98%     |         0.066 21% --
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A       1    5544570.553  |   5634853.059  102%     |   5355739.382  97%     |   1276719.950 23% --
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A    1000      37510.701  |     37428.777  100%     |     37971.972  101%    |      8511.690 23% --
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A 1000000         32.831  |        33.133  101%     |        33.224  101%    |         7.466 23% --
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A       1    4081082.521  |   3988577.555  98%      |   3855453.808  94%     |    892951.263 22% --
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A    1000      26194.758  |     26060.788  99%      |     24783.878  95%     |      5014.843 19% -- 
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A 1000000         24.255  |        24.638  102%     |        22.923  95%     |         5.212 21% --
r.operators.OperatorMapPerf.mapPassThru                                          N/A       1   24413615.697  |  24572501.107  101%     |  24135623.277  99%     |   5882139.319 24% --
r.operators.OperatorMapPerf.mapPassThru                                          N/A    1000     126022.367  |    126928.122  101%     |    121905.819  97%     |     31068.374 25% --
r.operators.OperatorMapPerf.mapPassThru                                          N/A 1000000        125.726  |       133.165  106%     |       125.238  100%    |        32.079 26% --
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A       1   26830181.693  |  26855829.721  100%     |  26402665.260  98%     |   6974887.323 26% --
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A    1000     126998.154  |    127883.467  101%     |    124275.543  98%     |     29430.411 23% --
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A 1000000        132.249  |       132.858  100%     |       130.028  98%     |       105.182 80% --
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A       1    5004527.084  |   5096505.217  102%     |   4913306.706  98%     |   4565544.618 91%
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A    1000      52723.842  |     51944.534  99%      |     44783.449  85% --  |     38827.856 74% --
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A 1000000         49.928  |        49.643  99%      |        47.285  95%     |        42.332 85% --
r.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A       1      99724.243  |     96046.578  96%      |     97233.505  98%     |     98970.453 99%
r.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A    1000          4.661  |         5.085  109%     |         4.688  101%    |         4.727 101%
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A       1    4543776.401  |   4562256.139  100%     |   4626141.577  102%    |   4550596.577 100%
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A     100     482015.536  |    481347.669  100%     |    477687.006  99%     |    474884.635 99%
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A    1000      52102.762  |     52212.844  100%     |     50536.678  97%     |     55255.898 106%
r.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A       1    5182887.347  |   4926496.569  95%      |   5160628.853  100%    |   5043255.904 97%
r.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A    1000         52.055  |        51.914  100%     |        48.084  92%     |        46.567 89% --
r.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A       1      76604.876  |     74224.276  97%      |     71937.709  94%     |     77366.844 101%
r.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A    1000       3166.341  |      3130.021  99%      |      3295.517  104%    |      2541.420 80% --
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A       1    5276030.387  |   5048453.291  96%      |   4806177.849  91%     |   4935148.406 94%
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A    1000      37197.231  |     37647.410  101%     |     38406.161  103%    |     36161.836 97%
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A 1000000         34.649  |        34.124  98%      |        34.025  98%     |        32.754 95%
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A       1     107207.970  |    100380.298  94%      |    108474.884  101%    |    105535.982 98%
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A    1000       6517.902  |      6869.709  105%     |      6371.416  98%     |      6301.948 97%
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A 1000000         13.670  |        13.580  99%      |        11.346  83% --  |        11.305 83% --
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A       1   15245087.895  |  14962479.384  98%      |  14997783.368  98%     |  14673057.780 96%
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A    1000     178513.653  |    173023.234  97%      |    170021.413  95%     |    164929.922 92%
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A 1000000        157.016  |       152.469  97%      |       154.095  98%     |       144.408 92%
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A       1      16879.424  |     15716.151  93%      |     15426.649  91%     |     14689.995 87% --
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A    1000       7783.654  |      7765.427  100%     |      6734.649  87%     |      7173.622 92%
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A 1000000         13.153  |        14.191  108%     |        11.650  89%     |        11.275 86% --
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A       1   25332343.625  |  25065988.234  99%      |  24342054.885  96%     |  25262395.598 100%
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A    1000     116819.629  |    116739.463  100%     |    113936.110  98%     |    115857.556 99%
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A 1000000        135.843  |       134.416  99%      |       130.710  96%     |       134.943 99%
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A       1  121325903.567  | 118002649.957  97%      | 112020450.304  92%     | 104636361.664 86% --
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A    1000     186533.260  |    187334.419  100%     |    185695.013  100%    |    179519.340 96%
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A 1000000        166.914  |       169.448  102%     |       160.806  96%     |       158.203 95%
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A       1   18921314.555  |  18257594.271  96%      |  18853324.397  100%    |  18123044.637 96%
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A    1000     269546.032  |    228423.425  85% --   |    266431.946  99%     |    248808.733 92%
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A 1000000        260.990  |       254.223  97%      |       253.943  97%     |       235.045 90% --
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A       1   10736813.240  |  10037561.783  93%      |   9935098.948  93%     |   9663588.470 90% --
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A    1000      79767.255  |     67068.394  84% --   |     66532.316  83% --  |     64151.866 80% --
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A 1000000         70.840  |        75.120  106%     |        73.776  104%    |        72.247 102%
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A       1     111389.498  |    110210.985  99%      |    110774.637  99%     |    106648.746 96%
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A    1000       7575.618  |      7207.681  95%      |      7189.025  95%     |      7175.698 95%
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A 1000000          9.196  |         9.864  107%     |         8.714  95%     |         9.383 102%
r.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A       1      83396.077  |     78874.484  95%      |     81866.626  98%     |     78901.924 95%
r.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A    1000      36273.839  |     34303.562  95%      |     35859.978  99%     |     34513.093 95%
r.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A       1      55607.010  |     53946.317  97%      |     55332.808  100%    |     51419.088 92%
r.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A    1000      53468.342  |     53613.934  100%     |     53089.878  99%     |     52291.141 98%
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A       1     107083.283  |    106172.060  99%      |    109756.005  102%    |    108969.564 102%
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A      10     103095.692  |    102757.452  100%     |    102707.186  100%    |     99579.238 97%
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A     100      37921.038  |     39183.046  103%     |     34085.675  90%     |     32331.879 85% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    1000       6776.178  |      7015.656  104%     |      6289.376  93%     |      6384.900 94%
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    2000       4851.628  |      4828.700  100%     |      4212.292  87%     |      4354.948 90% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    3000       3754.394  |      3778.104  101%     |      2961.396  79%     |      3207.050 85% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    4000       2994.907  |      2949.000  98%      |      2489.455  83% --  |      2562.348 86% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A   10000       1314.721  |      1275.489  97%      |      1113.610  85% --  |      1102.961 84% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A  100000        136.838  |       132.305  97%      |       115.854  85% --  |       117.097 86% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A 1000000         13.837  |        12.820  93%      |        11.543  83% --  |        10.903 79% --
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A       1     113032.129  |    112135.558  99%      |    111731.222  99%     |    111749.315 99%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A      10     109884.718  |    109449.819  100%     |    102844.370  94%     |    109021.256 99%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A     100      89945.753  |     88015.871  98%      |     85771.952  95%     |     88074.845 98%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    1000      31680.733  |     31522.878  100%     |     31045.429  98%     |     31413.322 99%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    2000      18490.513  |     18352.634  99%      |     15774.641  85% --  |     16059.751 87% --
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    3000      11490.479  |     11446.241  100%     |     11197.939  97%     |     12871.202 112% ++
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    4000       8833.117  |     10230.066  116% ++  |      9788.883  111%    |      9889.138 112% ++
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A   10000       3888.874  |      3885.651  100%     |      3919.543  101%    |      3903.835 100%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A  100000        446.789  |       438.143  98%      |       434.775  97%     |       432.321 97%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A 1000000         43.228  |        42.516  98%      |        42.588  99%     |        41.833 97%
r.schedulers.IOSchedulerPerf.observeOn                                           N/A       1     107443.954  |    103885.976  97%      |    106696.574  99%     |    105420.129 98%
r.schedulers.IOSchedulerPerf.observeOn                                           N/A    1000       6835.942  |      6934.710  101%     |      6175.613  90%     |      6257.461 92%
r.schedulers.IOSchedulerPerf.observeOn                                           N/A 1000000         13.804  |        13.076  95%      |        11.489  83% --  |        11.646 84% --
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A       1     113589.713  |    112548.761  99%      |    113767.664  100%    |    112749.541 99%
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A    1000      31572.535  |     31359.484  99%      |     31566.874  100%    |     28903.326 92%
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A 1000000         43.469  |        43.259  100%     |        43.075  99%     |        42.883 99%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                            1     N/A    4885450.713  |   4663855.111  95%      |   4760593.357  97%     |   4814097.168 99%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                         1000     N/A      36567.449  |     34794.653  95%      |     30965.582  85% --  |     35307.030 97%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                      1000000     N/A         46.758  |        44.710  96%      |        45.807  98%     |        45.132 97%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                         1     N/A    5166859.073  |   4928418.828  95%      |   4975843.203  96%     |   4971964.310 96%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                      1000     N/A      36677.914  |     35071.647  96%      |     34172.806  93%     |     36402.484 99%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                   1000000     N/A         45.299  |        43.800  97%      |        44.580  98%     |        44.281 98%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                           1     N/A    3602234.043  |   3467543.784  96%      |   3555240.202  99%     |   3590503.433 100%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                        1000     N/A      47750.855  |     46718.061  98%      |     46229.640  97%     |     47580.266 100%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                     1000000     N/A         42.764  |        47.144  110% ++  |        45.690  107%    |        42.126 99%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                        1     N/A    3787851.518  |   3637162.254  96%      |   3527627.269  93%     |   3761304.213 99%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                     1000     N/A      43472.144  |     46173.174  106%     |     41008.079  94%     |     46078.493 106%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                  1000000     N/A         42.057  |        41.150  98%      |        40.454  96%     |        40.994 97%

```
 =||= Here is a comparison of no pooling with size at 128 vs 1024:

```
Benchmark                                                                 (nextRuns)  (size)            1.x              No Pool (128)    No Pool (1024)     
r.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A     100     288851.474  |    464395.527  161% ++  |    491662.797  170% ++ 
r.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A   10000       1053.102  |      1122.418  107%     |      1201.884  114% ++ 
r.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A     100     130035.705  |    219530.470  169% ++  |    230427.274  177% ++ 
r.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A   10000        394.109  |       408.761  104%     |       430.168  109%    
r.internal.RxRingBufferPerf.spmcCreateUseAndDestroy1                             N/A     N/A   26400373.503  |   4011739.109  15% --   |   2066095.594  8%   -- 
r.internal.RxRingBufferPerf.spmcRingBufferAddRemove1                             N/A     N/A   41947289.772  |  40889056.084  97%      |  42517680.638  101%    
r.internal.RxRingBufferPerf.spscCreateUseAndDestroy1                             N/A     N/A   26625817.275  |   4041119.853  15% --   |   2065904.299  8%   -- 
r.internal.RxRingBufferPerf.spscRingBufferAddRemove1                             N/A     N/A   42376557.425  |  39384117.892  93%      |  42717826.799  101%    
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A       1     323419.496  |    314150.913  97%      |    286454.266  89%  -- 
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A    1000        325.685  |       320.644  98%      |       304.203  93%     
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A 1000000          0.318  |         0.318  100%     |         0.305  96%     
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A       1    5544570.553  |   5634853.059  102%     |   5703716.144  103%    
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A    1000      37510.701  |     37428.777  100%     |     37643.924  100%    
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A 1000000         32.831  |        33.133  101%     |        33.955  103%    
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A       1    4081082.521  |   3988577.555  98%      |   4148571.600  102%    
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A    1000      26194.758  |     26060.788  99%      |     27231.215  104%    
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A 1000000         24.255  |        24.638  102%     |        26.108  108%    
r.operators.OperatorMapPerf.mapPassThru                                          N/A       1   24413615.697  |  24572501.107  101%     |  25033228.781  103%    
r.operators.OperatorMapPerf.mapPassThru                                          N/A    1000     126022.367  |    126928.122  101%     |    131846.869  105%    
r.operators.OperatorMapPerf.mapPassThru                                          N/A 1000000        125.726  |       133.165  106%     |       129.763  103%    
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A       1   26830181.693  |  26855829.721  100%     |  27593572.229  103%    
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A    1000     126998.154  |    127883.467  101%     |    128981.592  102%    
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A 1000000        132.249  |       132.858  100%     |       130.398  99%     
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A       1    5004527.084  |   5096505.217  102%     |   5198752.240  104%    
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A    1000      52723.842  |     51944.534  99%      |     54578.616  104%    
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A 1000000         49.928  |        49.643  99%      |        46.496  93%     
r.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A       1      99724.243  |     96046.578  96%      |     92329.887  93%     
r.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A    1000          4.661  |         5.085  109%     |         4.858  104%    
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A       1    4543776.401  |   4562256.139  100%     |   4868734.621  107%    
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A     100     482015.536  |    481347.669  100%     |    474865.976  99%     
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A    1000      52102.762  |     52212.844  100%     |     41445.112  80%  -- 
r.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A       1    5182887.347  |   4926496.569  95%      |   5233708.963  101%    
r.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A    1000         52.055  |        51.914  100%     |        52.875  102%    
r.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A       1      76604.876  |     74224.276  97%      |     70830.676  92%     
r.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A    1000       3166.341  |      3130.021  99%      |      3684.324  116% ++ 
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A       1    5276030.387  |   5048453.291  96%      |   4977866.142  94%     
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A    1000      37197.231  |     37647.410  101%     |     39342.369  106%    
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A 1000000         34.649  |        34.124  98%      |        34.793  100%    
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A       1     107207.970  |    100380.298  94%      |    103951.076  97%     
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A    1000       6517.902  |      6869.709  105%     |      4597.071  71%  -- 
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A 1000000         13.670  |        13.580  99%      |         8.769  64%  -- 
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A       1   15245087.895  |  14962479.384  98%      |  15246618.567  100%    
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A    1000     178513.653  |    173023.234  97%      |    175349.312  98%     
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A 1000000        157.016  |       152.469  97%      |       158.773  101%    
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A       1      16879.424  |     15716.151  93%      |     15436.938  91%     
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A    1000       7783.654  |      7765.427  100%     |      4088.303  53%  -- 
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A 1000000         13.153  |        14.191  108%     |        14.327  109%    
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A       1   25332343.625  |  25065988.234  99%      |  25389267.172  100%    
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A    1000     116819.629  |    116739.463  100%     |    115639.590  99%     
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A 1000000        135.843  |       134.416  99%      |       135.049  99%     
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A       1  121325903.567  | 118002649.957  97%      | 117809961.937  97%     
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A    1000     186533.260  |    187334.419  100%     |    189459.713  102%    
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A 1000000        166.914  |       169.448  102%     |       167.025  100%    
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A       1   18921314.555  |  18257594.271  96%      |  19336558.885  102%    
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A    1000     269546.032  |    228423.425  85% --   |    272078.328  101%    
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A 1000000        260.990  |       254.223  97%      |       263.143  101%    
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A       1   10736813.240  |  10037561.783  93%      |  10329940.205  96%     
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A    1000      79767.255  |     67068.394  84% --   |     82774.032  104%    
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A 1000000         70.840  |        75.120  106%     |        73.439  104%    
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A       1     111389.498  |    110210.985  99%      |    114315.595  103%    
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A    1000       7575.618  |      7207.681  95%      |      6969.878  92%     
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A 1000000          9.196  |         9.864  107%     |        10.363  113% ++ 
r.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A       1      83396.077  |     78874.484  95%      |     83311.153  100%    
r.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A    1000      36273.839  |     34303.562  95%      |     35931.364  99%     
r.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A       1      55607.010  |     53946.317  97%      |     53502.884  96%     
r.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A    1000      53468.342  |     53613.934  100%     |     52365.494  98%     
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A       1     107083.283  |    106172.060  99%      |    103457.291  97%     
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A      10     103095.692  |    102757.452  100%     |     98744.249  96%     
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A     100      37921.038  |     39183.046  103%     |     38418.723  101%    
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    1000       6776.178  |      7015.656  104%     |      4530.745  67%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    2000       4851.628  |      4828.700  100%     |      2085.208  43%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    3000       3754.394  |      3778.104  101%     |      1310.303  35%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    4000       2994.907  |      2949.000  98%      |      1008.669  34%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A   10000       1314.721  |      1275.489  97%      |       399.229  30%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A  100000        136.838  |       132.305  97%      |        50.999  37%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A 1000000         13.837  |        12.820  93%      |         9.045  65%  -- 
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A       1     113032.129  |    112135.558  99%      |    113835.591  101%    
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A      10     109884.718  |    109449.819  100%     |    109171.798  99%     
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A     100      89945.753  |     88015.871  98%      |     89399.541  99%     
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    1000      31680.733  |     31522.878  100%     |     31588.465  100%    
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    2000      18490.513  |     18352.634  99%      |     18429.705  100%    
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    3000      11490.479  |     11446.241  100%     |     11472.235  100%    
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    4000       8833.117  |     10230.066  116% ++  |      9979.643  113% ++ 
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A   10000       3888.874  |      3885.651  100%     |      3517.361  90%     
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A  100000        446.789  |       438.143  98%      |       456.528  102%    
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A 1000000         43.228  |        42.516  98%      |        44.854  104%    
r.schedulers.IOSchedulerPerf.observeOn                                           N/A       1     107443.954  |    103885.976  97%      |    107011.170  100%    
r.schedulers.IOSchedulerPerf.observeOn                                           N/A    1000       6835.942  |      6934.710  101%     |      4307.395  63%  -- 
r.schedulers.IOSchedulerPerf.observeOn                                           N/A 1000000         13.804  |        13.076  95%      |        10.003  72%  -- 
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A       1     113589.713  |    112548.761  99%      |    112666.557  99%     
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A    1000      31572.535  |     31359.484  99%      |     31608.746  100%    
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A 1000000         43.469  |        43.259  100%     |        43.581  100%    
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                            1     N/A    4885450.713  |   4663855.111  95%      |   4769133.206  98%     
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                         1000     N/A      36567.449  |     34794.653  95%      |     36690.199  100%    
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                      1000000     N/A         46.758  |        44.710  96%      |        49.111  105%    
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                         1     N/A    5166859.073  |   4928418.828  95%      |   5233752.980  101%    
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                      1000     N/A      36677.914  |     35071.647  96%      |     37576.169  102%    
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                   1000000     N/A         45.299  |        43.800  97%      |        46.962  104%    
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                           1     N/A    3602234.043  |   3467543.784  96%      |   3700116.809  103%    
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                        1000     N/A      47750.855  |     46718.061  98%      |     47680.041  100%    
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                     1000000     N/A         42.764  |        47.144  110% ++  |        48.698  114% ++ 
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                        1     N/A    3787851.518  |   3637162.254  96%      |   3705592.692  98%     
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                     1000     N/A      43472.144  |     46173.174  106%     |     46912.710  108%    
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                  1000000     N/A         42.057  |        41.150  98%      |        46.833  111% ++ 
```

The drop from 1024 to 128 makes it work okay with no pooling. At 1024 we needed the pooling. 
 =||= Any of you able to check performance and object allocation behavior using https://github.com/ReactiveX/RxJava/pull/1944 so it's not just my judgement on this? Is removing the object pool okay while using SpscArrayQueue as long as we stay at size 128?

Can you get WeakReference pooling to work better than the "no pooling" performance?
 =||= @akarnokd based on the perf numbers above what do you think we should do?
 =||= The no-pool 128 version seems to be the best choice generally. Maybe the low spscCreateUseDestroy1 case can be improved by removing the pad and complex hierarchy from the main class.
 =||= Should we move forward with this change in 1.0.x or should it be 1.1? I have not seen any evidence in my testing to suggest that this is a significant change in GC behavior ... which surprised me and is why I'm hesitant and want confirmation. 
 =||= By the way, nothing we're doing here should affect Android since we use a LinkedList without pooling on Android. 
 =||= What versions of Android are supported? `Deque`/`ArrayDeque` are usually preferred if you are API 9 and up (which is Java 6, 99.5% of active Android devices).
 =||= We use the SpscRingBuffer for non-Android since it uses `sun.misc.Unsafe` and a `synchronized` `LinkedList` for Android. Is a `synchronized` `ArrayDeque` preferred for Android then? The max size for Android is set to 16 instead of 128. With LinkedList nothing is allocated until it is needed. If we use `ArrayDeque` would you want it set to 16 as the initial capacity or something like 2 and let it grow if needed?
 =||= Here is the size for Android: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/util/RxRingBuffer.java#L264 and the list impl choice when `Unsafe` is not available: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/util/RxRingBuffer.java#L324

The conditional check for `unsafe` happens here: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/util/RxRingBuffer.java#L44

If you want to make a change for Android would you like to submit a PR?
 =||= > What versions of Android are supported?

We code to Java 6 and I believe it is Android API 9+ as per discussions in https://github.com/ReactiveX/RxJava/issues/153 and https://github.com/ReactiveX/RxJava/issues/1004
 =||= On Android we generally prefer the up-front allocation over lazy allocation of somewhat disposable wrapper objects (such as that inside of a LinkedList). This is for the benefit of comparatively poor handling of short lived objects as well as avoiding the GC as much as possible in our 60fps world. We also definitely wouldn't want to pay the cost of having the array expand unless it exceeded the 16 value.
 =||= It will never exceed 16 due to how the backpressure approach works, it will throw a `MissingBackpressureException` instead if the origin doesn't respect the requested amount. 

Often the buffer is not needed, or it's only needed for a single value (using Observable like a Future) so on Android what is better, allocating a 16 size array and maybe only using 1 spot, or allocating linked nodes only as needed but potentially allocating more in a slow/contended stream of data?

Do you want to submit a PR with the changes done as you'd like them for Android?
 =||= I have added https://github.com/ReactiveX/RxJava/pull/1969 with Flight Recorder tests showing the impact of removing pooling. It's not catastrophic but it also shows signs of being a potential problem. This is exactly the type of metrics that pushed me to add object pooling. That said, because we've dropped from 1024 to 128 the impact is not anywhere near as bad as it was before. 
 =||= This test is particularly bad: OperatorMergePerf.mergeNAsyncStreamsOfN

This suggests we can't eliminate pooling and use array queues.

With Pooling

![screen shot 2014-12-13 at 11 22 24 am](https://cloud.githubusercontent.com/assets/813492/5424991/64bbd122-82ba-11e4-911f-c835a016d1db.png)

Without

![screen shot 2014-12-13 at 11 22 29 am](https://cloud.githubusercontent.com/assets/813492/5424992/6c478210-82ba-11e4-8484-1f456c9dd18e.png)

With Pooling

![screen shot 2014-12-13 at 11 22 40 am](https://cloud.githubusercontent.com/assets/813492/5424993/717c5eea-82ba-11e4-9efd-077afd519359.png)

Without

![screen shot 2014-12-13 at 11 22 45 am](https://cloud.githubusercontent.com/assets/813492/5425008/b0651f2a-82ba-11e4-97d6-90a642594e9f.png)
 =||= I have submitted another variant in https://github.com/ReactiveX/RxJava/pull/2189

It makes different tradeoffs to allow for object pooling to work in most use cases, normal GC in edge cases (haven't found a consistent one yet, only theoretical, but I haven't tried hard yet), while maintaining more-or-less the same performance characteristics as the current 1.x code. 

I have NOT battle-tested this and intend on sleeping on it then reviewing again, but wanted to post to trigger discussions and get a review on the direction and trade-offs. 
 =||= I tried another implementation, this time with a `WriterReaderPhaser` in #2243. It performs similarly to the RWLock and WIP implementations and worse than #2189. 
 =||= Problem definition:
- The current approach to removing the object pool occasionally results in concurrency issues because concurrent emission/unsubscribe can result in 2 instances of RxRingBuffer holding a single queue.
- Retaining a reference to the `queue` to avoid a `NullPointerException` results in the same problem of 2 RxRingBuffer instances holding a single queue. 
- In short, synchronization is needed between emission and unsubscribe in order to safely release the `queue` to the pool.

A refresher on what has been attempted so far while exploring this:
- All attempts at removing the object pool have resulted in performance degradation via significant increases in object allocation and GC time. This was pursued since removing the pool would eliminate the race condition. 
- Use of WIP, mutex, RW lock, and WriterReaderPhraser make it thread-safe but at significant performance penalty in the normal happy-path (see performance numbers below)
- Attempts with using WeakReference have failed so far. Every attempt I've made suggests that ReferenceQueue has non-trivial overhead and unfortunately it's the only way to get the "callback" via polling that something is released. It doesn't help much that it was written in Java 1.2 and is heavily synchronized. We can't implement our own as this code is special-cased by the JVM since it is involved in GC. 

The behavior we're trying to deal with is:
- Emissions are all serial from the same thread. Draining may happen on a second thread. It is SPSC in behavior. 
- Unsubscribe generally comes from the same thread, but does not have to, hence the possibly concurrency. This race happens only once, at the end. 
- It is okay if the unsubscribe/emission race is non-deterministic (finish emitting then unsubscribe or unsubscribe immediately and drop data). 

Here are performance numbers of the various tests I've done:

```
Benchmark                                          (size)   Mode   Samples          1.x   Inline Volatile    + finalize       RW Lock          WIP     WRPhaser
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4757888.048       5264594.520   4956256.323   5288310.755  5032942.628  5147447.030
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    44877.618         42845.758     39209.439     25742.696    29025.955    27779.876
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       42.366            40.979        37.036        24.769       27.260       27.694
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    99981.127         99910.070     94307.080    103112.286   103176.289   100516.101
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.675             4.620         4.670         4.374        4.313        4.413
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4751265.583       4706441.452   4376983.062   4739418.557  4673633.614  4510099.724
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   458704.984        480075.261    427165.143    483313.588   476318.407   462373.555
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    42493.290         42178.254     39640.240     42728.480    42542.171    41354.668
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5406448.872       5375090.752   5066264.570   5628401.294  4974892.417  4986054.668
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       44.528            40.990        41.106        24.974       28.212       27.755
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76898.222         72655.377     69748.305     78283.565    78987.646    78550.912
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3172.653          2955.854      3064.749      1858.361     2204.948     2310.804
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5157134.576       5163837.644   4846336.744   5290961.536  5139893.848  4486879.415
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    39961.491         39341.526     37312.117     40418.492    39163.267    37424.146
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.925            35.730        33.948        35.526       35.611       32.287
```
 =||= I'd like to move forward on something since we do currently have a correctness issue. 

Unless there is some performance or functional issue I am not yet aware of, I suggest we move forward with https://github.com/ReactiveX/RxJava/pull/2189 since it seems to work while retaining performance, despite not being the most elegant of approaches. 

Once we've merged and released to fix the correctness issue, other more elegant solutions can continue to be pursued. I'd love for something such as the WriterReaderPhaser to work and retain performance. 
 =||= As a fun aside, and because this is happening over the holidays, here are some pages from a book I just read my girls the other day that totally made me think of this issue and many others like it :-)

![screen shot 2014-12-27 at 10 30 00 pm](https://cloud.githubusercontent.com/assets/813492/5563235/2c1e51fa-8e18-11e4-8865-fca3cd9e77ad.png)

![screen shot 2014-12-27 at 10 30 17 pm](https://cloud.githubusercontent.com/assets/813492/5563236/31728edc-8e18-11e4-84ac-dc8f3d05e942.png)

![screen shot 2014-12-27 at 10 30 27 pm](https://cloud.githubusercontent.com/assets/813492/5563237/35c8133a-8e18-11e4-9bf3-0c3457ca4f8b.png)

Book at http://www.amazon.com/Most-Magnificent-Thing-Ashley-Spires-ebook/dp/B00IZH626G

Spoiler ... she eventually succeeds, though still with a few imperfections :-)
 =||= Just to let you know I have added an Spsc which might fit the bill here:
https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Small footprint, grows to max size if the queue needs to grow (if consumer falls behind), still has some of the false sharing protection. Seems to perform well in my benchmarks, let me know how it works for you.
 =||= Quite clever; no CAS, no tombstone and no copying. However, correct me if I'm wrong, but it seems the code on [line 135](https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java#L135) may read beyond the buffer if offset is at the last element. The other thing I see is that the queue should disallow offering Object[] values because it would confuse the poll. Better yet, when a new array needs to be communicated, wrap it into a private holder class so it is not confused with any other type; resize should be infrequent enough to not cause significant overhead.
 =||= Since the queues are limited to RxRingBuffer.SIZE, it might be worth considering this growable queue doesn't grow in several steps but jumps immediately to its maximum value. In my two-phased version, I also triggered a growth after cerain number of elements have been offered; this helped eliminating the cost of CAS for long running queues. Here, if the poll() can know no more resize can happen, an `instanceof` may be avoided (replaced by a simple boolean flag).
 =||= Fixed as per your suggestions in https://github.com/JCTools/JCTools/issues/43
I think the factor of 2 growth is beneficial, especially since CAS is no longer required. You'll be saving up on intermediate sizing, but suffering in the case of transient spike.
I considered adding a 'max capacity reached flag', still playing with it. I think the instanceof check is not that costly if you mean to actually use the returned object. 
 =||= The RxRingBuffer has been fixed and the JCTools queues have been upgraded in 1.0.5. Pooling seems to be the only way to increase the performance of single-shot merging of values.
 =||= ,0
7027,1927,Operator to call request(n) on behalf of its backpressure-unaware downstream?,We have three strategies to apply backpressure to a source that doesn't itself support backpressure. Would it be useful to have some operator that calls request() on backpressure-aware upstream to feed a backpressure-unaware downstream? 

For example, `source.applyBackpressure(128, 16)` would initially request 128 elements; when 16 elements have passed, it requests another 16. It doesn't buffer anything just calls request(n) on start and request(m) after each m elements have passed. What complicates things is that this operator should work if the downstream actually supports backpressure, i.e., a (256, 192) should not cause a `MissingBackpressureException` if `observeOn` is next in the chain, but this implies buffering or chosing the smallest what the operator uses and what downstream wants.

Thoughts?,I don't understand what this would do. If a downstream doesn't require backpressure (it requests Long.MAX_VALUE) that is either because it wants a firehose and uses temporal control flow, or because it is synchronous and has natural backpressure. 

What use case is this trying to solve?
 =||= I'd like to limit the in-flight events this way, but not block a producer thread or buffer elements. If I need to hand over my Observable to some 3rd party which doesn't care about backpressure, I don't want them to bog down my system because they could process it on full speed. 

Other case could be for batch processing without buffering/blocking; i.e, while I'm working on some batch, I request more work after certain items were processed, so the source can prepare it asynchronously. Now if I'm not the one who subscribes to the stream, I can't switch that Subscriber over to require backpressure.

This could be a symmetric operator to the onBackpressureXYZ (source doesn't know backpressure) vs. applyBackpressure (destination doesn't care about backpressure and you can't make them otherwise).

Of course, I can write such an operator for myself, but I'm hoping this is an useful operator for others.
 =||= I was actually thinking about using something like this for testing of back pressure without always having to use observeOn.
 =||= > hand over my Observable to some 3rd party which doesn't care about backpressure, I don't want them to bog down my system because they could process it on full speed.

Interesting use case. It's like reverse throttling. This basically seems like you're trying to slow down the request rate, correct?

> Other case could be for batch processing without buffering/blocking

I don't see how you do this async fetching without potentially buffering or blocking a thread (just another form of buffering). Even the signature `applyBackpressure(128, 16)` implies buffering of up to 128 items. So how is this done without async behavior (16 fetched at a time while still processing the rest) and without buffering (128 up front)? 

Without involving a time element I don't see how this operator would slow things down since the consumer would still request Long.MAX_VALUE and consume as fast as it can go. Wouldn't it just start requesting 16 at a time as fast as it could go?

It also seems it is not needed to have a separate operator for choosing to batch 16 elements at a time since a source Observable can already choose to fetch in batches of its own arbitrary size while emitting in a push manner. 
 =||= We've got a source Observable, which goes through flatMap('async operations') -> toSeq -> single. It would be useful to limit the number of items in flight at a time to avoid too many of the 'async operations' executing in parallel.

We could use concatMap to limit to one at a time in flight, or there are some other approaches involving buffer or creating a custom operator, but it seems using the operator suggested by @akarnokd could be more elegant?
 =||= > would be useful to limit the number of items in flight at a time to avoid too many of the 'async operations' executing in parallel.

If you are kicking off arbitrary async commands then you can use the `merge` overload that defines `maxConcurrent`: http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(java.lang.Iterable,%20int)

Thus instead of using `flatMap` (which is just `merge(map(func))` you'll manually do "flatmap" like this:

``` java
import static rx.Observable.*;
import rx.schedulers.Schedulers;

public class MergeMaxConcurrent {

    public static void main(String[] args) {
        merge(range(1, 1000000)
                .map(item -> {
                    return just(item)
                            .doOnNext(MergeMaxConcurrent::sleep)
                            .subscribeOn(Schedulers.io());
                }), 10).toBlocking().forEach(System.out::println);
    }

    public static void sleep(int value) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

However, I just realized we have not yet upgraded that variant of `merge` to support backpressure. It was completely missed!

If we upgrade it, it should work. 

Here is the code with logging showing it is not doing backpressure:

``` java
import static rx.Observable.*;
import rx.Observable;
import rx.schedulers.Schedulers;

public class MergeMaxConcurrent {

    public static void main(String[] args) {
        Observable<Observable<Integer>> asyncWork = range(1, 1000000)
                //      .doOnNext(i -> System.out.println("Value: " + i))
                .doOnRequest(r -> System.out.println("request1 " + r))
                .map(item -> {
                    return just(item)
                            .doOnNext(MergeMaxConcurrent::sleep)
                            .subscribeOn(Schedulers.io());
                })
                .doOnRequest(r -> System.out.println("request2 " + r));
        merge(asyncWork, 10).toBlocking().forEach(System.out::println);
    }

    public static void sleep(int value) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```
 =||= Closing because low relevance for now.
 =||= ,0
7027,1920,Gradle build fails due to semver?,Since I pulled the recent changes of 1.0.2 into my Eclipse project, I get a long exception when trying to build via gradlew build or from Eclipse. Switching back to branches of my recent PRs build fine (i.e., AtomicPerf). Any tips.

```
12:26:51.187 [DEBUG] [org.ajoberstar.gradle.git.semver.InferredVersion] Located nearest version: org.ajoberstar.gradle.git.semver.NearestVersion(1.0.2, 1.0.2, 4, 4)
12:26:51.187 [DEBUG] [org.ajoberstar.gradle.git.semver.InferredVersion] Inferred target normal version: 1.0.3
12:26:51.203 [ERROR] [org.gradle.configuration.project.LifecycleProjectEvaluator] Failed to notify ProjectEvaluationListener.afterEvaluate(), but primary configuration failure takes precedence.
org.gradle.listener.ListenerNotificationException: Failed to notify project evaluation listener.
    at org.gradle.listener.BroadcastDispatch.dispatch(BroadcastDispatch.java:94)
    at org.gradle.listener.BroadcastDispatch.dispatch(BroadcastDispatch.java:31)
    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
    at com.sun.proxy.$Proxy12.afterEvaluate(Unknown Source)
    at org.gradle.configuration.project.LifecycleProjectEvaluator.notifyAfterEvaluate(LifecycleProjectEvaluator.java:67)
    at org.gradle.configuration.project.LifecycleProjectEvaluator.evaluate(LifecycleProjectEvaluator.java:61)
    at org.gradle.api.internal.project.AbstractProject.evaluate(AbstractProject.java:493)
    at org.gradle.api.internal.project.AbstractProject.evaluate(AbstractProject.java:80)
    at org.gradle.configuration.DefaultBuildConfigurer.configure(DefaultBuildConfigurer.java:31)
    at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:142)
    at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:113)
    at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:81)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:64)
    at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:33)
    at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:24)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:35)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:26)
    at org.gradle.launcher.cli.RunBuildAction.run(RunBuildAction.java:50)
    at org.gradle.internal.Actions$RunnableActionAdapter.execute(Actions.java:171)
    at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:201)
    at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:174)
    at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:170)
    at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:139)
    at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:33)
    at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:22)
    at org.gradle.launcher.Main.doAction(Main.java:46)
    at org.gradle.launcher.bootstrap.EntryPoint.run(EntryPoint.java:45)
    at org.gradle.launcher.Main.main(Main.java:37)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.launcher.bootstrap.ProcessBootstrap.runNoExit(ProcessBootstrap.java:50)
    at org.gradle.launcher.bootstrap.ProcessBootstrap.run(ProcessBootstrap.java:32)
    at org.gradle.launcher.GradleMain.main(GradleMain.java:23)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.wrapper.BootstrapMainStarter.start(BootstrapMainStarter.java:33)
    at org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:130)
    at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:48)
Cause 1: Unexpected element '_', expecting '[DIGIT, LETTER, HYPHEN]'
    at com.github.zafarkhaja.semver.util.Stream.consume(Stream.java:115)
    at com.github.zafarkhaja.semver.VersionParser.alphanumericIdentifier(VersionParser.java:388)
    at com.github.zafarkhaja.semver.VersionParser.parseBuild(VersionParser.java:334)
    at com.github.zafarkhaja.semver.VersionParser.parseBuild(VersionParser.java:210)
    at com.github.zafarkhaja.semver.Version.setBuildMetadata(Version.java:387)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSiteNoUnwrap.invoke(PojoMetaMethodSite.java:210)
    at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
    at org.ajoberstar.gradle.git.semver.InferredVersion.infer(InferredVersion.groovy:175)
    at org.ajoberstar.gradle.git.semver.InferredVersion$infer$1.callCurrent(Unknown Source)
    at org.ajoberstar.gradle.git.semver.InferredVersion.infer(InferredVersion.groovy:136)
    at org.ajoberstar.gradle.git.semver.InferredVersion$infer$0.callCurrent(Unknown Source)
    at org.ajoberstar.gradle.git.semver.InferredVersion.infer(InferredVersion.groovy:126)
    at org.ajoberstar.gradle.git.semver.InferredVersion$infer.callCurrent(Unknown Source)
    at org.ajoberstar.gradle.git.semver.InferredVersion.toString(InferredVersion.groovy:256)
    at org.gradle.api.internal.artifacts.ProjectBackedModule.getVersion(ProjectBackedModule.java:38)
    at org.gradle.api.publish.maven.plugins.MavenPublishPlugin$MavenPublicationFactory.create(MavenPublishPlugin.java:100)
    at org.gradle.api.publish.maven.plugins.MavenPublishPlugin$MavenPublicationFactory.create(MavenPublishPlugin.java:86)
    at org.gradle.api.internal.DefaultPolymorphicDomainObjectContainer.doCreate(DefaultPolymorphicDomainObjectContainer.java:61)
    at org.gradle.api.internal.AbstractPolymorphicDomainObjectContainer.create(AbstractPolymorphicDomainObjectContainer.java:63)
    at org.gradle.api.internal.AbstractPolymorphicDomainObjectContainer.create(AbstractPolymorphicDomainObjectContainer.java:50)
    at org.gradle.api.PolymorphicDomainObjectContainer$create.call(Unknown Source)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
    at nebula.plugin.publishing.maven.NebulaMavenPublishingPlugin$1.execute(NebulaMavenPublishingPlugin.groovy:78)
    at nebula.plugin.publishing.maven.NebulaMavenPublishingPlugin$1.execute(NebulaMavenPublishingPlugin.groovy)
    at org.gradle.listener.ActionBroadcast.execute(ActionBroadcast.java:39)
    at org.gradle.api.internal.plugins.ExtensionsStorage$DeferredConfigurableExtensionHolder.configureNow(ExtensionsStorage.java:183)
    at org.gradle.api.internal.plugins.ExtensionsStorage$DeferredConfigurableExtensionHolder.get(ExtensionsStorage.java:162)
    at org.gradle.api.internal.plugins.ExtensionsStorage.getByType(ExtensionsStorage.java:77)
    at org.gradle.api.internal.plugins.DefaultConvention.getByType(DefaultConvention.java:122)
    at org.gradle.api.plugins.ExtensionContainer$getByType.call(Unknown Source)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
    at nebula.plugin.publishing.maven.NebulaBaseMavenPublishingPlugin$_withMavenPublication_closure4_closure9.doCall(NebulaBaseMavenPublishingPlugin.groovy:73)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:877)
    at groovy.lang.Closure.call(Closure.java:412)
    at groovy.lang.Closure.call(Closure.java:425)
    at org.gradle.api.internal.ClosureBackedAction.execute(ClosureBackedAction.java:58)
    at org.gradle.internal.Actions$FilteredAction.execute(Actions.java:203)
    at org.gradle.api.internal.DefaultDomainObjectCollection.all(DefaultDomainObjectCollection.java:110)
    at org.gradle.api.internal.DefaultDomainObjectCollection.all(DefaultDomainObjectCollection.java:115)
    at org.gradle.api.internal.DefaultDomainObjectCollection.withType(DefaultDomainObjectCollection.java:126)
    at org.gradle.api.DomainObjectCollection$withType.call(Unknown Source)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
    at nebula.plugin.publishing.maven.NebulaBaseMavenPublishingPlugin$_withMavenPublication_closure4.doCall(NebulaBaseMavenPublishingPlugin.groovy:72)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:877)
    at groovy.lang.Closure.call(Closure.java:412)
    at org.gradle.listener.ClosureBackedMethodInvocationDispatch.dispatch(ClosureBackedMethodInvocationDispatch.java:40)
    at org.gradle.listener.ClosureBackedMethodInvocationDispatch.dispatch(ClosureBackedMethodInvocationDispatch.java:25)
    at org.gradle.listener.BroadcastDispatch.dispatch(BroadcastDispatch.java:83)
    at org.gradle.listener.BroadcastDispatch.dispatch(BroadcastDispatch.java:31)
    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
    at com.sun.proxy.$Proxy12.afterEvaluate(Unknown Source)
    at org.gradle.configuration.project.LifecycleProjectEvaluator.notifyAfterEvaluate(LifecycleProjectEvaluator.java:67)
    at org.gradle.configuration.project.LifecycleProjectEvaluator.evaluate(LifecycleProjectEvaluator.java:61)
    at org.gradle.api.internal.project.AbstractProject.evaluate(AbstractProject.java:493)
    at org.gradle.api.internal.project.AbstractProject.evaluate(AbstractProject.java:80)
    at org.gradle.configuration.DefaultBuildConfigurer.configure(DefaultBuildConfigurer.java:31)
    at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:142)
    at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:113)
    at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:81)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:64)
    at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:33)
    at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:24)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:35)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:26)
    at org.gradle.launcher.cli.RunBuildAction.run(RunBuildAction.java:50)
    at org.gradle.internal.Actions$RunnableActionAdapter.execute(Actions.java:171)
    at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:201)
    at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:174)
    at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:170)
    at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:139)
    at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:33)
    at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:22)
    at org.gradle.launcher.Main.doAction(Main.java:46)
    at org.gradle.launcher.bootstrap.EntryPoint.run(EntryPoint.java:45)
    at org.gradle.launcher.Main.main(Main.java:37)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.launcher.bootstrap.ProcessBootstrap.runNoExit(ProcessBootstrap.java:50)
    at org.gradle.launcher.bootstrap.ProcessBootstrap.run(ProcessBootstrap.java:32)
    at org.gradle.launcher.GradleMain.main(GradleMain.java:23)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.wrapper.BootstrapMainStarter.start(BootstrapMainStarter.java:33)
    at org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:130)
    at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:48)
```,Never mind. It appears having an underscore in the branch name messes up things.
 =||= ,0
7027,1013,[scala] PublishSubject is inaccessible,``` scala
private [scala] object PublishSubject {
  def apply[T](): PublishSubject[T] =  new PublishSubject[T](rx.subjects.PublishSubject.create[T]())
}
```

There's no way to create it. I believe this object should be public?,Publish subject is the default subject and can be accessed via:

```
rx.lang.scala.Subject
```

See: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subject.scala
 =||= Still, what is the point of preventing access?

On April 12, 2014 11:38:22 AM EEST, Ross Lawley notifications@github.com wrote:

> Publish subject is the default subject and can be accessed via:
> 
>    rx.lang.scala.Subject
> 
> See:
> https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subject.scala
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Netflix/RxJava/issues/1013#issuecomment-40275240

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.
 =||= Access is not at all prevented, just a different name, leveraging the fact that Scala has traits; in .NET: ISubject --> Subject, in RxJava: Subject --> PublishSubject, in Scala: Subject. 
 =||= It is not prevented per se, but is awfully counterintuitive. I looked up the appropriate subject type from github docs, try to create it and can't while all the other type of subjects can be instantiated.

And I don't see how this serves any purpose. Lets say PublishSubject can be instantiated via its object and not Subject object. What is the downside of that?

The downside of current situation is that you get confused people like me. I guess there should be an upside to that as well, but I don't see it. Could you point it out?

On April 12, 2014 12:28:12 PM EEST, headinthebox notifications@github.com wrote:

> Access is not at all prevented, just a different name, leveraging the
> fact that Scala has traits; in .NET: ISubject --> Subject, in RxJava:
> Subject --> PublishSubject, in Scala: Subject. 
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Netflix/RxJava/issues/1013#issuecomment-40276043

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.
 =||= One type instead of two. Less is better. Same for Subscriptions. The fact that we are forced to call Subject "PublishSubject" in RxJava is just horrible. Names are the most precious resource in designing APIs.
 =||= Ok, it's your project so it's your call.

However the least that can be done is a comment in code and docs that in scala PublishSubject needs to be instantiated via Subject.

Do you agree?

On April 12, 2014 12:54:37 PM EEST, headinthebox notifications@github.com wrote:

> One type instead of two. Less is better. Same for Subscriptions. The
> fact that we are forced to call Subject "PublishSubject" in RxJava is
> just horrible. Names are the most precious resource in designing APIs.
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Netflix/RxJava/issues/1013#issuecomment-40276479

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.
 =||= Makes sense; but IMHO ideally, you should consider the Scala API by itself, not mirroring it to the RxJava one. Same for all other languages such as Rx .NET, RxJS, ... What is called Foo there can be called Baz here. Case in point Select <-> map, or Where <-> filter, or Subject <-> PublishSubject.  
 =||= Yes, but I tried to find scala docs for subjects and couldn't find them.

If they exist they need better visibility. Perhaps a link in the wiki near each section?

On April 12, 2014 1:48:29 PM EEST, headinthebox notifications@github.com wrote:

> Makes sense; but IMHO ideally, you should consider the Scala API by
> itself, not mirroring it to the RxJava one. Same for all other
> languages such as Rx .NET, RxJS, ... What is called Foo there can be
> called Baz here. Case in point Select <-> map, or Where <-> filter, or
> Subject <-> PublishSubject.  
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Netflix/RxJava/issues/1013#issuecomment-40277392

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.
 =||= I agree with @arturaz, I didn't find anything that would imply that `Subject` -> `PublishSubject`. I'm not a Scala architecture expert so I can't provide much input in that respect, all I can say is, from a user standpoint, it was a bit confusing seeing that all the other `Subject`s had public access while `PublishSubject` didn't. I guess I could've looked in the scala package instead of the scala.subjects package. Just my $0.02.
 =||= Done in https://github.com/Netflix/RxJava/pull/1216
 =||= ,0
7027,1958,sample/throttleLast doesn't call unsubscribe,In the following code, I would expect the "cleanup" message to be printed three times, but on the last case (o1.throttleLast(...)) it isn't.

``` groovy
 def o = rx.Observable.create({ subscriber ->
        subscriber.add(Subscriptions.create({ println "cleanup" }))
    })

    o.subscribe({})
        .unsubscribe() // prints

    o.take(1)
        .subscribe({})
        .unsubscribe();  // prints

    o.throttleLast(1, TimeUnit.MILLISECONDS)
        .subscribe({})
        .unsubscribe() // doesn't print
```

Reported by juanedi in http://stackoverflow.com/questions/27428757/unsubscriptions-not-cascading-back-to-base-observable-in-rxjava,nan,0
7027,1908,Pursue Elimination of RingBuffer Pooling,The use of object pooling significantly complicates the `unsubscribe` behavior and when it is safe to release. This issue is to track research on how we can eliminate pooling to improve or fix correctness while still maintaining good performance (and memory allocation and GC behavior).

The `merge` and `observeOn` use cases are good to track performance and already have JMH benchmarks in place. 

Here is how to run the tests:

```
./gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*OperatorMergePerf.*'
./gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*OperatorObserveOnPerf.*'
```

Here are results for `merge` and `observeOn` comparing use of pooled `SpmcArrayQueue` vs `SynchronizedQueue` (a synchronized LinkedList).

The `**` markers indicate where performance degradation happened.

```
Merge

Benchmark                                          (size)   Mode   Samples   RingBuffer  ||   LinkedList
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5448592.507  ||  5332264.735    5358807.217
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    54425.611  ||    52385.763      52409.485
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       52.477  ||       53.928         54.128
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    92792.488  ||   103554.112     104711.192
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.957  ||        4.194          4.143
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4608856.070  ||  4294087.613    4688656.691
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   431920.261  ||   451007.165     333391.274**
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    52309.410  ||    49952.664      50057.346
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5815289.623  ||  5558593.305    5575812.189
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       52.525  ||       49.788         49.567
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    77640.706  ||    79530.128      79472.088
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3000.748  ||     2358.716**     2397.035**
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5397752.619  ||  5282943.171    5361848.221
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    29257.005  ||    34150.793      35196.066
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.506  ||       25.827**       26.517**
```

```
ObserveOn

Benchmark                                         (size)   Mode   Samples   RingBuffer  ||    LinkedList       LinkedList
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5   109192.288  ||    111037.202       110112.152
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     6952.955  ||      2846.331**       2821.400**
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       12.267  ||         9.988**         10.063**
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 16430666.170  ||  16284869.881     16504292.796
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   153431.778  ||    158892.599       157288.399
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      150.061  ||       159.481          149.546
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    16899.056  ||     16111.396        16532.411
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     7262.566  ||      5742.547**       5504.293**
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       13.520  ||        10.364**          9.954**
```

The `SynchronizedQueue` was only ever intended for use by environments without `sun.misc.Unsafe` (such as Android) so it is worth exploring other alternatives that don't involve a ring buffer (and allocation overhead) but are thread-safe for the single-produce-multi-consumer use cases the RxRingBuffer is used in (and then rename to RxQueue or something like that).,Possible linked list implementations:
- https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/MpscLinkedQueue.java
- https://github.com/JCTools/JCTools/issues/39
 =||= Here are some tests with `MpscLinkedQueue` and `SpscLinkedQueue` with `merge` and `observeOn`.

```
Merge

Benchmark                                          (size)   Mode   Samples  SpmcArrayQueue  ||     Synchronized LinkedList    ||  MpscLinkedQueue7^
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5     5448592.507  ||  5332264.735    5358807.217    ||       5280793.113
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5       54425.611  ||    52385.763      52409.485    ||         51982.505
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5          52.477  ||       53.928         54.128    ||            59.971
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5       92792.488  ||   103554.112     104711.192    ||        104769.406
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5           4.957  ||        4.194          4.143    ||             4.750
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5     4608856.070  ||  4294087.613    4688656.691    ||       4274735.897
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5      431920.261  ||   451007.165     333391.274**  ||        440251.858
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5       52309.410  ||    49952.664      50057.346    ||         49188.282
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5     5815289.623  ||  5558593.305    5575812.189    ||       5576949.872
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5          52.525  ||       49.788         49.567    ||            51.102
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5       77640.706  ||    79530.128      79472.088    ||         75433.006
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5        3000.748  ||     2358.716**     2397.035**  ||          2881.911
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5     5397752.619  ||  5282943.171    5361848.221    ||       5445358.040
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5       29257.005  ||    34150.793      35196.066    ||         34305.563
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5          35.506  ||       25.827**       26.517**  ||            33.594

^MpscLinkedQueue7 => This can be used by merge and observeOn.  Currently unbounded and needs to be bounded.



ObserveOn


Benchmark                                         (size)   Mode   Samples SpmcArrayQueue  ||        Synchronized LinkedList    || MpscLinkedQueue7^ || SpscLinkedQueue^
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5     109192.288  ||    111037.202       110112.152    ||       106683.693  ||      109647.796
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5       6952.955  ||      2846.331**       2821.400**  ||         6280.963  ||        7117.558
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5         12.267  ||         9.988**         10.063**  ||           12.667  ||          13.786
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5   16430666.170  ||  16284869.881     16504292.796    ||     15826734.130  ||    16052912.021
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5     153431.778  ||    158892.599       157288.399    ||       153065.062  ||      155336.587
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5        150.061  ||       159.481          149.546    ||          153.177  ||         152.810
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5      16899.056  ||     16111.396        16532.411    ||        14405.399  ||       15836.574
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5       7262.566  ||      5742.547**       5504.293**  ||         7081.180  ||        8112.809
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5         13.520  ||        10.364**          9.954**  ||           12.881  ||          14.937


^MpscLinkedQueue7 => This could be used since observeOn supports single-consumer. Currently unbounded and needs to be bounded.
^SpscLinkedQueue7 => This could be used since observeOn supports single-producer, single-consumer. Currently unbounded and needs to be bounded.
```

JMC while running `merge` tests for 60 seconds:

![screen shot 2014-11-29 at 8 47 43 pm](https://cloud.githubusercontent.com/assets/813492/5236831/3006bb10-7809-11e4-98dc-0c2c78749187.png)

We can't use these queues as-is since they are single-consumer and we need multi-consumer for `merge`. Also, `observeOn` is showing some test failures. 

However, the results do suggest that we can get a data structure to achieve performance without object pooling. 
 =||= Here is an example of what we don't want as far as object-allocation.

`observeOn` using JCTools linked list (good):

![observeon-jctools-linkedlist](https://cloud.githubusercontent.com/assets/813492/5236838/e082ccea-7809-11e4-88eb-d0b439df8d27.png)

`observeOn` using JCTools array queue without pooling (bad):

![observeon-jctools-arrayqueue](https://cloud.githubusercontent.com/assets/813492/5236839/ece56a10-7809-11e4-964c-6372a3e0eb97.png)

Note the massive object allocation.
 =||= It's quite odd Spsc is failing since everything should be serialized, i.e., only 1 thread offering values to the internal queues at a time and only 1 thread collecting from all queues, right? Thread hopping should not affect Spsc. I can only speculate, but when I did some backpressure-related code lately, I often didn't get the consumption phase right at first: the case where upstream produces and downstream requests at the same time, both may end up in the drain loop. This is why I used the emitting flag in onBackpressureBlock or in backpressure-aware ReplaySubject.
 =||= Yes it should work and the other spsc/mpsc queue impls work so it suggests an issue with those impls (they aren't yet officially released). 
 =||= @benjchristensen with which params are you running jmh + jfr?
 =||= I manually attach JFR after the test passes the warmup and hits the first iteration. I increase the integration time to some longer number (been doing 25 seconds) so it runs far longer than the 60 seconds I capture via JFR.

```
./gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 25 .*OperatorObserveOnPerf.*'
```

I start flight recording when the first iteration starts:

```
# Run progress: 0.00% complete, ETA 00:19:30
# Warmup: 5 iterations, 1 s each
# Measurement: 5 iterations, 25 s each
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: rx.operators.OperatorObserveOnPerf.observeOnComputation
# Parameters: (size = 1)
# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/bin/java
# VM options: -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -Xmx512m -Dfile.encoding=UTF-8
# Fork: 1 of 1
# Warmup Iteration   1: 76564.389 ops/s
# Warmup Iteration   2: 105044.060 ops/s
# Warmup Iteration   3: 108520.068 ops/s
# Warmup Iteration   4: 108104.151 ops/s
# Warmup Iteration   5: 109615.544 ops/s
Iteration   1:
```

![screen shot 2014-11-30 at 11 03 48 am](https://cloud.githubusercontent.com/assets/813492/5238883/b02797e8-7880-11e4-94df-f71ec1ae27aa.png)

![screen shot 2014-11-30 at 11 03 56 am](https://cloud.githubusercontent.com/assets/813492/5238885/bdca1efc-7880-11e4-8c9e-5b5bd32e9213.png)
 =||= > some unit tests failing with this that need to be debugged

Just a silly oversight on my part. These are unbounded queues and our use cases requires them to be bounded. Thus, the `offer` never returns false so we never hit the backpressure exception:

``` java
        if (!queue.offer(on.next(o))) {
            throw new MissingBackpressureException();
        }
```

If we use one of these unbounded queues we'll need to add the overhead of tracking the size, or modify the queue implementation to correctly do that for us. 
 =||= ConcurrentLinkedQueue takes a performance hit compared with the JCTools implementations for `observeOn`:

```
ObserveOn

Benchmark                                         (size)  SpmcArrayQueue  ||   ConcurrentLinkedQueue
r.o.OperatorObserveOnPerf.observeOnComputation         1      109192.288  ||              110221.988
r.o.OperatorObserveOnPerf.observeOnComputation      1000        6952.955  ||                6016.298**
r.o.OperatorObserveOnPerf.observeOnComputation   1000000          12.267  ||                  10.748**
r.o.OperatorObserveOnPerf.observeOnImmediate           1    16430666.170  ||            16245304.118
r.o.OperatorObserveOnPerf.observeOnImmediate        1000      153431.778  ||              156059.398
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000         150.061  ||                 155.667
r.o.OperatorObserveOnPerf.observeOnNewThread           1       16899.056  ||               16700.144
r.o.OperatorObserveOnPerf.observeOnNewThread        1000        7262.566  ||                6813.449**
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000          13.520  ||                  10.655**
```

It's okay for `merge`:

```
Benchmark                                          (size)  SpmcArrayQueue  ||  MpscLinkedQueue7^  ||  ConcurrentLinkedQueue
r.o.OperatorMergePerf.merge1SyncStreamOfN               1     5448592.507  ||       5280793.113   ||            5292601.594
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000       54425.611  ||         51982.505   ||              51990.637
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000          52.477  ||            59.971   ||                 59.967
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1       92792.488  ||        104769.406   ||             103669.636
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000           4.957  ||             4.750   ||                  4.074
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1     4608856.070  ||       4274735.897   ||            4360997.158
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100      431920.261  ||        440251.858   ||             438544.154
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000       52309.410  ||         49188.282   ||              49382.440
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1     5815289.623  ||       5576949.872   ||            5577426.641
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000          52.525  ||            51.102   ||                 49.899
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1       77640.706  ||         75433.006   ||              78623.524
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000        3000.748  ||          2881.911   ||               2696.428
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1     5397752.619  ||       5445358.040   ||            5346115.873
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000       29257.005  ||         34305.563   ||              34051.746
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000          35.506  ||            33.594   ||                 35.157
```
 =||= I modified `RxRingBuffer` to use its own counter for bounding the links lists and am now using `SpscLinkedQueue`

The only unit test failing is `RxRingBufferSpmcTest.testConcurrency` which is a valid failure since I am only using an spsc queue.

Scroll to the right to see the `SpscLinkedQueue+Size` values:

```
Merge

Benchmark                                          (size)  SpmcArrayQueue  ||     Synchronized LinkedList    ||  MpscLinkedQueue7^  ||  ConcurrentLinkedQueue  || SpscLinkedQueue+Size
r.o.OperatorMergePerf.merge1SyncStreamOfN               1     5448592.507  ||  5332264.735    5358807.217    ||       5280793.113   ||            5292601.594  ||          5332726.909
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000       54425.611  ||    52385.763      52409.485    ||         51982.505   ||              51990.637  ||            49268.224
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000          52.477  ||       53.928         54.128    ||            59.971   ||                 59.967  ||               50.742
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1       92792.488  ||   103554.112     104711.192    ||        104769.406   ||             103669.636  ||           104210.342
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000           4.957  ||        4.194          4.143    ||             4.750   ||                  4.074  ||                4.688
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1     4608856.070  ||  4294087.613    4688656.691    ||       4274735.897   ||            4360997.158  ||          4888816.598
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100      431920.261  ||   451007.165     333391.274**  ||        440251.858   ||             438544.154  ||           445969.294
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000       52309.410  ||    49952.664      50057.346    ||         49188.282   ||              49382.440  ||            49817.351
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1     5815289.623  ||  5558593.305    5575812.189    ||       5576949.872   ||            5577426.641  ||          5707051.084
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000          52.525  ||       49.788         49.567    ||            51.102   ||                 49.899  ||               43.819**
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1       77640.706  ||    79530.128      79472.088    ||         75433.006   ||              78623.524  ||            78480.286
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000        3000.748  ||     2358.716**     2397.035**  ||          2881.911   ||               2696.428  ||             2627.181*
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1     5397752.619  ||  5282943.171    5361848.221    ||       5445358.040   ||            5346115.873  ||          5352179.516
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000       29257.005  ||    34150.793      35196.066    ||         34305.563   ||              34051.746  ||            35081.657
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000          35.506  ||       25.827**       26.517**  ||            33.594   ||                 35.157  ||               35.378


^MpscLinkedQueue7 => This can be used by merge and observeOn.  Currently unbounded and needs to be bounded.



ObserveOn


Benchmark                                         (size)  SpmcArrayQueue  ||        Synchronized LinkedList    || MpscLinkedQueue7^ || SpscLinkedQueue^  || ConcurrentLinkedQueue   || SpscLinkedQueue+Size
r.o.OperatorObserveOnPerf.observeOnComputation         1      109192.288  ||    111037.202       110112.152    ||       106683.693  ||      109647.796   ||            110221.988   ||           105952.032
r.o.OperatorObserveOnPerf.observeOnComputation      1000        6952.955  ||      2846.331**       2821.400**  ||         6280.963  ||        7117.558   ||              6016.298** ||             6615.249
r.o.OperatorObserveOnPerf.observeOnComputation   1000000          12.267  ||         9.988**         10.063**  ||           12.667  ||          13.786   ||                10.748** ||               11.381
r.o.OperatorObserveOnPerf.observeOnImmediate           1    16430666.170  ||  16284869.881     16504292.796    ||     15826734.130  ||    16052912.021   ||          16245304.118   ||         16294413.530
r.o.OperatorObserveOnPerf.observeOnImmediate        1000      153431.778  ||    158892.599       157288.399    ||       153065.062  ||      155336.587   ||            156059.398   ||           157113.031
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000         150.061  ||       159.481          149.546    ||          153.177  ||         152.810   ||               155.667   ||              157.675
r.o.OperatorObserveOnPerf.observeOnNewThread           1       16899.056  ||     16111.396        16532.411    ||        14405.399  ||       15836.574   ||             16700.144   ||            15718.673
r.o.OperatorObserveOnPerf.observeOnNewThread        1000        7262.566  ||      5742.547**       5504.293**  ||         7081.180  ||        8112.809   ||              6813.449** ||             7248.917
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000          13.520  ||        10.364**          9.954**  ||           12.881  ||          14.937   ||                10.655** ||               12.344


^MpscLinkedQueue7 => This could be used since observeOn supports single-consumer. Currently unbounded and needs to be bounded.
^SpscLinkedQueue7 => This could be used since observeOn supports single-producer, single-consumer. Currently unbounded and needs to be bounded.
```

observeOn Flight Recorder

1.0.1

![observeon-1 0 1](https://cloud.githubusercontent.com/assets/813492/5239162/be5d01a8-788b-11e4-9fbf-93324edb3691.png)

Modified to use SPSC Linked List

![observeon-spsc](https://cloud.githubusercontent.com/assets/813492/5239164/c7513a7c-788b-11e4-8840-0e169da74f62.png)

merge Flight Recorder

1.0.1

![merge-1 0 1](https://cloud.githubusercontent.com/assets/813492/5239166/d8dd8944-788b-11e4-96d4-85c39259a418.png)

Modified to use SPSC Linked List

![merge-spsc](https://cloud.githubusercontent.com/assets/813492/5239165/d716f726-788b-11e4-8953-440768dfa2a9.png)

The flight recorder stuff, particularly for `merge` needs more evaluation. 

It does seem though that the trade-offs in performance and object allocation are not severe and thus probably warrants the change to allow avoiding object pooling. 

I'll submit a PR with the changes for evaluation and further experimentation. 
 =||= PR https://github.com/ReactiveX/RxJava/pull/1909 contains the code for the previous perf tests. 
 =||= A note while we're working on this ... whatever decision we make here I think should target 1.1 since it will affect memory and GC behavior so is larger than a patch. 

I also want to give enough time to really think through this ... sleeping on whatever solutions we work on since this is very nuanced and the tradeoffs need to be thought through. 
 =||= I've been exploring weak and phantom references tonight while exploring whether it's possible to continue using object pooling but without manual release. I have it working, and performance is good, but at high velocity on JMH tests the ReferenceQueue is filling up in an unbounded manner. 

Anyone have good experience using WeakReferences for an object pool with high throughput? 

I wish there was a better way to get a callback from the WeakReference than it being put into a ReferenceQueue.
 =||= The problem with pooling is that it can now become the congestion point: multiple threads might want to grab an element from the pool at the same time.

The alternative is reference counting:

``` java
public void onNext(Object o) {
   Queue<Object> q = queue;
   if (q != null && q.acquire()) { // i.e., cas 1 -> 2
      q.offer(o);
      q.release(); // i.e., decrementAndGet
   }
}
public void unsubscribe() {
   Queue<Object> q = queue;
   if (q != null) {
        queue = null;
        q.release();
   } 
}
```

Could be achieved via AtomicInteger. When borrowed, the queue starts out in 1. Use toggles this between 1 and 2. If an unsubscription happens, the party that goes from 1 to 0 will put the queue back into the pool. The drawback is that now you have extra bookkeeping which may halve the throughput in RxRingBufferPerf.
 =||= > The problem with pooling is that it can now become the congestion point: multiple threads might want to grab an element from the pool at the same time.

Sure, but if it's a concurrent queue, which it is, then that contention should not be severe. It's using an `MpmcArrayQueue` optimized for performance. 

I agree it is a point of contention, but if that contention is cheaper than the object allocation/collection then it's a net win. 

> reference counting

This could work but is effectively synchronizing unsubscribe and queue usage (cheaper than mutex, but still a form of synchronizing) which definitely has a cost, both performance and cognitive every time this queue is used. Hence us pursuing either a solution that doesn't need to be pooled, or my pursuit of weak references so the release to the pool is automated. 
 =||= I think false sharing isn't really an issue by us because how te queus are used: the producer is likely to win the drain race and emit data, or the queue is practically full and only 1 element is put for each 1 element taken (request(1) in merge and observeOn) and the two sides are far away to each other and no false sharing happens. So an unpadded queue of 128 capacity takes up 1024+16+32 bytes nicely fitting in L1. The padded version takes 65k.
 =||= I have some some benchmarking on different solutions that have been posted, including removing the pooling altogether and here are the numbers. Note that we now have a queue size of 128, not 1024 like we used to.

```
Benchmark                                                                 (nextRuns)  (size)            1.x                   No Pool          2PhaseArrayQueue    branch rxqueue-spsc 
r.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A     100     288851.474  |    464395.527  161% ++  |    288585.686  100%    |    128859.372 45% --
r.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A   10000       1053.102  |      1122.418  107%     |       988.942  94%     |      1033.768 98%
r.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A     100     130035.705  |    219530.470  169% ++  |    129688.488  100%    |    122350.438 94%
r.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A   10000        394.109  |       408.761  104%     |       372.060  94%     |       382.935 97%
r.internal.RxRingBufferPerf.spmcCreateUseAndDestroy1                             N/A     N/A   26400373.503  |   4011739.109  15% --   |   3904652.414  15% --  |  10354119.555 39% --
r.internal.RxRingBufferPerf.spmcRingBufferAddRemove1                             N/A     N/A   41947289.772  |  40889056.084  97%      | 167128945.622  398% ++ |  39302492.472 94%
r.internal.RxRingBufferPerf.spscCreateUseAndDestroy1                             N/A     N/A   26625817.275  |   4041119.853  15% --   |  10543005.986  40% --  |   9844380.252 37% --
r.internal.RxRingBufferPerf.spscRingBufferAddRemove1                             N/A     N/A   42376557.425  |  39384117.892  93%      |  50678693.611  120% ++ |  40440515.140 95%
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A       1     323419.496  |    314150.913  97%      |    306704.864  95%     |     56413.217 17% --
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A    1000        325.685  |       320.644  98%      |       312.976  96%     |        75.440 23% --
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A 1000000          0.318  |         0.318  100%     |         0.311  98%     |         0.066 21% --
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A       1    5544570.553  |   5634853.059  102%     |   5355739.382  97%     |   1276719.950 23% --
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A    1000      37510.701  |     37428.777  100%     |     37971.972  101%    |      8511.690 23% --
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A 1000000         32.831  |        33.133  101%     |        33.224  101%    |         7.466 23% --
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A       1    4081082.521  |   3988577.555  98%      |   3855453.808  94%     |    892951.263 22% --
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A    1000      26194.758  |     26060.788  99%      |     24783.878  95%     |      5014.843 19% -- 
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A 1000000         24.255  |        24.638  102%     |        22.923  95%     |         5.212 21% --
r.operators.OperatorMapPerf.mapPassThru                                          N/A       1   24413615.697  |  24572501.107  101%     |  24135623.277  99%     |   5882139.319 24% --
r.operators.OperatorMapPerf.mapPassThru                                          N/A    1000     126022.367  |    126928.122  101%     |    121905.819  97%     |     31068.374 25% --
r.operators.OperatorMapPerf.mapPassThru                                          N/A 1000000        125.726  |       133.165  106%     |       125.238  100%    |        32.079 26% --
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A       1   26830181.693  |  26855829.721  100%     |  26402665.260  98%     |   6974887.323 26% --
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A    1000     126998.154  |    127883.467  101%     |    124275.543  98%     |     29430.411 23% --
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A 1000000        132.249  |       132.858  100%     |       130.028  98%     |       105.182 80% --
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A       1    5004527.084  |   5096505.217  102%     |   4913306.706  98%     |   4565544.618 91%
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A    1000      52723.842  |     51944.534  99%      |     44783.449  85% --  |     38827.856 74% --
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A 1000000         49.928  |        49.643  99%      |        47.285  95%     |        42.332 85% --
r.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A       1      99724.243  |     96046.578  96%      |     97233.505  98%     |     98970.453 99%
r.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A    1000          4.661  |         5.085  109%     |         4.688  101%    |         4.727 101%
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A       1    4543776.401  |   4562256.139  100%     |   4626141.577  102%    |   4550596.577 100%
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A     100     482015.536  |    481347.669  100%     |    477687.006  99%     |    474884.635 99%
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A    1000      52102.762  |     52212.844  100%     |     50536.678  97%     |     55255.898 106%
r.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A       1    5182887.347  |   4926496.569  95%      |   5160628.853  100%    |   5043255.904 97%
r.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A    1000         52.055  |        51.914  100%     |        48.084  92%     |        46.567 89% --
r.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A       1      76604.876  |     74224.276  97%      |     71937.709  94%     |     77366.844 101%
r.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A    1000       3166.341  |      3130.021  99%      |      3295.517  104%    |      2541.420 80% --
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A       1    5276030.387  |   5048453.291  96%      |   4806177.849  91%     |   4935148.406 94%
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A    1000      37197.231  |     37647.410  101%     |     38406.161  103%    |     36161.836 97%
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A 1000000         34.649  |        34.124  98%      |        34.025  98%     |        32.754 95%
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A       1     107207.970  |    100380.298  94%      |    108474.884  101%    |    105535.982 98%
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A    1000       6517.902  |      6869.709  105%     |      6371.416  98%     |      6301.948 97%
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A 1000000         13.670  |        13.580  99%      |        11.346  83% --  |        11.305 83% --
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A       1   15245087.895  |  14962479.384  98%      |  14997783.368  98%     |  14673057.780 96%
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A    1000     178513.653  |    173023.234  97%      |    170021.413  95%     |    164929.922 92%
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A 1000000        157.016  |       152.469  97%      |       154.095  98%     |       144.408 92%
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A       1      16879.424  |     15716.151  93%      |     15426.649  91%     |     14689.995 87% --
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A    1000       7783.654  |      7765.427  100%     |      6734.649  87%     |      7173.622 92%
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A 1000000         13.153  |        14.191  108%     |        11.650  89%     |        11.275 86% --
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A       1   25332343.625  |  25065988.234  99%      |  24342054.885  96%     |  25262395.598 100%
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A    1000     116819.629  |    116739.463  100%     |    113936.110  98%     |    115857.556 99%
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A 1000000        135.843  |       134.416  99%      |       130.710  96%     |       134.943 99%
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A       1  121325903.567  | 118002649.957  97%      | 112020450.304  92%     | 104636361.664 86% --
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A    1000     186533.260  |    187334.419  100%     |    185695.013  100%    |    179519.340 96%
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A 1000000        166.914  |       169.448  102%     |       160.806  96%     |       158.203 95%
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A       1   18921314.555  |  18257594.271  96%      |  18853324.397  100%    |  18123044.637 96%
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A    1000     269546.032  |    228423.425  85% --   |    266431.946  99%     |    248808.733 92%
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A 1000000        260.990  |       254.223  97%      |       253.943  97%     |       235.045 90% --
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A       1   10736813.240  |  10037561.783  93%      |   9935098.948  93%     |   9663588.470 90% --
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A    1000      79767.255  |     67068.394  84% --   |     66532.316  83% --  |     64151.866 80% --
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A 1000000         70.840  |        75.120  106%     |        73.776  104%    |        72.247 102%
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A       1     111389.498  |    110210.985  99%      |    110774.637  99%     |    106648.746 96%
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A    1000       7575.618  |      7207.681  95%      |      7189.025  95%     |      7175.698 95%
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A 1000000          9.196  |         9.864  107%     |         8.714  95%     |         9.383 102%
r.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A       1      83396.077  |     78874.484  95%      |     81866.626  98%     |     78901.924 95%
r.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A    1000      36273.839  |     34303.562  95%      |     35859.978  99%     |     34513.093 95%
r.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A       1      55607.010  |     53946.317  97%      |     55332.808  100%    |     51419.088 92%
r.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A    1000      53468.342  |     53613.934  100%     |     53089.878  99%     |     52291.141 98%
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A       1     107083.283  |    106172.060  99%      |    109756.005  102%    |    108969.564 102%
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A      10     103095.692  |    102757.452  100%     |    102707.186  100%    |     99579.238 97%
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A     100      37921.038  |     39183.046  103%     |     34085.675  90%     |     32331.879 85% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    1000       6776.178  |      7015.656  104%     |      6289.376  93%     |      6384.900 94%
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    2000       4851.628  |      4828.700  100%     |      4212.292  87%     |      4354.948 90% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    3000       3754.394  |      3778.104  101%     |      2961.396  79%     |      3207.050 85% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    4000       2994.907  |      2949.000  98%      |      2489.455  83% --  |      2562.348 86% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A   10000       1314.721  |      1275.489  97%      |      1113.610  85% --  |      1102.961 84% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A  100000        136.838  |       132.305  97%      |       115.854  85% --  |       117.097 86% --
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A 1000000         13.837  |        12.820  93%      |        11.543  83% --  |        10.903 79% --
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A       1     113032.129  |    112135.558  99%      |    111731.222  99%     |    111749.315 99%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A      10     109884.718  |    109449.819  100%     |    102844.370  94%     |    109021.256 99%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A     100      89945.753  |     88015.871  98%      |     85771.952  95%     |     88074.845 98%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    1000      31680.733  |     31522.878  100%     |     31045.429  98%     |     31413.322 99%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    2000      18490.513  |     18352.634  99%      |     15774.641  85% --  |     16059.751 87% --
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    3000      11490.479  |     11446.241  100%     |     11197.939  97%     |     12871.202 112% ++
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    4000       8833.117  |     10230.066  116% ++  |      9788.883  111%    |      9889.138 112% ++
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A   10000       3888.874  |      3885.651  100%     |      3919.543  101%    |      3903.835 100%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A  100000        446.789  |       438.143  98%      |       434.775  97%     |       432.321 97%
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A 1000000         43.228  |        42.516  98%      |        42.588  99%     |        41.833 97%
r.schedulers.IOSchedulerPerf.observeOn                                           N/A       1     107443.954  |    103885.976  97%      |    106696.574  99%     |    105420.129 98%
r.schedulers.IOSchedulerPerf.observeOn                                           N/A    1000       6835.942  |      6934.710  101%     |      6175.613  90%     |      6257.461 92%
r.schedulers.IOSchedulerPerf.observeOn                                           N/A 1000000         13.804  |        13.076  95%      |        11.489  83% --  |        11.646 84% --
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A       1     113589.713  |    112548.761  99%      |    113767.664  100%    |    112749.541 99%
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A    1000      31572.535  |     31359.484  99%      |     31566.874  100%    |     28903.326 92%
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A 1000000         43.469  |        43.259  100%     |        43.075  99%     |        42.883 99%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                            1     N/A    4885450.713  |   4663855.111  95%      |   4760593.357  97%     |   4814097.168 99%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                         1000     N/A      36567.449  |     34794.653  95%      |     30965.582  85% --  |     35307.030 97%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                      1000000     N/A         46.758  |        44.710  96%      |        45.807  98%     |        45.132 97%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                         1     N/A    5166859.073  |   4928418.828  95%      |   4975843.203  96%     |   4971964.310 96%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                      1000     N/A      36677.914  |     35071.647  96%      |     34172.806  93%     |     36402.484 99%
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                   1000000     N/A         45.299  |        43.800  97%      |        44.580  98%     |        44.281 98%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                           1     N/A    3602234.043  |   3467543.784  96%      |   3555240.202  99%     |   3590503.433 100%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                        1000     N/A      47750.855  |     46718.061  98%      |     46229.640  97%     |     47580.266 100%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                     1000000     N/A         42.764  |        47.144  110% ++  |        45.690  107%    |        42.126 99%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                        1     N/A    3787851.518  |   3637162.254  96%      |   3527627.269  93%     |   3761304.213 99%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                     1000     N/A      43472.144  |     46173.174  106%     |     41008.079  94%     |     46078.493 106%
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                  1000000     N/A         42.057  |        41.150  98%      |        40.454  96%     |        40.994 97%

```
 =||= Here is a comparison of no pooling with size at 128 vs 1024:

```
Benchmark                                                                 (nextRuns)  (size)            1.x              No Pool (128)    No Pool (1024)     
r.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A     100     288851.474  |    464395.527  161% ++  |    491662.797  170% ++ 
r.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A   10000       1053.102  |      1122.418  107%     |      1201.884  114% ++ 
r.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A     100     130035.705  |    219530.470  169% ++  |    230427.274  177% ++ 
r.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A   10000        394.109  |       408.761  104%     |       430.168  109%    
r.internal.RxRingBufferPerf.spmcCreateUseAndDestroy1                             N/A     N/A   26400373.503  |   4011739.109  15% --   |   2066095.594  8%   -- 
r.internal.RxRingBufferPerf.spmcRingBufferAddRemove1                             N/A     N/A   41947289.772  |  40889056.084  97%      |  42517680.638  101%    
r.internal.RxRingBufferPerf.spscCreateUseAndDestroy1                             N/A     N/A   26625817.275  |   4041119.853  15% --   |   2065904.299  8%   -- 
r.internal.RxRingBufferPerf.spscRingBufferAddRemove1                             N/A     N/A   42376557.425  |  39384117.892  93%      |  42717826.799  101%    
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A       1     323419.496  |    314150.913  97%      |    286454.266  89%  -- 
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A    1000        325.685  |       320.644  98%      |       304.203  93%     
r.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A 1000000          0.318  |         0.318  100%     |         0.305  96%     
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A       1    5544570.553  |   5634853.059  102%     |   5703716.144  103%    
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A    1000      37510.701  |     37428.777  100%     |     37643.924  100%    
r.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A 1000000         32.831  |        33.133  101%     |        33.955  103%    
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A       1    4081082.521  |   3988577.555  98%      |   4148571.600  102%    
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A    1000      26194.758  |     26060.788  99%      |     27231.215  104%    
r.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A 1000000         24.255  |        24.638  102%     |        26.108  108%    
r.operators.OperatorMapPerf.mapPassThru                                          N/A       1   24413615.697  |  24572501.107  101%     |  25033228.781  103%    
r.operators.OperatorMapPerf.mapPassThru                                          N/A    1000     126022.367  |    126928.122  101%     |    131846.869  105%    
r.operators.OperatorMapPerf.mapPassThru                                          N/A 1000000        125.726  |       133.165  106%     |       129.763  103%    
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A       1   26830181.693  |  26855829.721  100%     |  27593572.229  103%    
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A    1000     126998.154  |    127883.467  101%     |    128981.592  102%    
r.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A 1000000        132.249  |       132.858  100%     |       130.398  99%     
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A       1    5004527.084  |   5096505.217  102%     |   5198752.240  104%    
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A    1000      52723.842  |     51944.534  99%      |     54578.616  104%    
r.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A 1000000         49.928  |        49.643  99%      |        46.496  93%     
r.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A       1      99724.243  |     96046.578  96%      |     92329.887  93%     
r.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A    1000          4.661  |         5.085  109%     |         4.858  104%    
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A       1    4543776.401  |   4562256.139  100%     |   4868734.621  107%    
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A     100     482015.536  |    481347.669  100%     |    474865.976  99%     
r.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A    1000      52102.762  |     52212.844  100%     |     41445.112  80%  -- 
r.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A       1    5182887.347  |   4926496.569  95%      |   5233708.963  101%    
r.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A    1000         52.055  |        51.914  100%     |        52.875  102%    
r.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A       1      76604.876  |     74224.276  97%      |     70830.676  92%     
r.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A    1000       3166.341  |      3130.021  99%      |      3684.324  116% ++ 
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A       1    5276030.387  |   5048453.291  96%      |   4977866.142  94%     
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A    1000      37197.231  |     37647.410  101%     |     39342.369  106%    
r.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A 1000000         34.649  |        34.124  98%      |        34.793  100%    
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A       1     107207.970  |    100380.298  94%      |    103951.076  97%     
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A    1000       6517.902  |      6869.709  105%     |      4597.071  71%  -- 
r.operators.OperatorObserveOnPerf.observeOnComputation                           N/A 1000000         13.670  |        13.580  99%      |         8.769  64%  -- 
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A       1   15245087.895  |  14962479.384  98%      |  15246618.567  100%    
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A    1000     178513.653  |    173023.234  97%      |    175349.312  98%     
r.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A 1000000        157.016  |       152.469  97%      |       158.773  101%    
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A       1      16879.424  |     15716.151  93%      |     15436.938  91%     
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A    1000       7783.654  |      7765.427  100%     |      4088.303  53%  -- 
r.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A 1000000         13.153  |        14.191  108%     |        14.327  109%    
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A       1   25332343.625  |  25065988.234  99%      |  25389267.172  100%    
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A    1000     116819.629  |    116739.463  100%     |    115639.590  99%     
r.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A 1000000        135.843  |       134.416  99%      |       135.049  99%     
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A       1  121325903.567  | 118002649.957  97%      | 117809961.937  97%     
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A    1000     186533.260  |    187334.419  100%     |    189459.713  102%    
r.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A 1000000        166.914  |       169.448  102%     |       167.025  100%    
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A       1   18921314.555  |  18257594.271  96%      |  19336558.885  102%    
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A    1000     269546.032  |    228423.425  85% --   |    272078.328  101%    
r.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A 1000000        260.990  |       254.223  97%      |       263.143  101%    
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A       1   10736813.240  |  10037561.783  93%      |  10329940.205  96%     
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A    1000      79767.255  |     67068.394  84% --   |     82774.032  104%    
r.operators.OperatorSerializePerf.serializedSingleStream                         N/A 1000000         70.840  |        75.120  106%     |        73.439  104%    
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A       1     111389.498  |    110210.985  99%      |    114315.595  103%    
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A    1000       7575.618  |      7207.681  95%      |      6969.878  92%     
r.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A 1000000          9.196  |         9.864  107%     |        10.363  113% ++ 
r.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A       1      83396.077  |     78874.484  95%      |     83311.153  100%    
r.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A    1000      36273.839  |     34303.562  95%      |     35931.364  99%     
r.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A       1      55607.010  |     53946.317  97%      |     53502.884  96%     
r.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A    1000      53468.342  |     53613.934  100%     |     52365.494  98%     
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A       1     107083.283  |    106172.060  99%      |    103457.291  97%     
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A      10     103095.692  |    102757.452  100%     |     98744.249  96%     
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A     100      37921.038  |     39183.046  103%     |     38418.723  101%    
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    1000       6776.178  |      7015.656  104%     |      4530.745  67%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    2000       4851.628  |      4828.700  100%     |      2085.208  43%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    3000       3754.394  |      3778.104  101%     |      1310.303  35%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    4000       2994.907  |      2949.000  98%      |      1008.669  34%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A   10000       1314.721  |      1275.489  97%      |       399.229  30%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A  100000        136.838  |       132.305  97%      |        50.999  37%  -- 
r.schedulers.ComputationSchedulerPerf.observeOn                                  N/A 1000000         13.837  |        12.820  93%      |         9.045  65%  -- 
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A       1     113032.129  |    112135.558  99%      |    113835.591  101%    
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A      10     109884.718  |    109449.819  100%     |    109171.798  99%     
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A     100      89945.753  |     88015.871  98%      |     89399.541  99%     
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    1000      31680.733  |     31522.878  100%     |     31588.465  100%    
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    2000      18490.513  |     18352.634  99%      |     18429.705  100%    
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    3000      11490.479  |     11446.241  100%     |     11472.235  100%    
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    4000       8833.117  |     10230.066  116% ++  |      9979.643  113% ++ 
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A   10000       3888.874  |      3885.651  100%     |      3517.361  90%     
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A  100000        446.789  |       438.143  98%      |       456.528  102%    
r.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A 1000000         43.228  |        42.516  98%      |        44.854  104%    
r.schedulers.IOSchedulerPerf.observeOn                                           N/A       1     107443.954  |    103885.976  97%      |    107011.170  100%    
r.schedulers.IOSchedulerPerf.observeOn                                           N/A    1000       6835.942  |      6934.710  101%     |      4307.395  63%  -- 
r.schedulers.IOSchedulerPerf.observeOn                                           N/A 1000000         13.804  |        13.076  95%      |        10.003  72%  -- 
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A       1     113589.713  |    112548.761  99%      |    112666.557  99%     
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A    1000      31572.535  |     31359.484  99%      |     31608.746  100%    
r.schedulers.IOSchedulerPerf.subscribeOn                                         N/A 1000000         43.469  |        43.259  100%     |        43.581  100%    
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                            1     N/A    4885450.713  |   4663855.111  95%      |   4769133.206  98%     
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                         1000     N/A      36567.449  |     34794.653  95%      |     36690.199  100%    
r.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                      1000000     N/A         46.758  |        44.710  96%      |        49.111  105%    
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                         1     N/A    5166859.073  |   4928418.828  95%      |   5233752.980  101%    
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                      1000     N/A      36677.914  |     35071.647  96%      |     37576.169  102%    
r.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                   1000000     N/A         45.299  |        43.800  97%      |        46.962  104%    
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                           1     N/A    3602234.043  |   3467543.784  96%      |   3700116.809  103%    
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                        1000     N/A      47750.855  |     46718.061  98%      |     47680.041  100%    
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                     1000000     N/A         42.764  |        47.144  110% ++  |        48.698  114% ++ 
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                        1     N/A    3787851.518  |   3637162.254  96%      |   3705592.692  98%     
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                     1000     N/A      43472.144  |     46173.174  106%     |     46912.710  108%    
r.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                  1000000     N/A         42.057  |        41.150  98%      |        46.833  111% ++ 
```

The drop from 1024 to 128 makes it work okay with no pooling. At 1024 we needed the pooling. 
 =||= Any of you able to check performance and object allocation behavior using https://github.com/ReactiveX/RxJava/pull/1944 so it's not just my judgement on this? Is removing the object pool okay while using SpscArrayQueue as long as we stay at size 128?

Can you get WeakReference pooling to work better than the "no pooling" performance?
 =||= @akarnokd based on the perf numbers above what do you think we should do?
 =||= The no-pool 128 version seems to be the best choice generally. Maybe the low spscCreateUseDestroy1 case can be improved by removing the pad and complex hierarchy from the main class.
 =||= Should we move forward with this change in 1.0.x or should it be 1.1? I have not seen any evidence in my testing to suggest that this is a significant change in GC behavior ... which surprised me and is why I'm hesitant and want confirmation. 
 =||= By the way, nothing we're doing here should affect Android since we use a LinkedList without pooling on Android. 
 =||= What versions of Android are supported? `Deque`/`ArrayDeque` are usually preferred if you are API 9 and up (which is Java 6, 99.5% of active Android devices).
 =||= We use the SpscRingBuffer for non-Android since it uses `sun.misc.Unsafe` and a `synchronized` `LinkedList` for Android. Is a `synchronized` `ArrayDeque` preferred for Android then? The max size for Android is set to 16 instead of 128. With LinkedList nothing is allocated until it is needed. If we use `ArrayDeque` would you want it set to 16 as the initial capacity or something like 2 and let it grow if needed?
 =||= Here is the size for Android: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/util/RxRingBuffer.java#L264 and the list impl choice when `Unsafe` is not available: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/util/RxRingBuffer.java#L324

The conditional check for `unsafe` happens here: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/util/RxRingBuffer.java#L44

If you want to make a change for Android would you like to submit a PR?
 =||= > What versions of Android are supported?

We code to Java 6 and I believe it is Android API 9+ as per discussions in https://github.com/ReactiveX/RxJava/issues/153 and https://github.com/ReactiveX/RxJava/issues/1004
 =||= On Android we generally prefer the up-front allocation over lazy allocation of somewhat disposable wrapper objects (such as that inside of a LinkedList). This is for the benefit of comparatively poor handling of short lived objects as well as avoiding the GC as much as possible in our 60fps world. We also definitely wouldn't want to pay the cost of having the array expand unless it exceeded the 16 value.
 =||= It will never exceed 16 due to how the backpressure approach works, it will throw a `MissingBackpressureException` instead if the origin doesn't respect the requested amount. 

Often the buffer is not needed, or it's only needed for a single value (using Observable like a Future) so on Android what is better, allocating a 16 size array and maybe only using 1 spot, or allocating linked nodes only as needed but potentially allocating more in a slow/contended stream of data?

Do you want to submit a PR with the changes done as you'd like them for Android?
 =||= I have added https://github.com/ReactiveX/RxJava/pull/1969 with Flight Recorder tests showing the impact of removing pooling. It's not catastrophic but it also shows signs of being a potential problem. This is exactly the type of metrics that pushed me to add object pooling. That said, because we've dropped from 1024 to 128 the impact is not anywhere near as bad as it was before. 
 =||= This test is particularly bad: OperatorMergePerf.mergeNAsyncStreamsOfN

This suggests we can't eliminate pooling and use array queues.

With Pooling

![screen shot 2014-12-13 at 11 22 24 am](https://cloud.githubusercontent.com/assets/813492/5424991/64bbd122-82ba-11e4-911f-c835a016d1db.png)

Without

![screen shot 2014-12-13 at 11 22 29 am](https://cloud.githubusercontent.com/assets/813492/5424992/6c478210-82ba-11e4-8484-1f456c9dd18e.png)

With Pooling

![screen shot 2014-12-13 at 11 22 40 am](https://cloud.githubusercontent.com/assets/813492/5424993/717c5eea-82ba-11e4-9efd-077afd519359.png)

Without

![screen shot 2014-12-13 at 11 22 45 am](https://cloud.githubusercontent.com/assets/813492/5425008/b0651f2a-82ba-11e4-97d6-90a642594e9f.png)
 =||= I have submitted another variant in https://github.com/ReactiveX/RxJava/pull/2189

It makes different tradeoffs to allow for object pooling to work in most use cases, normal GC in edge cases (haven't found a consistent one yet, only theoretical, but I haven't tried hard yet), while maintaining more-or-less the same performance characteristics as the current 1.x code. 

I have NOT battle-tested this and intend on sleeping on it then reviewing again, but wanted to post to trigger discussions and get a review on the direction and trade-offs. 
 =||= I tried another implementation, this time with a `WriterReaderPhaser` in #2243. It performs similarly to the RWLock and WIP implementations and worse than #2189. 
 =||= Problem definition:
- The current approach to removing the object pool occasionally results in concurrency issues because concurrent emission/unsubscribe can result in 2 instances of RxRingBuffer holding a single queue.
- Retaining a reference to the `queue` to avoid a `NullPointerException` results in the same problem of 2 RxRingBuffer instances holding a single queue. 
- In short, synchronization is needed between emission and unsubscribe in order to safely release the `queue` to the pool.

A refresher on what has been attempted so far while exploring this:
- All attempts at removing the object pool have resulted in performance degradation via significant increases in object allocation and GC time. This was pursued since removing the pool would eliminate the race condition. 
- Use of WIP, mutex, RW lock, and WriterReaderPhraser make it thread-safe but at significant performance penalty in the normal happy-path (see performance numbers below)
- Attempts with using WeakReference have failed so far. Every attempt I've made suggests that ReferenceQueue has non-trivial overhead and unfortunately it's the only way to get the "callback" via polling that something is released. It doesn't help much that it was written in Java 1.2 and is heavily synchronized. We can't implement our own as this code is special-cased by the JVM since it is involved in GC. 

The behavior we're trying to deal with is:
- Emissions are all serial from the same thread. Draining may happen on a second thread. It is SPSC in behavior. 
- Unsubscribe generally comes from the same thread, but does not have to, hence the possibly concurrency. This race happens only once, at the end. 
- It is okay if the unsubscribe/emission race is non-deterministic (finish emitting then unsubscribe or unsubscribe immediately and drop data). 

Here are performance numbers of the various tests I've done:

```
Benchmark                                          (size)   Mode   Samples          1.x   Inline Volatile    + finalize       RW Lock          WIP     WRPhaser
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4757888.048       5264594.520   4956256.323   5288310.755  5032942.628  5147447.030
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    44877.618         42845.758     39209.439     25742.696    29025.955    27779.876
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       42.366            40.979        37.036        24.769       27.260       27.694
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    99981.127         99910.070     94307.080    103112.286   103176.289   100516.101
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.675             4.620         4.670         4.374        4.313        4.413
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4751265.583       4706441.452   4376983.062   4739418.557  4673633.614  4510099.724
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   458704.984        480075.261    427165.143    483313.588   476318.407   462373.555
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    42493.290         42178.254     39640.240     42728.480    42542.171    41354.668
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5406448.872       5375090.752   5066264.570   5628401.294  4974892.417  4986054.668
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       44.528            40.990        41.106        24.974       28.212       27.755
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76898.222         72655.377     69748.305     78283.565    78987.646    78550.912
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3172.653          2955.854      3064.749      1858.361     2204.948     2310.804
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5157134.576       5163837.644   4846336.744   5290961.536  5139893.848  4486879.415
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    39961.491         39341.526     37312.117     40418.492    39163.267    37424.146
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.925            35.730        33.948        35.526       35.611       32.287
```
 =||= I'd like to move forward on something since we do currently have a correctness issue. 

Unless there is some performance or functional issue I am not yet aware of, I suggest we move forward with https://github.com/ReactiveX/RxJava/pull/2189 since it seems to work while retaining performance, despite not being the most elegant of approaches. 

Once we've merged and released to fix the correctness issue, other more elegant solutions can continue to be pursued. I'd love for something such as the WriterReaderPhaser to work and retain performance. 
 =||= As a fun aside, and because this is happening over the holidays, here are some pages from a book I just read my girls the other day that totally made me think of this issue and many others like it :-)

![screen shot 2014-12-27 at 10 30 00 pm](https://cloud.githubusercontent.com/assets/813492/5563235/2c1e51fa-8e18-11e4-8865-fca3cd9e77ad.png)

![screen shot 2014-12-27 at 10 30 17 pm](https://cloud.githubusercontent.com/assets/813492/5563236/31728edc-8e18-11e4-84ac-dc8f3d05e942.png)

![screen shot 2014-12-27 at 10 30 27 pm](https://cloud.githubusercontent.com/assets/813492/5563237/35c8133a-8e18-11e4-9bf3-0c3457ca4f8b.png)

Book at http://www.amazon.com/Most-Magnificent-Thing-Ashley-Spires-ebook/dp/B00IZH626G

Spoiler ... she eventually succeeds, though still with a few imperfections :-)
 =||= Just to let you know I have added an Spsc which might fit the bill here:
https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Small footprint, grows to max size if the queue needs to grow (if consumer falls behind), still has some of the false sharing protection. Seems to perform well in my benchmarks, let me know how it works for you.
 =||= Quite clever; no CAS, no tombstone and no copying. However, correct me if I'm wrong, but it seems the code on [line 135](https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java#L135) may read beyond the buffer if offset is at the last element. The other thing I see is that the queue should disallow offering Object[] values because it would confuse the poll. Better yet, when a new array needs to be communicated, wrap it into a private holder class so it is not confused with any other type; resize should be infrequent enough to not cause significant overhead.
 =||= Since the queues are limited to RxRingBuffer.SIZE, it might be worth considering this growable queue doesn't grow in several steps but jumps immediately to its maximum value. In my two-phased version, I also triggered a growth after cerain number of elements have been offered; this helped eliminating the cost of CAS for long running queues. Here, if the poll() can know no more resize can happen, an `instanceof` may be avoided (replaced by a simple boolean flag).
 =||= Fixed as per your suggestions in https://github.com/JCTools/JCTools/issues/43
I think the factor of 2 growth is beneficial, especially since CAS is no longer required. You'll be saving up on intermediate sizing, but suffering in the case of transient spike.
I considered adding a 'max capacity reached flag', still playing with it. I think the instanceof check is not that costly if you mean to actually use the returned object. 
 =||= The RxRingBuffer has been fixed and the JCTools queues have been upgraded in 1.0.5. Pooling seems to be the only way to increase the performance of single-shot merging of values.
 =||= ,0
7028,7001,3.x: Flaky GroupBy test,https://github.com/ReactiveX/RxJava/blob/98acac218cdb04d279b5ac49bb1afc65bc6ec4fe/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java#L2668

```
io.reactivex.rxjava3.internal.operators.flowable.FlowableGroupByTest > issue6974Part2Case1NoEvict FAILED
    java.lang.AssertionError: Error(s) present: [io.reactivex.rxjava3.exceptions.CompositeException: 1 exceptions occurred. ] (latch = 0, values = 15551, errors = 1, completions = 0)
        at io.reactivex.rxjava3.observers.BaseTestConsumer.fail(BaseTestConsumer.java:125)
        at io.reactivex.rxjava3.observers.BaseTestConsumer.assertNoErrors(BaseTestConsumer.java:212)
        at io.reactivex.rxjava3.internal.operators.flowable.FlowableGroupByTest.issue6974RunPart2NoEvict(FlowableGroupByTest.java:2681)
        at io.reactivex.rxjava3.internal.operators.flowable.FlowableGroupByTest.issue6974Part2Case1NoEvict(FlowableGroupByTest.java:2693)
        Caused by:
        io.reactivex.rxjava3.exceptions.CompositeException: 1 exceptions occurred. 
            Caused by:
            io.reactivex.rxjava3.exceptions.MissingBackpressureException: Unable to emit a new group (#71) due to lack of requests. Please make sure the downstream can always accept a new group as well as each group is consumed in order for the whole operator to be able to proceed.
```

Error is an allowed outcome here.,I would like to pick up this issue if no one is working on it yet. =||= I would like to pick up this issue, @ddunig2  are you still working on it? =||= I had not realized I got the okay to work on this. @tmankita give me three days to work on it then it's all yours. =||= @akarnokd that test seems to be passing on my local machine, I'm not sure what the issue is. =||= It can probabilistically result in a `MissingBackpressureException`, which is an allowed outcome, but the test expects no errors: https://github.com/ReactiveX/RxJava/blob/98acac218cdb04d279b5ac49bb1afc65bc6ec4fe/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java#L2681

Effectively, the only thing needed is a different assert such as in this test: https://github.com/ReactiveX/RxJava/blob/98acac218cdb04d279b5ac49bb1afc65bc6ec4fe/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java#L2730 =||= @akarnokd Okay, I got it. Would simply removing the assertNoErrors be valid? I would have to change the TestSubsriber to TestSubscriberEx to include the assertTerminate() and in this case, would we still need assertComplete()? =||= ,0
7031,1972,Non-deterministic test failure: ReplaySubjectConcurrencyTest.testReplaySubjectEmissionSubscriptionRace,This test randomly failed on my local machine. This was just recently added: https://github.com/ReactiveX/RxJava/pull/1947/files#diff-fe6df6db9fa6e69287f256960599708bR338

/cc @akarnokd ,Where did it fail and with what message?

Edit: never mind, found the issue.
 =||= I failed to capture it, sorry. I copy/pasted the failure from my IDE and then re-ran it and it passed. When I pasted it all it had copied was the name of the test, not the stacktrace. 
 =||= Should be fixed now.
 =||= ,0
7033,7032,3.x Consider making .collect contravariant on T,Hi,

Currently, `collect` in Flowable, Observable accepts a `Collector<T, A, R> collector`. If that were to be `Collector<? super T, A, R> collector`, less casting would be needed in some instances. For example, when using `java.util.stream.Collectors.joining()`:

```java
Observable
        .just("foo", "bar", "baz")
        .cast(CharSequence.class)
        .collect(joining(", "));
```

The `.cast(CharSequence.class)` would then no longer be needed.

Should also be binary compatible?,Probably won't break anything. PR welcome. =||= ,0
7035,1855,publish,Change which into that.

publish()
Returns a ConnectableObservable, **which** waits until its connect method is called before it begins emitting items to those Observers that have subscribed to it.

publish(Func1<? super Observable<T>,? extends Observable<R>> selector)
Returns an Observable **that** emits the results of invoking a specified selector on items emitted by a ConnectableObservable that shares a single subscription to the underlying sequence.,Not sure about this one. The "which" clause here defines what a
ConnectableObservable _is_. If it were changed to a "that" clause it would
imply that the particular _sort_ of ConnectableObservable returned by
publish() is one that waits until its connect method is called.  In other
words:

publish() returns a ConnectableObservable, *which *[is a variety of
Observable that] waits until...

instead of

publish() returns [a variety of] ConnectableObservable *that *waits until...

Maybe I'll rewrite it to make this more explicit instead.

On Mon, Nov 10, 2014 at 12:06 PM, headinthebox notifications@github.com
wrote:

> Assigned #1855 https://github.com/ReactiveX/RxJava/issues/1855 to
> @DavidMGross https://github.com/DavidMGross.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1855#event-191004787.

## 

David M. Gross
PLP Consulting
 =||= > Maybe I'll rewrite it to make this more explicit instead.

Cool, I'd would have used that in both cases, but I never deeply understood the difference between that and which from strunk and white ;-)
 =||= ,0
7035,939,ReplaySubject leaks subscribers even after unsubscribing?,On Android a common use case is to `cache` or `replay` an observable to UI components that might get temporarily destroyed due to e.g. screen rotations.

The biggest challenge on Android when using RxJava is therefore to make sure that no resource leaks occur; since subscribers, however, might be inner classes of an Android Activity or Fragment (if you're unfamiliar: think screen object), those will leak if strong references held within an operator are not released when unsubscribing from the sequence.

I just noticed that when using e.g. `cache` on a long running sequence, and subscribing and unsubscribing multiple times, the observer I subscribe to the sequence never seems to get finalized. Android's StrictMode indeed reports that the observer (and hence the entire screen) is being leaked:

```
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=2; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=2; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=3; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=3; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=4; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=4; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=5; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=5; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=6; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=6; limit=1
```

I quickly glanced over the `ReplaySubject` subscription handling code, and it looks as if on unsubscribe, it removes the observer from the internal map; maybe that's broken, however?,We're observing the leakage on replaying as well (using version 0.17.0-RC7). 

It seems that `ReplaySubject` uses some `replayState` map within its `ReplayState` that keeps references to the subscribers.

We currently work around the issue by avoiding (non-static) inner classes as subscribers and voiding references to activity/fragment-bound variables explicitly in `onComplete`. This of course only minimizes the impact of the leakage.

Any better suggestions of how to handle that?
 =||= I think this issue and some related problems with ReplaySubject are now fixed. Could you confirm & close this issue?
 =||= I can confirm this is fixed for us.
 =||= Thanks @mttkay for the confirmation.
 =||= ,0
7035,1974,Update wiki to reference latest rxandroid (0.23) with new groupId/artifactId,See https://github.com/ReactiveX/RxJava/wiki/The-RxJava-Android-Module/_compare/ff5ebf8c37e209385e07b0794d2d08092e222732...b92bf069aa09b41dd1745dd449ce855f057713b5 where I've made this change.

I made this issue to ensure someone was aware of this change and that this was the correct thing to do. If so, please just confirm & close this issue.,LGTM. Thanks.
 =||= ,0
7035,1855,publish,Change which into that.

publish()
Returns a ConnectableObservable, **which** waits until its connect method is called before it begins emitting items to those Observers that have subscribed to it.

publish(Func1<? super Observable<T>,? extends Observable<R>> selector)
Returns an Observable **that** emits the results of invoking a specified selector on items emitted by a ConnectableObservable that shares a single subscription to the underlying sequence.,Not sure about this one. The "which" clause here defines what a
ConnectableObservable _is_. If it were changed to a "that" clause it would
imply that the particular _sort_ of ConnectableObservable returned by
publish() is one that waits until its connect method is called.  In other
words:

publish() returns a ConnectableObservable, *which *[is a variety of
Observable that] waits until...

instead of

publish() returns [a variety of] ConnectableObservable *that *waits until...

Maybe I'll rewrite it to make this more explicit instead.

On Mon, Nov 10, 2014 at 12:06 PM, headinthebox notifications@github.com
wrote:

> Assigned #1855 https://github.com/ReactiveX/RxJava/issues/1855 to
> @DavidMGross https://github.com/DavidMGross.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1855#event-191004787.

## 

David M. Gross
PLP Consulting
 =||= > Maybe I'll rewrite it to make this more explicit instead.

Cool, I'd would have used that in both cases, but I never deeply understood the difference between that and which from strunk and white ;-)
 =||= ,0
7035,1974,Update wiki to reference latest rxandroid (0.23) with new groupId/artifactId,See https://github.com/ReactiveX/RxJava/wiki/The-RxJava-Android-Module/_compare/ff5ebf8c37e209385e07b0794d2d08092e222732...b92bf069aa09b41dd1745dd449ce855f057713b5 where I've made this change.

I made this issue to ensure someone was aware of this change and that this was the correct thing to do. If so, please just confirm & close this issue.,LGTM. Thanks.
 =||= ,0
7035,1855,publish,Change which into that.

publish()
Returns a ConnectableObservable, **which** waits until its connect method is called before it begins emitting items to those Observers that have subscribed to it.

publish(Func1<? super Observable<T>,? extends Observable<R>> selector)
Returns an Observable **that** emits the results of invoking a specified selector on items emitted by a ConnectableObservable that shares a single subscription to the underlying sequence.,Not sure about this one. The "which" clause here defines what a
ConnectableObservable _is_. If it were changed to a "that" clause it would
imply that the particular _sort_ of ConnectableObservable returned by
publish() is one that waits until its connect method is called.  In other
words:

publish() returns a ConnectableObservable, *which *[is a variety of
Observable that] waits until...

instead of

publish() returns [a variety of] ConnectableObservable *that *waits until...

Maybe I'll rewrite it to make this more explicit instead.

On Mon, Nov 10, 2014 at 12:06 PM, headinthebox notifications@github.com
wrote:

> Assigned #1855 https://github.com/ReactiveX/RxJava/issues/1855 to
> @DavidMGross https://github.com/DavidMGross.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/1855#event-191004787.

## 

David M. Gross
PLP Consulting
 =||= > Maybe I'll rewrite it to make this more explicit instead.

Cool, I'd would have used that in both cases, but I never deeply understood the difference between that and which from strunk and white ;-)
 =||= ,0
7035,939,ReplaySubject leaks subscribers even after unsubscribing?,On Android a common use case is to `cache` or `replay` an observable to UI components that might get temporarily destroyed due to e.g. screen rotations.

The biggest challenge on Android when using RxJava is therefore to make sure that no resource leaks occur; since subscribers, however, might be inner classes of an Android Activity or Fragment (if you're unfamiliar: think screen object), those will leak if strong references held within an operator are not released when unsubscribing from the sequence.

I just noticed that when using e.g. `cache` on a long running sequence, and subscribing and unsubscribing multiple times, the observer I subscribe to the sequence never seems to get finalized. Android's StrictMode indeed reports that the observer (and hence the entire screen) is being leaked:

```
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=2; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=2; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=3; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=3; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=4; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=4; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=5; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=5; limit=1
E/StrictMode( 2791): class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=6; limit=1
E/StrictMode( 2791): android.os.StrictMode$InstanceCountViolation: class com.netflix.rxjava.android.samples.RetainedCacheFragmentActivity; instances=6; limit=1
```

I quickly glanced over the `ReplaySubject` subscription handling code, and it looks as if on unsubscribe, it removes the observer from the internal map; maybe that's broken, however?,We're observing the leakage on replaying as well (using version 0.17.0-RC7). 

It seems that `ReplaySubject` uses some `replayState` map within its `ReplayState` that keeps references to the subscribers.

We currently work around the issue by avoiding (non-static) inner classes as subscribers and voiding references to activity/fragment-bound variables explicitly in `onComplete`. This of course only minimizes the impact of the leakage.

Any better suggestions of how to handle that?
 =||= I think this issue and some related problems with ReplaySubject are now fixed. Could you confirm & close this issue?
 =||= I can confirm this is fixed for us.
 =||= Thanks @mttkay for the confirmation.
 =||= ,0
7040,7039,FlowableFilter potentially corrupts the source after observeOn,I've tried version 3.0.2 and 3.0.4 and both versions have this issue.

So here's the code that's causing the issue:

```java
	private Publisher<ShortCode> findAll() {
		// Yes, this is not just for this code example. I'm actually using Flowable.empty().
		return Flowable.<Boolean>empty()
				.observeOn(Schedulers.io())
				.filter(_b -> {
					System.out.println("111111111111111111111111111 " + (_b == null));
					return _b;
				})
				.map(_b -> {
					System.out.println("2222222222222222222222222222 " + (_b == null));
					return _b;
				})
				// The Flowable is always empty, so casting to anything is safe
				.map(ShortCode.class::cast);
	}
```

The code causes the following NPE:

```
java.lang.NullPointerException: The mapper function returned a null value.
        at java.util.Objects.requireNonNull(Objects.java:228)
        at io.reactivex.rxjava3.internal.operators.flowable.FlowableMap$MapConditionalSubscriber.tryOnNext(FlowableMap.java:124)
```

The console output is:

```
2222222222222222222222222222 true
```

So the function inside `filter` never gets called, which is expected, but then the function inside `map` gets called with a `null` element, which is not expected. It seems like the `filter` has corrupted the source and has made it emit a `null` element.

And the weird thing is that, if you run that piece of code in a standalone main method, it will NOT cause the NPE.

Also, doing any of the following will stop the NPE from happening:

* Remove the `observeOn`.
* Move the `observeOn` after the `filter`.
* Add `.to(Flux::from)` after the `observeOn`.
* Replace `Flowable.<Boolean>empty().observeOn(Schedulers.io())` with `Flux.<Boolean>empty().publishOn(reactor.core.scheduler.Schedulers.elastic())`.

The examples involving `Flux` are simply to demonstrate that it is not an issue with Reactor Core.

I know that not being able to reproduce the NPE with just that code sample is not terribly helpful, but are there any circumstances where doing an `observeOn` followed by a `filter` can corrupt the source?

Thanks!,How are you consuming the problematic flow?

Could you place an Object.requireNonNull inside the map to see what is the code path that triggers the NPE? =||= Found the issue and posted a fix in #7040  =||= Thanks a lot!!! 🎉 =||= ,0
7049,704,New contrib module: rxjava-async-util,- Added startFuture, deferFuture, forEachFuture operators.
- Left out the CancellationToken resembling overloads as I was in doubt they can be meaningfully used. If a task is cancelled, it is enough to check the Thread.currentThread().isInterrupted() flag.,[RxJava-pull-requests #620](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/620/) SUCCESS
This pull request looks good
 =||= Why is this changing 7700+ lines of `Observable` and most of `ObservableTests`?
 =||= I don't know. Maybe a line ending anomaly from your branch? Somehow these two classes got transformed into CRLF on checkout since I haven't touched them. I've changed them to LF.
 =||= [RxJava-pull-requests #622](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/622/) SUCCESS
This pull request looks good
 =||= This pull request merged the master branch instead of rebasing so has lots of unnecessary and unrelated changes. I have created a new pull request after cherry picking just the relevant changes and avoiding the "merge with master" artifacts: https://github.com/Netflix/RxJava/pull/706
 =||= ,0
7080,680,API Design Review: Async & Future,We have started collecting functionality related to `Async.java`, `Observable.start`, and similar such as in https://github.com/Netflix/RxJava/pull/645 and https://github.com/Netflix/RxJava/pull/622. 

These do not directly apply to the goals of rxjava-core in enabling async `Observable` behavior but are valuable utilities for converting to and from `Observable` and executing work asynchronously.

Having them in the core however has the following drawbacks:
- they increase API surface area, code and byte size
- they complicate the mental model by mixing multiple different concepts
- they are tied to the `java.util.concurrent` model
- different Java libraries such as Guava and Akka have different models
- each JVM language has different concurrency models and libraries
- work can be executed asynchronous in many ways such as actors, event-loops or thread pools and rxjava-core is purposefully non-opinionated about the source of concurrency or asynchronocity

For these reasons it is felt that this functionality should be removed and/or not accepted into rxjava-core but instead placed in a contrib module. This is similar to how `rxjava-android` and `rxjava-swing` add additional functionality. 

https://github.com/Netflix/RxJava/tree/master/rxjava-contrib

/cc @headinthebox and @jhusain,The `Async` class and related operators has been moved into `rxjava-async-util`: https://github.com/Netflix/RxJava/tree/master/rxjava-contrib/rxjava-async-util
 =||= ,0
7094,1671,Backpressure: SerializedSubscriber,Can we make `SerializedSubscriber` correctly be implemented with a bounded buffer and support reactive pull backpressure?

This should also ensure that `Observable.serialize()` works correctly with backpressure, both bounding its internal queue and chaining through the `Producer.request` calls.,Based on my experience in ReplaySubject, this might require an incompatible change. SerializedObserver needs to know that the wrapped Observer is a Subscriber and thus can participate in the backpressure logic whereas a general Observer cannot. This adds either a instanceof check on every onXYZ method or one needs to use some static factory method (i.e. `SerializedObserver.from()`) to return a specific subclass.

In addition, the array-based buffering as it is now, can't be kept because the queue might be partially consumed if the requested amount is less than Long.MAX_VALUE. Either the unconsumed elements need to be joined with the potential new queue or one needs to switch to a singly-linked list and do "pointer arithmetic". Single-value delivery latency will suffer either way.
 =||= A `SerializedObserver` can't by definition participate in backpressure since an `Observer` doesn't. The only time `SerializedObserver` should ever be used though is by a developer directly. All internal operators should be migrated to using `SerializedSubscriber` as they should all be using `Subscriber`.
 =||= I don't believe we should add backpressure support to `SerializedSubscriber`: it is a write-through from the perspective of backpressure: if downstream requests 5, `SerializedSubscriber` will request 5. It is not meant to run with backpressure-ignoring upstream and the`onBackpressureXXX` are there to handle it after.

I vote on closing this issue.
 =||= We use it mainly to serialize out `onNext` vs `onError` | `onCompleted`, for example in `takeUntil`, and not for serializing concurrent `onNext` calls (as far as I can remember).
 =||= ,0
7094,1660,Correct README Javadoc link.,nan,[ReactiveX » RxJava » RxJava-pull-requests #16](https://netflixoss.ci.cloudbees.com/job/ReactiveX/job/RxJava/job/RxJava-pull-requests/16/) SUCCESS
This pull request looks good
 =||= Thanks! (Got fixed in another PR though so closing out)
 =||= ,0
7126,7125,TestObserver error messages should include more information about values where possible,This applies to both 2.x and 3.x, and while I'd like this to be fixed in 2.x, it's more of a frustration than a bug.

Suppose I'm trying to assert that a value from a `TestObserver` is equal to a particular value. I write this test:
```kotlin
Single.just("foo").test().assertValue("bar")
```
and get this helpful error message:
```
java.lang.AssertionError: expected: bar (class: String) but was: foo (class: String) (latch = 0, values = 1, errors = 0, completions = 1)
Expected :bar (class: String) 
Actual   :foo (class: String) (latch = 0, values = 1, errors = 0, completions = 1)
```
(Never mind that the "Actual" in this case includes extra information, it conveys what it needs to.)

Suppose that I instead use a predicate:
```kotlin
Single.just("foo").test().assertValue { it.equals("goodbye", ignoreCase = true) }
```
Now I get this error message instead:
```
java.lang.AssertionError: Value not present (latch = 0, values = 1, errors = 0, completions = 1)
```
I'm told that the value isn't present, which is slightly misleading as "not present" is different than "does not match predicate." But more importantly, I don't see what the "not present" value is, which is immensely helpful when debugging the test. My usual solution here is to use something like this instead:
```kotlin
Single.just("foo").test().assertValue {
    assert(it).isEqualTo("bar", ignoreCase = true)
    true
}
```
This code is more clunky, but gives me the actual value in the error message:
```
java.lang.AssertionError: 
Expected :"[bar]"
Actual   :"[foo]"
```
The cost is that I lose useful `(latch = 0, values = 1, errors = 0, completions = 1)` information.

Instead of having to make a choice between these two, it would be most helpful if the simplest solution was also just as informative:
```
java.lang.AssertionError: Value bar (class: String) did not match predicate (latch = 0, values = 1, errors = 0, completions = 1)
```

This extends to many other assertions as well. For example, if I called `assertNoValues()` but there was a value? I'd like to know what that value was.,> The cost is that I lose useful (latch = 0, values = 1, errors = 0, completions = 1) information

With `Single`, you have 3 states: not finished, success, failure. You can rule out the first two via `assertComplete` and `assertNoErrors`, then use your predicate that captures the value for you. Since you are on Kotlin, you can even make an extension method for it. =||= If I change the order by checking `assertComplete` first:
```
BehaviorSubject.createDefault("foo").test().assertComplete().assertValue { it.equals("bar", ignoreCase = true)}
```
then if the chain is not completed, I will learn that first, without learning the value, even if knowing the value would be more useful for debugging:
```
java.lang.AssertionError: Not completed (latch = 1, values = 1, errors = 0, completions = 0)
```

Even then, with a more complicated workaround available, why shouldn't the library's provided assertion method provide information (the exact value that failedthe predicate) that any programmer would like to know when their test fails? The only drawback I can think of is if the value has an overly long and unhelpful `toString`, but that's a minor drawback compared to the usefulness of seeing the value in all cases. =||= The library provides a limited set of assertions based on community feedback and usage. For anything more complicated, the `TestObserver` can be extended and you'll have direct access to the [received events](https://github.com/ReactiveX/RxJava/blob/67c1a367397f1167f9ad5639dd5071b6608e4230/src/main/java/io/reactivex/rxjava3/observers/BaseTestConsumer.java#L35-L39) as well as add on-class methods. This will also let you call [fail()](https://github.com/ReactiveX/RxJava/blob/67c1a367397f1167f9ad5639dd5071b6608e4230/src/main/java/io/reactivex/rxjava3/observers/BaseTestConsumer.java#L96) to produce that particular formatted error message. =||= I'm not asking for a new assertion to be added, but for the existing assertion to have a better error message. Is there a reason for the "value not present" error message to not contain the value that failed the predicate? =||= It didn't fit the pattern expected vs actual because with a predicate there is no way to tell the expected, hence the actual was not considered to be printed either.

After further considerations and looking at other methods, the error message across the tester class can be improved. I'll prepare a PR with the changes. =||= Thanks! =||= ,0
7141,2157,observeOn() slowing things down considerably,Hi folks,

I'm again hunting lost performance and this time it seems that `observeOn` is a major contributor. I think the workload itself is not so important, but I'm fetching 5 docs in a batch from the server, wait and then the next one.  Something like:

``` java
while(true) {

    Observable
        .range(1, 5)
        .flatMap(new Func1<Integer, Observable<GetResponse>>() {
            @Override
            public Observable<GetResponse> call(Integer i) {
                return core.<GetResponse>send(new GetRequest("" + i, "default"));
            }
        })
        .doOnNext(new Action1<GetResponse>() {
            @Override
            public void call(GetResponse getResponse) {
                getResponse.content().release();
            }
        })
        .toBlocking()
        .last();
}
```

Now when I run it like this, I get 30k ops/s against my Couchbase Server cluster, which seems fair relatively. Now when I change the code to:

``` java
.flatMap(new Func1<Integer, Observable<GetResponse>>() {
    @Override
    public Observable<GetResponse> call(Integer i) {
        return core.<GetResponse>send(new GetRequest("" + i, "default")).observeOn(env.scheduler());
    }
})
```

I'm not getting over 22k ops/s, which means I'm loosing 8k ops/s just by moving it onto a different scheduler. The thing is, I need to move it somewhere else to prevent users from stalling my IO threads. I expect "some" loss, but not that much.

I did JFR runs for both sessions over 5 minute periods. I'm not 100% sure what is causing the issues here, but one interesting thing is that with `observeOn` I get contention reported, without it there is no contention:

![screen shot 2014-12-22 at 13 43 26](https://cloud.githubusercontent.com/assets/29086/5525064/9138fec8-89e0-11e4-9c23-0bb8e5f813f5.png)

Also, it looks like the Interrupt Exceptions are back with observeOn (no shown when omitted):

![screen shot 2014-12-22 at 13 46 16](https://cloud.githubusercontent.com/assets/29086/5525097/ff9e1f4c-89e0-11e4-9e2c-abeafef9f015.png)

So my questions are basically:

1) can we improve the observeOn performance to be mostly on-par (loosing a few 100 ops/s I'm okay with)
2) if not, is there an alternative way to go that is faster?
3) @akarnokd didn't you fix the interrupts?

This is on 1.0.3,Generally, it is a tradeoff between latency and throughput, and the current RxJava is mostly aimed at throughput of long streams. In your case, latency dominates and the synchronization points introduce overhead not diminished by large amounts of data. The second cause of throughput loss is the backpressure. Merging 5 values backpressure-enabled adds quite an overhead; I was advocating a plain, no-backpressure merge alternative a few times. You can dig up a version from 0.19.

Async unsubscriptions still issue an interrupting cancel. It is possible to enhance the current ScheduledAction to not interrupt at all if the action body has actually completed, but it can't help if an unsubscription swings around while the action is active.

At the end it might come to a case where there most operators would need two user-chosable variant: one for short and low latency work and one for long high throughput work.
 =||= @akarnokd thanks for your feedback. Now I understand why it is they way it is, but probably there is another way I can write to my scheduler without going through observe?

My motivation is that I have  ResponseHandler at the event notification side of a Disruptor, and I want to onNext and onComplete a Subject as quickly as possible, but of course not let the user run their Observable operations on my handler, since this would probably stall everything.

Do you think it could work to schedule an action on the scheduler which does the events, which would make me "be" on the scheduler thread without using observeOn? Is there anything I need to be aware of?

Also, if you have some ideas I wouldn't mind writing my own observeOn implementation in this case since its completely under my control, but I don't think that will help I guess.
 =||= That is a viable option, but you may need to consider backpressure if data amount is above 128 onNexts.
 =||= @akarnokd it's a async subject anyway, so only one `onNext` ever.

Is this good:

``` java
env().scheduler().createWorker().schedule(new Action0() {
            @Override
            public void call() {
                observable.onNext(response);
                observable.onCompleted();
            }
        }); 
```

I get better performance (although of course not equally to not scheduling it somewhere else) , but do I need to unsubscribe at some point to not risk leaking anything? When would I need to unsubscribe? I think if I cache the worker(), it will always hit the same thread on the computation scheduler I think...
 =||= You need to unsubscribe the worker in this case. Otherwise, you could use a plain, system-wide cached threadpool and not worry about such 1 shot emissions.
 =||= @akarnokd I have my own "CoreScheduler" created, which is basically just a Schedulers.computation() spinoff. I wonder if I could just expose the pool from there directly and issue it as a task without going through the scheduler? Do you think I can use the pool from both external and rx at the same time? Or would this break semantics.

Actually I'm not sure that's a good idea.. when do I need to unsubscribe the worker? Also, would you recommend caching the worker?
 =||= If you have access to the underlying pool, you can use it but don't expect the semantics of the Scheduler (i.e., strictly serialized and no thread hopping). So having "native" tasks interleaved with RxJava tasks is okay (but adds latency in case of interleaving).

You need to unsubscribe the worker if the downstream is completed, i.e., after sending out onCompleted. Schedulers.io() will cache the underlying workers so you don't need to worry about that.
 =||= So this is giving me a little better perf, does this seem reasonable to you?

``` java
        final Scheduler.Worker worker = env().scheduler().createWorker();
        worker.schedule(new Action0() {
            @Override
            public void call() {
                try {
                    observable.onNext(response);
                    observable.onCompleted();
                } catch(Exception ex) {
                    LOGGER.warn("Caught exception while onNext on observable", ex);
                    observable.onError(ex);
                } finally {
                    worker.unsubscribe();
                }
            }
        });
```
 =||= Yes.
 =||= > Merging 5 values backpressure-enabled adds quite an overhead

@akarnokd I'm curious as to what overhead are you are referring to. If there is no contention it never queues them. Perhaps you're referring to the extra bookkeeping? 

The performance of merge is measured in millions of ops/second when uncontended. If there is contention then the cost is paid, but that always exists with concurrent contended access/emission. 

> Do you think I can use the pool from both external and rx at the same time?

That's fine. We intend on doing something like this when running with Netty where the Computation Scheduler is the same as the Netty EventLoop Groups. 

>  at the event notification side of a Disruptor, and I want to onNext and onComplete a Subject as quickly as possible, but of course not let the user run their Observable operations on my handler,

If you already have Disruptor in your system then you can probably leverage it for faster dispatch and skip the Java ExecutorService stuff completely. In fact, I'd be quite interested in a DisruptorScheduler as a separate plugin that can be opted into. It would be interesting to see the perf difference. 

Since you do have Disruptor, why do you need to emit to an Observable directly on the handler thread and then move it to another Scheduler via `observeOn`? Perhaps the handler should just put it directly into a Disruptor queue and then have the `env.Scheduler` draining from Disruptor and emit to the Observable from there? 
 =||= I was talking about the many escaped synchronized block which isn't optimized away by the JVM. This may introduce several microseconds worth of sleep which may help the throughput benchmarks but has bad latency. Merge uses synchronized emitter blocks quite a lot, plus CompositeSubscription is also synchronized.

Disruptor is more than a queue and less than a queue. A DisruptorScheduler would be a multi-producer single consumer setup where the reader thread is where things get dequeues and run. Since one can't let this thread spin and make it eventually sleep, there might be no significant difference compared to a regular threadpoolexecutor. The time it takes to wake up a worker thread is almost the same, but perhaps the fact that concurrent producers don't block each other makes some difference. Note that with observeOn and SerializedObserver, we already have some smart batching because they take the entire piled-up work. Also timed execution and in-queue cancellation might be difficult to accomplish with it.
 =||= > This may introduce several microseconds worth of sleep which may help the throughput benchmarks but has bad latency

I agree we have used throughput as our measurement thus far, but we have not consciously optimized one way or another for latency since we have never tracked it sufficiently to do so. At this point latency is treated as "throughput/ops/second"

If we're going to discuss latency we'd need to track latency percentiles (such as by using HdrHistogram https://github.com/HdrHistogram/HdrHistogram) and define what specific portions of the lifecycle we are trying to measure such as:
- latency from subscribe to first onNext
- latency from subscribe to terminal event
- single onNext
- multi onNext
- contended merge
- non-contended merge
- etc

Then we'd have to decide if we're optimizing for a lower and/or more consistent max latency (say at the 99.99th percentile) while trading off a higher median. This would reduce throughput but give more reliable latency characteristics. 

Are either of you suggesting that we need to gather these stats and consider changes in our optimizations? Or is it really just throughput that we're still discussing (which the 30k -> 22k decrease suggests)?

> Since one can't let this thread spin and make it eventually sleep

Just because RxJava never lets a thread spin doesn't mean a DisruptorScheduler couldn't choose to make this trade-off. High-performance systems often do this kind of thing. As a general rule though I don't think it's valuable as it assumes the rest of the system is correctly configured to not try and use the CPU core with the spinning thread. 

> concurrent producers don't block each other

This type of design could offer a very different strategy for merge. I have sometimes considered whether there is room for a different variant of `merge`, or different operator name altogether that accepts a `Scheduler` and effectively is `observeOn` except for many-to-one instead of one-to-one. We could use a non-blocking MPSC queue on the producing side and single thread on the consuming side. I'm curious as to whether we could achieve better performance (throughput and/or latency) than `merge.observeOn`. I imagine we could. The MPSC queue would however still need to account for backpressure, so it would still need at least those counters per producer. 

> Also timed execution and in-queue cancellation might be difficult to accomplish with it.

I don't have enough practical experience with Disruptor to know. 
 =||= I want to understand where the InterruptedExceptions are coming from again. That could very easily be the source of all the problems here. 18k stacktraces being generated could definitely cause a drop from 30k -> 22k. If we solve that the rest of this discussion may be moot. 

I again question why we ever interrupt threads: https://github.com/ReactiveX/RxJava/issues/1914
 =||= @benjchristensen The thing is my event listeners for the Disruptor RingBuffer are single threaded, and all notifications flow through it. My intention to use observeOn here is that if say a user is doing a blocking operation in a map function or whatever when subscribing, he may stall my only thread and everything else gets stalled as well.

So I thought "let's move it off to the computation scheduler right away", so that if they do weird stuff its dragging the box too, but not as hard as if my only lifeline thread stalls.

Regarding the 30k -> 22k, I think latency is the limiting factor here too, given that we don't start the next 5er batch before the first is completed. My main problem is that I can do lots of stuff, but I also need to play it safe since most of the code I've seen out there: people do more harm than good ;)
 =||= Can you define what you mean by latency here? I want to know what we are measuring. It seems like it is actually throughput we are discussing due to the 30k -> 22k number. 

Protection against blocking is slightly better on the computation scheduler as it isn't just one thread but it is still limited to the number of cores. So if the developer blocks it is going to block the system regardless of which event loop they end up on. =
 =||= @benjchristensen In this example the latency is the full wall clock time for an operation against the database. This of course includes network and everything, but this particular test was run against localhost. I know that throughput often affects latency in the high percentile level, but in this case I think we can observe the other effect:

When we reduce the latency for each individual request we are increasing throughput, mainly because we are still single threaded (blocking on the 5 ops). I'm aware that this is mostly not a realistic production workload, but a common test that people run (and the increased latency potentially affects them on every call, even if not single threaded).

I also tried it in a very classical (while(true) { doOp() }) thing that users want to run very often. Note that this is completely driven by latency, since you are more or less benchmarking wall clock time. 

Here is the do one op blocking one time with and one without observeOn:

![screen shot 2014-12-23 at 08 01 52](https://cloud.githubusercontent.com/assets/29086/5535259/3e1672e4-8a7a-11e4-9b2f-83be01f83f3e.png)

So I'm mainly concerned about end-to-end latency. I can probably optimize more on my end too, but looking into JFR this was the main offender.

If we can get rid of the exceptions and it fixes the issues even better, because at some point I need to move it to a computation scheduler (since we also do JSON parsing at a higher level).
 =||= And as expected the effect magnifies if you increase the batch size (here code like above, but a range from 1 to 100, leading to a 100 batch get):

![screen shot 2014-12-23 at 08 07 33](https://cloud.githubusercontent.com/assets/29086/5535282/d9e883ec-8a7a-11e4-9872-54e3c07d42e8.png)

If it helps, I could do more precise latency numbers with HdrHistogram as well
 =||= I know I need to come back and spend some time on this. During Holidays I didn't spend much time on anything, and I'm rather busy in other "day job" items right now. Can this wait? Do you have a proposed change?

It seems the `InterruptedException` issue is the low hanging fruit I'd like solved. 
 =||= Well, the only thing at this point is that I'm thinking about avoiding observeOn where possible, but its not a solution. If you grab the low hanging fruit, I'll be more than happy to verify :)
 =||= In #1207 I was wondering if observeOn can be improved by not using any queue since the schedulers already have their queues.

In your base case, you have 3 messages per value going through the observeOn: onNext, onCompleted and unsubscribe. I think the onCompleted could be omitted if you know exactly how many onNexts there will be: just use a take(5) after the observeOn so upstream is cleaned up. If you don't have control over onNext, you can always concat/merge with never(), although they are quite heavy, or create your simple operator which simply swallows onCompleted.
 =||= Wouldn't it be more expensive to go through the queue used by the Executor since it would need to schedule a new task each time? The idea was that a single schedule step could drain many items from the queue, instead of each item needing to go through the scheduling overhead. 

It would be interesting to have concrete data comparing the two. 
 =||= I did some performance enhancements in #2603. Could you check if you get your performance back?
 =||= Several performance enhancements have been merged relating observeOn, so closing. If you have further problems, please don't hesitate to reopen this issue or post a new one.
 =||= Sounds great, I'll do that if needed. Cheers and thanks again
 =||= ,0
7141,2157,observeOn() slowing things down considerably,Hi folks,

I'm again hunting lost performance and this time it seems that `observeOn` is a major contributor. I think the workload itself is not so important, but I'm fetching 5 docs in a batch from the server, wait and then the next one.  Something like:

``` java
while(true) {

    Observable
        .range(1, 5)
        .flatMap(new Func1<Integer, Observable<GetResponse>>() {
            @Override
            public Observable<GetResponse> call(Integer i) {
                return core.<GetResponse>send(new GetRequest("" + i, "default"));
            }
        })
        .doOnNext(new Action1<GetResponse>() {
            @Override
            public void call(GetResponse getResponse) {
                getResponse.content().release();
            }
        })
        .toBlocking()
        .last();
}
```

Now when I run it like this, I get 30k ops/s against my Couchbase Server cluster, which seems fair relatively. Now when I change the code to:

``` java
.flatMap(new Func1<Integer, Observable<GetResponse>>() {
    @Override
    public Observable<GetResponse> call(Integer i) {
        return core.<GetResponse>send(new GetRequest("" + i, "default")).observeOn(env.scheduler());
    }
})
```

I'm not getting over 22k ops/s, which means I'm loosing 8k ops/s just by moving it onto a different scheduler. The thing is, I need to move it somewhere else to prevent users from stalling my IO threads. I expect "some" loss, but not that much.

I did JFR runs for both sessions over 5 minute periods. I'm not 100% sure what is causing the issues here, but one interesting thing is that with `observeOn` I get contention reported, without it there is no contention:

![screen shot 2014-12-22 at 13 43 26](https://cloud.githubusercontent.com/assets/29086/5525064/9138fec8-89e0-11e4-9c23-0bb8e5f813f5.png)

Also, it looks like the Interrupt Exceptions are back with observeOn (no shown when omitted):

![screen shot 2014-12-22 at 13 46 16](https://cloud.githubusercontent.com/assets/29086/5525097/ff9e1f4c-89e0-11e4-9e2c-abeafef9f015.png)

So my questions are basically:

1) can we improve the observeOn performance to be mostly on-par (loosing a few 100 ops/s I'm okay with)
2) if not, is there an alternative way to go that is faster?
3) @akarnokd didn't you fix the interrupts?

This is on 1.0.3,Generally, it is a tradeoff between latency and throughput, and the current RxJava is mostly aimed at throughput of long streams. In your case, latency dominates and the synchronization points introduce overhead not diminished by large amounts of data. The second cause of throughput loss is the backpressure. Merging 5 values backpressure-enabled adds quite an overhead; I was advocating a plain, no-backpressure merge alternative a few times. You can dig up a version from 0.19.

Async unsubscriptions still issue an interrupting cancel. It is possible to enhance the current ScheduledAction to not interrupt at all if the action body has actually completed, but it can't help if an unsubscription swings around while the action is active.

At the end it might come to a case where there most operators would need two user-chosable variant: one for short and low latency work and one for long high throughput work.
 =||= @akarnokd thanks for your feedback. Now I understand why it is they way it is, but probably there is another way I can write to my scheduler without going through observe?

My motivation is that I have  ResponseHandler at the event notification side of a Disruptor, and I want to onNext and onComplete a Subject as quickly as possible, but of course not let the user run their Observable operations on my handler, since this would probably stall everything.

Do you think it could work to schedule an action on the scheduler which does the events, which would make me "be" on the scheduler thread without using observeOn? Is there anything I need to be aware of?

Also, if you have some ideas I wouldn't mind writing my own observeOn implementation in this case since its completely under my control, but I don't think that will help I guess.
 =||= That is a viable option, but you may need to consider backpressure if data amount is above 128 onNexts.
 =||= @akarnokd it's a async subject anyway, so only one `onNext` ever.

Is this good:

``` java
env().scheduler().createWorker().schedule(new Action0() {
            @Override
            public void call() {
                observable.onNext(response);
                observable.onCompleted();
            }
        }); 
```

I get better performance (although of course not equally to not scheduling it somewhere else) , but do I need to unsubscribe at some point to not risk leaking anything? When would I need to unsubscribe? I think if I cache the worker(), it will always hit the same thread on the computation scheduler I think...
 =||= You need to unsubscribe the worker in this case. Otherwise, you could use a plain, system-wide cached threadpool and not worry about such 1 shot emissions.
 =||= @akarnokd I have my own "CoreScheduler" created, which is basically just a Schedulers.computation() spinoff. I wonder if I could just expose the pool from there directly and issue it as a task without going through the scheduler? Do you think I can use the pool from both external and rx at the same time? Or would this break semantics.

Actually I'm not sure that's a good idea.. when do I need to unsubscribe the worker? Also, would you recommend caching the worker?
 =||= If you have access to the underlying pool, you can use it but don't expect the semantics of the Scheduler (i.e., strictly serialized and no thread hopping). So having "native" tasks interleaved with RxJava tasks is okay (but adds latency in case of interleaving).

You need to unsubscribe the worker if the downstream is completed, i.e., after sending out onCompleted. Schedulers.io() will cache the underlying workers so you don't need to worry about that.
 =||= So this is giving me a little better perf, does this seem reasonable to you?

``` java
        final Scheduler.Worker worker = env().scheduler().createWorker();
        worker.schedule(new Action0() {
            @Override
            public void call() {
                try {
                    observable.onNext(response);
                    observable.onCompleted();
                } catch(Exception ex) {
                    LOGGER.warn("Caught exception while onNext on observable", ex);
                    observable.onError(ex);
                } finally {
                    worker.unsubscribe();
                }
            }
        });
```
 =||= Yes.
 =||= > Merging 5 values backpressure-enabled adds quite an overhead

@akarnokd I'm curious as to what overhead are you are referring to. If there is no contention it never queues them. Perhaps you're referring to the extra bookkeeping? 

The performance of merge is measured in millions of ops/second when uncontended. If there is contention then the cost is paid, but that always exists with concurrent contended access/emission. 

> Do you think I can use the pool from both external and rx at the same time?

That's fine. We intend on doing something like this when running with Netty where the Computation Scheduler is the same as the Netty EventLoop Groups. 

>  at the event notification side of a Disruptor, and I want to onNext and onComplete a Subject as quickly as possible, but of course not let the user run their Observable operations on my handler,

If you already have Disruptor in your system then you can probably leverage it for faster dispatch and skip the Java ExecutorService stuff completely. In fact, I'd be quite interested in a DisruptorScheduler as a separate plugin that can be opted into. It would be interesting to see the perf difference. 

Since you do have Disruptor, why do you need to emit to an Observable directly on the handler thread and then move it to another Scheduler via `observeOn`? Perhaps the handler should just put it directly into a Disruptor queue and then have the `env.Scheduler` draining from Disruptor and emit to the Observable from there? 
 =||= I was talking about the many escaped synchronized block which isn't optimized away by the JVM. This may introduce several microseconds worth of sleep which may help the throughput benchmarks but has bad latency. Merge uses synchronized emitter blocks quite a lot, plus CompositeSubscription is also synchronized.

Disruptor is more than a queue and less than a queue. A DisruptorScheduler would be a multi-producer single consumer setup where the reader thread is where things get dequeues and run. Since one can't let this thread spin and make it eventually sleep, there might be no significant difference compared to a regular threadpoolexecutor. The time it takes to wake up a worker thread is almost the same, but perhaps the fact that concurrent producers don't block each other makes some difference. Note that with observeOn and SerializedObserver, we already have some smart batching because they take the entire piled-up work. Also timed execution and in-queue cancellation might be difficult to accomplish with it.
 =||= > This may introduce several microseconds worth of sleep which may help the throughput benchmarks but has bad latency

I agree we have used throughput as our measurement thus far, but we have not consciously optimized one way or another for latency since we have never tracked it sufficiently to do so. At this point latency is treated as "throughput/ops/second"

If we're going to discuss latency we'd need to track latency percentiles (such as by using HdrHistogram https://github.com/HdrHistogram/HdrHistogram) and define what specific portions of the lifecycle we are trying to measure such as:
- latency from subscribe to first onNext
- latency from subscribe to terminal event
- single onNext
- multi onNext
- contended merge
- non-contended merge
- etc

Then we'd have to decide if we're optimizing for a lower and/or more consistent max latency (say at the 99.99th percentile) while trading off a higher median. This would reduce throughput but give more reliable latency characteristics. 

Are either of you suggesting that we need to gather these stats and consider changes in our optimizations? Or is it really just throughput that we're still discussing (which the 30k -> 22k decrease suggests)?

> Since one can't let this thread spin and make it eventually sleep

Just because RxJava never lets a thread spin doesn't mean a DisruptorScheduler couldn't choose to make this trade-off. High-performance systems often do this kind of thing. As a general rule though I don't think it's valuable as it assumes the rest of the system is correctly configured to not try and use the CPU core with the spinning thread. 

> concurrent producers don't block each other

This type of design could offer a very different strategy for merge. I have sometimes considered whether there is room for a different variant of `merge`, or different operator name altogether that accepts a `Scheduler` and effectively is `observeOn` except for many-to-one instead of one-to-one. We could use a non-blocking MPSC queue on the producing side and single thread on the consuming side. I'm curious as to whether we could achieve better performance (throughput and/or latency) than `merge.observeOn`. I imagine we could. The MPSC queue would however still need to account for backpressure, so it would still need at least those counters per producer. 

> Also timed execution and in-queue cancellation might be difficult to accomplish with it.

I don't have enough practical experience with Disruptor to know. 
 =||= I want to understand where the InterruptedExceptions are coming from again. That could very easily be the source of all the problems here. 18k stacktraces being generated could definitely cause a drop from 30k -> 22k. If we solve that the rest of this discussion may be moot. 

I again question why we ever interrupt threads: https://github.com/ReactiveX/RxJava/issues/1914
 =||= @benjchristensen The thing is my event listeners for the Disruptor RingBuffer are single threaded, and all notifications flow through it. My intention to use observeOn here is that if say a user is doing a blocking operation in a map function or whatever when subscribing, he may stall my only thread and everything else gets stalled as well.

So I thought "let's move it off to the computation scheduler right away", so that if they do weird stuff its dragging the box too, but not as hard as if my only lifeline thread stalls.

Regarding the 30k -> 22k, I think latency is the limiting factor here too, given that we don't start the next 5er batch before the first is completed. My main problem is that I can do lots of stuff, but I also need to play it safe since most of the code I've seen out there: people do more harm than good ;)
 =||= Can you define what you mean by latency here? I want to know what we are measuring. It seems like it is actually throughput we are discussing due to the 30k -> 22k number. 

Protection against blocking is slightly better on the computation scheduler as it isn't just one thread but it is still limited to the number of cores. So if the developer blocks it is going to block the system regardless of which event loop they end up on. =
 =||= @benjchristensen In this example the latency is the full wall clock time for an operation against the database. This of course includes network and everything, but this particular test was run against localhost. I know that throughput often affects latency in the high percentile level, but in this case I think we can observe the other effect:

When we reduce the latency for each individual request we are increasing throughput, mainly because we are still single threaded (blocking on the 5 ops). I'm aware that this is mostly not a realistic production workload, but a common test that people run (and the increased latency potentially affects them on every call, even if not single threaded).

I also tried it in a very classical (while(true) { doOp() }) thing that users want to run very often. Note that this is completely driven by latency, since you are more or less benchmarking wall clock time. 

Here is the do one op blocking one time with and one without observeOn:

![screen shot 2014-12-23 at 08 01 52](https://cloud.githubusercontent.com/assets/29086/5535259/3e1672e4-8a7a-11e4-9b2f-83be01f83f3e.png)

So I'm mainly concerned about end-to-end latency. I can probably optimize more on my end too, but looking into JFR this was the main offender.

If we can get rid of the exceptions and it fixes the issues even better, because at some point I need to move it to a computation scheduler (since we also do JSON parsing at a higher level).
 =||= And as expected the effect magnifies if you increase the batch size (here code like above, but a range from 1 to 100, leading to a 100 batch get):

![screen shot 2014-12-23 at 08 07 33](https://cloud.githubusercontent.com/assets/29086/5535282/d9e883ec-8a7a-11e4-9872-54e3c07d42e8.png)

If it helps, I could do more precise latency numbers with HdrHistogram as well
 =||= I know I need to come back and spend some time on this. During Holidays I didn't spend much time on anything, and I'm rather busy in other "day job" items right now. Can this wait? Do you have a proposed change?

It seems the `InterruptedException` issue is the low hanging fruit I'd like solved. 
 =||= Well, the only thing at this point is that I'm thinking about avoiding observeOn where possible, but its not a solution. If you grab the low hanging fruit, I'll be more than happy to verify :)
 =||= In #1207 I was wondering if observeOn can be improved by not using any queue since the schedulers already have their queues.

In your base case, you have 3 messages per value going through the observeOn: onNext, onCompleted and unsubscribe. I think the onCompleted could be omitted if you know exactly how many onNexts there will be: just use a take(5) after the observeOn so upstream is cleaned up. If you don't have control over onNext, you can always concat/merge with never(), although they are quite heavy, or create your simple operator which simply swallows onCompleted.
 =||= Wouldn't it be more expensive to go through the queue used by the Executor since it would need to schedule a new task each time? The idea was that a single schedule step could drain many items from the queue, instead of each item needing to go through the scheduling overhead. 

It would be interesting to have concrete data comparing the two. 
 =||= I did some performance enhancements in #2603. Could you check if you get your performance back?
 =||= Several performance enhancements have been merged relating observeOn, so closing. If you have further problems, please don't hesitate to reopen this issue or post a new one.
 =||= Sounds great, I'll do that if needed. Cheers and thanks again
 =||= ,0
7144,6995,3.x: Observable.amb marble diagram is a bit incorrect (or maybe it's a bug?),Version: 3.0.4

The marble diagram for the `Observable.amb` operator is as follows:
![amb](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png)

This means that the second (looser) `Observable` stays active (subscribed) while the whole `amb` executes. But in fact all `Observables` except the first (winner) are being cancelled (disposed).

Please consider the following code snippet:
```kotlin
        Observable
            .amb(
                listOf(
                    Observable
                        .create<Int> {
                            Thread.sleep(500L)
                            it.onNext(1)
                            Thread.sleep(500L)
                            it.onComplete()
                        }
                        .subscribeOn(Schedulers.computation())
                        .doOnNext { Log.v("MyTest", "1: next, $it") }
                        .doOnComplete { Log.v("MyTest", "1: complete") }
                        .doFinally { Log.v("MyTest", "1: finally") },
                    Observable
                        .create<Int> {
                            Thread.sleep(250L)
                            it.onNext(1)
                            Thread.sleep(500L)
                            it.onComplete()
                        }
                        .subscribeOn(Schedulers.computation())
                        .doOnNext { Log.v("MyTest", "2: next, $it") }
                        .doOnComplete { Log.v("MyTest", "2: complete") }
                        .doFinally { Log.v("MyTest", "2: finally") }
                )
            )
            .doOnNext { Log.v("MyTest", "amb: next, $it") }
            .doOnComplete { Log.v("MyTest", "amb: complete") }
            .doFinally { Log.v("MyTest", "amb: finally") }
            .subscribe()
```

This code produces the following output:
```
2020-05-22 16:37:01.724 5954-5979/? V/MyTest: 2: next, 1
2020-05-22 16:37:01.724 5954-5979/? V/MyTest: 1: finally
2020-05-22 16:37:01.724 5954-5979/? V/MyTest: amb: next, 1
2020-05-22 16:37:02.224 5954-5979/? V/MyTest: 2: complete
2020-05-22 16:37:02.224 5954-5979/? V/MyTest: amb: complete
2020-05-22 16:37:02.224 5954-5979/? V/MyTest: amb: finally
2020-05-22 16:37:02.224 5954-5979/? V/MyTest: 2: finally
```

Also it would be nice to describe this behavior explicitly in Java docs.,Some of the older diagrams haven't been updated to include dispose/cancel information. The [newer ones are](http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Maybe.html#amb-java.lang.Iterable-):

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.amb.png) 

> Also it would be nice to describe this behavior explicitly in Java docs.

PR welcome.
 =||= ,0
7163,711,Recursion on ExecutorService with >1 Thread is Slow,Recursion on NewThreadScheduler or ExecutorScheduler with 1 thread is fast. As number of threads increase in the pool it increasingly slows down. My guess is it's adding overhead jumping between threads and/or CPUs and thus having cache misses or something along those lines.

I found this while testing `TestRecursionMemoryUsage` and trying `Schedulers.threadPoolForComputation()` versus `Schedulers.newThread()`.

I confirmed that this changes the performance: `Executors.newScheduledThreadPool(2)` vs `Executors.newScheduledThreadPool(1)`

The real code uses numCores for that value which is worse.

We need to look at a way of using a thread-pool sized to the number of threads on the machine so we're not launching new threads every time a scheduler is used, but that recursion efficiently uses the same thread. ,Removed `ExecutorScheduler` and replaced with `ComputationScheduler` that has a pool of event loops: https://github.com/Netflix/RxJava/pull/1048
 =||= ,0
7164,716,[Scala Adapter] Observable trait has only the seed version of scan,In the documentation (https://github.com/Netflix/RxJava/wiki/Transforming-Observables#scan), it says that there are two forms of scan: `my_observable.scan(accumulator_closure)` which seeds with the next value of `my_observable` and `my_observable.scan(initial_seed, accumulator_closure)` which seeds with `initial_seed`.

However, the Scala adapter only provides the latter of these two. See http://rxscala.github.io/scaladoc/index.html#rx.lang.scala.Observable.

Is this missing for a reason?,I imagine that such a method would look something like

``` scala
def scan[T](accumulator: (T, T) => T): Observable[T] =
  toScalaObservable[T](asJavaObservable.scan(new Func2[T, T, T] {
    def call(t1: T, t2: T): T = accumulator(t1, t2)
  }))
```
 =||= Fixed, check the code to appreciate the beauty of covariance.
 =||= Hmm, I'm not exactly sure what you're referring to. The last commit affecting https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala was from 10 days ago.

In general, how would I go about writing a scan without an initial seed?
 =||= @samuela he's referring to this PR: https://github.com/Netflix/RxJava/pull/717 (which is not yet merged).
 =||= Awesome, thanks!
 =||= ,0
7165,706,Clean merge of rxjava-async-util,Manual merge of https://github.com/Netflix/RxJava/pull/704 by cherry picking relevant changes.,[RxJava-pull-requests #623](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/623/) SUCCESS
This pull request looks good
 =||= Ugh ... broke this pull request.
 =||= [RxJava-pull-requests #624](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/624/) FAILURE
Looks like there's a problem with this pull request
 =||= Looks like I got a properly cleaned merge in https://github.com/Netflix/RxJava/pull/707
 =||= ,0
7170,7154,3.x Feature: introduce abstract time source for scheduler impl,Version:
rxjava:3.0.9

Related:
https://github.com/ReactiveX/RxJava/issues/2943

Precondition:
* Task with delay scheduled in a `Scheduler`

Problem:
When the linux kernel wakes up from suspension `System.currentTimeMillis` will be adjusted on linux x86 OpenJDK. In my case this is bad, because watchdogs/ timer will fire, which they shouldn't. I would like to use a different time-source, but can't, because `System.currentTimeMillis` is hard-coded.

```java
    public long now(@NonNull TimeUnit unit) {
        return unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);
    }
```

Solution:
I would like to introduce a `TimeSource` interface, which can be set via `RxJavaPlugins`.

```kotlin
interface TimeSource {
    fun now(unit : TimeUnit) : Long
}
```

Impl
```kotlin
class NanoSource : TimeSource {
    override fun now(unit: TimeUnit): Long {
        return unit.convert(System.nanoTime(), TimeUnit.NANOSECONDS)
    }
}
```

In order to not break the current behavior the default TimeSource would still be `System.currentTimeMillis()`. 

This idea was pitched by: @artem-zinnatullin in https://github.com/ReactiveX/RxJava/issues/2943#issuecomment-102455813

If this is fine request is fine with the community I would try to implement it quickly and create a PR for it.,You can override `now` when implementing `Scheduler` and `Worker` and delegate the other methods to an existing `Scheduler` and `Worker`. =||= @akarnokd , 
thank you for your response.

I actually do not want to implement/ delegate, because this will probably only work 'new' scheduler. What about `Schedulers.single` or `Schedulers.from` (`ExecutorScheduler`).

For example, when I use `Schedulers.single.worker()`, the implementation for `public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit)` will be used from `super`, which uses `System.currentTimeMillis`. That said, I am unable to re-use already existing `Scheduler`, because it uses a clock, which is not desired. In my case `deep sleep` is a feature, which will occur quite often and other developers in different departments probably do not know, that `System.currentTimeMillis` is used and just use `Schedulers.single` for everything, which could cause very subtle bugs. 

Regarding delegation and overriding: Yes I could just wrap another Scheduler and overwrite now for `Worker` and `Scheduler` and use `RxJavaPlugins` in order to overwrite e.g. `Schedulers.single`, but I think this is actually more difficult, then just overwriting `System.currentTimeMillis` with an interface, which return a `long` as time-source. 

Performance wise I would reckon, that C2/ ART would just inline the call to the time-source, if `hot` enough, but I would bench it first.

Do you have a better idea how to easily switch the time without requiring to re-implement schedulers (e.g. reuse `Schedulers.single`)?  =||= Another idea would be to use the Java standard `ScheduledExecutorService` (provided it doesn't have the same timing problem) to drive your sensitive flows through `Subject`s and/or `Observable.create` emitting the ticks.

Otherwise, yes, we would need to add indirection to the `now` calculation. The problem then is, should it be affecting any and all default `Scheduler` implementations or should it be more coarse grained? =||= > Another idea would be to use the Java standard `ScheduledExecutorService` (provided it doesn't have the same timing problem) to drive your sensitive flows through `Subject`s and/or `Observable.create` emitting the ticks.
> 
> Otherwise, yes, we would need to add indirection to the `now` calculation. The problem then is, should it be affecting any and all default `Scheduler` implementations or should it be more coarse grained?

Is this a bad idea to add a method to RxJavaPlugins to override the default time source?
Something like this:
```
 /**
     * Sets the specific hook function.
     * @param handler the hook function to set, null allowed
     */
    public static void setTimeSourceHandler(@Nullable Function<? super TimeSource, ? extends TimeSource> handler) {
        if (lockdown) {
            throw new IllegalStateException("Plugins can't be changed anymore");
        }
        onTimeSourceHandler = handler;
    }
```

@SergejIsbrecht RxJavaPlugins can also be used to override single, io and computational schedulers. This doesn't cover Schedulers.from(), but at least it covers computation().
 =||= > Is this a bad idea to add a method to RxJavaPlugins to override the default time source?

I generally prefer to modify RxJavaPlugins as a last resort. =||= Dear @akarnokd,

I have been looking into `RxJava`s `Scheduler` implementation. I will sum up my findings as follows:

Scheduler
```
Scheduler {
    Default:
        Disposable scheduleDirect(@NonNull Runnable run)
        Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) // depends on Worker default-impl
        Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, @NonNull TimeUnit unit) // uses now(TimeUnit) transitively from Worker default-impl
        long now(@NonNull TimeUnit unit)
    Abstract:
        abstract Worker createWorker()
}
```

Worker
```
Scheduler.Worker {
    Default:
        Disposable schedule(@NonNull Runnable run)
        Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) // uses now(TimeUnit.NANOSECONDS)
        long now(@NonNull TimeUnit unit)
    Abstract:
        abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit)
}
```

Example implementation of `SingleScheduler`

```
SingleScheduler {
    Override:
        Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit)
        Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, TimeUnit unit)
        Worker createWorker()
}
```

```
SingleScheduler.Worker {
    Override:
        Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit)
}
```

Condition
* `SingleScheduler` uses a `ScheduledExecutorService` internally 
* `ScheduledExecutorService` uses `System.nanoTime` and `SingleScheduler.Worker#schedulePeriodically` uses `System.currentTimeMillis`

Problem:
`SingleScheduler` uses default impl `schedulePeriodically` from `SingleScheduler.Worker`, but overwrites `Scheduler#scheduleDirect` (with delay) & `Scheduler#schedulePeriodicallyDirect`

Conclusion:
Even one scheduler, in this case `SingleScheduler`, might use two different times, which might cause subtile issues, when returning from suspension (S2R). Any idea why `SingleScheduler.Worker` does not overwrite `SingleScheduler.Worker#schedulePeriodically`, just like it is done with `SingleScheduler#schedulePeriodicallyDirect`? I did not find a way to create a scheduler, which uses only one time-source at every case (e.g. ExecutorScheduler)

Regarding you suggestion:
> You can override now when implementing Scheduler and Worker and delegate the other methods to an existing Scheduler and Worker.

I do see a problem with this approach:
* in order to wrap a `SingleScheduler`, I would implement a new Scheduler and delegate all the work to given `SingleScheduler` and overload `now` with my time-source of choice. When looking into the implementation of `Scheduler` and `Worker` it becomes apparent, that `now` is actually only used in one place: `Scheduler.Worker#schedulePeriodically`. This means that this method should not be delegated in the new implementation, when `SingleScheduler` uses the default implementation. It can not be delegated, because the delegate would call now this it's `this` and not the overloaded `now`. This brings me to my point. I do need internal knowledge when and where `now` is used, which can change at any time. If this happens, my wrapper will probably not do what I want.

Conclusion: 
It might be possible to use a different time source, but in the light of how RxJava implements/ delegates to Executors, the only option is actually to use `System.nanoTime`, in order to garantuee, that all methods use the same time-source. 

Resolution:
Maybe we do not need a global time-source interface, which is set via `RxJavaPlugins` but extend some factory methods to take a time-source as a parameter when creating. By default a singleton of `System.currentTimeMillis` will be used. What do you think about it?

> Otherwise, yes, we would need to add indirection to the now calculation. The problem then is, should it be affecting any and all default Scheduler implementations or should it be more coarse grained?

I would probably not do it. There might be a use-case, there you want to configure how each `Scheduler` should behave (e.g. fire directly after suspension, when times will be adjusted and time > timer_fires_time or not fire, because time was not adjusted and time < timer_fires_time), but this could be done with a simple overload, when creating a `new` Scheduler witth the factory provided by `Schedulers`. But in my opinion there is actually only one value, which should be allowed, and this is `System.nanoTime`, because all work is already delegate to ExecutorService, which internally uses this time-source. This would make sure, that all methods use the same time-source. As I see it, no one ever had such a problem or did not bother, therefore the time and resources are probably not well spend to extend RxJava to support fine grained editing of the time-source.

SchedulerWrapper-Impl:
https://gist.github.com/SergejIsbrecht/2a9d71e781c6f35d7b74e9ae2bc0c6ef =||= [ObservableInterval](https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableInterval.java#L50) uses `schedulePeriodicallyDirect`. Would it work for your periodic needs?

> Any idea why SingleScheduler.Worker does not overwrite SingleScheduler.Worker#schedulePeriodically, just like it is done with SingleScheduler#schedulePeriodicallyDirect

I have to think about this.

 =||= > ObservableInterval uses schedulePeriodicallyDirect. Would it work for your periodic needs?

This is probably more of a isosteric problen, than a real one. Our developers probably use every method in the `Scheduler` and `Worker` class. This is why I can not say in advance, which operators will be used. 

`Scheduler.Worker#schedulePeriodically`
* FlowableInterval
* FlowableBufferTimed
* FlowableWindowTimed

`Scheduler#schedulePeriodicallyDirect`
* FlowableInterval
* FlowableSampleTimed
* FlowableWindowTimed

For example when I use a `SingleScheduler` and compose a Stream, which uses `Scheduler.Worker#schedulePeriodically` and `Scheduler#schedulePeriodicallyDirect` a developer might run into trouble, because a timer fires after suspension, and another one does not.

Example
```
        // Scheduler#schedulePeriodicallyDirect
        Flowable.interval(10, TimeUnit.SECONDS, Schedulers.single())
            // Scheduler.Worker#schedulePeriodically
            .buffer(5, TimeUnit.SECONDS, Schedulers.single())
``` =||= I see.

For a start, would the introduction of a system property `rx3.scheduler.drift-use-nanotime` and behavior help you?

 =||= > For a start, would the introduction of a system property rx3.scheduler.drift-use-nanotime and behavior help you?

Yes, of course. This would be enough for me. I would probably call it `rx3.scheduler.now-use-nanotime`, but either way is fine.

Edit: if this is the way, I would like to suggest, that I backport this change back to RxJava2, because we are currently using it and we would not need to change, before RxJava2 reaches EOL on `February 28, 2021`

If you would like, I would create an PR for RxJava3 and RxJava3, adding said property. =||= > PR for RxJava3 and RxJava3, adding said property

Sure, go ahead. Let's use `rx3.scheduler.drift-use-nanotime` because there could be an implicit assumption that `now(TimeUnit.MILLISECONDS)` is the current time.

 =||= ,0
7181,7179,Bintray is closing down in May 2021,https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/

I don't fully understand what this means for release processes using `gradle-bintray-plugin` or how to migrate.
,Can't we push to mavenCentral directly? =||= There are a few problems:
- The private key is on bintray and can't be extracted, only overwritten. (Maybe @benjchristensen still has it.)
- If we need to generate a new private key, I don't know/remember what to do with it. (It's been years since I setup my own private key for my libraries I release from my machine via your plugin.)
- I don't know how to inject a private key into the GitHub Action. (Having a GH secret string of the key material is one thing, afaik, it has to be imported into a keystore every time so Gradle's sign task can use it.) =||= I have all the ReactiveX keys.  =||= Secrets can be added to GitHub: https://github.com/vanniktech/gradle-maven-publish-plugin/settings/secrets/actions (replace username / repo with target repo):

<img width="1236" alt="Screenshot 2021-02-03 at 22 46 15" src="https://user-images.githubusercontent.com/5759366/106813686-a0cc1900-6671-11eb-9fd1-ad2736999ccc.png">

And then they can be used in GitHub actions:

```yml
name: Publish Release

on:
  push:
    tags:
      - '*'

jobs:
  publish:

    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Install JDK 8
        uses: actions/setup-java@v1
        with:
          java-version: 1.8

      - name: Upload release
        run: ./gradlew uploadArchives --no-daemon --no-parallel
        env:
          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_USERNAME: ${{ secrets.SONATYPE_NEXUS_USERNAME }}
          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_PASSWORD: ${{ secrets.SONATYPE_NEXUS_PASSWORD }}
          ORG_GRADLE_PROJECT_SIGNING_PRIVATE_KEY: ${{ secrets.SIGNING_PRIVATE_KEY }}
          ORG_GRADLE_PROJECT_SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}

      - name: Publish release
        run: ./gradlew closeAndReleaseRepoistory --no-daemon --no-parallel
        env:
          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_USERNAME: ${{ secrets.SONATYPE_NEXUS_USERNAME }}
          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_PASSWORD: ${{ secrets.SONATYPE_NEXUS_PASSWORD }}
```

[Source](https://github.com/vanniktech/gradle-maven-publish-plugin/blob/master/.github/workflows/publish-release.yml)

They key itself needs to be distributed in order for this to work though. Instructions are [here](https://central.sonatype.org/pages/working-with-pgp-signatures.html). =||= I don't think we need to generate new keys. 

How do we get the existing private key up there? Do we need a gpg file added to the project, then reference it from gradle.properties (consequently the key id & passwords are the secrets in your example)?





 =||= Ah, there is an in-memory option: [link](https://github.com/vanniktech/gradle-maven-publish-plugin/blob/master/build.gradle#L104-L108)

It needs an armored-ascii key string: [link](https://docs.gradle.org/current/userguide/signing_plugin.html#sec:in-memory-keys)

This is how to export it: [link](https://wiki.scn.sap.com/wiki/display/XI/Generating+ASCII+Armored+PGP+Key+Pairs#GeneratingASCIIArmoredPGPKeyPairs-GenerateASCIIArmoredKeysfromGPGKeys) =||= Posted #7181.

@benjchristensen Could you update `SIGNING_PRIVATE_KEY` and `SIGNING_PASSWORD`  in [secrets](https://github.com/ReactiveX/RxJava/settings/secrets/actions) with the current RxJava private key info? =||= Yes, I'll do that.  =||= Trying to figure out which of the keys it is ... it's been a while :-) =||= I've got on PGP key with a passphrase, and one without. Not sure which one needs to be used here, so I'll upload the one with a passphrase.  =||= Ok, I guess that can be tried now, and if that doesn't work, I can change it to the other one. Do you need the public key or do you have that already? =||= No need for the public key. =||= First step, ensure the snapshot is still working. https://github.com/ReactiveX/RxJava/runs/1840358093
Next step, create a pre-release for 3.0.11-RC1 to see if the new process works. =||= Pre-released 3.0.11-RC1: https://github.com/ReactiveX/RxJava/runs/1840960933 =||= Almost works, @vanniktech 

No staging repository prefixed with "ioreactivexrxjava3" found. Mae sure you called ./gradlew uploadArchives and `mavenPublish.nexus.groupId` is set correctly. =||= Now [it failed with something](https://github.com/ReactiveX/RxJava/runs/1841200311) and I see two staging repositories opened within 30 seconds of each other. =||= It worked [this time](https://github.com/ReactiveX/RxJava/runs/1841376226).

3.0.11-RC3 should be in [maven central shortly](https://repo1.maven.org/maven2/io/reactivex/rxjava3/rxjava/3.0.11-RC3/).

@benjchristensen I think the key setup worked. =||= ,0
7188,1654,Non-deterministic test failure: schedulers,```
rx.observables.BlockingObservableTest > testSingle STARTED

rx.schedulers.NewThreadSchedulerTest > testUnSubscribeForScheduler STARTED
rx.schedulers.NewThreadSchedulerTest > testUnSubscribeForScheduler FAILED
    java.lang.AssertionError: expected:<2> but was:<8>

rx.schedulers.NewThreadSchedulerTest > testRecursion STARTED
```

```
Test Result (2 failures / +2)
rx.schedulers.ExecutorSchedulerTest.testUnSubscribeForScheduler
```,I was watching this test run and the CloudBees instance was very slow.
 =||= this test can be made deterministic by using the test scheduler for interval(..) instead of the computation scheduler - https://github.com/dmgd/RxJava/commit/e95d4a4156320eab76ad282ae79d1bcbd052fda6
 =||= This is a test for the actual Scheduler implementation in `ExecutorSchedulerTest` so the intent is to be testing real concurrency.
 =||= Sorry, I should have been more clear in my earlier comment.  I'm not talking about using the test scheduler in place of the scheduler under test.  Currently the call to interval(..) is `Observable.interval(50, TimeUnit.MILLISECONDS)` which uses the computation scheduler.  I'm suggesting that instead of that you use the test scheduler, i.e `Observable.interval(50, TimeUnit.MILLISECONDS, testScheduler)`.

The scheduler under test will still observe all emissions, and the original issue #431 that when the observing thread requests unsubscription then the original emitting thread never sees isUnsubscribed() == true is still tested (because if it's not then the second call to advanceTime() will result in further emissions!)

With the current test there is always going to be a chance that the computation thread will get some time to generate more emissions -- we don't have control over the way that the underlying system schedules threads, so we can't control that!!

There are other ways to accomplish determinism here.  E.g. You could put a countdown latch inside the map--

```
.map(new Func1<Long, Long>() {
    @Override
    public Long call(Long aLong) {
      return aLong;
      if (1 == aLong) {
        latch.await();
      }
    }
})
```

--however this really just does exactly the same thing as using the test scheduler: it ensures that once the second interval(..) emission has been emitted, that the thread on which it is emitted does not get a chance to run until the thread on which the emission is observed has had a chance to react to the emission.  Either way works fine and results in the test being deterministic!
 =||= Haven't seen this fail since we moved to travis so closing.
 =||= ,0
7189,195,Unwrap AtomicObservableSubscription?,As far as I can tell, any custom subscription that is passed to `subscribe` gets `wrap`ped in an AtomicObservableSubscription unless `trusted` is true, a flag which can't be controlled from outside.

Since AOS doesn't have an `unwrap` method, how can I pass custom subscriptions in a type safe manner?

Rationale is being able to maintain extra state about a subscription _in_ the subscription.,An Observable by design doesn't expose state so that it can be composed (wrapped) exactly as this is doing. For example, Observable.synchronize() could be used to wrap an Observable before vending it out for use if the Observable was thought to not be thread-safe. This is part of the principles of being functional and monadic.

All state within the Func1 implementation that gets converted into an Observable should be self-contained.

So what is your use case that is causing you to want to reach back into the Observable implementation itself and how are you trying to do that?
 =||= Not sure if it makes a difference, but small correction: we don't want to track state in the Observable, we want to track state in the subscription, which is what the client holds on to.

The reason we want to do this is that on Android we need to deal with component life cycles and need to attach/detach observers to prevent resource leaks, or terminate observable sequence midway through.

I see there is a `BooleanSubscription` which helps terminating loops by checking the subscription for `isUnsubscribed`, which is similar to what we want to do. How would you even use this? Anything I get in return from `subscribe` is wrapped away in an AtomicObservableSubscription.
 =||= The state is always hidden behind the Observable or Subscription interfaces - not leaked out. 

Thus, your Func1 implementation (that becomes and Observable) would return an implementation of Subscription that works with your function correctly to signal an unsubscribe. This is important because the sequences of Observables can be composed n-levels and an unsubscribe will be propagated up the sequence and each Observable then does with it what its implementation dictates - but nothing external ever knows the implementation or tries to reach inside it.

Here's an example of how BooleanSubscription is used:
 https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/VideoExample.groovy#L110

``` groovy
Observable<VideoList> getListOfLists(userId) {
    return Observable.create({ observer -> 
        BooleanSubscription subscription = new BooleanSubscription();
        try {
            // this will happen on a separate thread as it requires a network call
            executor.execute({
                    // simulate network latency
                    Thread.sleep(180);
                    for(i in 0..15) {
                        if(subscription.isUnsubscribed()) {
                            break;
                        }
                        try {
                            //println("****** emitting list: " + i)
                            observer.onNext(new VideoList(i))
                        }catch(Exception e) {
                            observer.onError(e);
                        }
                    }
                    observer.onCompleted();
            })
        }catch(Exception e) {
            observer.onError(e);
        }
        return subscription;
    })
}
```

As for multiple observers subscribing/unsubscribing, that is definitely what Multicast/Publish is all about (https://github.com/Netflix/RxJava/issues/15 and https://github.com/Netflix/RxJava/issues/65) as discussed on Twitter: https://twitter.com/mttkay/status/310819293166178304

It's near the top of the todo list but if you need this functionality sooner than I or someone else is getting to it, perhaps you can try tackling them as they are the right way to handle these issues of state.
 =||= Thanks for clarifying! Have to admit that I'm still getting into the whole mindset of functional programming in Java (the lack of supportive language constructs doesn't help), and it's hard to do it in a clean way when introducing something like Rx into a grown code base. But we're getting there. No rush on the implementation of Multicast, but sure, I'll give it a shot when you guys are too busy!
 =||= Yes, it took myself and my teammates a month or two to adapt our thinking to it and several times we tried breaking the model before we starting thinking functionally. Also the lack of lambdas/closures in Java (until Java8 which I eagerly await) is why we predominantly use RxJava in other languages that support them.
 =||= ,0
7191,719,map doesn't work with random numbers,This may be specific to the Scala Adapter or a general issue.. I'm not sure. It may also be simply disallowed somewhere in the documentation but I couldn't find anything mentioning it.

``` scala
val o = Observable.interval(250 millis)
        .map(x => math.random)
        .take(10)
var id = o map(x => x)

o.subscribe(n => println("n = " + n))
id.subscribe(n => println("id = " + n))
```

produces

```
n = 0.16257918600676124
id = 0.015701253635574397
n = 0.65811522451999
id = 0.6745847570884935
n = 0.08592558068181289
id = 0.6761688548540207
n = 0.1511738754239501
id = 0.37751043543314455
n = 0.3335425497156287
id = 0.2433811198187099
...
```

Of course, we expect the values of the two Observables to be equal but they aren't related whatsoever.,This behavior is the expected behavior. Remove the line `var id = ...` and replace the line `id.subscribe(...)` by a second `o.subscribe(...)`, and you will see that the two outputs are still different. The reason is that everywhere in Rx, each subscriber gets its own version of the Observable it subscribes to. So here, each subscriber gets its own "Observable.interval", so `x => math.random` is executed seperately for each subscriber. If you want several observers to share the same Observable, you should use the `publish` operator.
 =||= You have discovered the distinction between "hot" and "cold" observables and the evil that is side-effects.

http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html
 =||= following up on a previous comment, your code should read something like this: 

```
val (start, o) = Observable.interval(250 millis) map {x => math.random} take 10 publish
val id = o map {x => x}
start()
o subscribe {x => println(s"n = $x")}
id subscribe {x => println(s"id = $x")}
```
 =||= Note that we will be changing the Scala bindings to use ConnectableObservable so while this code work now, in the future you would write something like so:

val observable = Observable.interval(250 millis).map(x => math.random).take(10).publish
val id = observable.map(x => x)

observable.subscribe(x => println(s"n = $x"))
id.subscribe(x => println(s"id = $x"))

observable.connect
 =||= Ah, gotcha.. thanks for the clarification!
 =||= ,0
7193,2190,Buffer might be easier to use with no argument method,``` java
observable.buffer()
```

I believe code speaks for itself. With no argument and no desire for time and quantity limit, harvesting all the values into a collection will be such a candy for the eyes.

Currently I am hacking same logic with adding time limit.

I say, we should add buffer() method with no args.,Hi. ToList does this.
 =||= Thanks. I assumed it will be within transformation section, my mistake. ^^
 =||= ,0
7196,719,map doesn't work with random numbers,This may be specific to the Scala Adapter or a general issue.. I'm not sure. It may also be simply disallowed somewhere in the documentation but I couldn't find anything mentioning it.

``` scala
val o = Observable.interval(250 millis)
        .map(x => math.random)
        .take(10)
var id = o map(x => x)

o.subscribe(n => println("n = " + n))
id.subscribe(n => println("id = " + n))
```

produces

```
n = 0.16257918600676124
id = 0.015701253635574397
n = 0.65811522451999
id = 0.6745847570884935
n = 0.08592558068181289
id = 0.6761688548540207
n = 0.1511738754239501
id = 0.37751043543314455
n = 0.3335425497156287
id = 0.2433811198187099
...
```

Of course, we expect the values of the two Observables to be equal but they aren't related whatsoever.,This behavior is the expected behavior. Remove the line `var id = ...` and replace the line `id.subscribe(...)` by a second `o.subscribe(...)`, and you will see that the two outputs are still different. The reason is that everywhere in Rx, each subscriber gets its own version of the Observable it subscribes to. So here, each subscriber gets its own "Observable.interval", so `x => math.random` is executed seperately for each subscriber. If you want several observers to share the same Observable, you should use the `publish` operator.
 =||= You have discovered the distinction between "hot" and "cold" observables and the evil that is side-effects.

http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html
 =||= following up on a previous comment, your code should read something like this: 

```
val (start, o) = Observable.interval(250 millis) map {x => math.random} take 10 publish
val id = o map {x => x}
start()
o subscribe {x => println(s"n = $x")}
id subscribe {x => println(s"id = $x")}
```
 =||= Note that we will be changing the Scala bindings to use ConnectableObservable so while this code work now, in the future you would write something like so:

val observable = Observable.interval(250 millis).map(x => math.random).take(10).publish
val id = observable.map(x => x)

observable.subscribe(x => println(s"n = $x"))
id.subscribe(x => println(s"id = $x"))

observable.connect
 =||= Ah, gotcha.. thanks for the clarification!
 =||= ,0
7203,7201,3.x Flowable#sample may complete on an interrupted thread,Hi !

Using version 3.0.10, and the following code:
```java
int i = 0;
while (true) {
        System.out.println("i = " + i++);
        PublishSubject<Long> subj = PublishSubject.create();
        subj.toFlowable(BackpressureStrategy.ERROR)
	        .sample(10, TimeUnit.MILLISECONDS)
	        .doFinally(() -> {
		        System.out.println(String.format("Current thread %s is interrupted: %b", 
                                        Thread.currentThread().getName(),
				        Thread.currentThread().isInterrupted())
                        );
		        if (Thread.currentThread().isInterrupted()) {
			        System.exit(1);
		        }
	        })
	        .subscribe();
        subj.onNext(1L);
        
        Observable.timer(10, TimeUnit.MILLISECONDS)
	        .blockingSubscribe(any -> subj.onComplete());
}
```
the loop ends after a few iterations (usually between 250 and 300 on my device).

The first iterations give: `Current thread main is interrupted: false`.
And the last: `Current thread RxComputationThreadPool-7 is interrupted: true`.

I quite understand why I get this result, but I'm still surprised by it. Is it an known/accepted/intended behavior ?

NB 1: Using `buffer` unstead of `sample` gives the same result.
NB 2: Changing `sample` scheduler to `Schedulers.from(Executors.newSingleThreadExecutor(...))` causes the loop to never end.
NB 3: First observed with RxJava2, with no change in behavior.,This is possible behavior because your completion races with the sampling. When the upstream completes, the timer for the sampler thread is cancelled which interrupts it if it happens to run.

If you want to avoid interruption, run the `sample` on a non-interruptible scheduler via [Schedulers.from(Executor, boolean)](http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/schedulers/Schedulers.html#from-java.util.concurrent.Executor-boolean-). =||= Thanks for the explanation and the work-around.

I have been doing a few tests with `Schedulers.from(Executor, boolean)`.
Using `Executors.newSingleThreadExecutor()` has given the expected result (ie an interrupted thread with a value `true` for the boolean, no interruption otherwise).
Using `Executors.newSingleThreadScheduledExecutor()` has not. In both case my code ended with an interruption.
Is there something I have been missing ?
 =||= I don't understand what you are saying. Are you saying you tried my suggestion with those executors and still got the interruption in doFinally? =||= That's it.
I ran the code provided in my first post, with only one modification: I specified a scheduler for the `sample` operator.

I tried the following schedulers:

`Schedulers.from(Executors.newSingleThreadExecutor())`
`Schedulers.from(Executors.newSingleThreadExecutor(), true)`
Both had the expected result.

`Schedulers.from(Executors.newSingleThreadScheduledExecutor(), false)`
`Schedulers.from(Executors.newSingleThreadScheduledExecutor(), true)`
Both ended with an interruption. =||= I see.

Looks like the case with `ScheduledExecutorService` was missed when the non-interruptible feature was added. I'll fix it tomorrow. =||= ,0
7212,721,Add groupByUntil operator to scala adapter,I have the following use case. I create an observable that streams in timestamped data. I would like to aggregate this data into distinct sequences based upon time ranges in which the data arrives (first 5 seconds, next 5 seconds, etc), and have it emitted as completed sequences from an observable. 
To be more explicit, let's call the type of my timestamped data observable, Observable[T]. 
Using groupBy gives me: Observable[(TimeRange, Observable[T])]. 
Next, I can perform a map to remove the TimeRange component from grouping tuple:
Observable[Observable[T]]. 
Then I can use toSeq to make the inner-most Observable return a single sequence for each group.
This is where I run into trouble. Since the groupBy operator doesn't have a mechanism for "closing" a group, the inner most observables will not emit their sequences until all of my timestamped data has been streamed in. Unless I am mistaken, there isn't an easy way to do this with the current set of operators the API provides. 

Thoughts? 

EDIT: Upon reviewing the documentation, there is a function called groupByUntil, which appears in rxJava, but not in the scala adapter. ,Can't you just use Observable's

``` scala
def buffer(timespan: Duration): Observable[Seq[T]]
```
 =||= No, because I do not necessarily want my data to be streamed in real-time. The distinction is that 

```
def buffer(timespan: Duration): Observable[Seq[T]] 
```

will only work if my timestamps correspond exactly to the current time. My data is streamed in with timestamps attached to it. The function above separates the data into groups based upon durations that pass at runtime, however, I would like to separate my data based upon the time stamps that are part of it's signature. 

As I mentioned in my above edit, there is a function groupByUntil, which I am fairly certain would solve my problem, but it is not yet available in the scala-adapter. 
 =||= Your problem might also be solved using this overload of `buffer`:

``` java
public <TOpening, TClosing> Observable<List<T>> buffer(Observable<? extends TOpening> bufferOpenings, Func1<? super TOpening, ? extends Observable<? extends TClosing>> bufferClosingSelector)
```

The type parameters `TOpening` and `TClosing` were recently added, and have not yet found their way into the Scala adapter. And as you said, `groupByUntil` is also missing. Pull requests are welcome ;-)
 =||= Not quite a pull request but here is a solution that works for our purposes:

``` scala
def bufferByKey[T, K](o: Observable[T], keyFunc: T => K): Observable[List[T]] =
  o.scan((None.asInstanceOf[Option[K]],
          List().asInstanceOf[List[T]],
          None.asInstanceOf[Option[List[T]]])) {
  (lastState: (Option[K], List[T], Option[List[T]]), newVal: T) =>
    val (lastKey, acc, emit) = lastState
    val nk = keyFunc(newVal)
    lastKey match {
      case None => (Some(nk), newVal :: acc, None)
      case Some(k) =>
        if (k == nk)
          (Some(k), newVal :: acc, None)
        else
          (Some(nk), List(newVal), Some(acc))
    }
  } flatMap {
    case (_, _, None) => Observable()
    case (_, _, Some(acc)) => Observable(acc.reverse)
  }
```

I think it would be much nicer to build this into the Java core with the chunking stuff but oh well. This solution also won't emit elements from the last change in keys to the closing of the Observable. For example,

``` scala
val o: Observable[Int] = Observable(1 to 11)
val x = bufferByKey(o, { x: Int => x % 3 == 0 })
x subscribe { x => println("x = " + x) }
```

will output

```
x = List(1, 2)
x = List(3)
x = List(4, 5)
x = List(6)
x = List(7, 8)
x = List(9)
```

(Note the absence of 10 and 11.)
 =||= @samuela Nice solution. 

The more I'm looking into it, it looks like almost every function that is being ported from the rxjava code is just a subset of scan and flatMap. For instance:

```
def buffer[T](o: Observable[T])(openings: (T)=>Boolean, closings: (T,T)=>Boolean) = {
  type S = (Boolean, Option[T], Seq[T], Boolean)
  o.scan[S]((false, None, Seq(), false)) {case ((open, first, buffered, closing), elem) =>
    if (open) {
      val Some(unwrapped_first) = first
      val is_closed = closings(unwrapped_first, elem)
      (!is_closed, first, elem +: buffered, is_closed)
    } else {
      val is_opened = openings(elem)
      if (is_opened) (is_opened, Some(elem), Seq(elem), false)
      else (is_opened, None, Seq(), false)
    }.flatMap {case (_, _, buffered, closing) => closing match {
      case true => Observable(buffered reverse)
      case false => Observable()
    }}
}
```

@samuelgruetter Have you guys ever thought about replacing some of the other functions in the library with solutions like these, it seems like it would be easier for you guys to maintain.
 =||= > it looks like almost every function that is being ported from the rxjava code is just a subset of scan and flatMap

Theoretically yes, and as a general rule we want to use existing operators to build other ones whenever it makes sense. In fact, that's part of the Rx Design Guidelines from Rx.Net.

Sometimes however it's not very efficient to do this as it involves extra levels of abstraction so we don't do it. Another way of viewing this is that on the outside we want to be functional and immutable in nature but on the inside we often use imperative, mutable approaches for performance. An example is we have started to make some code less elegant and remove abstractions such as the use of `Notification<T>` to improve performance (by quite a lot).

All that said, I'll be the first to state that all operators in RxJava are not yet implemented to the same degree of quality, nor are they all as battle-tested as we'd like. There's a reason we're not yet to a 1.0 release.

I'm not convinced `buffer` and `window` are completely correct and certainly not convinced that their performance and implementation is as good as it can be. I know `groupBy` has problems and basically needs a re-write. Some use a non-locking approach, others use locks. It's the nature of an open-source project with a 20+ contributors and a team improving it's understanding of the various operators over time. We have chosen to optimize for speed of getting functionality (coverage of operators) into the project and then iterating on improving rather than only allowing 2 or 3 people to slowly try and get through it.

I was working with @headinthebox (Erik Meijer) today on an approach for starting to clean up our operator implementations and establish a pattern for all future refactorings and implementations to follow as we are maturing and approaching towards 1.0 now that we've almost gotten all operators in and have the public API solidifying. This will likely involve common patterns for concurrency, error handling, performance testing, etc, as right now it's been ad-hoc based on who contributed and the intensity of the review done. Another example is that operators heavily used by the Netflix API are far more trusted than ones not used at Netflix. 

I hope this provides some background.

As for this operator missing on the Scala side, that should be a very easy contribution, and now that 0.16.0 is out (which was a big chunk of work) we can quickly iterate on new releases. I can push 0.16.1 tomorrow if someone wants to submit the PR for adding `groupByUntil` to Scala.
 =||= @benjchristensen, thank you for the explanation! It's reassuring to hear a candid report on the state of the project. For those of us interested in contributing to the RxJava project, is there any documentation on the implementation that we could use to get started? In terms of this issue specifically, is this a method which you would like to be included and, if so, would solutions like the one I gave previously be acceptable? I suppose that adding such a method to only the Scala adapter might be frowned upon.. Is this so?
 =||= > I suppose that adding such a method to only the Scala adapter might be frowned upon.. Is this so?

Our goal is for base functionality to be done in rxjava-core so it becomes available to all languages, thus we would rather not implement an operator only in one of the language bindings. The language bindings should be specific to exposing functionality in an idiomatic manner to that language and/or bridging with libraries and techniques of that language (Scala Futures for example). Thus we'd prefer that operators (or other common functionality like Schedulers, Subscriptions, etc) be implemented in rxjava-core and then exposed in the Scala bindings.

>  is there any documentation on the implementation that we could use to get started

This Wiki page is a very basic introduction: https://github.com/Netflix/RxJava/wiki/How-to-Contribute

It is from the beginning of the project though and I think I need to provide a much more detailed document now that lays out the roadmap to 1.0, plans for graduating language bindings to their own top-level projects, patterns for operator implementation etc.
 =||= Certainly, that makes sense. Ok if I get a chance I'll try to put a pull request together for this later.
 =||= Thanks @samuela for your involvement. We made good progress in 2013 but still have maturation to do and your help is appreciated.
 =||= @zsxwing Is this done yet? If not, can you do so in the Scala module?
 =||= I think this can be closed.
 =||= ,0
7227,7226,3.x: Migrate to native GitHub Dependabot,GitHub supports a native Dependabot implementation which provides better/easier integration with GitHub. Logs and details for dependencies will appear in the "Insights" menu on the GitHub repository page.

Steps to migrate to the native Dependabot:

- Disable dependabot-preview by removing RxJava repository from dependabot.com
- Dependabot [security updates enabled](https://docs.github.com/en/code-security/supply-chain-security/configuring-dependabot-security-updates#enabling-or-disabling-dependabot-security-updates-for-an-individual-repository) on GitHub repository
- dependabot.yml configuration file added to .github directory

An Administrator must perform the first two bullets. I will provide a pull request for the configuration file.,nan,0
7227,722,Possible Bug in Buffer function,I believe I have found a bug in the below definition:

```
def buffer(closings: () => Observable[Closing]): Observable[Seq[T]]
```

Consider the following code that should be expected to produce an observable of sequences terminated at every even number:

```
// import the Closing object/class
import rx.lang.scala.util._
// set up a basic observable.
val (start, obs) = Observable.interval(250 millis) publish
// prevent the example from going forever.
val o = obs take 10
// produce a closing at every even number, do not emit otherwise. 
val closings = o flatMap {case x => 
  if (x % 2 == 0) Observable(Closing)
  else Observable()
}
// pass the closings observable into the buffer function 
val buffered = o buffer(() => closings)
// print out the results.
buffered subscribe {x => println(x)}
start()
```

When I run this I get strange output, and the program locks up: 

```
Buffer(0)
Buffer(1)
Buffer(2)
Buffer(3)
Buffer()
Buffer()
Buffer(4)
Buffer(5)
Buffer()
Buffer()
Buffer()
Buffer()
Buffer()
Buffer(6)
Buffer()
Buffer(7)
Buffer()
Buffer()
Buffer()
Buffer()
Buffer()
Buffer()
Buffer()
Buffer()
Buffer()
Buffer()
Buffer()
Buffer(8)
Buffer()
Buffer()
Buffer()
Buffer(9)
```,I think it's not a bug. Note that the `() => Observable[Closing]` function you pass to `buffer` is called once for each opened buffer, and it should return an Observable emitting only 1 `Closing` object, but yours emits many `Closing` objects. This confuses the `buffer` operator and makes it behave weirdly. If you replace the line

``` scala
val buffered = o buffer(() => closings)
```

by 

``` scala
val buffered = o buffer (() => closings.take(1))
```

it works as expected.
 =||= > but yours emits many Closing objects. This confuses the buffer operator and makes it behave weirdly

This still might be a bug in buffer. If exactly one onNext or onClose is expected, then when one of them is fired, the closing observable should be unsubscribed. For example:

```
o.buffer(() -> interval(1 seconds))
```

should unsubscribe from interval after 1 second.
 =||= @akarnokd you're right, but I suggest we first should agree on the semantics of `buffer`. The question is: Should users be allowed to give an Observable emitting more than 1 closing object? Both make sense for me, but we should clearly document our choice.
 =||= Ahh, thanks for the clarification about it only emitting one Closing. The scaladoc currently reads like this for the description of the closings function: 

The function which is used to produce an rx.lang.scala.Observable for every buffer created. When this rx.lang.scala.Observable produces a rx.lang.scala.util.Closing object, the associated buffer is emitted and replaced with a new one.

Could it be made more explicit that the Observable produces one, and only one, Closing object. I didn't pick up on that when I read through it. 
 =||= Additionally, I just started working with a more recent version of the repo and encountered more suspicious looking behavior from this example of the buffer function. Please correct me if I have a misunderstanding if its use. 

```
val obs = Observable.interval(250 millis)
val o = obs take 20
val closings = o flatMap {case x =>
  if (x % 3 == 0) Observable.items(x)
  else Observable.items()
}
val buffered = o buffer(() => closings take 1)
buffered subscribe {x => println(x)}
```

I would expect this code to print out buffers of 3 items, however, when run I get the following output:

```
Buffer(0)
Buffer(1)
Buffer(2)
...
Buffer(17)
Buffer(18)
Buffer(19)
```
 =||= I believe in the previous example, @chrisgrimm meant

``` scala
val obs = Observable.interval(250 millis)
val o = obs take 20
val closings = o flatMap {case x =>
  if (x % 3 == 0) Observable.items(Closing)
  else Observable.items()
}
val buffered = o buffer(() => closings take 1)
buffered subscribe {x => println(x)}
```

I can confirm that it doesn't work. More strange behavior (on 0.15.1):

``` scala
val o = Observable(1 to 20)
val closings = o flatMap { case x =>
  if (x % 3 == 0) Observable(Closing)
  else Observable()
}
val buffered = o buffer(() => closings take 1)
buffered subscribe {x => println(x)}
```

produces 

```
Buffer()
Buffer()
...
Buffer()
Buffer()
Buffer(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
```
 =||= @chrisgrimm and @samuela the output of your examples is correct, because you forgot to use `publish`. If you have not yet done so, you should read about the difference between hot and cold Observables (see http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html), and note that `Observable.interval(250 millis)` and `Observable(1 to 20)` both are cold Observables, and play their items to each subscriber separately.
 =||= Is this still a problem?
 =||= Closing ... no response in a long time, and `buffer` has had significant bug fixes in recent releases. 

@chrisgrimm and @samuela Please re-open if there are still issues.
 =||= ,0
7230,650,Fatal Exception: java.lang.RuntimeException java.lang.RuntimeException in SafeObserver,I get Fatal Exception: java.lang.RuntimeException java.lang.RuntimeException in SafeObserver in cases when both onError and onNext will through exception inside. 

```
observable1
  .subscribe(new Observer<Configs>() {
                    @Override
                    public void onCompleted() {

                    }

                    @Override
                    public void onError(Throwable e) {
                        throw new UnknownError("Ooooppsss");
                    }

                    @Override
                    public void onNext(Configs args) {
                        throw new UnknownError("Ooooppsss");
                    }
                }); 
```

Stack trace:

```
    java.lang.RuntimeException: Error occurred when trying to propagate error to Observer.onError
            at rx.operators.SafeObserver.onError(SafeObserver.java:109)
            at rx.operators.SafeObserver.onNext(SafeObserver.java:125)
            at rx.Notification.accept(Notification.java:121)
            at rx.operators.OperationObserveOn$ObserveOn$2.call(OperationObserveOn.java:121)
            at rx.operators.OperationObserveOn$ObserveOn$2.call(OperationObserveOn.java:116)
            at rx.Scheduler$3.call(Scheduler.java:163)
            at rx.Scheduler$3.call(Scheduler.java:159)
            at rx.android.concurrency.HandlerThreadScheduler$1.run(HandlerThreadScheduler.java:82)
            at android.os.Handler.handleCallback(Handler.java:733)
            at android.os.Handler.dispatchMessage(Handler.java:95)
            at android.os.Looper.loop(Looper.java:136)
            at android.app.ActivityThread.main(ActivityThread.java:5017)
            at java.lang.reflect.Method.invokeNative(Native Method)
            at java.lang.reflect.Method.invoke(Method.java:515)
            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
            at dalvik.system.NativeStart.main(Native Method)
     Caused by: rx.util.CompositeException: UnknownError:Ooooppsss, UnknownError:Ooooppsss
            at rx.operators.SafeObserver.onError(SafeObserver.java:109)
            at rx.operators.SafeObserver.onNext(SafeObserver.java:125)
            at rx.Notification.accept(Notification.java:121)
            at rx.operators.OperationObserveOn$ObserveOn$2.call(OperationObserveOn.java:121)
            at rx.operators.OperationObserveOn$ObserveOn$2.call(OperationObserveOn.java:116)
            at rx.Scheduler$3.call(Scheduler.java:163)
            at rx.Scheduler$3.call(Scheduler.java:159)
            at rx.android.concurrency.HandlerThreadScheduler$1.run(HandlerThreadScheduler.java:82)
            at android.os.Handler.handleCallback(Handler.java:733)
            at android.os.Handler.dispatchMessage(Handler.java:95)
            at android.os.Looper.loop(Looper.java:136)
            at android.app.ActivityThread.main(ActivityThread.java:5017)
            at java.lang.reflect.Method.invokeNative(Native Method)
            at java.lang.reflect.Method.invoke(Method.java:515)
            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
            at dalvik.system.NativeStart.main(Native Method)
```,Issue is very typical for Android. Assume that we do some work with UI in onNext and onError. This work will fail with exception if activity was closed by the time async operation is completed. So we need to ensure that all exceptions in onError and onNext will be suppressed. 
 =||= If you want to suppress everything then you need to make sure you don't throw from within `onError` or an `onErrorResumeNext` operator. You can swallow the errors if you want, but RxJava won't swallow them automatically.
 =||= @benjchristensen got it! thanks.
 =||= cant get it how to resolve it??
 =||= ,0
7230,509,Operator: Generate,Operator Generate (6 variants) for Issue #49.,[RxJava-pull-requests #433](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/433/) SUCCESS
This pull request looks good
 =||= This PR needs to be rebased so it can merge ... along with some other questions/comments above.
 =||= Closing this PR as both this and the other variant (https://github.com/Netflix/RxJava/pull/519) need further work.
 =||= ,0
7230,507,Operation join,Issue #56,[RxJava-pull-requests #431](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/431/) SUCCESS
This pull request looks good
 =||= This needs to be rebased before it can merge (probably because of your other PR I just merged). Can you please update or resubmit?
 =||= Will do shortly.
 =||= ,0
7231,2479,Targeting the work thread for a TrampolineScheduler,So, `TrampolineScheduler` says work will run on the current thread. If I'm using `scheduleOn(Schedulers.trampoline()` in part of my Observable chain, how do I change which thread the sequential trampoline work is actually run on?

My assumption is it's something like this, wrapping it in another `scheduleOn`:

```
.scheduleOn(Schedulers.trampoline())
.scheduleOn(Schedulers.io())  // Or whatever scheduler you want the work done on.
```

This does look a bit funny and would require extra commenting to explain to a casual observer. If that's the case, would it make sense to add a static constructor for trampoline that can wrap another scheduler? Like:

```
.scheduleOn(TrampolineScheduler.on(Schedulers.io())
```

or even:

```
.scheduleOn(TrampolineScheduler.on(worker))
```

I can whip up a PR for such a thing if it would be helpful. If wrapping schedulers isn't the right way to do it, what is? :),The `TrampolineScheduler` is rarely used directly. It exists primarily to serve the `repeat`/`retry` recursive use cases. Dropping it into a normal `Observable` chain using `subscribeOn` is effectively a "no op" since it won't change behavior or where it executes. 

What are you trying to achieve?
 =||= So there may be a much better solution for this, but I have a pipeline of requests to do more work. In this case, it's requesting the next page in a request. So I may have two Observables of events of users asking for next/prev pages (through scroll events, buttons, whatever). Anyway, part of my requirements are that only one of these operations be done at once, and ignore incoming requests until ready for a new one. I was planning on using `onBackpressureDrop` to accomplish that part.

Anyway, the trampoline seemed to be the right way to enforce a sequence of a single action at a time, but it sounds like there might be a better way.

So, laying out the full scenario in another way, there are actually two paginations possible, next or previous. I have an Observable coming in for each so I can get the latest for each end. When a new page comes in, one or both of these may update. The signals to fetch a new continuation come in separately. If a user scrolls down to the bottom of a page (requesting a 'next') page, then we should be able to grab the latest next continuation (possibly with `sample`) and process it, as long as there is no currently processing continuation in the pipeline.

Hope that made a little bit of sense at least. :)
 =||= It sounds like you're trying to do flow control with user events. This sounds directionally like `debounce` and  `switchOnNext` are where you should be looking. 

> enforce a sequence of a single action at a time

You can just `merge` the 2 Observables together and it will give you a single stream. 

> ignore incoming requests until ready for a new one

Depends on what you mean by "ready for a new one". Is that based on user event? If so, then something like `switch` is probably relevant. I would need to understand the use case better to provide more guidance. Generally when dealing with user events all previous items should be cancelled and the latest event acted upon. This is what debounce/switch can help you achieve. 
 =||= So, we don't want to trigger a new page load (network request) until the previous one has finished. We enforce that 2-ways, so only a next or previous call on a page can be going, not both at once. So if a user keeps triggering the event that would load, we don't do extra work or spam the requests. We also don't want to queue up the user's request, since it's a transient event. Basically, from fetch page start -> fetch page end, we ignore the user input, and then start listening again after the page is fetched (or canceled, etc..) 
 =||= I'm closing this due to inactivity. If you have further questions, please don't hesitate to reopen this issue or post a new one.
 =||= ,0
7231,2468,Proposed improvement on OnNextValue stacktrace rendition,Hi,
I was looking at a stacktrace with `OnNextValue` in it and saw that the last emitted item, causing the Exception, was indeed logged in the stacktrace as just a `className`, as per #1401. (see also [the rendering code](https://github.com/ReactiveX/RxJava/blob/7924a3e919d408baf95de253f2dbcca1bfcd573d/src/main/java/rx/exceptions/OnErrorThrowable.java#L140)).

But in some contexts, like for the Couchbase SDK or some other framework using Rx, I think it is acceptable to say that we can identify more types that it makes sense to stringify. We can check that these types have a sufficiently performant, safe and slim `toString()` implementation to be fully rendered by `OnNextValue`.

Offering a mean to let RxJava know about such types would allow the String rendering to be activated in a cross-cutting manner, without reworking every single stream produced by the framework/library to induce additional logging behavior.

I see two broad ways of achieving such a thing:
- via an _interface_ in RxJava
  - either a marker interface (implementing classes would then be rendered by calling their `toString()`)
  - or a functional interface (implementing classes would have to define some sort of short, performant and safe `toString()`, `toShortString()`?, to be used by `OnNextValue` for rendering)
- achieve the same via a _RxJava Plugin_: providing a hook to decide or not if a value should be fully rendered (additional method on `RxJavaErrorHandler`?)

What do you think about this idea? If we can agree on a way of doing this, I'd be happy to contribute it!,I'm okay with exploring improvements to this (and anything else to improve debugging).

The marker interface could work, but it is intrusive to the public API and the types being used by libraries. It seems the plugin model would be the most powerful and would work on any types without forcing them to conform to the RxJava marker interface, which is important if the types are 3rd party and can't be changed, or they live somewhere that should not have dependency on RxJava.

One drawback of how the plugin registration works right now is that it assumes and enforces only 1 registration at startup, so if 2 libraries both tried, one would fail. Perhaps for this use case we want to allow many plugin registrations? 

It could be that `RxJavaErrorHandler` should support a chain of implementations?

@ReactiveX/rxjava-committers Do you have preferences on how this is pursued? 
 =||= I don't want another `Serializable` so I'd go for the plugin-based callbacks. I'd extend `RxJavaErrorHandler` with a 

``` java
public <T> Subscription registerErrorValueRenderer(
    Class<T> clazz, Func1<? super T, String> tostring);
public <T> boolean hasErrorValueRenderer(Class<T> clazz);
```

But what should happen if the same class was registered multiple times? I'd throw an `IllegalArgumentException` so libraries don't try to register for common types such as `Integer` but only their own types.
 =||= I was thinking about doing it the plugin way on the existing plugin but that breaks a committed interface doesn't it? So thinking about doing a separate plugin, and one that supports chaining (composite pattern?) :)
 =||= `RxJavaErrorHandler` is an abstract class so adding a regular method has only the risk if there is someone implementing this class with a method having the same name. 

Chaining has some issues: in worst case it would take N steps to reach a value renderer. You'd need some cooperation mechanisms to see who is interested in giving an answer and not ask anyone else (such as Swing's KeyEvent.consume() or something).
 =||= Ah right it's abstract!
What I was going for was one-in-all renderer, something like:

```
public interface ErrorRenderer {
    String attemptRender(Object item);
}
```

The renderer internally checks for relevant types and return a string value if it can manage the object, `null` if not. Chaining would involve having a composite root renderer and going to next renderer in chain if previous one had returned null. So one renderer per "client layer", not per type.

The stack rendering code would then check for primitive types (as it does now), then call `renderer.attemptRender(item)`, then if result is null fallback to printing the class name.

Example renderer implementation:

```
public MyErrorRenderer implements ErrorRenderer {
    public String attemptRender(Object item) {
        if (item == null) return null;
        if (item instanceof MyTypeWithShortToString) {
            //this one we know has a safe short toString()
            return item.toString();
        } else if (item instanceof MyOtherType) {
            //this one has a long toString but another safe short string representation method
            return ((MyOtherType) item).asShortString();
        }
        return null;
    }
}
```

what do you think?
 =||= I suggest you post a PR so we have a more complete picture how things can work.
 =||= sure, I think I may be able to find time tomorrow (CET) :+1: 
 =||= submitted a PR, had some problems during CI that seem unrelated to my work, any clue?

> No such property: release.scope for class: org.gradle.api.internal.project.DefaultProject_Decorated

edit: nevermind the issue has disappeared
 =||= Looks completed in #2632
 =||= ,0
7231,2460,Fix the race condition in OnBackpressureBuffer,Fixed #2459,Closed as it's already fixed in #1955
 =||= ,0
7234,469,Why are PublishSubject, etc considered 'internal/not needed by users' in scala-lang?,https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subjects/package.scala#L40

I have an instance in an Akka Actor where I'd like to pass back an Observable to the a client, and then manually convert messages passed to that actor as events on that observable for the client to handle. I can do this with:

``` scala

val ps = PublishSubject.create[Int]()
val o = Observable(ps)

// send o to client

// on incoming message,
ps.onNext(i)
```

Which works fine but it seems like shows that PublishSubject can be used in a not-internal way, and I certainly would use one out of the scala-lang package instead of having to dip outside of it.

I haven't used RxJava much but I used to do this with a .NET Rx project a lot, where objects would manage observables and converting non-IObservable pattern events into events on those observables. Is there a better way to convert Akka message streams\arbitrary non-RxJava streams into Observable events that I am missing?,Probably they have just not been wrapped yet by those contributing to the scala-lang module.

Here is a blog post from @jmhofer working with Akka: http://jmhofer.johoop.de/?p=507

You can see some background on the Scala support being added here: https://github.com/Netflix/RxJava/issues/336 and learn more about the implementation via this presentation starting around the 52 minute mark: http://youtu.be/tOMK_FYJREw?t=52m13s

You can get involved and contribute to this module: https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala
 =||= Thanks for the resources, I'll take a look. I worked in C# for years and used Rx extensively. I'm glad to see it make it's way into scala. I'll see what I can contribute.

Cheers,
Rob
 =||= It's me who wrote that "PublishSubject, etc are considered internal/not needed by users", but that's wrong, please discard it. 

I think @headinthebox started/wanted to start writing Scala bindings for these subjects, but I'm not sure what the status is.
 =||= ,0
7234,519,Operator Generate again,Issue #49
- Updated tests to use TestScheduler
- Removed class TimeSpan and the timeSelectors are expected to return a nanosecond-resolution value.,[RxJava-pull-requests #447](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/447/) SUCCESS
This pull request looks good
 =||= A small tip about github: You can continue to push any commits to your remote branch. The pull request will be updated automatically.

If you find some conflicts between your remote branch and your local branch, you can use `--force` to override your remote branch by force. Github will keep the pull request consistent with your remote branch. I think it's better than opening another pull request.
 =||= @zsxwing I know; my very first pull was such but I received the tip to use clean branches, especially when the master changes above me.
 =||= Do you mean https://github.com/Netflix/RxJava/pull/509#issuecomment-29109489 ? I think @benjchristensen was suggesting `git rebase`.
 =||= In addition, if it's hard to rebase it on master, I also think a new pull request is good.
 =||= > Removed class TimeSpan and the timeSelectors are expected to return a nanosecond-resolution value.

We need to support `long delayTime, TimeUnit unit` as discussed at:https://github.com/Netflix/RxJava/pull/509#discussion_r7916351
 =||= ,0
7246,227,Merge overload - possibility A,A possible implementation of scheduler overloads on the merge operator.

Related to Schedulers pulled in https://github.com/Netflix/RxJava/pull/225 and issue https://github.com/Netflix/RxJava/issues/19,This implementation uses `subscribeOn`

See https://github.com/Netflix/RxJava/pull/226 for another implementation using `Scheduler.schedule`

Is there any reason to use `Scheduler.schedule` on an internal operator implementation instead of just leveraging `subscribeOn` (other than when we need the delay arguments of course)?

For example, on a method overload of `merge` is this okay?

``` java
        return merge(source).subscribeOn(scheduler);
```

or is there some reason to inside the `OperationMerge` do this:

``` java
                return scheduler.schedule(new Func0<Subscription>() {

                    @Override
                    public Subscription call() {
                        return new MergeObservable<T>(o).call(observer);
                    }
                });
```

They seem to accomplish the same thing but would like to know if there's a reason to prefer one over the other.

I prefer just reusing `subscribeOn`. 

I can't tell from reading C# code what it does as I can't find the extensions that implement the override methods!
 =||= [RxJava-pull-requests #82](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/82/) SUCCESS
This pull request looks good
 =||= ,0
7246,226,Merge overload - possibility B,A possible implementation of scheduler overloads on the merge operator.

Related to Schedulers pulled in https://github.com/Netflix/RxJava/pull/225 and issue https://github.com/Netflix/RxJava/issues/19,This implementation uses `Scheduler.schedule`

See https://github.com/Netflix/RxJava/pull/227 for another implementation using `subscribeOn`

Is there any reason to use `Scheduler.schedule` on an internal operator implementation instead of just leveraging `subscribeOn` (other than when we need the delay arguments of course)?

For example, on a method overload of `merge` is this okay?

``` java
        return merge(source).subscribeOn(scheduler);
```

or is there some reason to inside the `OperationMerge` do this:

``` java
                return scheduler.schedule(new Func0<Subscription>() {

                    @Override
                    public Subscription call() {
                        return new MergeObservable<T>(o).call(observer);
                    }
                });
```

They seem to accomplish the same thing but would like to know if there's a reason to prefer one over the other.

I prefer just reusing `subscribeOn`. 

I can't tell from reading C# code what it does as I can't find the extensions that implement the override methods!
 =||= [RxJava-pull-requests #81](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/81/) SUCCESS
This pull request looks good
 =||= ,0
7246,213,More formal support for Scala,- This allows for type safety in statically-typed languages
  - This prevents dynamically-typed languages from hooking into rxjava-core.
    -- See #204 for details on code generation for dynamic languages
  - Added Scala implicits into rx.lang.scala.RxImplicits
  - Added tests of most methods on Observable using Scala functions
  - Fixed Scala Gradle/ScalaTest build,[RxJava-pull-requests #56](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/56/) FAILURE
Looks like there's a problem with this pull request
 =||= This pull request is for issue https://github.com/Netflix/RxJava/issues/208
 =||= The Scala implicits look good to me. Adding the ability to use observables the for-comprehension way is awesome.

Maybe it's better in the long run to use the "enrich my library" pattern and add explicit ".toRx" methods instead of all the automatic implicit conversions (see JavaConversions vs JavaConverters)? I'm not sure about that. Imho it's an argument of convenience vs explicitness. - However, as all this only concerns the Rx utility ActionX and FuncX classes I think I'd also prefer direct implicit conversions because the intent of those classes is very specific, and they match the Scala functions very naturally.
 =||= @jmhofer I considered the .toRx approach as well, but in the end I agreed with your point about the scope of these implicits.  Since we're only converting into rx.FuncX and rx.ActionX, it seems like it's hard to hit some unintended consequences.  

The only thing holding this up is the work on #204, which I'm making good progress on.
 =||= Just checking in ... this is still on hold while waiting on https://github.com/Netflix/RxJava/issues/204.

Good progress has been made by @mattrjacobs but completion has been held up for a bit (higher priority work).
 =||= ,0
7268,7,Observable: abstract or final,There is discussion about whether Observable should be a "final class" and only be usable via Observable.create(Func) or whether we should leave it as abstract.

Discuss and decide ...,I vote not final.
If it were final then it would be impossible to extend Observable to add operators and still interoperate with other code that uses Observable.
 =||= Agreed
 =||= We have decided to not make it final.

But we also have changed it from being abstract to a normal concrete class.

The 'subscribe' implementation is passed in via a protected constructor or using Observable.create(Func1)
 =||= ,0
7270,299,OperationToObservableIterable should call onError?,It seems a bit odd that the OperationToObservableIterable class doesn't catch exceptions and call onError. All of the other wrappers at that level catch exceptions and  call onError. It seems to break the contract of what happens when you pump a value into an observer. In my use case I am trying to test error handling by returning badly formatted data with Observable.just(badResponseObject) and the exception was bubbling out of the call and none of the onError cases were being executed. Perhaps I am missing something?,Not sure how I missed responding to this ... can you provide a unit test to demonstrate the issue?
 =||= Anyone able to replicate this?
 =||= This test succeeds due to the fact that `Observable.subscribe` catches the exception from the immediate iteration of the source sequence.

``` java
@Test 
public void testFailOnNext() {
    Observable<Integer> source = Observable.create(toObservableIterable(
       Arrays.asList(1, 2, 3)));

    @SuppressWarnings("unchecked")
    final Observer<Object> observer = mock(Observer.class);

    Observer<Integer> failer = new Observer<Integer>() {
        @Override
        public void onNext(Integer args) {
            if (args > 1) {
                throw new RuntimeException("Forced failure");
            }
            observer.onNext(args);
        }

        @Override
        public void onError(Throwable e) {
            observer.onError(e);
        }

        @Override
        public void onCompleted() {
            observer.onCompleted();
        }

    };
    source.subscribe(failer);
    verify(observer, times(1)).onNext(1);
    verify(observer, times(1)).onError(any(RuntimeException.class));
    verify(observer, never()).onCompleted();
}
```

But when moved to another thread via observeOn, the exception is just swallowed by the threadpool. It is not a problem with the toObservableIterable but with the observeOn not expecting `not.accept(observer)` to throw.

``` java
@Test 
public void testFailOnNextScheduled() throws InterruptedException {
    Observable<Integer> source = Observable.create(toObservableIterable(
        Arrays.asList(1, 2, 3))).observeOn(Schedulers.threadPoolForComputation());

    @SuppressWarnings("unchecked")
    final Observer<Object> observer = mock(Observer.class);

    Observer<Integer> failer = new Observer<Integer>() {
        @Override
        public void onNext(Integer args) {
            if (args > 1) {
                throw new RuntimeException("Forced failure");
            }
            observer.onNext(args);
        }

        @Override
        public void onError(Throwable e) {
            observer.onError(e);
        }

        @Override
        public void onCompleted() {
            observer.onCompleted();
        }

    };
    source.subscribe(failer);

    Thread.sleep(1000);

    verify(observer, times(1)).onNext(1);
    verify(observer, times(1)).onError(any(RuntimeException.class));
    verify(observer, never()).onCompleted();
}
```
 =||= No response on this in 6+ months so closing out ... re-open if still an issue. 

Many improvements occurred related to error handling in that time.

This test is passing now:

``` java
@Test 
    public void testFailOnNextScheduled() throws InterruptedException {
        Observable<Integer> source = Observable.from(Arrays.asList(1, 2, 3)).observeOn(Schedulers.computation());

        @SuppressWarnings("unchecked")
        final Observer<Object> observer = mock(Observer.class);

        Observer<Integer> failer = new Observer<Integer>() {
            @Override
            public void onNext(Integer args) {
                if (args > 1) {
                    throw new RuntimeException("Forced failure");
                }
                observer.onNext(args);
            }

            @Override
            public void onError(Throwable e) {
                observer.onError(e);
            }

            @Override
            public void onCompleted() {
                observer.onCompleted();
            }

        };
        source.subscribe(failer);

        Thread.sleep(1000);

        verify(observer, times(1)).onNext(1);
        verify(observer, times(1)).onError(any(RuntimeException.class));
        verify(observer, never()).onCompleted();
    }
```
 =||= ,0
7270,277,Finally Happens after onCompleted,Looks like `finallyDo` is behaving wrong:

``` groovy
package rx.lang.groovy.examples
import rx.Observable

class Testing {

    static class myActionClass implements rx.util.functions.Action0 {
        void call() { println('Finally'); }
     }

    static main(args) {



        def myAction = new myActionClass();
        def numbers = Observable.toObservable([1, 2, 3, 4, 5]);

        numbers.finallyDo(myAction).subscribe(
          [ onNext: { println(it); },
            onCompleted:{ println("Sequence complete"); },
            onError:{ println("Error encountered"); } ]
        );

    }

}
```

```
Output:

1
2
3
4
5
Sequence complete
Finally
```

I believe "Finally" should happen before "Sequence Completed",This issues was raised when `finally` PR was being sent. https://github.com/Netflix/RxJava/pull/196#issuecomment-15026180

Here is the C# equivalent code I just checked with.

``` c#
using System;
using System.Reactive.Linq;

var members = new[] { 1, 2, 3, 4, 5 }.ToObservable();

members
    .Finally(() => Console.WriteLine("Finally"))
    .Subscribe(Console.WriteLine /* next */, Console.WriteLine /* exception */, () => Console.WriteLine("Sequence Completed"));
```

Output:

```
1
2
3
4
5
Sequence Completed
Finally
```

Current behavior is correct.
 =||= Great. Thank you for confirming with C# code.
 =||= ,0
7270,278,Rx Guideline 6.5: Subscribe implementations should not throw,Some flavours of subscribe seem to ignore this guideline in the case that the given `final Object onNext` is null, for example: (Observable.java:366)

```
public Subscription subscribe(final Object onNext, final Object onError) {
    // lookup and memoize onNext
    if (onNext == null) {
        throw new RuntimeException("onNext must be implemented");
    }
    final FuncN onNextFunction = Functions.from(onNext);
```

This behaviour could be deliberately chosen, but then I wonder why other flavours of subscribe (those where an `Action1<T>` is passed) do neatly follow this guideline and only throw when onNext is actually being called: (Observable.java:428)

```
        public void onNext(T args) {
            if (onNext == null) {
                throw new RuntimeException("onNext must be implemented");
            }
            onNext.call(args);
        }
```

Moreover, I would actually expect both cases to call onError instead of throwing an Exception, though this could perhaps be defended, and for sure you would want to fix issue #198 first. It seems strange to me however that there is this difference in behaviour between passing an Object and passing an Action1 for onNext, or am I missing something?,The idea is that if calling a method with specific arguments for handlers that null should not be passed in and that this is considered a programmer error, thus throwing an exception rather than invoking `onError`. In short, this is argument validation.

Any difference between Action1 or Object being passed in is a bug, they should behave the same (and we're actively working on getting rid of the Object overloads while still supporting the various languages).

While glancing through the code I see for example what appears to be the result of refactoring placing the null check inside the `onNext` call instead of at the top of the method as an argument validation: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L428

I consider that incorrect, as these are basically intended to be checking that the handlers passed in are valid and thus should be done before any actual Observable logic is invoked.
 =||= Okay, it's clarifying to hear the incongruity between Objects and Action1's is an error.

Whether they should throw an exception or call onError is defensible in favor of either, and perhaps not very important. I would actually choose the latter as it allows to handle all errors in one place and makes calling subscribe a bit simpler (try&catch never needed), but having to do a null check before calling subscribe sounds tolerable.
If both onNext and onError are null, then an exception will still be thrown anyway (if #198 gets fixed).
 =||= ,0
7270,292,Kotlin Language Adaptor,Langauge adaptor for kotlin,[RxJava-pull-requests #165](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/165/) FAILURE
Looks like there's a problem with this pull request
 =||= Is a problem with the Perm-Gen memory size when compiling the scala module after you download the kotlin libraries for the first time. The problem disappear growing up the Perm-Gen size, or running the whole process a second time  
 =||= Thank you for submitting this, I am not ignoring it due to lack of interest, I'm just overly busy at the moment but I will get around to this!
 =||= No problem
 =||= @MarioAriasC you might want to redo this on a feature branch as there's a lot of clutter (merge commits, whoops I forgot this) here.  I'll review anyway, but we are interested in merging concise, complete commits.  make sense?  Let me know if you need git syntax help.
 =||= looks good to me.  sufficient unit tests, etc.  cleanup the files, build.gradle, and commit, then ask @benjchristensen!
 =||= @adriancole Any help with git syntax (and other things) will be very appreciated 
 =||= sure.

It looks like you are 7 commits ahead of master (merges plus the other things you've added)

do `git reset HEAD~7` which should unstage your changes.

Then, you do `git pull upstream master` to reset your head to latest.
Then, redo your commit, and you'll need to do `git push -f origin master` to overwrite the commits here.

hope this helps.
 =||= We are getting very close to being able to pull this in (with some refactoring) now that pull https://github.com/Netflix/RxJava/pull/300 is coming.
 =||= Does Kotlin support closure/function coercion like Java 8 or Groovy 2.2 (http://docs.codehaus.org/display/GROOVY/2013/07/09/First+beta+of+Groovy+2.2+available) or allow dynamic generation of extension methods?

I see that Kotlin has extension methods, but every method must be defined manually.

I'm interested in a mechanism to automatically coerce from Kotlin functions to RxJava Function/Action classes, or dynamically generate the extension methods. Here's how I generate the extension methods dynamically in Groovy: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/RxGroovyExtensionModule.java#L84
 =||= For background on the previous questions and why it has been so long in responding to this pull request look at release 0.11.0 which significantly changes how we do language adaptors: https://github.com/Netflix/RxJava/releases/tag/rxjava-0.11.0
 =||= Kotlin support function coercion is called SAM (Single Abstract Method) Conversions, this support was introduced in M5.2 and completed in M6 http://blog.jetbrains.com/kotlin/2013/08/kotlin-m6-is-here/

Personally I used it in other project and works fine, but sometimes the compiler can infer the actual type of the interface, in those cases we could fall back on Extension methods.
 =||= That sounds like it could "just work" without anything special then. If not then perhaps the extension methods can fix where we have issues.

Can you give it a try against the new rxjava-core? If coercion is all that's needed then it's simple. If you find issues and extension methods would help, or there are extras that would benefit Kotlin (make it more idiomatic etc) that can be added through a utility class, extension methods etc, it would be great to get an updated pull request.

If nothing else, examples of Kotlin code using RxJava would be great if coercion handles all needed cases.
 =||= @benjchristensen I'll close this pull request and open a new one. I have several problems with Git and gradle related to my changes. 

I want to start fresh, will be more easy for all of us 
 =||= ,0
7270,293,Expose ScheduledSubscription on the public API,I understand it should be transparent for a client where an observable was scheduled. However, we'd actually like to ensure that our service objects schedule operations on an appropriate scheduler (we use different schedulers for e.g. API requests and local storage I/O).

This is not possible at the moment since there is no way to obtain information about this by inspecting the observable or the subscription. Since subscribeOn effectively creates a new observable, there is also no simple way to use mock objects other than to spy into the implementation using partial mocks, which is not great.

I was wondering if it would make sense to change ScheduledSubscription so that

a) ScheduledSubscription is a public top level class
b) exposes a method getScheduler that returns the currently private scheduler instance

so that clients can test subscriptions in unit tests in the following way:

Subscription sub = serviceObject.performJob().subscribe(...);
assertThat(sub, instanceOf(ScheduledSubscription.class));
assertThat(sub, ((ScheduledSubscription) sub).getScheduler(), equalTo(expectedScheduler) );,Answered in https://github.com/Netflix/RxJava/pull/294
 =||= ,0
7270,297,Remove unit tests from distribution JAR,Embedded unit tests make up 50% of the rxjava-core JAR size. Factoring these out into a separate source tree would allow for a more manageable library size for distribution in size-constrained applications. Removing the unit tests from the JAR dropped the size from 600K to 315K.,+1
 =||= I noticed a line that was put in comments which excluded unit tests in the [build.gradle](https://github.com/Netflix/RxJava/blob/master/rxjava-core/build.gradle). I do know that there are unit tests residing in `src/main/java`, so you would need to move those first.
 =||= The unit tests are internal classes of the objects they test. Separating them out would eliminate the junit and mockito dependencies in the core source.

... just read the reasoning for that: http://benjchristensen.com/2011/10/23/junit-tests-as-inner-classes/

This article brings up some interesting topics. Obviously this decision was well thought out. 
 =||= Indeed. Some very good points in that article.

The one problematic unforeseen consequence that I currently see is that the Scala compiler actually checks for the existence of those internal classes. In contrast to Java, It doesn't allow them to just be absent, even if they're not used anywhere. This means that the idea of simply removing all those inner test classes during packaging doesn't work anymore for any libraries that want to be usable in Scala, which is a pity.
 =||= This was also discussed at: https://groups.google.com/forum/#!topic/rxjava/b4DYjvUTazI

For Android specifically, is it not common to use tools such as Proguard (http://proguard.sourceforge.net/index.html and http://developer.android.com/tools/help/proguard.html) to reduce jars to only include classes used by an app? I have been told that is the case (but I don't developer for Android so can't speak to this).

Unfortunately due to Groovy/Scala (and possibly other languages) the general solution of stripping the $UnitTest classes before creating the jar has been disabled, otherwise the issue of Jar file size would not exist.

At this time however the intent is to leave things as they are. 
 =||= What dependencies? They are 'provided' and not runtime. 

RxJava has 0 dependencies beyond the JVM and is a single jar library.
 =||= You're right. I missed this thing about "provided" dependencies. Then checked my own build and found no unit test dependencies, understood the idea and removed my comment. Sorry about that.
 =||= It's okay, it's what I get for doing something unconventional :-)
 =||= @benjchristensen To give you some background on the proguard/Android development practices:
- The testing tools for Android are really shoddy. You cannot run POJO unit tests*\* without running it through the android framework. 
- So running unit tests are pretty slow, as that implies compiling your apk (application package), deploying it on the device, and then having your unit tests run on them. It's a couple of seconds, but still extremely slow for unit tests standards.
- Adding proguard to the mix increases that time by a few more seconds, which makes the possibility of fast testing even less likely. This is why people avoid using proguard (during development).

Ok, so you may then ask: Why not disable proguard for development builds alone? Well, that's what most of us do. However:
- Android has [a hard dex method limit of 64k](http://jakewharton.com/play-services-is-a-monolith/). This basically means, that if you hit this limit (by virtue of having many referenced methods in your app or referencing external libraries that do the same), you are stopped from compiling an apk. 
- This means that you cannot compile an app (even on development builds) if you've crossed that limit (it's actually pretty bad, because-as mentioned before- this means you can't even run basic unit tests because of this). 

In sum, Android developers (should) use proguard for release builds, but prefer having very small libraries as that helps in avoiding other problems during development.

 *\* Well that is not entirely true, since you can run POJO unit tests, but you have to place them in a different project, and reference them like libraries from within your main project. It's not hard, but not easy enough.
 =||= Thanks for the info, it was educational for me on things I didn't know. However, what triggered this since this issue has been closed for 10 months?
 =||= hah apologies for waking the dead.

I noticed my apk size increased by about an MB after adding in RxJava, so I
started looking around for strategies on minimizing the library size (or if
that even made sense). I ran across these [two](https://github.com/Netflix/RxJava/issues/439) [threads](https://github.com/Netflix/RxJava/issues/297), and thought i'll add my two
cents for posterity, since the question was raised in both threads.

On Fri, Aug 8, 2014 at 8:17 PM, Ben Christensen notifications@github.com
wrote:

> Thanks for the info, it was educational for me on things I didn't know.
> However, what triggered this since this issue has been closed for 10 months?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/Netflix/RxJava/issues/297#issuecomment-51675620.
 =||= Ah, makes sense :-) Other than removing functionality from rxjava-core, I am not aware of anything more we can do to reduce the size of the Jar at this point. It has zero dependencies, no testing code and only contains core functionality.

Thanks for the background on Android. The 64k limits sound very painful!
 =||= ,0
7270,298,LINQ /Stream,Hi,

Will this add LINQ like functionality in the future? This is one thing that makes .NET Rx very attractive.

Suminda,We have no intention of attempting to create a DSL in Java as the language does not afford those capabilities.

If someone wanted to pursue it in a different language such as Groovy, Scala or Clojure, it could be a great [contrib module](https://github.com/Netflix/RxJava/tree/master/rxjava-contrib). 
 =||= ,0
7270,282,PublishSubject's HashMap makes groupBy and such non-deterministic.,In a few cases already I noticed unexpected and non-deterministic behaviour occurring when subscribing (directly or via a chain of observables) to a PublishSubject source. This happens when subscribing from within an onNext method that is directly or indirectly triggered by that same source. The newly subscribed observer may or may not directly receive the onNext call from the same event. An example where this is annoying:

```
connectToEventStream()
    .publish()
    .groupBy(event -> event.source).subscribe(eventStream -> {
        LogFile log = new LogFile(eventStream.getKey() + ".log");
        eventStream.subscribe(event -> log.write(event.getMessage()));
    });
```

In this example the first event of each source might be skipped and not be logged, but other times it will work fine. To me this seems undesired behaviour. There may be cases where it actually is preferable that the current item will be skipped when subscribing from an onNext method, but this happening unpredictably is never a good idea.

The cause of the unpredictability is the implementation of Map that is used in PublishSubject, which when iterating on the map's values sometimes includes new items:

>  Similarly, Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration.

And supposedly whether an item will be iterated over or not depends on the hashes of the subscriptions, thus totally unpredictable. A sensible option would be to use a different implementation of Map that does iterate over any items that are added during the iterating loop, but it looks like this implementation then has to be written or found first as java seems not to provide anything like this.

As a quick hack I added this code to the PublishSubject, but I considered this solution too ugly to be worth a pull request (commit a7fc861):

```
public void onNext(T args) {
    int observersSize;
    Set<Observer<T>> notifiedObservers = new HashSet<Observer<T>>();
    do {
        observersSize = observers.size();
        for (Observer<T> observer : observers.values()) {
            if (!notifiedObservers.contains(observer)) {
                observer.onNext(args);
                notifiedObservers.add(observer);
            }
        }
    } while (observers.size() > observersSize);
}
```,Short Version: It looks like a bug with `groupBy` not `publish`.

Long Version:

PublishSubject will send events through to whatever subscribers it currently has and not replay past events as new subscribers arrive. This is why the `publish` operator returns a `ConnectedObservable` that allows a developer to wait for all Observers to subscribe and then `connect` the source that is publishing.

The `ConcurrentHashMap` implementation of `Map` used by `PublishSubject` is the correct thread-safe implementation to be using. It allows concurrent modifications and each time `values()` is invoked (on each `onNext` call) it gives the current state of the data (all subscribers) in the map in a thread-safe manner. Thus it is thread-safe for the `onNext` call to continue being invoked while subscribers come and go, but it will naturally be a race condition as to whether the subscription occurs before-or-after the `onNext` if they are done concurrently. 

As to the issue you're seeing I think it's not `PublishSubject` with the issue but the implementation of `groupBy` which seems to re-subscribe to the underlying `Observable` on each group that gets emitted. That would definitely not work well with `publish` since it would not receive the item previously emitted, only subsequent ones.

I have replicated the issue and see this in my output:

```
*** Subscribing to EventStream ***
============> PublishSubject onNext: Event => source: 0 message: Event-0  observers: 1
GroupedObservable Key: 0
============> PublishSubject onNext: Event => source: 1 message: Event-1  observers: 2
GroupedObservable Key: 1
Source: 1  Message: Event-1
============> PublishSubject onNext: Event => source: 0 message: Event-2  observers: 3
```

Note how the observers count increases as each group is triggered. The first observer is the `groupBy` and the following two are the observer for each of the 2 groups.

Removing the `publish` operator this is confirmed here:

```
*** Subscribing to EventStream ***
GroupedObservable Key: 0
*** Subscribing to EventStream ***
Source: 0  Message: Event-0
GroupedObservable Key: 1
*** Subscribing to EventStream ***
```

I don't have time tonight to figure out what needs to change with `groupBy` but from what I can tell this is definitely a bug.

---

Regarding the given sample code, since the `publish` operator is not going to publish anything unless `connect` is invoked on it so I assume that sample code is just representative as it will not actually emit any data.

The code would need to look more like this:

``` java
        ConnectableObservable<Event> es = connectToEventStream().publish();

        es.groupBy(event -> event.source).subscribe(eventStream -> {
            eventStream.subscribe(event -> System.out.println(event.message));
        });

        es.connect();
```

I also generally recommend not doing nested subscribes as the control of the subscriptions is lost.

``` java
        ConnectableObservable<Event> es = connectToEventStream().publish();

        es.groupBy(event -> event.source).mapMany(eventGroupedObservable -> {
            return eventGroupedObservable.map(event -> {
                return "Source: " + event.source + "  Message: " + event.message;
            });
        }).subscribe(outputMessage -> {
            System.out.println(outputMessage);
        });

        es.connect();
```

Are you using `publish` just to handle `groupBy` subscribing to it multiple times, or do you have multiple legit subscribers to the same eventstream?

---

Following is the full test case I built (in normal Java so it fits into the Java 6 project and not Java 8 so it is far more verbose):

``` java
package rx.subjects;

import static org.junit.Assert.*;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.Test;

import rx.Observable;
import rx.Observer;
import rx.Subscription;
import rx.observables.ConnectableObservable;
import rx.observables.GroupedObservable;
import rx.subscriptions.Subscriptions;
import rx.util.functions.Func1;

public class TestPublishSubject {

    @Test
    public void testPublishCount() throws Exception {

        final AtomicInteger counter = new AtomicInteger();
        final CountDownLatch latch = new CountDownLatch(1);
        int count = 100;

        ConnectableObservable<Event> es = connectToEventStream(count).publish();
//        Observable<Event> es = connectToEventStream(count);

        es.groupBy(new Func1<Event, Integer>() {

            @Override
            public Integer call(Event e) {
                return e.source;
            }
        }).mapMany(new Func1<GroupedObservable<Integer, Event>, Observable<String>>() {

            @Override
            public Observable<String> call(GroupedObservable<Integer, Event> eventGroupedObservable) {
                System.out.println("GroupedObservable Key: " + eventGroupedObservable.getKey());

                return eventGroupedObservable.map(new Func1<Event, String>() {

                    @Override
                    public String call(Event event) {
                        return "Source: " + event.source + "  Message: " + event.message;
                    }
                });

            };
        }).subscribe(new Observer<String>() {

            @Override
            public void onCompleted() {
                latch.countDown();
            }

            @Override
            public void onError(Exception e) {
                e.printStackTrace();
                latch.countDown();
            }

            @Override
            public void onNext(String outputMessage) {
                System.out.println(outputMessage);
                counter.incrementAndGet();
            }
        });

        es.connect();

        latch.await(5000, TimeUnit.MILLISECONDS);
        assertEquals(count, counter.get());

    }

    public static Observable<Event> connectToEventStream(final int count) {
        return Observable.create(new Func1<Observer<Event>, Subscription>() {

            @Override
            public Subscription call(final Observer<Event> observer) {
                System.out.println("*** Subscribing to EventStream ***");
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        for (int i = 0; i < count; i++) {
                            Event e = new Event();
                            e.source = i % 2;
                            e.message = "Event-" + i;
                            observer.onNext(e);
                            try {
                                Thread.sleep(50);
                            } catch (Exception ex) {
                                // ignore
                            }
                        }
                    }

                }).start();
                return Subscriptions.empty();
            }

        });
    };

    public static class Event {
        int source;
        String message;

        @Override
        public String toString() {
            return "Event => source: " + source + " message: " + message;
        }
    }

}
```
 =||= Thanks for the elaborate reply. From your answer I draw the conclusion that both PublishSubject and groupBy contain  an error.

**PublishSubject**
You say that on a call to onNext, PublishSubject should take its current list of subscribed observers and iterate over those. However your following assumption looks incorrect:

> each time values() is invoked (on each onNext call) it gives the current state of the data (all subscribers) in the map in a thread-safe manner

[ConcurrentHashMap.values](http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html#values%28%29) however does not return a snapshot of the map's values:

> The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa

And as quoted before, the iterator does not make guarantees about including or excluding items that are added to the map after creation of the iterator (from the same [doc](http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html)):

>  Similarly, Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration.

Those two properties combined allow PublishSubject.onNext to sometimes include observers that are added while iterating. And, at least in the implementation I am using (OpenJDK8), it does this unpredictably, presumably based on hash values.

I guess this bug should be fixed either by always including the newly added observers, or by always excluding them. You say they should be excluded. I think this does sound like the most intuitive behaviour, but maybe it would be more practical to opt for including them, as for example it would directly fix the problem with groupBy.
I do not know which behaviour would be desired in other cases, that means any case where one (possibly indirectly) subscribes to a PublishSubject as a reaction to an (indirect) onNext from that same PublishSubject (via nested subscribes or mapMany or whatever).
A reason to include them could be that you can always use skip(1) to exclude them. Actually the other way around can also be realised, by calling onNext on the new observer when subscribing it to the PublishSubject, though this looks a bit more hacky as you're calling onNext from a different place (and maybe even a different thread?).

**groupBy**
If you choose to exclude newly added observers, then there indeed also is a bug in groupBy. I do not know how to solve this if you would want groupBy to keep re-subscribing to the underlying source for each new group. A possibility would be that groupBy dispatches the incoming items to the appropriate self-produced observables, which would then behave like (or be) PublishSubjects.
As an example, what should this (rather contrived) code do?

``` java
randomIntSource().groupBy(x -> x%2).mapMany(subsource -> {
    Counter counter = new Counter();
    return subsource.map(x -> counter);
}).subscribe(counter -> counter.increment());
```

It would currently create a new random source for the even numbers and one for the odds, though my first expectation would be that it would allow to count the amount of evens and odds in a single random source.

---

About my example code in the first post, I indeed forgot the `connect()` call.

> Are you using publish just to handle groupBy subscribing to it multiple times, or do you have multiple legit subscribers to the same eventstream?

That was just to keep the example short. In real code I usually have one observable that reads incoming events and then I `publish()` it to allow several observers to read the events, some of which may want to use groupBy.

Thanks for the tip to use mapMany, I had not used it before. When more group-dependent variables are used in the observer I guess mapMany becomes less convenient though, and nesting subscribes becomes the more legible way.
 =||= Why do you consider the following to be a bug, and how does this have anything to do with the `groupBy` issue?

> Those two properties combined allow PublishSubject.onNext to sometimes include observers that are added while iterating.

This is done in a thread-safe manner as that is the point of `ConcurrentHashMap` and seems perfectly reasonable and correct for concurrent pub/sub behavior. 

The nature of `PublishSubject` is that it will receive subscriptions concurrently with `onNext` invocations. Thus, as expected with concurrent pub/sub it is always a race as to whether a given observer will be part of a given onNext event. If the pub/sub always occurs between onNext boundaries then there will be no race.

If the pub/sub is not being concurrently modified then none of this applies.

Here is a flow showing concurrent subscriptions:

![publish-subject](https://f.cloud.github.com/assets/813492/592913/28bffd84-ca28-11e2-9f5b-c783cef0eb81.png)
 =||= > nesting subscribes becomes the more legible way

I would suggest you re-consider as you lose the subscription and it can result in memory leaks, observable sequences never closing and other such behavior.

You can read others saying the same thing here: http://www.introtorx.com/content/v1.0.10621.0/07_Aggregation.html

> The code above would work, but it is not good practice to have these nested subscribe calls. We have lost control of the nested subscription, and it is hard to read. When you find yourself creating nested subscriptions, you should consider how to apply a better pattern.
 =||= > Why do you consider the following to be a bug, and how does this have anything to do with the groupBy issue?

When one subscribes to the pubsub from a different thread it is indeed totally reasonable that he may or may not receive the item that is currently being handled. What I am talking about is the case where one subscribes to the pubsub from the _same_ thread as where the pubsub onNext is being handled. This happens when, in the image, B.onNext(8) will subscribe a new observer D to the pubsub. The question is then whether this D will or will not receive the value 8. As this is all happening in a single thread, there is no need for this action to be unpredictable. The subscription of D is undoubtably happening _after_  pubsub.onNext was called, because it was _caused_ by it. That makes it weird that D only _might_ receive 8 because there is no race condition. It either should or it should not include D in the set of obervers that receive 8, depending on which behaviour you want pubsub to have (as discussed in my last post).
To extend the image:
![publishsubjectissue](https://f.cloud.github.com/assets/4191409/593119/5f4498ea-ca2f-11e2-8639-5dda6c06e8c8.png)

The relation to groupBy:
What groupBy does is emitting observables that are descendents of its own source. When using groupBy on a pubsub, when one subscribes to these emitted observables (using nested subscribes or mapMany or whatever), the situation described above occurs (perhaps with some operators between B.onNext and pubsub.subscribe(D)). This results in not knowing whether or not the first item of the group will be received.

I hope my explanation is clear enough, just let me know if it is not or if you find some flaw in my thoughts.
 =||= > That makes it weird that D only might receive 8 because there is no race condition.

Can you give me a test case when an `onNext` action re-subscribes to the same `PublishSubject` on the same thread and it behaves non-deterministically?

> the situation described above occurs (perhaps with some operators between B.onNext and pubsub.subscribe(D)). 

That is the bug with `groupBy`, it should not re-subscribe.
 =||= Please review these changes: https://github.com/Netflix/RxJava/pull/283

This unit test in particular was derived from this discussion: https://github.com/Netflix/RxJava/pull/283/files#L0R365
 =||= That commit looks like a good step on first impression, I will scrutinize it tomorrow or Monday.
I just read the Rx.Net implementation of groupBy which works in a similar way as your newly committed one, but I also still have to figure out if there are some bugs in there or if I just don't fully understand it yet.

I will also write an example for PublishSubject.
 =||= I replaced pull #283 with https://github.com/Netflix/RxJava/pull/284
 =||= Hi,
I did not have time to scrutinize your code today, I will do so tomorrow.

[Here](https://gist.github.com/Treora/5699048) is an example that shows the unpredictable results of PublishSubject. Implemented once using nested subjects and once using mapMany. It does use lambda expressions, I hope that's not a problem for you.
 =||= Thanks for those code examples. I'm able to replicate the issue and working on a fix.
 =||= I updated PublishSubject to take snapshots of the subscribed observers before iterating so that it behaves deterministically and only emits value to observers already subscribed once onNext starts.

This makes the nested subscription behavior deterministic. What it was doing before was allowing new subscriptions from the nested subscribes to get into the iteration ... and that is based on the internal data structure and likely as you suggest the hashing of the object id (which is the only variant that changes between each run).

The unit test for this is at https://github.com/Netflix/RxJava/pull/288/files#L0R479

The specific fix for onNext is this line: https://github.com/Netflix/RxJava/pull/288/files#L0R162
 =||= > Please review these changes: #283

I first looked into how the Rx.Net implementation of groupBy works (which took longer than I wanted because of some bugs in there, more on this below), and then read your committed code (#284) and tested it. I have four comments on your code:
1. There was a small error in using the numGroupSubscriptions counter causing it to drop the parent subscription too eagerly. I added a unit test for it, and then fixed it in commit 22cd318. Maybe it still needs some locking though to prevent race conditions.
2. Is there a reason to allow only one observer to listen to a group? I guess the alternative would be to use a PublishSubject for each GroupedObservable. Rx.Net also works this way, it wraps a Subject (the equivalent of PublishSubject) into a GroupedObservable object. No need to worry about the problem of PublishSubject omitting the current item, as it will not occur here because [`observer.onNext(gs)`](https://github.com/benjchristensen/RxJava/commit/e14449ac44210c292a796ca34b5beab5ed975691#L0R110) is finished before [`gs.onNext(value.value)`](https://github.com/benjchristensen/RxJava/commit/e14449ac44210c292a796ca34b5beab5ed975691#L0R116) is called. I did not make this change.
3. The same question can be asked for GroupBy itself: it also does not allow subscribing more than once. I assume this is an error, and fixed this (commit fc89a79) by putting some fields and methods into the spawned Observer, instead of in the GroupBy class. I named this formerly anonymous class GroupByObserver. The GroupedObservables now regard this GroupByObserver instead of the GroupBy object as their parent. Perhaps it would be nice to create a RefCountSubscription class like Rx.Net has, to group the reference counting logic in there instead of scattering it around GroupBy and GroupByObserver.
4. Should it maybe be disallowed to subscribe to a group after the primary observer (the one receiving the GroupedObservables) has been unsubscribed? See the thoughts on this further below.

---

**Rx.Net**
Actually it looks like Rx.Net suffers some problems with the subscriptions itself, so I spent a while trying to figure out how it should work. Could someone with a .NET development environment and more C# skills than I have perhaps test whether I really found some bugs here or if I am talking nonsense?
@headinthebox: Erik, what do you think about the groupBy issues described below?
1. [GroupBy](http://rx.codeplex.com/SourceControl/latest#Rx/NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/GroupBy.cs) creates a Sink (an Observer) on subscribe, which spawns GroupedObservables which keep references to the _refCountDisposable field in GroupBy, while instead this field should be in the Sink that spawned them. If I understand correctly, when subscribing two observers to one groupBy operator, this will lead to being unable to unsubscribe the first one. This is problem is similar to my third comment above.
2. Apart from that, it looks like a subscription to a GroupBy Observable will keep emitting new GroupedObservables even when it has been unsubscribed from. The used [RefCountDisposable](http://rx.codeplex.com/SourceControl/latest#Rx/NET/Source/System.Reactive.Core/Reactive/Disposables/RefCountDisposable.cs) is made to unsubscribe from the source only when the primary observable and all emitted observables have been unsubscribed from, which is fine but then the created Sink should check if it has been disposed of before it emits a new GroupedObservable.
   In essence, it needs a line like this:
   `if (!_refCountDisposable.isPrimaryDisposed())`
   before doing this:
   `_observer.OnNext(group);` ([GroupBy.cs](http://rx.codeplex.com/SourceControl/latest#Rx/NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/GroupBy.cs))
3. A third quirk in Rx.Net is that whether one can still subscribe to a GroupedObservable can depend on if any other GroupedObservables are still having any subscribers. The RefCountDisposable disposes of its core disposable when both the primary observer and all emitted observables have unsubscribed. If one subscribes to a GroupedObservable hereafter, no items will be received anymore. However if some other subscription to some GroupedObservable of another group is still keeping the RefCountDisposable alive, the new subscription will receive items. This could lead to unexpected behaviour.

---

**Behaviour of groups after unsubscribing the primary observer**
A question to be answered here for both Rx.Net and RxJava is how the groupBy should behave after unsubscribing the primary observer. Should we still be able to subscribe to the GroupedObservables that were emitted earlier? If not, the mentioned third quirk in Rx.Net could be fixed by allowing to subscribe to a GroupedObservable only when the RefCountDisposable's _isPrimaryDisposed is false (again we need an isPrimaryDisposed() method). A similar thing can be done in RxJava by checking unsubscribeRequested when subscribing to a GroupedObservable.
If you do want to allow storing the GroupedObservables for later use (after the GroupByObservable has been disconnected from), the approach of groupBy forms a problem because then we can never know if we can unsubscribe, so it may be better to opt for the first type of behaviour. The most normal usage of groupBy is to subscribe directly anyway so the issue is probably not noticed often, but still it would be best if it does not produce weird results when it is used differently.
 =||= @zsxwing This is another if you have the interest that could use someone's attention and is rather important.
 =||= @benjchristensen I'll try to handle it.
 =||= Thank you @zsxwing 
 =||= Closing this and it will be addressed via https://github.com/Netflix/RxJava/issues/570
 =||= ,0
7270,299,OperationToObservableIterable should call onError?,It seems a bit odd that the OperationToObservableIterable class doesn't catch exceptions and call onError. All of the other wrappers at that level catch exceptions and  call onError. It seems to break the contract of what happens when you pump a value into an observer. In my use case I am trying to test error handling by returning badly formatted data with Observable.just(badResponseObject) and the exception was bubbling out of the call and none of the onError cases were being executed. Perhaps I am missing something?,Not sure how I missed responding to this ... can you provide a unit test to demonstrate the issue?
 =||= Anyone able to replicate this?
 =||= This test succeeds due to the fact that `Observable.subscribe` catches the exception from the immediate iteration of the source sequence.

``` java
@Test 
public void testFailOnNext() {
    Observable<Integer> source = Observable.create(toObservableIterable(
       Arrays.asList(1, 2, 3)));

    @SuppressWarnings("unchecked")
    final Observer<Object> observer = mock(Observer.class);

    Observer<Integer> failer = new Observer<Integer>() {
        @Override
        public void onNext(Integer args) {
            if (args > 1) {
                throw new RuntimeException("Forced failure");
            }
            observer.onNext(args);
        }

        @Override
        public void onError(Throwable e) {
            observer.onError(e);
        }

        @Override
        public void onCompleted() {
            observer.onCompleted();
        }

    };
    source.subscribe(failer);
    verify(observer, times(1)).onNext(1);
    verify(observer, times(1)).onError(any(RuntimeException.class));
    verify(observer, never()).onCompleted();
}
```

But when moved to another thread via observeOn, the exception is just swallowed by the threadpool. It is not a problem with the toObservableIterable but with the observeOn not expecting `not.accept(observer)` to throw.

``` java
@Test 
public void testFailOnNextScheduled() throws InterruptedException {
    Observable<Integer> source = Observable.create(toObservableIterable(
        Arrays.asList(1, 2, 3))).observeOn(Schedulers.threadPoolForComputation());

    @SuppressWarnings("unchecked")
    final Observer<Object> observer = mock(Observer.class);

    Observer<Integer> failer = new Observer<Integer>() {
        @Override
        public void onNext(Integer args) {
            if (args > 1) {
                throw new RuntimeException("Forced failure");
            }
            observer.onNext(args);
        }

        @Override
        public void onError(Throwable e) {
            observer.onError(e);
        }

        @Override
        public void onCompleted() {
            observer.onCompleted();
        }

    };
    source.subscribe(failer);

    Thread.sleep(1000);

    verify(observer, times(1)).onNext(1);
    verify(observer, times(1)).onError(any(RuntimeException.class));
    verify(observer, never()).onCompleted();
}
```
 =||= No response on this in 6+ months so closing out ... re-open if still an issue. 

Many improvements occurred related to error handling in that time.

This test is passing now:

``` java
@Test 
    public void testFailOnNextScheduled() throws InterruptedException {
        Observable<Integer> source = Observable.from(Arrays.asList(1, 2, 3)).observeOn(Schedulers.computation());

        @SuppressWarnings("unchecked")
        final Observer<Object> observer = mock(Observer.class);

        Observer<Integer> failer = new Observer<Integer>() {
            @Override
            public void onNext(Integer args) {
                if (args > 1) {
                    throw new RuntimeException("Forced failure");
                }
                observer.onNext(args);
            }

            @Override
            public void onError(Throwable e) {
                observer.onError(e);
            }

            @Override
            public void onCompleted() {
                observer.onCompleted();
            }

        };
        source.subscribe(failer);

        Thread.sleep(1000);

        verify(observer, times(1)).onNext(1);
        verify(observer, times(1)).onError(any(RuntimeException.class));
        verify(observer, never()).onCompleted();
    }
```
 =||= ,0
7270,277,Finally Happens after onCompleted,Looks like `finallyDo` is behaving wrong:

``` groovy
package rx.lang.groovy.examples
import rx.Observable

class Testing {

    static class myActionClass implements rx.util.functions.Action0 {
        void call() { println('Finally'); }
     }

    static main(args) {



        def myAction = new myActionClass();
        def numbers = Observable.toObservable([1, 2, 3, 4, 5]);

        numbers.finallyDo(myAction).subscribe(
          [ onNext: { println(it); },
            onCompleted:{ println("Sequence complete"); },
            onError:{ println("Error encountered"); } ]
        );

    }

}
```

```
Output:

1
2
3
4
5
Sequence complete
Finally
```

I believe "Finally" should happen before "Sequence Completed",This issues was raised when `finally` PR was being sent. https://github.com/Netflix/RxJava/pull/196#issuecomment-15026180

Here is the C# equivalent code I just checked with.

``` c#
using System;
using System.Reactive.Linq;

var members = new[] { 1, 2, 3, 4, 5 }.ToObservable();

members
    .Finally(() => Console.WriteLine("Finally"))
    .Subscribe(Console.WriteLine /* next */, Console.WriteLine /* exception */, () => Console.WriteLine("Sequence Completed"));
```

Output:

```
1
2
3
4
5
Sequence Completed
Finally
```

Current behavior is correct.
 =||= Great. Thank you for confirming with C# code.
 =||= ,0
7270,278,Rx Guideline 6.5: Subscribe implementations should not throw,Some flavours of subscribe seem to ignore this guideline in the case that the given `final Object onNext` is null, for example: (Observable.java:366)

```
public Subscription subscribe(final Object onNext, final Object onError) {
    // lookup and memoize onNext
    if (onNext == null) {
        throw new RuntimeException("onNext must be implemented");
    }
    final FuncN onNextFunction = Functions.from(onNext);
```

This behaviour could be deliberately chosen, but then I wonder why other flavours of subscribe (those where an `Action1<T>` is passed) do neatly follow this guideline and only throw when onNext is actually being called: (Observable.java:428)

```
        public void onNext(T args) {
            if (onNext == null) {
                throw new RuntimeException("onNext must be implemented");
            }
            onNext.call(args);
        }
```

Moreover, I would actually expect both cases to call onError instead of throwing an Exception, though this could perhaps be defended, and for sure you would want to fix issue #198 first. It seems strange to me however that there is this difference in behaviour between passing an Object and passing an Action1 for onNext, or am I missing something?,The idea is that if calling a method with specific arguments for handlers that null should not be passed in and that this is considered a programmer error, thus throwing an exception rather than invoking `onError`. In short, this is argument validation.

Any difference between Action1 or Object being passed in is a bug, they should behave the same (and we're actively working on getting rid of the Object overloads while still supporting the various languages).

While glancing through the code I see for example what appears to be the result of refactoring placing the null check inside the `onNext` call instead of at the top of the method as an argument validation: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L428

I consider that incorrect, as these are basically intended to be checking that the handlers passed in are valid and thus should be done before any actual Observable logic is invoked.
 =||= Okay, it's clarifying to hear the incongruity between Objects and Action1's is an error.

Whether they should throw an exception or call onError is defensible in favor of either, and perhaps not very important. I would actually choose the latter as it allows to handle all errors in one place and makes calling subscribe a bit simpler (try&catch never needed), but having to do a null check before calling subscribe sounds tolerable.
If both onNext and onError are null, then an exception will still be thrown anyway (if #198 gets fixed).
 =||= ,0
7270,292,Kotlin Language Adaptor,Langauge adaptor for kotlin,[RxJava-pull-requests #165](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/165/) FAILURE
Looks like there's a problem with this pull request
 =||= Is a problem with the Perm-Gen memory size when compiling the scala module after you download the kotlin libraries for the first time. The problem disappear growing up the Perm-Gen size, or running the whole process a second time  
 =||= Thank you for submitting this, I am not ignoring it due to lack of interest, I'm just overly busy at the moment but I will get around to this!
 =||= No problem
 =||= @MarioAriasC you might want to redo this on a feature branch as there's a lot of clutter (merge commits, whoops I forgot this) here.  I'll review anyway, but we are interested in merging concise, complete commits.  make sense?  Let me know if you need git syntax help.
 =||= looks good to me.  sufficient unit tests, etc.  cleanup the files, build.gradle, and commit, then ask @benjchristensen!
 =||= @adriancole Any help with git syntax (and other things) will be very appreciated 
 =||= sure.

It looks like you are 7 commits ahead of master (merges plus the other things you've added)

do `git reset HEAD~7` which should unstage your changes.

Then, you do `git pull upstream master` to reset your head to latest.
Then, redo your commit, and you'll need to do `git push -f origin master` to overwrite the commits here.

hope this helps.
 =||= We are getting very close to being able to pull this in (with some refactoring) now that pull https://github.com/Netflix/RxJava/pull/300 is coming.
 =||= Does Kotlin support closure/function coercion like Java 8 or Groovy 2.2 (http://docs.codehaus.org/display/GROOVY/2013/07/09/First+beta+of+Groovy+2.2+available) or allow dynamic generation of extension methods?

I see that Kotlin has extension methods, but every method must be defined manually.

I'm interested in a mechanism to automatically coerce from Kotlin functions to RxJava Function/Action classes, or dynamically generate the extension methods. Here's how I generate the extension methods dynamically in Groovy: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/RxGroovyExtensionModule.java#L84
 =||= For background on the previous questions and why it has been so long in responding to this pull request look at release 0.11.0 which significantly changes how we do language adaptors: https://github.com/Netflix/RxJava/releases/tag/rxjava-0.11.0
 =||= Kotlin support function coercion is called SAM (Single Abstract Method) Conversions, this support was introduced in M5.2 and completed in M6 http://blog.jetbrains.com/kotlin/2013/08/kotlin-m6-is-here/

Personally I used it in other project and works fine, but sometimes the compiler can infer the actual type of the interface, in those cases we could fall back on Extension methods.
 =||= That sounds like it could "just work" without anything special then. If not then perhaps the extension methods can fix where we have issues.

Can you give it a try against the new rxjava-core? If coercion is all that's needed then it's simple. If you find issues and extension methods would help, or there are extras that would benefit Kotlin (make it more idiomatic etc) that can be added through a utility class, extension methods etc, it would be great to get an updated pull request.

If nothing else, examples of Kotlin code using RxJava would be great if coercion handles all needed cases.
 =||= @benjchristensen I'll close this pull request and open a new one. I have several problems with Git and gradle related to my changes. 

I want to start fresh, will be more easy for all of us 
 =||= ,0
7270,293,Expose ScheduledSubscription on the public API,I understand it should be transparent for a client where an observable was scheduled. However, we'd actually like to ensure that our service objects schedule operations on an appropriate scheduler (we use different schedulers for e.g. API requests and local storage I/O).

This is not possible at the moment since there is no way to obtain information about this by inspecting the observable or the subscription. Since subscribeOn effectively creates a new observable, there is also no simple way to use mock objects other than to spy into the implementation using partial mocks, which is not great.

I was wondering if it would make sense to change ScheduledSubscription so that

a) ScheduledSubscription is a public top level class
b) exposes a method getScheduler that returns the currently private scheduler instance

so that clients can test subscriptions in unit tests in the following way:

Subscription sub = serviceObject.performJob().subscribe(...);
assertThat(sub, instanceOf(ScheduledSubscription.class));
assertThat(sub, ((ScheduledSubscription) sub).getScheduler(), equalTo(expectedScheduler) );,Answered in https://github.com/Netflix/RxJava/pull/294
 =||= ,0
7270,297,Remove unit tests from distribution JAR,Embedded unit tests make up 50% of the rxjava-core JAR size. Factoring these out into a separate source tree would allow for a more manageable library size for distribution in size-constrained applications. Removing the unit tests from the JAR dropped the size from 600K to 315K.,+1
 =||= I noticed a line that was put in comments which excluded unit tests in the [build.gradle](https://github.com/Netflix/RxJava/blob/master/rxjava-core/build.gradle). I do know that there are unit tests residing in `src/main/java`, so you would need to move those first.
 =||= The unit tests are internal classes of the objects they test. Separating them out would eliminate the junit and mockito dependencies in the core source.

... just read the reasoning for that: http://benjchristensen.com/2011/10/23/junit-tests-as-inner-classes/

This article brings up some interesting topics. Obviously this decision was well thought out. 
 =||= Indeed. Some very good points in that article.

The one problematic unforeseen consequence that I currently see is that the Scala compiler actually checks for the existence of those internal classes. In contrast to Java, It doesn't allow them to just be absent, even if they're not used anywhere. This means that the idea of simply removing all those inner test classes during packaging doesn't work anymore for any libraries that want to be usable in Scala, which is a pity.
 =||= This was also discussed at: https://groups.google.com/forum/#!topic/rxjava/b4DYjvUTazI

For Android specifically, is it not common to use tools such as Proguard (http://proguard.sourceforge.net/index.html and http://developer.android.com/tools/help/proguard.html) to reduce jars to only include classes used by an app? I have been told that is the case (but I don't developer for Android so can't speak to this).

Unfortunately due to Groovy/Scala (and possibly other languages) the general solution of stripping the $UnitTest classes before creating the jar has been disabled, otherwise the issue of Jar file size would not exist.

At this time however the intent is to leave things as they are. 
 =||= What dependencies? They are 'provided' and not runtime. 

RxJava has 0 dependencies beyond the JVM and is a single jar library.
 =||= You're right. I missed this thing about "provided" dependencies. Then checked my own build and found no unit test dependencies, understood the idea and removed my comment. Sorry about that.
 =||= It's okay, it's what I get for doing something unconventional :-)
 =||= @benjchristensen To give you some background on the proguard/Android development practices:
- The testing tools for Android are really shoddy. You cannot run POJO unit tests*\* without running it through the android framework. 
- So running unit tests are pretty slow, as that implies compiling your apk (application package), deploying it on the device, and then having your unit tests run on them. It's a couple of seconds, but still extremely slow for unit tests standards.
- Adding proguard to the mix increases that time by a few more seconds, which makes the possibility of fast testing even less likely. This is why people avoid using proguard (during development).

Ok, so you may then ask: Why not disable proguard for development builds alone? Well, that's what most of us do. However:
- Android has [a hard dex method limit of 64k](http://jakewharton.com/play-services-is-a-monolith/). This basically means, that if you hit this limit (by virtue of having many referenced methods in your app or referencing external libraries that do the same), you are stopped from compiling an apk. 
- This means that you cannot compile an app (even on development builds) if you've crossed that limit (it's actually pretty bad, because-as mentioned before- this means you can't even run basic unit tests because of this). 

In sum, Android developers (should) use proguard for release builds, but prefer having very small libraries as that helps in avoiding other problems during development.

 *\* Well that is not entirely true, since you can run POJO unit tests, but you have to place them in a different project, and reference them like libraries from within your main project. It's not hard, but not easy enough.
 =||= Thanks for the info, it was educational for me on things I didn't know. However, what triggered this since this issue has been closed for 10 months?
 =||= hah apologies for waking the dead.

I noticed my apk size increased by about an MB after adding in RxJava, so I
started looking around for strategies on minimizing the library size (or if
that even made sense). I ran across these [two](https://github.com/Netflix/RxJava/issues/439) [threads](https://github.com/Netflix/RxJava/issues/297), and thought i'll add my two
cents for posterity, since the question was raised in both threads.

On Fri, Aug 8, 2014 at 8:17 PM, Ben Christensen notifications@github.com
wrote:

> Thanks for the info, it was educational for me on things I didn't know.
> However, what triggered this since this issue has been closed for 10 months?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/Netflix/RxJava/issues/297#issuecomment-51675620.
 =||= Ah, makes sense :-) Other than removing functionality from rxjava-core, I am not aware of anything more we can do to reduce the size of the Jar at this point. It has zero dependencies, no testing code and only contains core functionality.

Thanks for the background on Android. The 64k limits sound very painful!
 =||= ,0
7270,298,LINQ /Stream,Hi,

Will this add LINQ like functionality in the future? This is one thing that makes .NET Rx very attractive.

Suminda,We have no intention of attempting to create a DSL in Java as the language does not afford those capabilities.

If someone wanted to pursue it in a different language such as Groovy, Scala or Clojure, it could be a great [contrib module](https://github.com/Netflix/RxJava/tree/master/rxjava-contrib). 
 =||= ,0
7270,282,PublishSubject's HashMap makes groupBy and such non-deterministic.,In a few cases already I noticed unexpected and non-deterministic behaviour occurring when subscribing (directly or via a chain of observables) to a PublishSubject source. This happens when subscribing from within an onNext method that is directly or indirectly triggered by that same source. The newly subscribed observer may or may not directly receive the onNext call from the same event. An example where this is annoying:

```
connectToEventStream()
    .publish()
    .groupBy(event -> event.source).subscribe(eventStream -> {
        LogFile log = new LogFile(eventStream.getKey() + ".log");
        eventStream.subscribe(event -> log.write(event.getMessage()));
    });
```

In this example the first event of each source might be skipped and not be logged, but other times it will work fine. To me this seems undesired behaviour. There may be cases where it actually is preferable that the current item will be skipped when subscribing from an onNext method, but this happening unpredictably is never a good idea.

The cause of the unpredictability is the implementation of Map that is used in PublishSubject, which when iterating on the map's values sometimes includes new items:

>  Similarly, Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration.

And supposedly whether an item will be iterated over or not depends on the hashes of the subscriptions, thus totally unpredictable. A sensible option would be to use a different implementation of Map that does iterate over any items that are added during the iterating loop, but it looks like this implementation then has to be written or found first as java seems not to provide anything like this.

As a quick hack I added this code to the PublishSubject, but I considered this solution too ugly to be worth a pull request (commit a7fc861):

```
public void onNext(T args) {
    int observersSize;
    Set<Observer<T>> notifiedObservers = new HashSet<Observer<T>>();
    do {
        observersSize = observers.size();
        for (Observer<T> observer : observers.values()) {
            if (!notifiedObservers.contains(observer)) {
                observer.onNext(args);
                notifiedObservers.add(observer);
            }
        }
    } while (observers.size() > observersSize);
}
```,Short Version: It looks like a bug with `groupBy` not `publish`.

Long Version:

PublishSubject will send events through to whatever subscribers it currently has and not replay past events as new subscribers arrive. This is why the `publish` operator returns a `ConnectedObservable` that allows a developer to wait for all Observers to subscribe and then `connect` the source that is publishing.

The `ConcurrentHashMap` implementation of `Map` used by `PublishSubject` is the correct thread-safe implementation to be using. It allows concurrent modifications and each time `values()` is invoked (on each `onNext` call) it gives the current state of the data (all subscribers) in the map in a thread-safe manner. Thus it is thread-safe for the `onNext` call to continue being invoked while subscribers come and go, but it will naturally be a race condition as to whether the subscription occurs before-or-after the `onNext` if they are done concurrently. 

As to the issue you're seeing I think it's not `PublishSubject` with the issue but the implementation of `groupBy` which seems to re-subscribe to the underlying `Observable` on each group that gets emitted. That would definitely not work well with `publish` since it would not receive the item previously emitted, only subsequent ones.

I have replicated the issue and see this in my output:

```
*** Subscribing to EventStream ***
============> PublishSubject onNext: Event => source: 0 message: Event-0  observers: 1
GroupedObservable Key: 0
============> PublishSubject onNext: Event => source: 1 message: Event-1  observers: 2
GroupedObservable Key: 1
Source: 1  Message: Event-1
============> PublishSubject onNext: Event => source: 0 message: Event-2  observers: 3
```

Note how the observers count increases as each group is triggered. The first observer is the `groupBy` and the following two are the observer for each of the 2 groups.

Removing the `publish` operator this is confirmed here:

```
*** Subscribing to EventStream ***
GroupedObservable Key: 0
*** Subscribing to EventStream ***
Source: 0  Message: Event-0
GroupedObservable Key: 1
*** Subscribing to EventStream ***
```

I don't have time tonight to figure out what needs to change with `groupBy` but from what I can tell this is definitely a bug.

---

Regarding the given sample code, since the `publish` operator is not going to publish anything unless `connect` is invoked on it so I assume that sample code is just representative as it will not actually emit any data.

The code would need to look more like this:

``` java
        ConnectableObservable<Event> es = connectToEventStream().publish();

        es.groupBy(event -> event.source).subscribe(eventStream -> {
            eventStream.subscribe(event -> System.out.println(event.message));
        });

        es.connect();
```

I also generally recommend not doing nested subscribes as the control of the subscriptions is lost.

``` java
        ConnectableObservable<Event> es = connectToEventStream().publish();

        es.groupBy(event -> event.source).mapMany(eventGroupedObservable -> {
            return eventGroupedObservable.map(event -> {
                return "Source: " + event.source + "  Message: " + event.message;
            });
        }).subscribe(outputMessage -> {
            System.out.println(outputMessage);
        });

        es.connect();
```

Are you using `publish` just to handle `groupBy` subscribing to it multiple times, or do you have multiple legit subscribers to the same eventstream?

---

Following is the full test case I built (in normal Java so it fits into the Java 6 project and not Java 8 so it is far more verbose):

``` java
package rx.subjects;

import static org.junit.Assert.*;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.Test;

import rx.Observable;
import rx.Observer;
import rx.Subscription;
import rx.observables.ConnectableObservable;
import rx.observables.GroupedObservable;
import rx.subscriptions.Subscriptions;
import rx.util.functions.Func1;

public class TestPublishSubject {

    @Test
    public void testPublishCount() throws Exception {

        final AtomicInteger counter = new AtomicInteger();
        final CountDownLatch latch = new CountDownLatch(1);
        int count = 100;

        ConnectableObservable<Event> es = connectToEventStream(count).publish();
//        Observable<Event> es = connectToEventStream(count);

        es.groupBy(new Func1<Event, Integer>() {

            @Override
            public Integer call(Event e) {
                return e.source;
            }
        }).mapMany(new Func1<GroupedObservable<Integer, Event>, Observable<String>>() {

            @Override
            public Observable<String> call(GroupedObservable<Integer, Event> eventGroupedObservable) {
                System.out.println("GroupedObservable Key: " + eventGroupedObservable.getKey());

                return eventGroupedObservable.map(new Func1<Event, String>() {

                    @Override
                    public String call(Event event) {
                        return "Source: " + event.source + "  Message: " + event.message;
                    }
                });

            };
        }).subscribe(new Observer<String>() {

            @Override
            public void onCompleted() {
                latch.countDown();
            }

            @Override
            public void onError(Exception e) {
                e.printStackTrace();
                latch.countDown();
            }

            @Override
            public void onNext(String outputMessage) {
                System.out.println(outputMessage);
                counter.incrementAndGet();
            }
        });

        es.connect();

        latch.await(5000, TimeUnit.MILLISECONDS);
        assertEquals(count, counter.get());

    }

    public static Observable<Event> connectToEventStream(final int count) {
        return Observable.create(new Func1<Observer<Event>, Subscription>() {

            @Override
            public Subscription call(final Observer<Event> observer) {
                System.out.println("*** Subscribing to EventStream ***");
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        for (int i = 0; i < count; i++) {
                            Event e = new Event();
                            e.source = i % 2;
                            e.message = "Event-" + i;
                            observer.onNext(e);
                            try {
                                Thread.sleep(50);
                            } catch (Exception ex) {
                                // ignore
                            }
                        }
                    }

                }).start();
                return Subscriptions.empty();
            }

        });
    };

    public static class Event {
        int source;
        String message;

        @Override
        public String toString() {
            return "Event => source: " + source + " message: " + message;
        }
    }

}
```
 =||= Thanks for the elaborate reply. From your answer I draw the conclusion that both PublishSubject and groupBy contain  an error.

**PublishSubject**
You say that on a call to onNext, PublishSubject should take its current list of subscribed observers and iterate over those. However your following assumption looks incorrect:

> each time values() is invoked (on each onNext call) it gives the current state of the data (all subscribers) in the map in a thread-safe manner

[ConcurrentHashMap.values](http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html#values%28%29) however does not return a snapshot of the map's values:

> The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa

And as quoted before, the iterator does not make guarantees about including or excluding items that are added to the map after creation of the iterator (from the same [doc](http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html)):

>  Similarly, Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration.

Those two properties combined allow PublishSubject.onNext to sometimes include observers that are added while iterating. And, at least in the implementation I am using (OpenJDK8), it does this unpredictably, presumably based on hash values.

I guess this bug should be fixed either by always including the newly added observers, or by always excluding them. You say they should be excluded. I think this does sound like the most intuitive behaviour, but maybe it would be more practical to opt for including them, as for example it would directly fix the problem with groupBy.
I do not know which behaviour would be desired in other cases, that means any case where one (possibly indirectly) subscribes to a PublishSubject as a reaction to an (indirect) onNext from that same PublishSubject (via nested subscribes or mapMany or whatever).
A reason to include them could be that you can always use skip(1) to exclude them. Actually the other way around can also be realised, by calling onNext on the new observer when subscribing it to the PublishSubject, though this looks a bit more hacky as you're calling onNext from a different place (and maybe even a different thread?).

**groupBy**
If you choose to exclude newly added observers, then there indeed also is a bug in groupBy. I do not know how to solve this if you would want groupBy to keep re-subscribing to the underlying source for each new group. A possibility would be that groupBy dispatches the incoming items to the appropriate self-produced observables, which would then behave like (or be) PublishSubjects.
As an example, what should this (rather contrived) code do?

``` java
randomIntSource().groupBy(x -> x%2).mapMany(subsource -> {
    Counter counter = new Counter();
    return subsource.map(x -> counter);
}).subscribe(counter -> counter.increment());
```

It would currently create a new random source for the even numbers and one for the odds, though my first expectation would be that it would allow to count the amount of evens and odds in a single random source.

---

About my example code in the first post, I indeed forgot the `connect()` call.

> Are you using publish just to handle groupBy subscribing to it multiple times, or do you have multiple legit subscribers to the same eventstream?

That was just to keep the example short. In real code I usually have one observable that reads incoming events and then I `publish()` it to allow several observers to read the events, some of which may want to use groupBy.

Thanks for the tip to use mapMany, I had not used it before. When more group-dependent variables are used in the observer I guess mapMany becomes less convenient though, and nesting subscribes becomes the more legible way.
 =||= Why do you consider the following to be a bug, and how does this have anything to do with the `groupBy` issue?

> Those two properties combined allow PublishSubject.onNext to sometimes include observers that are added while iterating.

This is done in a thread-safe manner as that is the point of `ConcurrentHashMap` and seems perfectly reasonable and correct for concurrent pub/sub behavior. 

The nature of `PublishSubject` is that it will receive subscriptions concurrently with `onNext` invocations. Thus, as expected with concurrent pub/sub it is always a race as to whether a given observer will be part of a given onNext event. If the pub/sub always occurs between onNext boundaries then there will be no race.

If the pub/sub is not being concurrently modified then none of this applies.

Here is a flow showing concurrent subscriptions:

![publish-subject](https://f.cloud.github.com/assets/813492/592913/28bffd84-ca28-11e2-9f5b-c783cef0eb81.png)
 =||= > nesting subscribes becomes the more legible way

I would suggest you re-consider as you lose the subscription and it can result in memory leaks, observable sequences never closing and other such behavior.

You can read others saying the same thing here: http://www.introtorx.com/content/v1.0.10621.0/07_Aggregation.html

> The code above would work, but it is not good practice to have these nested subscribe calls. We have lost control of the nested subscription, and it is hard to read. When you find yourself creating nested subscriptions, you should consider how to apply a better pattern.
 =||= > Why do you consider the following to be a bug, and how does this have anything to do with the groupBy issue?

When one subscribes to the pubsub from a different thread it is indeed totally reasonable that he may or may not receive the item that is currently being handled. What I am talking about is the case where one subscribes to the pubsub from the _same_ thread as where the pubsub onNext is being handled. This happens when, in the image, B.onNext(8) will subscribe a new observer D to the pubsub. The question is then whether this D will or will not receive the value 8. As this is all happening in a single thread, there is no need for this action to be unpredictable. The subscription of D is undoubtably happening _after_  pubsub.onNext was called, because it was _caused_ by it. That makes it weird that D only _might_ receive 8 because there is no race condition. It either should or it should not include D in the set of obervers that receive 8, depending on which behaviour you want pubsub to have (as discussed in my last post).
To extend the image:
![publishsubjectissue](https://f.cloud.github.com/assets/4191409/593119/5f4498ea-ca2f-11e2-8639-5dda6c06e8c8.png)

The relation to groupBy:
What groupBy does is emitting observables that are descendents of its own source. When using groupBy on a pubsub, when one subscribes to these emitted observables (using nested subscribes or mapMany or whatever), the situation described above occurs (perhaps with some operators between B.onNext and pubsub.subscribe(D)). This results in not knowing whether or not the first item of the group will be received.

I hope my explanation is clear enough, just let me know if it is not or if you find some flaw in my thoughts.
 =||= > That makes it weird that D only might receive 8 because there is no race condition.

Can you give me a test case when an `onNext` action re-subscribes to the same `PublishSubject` on the same thread and it behaves non-deterministically?

> the situation described above occurs (perhaps with some operators between B.onNext and pubsub.subscribe(D)). 

That is the bug with `groupBy`, it should not re-subscribe.
 =||= Please review these changes: https://github.com/Netflix/RxJava/pull/283

This unit test in particular was derived from this discussion: https://github.com/Netflix/RxJava/pull/283/files#L0R365
 =||= That commit looks like a good step on first impression, I will scrutinize it tomorrow or Monday.
I just read the Rx.Net implementation of groupBy which works in a similar way as your newly committed one, but I also still have to figure out if there are some bugs in there or if I just don't fully understand it yet.

I will also write an example for PublishSubject.
 =||= I replaced pull #283 with https://github.com/Netflix/RxJava/pull/284
 =||= Hi,
I did not have time to scrutinize your code today, I will do so tomorrow.

[Here](https://gist.github.com/Treora/5699048) is an example that shows the unpredictable results of PublishSubject. Implemented once using nested subjects and once using mapMany. It does use lambda expressions, I hope that's not a problem for you.
 =||= Thanks for those code examples. I'm able to replicate the issue and working on a fix.
 =||= I updated PublishSubject to take snapshots of the subscribed observers before iterating so that it behaves deterministically and only emits value to observers already subscribed once onNext starts.

This makes the nested subscription behavior deterministic. What it was doing before was allowing new subscriptions from the nested subscribes to get into the iteration ... and that is based on the internal data structure and likely as you suggest the hashing of the object id (which is the only variant that changes between each run).

The unit test for this is at https://github.com/Netflix/RxJava/pull/288/files#L0R479

The specific fix for onNext is this line: https://github.com/Netflix/RxJava/pull/288/files#L0R162
 =||= > Please review these changes: #283

I first looked into how the Rx.Net implementation of groupBy works (which took longer than I wanted because of some bugs in there, more on this below), and then read your committed code (#284) and tested it. I have four comments on your code:
1. There was a small error in using the numGroupSubscriptions counter causing it to drop the parent subscription too eagerly. I added a unit test for it, and then fixed it in commit 22cd318. Maybe it still needs some locking though to prevent race conditions.
2. Is there a reason to allow only one observer to listen to a group? I guess the alternative would be to use a PublishSubject for each GroupedObservable. Rx.Net also works this way, it wraps a Subject (the equivalent of PublishSubject) into a GroupedObservable object. No need to worry about the problem of PublishSubject omitting the current item, as it will not occur here because [`observer.onNext(gs)`](https://github.com/benjchristensen/RxJava/commit/e14449ac44210c292a796ca34b5beab5ed975691#L0R110) is finished before [`gs.onNext(value.value)`](https://github.com/benjchristensen/RxJava/commit/e14449ac44210c292a796ca34b5beab5ed975691#L0R116) is called. I did not make this change.
3. The same question can be asked for GroupBy itself: it also does not allow subscribing more than once. I assume this is an error, and fixed this (commit fc89a79) by putting some fields and methods into the spawned Observer, instead of in the GroupBy class. I named this formerly anonymous class GroupByObserver. The GroupedObservables now regard this GroupByObserver instead of the GroupBy object as their parent. Perhaps it would be nice to create a RefCountSubscription class like Rx.Net has, to group the reference counting logic in there instead of scattering it around GroupBy and GroupByObserver.
4. Should it maybe be disallowed to subscribe to a group after the primary observer (the one receiving the GroupedObservables) has been unsubscribed? See the thoughts on this further below.

---

**Rx.Net**
Actually it looks like Rx.Net suffers some problems with the subscriptions itself, so I spent a while trying to figure out how it should work. Could someone with a .NET development environment and more C# skills than I have perhaps test whether I really found some bugs here or if I am talking nonsense?
@headinthebox: Erik, what do you think about the groupBy issues described below?
1. [GroupBy](http://rx.codeplex.com/SourceControl/latest#Rx/NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/GroupBy.cs) creates a Sink (an Observer) on subscribe, which spawns GroupedObservables which keep references to the _refCountDisposable field in GroupBy, while instead this field should be in the Sink that spawned them. If I understand correctly, when subscribing two observers to one groupBy operator, this will lead to being unable to unsubscribe the first one. This is problem is similar to my third comment above.
2. Apart from that, it looks like a subscription to a GroupBy Observable will keep emitting new GroupedObservables even when it has been unsubscribed from. The used [RefCountDisposable](http://rx.codeplex.com/SourceControl/latest#Rx/NET/Source/System.Reactive.Core/Reactive/Disposables/RefCountDisposable.cs) is made to unsubscribe from the source only when the primary observable and all emitted observables have been unsubscribed from, which is fine but then the created Sink should check if it has been disposed of before it emits a new GroupedObservable.
   In essence, it needs a line like this:
   `if (!_refCountDisposable.isPrimaryDisposed())`
   before doing this:
   `_observer.OnNext(group);` ([GroupBy.cs](http://rx.codeplex.com/SourceControl/latest#Rx/NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/GroupBy.cs))
3. A third quirk in Rx.Net is that whether one can still subscribe to a GroupedObservable can depend on if any other GroupedObservables are still having any subscribers. The RefCountDisposable disposes of its core disposable when both the primary observer and all emitted observables have unsubscribed. If one subscribes to a GroupedObservable hereafter, no items will be received anymore. However if some other subscription to some GroupedObservable of another group is still keeping the RefCountDisposable alive, the new subscription will receive items. This could lead to unexpected behaviour.

---

**Behaviour of groups after unsubscribing the primary observer**
A question to be answered here for both Rx.Net and RxJava is how the groupBy should behave after unsubscribing the primary observer. Should we still be able to subscribe to the GroupedObservables that were emitted earlier? If not, the mentioned third quirk in Rx.Net could be fixed by allowing to subscribe to a GroupedObservable only when the RefCountDisposable's _isPrimaryDisposed is false (again we need an isPrimaryDisposed() method). A similar thing can be done in RxJava by checking unsubscribeRequested when subscribing to a GroupedObservable.
If you do want to allow storing the GroupedObservables for later use (after the GroupByObservable has been disconnected from), the approach of groupBy forms a problem because then we can never know if we can unsubscribe, so it may be better to opt for the first type of behaviour. The most normal usage of groupBy is to subscribe directly anyway so the issue is probably not noticed often, but still it would be best if it does not produce weird results when it is used differently.
 =||= @zsxwing This is another if you have the interest that could use someone's attention and is rather important.
 =||= @benjchristensen I'll try to handle it.
 =||= Thank you @zsxwing 
 =||= Closing this and it will be addressed via https://github.com/Netflix/RxJava/issues/570
 =||= ,0
7270,193,Are there plans to set up a mailing list?,It would be great to be able to get in touch with other developers using Rx(Java) and how they deal with typical problems. For instance, we're not sure if we're using the right granularity of Observables and we have a few other questions where we'd be curious to know how others solved them.,Yes, that's a good idea ... just didn't get around to it.

Will do so shortly and post back here.
 =||= I added a link on the Readme and created a GoogleGroup: https://github.com/Netflix/RxJava#communication
 =||= ,0
7273,2242,Non-deterministic test failure: OnSubscribeCacheTest.testWithBehaviorSubjectAndRepeat,This occurred while playing with RxRingBuffer. Not sure if it's RxRingBuffer that causes it, or it's just non-deterministic. I saw it fail once. 

```
java.lang.AssertionError: Value at index: 1 expected to be [1] (Integer) but was: [2] (Integer)
    at rx.observers.TestObserver.assertReceivedOnNext(TestObserver.java:126)
    at rx.observers.TestSubscriber.assertReceivedOnNext(TestSubscriber.java:164)
    at rx.internal.operators.OnSubscribeCacheTest.testWithCustomSubjectAndRepeat(OnSubscribeCacheTest.java:127)
    at rx.internal.operators.OnSubscribeCacheTest.testWithBehaviorSubjectAndRepeat(OnSubscribeCacheTest.java:138)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:483)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
    at org.junit.internal.runners.statements.FailOnTimeout$StatementThread.run(FailOnTimeout.java:62)
```

I will try replicating in a tight-loop in a bit and post here. ,Closing due to old age. I haven't seen this causing us issues.
 =||= ,0
7273,2291,Backpressure: flatMap/merge with maxConcurrent,The `merge(Observable/Iterable o, int maxConcurrent)` overloads do not support backpressure. They were missed when implementing the normal `merge`. 

This was first brought up in https://github.com/ReactiveX/RxJava/issues/1927#issuecomment-66885487

This code shows the problem:

``` java
import static rx.Observable.*;
import rx.Observable;
import rx.schedulers.Schedulers;

public class MergeMaxConcurrent {

    public static void main(String[] args) {
        Observable<Observable<Integer>> asyncWork = range(1, 1000000)
                //      .doOnNext(i -> System.out.println("Value: " + i))
                .doOnRequest(r -> System.out.println("request1 " + r))
                .map(item -> {
                    return just(item)
                            .doOnNext(MergeMaxConcurrent::sleep)
                            .subscribeOn(Schedulers.io());
                })
                .doOnRequest(r -> System.out.println("request2 " + r));
        merge(asyncWork, 10).toBlocking().forEach(System.out::println);
    }

    public static void sleep(int value) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

Related to this, we should have a `flatMap` overload that accepts a `maxConcurrent` parameter so that the `merge(o, maxConcurrent)` can be used like this with backpressure:

``` java
        Observable.range(0, Integer.MAX_VALUE).map(i -> "lineOfData-" + i) // simulate the file with many lines
                .buffer(100) // buffer up chunks of work before processing them
                .flatMap(chunk -> {
                    return Observable.just(chunk).subscribeOn(Schedulers.io()) // put each group on a new thread (io scheduler for blocking IO) 
                            .doOnNext(t -> {
                                // do work here
                                try {
                                    Thread.sleep(1000);
                                } catch (Exception e) {
                                }
                                // write out on blocking IO as a side-effect
                                System.out.println("Emitting to IO: " + t);
                            });
                }).toBlocking().forEach(System.out::println);
```

Right now an awkward use of `groupBy` can be used to avoid using `merge` but it is inefficient since it calls the `groupBy` function on every item instead of being able to do the buffering before `flatMap` and just using backpressure to only `merge` the `maxConcurrent` as they are processed.

Here is the `groupBy` approach:

``` java
        Observable.range(0, Integer.MAX_VALUE).map(i -> "lineOfData-" + i) // simulate the file with many lines
                .zipWith(Observable.range(0, Integer.MAX_VALUE), (d, i) -> new Object[] { d, i }) // index it so we can use the index position
                .groupBy(pair -> (int) pair[1] % 4) // mod on index for parallelism
                .flatMap(g -> {
                    return g.observeOn(Schedulers.computation()) // put each group on a new CPU 
                            .map(pair -> pair[0]) // extract just the value
                            .buffer(100) // buffer up chunks of work before processing them
                            .map(t -> {
                                // do work here
                                try {
                                    Thread.sleep(1000);
                                } catch (Exception e) {
                                }
                                // generally just pure processing goes in a map function
                                // so if IO side-effects are being done here, then it is idiomatic to instead
                                // use doOnNext which returns Void. 
                                // If doing blocking IO here, then use Schedulers.io() instead of computation() above. 
                                return "processed " + t;
                            });
                }).toBlocking().forEach(System.out::println);
```

These last 2 solutions are variants for splitting up a long file of data, processing them in multiple threads and emitting the results over network IO. It is not important whether the IO is blocking or non-blocking. It is not even all that important whether the IO is done as a side-effect on each thread, or the results are merged back into 1 thread and then emitted. The important part is that right now it's not obviously simple to use `flatMap` and achieve backpressured, async parallelism. ,I just want to mention that the maxConcurrent value may allow the use of a single large buffer split into N element regions. Once a region has completed, that part can be assigned to a new source. Of course, merging 100s of one element sources is wasteful.
 =||= Is the flatMap api still going to get a `maxConcurrent` overload?
 =||= I would still like to. I opened this issue for it: https://github.com/ReactiveX/RxJava/issues/2626
 =||= ,0
7273,2243,Experimental RingBuffer using WriterReaderPhaser,As per discussion in #2189 this is an attempt at implementing `RxRingBuffer` using `WriterReaderPhaser`. 

The performance numbers are worse than #2189, inline with the RW Lock and WIP implementations. 

See the last column:

```
Benchmark                                          (size)   Mode   Samples          1.x   Inline Volatile    + finalize       RW Lock          WIP     WRPhaser
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4757888.048       5264594.520   4956256.323   5288310.755  5032942.628  5147447.030
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    44877.618         42845.758     39209.439     25742.696    29025.955    27779.876
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       42.366            40.979        37.036        24.769       27.260       27.694
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    99981.127         99910.070     94307.080    103112.286   103176.289   100516.101
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.675             4.620         4.670         4.374        4.313        4.413
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4751265.583       4706441.452   4376983.062   4739418.557  4673633.614  4510099.724
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   458704.984        480075.261    427165.143    483313.588   476318.407   462373.555
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    42493.290         42178.254     39640.240     42728.480    42542.171    41354.668
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5406448.872       5375090.752   5066264.570   5628401.294  4974892.417  4986054.668
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       44.528            40.990        41.106        24.974       28.212       27.755
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76898.222         72655.377     69748.305     78283.565    78987.646    78550.912
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3172.653          2955.854      3064.749      1858.361     2204.948     2310.804
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5157134.576       5163837.644   4846336.744   5290961.536  5139893.848  4486879.415
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    39961.491         39341.526     37312.117     40418.492    39163.267    37424.146
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.925            35.730        33.948        35.526       35.611       32.287
```,cc @akarnokd 
 =||= This failure again:

```
rx.internal.operators.OperatorRetryTest > testRetryWithBackpressure FAILED
    java.lang.Exception: test timed out after 10000 milliseconds
```
 =||= An update related to this is available at https://github.com/ReactiveX/RxJava/issues/1908#issuecomment-68067888
 =||= The implementation is incorrect. Once flipped, the onXXX should be routed to the nop_queue, but essentially if the criticalValueAtEnter is less than zero, the unsubscription has happened and nothing should be enqueued. The release() is not idempotent because it can flip a second time back to the emitting-enabled mode.

I believe by joining the ringbuffer and the phaser, you can get away with a single ingress atomic counter. It will provide he phase bit and the writerIndex at the same time. 

In addition, I figured out why the multi-consumer queue was needed: it was because an async clear() acts as a second reader using the same poll() and thus would corrupt an SPSC. Maybe an SPSC queue's poll can be modified so a filling the queue with nulls and moving the reader's index up to the writer's index is workable.
 =||= Why do they need to be routed anywhere? All future emissions will now return immediately since released == true. 

Also, a single counter had the same performance problem. That was the WIP implementation. 
 =||= Released field is redundant because a negative critical value can indicate a terminal state; one field less.

The WIP produced some nice results, ecxept on a few cases where it drastically underperformed. Could you point me to the sources of this variant to see if more nanoseconds can be saved?
 =||= > Released field is redundant because a negative critical value can indicate a terminal state; one field less.

Okay, but how is the implementation incorrect, even if it may have other optimizations?

> Could you point me to the sources of this variant to see if more nanoseconds can be saved?

The test is in https://github.com/benjchristensen/RxJava/blob/ring-buffer-wip/src/main/java/rx/internal/util/RxRingBuffer.java
 =||= I just pushed the change you recommended and eliminated the use of `released` and use the phase state directly. It did not change performance:

```
with WriterReaderPhaser using phase state

Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4930586.615  1177558.483    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    26117.610      412.515    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       25.466        0.775    ops/s
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5   102486.748     1377.611    ops/s
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.087        0.233    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4457316.389   363539.115    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   473724.591    21719.743    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    40023.766     3562.388    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5220487.374   405664.161    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       23.860        1.395    ops/s
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    78372.613     2185.710    ops/s
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     2189.509       30.923    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5168348.297   107791.880    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    38955.533     4054.434    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.013        2.609    ops/s
```
 =||= Method release is not idempotent and may flip the phaser back to even. I think the critical section in poll might be the cause of the performance drop. I see that without it, an ongoing poll might pick up a value from a new use of the queue. I'll think about this a bit more. An improvement could be if you eliminated the size() call before each onNext; a failed offer is enough indication of a missing backpressure, no need to count the queue all the time.
 =||= I did some experimenting on this branch, here are the results:

```
Benchmark              (size)        1.x   |    ben      | growable-fx |    growable |       spsc 
1SyncStreamOfN              1  3779678,748 | 3750731,962 | 3895262,865 | 3831654,726 | 3815898,055
1SyncStreamOfN           1000    21250,675 |   16863,054 |   17524,493 |   17623,563 |   17311,877
1SyncStreamOfN        1000000       20,406 |      14,935 |      16,457 |      16,812 |      16,697
NAsyncStreamsOfN            1   115390,116 |  108276,321 |  113706,768 |  113270,805 |  104689,284
NAsyncStreamsOfN         1000        2,579 |       2,359 |       2,416 |       2,429 |       2,485
NSyncStreamsOf1             1  3543551,254 | 3634053,632 | 3521790,813 | 3521857,887 | 3588808,022
NSyncStreamsOf1           100   299166,910 |  301841,420 |  268720,642 |  299909,354 |  298040,908
NSyncStreamsOf1          1000    28404,751 |   28600,354 |   22409,451 |   28502,782 |   28327,782
NSyncStreamsOfN             1  4054571,577 | 4059693,836 | 4045262,328 | 4070817,061 | 4126726,344
NSyncStreamsOfN          1000       24,324 |      18,672 |      19,361 |      19,433 |      19,313
TwoAsyncStreamsOfN          1    85846,727 |   82293,815 |   81340,729 |   84980,486 |   83300,137
TwoAsyncStreamsOfN       1000     1823,137 |    1657,242 |    1630,500 |    1631,996 |    1777,078
reamOfNthatMergesIn1        1  3724179,351 | 3749830,891 | 3734612,120 | 3738599,855 | 3594971,781
reamOfNthatMergesIn1     1000    19051,928 |   19221,689 |   19255,202 |   19312,769 |   21084,864
reamOfNthatMergesIn1  1000000       18,265 |      18,202 |      17,673 |      18,295 |      18,360

Benchmark              (size)        1.x   | spmc+2wrp   | spmc+2wrpp  | grow+2wrp   | spsc+2wrp   | spsc+2hp   
1SyncStreamOfN              1  3779678,748 | 3798671,379 | 3724837,669 | 3733385,355 | 3767936,028 | 3788226,802
1SyncStreamOfN           1000    21250,675 |   18564,658 |   18101,748 |   18437,839 |   18530,542 |   18813,822
1SyncStreamOfN        1000000       20,406 |      18,270 |      17,751 |      17,707 |      17,712 |      16,972
NAsyncStreamsOfN            1   115390,116 |  106782,224 |   97994,868 |  112464,083 |  115629,480 |  104921,251
NAsyncStreamsOfN         1000        2,579 |       2,520 |       2,492 |       2,485 |       2,546 |       2,495
NSyncStreamsOf1             1  3543551,254 | 3606618,888 | 3614771,590 | 3567401,694 | 3602242,709 | 3611750,573
NSyncStreamsOf1           100   299166,910 |  299075,019 |  271830,698 |  299063,067 |  301703,721 |  302071,539
NSyncStreamsOf1          1000    28404,751 |   28612,302 |   28363,753 |   28482,301 |   28420,833 |   28577,877
NSyncStreamsOfN             1  4054571,577 | 4143834,293 | 4041081,408 | 4020815,026 | 4003156,953 | 4057396,041
NSyncStreamsOfN          1000       24,324 |      20,916 |      20,821 |      20,553 |      20,601 |      20,736
TwoAsyncStreamsOfN          1    85846,727 |   86027,435 |   83778,359 |   84782,438 |   85682,983 |   84881,540
TwoAsyncStreamsOfN       1000     1823,137 |    1778,062 |    1804,147 |    1758,151 |    1889,458 |    1898,120
reamOfNthatMergesIn1        1  3724179,351 | 3723142,805 | 3751296,228 | 3729408,751 | 3725068,220 | 3717625,162
reamOfNthatMergesIn1     1000    19051,928 |   19251,003 |   21053,425 |   19270,488 |   19392,595 |   19262,662
reamOfNthatMergesIn1  1000000       18,265 |      18,066 |      18,323 |      18,172 |      18,069 |      16,494
```

The `growable` is a modified version of JCTools' `SpscGrowableArrayQueue` to support full capacity utilization. The `growable-fx` is a variant where it is used as a fixed capacity queue. Both are in par with 1.x except on 2-3 cases where they perform 20% worse. Note that due to the pooling, the queues may reach their full capacity and thus the cost of resize diminishes over time.

The `spsc` is the usual `SpscArrayQueue` but again fixed support full capacity utilization. It does well but has 10%-20% loss in some benchmarks.

The `-2wrp` postfix indicates a different phasing: separate phaser for the writers and separate phaser for the readers: it reduces contention between writers and readers and since both are single threaded, it allows the phaser to use lazySet on its egress counters instead of atomic increment-and-get. In addition, the phase flip uses spinning instead of yielding. They all perform well and get closer to the 1.x mark if not surpassing it; however, there isn't one that mostly outperforms the others within the error margin. The `-2wrpp` is a padded version which seems to improve on some of the high-contention benchmarks. The final column of `spsc-2hp` is a two half-phasers (no odd epoch since it isn't really used) and performs quite well except in two benchmarks which drop I can't explain.

In conclusion, I'd chose SpscArrayQueue + two lazy writer-reader-phaser implementation to replace 1.x; it gets close to the baseline and is correct to avoid false sharing of queues between subsequent uses. [See implementation here](https://github.com/akarnokd/RxJava/blob/experimental-ringbuffer-writerreaderphaser/src/main/java/rx/internal/util/RxRingBuffer.java).
 =||= Looks interesting. I'll play with the implementation you provided. Do you want to provide a cleaned up pull request of your proposed winner?
 =||= Sure.
 =||= ,0
7278,588,Observable.concat does not,This issue was discovered by Graeme Ludwig during the Coursera "Principles of Reactive Programming" class.

```
scala> import rx.lang.scala._
import rx.lang.scala._

scala> Observable(1,2,3,4,5,6,7,8,9,10).groupBy(_ % 2 == 0).filter{_._1 == true}.map{_._2}.concat.subscribe(x => println(x))
2
4
6
8
10
res0: rx.lang.scala.Subscription = rx.lang.scala.Subscription$$anon$1@6e0031c0

scala> Observable(1,2,3,4,5,6,7,8,9,10).groupBy(_ % 2 == 0).filter{_._1 == false}.map{_._2}.concat.subscribe(x => println(x))
1
3
5
7
9
res1: rx.lang.scala.Subscription = rx.lang.scala.Subscription$$anon$1@3f18dc75

scala> Observable(1,2,3,4,5,6,7,8,9,10).groupBy(_ % 2 == 0).map{_._2}.concat.subscribe(x => println(x))
1
3
5
7
9
res2: rx.lang.scala.Subscription = rx.lang.scala.Subscription$$anon$1@320bdadc
```

The concat method seems to be misplacing the results of one of the Observables.  Above was using rxjava-scala 0.15.1,Could be the manifestation of Issues #552 and #583, and hopefully fixed by #586.
Excuse my lack of Scala knowledge, but where does this misplacement happen in the examples above?
 =||= The scala bindings typically add no logic of themselves but just wrap & unwrap the underlying Java classes, so in the common case the issue is in RxJava as @akernokd suggests. @LannyRipple can you repro this in Java.
 =||= I did some testing (with Java 8) and it prints the same values with and without the concat fix. I think @LannyRipple expected the last one to print `{1,3,5,7,9,2,4,6,8,10}`, so this is rather the good old groupBy issue: once concat finishes with the odd values, the even group has already finished and there is nothing to print. (#282 and #289). However, the workaround I proposed in #289 works:

``` java
Observable<Integer> source = Observable.from(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
Func1<Integer, Boolean> gf = v -> v % 2 == 0;
ConnectableObservable<Integer> co = source.replay();
Observable.concat(
     co.groupBy(gf)
          .map(u -> co.where(v -> gf.call(v) == u.getKey()))
).subscribe(System.out::println);
co.connect();
```

or

``` java
Observable.concat(
    source.groupBy(x -> x % 2 == 0).map(u -> u.replay()).doOnEach(v -> v.connect()))
.subscribe(System.out::println);
```
 =||= Oops.  Sorry.  I should have mentioned the output I expected which would have been the odd numbers then the evens.

I'll make a mental note and reply back to the class forums that groupBy can cause surprising results.  Thanks for the clarification of the issue.
 =||= ,0
7279,39,Operator: DistinctUntilChanged,http://msdn.microsoft.com/en-us/library/hh229494(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229776(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229508(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229533(v=vs.103).aspx,nan,0
7279,38,Operator: Distinct,http://msdn.microsoft.com/en-us/library/hh229764(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211630(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244310(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229050(v=vs.103).aspx,nan,0
7279,37,Operator: Dematerialize,http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx,nan,0
7279,36,Operator: Delay,http://msdn.microsoft.com/en-us/library/hh229677(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229810(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229250(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229280(v=vs.103).aspx,Once we have this operator, we can implement [Time Flies Like An Arrow](http://reactive-extensions.github.io/RxJS-Examples/timeflies/timeflies.html) :-)
 =||= Pretty. :-) I'll see what I can do...
 =||= @benjchristensen What about implementing delay as combination of "interval" and "first" operations?
 =||= @lexer I don't think that can get us the needed functionality. Here is the discussion: https://github.com/Netflix/RxJava/pull/384#issuecomment-26393612
 =||= Delay is implemented.
 =||= ,0
7279,34,Operator: DefaultIfEmpty,http://msdn.microsoft.com/en-us/library/hh229332(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229624(v=vs.103).aspx,nan,0
7279,31,Operator: Contains,http://msdn.microsoft.com/en-us/library/hh228965(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229815(v=vs.103).aspx,nan,0
7279,30,Operator: Concat,http://msdn.microsoft.com/en-us/library/hh212124(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229289(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211916(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh212146(v=vs.103).aspx,It seems like this operator has been already implemented 

https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperationConcat.java
 =||= Yes you're correct.
 =||= ,0
7279,29,Operator: CombineLatest,http://msdn.microsoft.com/en-us/library/hh211991(v=vs.103).aspx,What's the status on this operator? - There is some code, but the tests look a bit different from what I would expect this operator to do.

Shouldn't

``` java
            w1.Observer.onNext("1a");
            w1.Observer.onCompleted();

            w2.Observer.onNext("2a");
            w2.Observer.onNext("2b");
            w2.Observer.onCompleted();

            w3.Observer.onNext("3a");
            w3.Observer.onNext("3b");
            w3.Observer.onNext("3c");
            w3.Observer.onNext("3d");
            w3.Observer.onCompleted();
```

generate "1a2b3a", then "1a2b3b", then "1a2b3c", then "1a2b3d"? Because it starts with the latest values of `w1` and `w2` as soon as `w3` fires its first string? - To me, this currently looks a bit like a mixture between `zip` and `combineLatest`. But maybe I'm understanding the semantics of `combineLatest` wrong.

The current code seems to still "wait" for an `onNext` from each combined observable before firing its own `onNext`? I'd love to try and fix that, if you can confirm that I understand `combineLatest` correctly.
 =||= As I'm reading through this I'm using the following to research the expected behavior:

http://blogs.microsoft.co.il/blogs/bnaya/archive/2010/03/10/rx-for-beginners-part-8-combine-latest-expression.aspx
http://theburningmonk.com/2010/03/rx-framework-iobservable-combinelatest/

> Like IObservable<T>.Zip, IObservable<T>.CombineLatest com­bines ‘pairs’ of val­ues from the two observ­able col­lec­tions, but unlike Zip when a new value becomes avail­able on one col­lec­tion it does not wait till a new value to be avail­able on the other col­lec­tion, instead it takes what­ever the lat­est value is from the other col­lec­tion (pro­vided there is one):

The test case appears to be as follows:

```
x.onNext(1)
y.onNext("a")
x.onNext(2)
x.onNext(3)
y.onNext("b")
x.onNext(4)
```

This should result in:

```
a1
a2
a3
b3
b4
```

On each `onNext` from whatever sequence sends it the combination will be emitted using whatever the latest value is.

Extrapolating that into a unit test I get something like this:

``` java
        @Test
        public void testCombineLatestDifferentLengthObservableSequencesWithInterleaving1() {
            Observer<String> w = mock(Observer.class);

            TestObservable x = new TestObservable();
            TestObservable y = new TestObservable();

            Observable<String> combineLatestW = Observable.create(combineLatest(y, x, getConcat2StringsCombineLatestFunction()));
            combineLatestW.subscribe(w);

            /* simulate sending data */
            x.Observer.onNext("1");
            y.Observer.onNext("a");
            x.Observer.onNext("2");
            x.Observer.onNext("3");
            y.Observer.onNext("b");
            x.Observer.onNext("4");

            x.Observer.onCompleted();
            y.Observer.onCompleted();

            /* we should have been called 5 times on the Observer */
            InOrder inOrder = inOrder(w);
            inOrder.verify(w).onNext("a1");
            inOrder.verify(w).onNext("a2");
            inOrder.verify(w).onNext("a3");
            inOrder.verify(w).onNext("b3");
            inOrder.verify(w).onNext("b4");

            inOrder.verify(w, times(1)).onCompleted();
        }
```

This test fails with current code.

So yes, the current implementation is wrong - and it's crazy complicated.

I'll take a look at your pull request for this fix (hopefully tomorrow, though I have a lot of meetings so ...)

Thank you @jmhofer 
 =||= I agree. Your test should work with my pull request as I've added a similar test. Also, I simplified the code a bit, but I wasn't sure how thoroughly I could/should rework it, so I kept the basic structure (I guess the complexity mostly comes from the Zip operator it seems to have been copied from originally).

The one thing I'm still unsure of is when the combined stream should complete. That first of your links above says: "the Combine Latest processing will come to end either when one of the stream will complete or throw exception." - However I don't really see a reason why it should complete before all streams are complete. - I haven't found any other specification yet for cross-checking this.
 =||= You can change the implementation to whatever makes sense as I obviously misunderstood the behavior when I implemented this long ago and stole the base functionality from `zip` which starts it from the wrong place altogether since it shouldn't do queuing and thus doesn't need a lot (or any?) of the synchronization the zip requires.

Your last question is a good one. If an `onError` is received at any time the whole thing should finish and propagate the error.

For the `onCompleted` question I'm not sure ... the C# code will provide the definitive answer. I'll try to review that (no time right now) unless you can beat me to it or find a better answer somewhere else.

https://rx.codeplex.com/SourceControl/changeset/view/aa25748a430e#Rx/NET/Source/System.Reactive.Linq/Reactive/Linq/Observable/CombineLatest.cs

Another way would be a Rx.Net or RxJS test case if you have access to either of those or someone who does.
 =||= The C# code looks very much like they complete only when all streams are complete (when there are no errors). - That's good, then the pull request code should already handle that correctly.
 =||= Great, then I'll proceed with the review and merge. I appreciate your willingness to dive into this one and deal with that gnarly code.
 =||= So if I understand correctly, synchrononous (blocking) sequences make `combineLatest` behavior rather odd, such as this where only the last value of the first sequence will ever show up in the combined values:

``` java
            Observable<String> w = Observable.create(combineLatest(Observable.toObservable("one", "two"), Observable.toObservable(2, 3, 4), combineLatestFunction));
            w.subscribe(aObserver);

            verify(aObserver, times(1)).onNext("two2");
            verify(aObserver, times(1)).onNext("two3");
            verify(aObserver, times(1)).onNext("two4");
```
 =||= Yes, I think so. - I came to that conclusion, too. "latest" doesn't really make much sense in the synchronous case.
 =||= I updated my pull request: I had previously forgotten to adapt the comments. Also, I cleaned up the code a bit and tried to fix synchronization (it's hard, as always...)
 =||= I have merged pull request https://github.com/Netflix/RxJava/pull/207 to resolve this issue.
 =||= ,0
7279,38,Operator: Distinct,http://msdn.microsoft.com/en-us/library/hh229764(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh211630(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh244310(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229050(v=vs.103).aspx,nan,0
7279,37,Operator: Dematerialize,http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx,nan,0
7279,39,Operator: DistinctUntilChanged,http://msdn.microsoft.com/en-us/library/hh229494(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229776(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229508(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229533(v=vs.103).aspx,nan,0
7279,36,Operator: Delay,http://msdn.microsoft.com/en-us/library/hh229677(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229810(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229250(v=vs.103).aspx
http://msdn.microsoft.com/en-us/library/hh229280(v=vs.103).aspx,Once we have this operator, we can implement [Time Flies Like An Arrow](http://reactive-extensions.github.io/RxJS-Examples/timeflies/timeflies.html) :-)
 =||= Pretty. :-) I'll see what I can do...
 =||= @benjchristensen What about implementing delay as combination of "interval" and "first" operations?
 =||= @lexer I don't think that can get us the needed functionality. Here is the discussion: https://github.com/Netflix/RxJava/pull/384#issuecomment-26393612
 =||= Delay is implemented.
 =||= ,0
7280,2297,Make RxJavaPlugins.reset() public,Let me preface this by saying the RxJava library has made my life easier in just the short time I've been using it. However, there's one jagged edge that bit me today.

I'm attempting to use the `RxJavaPlugins` class to override the default schedulers via `registerSchedulersHook`. However, I want to only override the defaults for a single JUnit test. Ideally, I would call `RxJavaPlugins.getInstance().reset()` in my `@After` method...but I can't, because it is package private.

I could get at it via reflection, but it'd be easier if it was public -- unless there is a) a very good reason it is not or b) there is an obvious alternative I am missing (always a possibility!),I'm open to making it public. Do you want to submit the PR to make the change?

There are 2 reasons it is not public: 

1) I avoid making things public until they need to be as once public it must be supported for a very long time. 
2) The drawback ... resetting the plugins is not safe during application runtime and also bad code could invoke it in the middle of an application life-cycle and really break things. For example, a 3rd party transitive library that abusively calls `reset()` in order to always register its plugin automatically in place of anything else already registered. 

Of course, if someone wants to do that bad thing we can't prevent it anyways, since all someone has to do is put a class inside the same package and invoke `reset` from there. So the "security drawback" isn't a strong enough reason to avoid it. And the non-safe issue is one developers will just have to understand and use it wisely. In other words, `reset` should never be called during normal application operation. 

/cc @akarnokd @mattrjacobs @abersnaze for your thoughts on this
 =||= Some good points. I definitely agree with "as private as possible" by default. 

After looking into it some more, I see that my use case would not precisely be served by this -- even if I could re-register a different hook, the `Scheduler` class will have already assigned its instance fields for `io`, `computation`, etc. 

For now I am solving my testing issue by injecting a `Scheduler` with Guice which is annotated with `@Named("io")`, and in the test substituting `Schedulers.test()` for that scheduler. I'm not sure I love that approach as the scheduler doesn't feel like a "real" dependency, and it's another thing which must be configured in the DI container... Another approach might be to sidestep the public API and swap out schedulers using something like PowerMock.

So, rambling aside -- making `reset()` public still would not let me tweak the default schedulers on a per-test basis. If I think of an alternative approach which doesn't seem to compromise the safety of the rest of the API I'll submit a PR.
 =||= Why don't you use operators which let you parametrize the scheduler and not rely on the defaults?

For the other hooks, you could set up a level of indirection, i.e., you register your own hook which then does allow setting/removing further hooks at will. You can even create it such a way that multiple hooks can work at the same time, but you have to implement a separate Observable-Observer and make careful decisions when these hooks return some value instead of just consuming.
 =||= As a work around for this what I have done by now is defining a RxJavaTestPlugins class on src/test/java/rx/plugins

```
public class RxJavaTestPlugins extends RxJavaPlugins {
    RxJavaTestPlugins() {
        super();
    }

    public static void resetPlugins(){
        getInstance().reset();
    }
}
```

And then invoke `resetPlugins()`  on the ~~tear down~~ setup of my units test before `registerSchedulersHook`

If your run it on the `tearDown` there can be another test that uses RxJava then, hence default hook is already loaded and you can't load your custom hook.
 =||= I very much would like something like this, too.

I do something similar to what you have but as a JUnit rule so it can be used as:

``` java
@Rule public final RxJavaPluginsResetRule pluginsReset = new RxJavaPluginsResetRule();
```

and it calls `.reset()` automatically both before and after each test.
 =||= FYI RxAndroid shipped with a `@Beta reset()` method public on its `RxAndroidPlugins` class.
 =||= @JakeWharton Is there really a point of doing .reset() in your Rule? To me it doesn't seem to have the expected effect. Any subsequent call to Schedulers.\* will still return the same original Scheduler even after calling .reset(). Since the hooks are only called once when the Schedulers instance is created.

I can't seem to find a valid use case for using RxJavaPlugins to register test schedulers in unit tests really. Maybe it was never intended for that anyway.
 =||= Here's an example of how you can accidently misuse TestScheduler to break unrelated tests.
https://github.com/pakerfeldt/rxjava-the-schedulers-pitfall
 =||= Actually, using a singleton TestScheduler wrapper we can more easily identify when we accidently initialize Schedulers before our hook is called (instead of just getting weird behavior in the test):
https://gist.github.com/pakerfeldt/db297764918e7d464884#file-testschedulerproxy-java

However, that would require all unit tests that happen to execute any code that would initialize Schedulers to first initialize our TestSchedulerProxy (which registers the hook). And possibly also advance / trigger the test scheduler I guess.
 =||= I ran into this exact problem and it was frustrating. I ended up creating the following TestWatcher, which is specific to verifying that there are no leaking subscriptions, but I suppose could be used more generally. 

```
/**
 * This Verifier will assert that any subscriptions created during a test are unsubscribed after the
 * test has finished.<br>
 * 
 * NOTE: It is very important that the call {@link #initialize()} is done before any
 * {@link Observable} is created. Failing to do so, means that the {@link SusbcriptionCollector}
 * would fail to collect any subscriptions.
 */
public class RxTestCaseSubscriptionsVerifier extends TestWatcher
{
    @Override
    protected void starting( Description description )
    {
        SusbcriptionCollector subSusbcriptionCollector = SusbcriptionCollector.getInstance();

        checkState( ! subSusbcriptionCollector.isCollecting(),
                    "Cannot start collecting subscriptions while another SusbcriptionCollector is " +
                    "already collecting." );

        subSusbcriptionCollector.startCollecting();
    }

    @Override
    protected void succeeded( Description description )
    {
        SusbcriptionCollector subSusbcriptionCollector = SusbcriptionCollector.getInstance();

        checkState( subSusbcriptionCollector.isCollecting(), 
                    "Cannot assert all subscriptions are unsubscribed if the SusbcriptionCollector " +
                    "was not collecting subscriptions" );

        subSusbcriptionCollector.assertAllSubscriptionsAreUnsubscribed();
    }

    @Override
    protected void finished( Description description )
    {
        SusbcriptionCollector subSusbcriptionCollector = SusbcriptionCollector.getInstance();

        subSusbcriptionCollector.reset();

        checkState( ! subSusbcriptionCollector.isCollecting(), 
                    "The SusbcriptionCollector should not be collecting once reset" );
    }

    /**
     * See NOTE in the class documentation.
     */
    public static void initialize()
    {
        SusbcriptionCollector.getInstance();
    }

    private static class SusbcriptionCollector
    {
        private static SusbcriptionCollector INSTANCE = null;

        private final Map<Subscription, String> mSubscriptions =  Collections.synchronizedMap( Maps.newHashMap() );
        private volatile boolean mShouldCollect = false;

        private SusbcriptionCollector()
        {
            RxJavaPlugins.getInstance().registerObservableExecutionHook( createSubscriptionCollector() );
        }

        static synchronized SusbcriptionCollector getInstance()
        {
            if ( INSTANCE == null )
                INSTANCE = new SusbcriptionCollector();

            return INSTANCE;
        }

        void startCollecting()
        {
            mShouldCollect = true;
        }

        public void assertAllSubscriptionsAreUnsubscribed()
        {
            synchronized( mSubscriptions )
            {
                for ( Map.Entry<Subscription, String> entry : mSubscriptions.entrySet() )
                {
                    if ( ! entry.getKey().isUnsubscribed() )
                    {
                        fail( "There was an non-unsubscribed subscription detected " +
                              "which was created at the following place:\n" +
                              "<-------------------- start unsubscribed stack -------------------->\n" + 
                              entry.getValue() +
                              "<--------------------- end unsubscribed stack --------------------->" );
                    }
                }
            }
        }

        private void reset()
        {
            synchronized( mSubscriptions )
            {                
                mSubscriptions.clear();
                mShouldCollect = false;
            }
        }

        private boolean isCollecting()
        {
            return mShouldCollect;
        }

        private RxJavaObservableExecutionHook createSubscriptionCollector()
        {
            return new RxJavaObservableExecutionHook()
            {
                @Override
                public <T extends Object> Subscription onSubscribeReturn( Subscription subscription )
                {
                    if ( ! mShouldCollect )
                        return subscription;

                    String stackTrace = Debug.getStackTrace( new Exception( "Subscription not unsubscribed." ) );
                    mSubscriptions.put( subscription, stackTrace );
                    return subscription;
                };
            };
        }
    }
}
```

then in the test you need to add the following:

```
@Rule public final TestRule mSubscriptionsVerifier = new RxTestCaseSubscriptionsVerifier();
```

or in a Test Suite class you could do this if you want  to use the rule on all tests.

```
    @BeforeClass
    public static void initializeRxVerifier()
    {
        RxTestCaseSubscriptionsVerifier.initialize();
    }
```
 =||= I also think making `reset()` public would be very useful for unit testing. At the moment, there isn't a way of calling `registerSchedulersHook` during local unit tests that doesn't end up throwing `java.lang.IllegalStateException: Another strategy was already registered` 

The closes I got was from the constructor of a custom test Runner but this only works for the first test case, the rest would throw the exception above. So the two option I have is catch the `IllegalStateException` so once my hook is registered it will live for the rest of the tests or use reflection to call reset. I'm using reflection for now but there should be a better way of achieving this.
 =||= @ivacf Not sure if you are referring to my previous comment, but it's very important that you add:

```
    @BeforeClass
    public static void initializeRxVerifier()
    {
        RxTestCaseSubscriptionsVerifier.initialize();
    }
```

to whatever class groups all you're tests. If you don't have a suite that groups tests, then it's possible this might have to be done before each test. Anyway, this was tricky and frustrating for the reasons you already mentioned.
 =||= :+1: 
I was trying to contribute back to `spring-cloud-sleuth` to have distributed tracing capabilities across RxJava threadpools as well (https://github.com/spring-cloud/spring-cloud-sleuth/issues/235). I am following their current `Hystrix` implementation strategy : https://github.com/spring-cloud/spring-cloud-sleuth/blob/master/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/instrument/hystrix/SleuthHystrixConcurrencyStrategy.java#L66
You could reset HystrixPlugins but the same cannot be done right now with RxjavaPlugins. I have to create a wrapper (as mentioned above) in the same `rx.plugins` folder as a workaround (testing as we speak if it's working or not). 
It'd be good to not have to do this workaround. 
 =||= Hi! @benjchristensen @akarnokd @mattrjacobs @abersnaze  - any news on this? It doesn't seem like a big change and would certainly be helpful in Spring Cloud Sleuth's intergration with RxJava.
 =||= I don't use the plugin API so can't tell if its worth it or what consequences it holds. PR welcome.
 =||= Closing via #3820
 =||= I'm getting problem when I use:
`@ClassRule public static final RxJavaPluginsResetRule pluginsReset = new RxJavaPluginsResetRule();`
instead of:
`@Rule public final RxJavaPluginsResetRule pluginsReset = new RxJavaPluginsResetRule();`

`@ClassRule` causes `(singleExecutionHook.get() == null)` to be `true` in `RxJavaPlugins.getSingleExecutionHook()` which leads to default hook for `RxJavaPlugins`.

How can it be possible?
Thanks!
 =||= Not sure if its related to this issue, but just wanted to say that RxJava2 changed a few things about how to override schedulers. I found another way outlined here: http://stackoverflow.com/a/43320828/3870025 =||= ,0
7280,2293,Stack trace is opaque for IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.,This occurs when using RxAndroid 0.23.0/RxJava 1.0.0, please redirect me if this is not the most appropriate place for this.

There seem to be a several ways to cause the following exception, notably using observeOn() on a when there exists overproducing or underconsuming, and there is no clear association with client code:

```
java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.
       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:50)
       at android.os.Handler.handleCallback(Handler.java:733)
       at android.os.Handler.dispatchMessage(Handler.java:95)
       at android.os.Looper.loop(Looper.java:146)
       at android.app.ActivityThread.main(ActivityThread.java:5598)
       at java.lang.reflect.Method.invokeNative(Method.java)
       at java.lang.reflect.Method.invoke(Method.java:515)
       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1283)
       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1099)
       at dalvik.system.NativeStart.main(NativeStart.java)
Caused by: rx.exceptions.OnErrorNotImplementedException
       at rx.Observable$31.onError(Observable.java:7204)
       at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:127)
       at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:96)
       at rx.internal.operators.NotificationLite.accept(NotificationLite.java:147)
       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:177)
       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:65)
       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:153)
       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)
       at android.os.Handler.handleCallback(Handler.java:733)
       at android.os.Handler.dispatchMessage(Handler.java:95)
       at android.os.Looper.loop(Looper.java:146)
       at android.app.ActivityThread.main(ActivityThread.java:5598)
       at java.lang.reflect.Method.invokeNative(Method.java)
       at java.lang.reflect.Method.invoke(Method.java:515)
       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1283)
       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1099)
       at dalvik.system.NativeStart.main(NativeStart.java)
Caused by: rx.exceptions.MissingBackpressureException
       at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:222)
       at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.onNext(OnSubscribeCombineLatest.java:201)
       at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceRequestableSubscriber.onNext(OnSubscribeCombineLatest.java:252)
       at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)
       at rx.Scheduler$Worker$1.call(Scheduler.java:118)
       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)
       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)
       at java.util.concurrent.FutureTask.run(FutureTask.java:237)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)
       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
       at java.lang.Thread.run(Thread.java:841)
```

I'd like to strike up a discussion highlighting common causes on these backpressure exceptions, how to determine the source of them in client code, and finally how to improve the stacktrace.,May relate to 
https://github.com/ReactiveX/RxJava/issues/1821
https://github.com/ReactiveX/RxJava/issues/1804
https://github.com/ReactiveX/RxJava/issues/1682
 =||= You can simply add an `onError` handler so that RxJava can report the error to you.
 =||= Right, but given I have hundreds of places that I could add that onError handler to, and decoupled stacktrace, I have no obvious place to start.
 =||= You can register a global error handler if you don't have specific error handlers. We use it at Netflix to track unhandled errors. 

Take a look at http://reactivex.io/RxJava/javadoc/rx/plugins/RxJavaPlugins.html#registerErrorHandler(rx.plugins.RxJavaErrorHandler)
 =||= Since you haven't defined an error handler all that can be done is register the uncaught exception. This has been discussed at length, particularly in #1682 and #1766 which added the `uncaughtExceptionHandler` behavior: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/schedulers/ScheduledAction.java#L58

Errors are propagated down, not up, when going across thread boundaries. When an exception is thrown up, as happens when there is no error handler defined, it will eventually hit the thread boundary and then we send it to the ErrorPlugin and register it with the `uncaughtExceptionHandler`: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/schedulers/ScheduledAction.java#L56

So you have 3 options:

1) add error handling in your application (generally the appropriate solution)
2) add an `uncaughtExceptionHandler` (the JDK solution for getting unhandled errors)
3) add a `RxJavaErrorHandler` (the RxJava solution for getting unhandled errors)

Now a few more specific questions:

> given I have hundreds of places that I could add that onError handler to

This jumped out at me as that number doesn't sound right. If you have hundreds of places where you are subscribing that generally indicates a problem (unless your application is rather large or has many distinct use cases). The `subscribe` should only happen at the very end of an `Observable` sequence. In a request/response loop serving a user request for example, there would be one `subscribe`. Do you legitimately have hundreds of individual use cases with subscribes, or by chance are you doing nested subscribes inside `map` and other such functions?

> I'd like to strike up a discussion highlighting common causes on these backpressure exceptions

What particular questions do you have about causes? 

The operators involved are generally going to be `merge`, `flatMap`, `zip`, or `observeOn`. 

> how to determine the source of them in client code

The stack trace you showed suggests it is probably a `timer. combineLatest` sequence. See the next comments below for more on this. 

> and finally how to improve the stacktrace.

This is the biggest weakness of async code because JVM callstacks are intended for synchronous imperative code. I personally am researching solutions for stitching together artificial callstacks that show the actual user code instead of the JVM callstacks which show the Rx library, but to do it without killing performance requires digging into the native JVM code via native java agents. Thus it will not be an option for Android. We may be able to create one for debugging purposes that uses normal Java, but it would be far too slow to ever enable in production (as it involves capturing a stacktrace at every operator invocation). 

Another route we are exploring is the use of the plugins for debugging and capturing the callgraph as a stream of events. We have succeeded in getting the graph of events, but not yet had time to create a UI to make it usable. You can see the effort so far at https://github.com/ReactiveX/RxJavaDebug Again, this would be too slow for production use except for cases where it is dynamically enabled just for tracing a particular request. 

What suggestions do you have and what would you like to help improve?
 =||= @benjchristensen thank you for taking the time to answer. I think I understand the difficulty here. I've already got an `uncaughtExceptionHandler` hooked up to some analytics that made me aware of this issue in the first place. 

> This jumped out at me as that number doesn't sound right. If you have hundreds of places where you are subscribing that generally indicates a problem (unless your application is rather large or has many distinct use cases). 

You're right. Performing a search for `subscribe(` in my application turned up 153 instances, where about 110 of those are in client/UI binding code, and 43 in service-level code. Admittedly, there is a lot of legacy code here that wholly misses the mark of Rx in general and abuses subscriptions where other more appropriate operators should be used. I've begun identifying and cleaning up instances of these abuses and hopefully that will improve the situation.

> The stack trace you showed suggests it is probably a timer. combineLatest sequence. See the next comments below for more on this.

I see where the stack trace references timer, but I don't see any obvious references to combineLatest without knowing more about the internals of the library. I don't use timer directly in my client code, but I do use `Workers/SchedulePeriodically` and `Observable.interval()` 

For the time being, is there some way I can apply a global backpressure strategy, knowing that it will have negative side-effects, until I can properly address my problems?
 =||= You can apply onBackpressureBuffer to your source and it will make it behave the same as before. If that isn't an option you can set a global property for rx.ring-buffer.size to a value higher than your max stream length. 
 =||= Another curiosity for me to better understand how things get used. Why do you end up using Workers/SchedulePeriodically directly instead of an operator like interval?=
 =||= In my opinion, it happens because programmers come from the classical Executor training and find the Scheduler as the nearest thing to work with periodically. 

The second cause, I think, is that not using a value from a source and mapping in something else is a strange way of doing async work. (I.e., using `just(1).subscribeOn(io()).map(_ -> { doWork(); return 2;}).subscribe();`).

Maybe the detailing of the scheduler API should be an advanced topic described way after the use of operators such as timer and interval. Besides, using the Worker correctly to avoid leaks in operators or in user code is IMO an advanced topic.
 =||= @benjchristensen Naivety. Like I said, I've begun re-writing the app to eliminate some of these novice mistakes. Something like `Observable.interval(x).takeUntil(needsCleanup).flatMap(...).subscribe()` for some of the cases where I'm using schedulePeriodically and accessing member observables within their subscribes.

edit) @akarnokd is fairly spot on. The API feels familiar and is accessible. Can you elaborate on:

> The second cause, I think, is that not using a value from a source and mapping in something else is a strange way of doing async work. (I.e., using just(1).subscribeOn(io()).map(_ -> { doWork(); return 2;}).subscribe();).
 =||= >  Naivety

That's a good enough reason :-) It took me many months before I was using this style of programming correctly. 

What would you suggest we improve to provide education and examples for how to do things idiomatically and functionally? I was lucky to have an expert close by when I was learning so I could ask lots of questions. Without that it would have been far harder. As you have learned, what do you wish you could have been provided by the RxJava project early on to teach you?
 =||= @benjchristensen I'm under a fairly tight deadline right now, but I'll try to review the current education resources and get you some feedback soon.

I picked up RxJava-Android (when it was called that) back in March 2014; my interest was originally piqued having used ReactiveCocoa on iOS. Much of what I've picked up has been from a combination of the documents from https://github.com/ReactiveX/RxJava/wiki/The-RxJava-Android-Module and hard-won from ReactiveCocoa's Github issues. Luckily most of the Rx contract is upheld between the two implementations ;)
 =||= @benjchristensen Not sure if my suggestion is solid. I have seen the following above:

> I personally am researching solutions for stitching together artificial callstacks that show the actual user code instead of the JVM callstacks which show the Rx library, 

The problem I am facing right now is that somewhere there is not placed an onError so it causes the (android) program to crash. It would be very helpful to see the codeline of the original Action0 (or something similar) so we can easily locate the problem. Of course I do not know the implications of the whole JVM - as you say above.

Update for further people hitting this from google: 
As a general solution I registered the `registerErrorHandler` and then:

```
 Log.w("Error",e);
```
 =||= We are actively exploring this space, but nothing usable yet. Also, it is only for the Hotspot/OpenJDK/Oracle JVMs that we are pursuing anything right now. I don't know what the options are for Android. 

Just the other day I saw some native C code via native plugins and also via JNI allowing a logical callstack across async boundaries. Performance is still an issue though. Beyond that I don't have much further to offer as a solution at this time.

We still use println logging (via `doOnEach`, `doOnNext`, `doOnSubscribe`, `doOnUnsubscribe`, `doOnRequest`, etc) for our debugging today at Netflix. 
 =||= I am toying with RxJava and I had this issue as well. I think ReactiveX should be very careful to explain the difference between Observable.doOnError (side effect, will still blow up) and Subscriber.onError (last consumer, if handled here your error won't pop anymore. At least that was my problem. https://twitter.com/Corlaez/status/782023068793339904
 =||= maybe callback run in wrong thread.
i just meet the problem, and solve it.
 =||= it occurs to me that Action1<> can be dangerous to use, given that Observable.subscribe will throw unchecked exception in onError ... ex:

```        
final rx.plugins.RxJavaErrorHandler rxJavaErrorHandler = new rx.plugins.RxJavaErrorHandler() {
            @Override
            public void handleError( final Throwable x ) {
                System.out.println( "rxJavaErrorHandler.handleError: " + x.getClass().getSimpleName() );
            }
        };
        rx.plugins.RxJavaPlugins.getInstance().registerErrorHandler( rxJavaErrorHandler );

        final rx.functions.Action1<Long> action = new rx.functions.Action1<Long>() {
            @Override
            public void call( final Long L ) {
                System.out.println( "tick" );
                try { Thread.sleep( 2500 ); } catch ( InterruptedException x ) {}
            }
        };

        final rx.Subscription subscription = rx.Observable.interval( 100L,TimeUnit.MILLISECONDS )
                .subscribeOn( rx.schedulers.Schedulers.io() )
                .observeOn( rx.schedulers.Schedulers.newThread() )
                .subscribe( action );
```

this code generates MissingBackpressureException, which propogates to OnErrorNotImplementedException then is wrapped in IllegalStateException ... but in ScheduledAction.run, calls `RxJavaPlugins.getInstance().getErrorHandler().handleError(ie);` and then regardless calls `thread.getUncaughtExceptionHandler().uncaughtException(thread, ie);`
to me this means you don't really get to "handle" the error in your registered RxJavaPlugins error handler. 
on android, this will kill the process.
 =||= That seems normal. If you don't supply what is the reactive equivalent of a
catch block then the exception propagates resulting in app death. Supply an
error handler and the problem goes away.

On Sun, Nov 27, 2016, 10:53 PM GuBo <notifications@github.com> wrote:

> it occurs to me that Action1<> can be dangerous to use, given that
> Observable.subscribe will throw unchecked exception in onError ... ex:
>
> ` final rx.plugins.RxJavaErrorHandler rxJavaErrorHandler = new
> rx.plugins.RxJavaErrorHandler() {
> @Override <https://github.com/Override>
> public void handleError( final Throwable x ) {
> System.out.println( "rxJavaErrorHandler.handleError: " +
> x.getClass().getSimpleName() );
> }
> };
> rx.plugins.RxJavaPlugins.getInstance().registerErrorHandler(
> rxJavaErrorHandler );
>
>     final rx.functions.Action1<Long> action = new rx.functions.Action1<Long>() {
>         @Override
>         public void call( final Long L ) {
>             System.out.println( "tick" );
>             try { Thread.sleep( 2500 ); } catch ( InterruptedException x ) {}
>         }
>     };
>
>     final rx.Subscription subscription = rx.Observable.interval( 100L,TimeUnit.MILLISECONDS )
>             .subscribeOn( rx.schedulers.Schedulers.io() )
>             .observeOn( rx.schedulers.Schedulers.newThread() )
>             .subscribe( action );`
>
> this code generates MissingBackpressureException, which propogates to
> OnErrorNotImplementedException then is wrapped in IllegalStateException ...
> but in ScheduledAction.run, calls
> RxJavaPlugins.getInstance().getErrorHandler().handleError(ie); and then
> regardless calls thread.getUncaughtExceptionHandler().uncaughtException(thread,
> ie);
> to me this means you don't really get to "handle" the error in your
> registered RxJavaPlugins error handler.
> on android, this will kill the process.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/2293#issuecomment-263178113>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEYQnNW4Hqy1bK6ssdmWzvsUYCyr5ks5rClBLgaJpZM4DNEGU>
> .
>
 =||= but rx.plugins.RxJavaPlugins.getInstance().registerErrorHandler( rxJavaErrorHandler );
was my error handler.

if i put .doOnError( Action1<Throwable>... ) after .observeOn, it gets called but the chain
continues on to call the plugin errorhandler, then it calls the actual Subscriber that Observable creates to wrap the Action, and this then throws OnErrorNotImplementedException.

(if i subscribe on a SafeSubscriber, i.e. new rx.Observer<>... then there is not the problem ... problem is with subscribing with an Action1) =||= The problem is this:

> .subscribe( action );

You have to handle exception by consuming it via `subscribe`:

```java
.subscribe( action, error -> errorHandler(error) );
``` =||= I am trying a program in android studio which was provided by ResearchStack. I am acing the same error and I now I should use an Error Handler to solve this issue. But the RxJava program is an executable jar file of RxJava. So where can I add the error handler program? 
 =||= ,0
7282,320,JRuby examples don't work (JRuby picks the wrong overloaded method),The JRuby adapter doesn't work because JRuby can't figure out which overloaded `Observable#subscribe` method to pick. It ends up picking `Observable#subscribe(Map<String, Object>)`, which raises an error because the argument doesn't respond right:

``` ruby
require 'rxjava-core-0.10.0.jar'
require 'rxjava-jruby-0.10.0.jar'

observable = Java::Rx::Observable.toObservable(['one', 'two', 'three'])
observable.take(2).subscribe(lambda { |x| puts x })
```

the code above prints the following errors in JRuby 1.7.4:

```
% ruby rxjava.rb
rxjava.rb:6 warning: ambiguous Java methods found, using subscribe(java.util.Map)
onNext
Observable.java:278:in `subscribe': java.lang.RuntimeException: 'onNext' key must contain an implementation
    from NativeMethodAccessorImpl.java:-2:in `invoke0'
    from NativeMethodAccessorImpl.java:57:in `invoke'
    from DelegatingMethodAccessorImpl.java:43:in `invoke'
    from Method.java:601:in `invoke'
    from JavaMethod.java:455:in `invokeDirectWithExceptionHandling'
    from JavaMethod.java:316:in `invokeDirect'
    from InstanceMethodInvoker.java:61:in `call'
    from MethodHandle.java:599:in `invokeWithArguments'
    from InvocationLinker.java:153:in `invocationFallback'
    from rxjava.rb:5:in `__file__'
    from rxjava.rb:-1:in `load'
    from Ruby.java:807:in `runScript'
    from Ruby.java:800:in `runScript'
    from Ruby.java:669:in `runNormally'
    from Ruby.java:518:in `runFromMain'
    from Main.java:390:in `doRunFromMain'
    from Main.java:279:in `internalRun'
    from Main.java:221:in `run'
    from Main.java:201:in `main'
```

in JRuby 1.6.8 it prints a less verbose version of the same error.

Notice the line which reads "onNext". That's actually the `puts` from `lambda { |x| puts x }` in action. JRuby wraps the lambda in something that looks like a `Map`, and then when RxJava calls `get` on that map JRuby calls `call` on the lambda.

So if you modify the example code to read `lambda { |x| lambda { |y| puts y } }` this is what happens:

```
% ruby rxjava.rb
rxjava.rb:6 warning: ambiguous Java methods found, using subscribe(java.util.Map)
RxJava => Could not find function language adaptor: Groovy with path: rx.lang.groovy.GroovyAdaptor
RxJava => Successfully loaded function language adaptor: JRuby with path: rx.lang.jruby.JRubyAdaptor
RxJava => Could not find function language adaptor: Clojure with path: rx.lang.clojure.ClojureAdaptor
RxJava => Could not find function language adaptor: Scala with path: rx.lang.scala.ScalaAdaptor
one
two
```

Which kind of works, but it's not as smooth as the ideal API would be:

``` ruby
observable.subscribe { |x| puts x }
```

But that would probably require a real JRuby native extension (if I get the time I'll send you a pull request with one).,Glad to have you involved, we haven't had much use of JRuby (that I'm aware of) so I'm not surprised we have some issues. I would appreciate your involvement.

Can you check out code from this pull request (https://github.com/Netflix/RxJava/pull/319), build the rxjava-jruby jar and try it? We are working on a very different approach in this pull request for language adaptors that is statically typed.

As for the `subscribe(Map)` overload ... I'm not thrilled by that one and it has caused other issues. I've considered getting rid of it before we hit 1.0, but I know it's used in a variety of places so haven't pulled that trigger.
 =||= It works better, but not perfect. JRuby seems to pick a working overload, but it still warns about there being multiple overloads (which is hard to fix without adding JRuby-metadata to the `Observable` class).

An upside is that you can skip the `lambda { ... }` and use the more Ruby-ish: `obs.subscribe { |x| puts x }` (i.e. pass a block to `#subscribe`).

Since there will be a version generated to work specially for JRuby, how much can the code generation things add? Ideally it would add JRuby metadata to the class to make it work as a JRuby native extension. Can you give me any hints on how to dig into that? Where should I start to look in the code to understand the code generation?
 =||= If the generated `Observable` could be something like this (but lots more, obviously), it could integrate with JRuby even better:

``` ruby
@JRubyClass(name="Rx::Observable")
public class Observable<T> extends RubyObject {
    @JRubyMethod(meta = true, rest = true)
    public static <T> Observable<T> from(ThreadContext ctx, IRubyObject receiver, IRubyObject[] args) {
        // ...
    }

    @JRubyMethod(name = "subscribe")
    public IRubyObject subscribeRuby(ThreadContext ctx, Block block) {
        // ...
    }
```

There would be some more code needed that registered the class with the runtime, and created the `Rx` module, and some more things, but that wouldn't need to be generated.
 =||= Can you take a look at pull request https://github.com/Netflix/RxJava/pull/323 and suggest how to re-add JRuby support correctly? We have decided against doing byte-code generation.

We can not add anything (such as the annotations in your example) to rxjava-core, it needs to be in a separate submodule, similar to Groovy, Scala and Clojure. So this means using something like extension methods, implicits, or other such tools if JRuby supports them. 
 =||= I will have a look.
 =||= With some small patches at least some of the basics work:

``` ruby
require 'rxjava-core/build/libs/rxjava-0.10.1-SNAPSHOT.jar'

class Java::Rx::Observable
  java_alias :subscribe, :subscribe, [Java::RxUtilFunctions::Action1.java_class]
end

module Rx
  include_package 'rx'
end

o = Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

I haven't tested any more than that, but it looks like it could work.
 =||= #323 should be `0.11.0-SNAPSHOT` afaik, not `0.10.1-SNAPSHOT`. Are you sure you're using the correct version of RxJava?
 =||= Good catch, I'm not used to gradle, or even having to compile stuff, so I didn't clean up from the last build I did so the old jars were still around. 

The Ruby patch works with 0.11.0 too (which means that those small patches would have make the old version work too, so that's good to know). Without the patch it works as with #319, the code runs but it prints a warning about not finding the right overloaded method.

The boring part of doing it this way is that each method on Observable, and any other classes needed for interoperability will need to be annotated with `java_alias`. On the other hand I don't see any other way of doing it which wouldn't involve writing even more code.
 =||= Does JRuby have a way to apply these aliases programmatically? For example, in Groovy we use reflection to determine all methods that need extensions and then programmatically create all of the `MetaMethod` implementations to bridge Groovy and Java. You can see an example here: https://github.com/mattrjacobs/RxJava/blob/8c87c29bea5e076bdc4202af5626d474ab1c7117/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/RxGroovyExtensionModule.java#L103

Otherwise every time a new method is added to core someone will have to maintain the JRuby java_alias mappings.
 =||= Maybe, I'm not sure, I'll have to look into more about how JRuby's native extensions work. So far I've only done it by creating classes and adding metadata, but I guess that it should be possible to do it on existing classes to somehow.

If I understand the code you linked to correctly it's looking through the `Observable` and `BlockingObservable` classes for methods that take subclasses of `Function` and somehow makes the Groovy runtime prefer those over any other overloads. That's what would be needed for JRuby too, and since the Groovy version just uses Java reflection to do it I think it should be possible in JRuby too. 

All that the `java_alias` thing does is that it looks up a Java method by reflection and adds that method into a cache that JRuby will look in before it looks at the Java class, which is kind of similar to what the Groovy extension thing does, I think.

So, yes, probably, maybe, hopefully, but I'm not sure exactly how right now.
 =||= This isn't complete yet, but here's a first pass at an implementation I think will work. @benjchristensen can you take a look and let me know if this is the direction you're looking for? It's largely cribbed from the Groovy implementation.

https://github.com/ragalie/RxJava/commit/fc0a706faaa27d1d797cfb8c43080a3b68e1cb1f
 =||= I'm getting warnings about overloads.

This is my code:

``` ruby
require 'rxjava-core/build/libs/rxjava-core-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/build/libs/language-adaptors-0.14.2-SNAPSHOT-sources.jar'

module Rx
  include_package 'rx'
end

o = Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

and this is the output (JRuby 1.7.4):

```
rxjava.rb:14 warning: ambiguous Java methods found, using subscribe(rx.util.functions.Action1)
2
4
6
```
 =||= Just to be clear, the commit I posted doesn't work yet. I just want to make sure that the approach is sane before investing more time in it. 
 =||= Ok. Yeah, it might work.

Not sure how well the generated methods will work, though: they are added on the classes, but call `super` to call the original method, but I'm not sure that `super` is actually what you think it is (it might be, I assume you've run the code, and I have not, so I could be completely wrong). In other words, you're adding a method on `Observable`, and then you call `super` in that method to call the original method on `Observable`, but that should call a method on the superclass of `Observable`, not the original method -- unless JRuby tries to be clever and figures out that your added method is on the eigenclass and `super` should refer to `Observable`, but I don't think it does.

And either way, once you call `super` JRuby still has to look up the right Java method to call, and it doesn't have any more type information to do it, so it will pick one at random and print out the "ambiguous Java methods found" warning. Even if you've wrapped the proc in an `Action` I'm not sure that JRuby will pick the right overloaded method. In my experience it tries, but it doesn't always succeed in picking the right method.

I think a better way to solve the problem is to use `java_alias` as in one of my examples above. That way JRuby will always pick the right overload. I'm not sure all the wrapper classes would be needed in that case, because JRuby will wrap a proc in a proxy class that implements whatever interface is required (and since `Function` and `Action` interfaces only really have one method, that also just happens to map straight to interface of proc, I think letting JRuby do it makes sense). There might be a slight performance loss from letting JRuby generate proxies instead of having Java classes, but I think it's greatly outweighted by skipping a large part of the work that JRuby otherwise would have done in finding the right overload.
 =||= You're right, the `super` approach won't work.

I tried the `java_alias` approach first and the problem I ran into is that it didn't seem to work correctly when a method had multiple signatures with the same number of arguments. For instance, I tested it with RxJava 0.10 which has `subscribe(Hash)` and `subscribe(Action1)` (or something like that). I tried just running `java_alias` on the methods that had `Function` arguments and it threw an error when I tried to use the `Hash` argument. I tried running `java_alias` on all methods, but running it first on the non-function methods and second on the function methods and that didn't work either (threw an error with a `Hash` argument).

I'm a relative newbie at JRuby, so totally possible I'm doing something wrong. But from my basic understanding I don't understand how `java_alias` will be a solution if there are two signatures with the same number of arguments and we want to allow access to both of them.
 =||= I spent some more time researching this evening and I think the easiest path forward is to leverage the JRuby method dispatching as much as possible. Outside of the `Proc` => `Action`/`OnSubscribeFunc`/`Function` casts, which we can reliably do but which the JRuby dispatch logic is having trouble reliably doing, the default dispatch logic is likely to be far better at sussing out the method signature we want to invoke than we would be.

The first thing the dispatch logic checks for when trying to find a method signature match is whether the Java class of the argument provided is an exact match with the parameter type specified in the method signature (see: https://github.com/jruby/jruby/blob/master/core/src/main/java/org/jruby/java/dispatch/CallableSelector.java#L321). While it isn't guaranteed that this will always be true (JRuby could change the dispatch logic), I think it's a safe bet that it will continue to preference exact class matches when selecting overloads. I think that means that as long as we pass in arguments that implement the exact interfaces JRuby should have a much easier time finding the matching method signature.

Assuming that's true, I think we should implement an algorithm like the following on load:
- Select the methods that have any signatures that contain a parameter type that is a (sub)interface of `rx.util.functions.Function`
- Determine the (sub)interfaces of `Function` that are possibilities for each argument position for a given method.
- If any given argument position has more than one possibility (e.g. `Action1` or `Action0`), ignore.
- If any given argument position has only one possibility, then note that we should convert any `Proc` we see in that argument position into the `Function` subclass we've identified.

Then I think we should implement the following to occur at runtime:
- Upon invoking a method where we've noted that we should convert `Proc`s, replace the `Proc` arguments with wrappers that implements the noted interfaces, if applicable.
- Call the original Ruby method with the modified arguments.

We should be able to do this using `alias_method` to copy the original `subscribe`, for instance, to `subscribe_without_argument_wrapping` and then redefine `subscribe` to modify the arguments and call `subscribe_without_argument_wrapping` with the updated arguments.

Under this scenario most of the hard dispatch logic remains in Java: the only additional runtime things we're doing in Ruby are a) a check to see if the argument is a `Proc`, b) a Hash lookup to see whether we can replace the `Proc` with a wrapper and c) instantiating the Java wrapper. So I don't think it should significantly slow things down.

It's clear you've thought about this quite a bit @iconara; anything stick out to you as suspect here?
 =||= It isn't the cleanest thing in the world, but https://github.com/ragalie/RxJava/commit/957af11bb7e843e79e72a7559a7c0c8a24052e35 seems to be working correctly.

This code no longer causes an ambiguous method warning:

``` ruby
require 'rxjava-core/build/libs/rxjava-core-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/rxjava-jruby/build/libs/rxjava-jruby-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/rxjava-jruby/src/main/ruby/rx/lang/jruby/interop'

o = Java::Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

I'm going to clean it up as best as I can then open a PR. I'm pretty new to JRuby, though, and I'm sure there are some ways to simplify what I've done, so hopefully someone can help me out with that. In particular I'd love to be able to leverage the built-in JRuby proxying (telling it which interface to proxy) instead of the clunky ones in the commit.

I also don't know what to do with the Ruby code. Should that stay in the JAR and just need to be required manually? Or should it be pulled out to a gem? I'm not sure what's idiomatic.

Thanks!
 =||= @ragalie I'm sure it can be done more elegantly, but it would take a lot of time, and I don't know very much more about the details of JRuby's Java integration to say for sure how to do it. It's better to get something that works and improve it later than trying to find the optimal solution now.

There's a way to package a JAR that makes JRuby run code when it is require'd from Ruby code. You need to stick a special class at the root of the JAR (here's an example: https://github.com/iconara/msgpack-jruby/blob/master/ext/java/MsgpackJrubyService.java). It's used to load JRuby native extensions (i.e. Java code that creates JRuby modules and classes), but in this case it could be used to automatically run the interop code (which can be loaded from within the JAR).

Another option would be to make the the interop code the main entrypoint for Ruby, and for it to load `rxjava-core.jar` and `rxjava-jruby.jar`. Come to think of it, that would be the better solution.

The benefit of the former solution would be that you could ship it all as just the JAR, but the latter is simpler to maintain and is how many JRuby wrappers for Java libraries work.

If it's ever going to get any kind of adoption in the Ruby world the library must be packaged as a gem.
 =||= I implemented JRuby support in #422. Let me know what you all think and if there's anything that doesn't seem to be working correctly. Thanks!
 =||= Awesome @ragalie! I'm taking a look now and will merge it into master or iterate with you on it if there are changes needed.
 =||= ,0
7282,336,Idiomatic Scala Support,As of version 0.11.0 Scala support is provided through the use of implicits. Conversations on Twitter are bringing up other possible improvements. Let's use this issue to discuss.  ,A few comments from my point of view (since I first looked at this project, I always wanted to use it from Scala):

Now that the core is typesafe, imho we have the first workable Scala integration (via implicits). From here on, everthing depends on how much effort we want to put into this vs how convenient it will be for the users.

What we already have is that the most important method names match (`map`, `flatMap`, `filter`). Matt also made Scala for-comprehensions work with observables.

There's a lot of room for improvements, though. It seems that due to Scala-Java interop, there are problems with type inference (I even ran into a Scala compiler crash somewhere), and sometimes `asJava` collection conversions are necessary. Also, Scala/Akka futures are not yet addressed at all. An Akka-specific scheduler would probably be awesome to have, too.

For full Scala user convenience, we'd probably have to completely wrap `rx.Observable` into its own `rx.scala.Observable`. This would mean a lot more maintenance effort for the Scala integration, of course (I don't think we can do this automatically via code generation or macros, but I'm no expert of all that). But still, I think it's well worth it to create a dedicated Scala API.
 =||= 1) Implicit-based integration with Java-based observables has a serious flaw as it doesn't support parameter type inference for lambdas. The situation isn't going to change until https://issues.scala-lang.org/browse/SI-6221 is fixed. It's definitely fixed in 2.11, and at EPFL we have a compiler plugin that backports the fix to 2.10. Probably Typesafe folks can be convinced to do the backport in one of 2.10.x releases (/cc @adriaanm @gkossakowski @retronym @JamesIry).

2) Some features that might be desirable in `rx.scala.Observable`: a) native function types, b) native collections, c) method names familiar to folks that use native collections, d) making parameter of `defer` by-name, e) creation of Observables via `apply` rather than via `from`.

3) I also don't think that macros can help with `rx.scala.Observable`, because what you're probably after isn't just a copy/paste of a Java API, but rather a redesign that takes Scala features into account. But if there are some things that can be autogenerated, I'll be happy to answer questions about how macros work and how they can be used.
 =||= IMHO, after looking at the code, using implicits convertions is not a good idea.

I think you have better to start with a complete wrapper of the API, then you'll be able to apply scala idiom (basically writing a DSL) instead of having a Java API with some facilities for converting type.

And that way you don't have to wait for https://issues.scala-lang.org/browse/SI-6221 ... which sounds anyway like a clumsy integration of Java API to me.
 =||= Here is some [background](https://github.com/Netflix/RxJava/issues/204#issuecomment-15249648) on why the current design was chosen rather than having each language with a separate version of Observable:

---

The approach of having language specific packages/classes was pursued but did not work well because Rx is a composable library. It means that every time an `Observable` is used it needs to be re-wrapped or un-wrapped by whichever language is using it.

For example ...

From Java a library is exposed that has a method like this:

``` java
rx.Observable getData()
```

From Groovy a library is exposed with a method like:

``` java
rx.groovy.GroovyObservable getOtherData()
```

Then from Scala you need to wrap them again:

``` java
rx.scala.ScalaObservable.from(getOtherData())
```

This means we have an `rx.Observable` wrapped as `rx.groovy.GroovyObservable` wrapped as `rx.scala.ScalaObservable`.

To compose the two we would have:

``` java
rx.scala.ScalaObservable.zip(rx.scala.ScalaObservable.from(
      getOtherData()), 
      rx.scala.ScalaObservable.from(getData()),
       ... scala closure here ...);
```

Now what does `ScalaObservable` return from its operators? `ScalaObservable` or `Observable`?

Should the above zip operator return `rx.scala.ScalaObservable` or `rx.Observable`? What happens if this library is consumed from another language?

If `Observable` each step along the way it must be wrapped yet again. If `ScalaObservable` it has now changed all of the return types of `rx.Observable` to a subtype.

In short, for interop between languages it very quickly becomes a mess and our primary polyglot goal was that `rx.Observable` was usable across all libraries as the single type and because the whole point of Rx is chained composition it's not as simple as just a single decoration at the beginning. It affects every single method in an API and step of the chaining.

For this reason we chose the current language-adaptor model so `rx.Observable` can remain the sole public interface across languages.
 =||= Thanks for providing the design notes!

I wonder though how often people tend to mix languages in their projects. Usability improvements in switching from a Java-based least common denominator to an idiomatic API might be significant. Does being polyglot overweigh these improvements?
 =||= I'm not sure if wrapping `Observable` for Scala (not in a subclass though) would really hurt so much. Imho it's worth a try to find out how it feels. There will be a lot of wrapping and unwrapping behind the scene though, I'm afraid.
 =||= At Netflix we are using Clojure, Groovy, Java and Scala and I know of apps running code from at least 3 of those 4 in the same JVM instance. I imagine it's not common in most environment for this type of diversity, but it is something we have wanted to support as seamlessly as possible. This is because we have wanted the `rx.Observable` to act as the interface we can expose across module boundaries as it naturally ends up at the edge of the API in methods such as `Observable<T> getDataFromService(args)`. This is part of what drove us to target the JVM with RxJava and not any specific language.

That said, an idiomatic solution that works best for pure Scala apps is more important. If we can find a solution that can retain the use of `rx.Observable` without a completely separate wrapper then great, otherwise let's have a `ScalaObservable` for pure Scala apps and a way of going back and forth across language boundaries when it's needed. Perhaps the implicits that exist right now can solve the immediate interop needs for easy interaction from Scala to Java, but the option to convert to `ScalaObservable` would also be there.

Another piece of information to guide this ... the Rx.Net version in C# is defined by simple interfaces for `Observer` and `Observable` without any of the operator interfaces on them. All of the operator methods (static and instance level) are added via extension methods. It's quite clean and makes the interfaces more flexible (anyone can easily implement them and the extension methods are 'just there' without inheritance involved).

The reason RxJava has `Observable` as a concrete class is because extension methods don't exist in Java so we don't have a choice but to have them as concrete methods to enable the fluent chaining pattern.

In Scala however we do have extension methods (implicits), macros etc that theoretically can allow the `rx.Observable` to be made into whatever it needs to be for idiomatic Scala usage, similar to how C# implements Rx.Net using extension methods. I imagine a possible issue is if existing methods on `rx.Observable` are in the way and cause problems in achieving idiomatic Scala functionality, if that's the case I'd like to understand what those issues are and if they can be resolved and if not if they really are deal breakers.

At this point I become not so helpful as I am not skilled enough in Scala to have a valid opinion or guide the conversation much further. I do have some questions though for the Scala experts here:

1) What would make `rx.Observable` idiomatic for Scala?

I'd like to see unit tests or sample code demonstrating expected behavior and usage so that we're all working towards the same goal and know when we've achieved success.

2) What about the current `rx.Observable` + Scala implicits is not working well?

3) What requirements of (1) can not be achieved with implicits and macros and requires a separate concrete class as a wrapper?

Thank you everyone for your involvement, I really do want us to find the ideal solution for Scala and then as a secondary priority make it work well across the JVM for polyglot applications.
 =||= Thank you for your swift feedback! It's a pleasure to help.

1) I'm not an Rx expert, and in fact this is the first time I see any Rx code apart from random snippets in web articles, so please don't treat this list as definitive. Comprehensive analysis would require quite some time, and I'm not sure I have it right now.

a) `Observable.from` could be replaced by `Observable.apply`, so that one can write `Observable(1, 2, 3)` instead of `Observable.from(1, 2, 3)`.

b) It shouldn't be necessary to write `asJava`, e.g. as in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L349, and `asScala` (not sure whether it's necessary now).

c) Use of mutable collections in situations like https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L350 is really inconsistent with Scala's pursuit of immutability. I wonder whether it'd be possible to write such code in a functional way.

d) Instead of taking a no-arg function, `Observable.defer` could take a by-name parameter, which would obviate the need of creating an explicit closure: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L232.

e) For a former C# developer like me, method names like `lastOrDefault` sound familiar, but for the Scala croud out there - not so much. How about changing the names and maybe even signatures, so that they mirror method names of native collections? E.g. `lastOrDefault` could become `lastOption` (also note the change from default values to options).

f) I'm also not sure whether extension methods are even necessary. From what I would guess, in C# they are forced to use them, because interfaces can't define methods with implementations (at least, that was the story with `IEnumerable` and `Enumerable`). In Scala, we can do that, so why not just put all the combinators in `Observable`?

g) `mapMany` in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L351 is essentially `flatMap`, right?

h) No idea how this name could be stated more succinctly, but `toBlockingObservable` feels a bit verbose. When I moved from C# to Scala, in people's code I felt an overall tendency to compress everything, including names. This is kind of a vague observation, so feel free to ignore it.

2) Function literals don't support inference for parameter types unless they are used in a context that requires a Scala native function type. In particular, inference won't work if function literals are supposed to be converted to something implicitly. 

E.g. in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L341 one can't drop type annotations for lambda parameters. I tried removing them and got a compilation error. (Btw why are you using 2.10.1, when 2.10.2 is already available for quite long? Did you have any problems with it?)

That's an instance of https://issues.scala-lang.org/browse/SI-6221, which has been fixed in 2.11 and probably could be backported to 2.10. If you're in need of an immediate solution, we at EPFL have a compiler plugin for 2.10 that provides a backport.
 =||= Excellent observations about the API @xeno-by. Currently, we are preparing exercises for the Coursera class [Principles of Reactive Programming](https://www.coursera.org/course/reactive). For this course we would like to make an idiomatic Scala API. @samuelgruetter is working on that. 

The cross language compatibility pointed out by @benjchristensen is a reasonable concern. However, I think there is a lot of monolingual projects out there that would greatly benefit from the idiomatic Scala library. It seems to me that  adding a Scala wrapper can be only a plus in those cases. 

For polyglot projects we could also take the Java rx.Observable as a common ground (being a return type of each operation and in API signatures). Then all of the Scala support can be added by an implicit conversion (rx.Observable => rx.ScalaObservable). 

As a long-shot maybe the interface for multi and mono lingual projects can be unified so that we do not repeat our selves. IMHO it is worth a try. 
 =||= Thanks for all the observations! I'll try to address some of the ones from @xeno-by.

1a), 1e) and 1g) are just aliasing problems, imho. We already have `flatMap` as alias for `mapMany`, and the other aliases could easily be added, either directly in `rx.Observable`, or in a Scala wrapper, if the namespace gets too big otherwise (not my preferred solution). Methods returning options will have to live in a Scala wrapper, however.

I didn't take a look at 1b) and collection conversions yet. This really shouldn't be necessary often, if at all.

1c) You're looking at test code here which tests the callback "at the end of the world". This is not really normal usage of the API. The whole RxJava codebase is refreshingly (though not completely) free of mutability, if you ask me. Also, the Rx API is actually there to allow you to handle all your events in a functional, immutable way. - In short, I don't see a problem here.

1d) is Scala-specific. By-name parameters are a great feature for methods like `defer`, I agree. We should make use of them in the Scala wrapper.

I'm not worried about 1f) either.

1h) I like the verbose name in this specific case. Imho, it's the same as `asInstanceOf` in Scala: Maybe I'm evil, but I like to punish people who do things they probably shouldn't do. :) Ok, there will of course be valid use cases for blocking observables, but there shouldn't be too many of them, hopefully.

2) is quite a big problem, if you ask me. A backport of the fix to Scala 2.10 would be great. We can probably get around this with a dedicated Scala wrapper, though.

And the reason for 2.10.1 instead of 2.10.2 is currently just a technical problem with the build system. I, too, hope that this will be fixed soon.
 =||= 1c) Even that can be made functional if you replace the subscribe() with .toList().toBlockingObservable().single();
 =||= @abersnaze You're right, good point.

I started a little experiment with a more idiomatic Scala wrapper. It's just humble beginnings currently, though. You can find it [here](https://github.com/jmhofer/RxJava/blob/scala-wrapper/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala). 

Comments and forks are welcome, of course. I started from the super-extends pull request in order to check how this whole thing feels in Scala.
 =||= Scala 2.10.2 support was added in version 0.11.2 (https://github.com/Netflix/RxJava/releases/tag/0.11.2).
 =||= > 1) Implicit-based integration with Java-based observables has a serious flaw as it doesn't support parameter type inference for lambdas. The situation isn't going to change until https://issues.scala-lang.org/browse/SI-6221 is fixed. It's definitely fixed in 2.11, and at EPFL we have a compiler plugin that backports the fix to 2.10. Probably Typesafe folks can be convinced to do the backport in one of 2.10.x releases (/cc @adriaanm @gkossakowski @retronym @JamesIry).

Sorry, we don't change type inference in minor versions unless there's a critical bug.
The risk of regression in source compatibility is too high.
 =||= > The cross language compatibility pointed out by @benjchristensen is a reasonable concern. However, I think there is a lot of monolingual projects out there that would greatly benefit from the idiomatic Scala library. It seems to me that adding a Scala wrapper can be only a plus in those cases.

I completely agree if a wrapper is the only way to achieve idiomatic support. Monolingual projects should take first priority as that is the common case.
 =||= We believe that the following solution would be best:
-   Implicit value class (let's call it `ScalaObservable` for the moment) wrapping an rx.Observable
-   all return types are `rx.Observable`
-   Since `ScalaObservable` is a value class, there is no runtime overhead for the wrapping (some explanations can be found in the second half of this [blog post](http://www.blog.project13.pl/index.php/coding/1769/scala-2-10-and-why-you-will-love-implicit-value-classes/)). This is new in Scala 2.10, and actually allows us to have extension methods similar to C#.
-   An object `FunctionConversions` containing all implicit conversions from Scala functions to Rx functions (the same as in the present [Scala adaptor](https://github.com/Netflix/RxJava/blob/rxjava-0.11.1/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L29)). These conversions are only used by the adapter, users of Scala Rx won't use them.
-   All instance methods of `rx.Observable` which take a Func or an Action have a wrapper method in `ScalaObservable` whose signature has Scala functions and whose body uses the conversions from `FunctionConversions`
-   `ScalaObservable` has map, flatMap, filter, like in the [present adaptor](https://github.com/Netflix/RxJava/blob/rxjava-0.11.1/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L108) to enable for comprehensions
-   `ScalaObservable` has `lastOption` method instead of `lastOrDefault` etc
-   functions passed by Rx Scala users to Observable needn't be implicitly converted, so we're not affected by the [bug](https://issues.scala-lang.org/browse/SI-6221) that parameter type inference of implicitly converted functions does not work in Scala 2.10
-   An `object Observable` with `apply` methods instead of `from` and `create`
-   polyglot projects can also use this approach

I've started to implement such an adapter and will post some code soon.

Note that I've not (yet) addressed the following points:
-   compatibility with Scala/Akka futures
-   how to integrate `ScalaObservable` with Scala collections to get all methods of Scala's [Traversable](http://www.scala-lang.org/api/current/index.html#scala.collection.Traversable)
 =||= @samuelgruetter Sounds awesome! Very much looking forward to your sharing the code.
 =||= You can see what I'm doing [here](https://github.com/samuelgruetter/rx-playground/blob/master/RxScalaAdapter/src/main/scala/ScalaAdapter.scala). Note that it's still very incomplete and not yet tested, but work is in progress.
 =||= Great, thanks! I'll play around with it, too.
 =||= @samuelgruetter All of that sounds great.  I'll take a look next week and offer feedback.
 =||= There's an interesting problem with `map`: If I add an explicit conversion like `ScalaObservable(numbers).map(...)`, it works, but without, i.e. `numbers.map(...)` gives an error... I'll investigate on this. You can see the corresponding test [here](https://github.com/samuelgruetter/rx-playground/blob/365a7ba8afa4feda1f5961a3a21c524092caf8f4/RxScalaAdapter/src/main/scala/rx/lang/scala/Adaptor.scala#L497)
 =||= Maybe there's a 2nd implicit somewhere, adding map?
 =||= @samuelgruetter what is the error? if @jmhofer is right you should have an `amibgous` implicit resolution error.
 =||= If anything about the core Java library is causing issues let me know.
 =||= There's no 2nd implicit, but there's a second `map`: The `map` in rx.Observable. And scalac wants to use this one and does not convert to `ScalaObservable`. However, with `reduce`, it works...
 =||= Just another guess, but then it's maybe due to the type parameter of `map` (your `reduce` doesn't have one; you renamed the one with type parameter to `fold` which luckily avoids the problem).
 =||= Covariant support has been merged into master. This also changes the type used with `Observable.create`.
 =||= I believe all of the structural changes are now merged to master. Are there any other changes that should be made before we release 0.12 so as to better support Scala integration?
 =||= I've isolated the implicit conversion problem [here](https://github.com/samuelgruetter/rx-playground/blob/master/ScalaImplicitsProblem/src/main/scala/ScalaImplicitsProblem.scala). It's a problem with the Scala compiler.
@benjchristensen looking forward to a jar with covariant observables!
 =||= @samuelgruetter I'm pretty sure no one could make the scala compiler be able to solve an ambiguity like that one.

If you where the compiler, which method you think should be choosed?

You guys should seriously consider implementing a full wrapped scala version first, and keep multi-lang support as a cherry on cake.

IMHO it's a mistake to do the opposite, maybe I'm wrong but I think most scala user will want to use it in a full scala project.

And for the course, it would be good to have an idiomatic API.
 =||= scalac is indeed inconsistent, it goes the extra mile to try an implicit view when the originally tried method is monomorphic, but doesn't do the same if it is polymorphic.

That's unlikely to change soon, even in 2.11.

But, one change that is likely in the 2.11 timeframe is first class support of SAM types, which would let you write an anonymous function that would be translated to `rx.Func1`.

BTW, it's really great to see this discussion and cooperation happening!
 =||= So, to make polymorphic methods like `map` work, we'd have to return ScalaObservables, not (Java)Observables everywhere, I guess (which doesn't pose a problem anyway as far as I can see)?

@aloiscochard: Is that what you mean by "a full wrapped scala version"? - Because I thought that @samuelgruetter's goal was already to create a full wrapped scala version.
 =||= @jmhofer yeah it's exactly what I meant :-)

By doing that you'll be able to provide the best possible syntax for RX API, looking forward next enhancement!
 =||= @samuelgruetter is there something we can do in the short-term to work around this issue? Is there anything about the core library that if changed would simplify this effort?

@aloiscochard What about the approach being pursued (if the compiler bugs didn't exist) is a mistake?
 =||= @benjchristensen I don't see any problem with switching to the approach where we stay with intermediate ScalaObservables throughout the wrapper. As `ScalaObservable` is a value class, it shouldn't even impact performance at all.
 =||= I agree with @jmhofer. I've started such a Scala Observable which always returns Scala Observable, see [here](https://github.com/samuelgruetter/rx-playground/blob/master/RxScalaAdapter/src/main/scala/rx/lang/scala/Observable.scala)
 =||= @benjchristensen I would say it's kind of bad design, a form of overloading abuse. I would go the type-class way (on a similar Wrapper than @jmhofer one) to make a map function polymorphic.

Anyway, the current approach took by @samuelgruetter looks good!
As @jmhofer said there should be no perf impact as long as you keep a value class, and from what I've seen there should be no reason to need more than one value in the wrapper.

I have some remarks but I'l make them directly on @samuelgruetter commit as I did before.
 =||= @benjchristensen I'm confused about the jar releases. I thought they have contained @jmhofer 's changes for proper covariance/contravariance handling since 0.11.2, but apparently they don't:

In `rxjava-core-0.11.3.jar`, `flatMap` looks like this:

```
public <R> Observable<R> flatMap(Func1<T, Observable<R>> func) {
    return mapMany(func);
}
```

On github master, `flatMap` looks like this (that's what I would like to have in the jar):

```
public <R> Observable<R> flatMap(Func1<? super T, ? extends Observable<? extends R>> func) {
    return mapMany(func);
}
```
 =||= @samuelgruetter If I'm not mistaken, there was no release yet after the merge of the co-/contavariance branch. 0.11.3 was right before that. I'm afraid that you'll have to wait for 0.11.4 (or 0.12, more likely), or you'll have to work directly on the repo build of RxJava.
 =||= Those changes will be in 0.12 which has not been released yet. It was merged to master yesterday. 

Before releasing I wanted to determine if this thread of discussion required any further changes to core, and I want to get in https://github.com/Netflix/RxJava/pull/349 as well since it generalizes some objects in `rx.util` which hopefully gets confirmed today.

Is there anything else that if done in core for release 0.12 would improve Scala support?
 =||= I can't currently think of anything that if done in core for release 0.12 would improve Scala support. But probably I'll find such things just after 0.12 is released ;-)
 =||= Then once I wrap up those other things (hopefully today) I will release 0.12. I fully expect we'll find more to change ... hence us not being at 1.0 yet :-)
 =||= Due to the 2 bugs, are we unable to pursue the route where `rx.Observable` is the return type at this time?

Also, since I'm unfortunately not yet very experienced with Scala, in your examples would you mind demonstrating a use case where a ScalaObservable is exposed back to Java for interop? I'm interested in understanding how the solution being worked on would function in polyglot environments (while understanding this is a secondary priority).
 =||= if you call `.wrapped` on a `ScalaObservable` you get back the original `Observable` which can be used with the Java API.

Maybe we could find a better name that wrapped, not easy though ;-)
 =||= I'd prefer calling `.wrapped` `.asJava` instead (like the collection `JavaConverters` do).
 =||= Version 0.12 has been released. 
 =||= I've forked the RxJava repo and I'm now working [here](https://github.com/samuelgruetter/RxJava/blob/idiomaticscala/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala).
 =||= @samuelgruetter great stuff!
 =||= @samuelgruetter Good idea!

And: Yay, finally a covariant observable! Awesome! I've been working towards this all the time...
 =||= Well now I have a Scala compiler bug... It's [here](https://github.com/samuelgruetter/RxJava/blob/idiomaticscala/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala#L168). I don't know yet what to do about that.
 =||= @samuelgruetter  You can work around the bug by explicitly provide a type argument. I've isolated and reported this issue, along with the workaround, here: https://issues.scala-lang.org/browse/SI-7818
 =||= Try it with an explicit type parameter for the Java method: `new Observable(JObservable.synchronize[T](asJava))`

Works for me, at least.
 =||= Thanks @retronym. Is this going to be fixed in Scala 2.10.x? I'm asking because we want to use the Rx Scala Wrapper for a course in November, and we don't want to confront students with compiler bugs. So we consider temporarily removing `extends AnyVal`, until the interplay between value classes and covariance can be considered stable.
 =||= @samuelgruetter The particular bug only affects you when you define the value class. Clients of the class are safe.
 =||= ok, so we'll keep using `extends AnyVal`, unless it leads to more problems...
 =||= This [Observable.scala](https://github.com/samuelgruetter/RxJava/blob/955fbfcdfdd2ce12ac2ee578d63c8edd734f8444/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala) now contains all methods present in the Java Observable, **but** for many of them, there is only a comment containing their signature and a note on the problem I faced. You can find all these interesting problems by searching for `TODO`.
 =||= [![Code Bounty](https://app.codebounty.co/reward/image/6b82995d8cf0ea7678754a98)](https://app.codebounty.co/reward/link/6b82995d8cf0ea7678754a98)
 =||= I'm planning to continue as follows:
-    Add some tests to `Observable.java`. Their goal is not to test the correct behavior of the methods (that's already done in the unit tests of the operations), but to test if the method signatures of `Observable` are good, and to provide small usage examples.
-    I expect these tests to reveal some issues related to covariance. Fix these.
-    Continue with the Scala adaptor.
 =||= @samuelgruetter I just took a quick look, nice progress.

Looks like most of your issues are related to covariance, I haven't look in depth but there is some trick to workaround this kind of thing in scala... not sure if possible to apply them here.

I'll try to take a look during the week and give you feedback... not sure when unfortunately.

I've seen some comments where you hesitate returning the scala wrapped version or the java one, I would say that for a first version, just return the scala one.

You can refine that later trying to find where you can return the native type, IMO it's a nice to have but clearly not absolutely needed when using the API in pure scala.

About `Future`, I think it should be quite easy to create a wrapper to expose scala future as java one, have you tried implementing the java future interface backed by a scala one?
 =||=  @samuelgruetter Could you explain the problem with the `reduce` signature please?

Do you mean by your TODO that this needs a second type parameter `U` with `U extends T` etc instead of simple wildcards in Java, too?
 =||= I think that `reduce` needs a type parameter `U` with `U super T` in the Java Observable. And similar changes will be needed for other methods as well, in order to make sure that the `T` of `Observable<T>` never occurs in a contravariant position. I'll post corresponding code soon.
 =||= I added tests to [CovarianceTest.java](https://github.com/samuelgruetter/RxJava/blob/b59b68d7361bbb01604e2feaeba904a6b4cbd85c/rxjava-core/src/test/java/rx/CovarianceTest.java), which I would like to compile, but they don't, and I think that the signatures in `Observable.java` need to be tweaked.
The tests which do not compile are marked with `might-not-compile`.
I will now try to tweak `Observable.java` as needed.
 =||= The signature of `reduce` in `Observable.java` currently looks like this:

```
public Observable<T> reduce(Func2<? super T, ? super T, ? extends T> accumulator) {
                                                        ^^^^^^^^^^^
```

The problem with this is that the underlined `T` appears in a contravariant position. This means that we cannot say anymore that `Observable<T>` is covariant in `T`, and we cannot use Observable as we would like to:

```
public void libraryFunctionActingOnMovieObservables(Observable<? extends Movie> obs) {
    Func2<Movie, Movie, Movie> chooseSecondMovie = 
        new Func2<Movie, Movie, Movie>() {
            public Movie call(Movie t1, Movie t2) {
                return t2;
            }
        };
    Observable<Movie> reduceResult = obs.reduce(chooseSecondMovie); // <- weird error
    // do something with reduceResult...
}

public void codeUsingTheFunction() {
    Observable<HorrorMovie> horrorMovies = Observable.from(new HorrorMovie());

    // do something with horrorMovies, relying on the fact that all are HorrorMovies
    // and not just any Movies...

    // pass it to library (works because it takes Observable<? extends Movie>)
    libraryFunctionActingOnMovieObservables(horrorMovies);
}
```

The above code should compile, but instead produces a weird compilation error.

Now let's see how Scala solves this: The signature of reduceLeft in the Scala immutable collections (which are covariant in their type parameter `A`) looks like this:

```
def reduceLeft[B >: A](f: (B, A) => B): B
```

The trick is to add a type parameter `B` to the method, whose lower bound is `A`. Now `A` only appears in covariant positions, and we're fine.

So I thought we could just do the "same" in Java:

```
public <U super T> Observable<U> reduce(Func2<? super U, ? super T, ? extends U> accumulator)
```

But, unfortunately, Java does not support lower bounds for type parameters.

So, this makes me think that Java's type system is not powerful enough to properly support covariant Observables.

Because of this, I will now return to the Scala adaptor, and try to implement a covariant Scala Observable, which uses casts where necessary. If we later find a way to get rid of the casts, all the better.
 =||= I think it would be possible to work around that by making `reduce` static and giving it two type parameters `<U, T extends U>`. With this, we could probably simplify the type parameters of the instance method, dropping covariance in that place, and instead get the full covariance via the static method. Scala could just use the static method. 

I'm not sure whether we want that.

Or maybe there's a more direct workaround via casting (yuck). Haven't tried anything like that out yet.
 =||= It could go direct against the internal static operators instead of us putting an unnecessary static reduce on `Observable`.

``` java
Observable.create(OperationScan.scan(observable, accumulator)).takeLast(1);
```
 =||= Varargs have been removed from `Observable`: https://github.com/Netflix/RxJava/pull/361
 =||= Investigating issues with `reduce` covariance at https://github.com/Netflix/RxJava/issues/360#issuecomment-24128500.

It works when done statically instead of via an instance method: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/ReduceTests.java#L39
 =||= I can now confirm that the solution with value classes is indeed as awesome as we expected :D
I wrote a very small example showing how Java code can use Scala code: There's a [MovieLib.scala](https://github.com/samuelgruetter/RxJava/blob/0603e395b680655a923e138582d779c65d001651/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scalatests/MovieLib.scala), which uses Scala Observables everywhere.
In a second project, there is [MovieLibUsage.java](https://github.com/samuelgruetter/RxJava/blob/0603e395b680655a923e138582d779c65d001651/language-adaptors/rxjava-scala-java/src/main/java/rx/lang/scalaexamples/MovieLibUsage.java), which uses `MovieLib` as a class which uses Java Observables everywhere, because Scala value classes are such that the Scala Observables appear as Java Observables for the Java compiler.
The only challenge here is to set up the build process correctly: In this scenario, the Scala sources have to be built first, and then the Java sources. I achieved this by making a seperate project for `MovieLibUsage`, which depends on the project containing `MovieLib`.
 =||= Value classes are awesome. This means we don't even need to convert back to Java Observables anywhere. Thanks for the example.
 =||= Sounds great @samuelgruetter, I'm happy to hear that we can achieve idiomatic Scala and Java interop cleanly without converting back and forth!

Do the compiler bugs prevent us from moving forward or are their sufficient workarounds for now?

I am planning on releasing 0.13 with the changes merged to master shortly. Is there anything else you need to core to support `rx.lang.scala.Observable`?
 =||= We have sufficient workarounds for the compiler bug.

There's nothing fundamental that we need for the Scala adapter right now, but I'm currently trying to translate the dictionary autocomplete example written in C# from this [Rx Hands On Lab](http://blogs.msdn.com/b/rxteam/archive/2010/07/15/rx-hands-on-labs-published.aspx) to Scala to see what we can already do. For this, I miss the `distinctUntilChanged` and the `throttle` operator, so these are currently on top of my whishlist ;-)
 =||= The 'throttle' operator was just merged to master as `debounce``throttleWithTimeout`. See https://github.com/Netflix/RxJava/pull/368 for an explanation of the 3 variants of`throttle` that were committed.

We do not yet have `distinctUntilChanged` but that shouldn't be hard to get added.
 =||= That's great that workarounds exist so we can move forward, I look forward to hearing how the autocomplete example works.

If you can get that functioning is that strong enough evidence to move forward with it or are there still pieces of functionality lacking?

How do you envision ongoing maintenance of this class? Do all new operators added to `rx.Observable.java` required wrapping methods, or does it pass thru if a wrapper isn't there?
 =||= If I can get the autocomplete example functioning then I think that's strong enough evidence to move forward with it. We still lack operations in the wrapper, but it should be possible to add them all.

This adapter will require some maintenance. New operators added to the Java observable will have to be added to the adapter as well, and updates of the documentation too, because the signatures are too different to automate this. 
However, if really needed, one can always call `.asJava` on a Scala observable and use the Java methods directly, and if the implicit function conversions from Scala functions to Java Func/Action are imported, one could even use Scala functions. But that's not the intended way of using it and should only be used in quick hacks.
 =||= Good to know regarding maintenance ... we'll need to figure out a reasonable way of handling that as operators get added.

Do you have an idea of when I should expect a pull request with this new Scala Observable?

Is this a breaking change to how the implicits support currently works for Scala, or does this wrapper only take effect when someone imports `rx.lang.scala.Observable` instead of `rx.Observable`? Can the existing implicits continue existing alongside?
 =||= It's not a breaking change: The old `RxImplicits` are still there and usable, but marked as deprecated.
 =||= So does it make sense to mark them deprecated since they're still usable and possibly useful for someone accessing operations that haven't made their way to this curated wrapper? Just checking.
 =||= If an operation from `rx.Observable` has not yet made it to `rx.lang.scala.Observable`, there are the following solutions (ordered by my preference):
-    report an issue to get the operation into `rx.lang.scala.Observable` ;-)
-    call `.asJava` on the Scala observable and use the implicit conversions from `rx.lang.scala.internal.ImplicitFunctionConversions`
-    use the old `RxImplicits`
 =||= Btw `RxImplicits` and `ImplicitFunctionConversions` are almost the same, except that `ImplicitFunctionConversions` does not contain an `implicit class ScalaObservable`.
 =||= Pull https://github.com/Netflix/RxJava/pull/376 has been released in [0.13.1](https://github.com/Netflix/RxJava/releases/tag/0.13.1)

Thank you @samuelgruetter!
 =||= > Btw RxImplicits and ImplicitFunctionConversions are almost the same, except that ImplicitFunctionConversions does not contain an implicit class ScalaObservable.

With that one difference does it still require the two existing, or can `ImplicitFunctionConversions` perform the same functionality as `RxImplicits` and negate it's need? Or does having `RxImplicits` around still help for any use cases?
 =||= If there is already code out there depending on `RxImplicits`, we need to keep it to remain compatible with that code. If not, we can remove `RxImplicits` without any loss of functionality.
 =||= Given that there's no loss of functionality, I think it makes the most sense to remove `RxImplicits` and not introduce the chance of newcomers to RxJava depending on unsupported functionality.  I'll generate a pull request to this effect
 =||= Removing duplication makes sense. Since `rx.lang.scala.internal.ImplicitFunctionConversions` is escape hatch (besides manually using Func1 and friends) for stuff not covered by the Scala wrapper, would it make sense for it not to be in an internal package?
 =||= @mattrjacobs Good idea.

@daveray Well the goal should be that there is no such thing as "stuff not covered by the Scala wrapper"... Having `ImplicitFunctionConversions` in an internal package would increase the pressure to keep the Scala Observable in sync, which is a desired effect. And if we add a unit test as I outlined at the bottom of [this comment](https://github.com/Netflix/RxJava/pull/376#issuecomment-24439163), keeping the Scala Observable up to date would become easier.
 =||= Removing `RxImplicits` will be breaking for people until they change their import from `rx.Observable` to `rx.lang.scala.Observable` correct? If so I will bump the version to 0.14 when I merge this change.

Can someone also please update the README (https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/README.md) to show usage information to help someone get started?
 =||= @samuelgruetter It's up to you guys. I'll just leave with this: open source projects live a lot longer than the enthusiasm of their contributors so I'm skeptical of a wrapper that assumes it will always be kept completely up-to-date with complete coverage forever. If some third party decided to create a project of custom observables beyond what's in RxJava, those would be more difficult to use, assuming users respect the implication of "internal" in the package name. I'll go back to Clojure-land now :)
 =||= @daveray ScalaObservable has a method to get the wrapped Java Observable, so you should be able to use any method from its API.
And since the project is Open Source you can always send a Pull Request and improve it ;)
 =||= @martin-g Right. And if for whatever reason some poor Scala programmer finds herself in yucky Java-land calling these mehods, at least throw her a bone and make the Func implicits available in a non-internal package.
 =||= @martin-g Correct me if I'm wrong, but dropping down to using rx.Observable still mandates passing in `Func1/Func2`/etc.  Being able to use native Scala functions and the implicits in this case seems far better than forcing user code to new up these function types and pass them in.

After thinking about it, +1 to @daveray's idea of making both the value class and implicits available (with the value class preferred).  This will allow any temporary mismatch between `rx.Observable` and `rx.lang.scala.Observable` to be addressed by implicits while not impeding non-Scala developers from moving core along.
 =||= +1 on this. There are other places where `Func*` are used, such as `BlockingObservable` not yet wrapped, and as new things are added, if they don't yet have a full wrapper there should still be a way to use them with the implicits.
 =||= > it might be cool to have a unit test in which we encode the information "which Java method corresponds to which Scala method", and using reflection, we check if there is a Scala method for each Java method. So if a method is added to the Java Observable but not to the Scala Observable, this test would fail.
> 
> And if we add a unit test as I outlined at the bottom of this comment, keeping the Scala Observable up to date would become easier.

We can't make the build fail if `rx.lang.scala.Observable` is out of sync. We can't block the project from building and releasing just because a new operator is added and the developer adding it isn't comfortable deciding what the idiomatic Scala method signature should look like.

It needs to be an async process for Scala developers to add wrapper methods/classes. Since this is open source we can't control people's schedule and require quick turnaround on adding the wrappers. Ideally that will happen when new functionality is added, but we can't make building and releasing dependent on that.

Thus, I think we need to account for the fact that most things will have wrappers but very newly added functionality or fringe functionality may not and should still have a mechanism for being used.
 =||= If you want rxjava-core to evolve independently then perhaps rxjava-scala
and other language adapters should each be a separate top-level project
with its own release cycle.

On Mon, Sep 16, 2013 at 2:55 PM, Ben Christensen
notifications@github.comwrote:

> it might be cool to have a unit test in which we encode the information
> "which Java method corresponds to which Scala method", and using
> reflection, we check if there is a Scala method for each Java method. So if
> a method is added to the Java Observable but not to the Scala Observable,
> this test would fail.
> 
> And if we add a unit test as I outlined at the bottom of this comment,
> keeping the Scala Observable up to date would become easier.
> 
> We can't make the build fail if rx.lang.scala.Observable is out of sync.
> We can't block the project from building and releasing just because a new
> operator is added and the developer adding it isn't comfortable deciding
> what the idiomatic Scala method signature should look like.
> 
> It needs to be an async process for Scala developers to add wrapper
> methods/classes. Since this is open source we can't control people's
> schedule and require quick turnaround on adding the wrappers. Ideally that
> will happen when new functionality is added, but we can't make building and
> releasing dependent on that.
> 
> Thus, I think we need to account for the fact that most things will have
> wrappers but very newly added functionality or fringe functionality may not
> and should still have a mechanism for being used.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/336#issuecomment-24548044
> .
 =||= Erik Meijer and I have discussed this but it doesn't feel like the right thing to do, as it would hurt the JVM ecosystem more than benefit it if the different languages forked from each other. 

There is no harm in a new version of RxJava being released without the Scala adaptor adding the new functionality, as that is no different than a separate RxScala project not yet supporting it on top of the RxJava core dependency.

As we approach 1.0 the rapid iteration will slow and this will become less of an issue. Around that time as well the project may migrate into a different home than here.
On September 16, 2013 at 3:20:07 PM, Chris Richardson (notifications@github.com) wrote:

If you want rxjava-core to evolve independently then perhaps rxjava-scala  
and other language adapters should each be a separate top-level project  
with its own release cycle.
 =||= I like @daveray's point: If some third party decided to create a Java project of custom observables beyond what's in RxJava, and we want to use this project from Scala, then we need the `ImplicitFunctionConversions`. So I will make this non-internal.

@benjchristensen I agree that it would be kind of crazy to make the build fail just because `rx.lang.scala.Observable` is out of sync.
 =||= Closing this out as completed ... further progress/bugs can use new issues.

Great work and thank you everyone involved on this.
 =||= ,0
7282,339,Garbage Creation,Hi,

Do you use object pooling to prevent garbage being produced? Can this run without GC activity for a few weeks at least?

Suminda,No it does not use pooling. By definition Rx uses composition and if object allocation is a concern to you then it should not be used.  We use Rx extensively in the Netflix API without full (stop-the-world) GCs, but the young gen is constantly cleaning garbage. Our JVMs are tuned to handle the garbage throughput of Rx, Hystrix, JSON/XML/Thrift/etc serialization/deserialization and all other object allocations of the JVM. We (nor this library) do not attempt to fit the constraints of something like a financial trading application which pursues no object allocation at all. 
 =||= @benjchristensen Will you be willing to share some of the strategies you used for tuning the JVM? Which garbage collector do you use currently?
 =||= ,0
7282,304,Version 0.10.0 - Static Language Support,Manual merge of pull https://github.com/Netflix/RxJava/pull/300 from @mattrjacobs 

This will make RxJava completely static by removing all Object overloads (see https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204).

I'm submitting this before it being 100% ready so people can review and provide feedback.

Open items to append to this pull request before merging:

**1) subscribe with map is not handled yet**

The following signature needs to be made static. Right now the lack of this combined with removal of Functions.from dynamic language functionality has broken this.

``` java
public Subscription subscribe(final Map<String, Object> callbacks)
```

**2) Core artifact naming convention**

Should rxjava-core-x.y.x.jar become rxjava-x.y.z.jar since the concept of core+language no longer applies?

I think I'd prefer this:
- rxjava-x.y.z.jar 
- rxjava-groovy-x.y.z.jar 
- rxjava-clojure-x.y.z.jar 
- rxjava-scala-x.y.z.jar 
- rxjava-jruby-x.y.z.jar 
- rxjava-kotlin-x.y.z.jar 
- rxjava-dynamic-x.y.z.jar (object overload for any language)
- rxjava-groovy-clojure-x.y.z.jar (multi-language jar)

Only one of those jars is needed hence the reason why I think the 'core' term is no longer needed as it communicated the fact it was always needed.

Any contrib modules would be: rxjava-contrib-module-name-x.y.x.jar

**3) Dependencies from languages to core still exist**

The build still will result in Maven Central POM files requires rxjava-core from the language version despite that not being the case. Need to eliminate this dependency in the artifact.

---

Implementation notes originally posted at https://github.com/Netflix/RxJava/issues/204#issuecomment-20396621:

After implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities. 

Our goals are:
- support static typing for Java/Scala/Kotlin etc by removing the Object overloads
- support any JVM language, static or dynamically typed
- allow all languages to use the same `rx.Observable` class so that we don't divide libraries with helpers such as `GroovyObservable`, `ClojureObservable` etc that then need to be converted back and forth when doing interop
- do not require special classloaders or agents to enable runtime bytecode generation
- do not remove static operators to enable proxying
- small jars and limited or no dependencies

The solution we have arrived at will work as follows:
- The rxjava-core source code will delete all Object overload methods and be pure static java.
  - Any language that supports functional interfaces directly (such as Java 8 and XTend) can use the Java core version directly.
- Languages needing specific lambda/clojure type mapping to the Func_/Action_ types will have language specific Jars created via build-time bytecode generation.
  - Any method with a Func_/Action_ argument will be overloaded with a version supporting the language requirements.

For example:

The default Java version:

``` java
public static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> predicate)
```

A Groovy version:

``` java
public static <T> Observable<T> filter(Observable<T> that, groovy.lang.Closure predicate)
```
- A jar per language will be created as follows:
  - rxjava-x.y.z.jar 
  - rxjava-groovy-x.y.z.jar 
  - rxjava-clojure-x.y.z.jar 
  - rxjava-scala-x.y.z.jar 
  - rxjava-jruby-x.y.z.jar 
  - rxjava-kotlin-x.y.z.jar 

A project will include just the jar that meets their language needs, there will no longer be a "core" jar plus the language adaptor.

The drawback of this is that mixing two of these in a classpath will result in non-deterministic loading (whichever is loaded last wins) and that is the version that will be used. This means if a library depends on rxjava.jar but is using Groovy and needs rxjava-groovy.jar it is up to the developer of that project to make sure they have only the rxjava-groovy.jar version. This is not ideal but is a one-time pain setting up a build and is better than the constant pain of missing static typing or converting to/from different Observable implementations for different languages.
- At this time we are optimizing for projects using a single language or Java + another language. If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options:
  - include an rxjava-dynamic.jar version that re-adds the Object overloads
  - include build configs for common combinations of languages such as rxjava-groovy-clojure.jar
- Language adaptations (such as clojure which has preferred idioms that necessitate wrapping) will still be possible through the language-adaptor projects and be included in the appropriate language jars.

This should not break any code but will require a slight change to the build dependencies in your project when we release this. 

We hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages.,[RxJava-pull-requests #174](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/174/) SUCCESS
This pull request looks good
 =||= 1.  I don't think I follow your point about making the `subscribe(Map<String, Object>)` method static.  Wouldn't that break all existing scripts that use this method?  Could we add a `subscribe(Map<String, Closure>)` or `subscribe(Map<String, IFn>)` variant in the dynamic JARs?  That would also suggest tightening up the core signature to `subscribe(Map<String, Function>)`.
2.  This naming convention makes sense to me.  I will change rxjava-core to rxjava in the artifact name, at least.  I think I will leave the directory rxjava-core alone, since it makes more sense there, and IMO, it would be confusing to have a dir like `RxJava/rxjava/...`  I don't plan on bringing rxjava-kotlin along with this pull request, but I can review #292 to help fit that into the 0.10 world.  
3.  I think I understand this, though I'm already at the edge of my Gradle ability.  If I'm understanding this correctly, we should not change the build steps for a project - we just need to change the generated Maven POM.  That makes sense - I'll figure out a way to accomplish that.
 =||= Looks good, all in all. I'll try this out with my Scala sample as soon as possible. Thanks for the awesome work!
 =||= Thanks @jmhofer for stepping in to test out these changes.

@mattrjacobs Answers to your questions ...

1) subscribe(Map)

If we leave the `Map<String, Object>` then the `Functions.from` capability needs to keep working.

The other option is we change that to be `Map<String, Function>` as you suggest and then auto-generate the versions for each language.

2) Thanks, and agreed on the directory name, but that can change if we want in the future without impacting the artifact name once you set the name.

3) Maven POM

I think the simplest solution is just not have any "compile" dependencies, only "provided". I believe your Gradle scripts just need to adjust to include provided dependencies, not just compile runtime dependencies and then it will work. I would not try messing with POM files directly. If something is specified as "provided" then it is used for compilation but not included in the POM when pushed to Maven Central.
 =||= [RxJava-pull-requests #175](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/175/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #176](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/176/) FAILURE
Looks like there's a problem with this pull request
 =||= [RxJava-pull-requests #177](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/177/) SUCCESS
This pull request looks good
 =||= Currently, if you publish RxJava to your local Maven repo, you'll find that the rxjava-scala and rxjava-swing POMs include a dependency on "rxjava-core", which doesn't exist anymore as a module, as it was renamed to "rxjava".

Unfortunately, I don't know enough about Gradle to be able to fix this. My guess would be that it's not enough to set the `baseName` of the JAR to just "rxjava". There should be a way to tell gradle that the module is called "rxjava" even though the directory is called "rxjava-core".
 =||= Here's another problem: Excluding "*$UnitTest" from JARs that might be included by Scala will cause the Scala compiler to crash with a Typer error because it expects defined inner classes to exist. This means that at least in `rxjava-swing`, the exclude can't be done.
 =||= I've created a mini-PR against the unit test problem here: https://github.com/benjchristensen/RxJava/pull/1
 =||= I got my little sample (https://github.com/jmhofer/rxjava-samples) working with this PR. The code itself was very easy to adapt. The implicits seem to be working fine. 

One small thing I noticed: The very long names of the implicits are a bit distracting, imho. Should I want to use one of these functions explicitly, I'd prefer shorter names like simply `func1` instead of `scalaFunction1ToRxFunc1`, for example.
 =||= Responses to @jmhofer:
1. POM references to rxjava-core:  In the Scala case, I prefer including all of the core Rx classes directly in the rxjava-scala.jar, so that there is no dependency at all.  This avoids the problem entirely.  For rxjava-swing, I'll work on the Gradle side to make the reference correct.  This might take the form of changing the reference or actually changing the name of rxjava-core to rxjava - we'll see how friendly Gradle is.
2. Excluding inner classes:  I've also come across the Scala compiler error on Classfile parsing with excluded inner classes.  At the moment, unit tests exist in rxjava-core.jar and rxjava-scala.jar only.  Going forward:
   - rxjava-core: These unit tests only exist so that rxjava-scala can be built.  I will exclude them, add a new unfilteredJar Gradle task, and build rxjava-scala off of unfilteredJar.  
   - rxjava-scala: I will continue to include UnitTests, since it's pretty likely that Scala projects are consuming this 
   - rxjava-swing: I hadn't considered the case of Scala consuming this, but you're obviously right.  For now, I'll err on the side of caution and unilaterally add the UnitTests back to the jar.  At some later point, we might want to re-examine (rxjava-swing-scala.jar/rxjava-swing-filtered.jar).  But adding them back is the safe thing to do.  Your PR is exactly what I will do, thanks for that.
3.  Implicit names: In my experience, it's rare that I call implicit conversions by name, but I can see your point.  My only concern is ambiguous namings.  Would changing 'scalaFunction1ToRxFunc1' to 'toRxFunc1' (and other similar naming changes) be satisfying?
 =||= @mattrjacobs: All your suggestions seem sensible to me.

Concerning implicit naming: It may be relatively rare, however using the implicits often leads to your having to specify the parameter types of the closures being implicitely converted, which can be more verbose and confusing than making the conversion explicit and then being able to shorten the closure syntax.

Names like `toRxFunc1` are ok with me, not too long and still unambiguous, sounds like a good compromise.
 =||= [RxJava-pull-requests #181](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/181/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #182](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/182/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #183](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/183/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #188](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/188/) FAILURE
Looks like there's a problem with this pull request
 =||= Replaced by https://github.com/Netflix/RxJava/pull/319
 =||= ,0
7282,310,How to observe perpetually changing Iterable,Hi guys. Can you explain how to observer a perpetually changing Iterable? For instance, here is some code:

``` java
public class ReportConnector {

  private ConcurrentLinkedQueue<String> eventList = new ConcurrentLinkedQueue<String>();
  private Observable<String> observable;

  public ReportConnector() {
    observable = Oberservable.toObservable(eventList);
    observable.subscribe(new Action1<String>() {
      @Override
      public void call(String event) {
        System.out.println("Val sent: "+event);
      }
    });
  }

  public addEvent(String event) {
    eventList.add(event);
  }
}
```

The problem is, the observable immediately calls onComplete in the constructor after adding the subscriber, and then subsequent additions to my linked queue through the addEvent method never get processed by the subscriber. I'm sure I'm missing a big concept here, so any help in pointing me to how to do this correctly would be greatly appreciated. Thanks!,The Oberservable.toObservable(eventList) method captures the current state
of the Iterable, emits it and completes. There is no builti-in mechanism
for observing an Iterable for future changes.

If the source Iterable must exist and can't be wrapped/modified then
something (likely a thread) would need to poll that Iterable for new values
that are then emitted to an Observable via onNext and never call
onCompleted.

If the source Iterable can be wrapped or replaced, I'd make it so whenever
something is offered to the ConcurrentLinkedQueue that it also gets sent to
the Observable onNext. This is obviously far more efficient than polling an
Iterable.

Basically, wherever the events originally come from it is better to capture
that event and push it to the Observable rather than route them through an
Iterable if you can. The Observable.from(Iterable) method is just a bridge
from a snapshot of a List/Collection.

The monitoring approach could theoretically be done with a signature such
as Observable.monitor(Iterable i, Scheduler s) with the Scheduler giving it
the thread to perform the monitoring on.

Ben

On Tue, Jul 23, 2013 at 3:41 PM, Eric Nelson notifications@github.comwrote:

> Hi guys. Can you explain how to observer a perpetually changing Iterable?
> For instance, here is some code:
> 
> public class ReportConnector {
> 
>   private ConcurrentLinkedQueue<String> eventList = new ConcurrentLinkedQueue<String>();
>   private Observable<String> observable;
> 
>   public ReportConnector() {
>     observable = Oberservable.toObservable(eventList);
>     observable.subscribe(new Action1<String>() {
>       @Override
>       public void call(String event) {
>         System.out.println("Val sent: "+event);
>       }
>     });
>   }
> 
>   public addEvent(String event) {
>     eventList.add(event);
>   }}
> 
> The problem is, the observable immediately calls onComplete in the
> constructor after adding the subscriber, and then subsequent additions to
> my linked queue through the addEvent method never get processed by the
> subscriber. I'm sure I'm missing a big concept here, so any help in
> pointing me to how to do this correctly would be greatly appreciated.
> Thanks!
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/310
> .

## 

Ben Christensen - API Team
+1-310-781-5511  @benjchristensen
 =||= You might want to look at the Subject and friends.  A subject is both and observable and observer at the same time.

```
    PublishSubject<String> events = PublishSubject.create();
    events.subscribe(new Action1<String>() {
        @Override
        public void call(String event) {
            System.out.println("Val sent: " + event);
        }
    });
    events.onNext("one");
    events.onNext("two");
```
 =||= Thanks so much for your quick responses. I really appreciate it!
 =||= ,0
7282,317,AndroidScheduler.java,Initial spike for AndroidScheduler.java.

Been using this for quite some time. But I don't like the concept using calling `observer.observeOn(AndroidScheduler.getInstance())` as it sort of puts Android specific stuffs. Should RxJava support some concept of `Schedulers.mainScheduler()`? We can then set the default main schedulers using `Schedulers.setMainScheduler(AndroidScheduler.getInstance())` when app starts.,[RxJava-pull-requests #195](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/195/) FAILURE
Looks like there's a problem with this pull request
 =||= Thanks @prabirshrestha for the submission. Support for Android is something several people will be happy about getting.

Since I don't work with Android I'd like to pull @mustafasezgin into this conversation as he's using RxJava on Android at SoundCloud. Mustafa, can you review, contribute and/or answer questions?

Mustafa gave a presentation that hinted at the use of Schedulers for Android: http://backstage.soundcloud.com/2013/08/responsive-android-applications-with-sane-code/

![android-schedulers-soundcloud](https://f.cloud.github.com/assets/813492/958852/530a5bd4-0470-11e3-88c3-1c0ef2be88f8.png)

I don't like the idea of global settings like Schedulers.setMainScheduler, as libraries would be stepping on each other.

I think something such as the following is a good approach, similar to the `Schedulers` factory class in Rx core:

``` java
AndroidScheduler.MAIN_SCHEDULER
... or ...
AndroidScheduler.mainScheduler()
```
 =||= `AndroidScheduler.mainScheduler()` definitely sounds better then `AndroidScheduler.getInstance()`.

I named the method as `getInstance` so that the AndroidScheduler is similar to the SwingScheduler which uses `getInstance()`. 

I would also need help on writing the gradle build scripts.(Android SDK should also be installed in the CI server)
 =||= Android dependencies should be in a repo such as Maven Central so that someone does not need to configure their environment correctly to build. 

Is this what it needs? 

http://search.maven.org/#artifactdetails%7Ccom.android.tools%7Csdk-common%7C22.1.3%7Cjar

The gradle file will be similar to this: https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-swing/build.gradle

... but you will add this dependency:

```
compile 'com.android.tools:sdk-common:22.1.3'
```

Also add your module to this file: https://github.com/Netflix/RxJava/blob/master/settings.gradle

For example, place this on the 2nd to last line before rxjava-swing:

```
'rxjava-contrib:rxjava-android', \
```
 =||= @benjchristensen happy to help out, @mttkay (from the SoundCloud Android team) will also be valuable to the discussion.

We use the first method outlined by @benjchristensen to set a the main thread scheduler on an observable. The main thread scheduler is similar to the one submitted by @prabirshrestha with the second method being implemented using the `Handler.postDelayed()` method. For consistency with the core package I think the static method approach for the scheduler is more suited in this instance.

@mttkay wrote some helpful components related to fragments which we were also looking to opensource. Maybe we should look to getting that out sooner. @mttkay thoughts?

Also you should only need to add the main android sdk dependency http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22com.google.android%22%20AND%20a%3A%22android%22 using the _provided_ maven scope.
 =||= Thanks @mustafasezgin for getting involved. Nice to know you and @mttkay work together.

Yes, we only need the SDK as a provided not compile dependency. So like this in the build.gradle file:

```
provided 'com.google.android:android:4.1.1.4'
```
 =||= Awesome. I was playing around with Android and RxJava already, too. But I guess for me, it'll be a libgdx integration mostly.
 =||= Hey guys, indeed we have been using a more complete scheduler for a while, one that has an implementation for delayed messages too.

My suggestion is to rename `AndroidScheduler` to `AndroidSchedulers` (plural) since there may be more schedulers to be implemented for Android down the road (like scheduling via AsyncTasks). So we should have:

`AndroidSchedulers.mainThread()`

I'm also missing tests and build integration with this PR. It seems like it's a WIP, maybe we should combine our efforts around this?
 =||= Have a look at the above PR. I've pulled the scheduler component out of our production app code and into rxjava-contrib.

The build should pass, the Scala adaptor seems to be causing trouble though? Seems to neither build on the public CI nor on my local machine. Test execution time is slightly up due to the addition of Robolectric, which goes through a start-up procedure to initialize a fake Android application environment for testing.
 =||= closing in favor of #318
 =||= ,0
7282,319,typesafe-core,Here's another attempt at making rx-core typesafe and still supporting dynamic languages. The previous attempt was https://github.com/Netflix/RxJava/pull/304.  Enough changed (including the 0.10 release) since I submitted #304 that it made more sense to start fresh with this one.  All the comments from that PR still apply, and the 'subscribe on map' issue is now handled.

This will make RxJava completely static by removing all Object overloads (see https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204).

---

Implementation notes originally posted at https://github.com/Netflix/RxJava/issues/204#issuecomment-20396621:

After implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities. 

Our goals are:
- support static typing for Java/Scala/Kotlin etc by removing the Object overloads
- support any JVM language, static or dynamically typed
- allow all languages to use the same `rx.Observable` class so that we don't divide libraries with helpers such as `GroovyObservable`, `ClojureObservable` etc that then need to be converted back and forth when doing interop
- do not require special classloaders or agents to enable runtime bytecode generation
- do not remove static operators to enable proxying
- small jars and limited or no dependencies

The solution we have arrived at will work as follows:
- The rxjava-core source code will delete all Object overload methods and be pure static java.
  - Any language that supports functional interfaces directly (such as Java 8 and XTend) can use the Java core version directly.
- Languages needing specific lambda/clojure type mapping to the Func_/Action_ types will have language specific Jars created via build-time bytecode generation.
  - Any method with a Func_/Action_ argument will be overloaded with a version supporting the language requirements.

For example:

The default Java version:

``` java
public static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> predicate)
```

A Groovy version:

``` java
public static <T> Observable<T> filter(Observable<T> that, groovy.lang.Closure predicate)
```
- A jar per language will be created as follows:
  - rxjava-x.y.z.jar 
  - rxjava-groovy-x.y.z.jar 
  - rxjava-clojure-x.y.z.jar 
  - rxjava-scala-x.y.z.jar 
  - rxjava-jruby-x.y.z.jar 
  - rxjava-kotlin-x.y.z.jar 

A project will include just the jar that meets their language needs, there will no longer be a "core" jar plus the language adaptor.

The drawback of this is that mixing two of these in a classpath will result in non-deterministic loading (whichever is loaded last wins) and that is the version that will be used. This means if a library depends on rxjava.jar but is using Groovy and needs rxjava-groovy.jar it is up to the developer of that project to make sure they have only the rxjava-groovy.jar version. This is not ideal but is a one-time pain setting up a build and is better than the constant pain of missing static typing or converting to/from different Observable implementations for different languages.
- At this time we are optimizing for projects using a single language or Java + another language. If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options:
  - include an rxjava-dynamic.jar version that re-adds the Object overloads
  - include build configs for common combinations of languages such as rxjava-groovy-clojure.jar
- Language adaptations (such as clojure which has preferred idioms that necessitate wrapping) will still be possible through the language-adaptor projects and be included in the appropriate language jars.

This should not break any code but will require a slight change to the build dependencies in your project when we release this. 

We hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages.,[RxJava-pull-requests #201](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/201/) FAILURE
Looks like there's a problem with this pull request
 =||= When trying to build, I get "Could not find property 'ideaProject' on task set." (for `:language-adaptors:rxjava-scala`). What can I do against that?
 =||= Are you building using gradle or gradlew?  gradlew is a wrapper script at
the root of RxJava that allows for consistent builds (pins to gradle 1.6)

For more context on why this is a useful convention, see:
http://www.gradle.org/docs/current/userguide/gradle_wrapper.html

-Matt

On Tue, Aug 20, 2013 at 12:02 AM, Joachim Hofer notifications@github.comwrote:

> When trying to build, I get "Could not find property 'ideaProject' on task
> set." (for :language-adaptors:rxjava-scala). What can I do against that?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/pull/319#issuecomment-22926217
> .
 =||= Thanks, with `gradlew` it works. I simply didn't know about the wrapper script.
 =||= [RxJava-pull-requests #202](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/202/) FAILURE
Looks like there's a problem with this pull request
 =||= Replacing with https://github.com/Netflix/RxJava/pull/323
 =||= ,0
7282,334,Idiomatic Clojure interface,As of RxJava 0.11, the automagic conversion of `IFn` has been removed and, in it's place, there's now a set of functions and macros (`rx.lang.clojure.interop`) to ease interop. It's slightly more tedious, but the API surface area of RxJava has been reduced and it's clearer exactly what's going on now.

That said, using RxJava directly from Clojure still doesn't feel that Clojure-y. Some issues:
- Remembering to use `(rx/fn [])` now instead of just `(fn [])`.
- RxJava predicates, like those passed to `.filter`, must return a `boolean`. Failure to do so results in a `ClassCastException`.
- Argument order isn't consistent with Clojure conventions even though many names are the same
- etc.

This issue is meant to track the addition of a Clojure interface to RxJava that addresses these issues and more. The basic idea is to provide an `rx.core` namespace (I'm open to other suggestions, but I like this since the single-segment `rx` namespace is usually frowned upon in Clojure) that provides observable implementations for all the functions in `clojure.core`, at least where it makes sense. So, for example, `rx.core/map`, unlike `Observable.map` would support multiple sequences and take a plain IFn to apply to them. Similarly, rather than operators, like `Observable.toList`, `rx.core/into` would provide the same, but more powerful, semantics.

Similar namespaces for blocking ops, futures, and other useful stuff would also be included. Also a "raw" namespace will exist that provides wrappers around useful Obesrvable methods that don't have a `clojure.core` counterpart. For example, `Observable.merge` would live here.

A very old sketch of this approach can be seen here: https://github.com/daveray/rx-clj

Since then, we've internally extended these ideas and used them in production. So, the next steps will be for me (@daveray) to get that stuff all updated and tested with 0.11 and submit an initial pull request for review.

Please use this space to offer suggestions, ideas, etc. I've pursued the above approach, but I'm totally open to hearing other ideas for making RxJava easier to use from Clojure.,Is there any way in Clojure to support implicit closure/function coercion against "function interfaces" like Java 8 or Groovy 2.2 (http://docs.codehaus.org/display/GROOVY/2013/07/09/First+beta+of+Groovy+2.2+available)?

However this goes, I would like to see a solution that doesn't require adding new Clojure wrapper code every time a new method/operator is added to the core library.
 =||= Don't know why I didn't think of this, especially since I did a proof of concept of it back before RxJava was called RxJava. At compile time, generate wrapper functions from class/method info. It won't be perfect and will have some of the same problems as Matt's approach, but it will be automated and a nice intermediate step between raw java interop and the more curated approach I suggested above. I'll give it a try and report back. 
 =||= I like the idea of a more idiomatic clojure interface for RxJava. I'm integrating RxJava into some small clojure projects at Rally and would like to help.
 =||= In PR #338, I wrote some kinda messy code to try auto-generating Clojure wrapper functions for RxJava. The basic goal is, as Ben alluded to, something that takes care of `fn -> rx.util.functions.Func` conversion and is auto-generated from RxJava with minimal human intervention. Newly added methods should magically appear in the Clojure wrapper.

If you look at `observable.clj` you can see the invocation which causes the code generation. In `observable_test.clj` is basic usage showing that it actually works.

The problems @mattrjacobs encountered when doing basically the same thing from Java still remain. Figuring out exactly what to do for overloads with the same arity may be tricky. I can write a little "solver" that should be able to insert the right `instanceof` checks to dispatch correctly, at least in most cases. Pathological cases like `Observable.switchDo` where the static and non-static forms are basically indistinguishable when written as normal function application probably can't be solved automatically.

So. Feedback on this approach is encouraged and welcome. I think this would make using rxjava from Clojure mostly idiomatic although I'm still partial to the curated approach outlined above. I like only needing to know one set of sequence manipulation primitives rather than two :) 
 =||= > Pathological cases like Observable.switchDo where the static and non-static forms are basically indistinguishable when written as normal function application probably can't be solved automatically.

Is this the case even when `switchDo` as an instance has no args? I would think it wouldn't apply to this issue in that case.

Note the comment I left in the source code for `switchDo` as one I couldn't decide should be left as a static or removed: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L776

Are there any others you've come across? One of the reasons to remove most of the static methods was to remove duplicate signatures that would confuse dynamic languages (and also reduce API surface area, confusion, etc)
 =||= Well, the instance`switchDo` has no args and the static version has one `Observable` arg. In clojure, the `this` parameter from the instance method moves to the arg list, so they're effectively exactly the same.

Unless the instance version can somehow express the constraint that it only applies to `Observable<Observable<T>>`, I'd stick with just the static version.
 =||= The `switchDo` issue has been fixed by deleting the instance method in version 0.12. It has also been renamed to `switchOnNext`.
 =||= Start of wrapper for discussion: https://github.com/Netflix/RxJava/pull/338
 =||= Anyone want to continue this discussion?

@daveray I know you have for more mature Clojure bindings internally, do you want to close this and re-open a new discussion when you have a pull request ready?
 =||= Closing out ... if and when there is something concrete regarding Clojure improvements please open a new issue or contribute a PR.
 =||= ,0
7282,335,Support for Android events,Hello,

**TL;DR: I want to contribute on Android support**

In the past few weeks I'm become very interested in FRP in general, and how it applies to better wire code in GUI applications - my main interest is to build more elegant Android code.

So, I found that here on RxJava there is an initial code to support run RxJava on Android, which is really awesome! So, I've started to work on some code to try to grasp how to work with Rx.

After that, I want to have some helper methods to transform Android event listeners into RxJava's `Subject`s, so we can really start to make it useful to cleanup our `Activity`/`Fragment` code.

There is something like that waiting to be published? Can I start to draft some implementation? Someone is taking this task and want some help?

@mttkay I saw that you commited on this "area" of the project... are you the person to ask about this stuff?

Thank you all for the attention and sorry about the large message :smile: ,Hi Andrew,

at SoundCloud we're using RxJava on the service layer. With the exception of adapters, which can be hooked up nicely to an Observable exposed by a service object, we haven't given other UI components much thought. The main reason I guess being that there is less to be gained out of it. I see RxJava's main benefits in the reliability and ease gained where asynchronous event composition is required. However, neither seem very likely to me to occur in, say, a TextView or other widgets/UI components. When I say that I suppose I mean RxJava specifically, not FRP in general. ReactiveCocoa for instances takes Rx into the view layer, but it supports heterogeneous signals that can be mapped to view properties, which is very powerful since it allows a view to directly react to state change emitted by an observable sequence. With (Rx)Java one would have to jump through a few hoops to accomplish that.

That's not to say I'm not interested in investigating in that direction! If you have ideas or even some working components already I'd be curious how such a solution could look like. I'll be on vacation for 2 weeks starting Tuesday, so apologies if I reply infrequently.
 =||= That reminds me. Another area where I think RxJava adds benefits and convenience on Android is when used as a simple event bus. Due to its nature it's extremely simple to build application global pub-sub style interaction with Rx. The `Subject` class lends itself well for that, since every system event can be described using a `Subject` to which observers subscribe. I wrote a tiny event bus using a Java enum, in which every enum constant was a Subject. The enum had a `fire` method to signal each event, so that observers would receive it. The data transmitted through the subject could then be an event object. 

That way you can e.g. fan out a state change to multiple views at once. I can see also benefits in this in replacing many occasions where Intents or Handler messages are cumbersome to use.
 =||= @mttkay Thank you for the response and the nice share of experiences :smile: 

My idea with the event support is to remove the logic from `Activity` by creating new objects, in a similar way to `ViewModel`/`Passive Presenter`. So we can write our business logic and test in separation from Android code. Even without any separation, our code becomes much more declarative, and I think that we could have some benefit from this approach.

I will try to put some experimental project online and link here so you can see what I'm talking about.

Thank you again for your attention.
 =||= Hello!

Here is a [short example](https://github.com/andrewhr/rxjava-android-example) of what I'm thinking about with extending RxJava. The implementation of the `Events` and `Properties` is quite naive, but served as a sort of API exploration.

There is anyone who also thinks that this extensions are useful?
 =||= I definitely find this useful. Especially as it can be combined with Scala even for Android development.
 =||= Thanks @jmhofer for the feedback. I will continue to explore in a separate project before making any PR to official project.
 =||= Andrew,

this looks very interesting and in fact I sat down the other day to think
about how this could look like and came up with something very similar.

I was wondering if you guys already use this in production? I would not
like the idea of adding features to the library prematurely, not unless the
code has proven to work in a number of production scenarios.

I will also start to dabble with it when I'm back from vacation, I'm still
traveling for the next 10 days.

Thanks for working on this! It could go a long way in getting
rxjava-android closer to the feature set of ReactiveCocoa.
On Sep 7, 2013 3:02 AM, "Andrew Rosa" notifications@github.com wrote:

> Thanks @jmhofer https://github.com/jmhofer for the feedback. I will
> continue to explore in a separate project before making any PR to official
> project.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/335#issuecomment-23978488
> .
 =||= Hello @mttkay,

Honestly, we don't have any code in production... yet. I'm still trying to get around the concepts. But I agree with you that we need something more _solid_ to put into RxJava itself.

What I've started to do was converting some code from our apps to Rx model, and in the past days I've done for a meaningful amount of the codebase. This is helping me to evaluate and extend the helpers I've published before.

As soon I ship this application I can give more concrete feedback about the experience.

Thank you again for the attention spent here. I really appreciate!
 =||= Sounds good! Looking forward to it
 =||= Hi, @andrewhr, I also think this is very helpful. However, I have one problem about Android events. Most of Android listeners are set via set***Listeners. If some view has already been set a listener, how do you handle it? Override it directly? Or wrap the old listener in a new listener?
 =||= Hi @zsxwing!

Actually, I have only one project in production, which was ported to use the helpers similar to those on the sample project that I shared.

In the current implementation, I found the exact problem that you described. I opted for just override the listeners. The few cases where I need to reuse an observable, I just create a temporary reference for reusing. I though that it's fine because my in this first attempt I only want to experiment with some sort of API (and also want to gain some experience with the tools... this is my first real project with FRP style).

I've never tough about listener overriding before, but I've imagined some kind of Context-like object to create the observers, instead of just using static helpers... so it can keep all references and memoize if necessary. But I'm afraid that it would to some over complication :worried:
 =||= Is work still happening on this issue? 
 =||= Closing out as this thread has gone quiet ... please re-open or start something new if applicable.

The RxJava Google Groups is a good place for discussion as well: https://groups.google.com/forum/#!forum/rxjava
 =||= ,0
7282,337,Added the window() operation.,window() returns an Observable<Observable<T>> that will chunk the source observable
based on several criteria; counts, time etc.

This differs from buffer() in that the underlying observables will all onComplete()
independently from their upstream Observable.,[RxJava-pull-requests #224](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/224/) SUCCESS
This pull request looks good
 =||= For consistency with `buffer` it seems like all the `Observable.window` methods should be instance methods rather than static.
 =||= ok. Missed it when porting into 0.11.1

I've forced-pushed my amended commit.
 =||= [RxJava-pull-requests #225](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/225/) SUCCESS
This pull request looks good
 =||= Now documented on the wiki (marble diagrams TBD):

https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window
 =||= Let's switch over to https://github.com/Netflix/RxJava/pull/349 for review as this pull request is out-of-date with master.
 =||= ,0
7282,320,JRuby examples don't work (JRuby picks the wrong overloaded method),The JRuby adapter doesn't work because JRuby can't figure out which overloaded `Observable#subscribe` method to pick. It ends up picking `Observable#subscribe(Map<String, Object>)`, which raises an error because the argument doesn't respond right:

``` ruby
require 'rxjava-core-0.10.0.jar'
require 'rxjava-jruby-0.10.0.jar'

observable = Java::Rx::Observable.toObservable(['one', 'two', 'three'])
observable.take(2).subscribe(lambda { |x| puts x })
```

the code above prints the following errors in JRuby 1.7.4:

```
% ruby rxjava.rb
rxjava.rb:6 warning: ambiguous Java methods found, using subscribe(java.util.Map)
onNext
Observable.java:278:in `subscribe': java.lang.RuntimeException: 'onNext' key must contain an implementation
    from NativeMethodAccessorImpl.java:-2:in `invoke0'
    from NativeMethodAccessorImpl.java:57:in `invoke'
    from DelegatingMethodAccessorImpl.java:43:in `invoke'
    from Method.java:601:in `invoke'
    from JavaMethod.java:455:in `invokeDirectWithExceptionHandling'
    from JavaMethod.java:316:in `invokeDirect'
    from InstanceMethodInvoker.java:61:in `call'
    from MethodHandle.java:599:in `invokeWithArguments'
    from InvocationLinker.java:153:in `invocationFallback'
    from rxjava.rb:5:in `__file__'
    from rxjava.rb:-1:in `load'
    from Ruby.java:807:in `runScript'
    from Ruby.java:800:in `runScript'
    from Ruby.java:669:in `runNormally'
    from Ruby.java:518:in `runFromMain'
    from Main.java:390:in `doRunFromMain'
    from Main.java:279:in `internalRun'
    from Main.java:221:in `run'
    from Main.java:201:in `main'
```

in JRuby 1.6.8 it prints a less verbose version of the same error.

Notice the line which reads "onNext". That's actually the `puts` from `lambda { |x| puts x }` in action. JRuby wraps the lambda in something that looks like a `Map`, and then when RxJava calls `get` on that map JRuby calls `call` on the lambda.

So if you modify the example code to read `lambda { |x| lambda { |y| puts y } }` this is what happens:

```
% ruby rxjava.rb
rxjava.rb:6 warning: ambiguous Java methods found, using subscribe(java.util.Map)
RxJava => Could not find function language adaptor: Groovy with path: rx.lang.groovy.GroovyAdaptor
RxJava => Successfully loaded function language adaptor: JRuby with path: rx.lang.jruby.JRubyAdaptor
RxJava => Could not find function language adaptor: Clojure with path: rx.lang.clojure.ClojureAdaptor
RxJava => Could not find function language adaptor: Scala with path: rx.lang.scala.ScalaAdaptor
one
two
```

Which kind of works, but it's not as smooth as the ideal API would be:

``` ruby
observable.subscribe { |x| puts x }
```

But that would probably require a real JRuby native extension (if I get the time I'll send you a pull request with one).,Glad to have you involved, we haven't had much use of JRuby (that I'm aware of) so I'm not surprised we have some issues. I would appreciate your involvement.

Can you check out code from this pull request (https://github.com/Netflix/RxJava/pull/319), build the rxjava-jruby jar and try it? We are working on a very different approach in this pull request for language adaptors that is statically typed.

As for the `subscribe(Map)` overload ... I'm not thrilled by that one and it has caused other issues. I've considered getting rid of it before we hit 1.0, but I know it's used in a variety of places so haven't pulled that trigger.
 =||= It works better, but not perfect. JRuby seems to pick a working overload, but it still warns about there being multiple overloads (which is hard to fix without adding JRuby-metadata to the `Observable` class).

An upside is that you can skip the `lambda { ... }` and use the more Ruby-ish: `obs.subscribe { |x| puts x }` (i.e. pass a block to `#subscribe`).

Since there will be a version generated to work specially for JRuby, how much can the code generation things add? Ideally it would add JRuby metadata to the class to make it work as a JRuby native extension. Can you give me any hints on how to dig into that? Where should I start to look in the code to understand the code generation?
 =||= If the generated `Observable` could be something like this (but lots more, obviously), it could integrate with JRuby even better:

``` ruby
@JRubyClass(name="Rx::Observable")
public class Observable<T> extends RubyObject {
    @JRubyMethod(meta = true, rest = true)
    public static <T> Observable<T> from(ThreadContext ctx, IRubyObject receiver, IRubyObject[] args) {
        // ...
    }

    @JRubyMethod(name = "subscribe")
    public IRubyObject subscribeRuby(ThreadContext ctx, Block block) {
        // ...
    }
```

There would be some more code needed that registered the class with the runtime, and created the `Rx` module, and some more things, but that wouldn't need to be generated.
 =||= Can you take a look at pull request https://github.com/Netflix/RxJava/pull/323 and suggest how to re-add JRuby support correctly? We have decided against doing byte-code generation.

We can not add anything (such as the annotations in your example) to rxjava-core, it needs to be in a separate submodule, similar to Groovy, Scala and Clojure. So this means using something like extension methods, implicits, or other such tools if JRuby supports them. 
 =||= I will have a look.
 =||= With some small patches at least some of the basics work:

``` ruby
require 'rxjava-core/build/libs/rxjava-0.10.1-SNAPSHOT.jar'

class Java::Rx::Observable
  java_alias :subscribe, :subscribe, [Java::RxUtilFunctions::Action1.java_class]
end

module Rx
  include_package 'rx'
end

o = Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

I haven't tested any more than that, but it looks like it could work.
 =||= #323 should be `0.11.0-SNAPSHOT` afaik, not `0.10.1-SNAPSHOT`. Are you sure you're using the correct version of RxJava?
 =||= Good catch, I'm not used to gradle, or even having to compile stuff, so I didn't clean up from the last build I did so the old jars were still around. 

The Ruby patch works with 0.11.0 too (which means that those small patches would have make the old version work too, so that's good to know). Without the patch it works as with #319, the code runs but it prints a warning about not finding the right overloaded method.

The boring part of doing it this way is that each method on Observable, and any other classes needed for interoperability will need to be annotated with `java_alias`. On the other hand I don't see any other way of doing it which wouldn't involve writing even more code.
 =||= Does JRuby have a way to apply these aliases programmatically? For example, in Groovy we use reflection to determine all methods that need extensions and then programmatically create all of the `MetaMethod` implementations to bridge Groovy and Java. You can see an example here: https://github.com/mattrjacobs/RxJava/blob/8c87c29bea5e076bdc4202af5626d474ab1c7117/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/RxGroovyExtensionModule.java#L103

Otherwise every time a new method is added to core someone will have to maintain the JRuby java_alias mappings.
 =||= Maybe, I'm not sure, I'll have to look into more about how JRuby's native extensions work. So far I've only done it by creating classes and adding metadata, but I guess that it should be possible to do it on existing classes to somehow.

If I understand the code you linked to correctly it's looking through the `Observable` and `BlockingObservable` classes for methods that take subclasses of `Function` and somehow makes the Groovy runtime prefer those over any other overloads. That's what would be needed for JRuby too, and since the Groovy version just uses Java reflection to do it I think it should be possible in JRuby too. 

All that the `java_alias` thing does is that it looks up a Java method by reflection and adds that method into a cache that JRuby will look in before it looks at the Java class, which is kind of similar to what the Groovy extension thing does, I think.

So, yes, probably, maybe, hopefully, but I'm not sure exactly how right now.
 =||= This isn't complete yet, but here's a first pass at an implementation I think will work. @benjchristensen can you take a look and let me know if this is the direction you're looking for? It's largely cribbed from the Groovy implementation.

https://github.com/ragalie/RxJava/commit/fc0a706faaa27d1d797cfb8c43080a3b68e1cb1f
 =||= I'm getting warnings about overloads.

This is my code:

``` ruby
require 'rxjava-core/build/libs/rxjava-core-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/build/libs/language-adaptors-0.14.2-SNAPSHOT-sources.jar'

module Rx
  include_package 'rx'
end

o = Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

and this is the output (JRuby 1.7.4):

```
rxjava.rb:14 warning: ambiguous Java methods found, using subscribe(rx.util.functions.Action1)
2
4
6
```
 =||= Just to be clear, the commit I posted doesn't work yet. I just want to make sure that the approach is sane before investing more time in it. 
 =||= Ok. Yeah, it might work.

Not sure how well the generated methods will work, though: they are added on the classes, but call `super` to call the original method, but I'm not sure that `super` is actually what you think it is (it might be, I assume you've run the code, and I have not, so I could be completely wrong). In other words, you're adding a method on `Observable`, and then you call `super` in that method to call the original method on `Observable`, but that should call a method on the superclass of `Observable`, not the original method -- unless JRuby tries to be clever and figures out that your added method is on the eigenclass and `super` should refer to `Observable`, but I don't think it does.

And either way, once you call `super` JRuby still has to look up the right Java method to call, and it doesn't have any more type information to do it, so it will pick one at random and print out the "ambiguous Java methods found" warning. Even if you've wrapped the proc in an `Action` I'm not sure that JRuby will pick the right overloaded method. In my experience it tries, but it doesn't always succeed in picking the right method.

I think a better way to solve the problem is to use `java_alias` as in one of my examples above. That way JRuby will always pick the right overload. I'm not sure all the wrapper classes would be needed in that case, because JRuby will wrap a proc in a proxy class that implements whatever interface is required (and since `Function` and `Action` interfaces only really have one method, that also just happens to map straight to interface of proc, I think letting JRuby do it makes sense). There might be a slight performance loss from letting JRuby generate proxies instead of having Java classes, but I think it's greatly outweighted by skipping a large part of the work that JRuby otherwise would have done in finding the right overload.
 =||= You're right, the `super` approach won't work.

I tried the `java_alias` approach first and the problem I ran into is that it didn't seem to work correctly when a method had multiple signatures with the same number of arguments. For instance, I tested it with RxJava 0.10 which has `subscribe(Hash)` and `subscribe(Action1)` (or something like that). I tried just running `java_alias` on the methods that had `Function` arguments and it threw an error when I tried to use the `Hash` argument. I tried running `java_alias` on all methods, but running it first on the non-function methods and second on the function methods and that didn't work either (threw an error with a `Hash` argument).

I'm a relative newbie at JRuby, so totally possible I'm doing something wrong. But from my basic understanding I don't understand how `java_alias` will be a solution if there are two signatures with the same number of arguments and we want to allow access to both of them.
 =||= I spent some more time researching this evening and I think the easiest path forward is to leverage the JRuby method dispatching as much as possible. Outside of the `Proc` => `Action`/`OnSubscribeFunc`/`Function` casts, which we can reliably do but which the JRuby dispatch logic is having trouble reliably doing, the default dispatch logic is likely to be far better at sussing out the method signature we want to invoke than we would be.

The first thing the dispatch logic checks for when trying to find a method signature match is whether the Java class of the argument provided is an exact match with the parameter type specified in the method signature (see: https://github.com/jruby/jruby/blob/master/core/src/main/java/org/jruby/java/dispatch/CallableSelector.java#L321). While it isn't guaranteed that this will always be true (JRuby could change the dispatch logic), I think it's a safe bet that it will continue to preference exact class matches when selecting overloads. I think that means that as long as we pass in arguments that implement the exact interfaces JRuby should have a much easier time finding the matching method signature.

Assuming that's true, I think we should implement an algorithm like the following on load:
- Select the methods that have any signatures that contain a parameter type that is a (sub)interface of `rx.util.functions.Function`
- Determine the (sub)interfaces of `Function` that are possibilities for each argument position for a given method.
- If any given argument position has more than one possibility (e.g. `Action1` or `Action0`), ignore.
- If any given argument position has only one possibility, then note that we should convert any `Proc` we see in that argument position into the `Function` subclass we've identified.

Then I think we should implement the following to occur at runtime:
- Upon invoking a method where we've noted that we should convert `Proc`s, replace the `Proc` arguments with wrappers that implements the noted interfaces, if applicable.
- Call the original Ruby method with the modified arguments.

We should be able to do this using `alias_method` to copy the original `subscribe`, for instance, to `subscribe_without_argument_wrapping` and then redefine `subscribe` to modify the arguments and call `subscribe_without_argument_wrapping` with the updated arguments.

Under this scenario most of the hard dispatch logic remains in Java: the only additional runtime things we're doing in Ruby are a) a check to see if the argument is a `Proc`, b) a Hash lookup to see whether we can replace the `Proc` with a wrapper and c) instantiating the Java wrapper. So I don't think it should significantly slow things down.

It's clear you've thought about this quite a bit @iconara; anything stick out to you as suspect here?
 =||= It isn't the cleanest thing in the world, but https://github.com/ragalie/RxJava/commit/957af11bb7e843e79e72a7559a7c0c8a24052e35 seems to be working correctly.

This code no longer causes an ambiguous method warning:

``` ruby
require 'rxjava-core/build/libs/rxjava-core-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/rxjava-jruby/build/libs/rxjava-jruby-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/rxjava-jruby/src/main/ruby/rx/lang/jruby/interop'

o = Java::Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

I'm going to clean it up as best as I can then open a PR. I'm pretty new to JRuby, though, and I'm sure there are some ways to simplify what I've done, so hopefully someone can help me out with that. In particular I'd love to be able to leverage the built-in JRuby proxying (telling it which interface to proxy) instead of the clunky ones in the commit.

I also don't know what to do with the Ruby code. Should that stay in the JAR and just need to be required manually? Or should it be pulled out to a gem? I'm not sure what's idiomatic.

Thanks!
 =||= @ragalie I'm sure it can be done more elegantly, but it would take a lot of time, and I don't know very much more about the details of JRuby's Java integration to say for sure how to do it. It's better to get something that works and improve it later than trying to find the optimal solution now.

There's a way to package a JAR that makes JRuby run code when it is require'd from Ruby code. You need to stick a special class at the root of the JAR (here's an example: https://github.com/iconara/msgpack-jruby/blob/master/ext/java/MsgpackJrubyService.java). It's used to load JRuby native extensions (i.e. Java code that creates JRuby modules and classes), but in this case it could be used to automatically run the interop code (which can be loaded from within the JAR).

Another option would be to make the the interop code the main entrypoint for Ruby, and for it to load `rxjava-core.jar` and `rxjava-jruby.jar`. Come to think of it, that would be the better solution.

The benefit of the former solution would be that you could ship it all as just the JAR, but the latter is simpler to maintain and is how many JRuby wrappers for Java libraries work.

If it's ever going to get any kind of adoption in the Ruby world the library must be packaged as a gem.
 =||= I implemented JRuby support in #422. Let me know what you all think and if there's anything that doesn't seem to be working correctly. Thanks!
 =||= Awesome @ragalie! I'm taking a look now and will merge it into master or iterate with you on it if there are changes needed.
 =||= ,0
7282,336,Idiomatic Scala Support,As of version 0.11.0 Scala support is provided through the use of implicits. Conversations on Twitter are bringing up other possible improvements. Let's use this issue to discuss.  ,A few comments from my point of view (since I first looked at this project, I always wanted to use it from Scala):

Now that the core is typesafe, imho we have the first workable Scala integration (via implicits). From here on, everthing depends on how much effort we want to put into this vs how convenient it will be for the users.

What we already have is that the most important method names match (`map`, `flatMap`, `filter`). Matt also made Scala for-comprehensions work with observables.

There's a lot of room for improvements, though. It seems that due to Scala-Java interop, there are problems with type inference (I even ran into a Scala compiler crash somewhere), and sometimes `asJava` collection conversions are necessary. Also, Scala/Akka futures are not yet addressed at all. An Akka-specific scheduler would probably be awesome to have, too.

For full Scala user convenience, we'd probably have to completely wrap `rx.Observable` into its own `rx.scala.Observable`. This would mean a lot more maintenance effort for the Scala integration, of course (I don't think we can do this automatically via code generation or macros, but I'm no expert of all that). But still, I think it's well worth it to create a dedicated Scala API.
 =||= 1) Implicit-based integration with Java-based observables has a serious flaw as it doesn't support parameter type inference for lambdas. The situation isn't going to change until https://issues.scala-lang.org/browse/SI-6221 is fixed. It's definitely fixed in 2.11, and at EPFL we have a compiler plugin that backports the fix to 2.10. Probably Typesafe folks can be convinced to do the backport in one of 2.10.x releases (/cc @adriaanm @gkossakowski @retronym @JamesIry).

2) Some features that might be desirable in `rx.scala.Observable`: a) native function types, b) native collections, c) method names familiar to folks that use native collections, d) making parameter of `defer` by-name, e) creation of Observables via `apply` rather than via `from`.

3) I also don't think that macros can help with `rx.scala.Observable`, because what you're probably after isn't just a copy/paste of a Java API, but rather a redesign that takes Scala features into account. But if there are some things that can be autogenerated, I'll be happy to answer questions about how macros work and how they can be used.
 =||= IMHO, after looking at the code, using implicits convertions is not a good idea.

I think you have better to start with a complete wrapper of the API, then you'll be able to apply scala idiom (basically writing a DSL) instead of having a Java API with some facilities for converting type.

And that way you don't have to wait for https://issues.scala-lang.org/browse/SI-6221 ... which sounds anyway like a clumsy integration of Java API to me.
 =||= Here is some [background](https://github.com/Netflix/RxJava/issues/204#issuecomment-15249648) on why the current design was chosen rather than having each language with a separate version of Observable:

---

The approach of having language specific packages/classes was pursued but did not work well because Rx is a composable library. It means that every time an `Observable` is used it needs to be re-wrapped or un-wrapped by whichever language is using it.

For example ...

From Java a library is exposed that has a method like this:

``` java
rx.Observable getData()
```

From Groovy a library is exposed with a method like:

``` java
rx.groovy.GroovyObservable getOtherData()
```

Then from Scala you need to wrap them again:

``` java
rx.scala.ScalaObservable.from(getOtherData())
```

This means we have an `rx.Observable` wrapped as `rx.groovy.GroovyObservable` wrapped as `rx.scala.ScalaObservable`.

To compose the two we would have:

``` java
rx.scala.ScalaObservable.zip(rx.scala.ScalaObservable.from(
      getOtherData()), 
      rx.scala.ScalaObservable.from(getData()),
       ... scala closure here ...);
```

Now what does `ScalaObservable` return from its operators? `ScalaObservable` or `Observable`?

Should the above zip operator return `rx.scala.ScalaObservable` or `rx.Observable`? What happens if this library is consumed from another language?

If `Observable` each step along the way it must be wrapped yet again. If `ScalaObservable` it has now changed all of the return types of `rx.Observable` to a subtype.

In short, for interop between languages it very quickly becomes a mess and our primary polyglot goal was that `rx.Observable` was usable across all libraries as the single type and because the whole point of Rx is chained composition it's not as simple as just a single decoration at the beginning. It affects every single method in an API and step of the chaining.

For this reason we chose the current language-adaptor model so `rx.Observable` can remain the sole public interface across languages.
 =||= Thanks for providing the design notes!

I wonder though how often people tend to mix languages in their projects. Usability improvements in switching from a Java-based least common denominator to an idiomatic API might be significant. Does being polyglot overweigh these improvements?
 =||= I'm not sure if wrapping `Observable` for Scala (not in a subclass though) would really hurt so much. Imho it's worth a try to find out how it feels. There will be a lot of wrapping and unwrapping behind the scene though, I'm afraid.
 =||= At Netflix we are using Clojure, Groovy, Java and Scala and I know of apps running code from at least 3 of those 4 in the same JVM instance. I imagine it's not common in most environment for this type of diversity, but it is something we have wanted to support as seamlessly as possible. This is because we have wanted the `rx.Observable` to act as the interface we can expose across module boundaries as it naturally ends up at the edge of the API in methods such as `Observable<T> getDataFromService(args)`. This is part of what drove us to target the JVM with RxJava and not any specific language.

That said, an idiomatic solution that works best for pure Scala apps is more important. If we can find a solution that can retain the use of `rx.Observable` without a completely separate wrapper then great, otherwise let's have a `ScalaObservable` for pure Scala apps and a way of going back and forth across language boundaries when it's needed. Perhaps the implicits that exist right now can solve the immediate interop needs for easy interaction from Scala to Java, but the option to convert to `ScalaObservable` would also be there.

Another piece of information to guide this ... the Rx.Net version in C# is defined by simple interfaces for `Observer` and `Observable` without any of the operator interfaces on them. All of the operator methods (static and instance level) are added via extension methods. It's quite clean and makes the interfaces more flexible (anyone can easily implement them and the extension methods are 'just there' without inheritance involved).

The reason RxJava has `Observable` as a concrete class is because extension methods don't exist in Java so we don't have a choice but to have them as concrete methods to enable the fluent chaining pattern.

In Scala however we do have extension methods (implicits), macros etc that theoretically can allow the `rx.Observable` to be made into whatever it needs to be for idiomatic Scala usage, similar to how C# implements Rx.Net using extension methods. I imagine a possible issue is if existing methods on `rx.Observable` are in the way and cause problems in achieving idiomatic Scala functionality, if that's the case I'd like to understand what those issues are and if they can be resolved and if not if they really are deal breakers.

At this point I become not so helpful as I am not skilled enough in Scala to have a valid opinion or guide the conversation much further. I do have some questions though for the Scala experts here:

1) What would make `rx.Observable` idiomatic for Scala?

I'd like to see unit tests or sample code demonstrating expected behavior and usage so that we're all working towards the same goal and know when we've achieved success.

2) What about the current `rx.Observable` + Scala implicits is not working well?

3) What requirements of (1) can not be achieved with implicits and macros and requires a separate concrete class as a wrapper?

Thank you everyone for your involvement, I really do want us to find the ideal solution for Scala and then as a secondary priority make it work well across the JVM for polyglot applications.
 =||= Thank you for your swift feedback! It's a pleasure to help.

1) I'm not an Rx expert, and in fact this is the first time I see any Rx code apart from random snippets in web articles, so please don't treat this list as definitive. Comprehensive analysis would require quite some time, and I'm not sure I have it right now.

a) `Observable.from` could be replaced by `Observable.apply`, so that one can write `Observable(1, 2, 3)` instead of `Observable.from(1, 2, 3)`.

b) It shouldn't be necessary to write `asJava`, e.g. as in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L349, and `asScala` (not sure whether it's necessary now).

c) Use of mutable collections in situations like https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L350 is really inconsistent with Scala's pursuit of immutability. I wonder whether it'd be possible to write such code in a functional way.

d) Instead of taking a no-arg function, `Observable.defer` could take a by-name parameter, which would obviate the need of creating an explicit closure: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L232.

e) For a former C# developer like me, method names like `lastOrDefault` sound familiar, but for the Scala croud out there - not so much. How about changing the names and maybe even signatures, so that they mirror method names of native collections? E.g. `lastOrDefault` could become `lastOption` (also note the change from default values to options).

f) I'm also not sure whether extension methods are even necessary. From what I would guess, in C# they are forced to use them, because interfaces can't define methods with implementations (at least, that was the story with `IEnumerable` and `Enumerable`). In Scala, we can do that, so why not just put all the combinators in `Observable`?

g) `mapMany` in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L351 is essentially `flatMap`, right?

h) No idea how this name could be stated more succinctly, but `toBlockingObservable` feels a bit verbose. When I moved from C# to Scala, in people's code I felt an overall tendency to compress everything, including names. This is kind of a vague observation, so feel free to ignore it.

2) Function literals don't support inference for parameter types unless they are used in a context that requires a Scala native function type. In particular, inference won't work if function literals are supposed to be converted to something implicitly. 

E.g. in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L341 one can't drop type annotations for lambda parameters. I tried removing them and got a compilation error. (Btw why are you using 2.10.1, when 2.10.2 is already available for quite long? Did you have any problems with it?)

That's an instance of https://issues.scala-lang.org/browse/SI-6221, which has been fixed in 2.11 and probably could be backported to 2.10. If you're in need of an immediate solution, we at EPFL have a compiler plugin for 2.10 that provides a backport.
 =||= Excellent observations about the API @xeno-by. Currently, we are preparing exercises for the Coursera class [Principles of Reactive Programming](https://www.coursera.org/course/reactive). For this course we would like to make an idiomatic Scala API. @samuelgruetter is working on that. 

The cross language compatibility pointed out by @benjchristensen is a reasonable concern. However, I think there is a lot of monolingual projects out there that would greatly benefit from the idiomatic Scala library. It seems to me that  adding a Scala wrapper can be only a plus in those cases. 

For polyglot projects we could also take the Java rx.Observable as a common ground (being a return type of each operation and in API signatures). Then all of the Scala support can be added by an implicit conversion (rx.Observable => rx.ScalaObservable). 

As a long-shot maybe the interface for multi and mono lingual projects can be unified so that we do not repeat our selves. IMHO it is worth a try. 
 =||= Thanks for all the observations! I'll try to address some of the ones from @xeno-by.

1a), 1e) and 1g) are just aliasing problems, imho. We already have `flatMap` as alias for `mapMany`, and the other aliases could easily be added, either directly in `rx.Observable`, or in a Scala wrapper, if the namespace gets too big otherwise (not my preferred solution). Methods returning options will have to live in a Scala wrapper, however.

I didn't take a look at 1b) and collection conversions yet. This really shouldn't be necessary often, if at all.

1c) You're looking at test code here which tests the callback "at the end of the world". This is not really normal usage of the API. The whole RxJava codebase is refreshingly (though not completely) free of mutability, if you ask me. Also, the Rx API is actually there to allow you to handle all your events in a functional, immutable way. - In short, I don't see a problem here.

1d) is Scala-specific. By-name parameters are a great feature for methods like `defer`, I agree. We should make use of them in the Scala wrapper.

I'm not worried about 1f) either.

1h) I like the verbose name in this specific case. Imho, it's the same as `asInstanceOf` in Scala: Maybe I'm evil, but I like to punish people who do things they probably shouldn't do. :) Ok, there will of course be valid use cases for blocking observables, but there shouldn't be too many of them, hopefully.

2) is quite a big problem, if you ask me. A backport of the fix to Scala 2.10 would be great. We can probably get around this with a dedicated Scala wrapper, though.

And the reason for 2.10.1 instead of 2.10.2 is currently just a technical problem with the build system. I, too, hope that this will be fixed soon.
 =||= 1c) Even that can be made functional if you replace the subscribe() with .toList().toBlockingObservable().single();
 =||= @abersnaze You're right, good point.

I started a little experiment with a more idiomatic Scala wrapper. It's just humble beginnings currently, though. You can find it [here](https://github.com/jmhofer/RxJava/blob/scala-wrapper/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala). 

Comments and forks are welcome, of course. I started from the super-extends pull request in order to check how this whole thing feels in Scala.
 =||= Scala 2.10.2 support was added in version 0.11.2 (https://github.com/Netflix/RxJava/releases/tag/0.11.2).
 =||= > 1) Implicit-based integration with Java-based observables has a serious flaw as it doesn't support parameter type inference for lambdas. The situation isn't going to change until https://issues.scala-lang.org/browse/SI-6221 is fixed. It's definitely fixed in 2.11, and at EPFL we have a compiler plugin that backports the fix to 2.10. Probably Typesafe folks can be convinced to do the backport in one of 2.10.x releases (/cc @adriaanm @gkossakowski @retronym @JamesIry).

Sorry, we don't change type inference in minor versions unless there's a critical bug.
The risk of regression in source compatibility is too high.
 =||= > The cross language compatibility pointed out by @benjchristensen is a reasonable concern. However, I think there is a lot of monolingual projects out there that would greatly benefit from the idiomatic Scala library. It seems to me that adding a Scala wrapper can be only a plus in those cases.

I completely agree if a wrapper is the only way to achieve idiomatic support. Monolingual projects should take first priority as that is the common case.
 =||= We believe that the following solution would be best:
-   Implicit value class (let's call it `ScalaObservable` for the moment) wrapping an rx.Observable
-   all return types are `rx.Observable`
-   Since `ScalaObservable` is a value class, there is no runtime overhead for the wrapping (some explanations can be found in the second half of this [blog post](http://www.blog.project13.pl/index.php/coding/1769/scala-2-10-and-why-you-will-love-implicit-value-classes/)). This is new in Scala 2.10, and actually allows us to have extension methods similar to C#.
-   An object `FunctionConversions` containing all implicit conversions from Scala functions to Rx functions (the same as in the present [Scala adaptor](https://github.com/Netflix/RxJava/blob/rxjava-0.11.1/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L29)). These conversions are only used by the adapter, users of Scala Rx won't use them.
-   All instance methods of `rx.Observable` which take a Func or an Action have a wrapper method in `ScalaObservable` whose signature has Scala functions and whose body uses the conversions from `FunctionConversions`
-   `ScalaObservable` has map, flatMap, filter, like in the [present adaptor](https://github.com/Netflix/RxJava/blob/rxjava-0.11.1/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L108) to enable for comprehensions
-   `ScalaObservable` has `lastOption` method instead of `lastOrDefault` etc
-   functions passed by Rx Scala users to Observable needn't be implicitly converted, so we're not affected by the [bug](https://issues.scala-lang.org/browse/SI-6221) that parameter type inference of implicitly converted functions does not work in Scala 2.10
-   An `object Observable` with `apply` methods instead of `from` and `create`
-   polyglot projects can also use this approach

I've started to implement such an adapter and will post some code soon.

Note that I've not (yet) addressed the following points:
-   compatibility with Scala/Akka futures
-   how to integrate `ScalaObservable` with Scala collections to get all methods of Scala's [Traversable](http://www.scala-lang.org/api/current/index.html#scala.collection.Traversable)
 =||= @samuelgruetter Sounds awesome! Very much looking forward to your sharing the code.
 =||= You can see what I'm doing [here](https://github.com/samuelgruetter/rx-playground/blob/master/RxScalaAdapter/src/main/scala/ScalaAdapter.scala). Note that it's still very incomplete and not yet tested, but work is in progress.
 =||= Great, thanks! I'll play around with it, too.
 =||= @samuelgruetter All of that sounds great.  I'll take a look next week and offer feedback.
 =||= There's an interesting problem with `map`: If I add an explicit conversion like `ScalaObservable(numbers).map(...)`, it works, but without, i.e. `numbers.map(...)` gives an error... I'll investigate on this. You can see the corresponding test [here](https://github.com/samuelgruetter/rx-playground/blob/365a7ba8afa4feda1f5961a3a21c524092caf8f4/RxScalaAdapter/src/main/scala/rx/lang/scala/Adaptor.scala#L497)
 =||= Maybe there's a 2nd implicit somewhere, adding map?
 =||= @samuelgruetter what is the error? if @jmhofer is right you should have an `amibgous` implicit resolution error.
 =||= If anything about the core Java library is causing issues let me know.
 =||= There's no 2nd implicit, but there's a second `map`: The `map` in rx.Observable. And scalac wants to use this one and does not convert to `ScalaObservable`. However, with `reduce`, it works...
 =||= Just another guess, but then it's maybe due to the type parameter of `map` (your `reduce` doesn't have one; you renamed the one with type parameter to `fold` which luckily avoids the problem).
 =||= Covariant support has been merged into master. This also changes the type used with `Observable.create`.
 =||= I believe all of the structural changes are now merged to master. Are there any other changes that should be made before we release 0.12 so as to better support Scala integration?
 =||= I've isolated the implicit conversion problem [here](https://github.com/samuelgruetter/rx-playground/blob/master/ScalaImplicitsProblem/src/main/scala/ScalaImplicitsProblem.scala). It's a problem with the Scala compiler.
@benjchristensen looking forward to a jar with covariant observables!
 =||= @samuelgruetter I'm pretty sure no one could make the scala compiler be able to solve an ambiguity like that one.

If you where the compiler, which method you think should be choosed?

You guys should seriously consider implementing a full wrapped scala version first, and keep multi-lang support as a cherry on cake.

IMHO it's a mistake to do the opposite, maybe I'm wrong but I think most scala user will want to use it in a full scala project.

And for the course, it would be good to have an idiomatic API.
 =||= scalac is indeed inconsistent, it goes the extra mile to try an implicit view when the originally tried method is monomorphic, but doesn't do the same if it is polymorphic.

That's unlikely to change soon, even in 2.11.

But, one change that is likely in the 2.11 timeframe is first class support of SAM types, which would let you write an anonymous function that would be translated to `rx.Func1`.

BTW, it's really great to see this discussion and cooperation happening!
 =||= So, to make polymorphic methods like `map` work, we'd have to return ScalaObservables, not (Java)Observables everywhere, I guess (which doesn't pose a problem anyway as far as I can see)?

@aloiscochard: Is that what you mean by "a full wrapped scala version"? - Because I thought that @samuelgruetter's goal was already to create a full wrapped scala version.
 =||= @jmhofer yeah it's exactly what I meant :-)

By doing that you'll be able to provide the best possible syntax for RX API, looking forward next enhancement!
 =||= @samuelgruetter is there something we can do in the short-term to work around this issue? Is there anything about the core library that if changed would simplify this effort?

@aloiscochard What about the approach being pursued (if the compiler bugs didn't exist) is a mistake?
 =||= @benjchristensen I don't see any problem with switching to the approach where we stay with intermediate ScalaObservables throughout the wrapper. As `ScalaObservable` is a value class, it shouldn't even impact performance at all.
 =||= I agree with @jmhofer. I've started such a Scala Observable which always returns Scala Observable, see [here](https://github.com/samuelgruetter/rx-playground/blob/master/RxScalaAdapter/src/main/scala/rx/lang/scala/Observable.scala)
 =||= @benjchristensen I would say it's kind of bad design, a form of overloading abuse. I would go the type-class way (on a similar Wrapper than @jmhofer one) to make a map function polymorphic.

Anyway, the current approach took by @samuelgruetter looks good!
As @jmhofer said there should be no perf impact as long as you keep a value class, and from what I've seen there should be no reason to need more than one value in the wrapper.

I have some remarks but I'l make them directly on @samuelgruetter commit as I did before.
 =||= @benjchristensen I'm confused about the jar releases. I thought they have contained @jmhofer 's changes for proper covariance/contravariance handling since 0.11.2, but apparently they don't:

In `rxjava-core-0.11.3.jar`, `flatMap` looks like this:

```
public <R> Observable<R> flatMap(Func1<T, Observable<R>> func) {
    return mapMany(func);
}
```

On github master, `flatMap` looks like this (that's what I would like to have in the jar):

```
public <R> Observable<R> flatMap(Func1<? super T, ? extends Observable<? extends R>> func) {
    return mapMany(func);
}
```
 =||= @samuelgruetter If I'm not mistaken, there was no release yet after the merge of the co-/contavariance branch. 0.11.3 was right before that. I'm afraid that you'll have to wait for 0.11.4 (or 0.12, more likely), or you'll have to work directly on the repo build of RxJava.
 =||= Those changes will be in 0.12 which has not been released yet. It was merged to master yesterday. 

Before releasing I wanted to determine if this thread of discussion required any further changes to core, and I want to get in https://github.com/Netflix/RxJava/pull/349 as well since it generalizes some objects in `rx.util` which hopefully gets confirmed today.

Is there anything else that if done in core for release 0.12 would improve Scala support?
 =||= I can't currently think of anything that if done in core for release 0.12 would improve Scala support. But probably I'll find such things just after 0.12 is released ;-)
 =||= Then once I wrap up those other things (hopefully today) I will release 0.12. I fully expect we'll find more to change ... hence us not being at 1.0 yet :-)
 =||= Due to the 2 bugs, are we unable to pursue the route where `rx.Observable` is the return type at this time?

Also, since I'm unfortunately not yet very experienced with Scala, in your examples would you mind demonstrating a use case where a ScalaObservable is exposed back to Java for interop? I'm interested in understanding how the solution being worked on would function in polyglot environments (while understanding this is a secondary priority).
 =||= if you call `.wrapped` on a `ScalaObservable` you get back the original `Observable` which can be used with the Java API.

Maybe we could find a better name that wrapped, not easy though ;-)
 =||= I'd prefer calling `.wrapped` `.asJava` instead (like the collection `JavaConverters` do).
 =||= Version 0.12 has been released. 
 =||= I've forked the RxJava repo and I'm now working [here](https://github.com/samuelgruetter/RxJava/blob/idiomaticscala/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala).
 =||= @samuelgruetter great stuff!
 =||= @samuelgruetter Good idea!

And: Yay, finally a covariant observable! Awesome! I've been working towards this all the time...
 =||= Well now I have a Scala compiler bug... It's [here](https://github.com/samuelgruetter/RxJava/blob/idiomaticscala/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala#L168). I don't know yet what to do about that.
 =||= @samuelgruetter  You can work around the bug by explicitly provide a type argument. I've isolated and reported this issue, along with the workaround, here: https://issues.scala-lang.org/browse/SI-7818
 =||= Try it with an explicit type parameter for the Java method: `new Observable(JObservable.synchronize[T](asJava))`

Works for me, at least.
 =||= Thanks @retronym. Is this going to be fixed in Scala 2.10.x? I'm asking because we want to use the Rx Scala Wrapper for a course in November, and we don't want to confront students with compiler bugs. So we consider temporarily removing `extends AnyVal`, until the interplay between value classes and covariance can be considered stable.
 =||= @samuelgruetter The particular bug only affects you when you define the value class. Clients of the class are safe.
 =||= ok, so we'll keep using `extends AnyVal`, unless it leads to more problems...
 =||= This [Observable.scala](https://github.com/samuelgruetter/RxJava/blob/955fbfcdfdd2ce12ac2ee578d63c8edd734f8444/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala) now contains all methods present in the Java Observable, **but** for many of them, there is only a comment containing their signature and a note on the problem I faced. You can find all these interesting problems by searching for `TODO`.
 =||= [![Code Bounty](https://app.codebounty.co/reward/image/6b82995d8cf0ea7678754a98)](https://app.codebounty.co/reward/link/6b82995d8cf0ea7678754a98)
 =||= I'm planning to continue as follows:
-    Add some tests to `Observable.java`. Their goal is not to test the correct behavior of the methods (that's already done in the unit tests of the operations), but to test if the method signatures of `Observable` are good, and to provide small usage examples.
-    I expect these tests to reveal some issues related to covariance. Fix these.
-    Continue with the Scala adaptor.
 =||= @samuelgruetter I just took a quick look, nice progress.

Looks like most of your issues are related to covariance, I haven't look in depth but there is some trick to workaround this kind of thing in scala... not sure if possible to apply them here.

I'll try to take a look during the week and give you feedback... not sure when unfortunately.

I've seen some comments where you hesitate returning the scala wrapped version or the java one, I would say that for a first version, just return the scala one.

You can refine that later trying to find where you can return the native type, IMO it's a nice to have but clearly not absolutely needed when using the API in pure scala.

About `Future`, I think it should be quite easy to create a wrapper to expose scala future as java one, have you tried implementing the java future interface backed by a scala one?
 =||=  @samuelgruetter Could you explain the problem with the `reduce` signature please?

Do you mean by your TODO that this needs a second type parameter `U` with `U extends T` etc instead of simple wildcards in Java, too?
 =||= I think that `reduce` needs a type parameter `U` with `U super T` in the Java Observable. And similar changes will be needed for other methods as well, in order to make sure that the `T` of `Observable<T>` never occurs in a contravariant position. I'll post corresponding code soon.
 =||= I added tests to [CovarianceTest.java](https://github.com/samuelgruetter/RxJava/blob/b59b68d7361bbb01604e2feaeba904a6b4cbd85c/rxjava-core/src/test/java/rx/CovarianceTest.java), which I would like to compile, but they don't, and I think that the signatures in `Observable.java` need to be tweaked.
The tests which do not compile are marked with `might-not-compile`.
I will now try to tweak `Observable.java` as needed.
 =||= The signature of `reduce` in `Observable.java` currently looks like this:

```
public Observable<T> reduce(Func2<? super T, ? super T, ? extends T> accumulator) {
                                                        ^^^^^^^^^^^
```

The problem with this is that the underlined `T` appears in a contravariant position. This means that we cannot say anymore that `Observable<T>` is covariant in `T`, and we cannot use Observable as we would like to:

```
public void libraryFunctionActingOnMovieObservables(Observable<? extends Movie> obs) {
    Func2<Movie, Movie, Movie> chooseSecondMovie = 
        new Func2<Movie, Movie, Movie>() {
            public Movie call(Movie t1, Movie t2) {
                return t2;
            }
        };
    Observable<Movie> reduceResult = obs.reduce(chooseSecondMovie); // <- weird error
    // do something with reduceResult...
}

public void codeUsingTheFunction() {
    Observable<HorrorMovie> horrorMovies = Observable.from(new HorrorMovie());

    // do something with horrorMovies, relying on the fact that all are HorrorMovies
    // and not just any Movies...

    // pass it to library (works because it takes Observable<? extends Movie>)
    libraryFunctionActingOnMovieObservables(horrorMovies);
}
```

The above code should compile, but instead produces a weird compilation error.

Now let's see how Scala solves this: The signature of reduceLeft in the Scala immutable collections (which are covariant in their type parameter `A`) looks like this:

```
def reduceLeft[B >: A](f: (B, A) => B): B
```

The trick is to add a type parameter `B` to the method, whose lower bound is `A`. Now `A` only appears in covariant positions, and we're fine.

So I thought we could just do the "same" in Java:

```
public <U super T> Observable<U> reduce(Func2<? super U, ? super T, ? extends U> accumulator)
```

But, unfortunately, Java does not support lower bounds for type parameters.

So, this makes me think that Java's type system is not powerful enough to properly support covariant Observables.

Because of this, I will now return to the Scala adaptor, and try to implement a covariant Scala Observable, which uses casts where necessary. If we later find a way to get rid of the casts, all the better.
 =||= I think it would be possible to work around that by making `reduce` static and giving it two type parameters `<U, T extends U>`. With this, we could probably simplify the type parameters of the instance method, dropping covariance in that place, and instead get the full covariance via the static method. Scala could just use the static method. 

I'm not sure whether we want that.

Or maybe there's a more direct workaround via casting (yuck). Haven't tried anything like that out yet.
 =||= It could go direct against the internal static operators instead of us putting an unnecessary static reduce on `Observable`.

``` java
Observable.create(OperationScan.scan(observable, accumulator)).takeLast(1);
```
 =||= Varargs have been removed from `Observable`: https://github.com/Netflix/RxJava/pull/361
 =||= Investigating issues with `reduce` covariance at https://github.com/Netflix/RxJava/issues/360#issuecomment-24128500.

It works when done statically instead of via an instance method: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/ReduceTests.java#L39
 =||= I can now confirm that the solution with value classes is indeed as awesome as we expected :D
I wrote a very small example showing how Java code can use Scala code: There's a [MovieLib.scala](https://github.com/samuelgruetter/RxJava/blob/0603e395b680655a923e138582d779c65d001651/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scalatests/MovieLib.scala), which uses Scala Observables everywhere.
In a second project, there is [MovieLibUsage.java](https://github.com/samuelgruetter/RxJava/blob/0603e395b680655a923e138582d779c65d001651/language-adaptors/rxjava-scala-java/src/main/java/rx/lang/scalaexamples/MovieLibUsage.java), which uses `MovieLib` as a class which uses Java Observables everywhere, because Scala value classes are such that the Scala Observables appear as Java Observables for the Java compiler.
The only challenge here is to set up the build process correctly: In this scenario, the Scala sources have to be built first, and then the Java sources. I achieved this by making a seperate project for `MovieLibUsage`, which depends on the project containing `MovieLib`.
 =||= Value classes are awesome. This means we don't even need to convert back to Java Observables anywhere. Thanks for the example.
 =||= Sounds great @samuelgruetter, I'm happy to hear that we can achieve idiomatic Scala and Java interop cleanly without converting back and forth!

Do the compiler bugs prevent us from moving forward or are their sufficient workarounds for now?

I am planning on releasing 0.13 with the changes merged to master shortly. Is there anything else you need to core to support `rx.lang.scala.Observable`?
 =||= We have sufficient workarounds for the compiler bug.

There's nothing fundamental that we need for the Scala adapter right now, but I'm currently trying to translate the dictionary autocomplete example written in C# from this [Rx Hands On Lab](http://blogs.msdn.com/b/rxteam/archive/2010/07/15/rx-hands-on-labs-published.aspx) to Scala to see what we can already do. For this, I miss the `distinctUntilChanged` and the `throttle` operator, so these are currently on top of my whishlist ;-)
 =||= The 'throttle' operator was just merged to master as `debounce``throttleWithTimeout`. See https://github.com/Netflix/RxJava/pull/368 for an explanation of the 3 variants of`throttle` that were committed.

We do not yet have `distinctUntilChanged` but that shouldn't be hard to get added.
 =||= That's great that workarounds exist so we can move forward, I look forward to hearing how the autocomplete example works.

If you can get that functioning is that strong enough evidence to move forward with it or are there still pieces of functionality lacking?

How do you envision ongoing maintenance of this class? Do all new operators added to `rx.Observable.java` required wrapping methods, or does it pass thru if a wrapper isn't there?
 =||= If I can get the autocomplete example functioning then I think that's strong enough evidence to move forward with it. We still lack operations in the wrapper, but it should be possible to add them all.

This adapter will require some maintenance. New operators added to the Java observable will have to be added to the adapter as well, and updates of the documentation too, because the signatures are too different to automate this. 
However, if really needed, one can always call `.asJava` on a Scala observable and use the Java methods directly, and if the implicit function conversions from Scala functions to Java Func/Action are imported, one could even use Scala functions. But that's not the intended way of using it and should only be used in quick hacks.
 =||= Good to know regarding maintenance ... we'll need to figure out a reasonable way of handling that as operators get added.

Do you have an idea of when I should expect a pull request with this new Scala Observable?

Is this a breaking change to how the implicits support currently works for Scala, or does this wrapper only take effect when someone imports `rx.lang.scala.Observable` instead of `rx.Observable`? Can the existing implicits continue existing alongside?
 =||= It's not a breaking change: The old `RxImplicits` are still there and usable, but marked as deprecated.
 =||= So does it make sense to mark them deprecated since they're still usable and possibly useful for someone accessing operations that haven't made their way to this curated wrapper? Just checking.
 =||= If an operation from `rx.Observable` has not yet made it to `rx.lang.scala.Observable`, there are the following solutions (ordered by my preference):
-    report an issue to get the operation into `rx.lang.scala.Observable` ;-)
-    call `.asJava` on the Scala observable and use the implicit conversions from `rx.lang.scala.internal.ImplicitFunctionConversions`
-    use the old `RxImplicits`
 =||= Btw `RxImplicits` and `ImplicitFunctionConversions` are almost the same, except that `ImplicitFunctionConversions` does not contain an `implicit class ScalaObservable`.
 =||= Pull https://github.com/Netflix/RxJava/pull/376 has been released in [0.13.1](https://github.com/Netflix/RxJava/releases/tag/0.13.1)

Thank you @samuelgruetter!
 =||= > Btw RxImplicits and ImplicitFunctionConversions are almost the same, except that ImplicitFunctionConversions does not contain an implicit class ScalaObservable.

With that one difference does it still require the two existing, or can `ImplicitFunctionConversions` perform the same functionality as `RxImplicits` and negate it's need? Or does having `RxImplicits` around still help for any use cases?
 =||= If there is already code out there depending on `RxImplicits`, we need to keep it to remain compatible with that code. If not, we can remove `RxImplicits` without any loss of functionality.
 =||= Given that there's no loss of functionality, I think it makes the most sense to remove `RxImplicits` and not introduce the chance of newcomers to RxJava depending on unsupported functionality.  I'll generate a pull request to this effect
 =||= Removing duplication makes sense. Since `rx.lang.scala.internal.ImplicitFunctionConversions` is escape hatch (besides manually using Func1 and friends) for stuff not covered by the Scala wrapper, would it make sense for it not to be in an internal package?
 =||= @mattrjacobs Good idea.

@daveray Well the goal should be that there is no such thing as "stuff not covered by the Scala wrapper"... Having `ImplicitFunctionConversions` in an internal package would increase the pressure to keep the Scala Observable in sync, which is a desired effect. And if we add a unit test as I outlined at the bottom of [this comment](https://github.com/Netflix/RxJava/pull/376#issuecomment-24439163), keeping the Scala Observable up to date would become easier.
 =||= Removing `RxImplicits` will be breaking for people until they change their import from `rx.Observable` to `rx.lang.scala.Observable` correct? If so I will bump the version to 0.14 when I merge this change.

Can someone also please update the README (https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/README.md) to show usage information to help someone get started?
 =||= @samuelgruetter It's up to you guys. I'll just leave with this: open source projects live a lot longer than the enthusiasm of their contributors so I'm skeptical of a wrapper that assumes it will always be kept completely up-to-date with complete coverage forever. If some third party decided to create a project of custom observables beyond what's in RxJava, those would be more difficult to use, assuming users respect the implication of "internal" in the package name. I'll go back to Clojure-land now :)
 =||= @daveray ScalaObservable has a method to get the wrapped Java Observable, so you should be able to use any method from its API.
And since the project is Open Source you can always send a Pull Request and improve it ;)
 =||= @martin-g Right. And if for whatever reason some poor Scala programmer finds herself in yucky Java-land calling these mehods, at least throw her a bone and make the Func implicits available in a non-internal package.
 =||= @martin-g Correct me if I'm wrong, but dropping down to using rx.Observable still mandates passing in `Func1/Func2`/etc.  Being able to use native Scala functions and the implicits in this case seems far better than forcing user code to new up these function types and pass them in.

After thinking about it, +1 to @daveray's idea of making both the value class and implicits available (with the value class preferred).  This will allow any temporary mismatch between `rx.Observable` and `rx.lang.scala.Observable` to be addressed by implicits while not impeding non-Scala developers from moving core along.
 =||= +1 on this. There are other places where `Func*` are used, such as `BlockingObservable` not yet wrapped, and as new things are added, if they don't yet have a full wrapper there should still be a way to use them with the implicits.
 =||= > it might be cool to have a unit test in which we encode the information "which Java method corresponds to which Scala method", and using reflection, we check if there is a Scala method for each Java method. So if a method is added to the Java Observable but not to the Scala Observable, this test would fail.
> 
> And if we add a unit test as I outlined at the bottom of this comment, keeping the Scala Observable up to date would become easier.

We can't make the build fail if `rx.lang.scala.Observable` is out of sync. We can't block the project from building and releasing just because a new operator is added and the developer adding it isn't comfortable deciding what the idiomatic Scala method signature should look like.

It needs to be an async process for Scala developers to add wrapper methods/classes. Since this is open source we can't control people's schedule and require quick turnaround on adding the wrappers. Ideally that will happen when new functionality is added, but we can't make building and releasing dependent on that.

Thus, I think we need to account for the fact that most things will have wrappers but very newly added functionality or fringe functionality may not and should still have a mechanism for being used.
 =||= If you want rxjava-core to evolve independently then perhaps rxjava-scala
and other language adapters should each be a separate top-level project
with its own release cycle.

On Mon, Sep 16, 2013 at 2:55 PM, Ben Christensen
notifications@github.comwrote:

> it might be cool to have a unit test in which we encode the information
> "which Java method corresponds to which Scala method", and using
> reflection, we check if there is a Scala method for each Java method. So if
> a method is added to the Java Observable but not to the Scala Observable,
> this test would fail.
> 
> And if we add a unit test as I outlined at the bottom of this comment,
> keeping the Scala Observable up to date would become easier.
> 
> We can't make the build fail if rx.lang.scala.Observable is out of sync.
> We can't block the project from building and releasing just because a new
> operator is added and the developer adding it isn't comfortable deciding
> what the idiomatic Scala method signature should look like.
> 
> It needs to be an async process for Scala developers to add wrapper
> methods/classes. Since this is open source we can't control people's
> schedule and require quick turnaround on adding the wrappers. Ideally that
> will happen when new functionality is added, but we can't make building and
> releasing dependent on that.
> 
> Thus, I think we need to account for the fact that most things will have
> wrappers but very newly added functionality or fringe functionality may not
> and should still have a mechanism for being used.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/336#issuecomment-24548044
> .
 =||= Erik Meijer and I have discussed this but it doesn't feel like the right thing to do, as it would hurt the JVM ecosystem more than benefit it if the different languages forked from each other. 

There is no harm in a new version of RxJava being released without the Scala adaptor adding the new functionality, as that is no different than a separate RxScala project not yet supporting it on top of the RxJava core dependency.

As we approach 1.0 the rapid iteration will slow and this will become less of an issue. Around that time as well the project may migrate into a different home than here.
On September 16, 2013 at 3:20:07 PM, Chris Richardson (notifications@github.com) wrote:

If you want rxjava-core to evolve independently then perhaps rxjava-scala  
and other language adapters should each be a separate top-level project  
with its own release cycle.
 =||= I like @daveray's point: If some third party decided to create a Java project of custom observables beyond what's in RxJava, and we want to use this project from Scala, then we need the `ImplicitFunctionConversions`. So I will make this non-internal.

@benjchristensen I agree that it would be kind of crazy to make the build fail just because `rx.lang.scala.Observable` is out of sync.
 =||= Closing this out as completed ... further progress/bugs can use new issues.

Great work and thank you everyone involved on this.
 =||= ,0
7282,339,Garbage Creation,Hi,

Do you use object pooling to prevent garbage being produced? Can this run without GC activity for a few weeks at least?

Suminda,No it does not use pooling. By definition Rx uses composition and if object allocation is a concern to you then it should not be used.  We use Rx extensively in the Netflix API without full (stop-the-world) GCs, but the young gen is constantly cleaning garbage. Our JVMs are tuned to handle the garbage throughput of Rx, Hystrix, JSON/XML/Thrift/etc serialization/deserialization and all other object allocations of the JVM. We (nor this library) do not attempt to fit the constraints of something like a financial trading application which pursues no object allocation at all. 
 =||= @benjchristensen Will you be willing to share some of the strategies you used for tuning the JVM? Which garbage collector do you use currently?
 =||= ,0
7282,304,Version 0.10.0 - Static Language Support,Manual merge of pull https://github.com/Netflix/RxJava/pull/300 from @mattrjacobs 

This will make RxJava completely static by removing all Object overloads (see https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204).

I'm submitting this before it being 100% ready so people can review and provide feedback.

Open items to append to this pull request before merging:

**1) subscribe with map is not handled yet**

The following signature needs to be made static. Right now the lack of this combined with removal of Functions.from dynamic language functionality has broken this.

``` java
public Subscription subscribe(final Map<String, Object> callbacks)
```

**2) Core artifact naming convention**

Should rxjava-core-x.y.x.jar become rxjava-x.y.z.jar since the concept of core+language no longer applies?

I think I'd prefer this:
- rxjava-x.y.z.jar 
- rxjava-groovy-x.y.z.jar 
- rxjava-clojure-x.y.z.jar 
- rxjava-scala-x.y.z.jar 
- rxjava-jruby-x.y.z.jar 
- rxjava-kotlin-x.y.z.jar 
- rxjava-dynamic-x.y.z.jar (object overload for any language)
- rxjava-groovy-clojure-x.y.z.jar (multi-language jar)

Only one of those jars is needed hence the reason why I think the 'core' term is no longer needed as it communicated the fact it was always needed.

Any contrib modules would be: rxjava-contrib-module-name-x.y.x.jar

**3) Dependencies from languages to core still exist**

The build still will result in Maven Central POM files requires rxjava-core from the language version despite that not being the case. Need to eliminate this dependency in the artifact.

---

Implementation notes originally posted at https://github.com/Netflix/RxJava/issues/204#issuecomment-20396621:

After implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities. 

Our goals are:
- support static typing for Java/Scala/Kotlin etc by removing the Object overloads
- support any JVM language, static or dynamically typed
- allow all languages to use the same `rx.Observable` class so that we don't divide libraries with helpers such as `GroovyObservable`, `ClojureObservable` etc that then need to be converted back and forth when doing interop
- do not require special classloaders or agents to enable runtime bytecode generation
- do not remove static operators to enable proxying
- small jars and limited or no dependencies

The solution we have arrived at will work as follows:
- The rxjava-core source code will delete all Object overload methods and be pure static java.
  - Any language that supports functional interfaces directly (such as Java 8 and XTend) can use the Java core version directly.
- Languages needing specific lambda/clojure type mapping to the Func_/Action_ types will have language specific Jars created via build-time bytecode generation.
  - Any method with a Func_/Action_ argument will be overloaded with a version supporting the language requirements.

For example:

The default Java version:

``` java
public static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> predicate)
```

A Groovy version:

``` java
public static <T> Observable<T> filter(Observable<T> that, groovy.lang.Closure predicate)
```
- A jar per language will be created as follows:
  - rxjava-x.y.z.jar 
  - rxjava-groovy-x.y.z.jar 
  - rxjava-clojure-x.y.z.jar 
  - rxjava-scala-x.y.z.jar 
  - rxjava-jruby-x.y.z.jar 
  - rxjava-kotlin-x.y.z.jar 

A project will include just the jar that meets their language needs, there will no longer be a "core" jar plus the language adaptor.

The drawback of this is that mixing two of these in a classpath will result in non-deterministic loading (whichever is loaded last wins) and that is the version that will be used. This means if a library depends on rxjava.jar but is using Groovy and needs rxjava-groovy.jar it is up to the developer of that project to make sure they have only the rxjava-groovy.jar version. This is not ideal but is a one-time pain setting up a build and is better than the constant pain of missing static typing or converting to/from different Observable implementations for different languages.
- At this time we are optimizing for projects using a single language or Java + another language. If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options:
  - include an rxjava-dynamic.jar version that re-adds the Object overloads
  - include build configs for common combinations of languages such as rxjava-groovy-clojure.jar
- Language adaptations (such as clojure which has preferred idioms that necessitate wrapping) will still be possible through the language-adaptor projects and be included in the appropriate language jars.

This should not break any code but will require a slight change to the build dependencies in your project when we release this. 

We hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages.,[RxJava-pull-requests #174](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/174/) SUCCESS
This pull request looks good
 =||= 1.  I don't think I follow your point about making the `subscribe(Map<String, Object>)` method static.  Wouldn't that break all existing scripts that use this method?  Could we add a `subscribe(Map<String, Closure>)` or `subscribe(Map<String, IFn>)` variant in the dynamic JARs?  That would also suggest tightening up the core signature to `subscribe(Map<String, Function>)`.
2.  This naming convention makes sense to me.  I will change rxjava-core to rxjava in the artifact name, at least.  I think I will leave the directory rxjava-core alone, since it makes more sense there, and IMO, it would be confusing to have a dir like `RxJava/rxjava/...`  I don't plan on bringing rxjava-kotlin along with this pull request, but I can review #292 to help fit that into the 0.10 world.  
3.  I think I understand this, though I'm already at the edge of my Gradle ability.  If I'm understanding this correctly, we should not change the build steps for a project - we just need to change the generated Maven POM.  That makes sense - I'll figure out a way to accomplish that.
 =||= Looks good, all in all. I'll try this out with my Scala sample as soon as possible. Thanks for the awesome work!
 =||= Thanks @jmhofer for stepping in to test out these changes.

@mattrjacobs Answers to your questions ...

1) subscribe(Map)

If we leave the `Map<String, Object>` then the `Functions.from` capability needs to keep working.

The other option is we change that to be `Map<String, Function>` as you suggest and then auto-generate the versions for each language.

2) Thanks, and agreed on the directory name, but that can change if we want in the future without impacting the artifact name once you set the name.

3) Maven POM

I think the simplest solution is just not have any "compile" dependencies, only "provided". I believe your Gradle scripts just need to adjust to include provided dependencies, not just compile runtime dependencies and then it will work. I would not try messing with POM files directly. If something is specified as "provided" then it is used for compilation but not included in the POM when pushed to Maven Central.
 =||= [RxJava-pull-requests #175](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/175/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #176](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/176/) FAILURE
Looks like there's a problem with this pull request
 =||= [RxJava-pull-requests #177](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/177/) SUCCESS
This pull request looks good
 =||= Currently, if you publish RxJava to your local Maven repo, you'll find that the rxjava-scala and rxjava-swing POMs include a dependency on "rxjava-core", which doesn't exist anymore as a module, as it was renamed to "rxjava".

Unfortunately, I don't know enough about Gradle to be able to fix this. My guess would be that it's not enough to set the `baseName` of the JAR to just "rxjava". There should be a way to tell gradle that the module is called "rxjava" even though the directory is called "rxjava-core".
 =||= Here's another problem: Excluding "*$UnitTest" from JARs that might be included by Scala will cause the Scala compiler to crash with a Typer error because it expects defined inner classes to exist. This means that at least in `rxjava-swing`, the exclude can't be done.
 =||= I've created a mini-PR against the unit test problem here: https://github.com/benjchristensen/RxJava/pull/1
 =||= I got my little sample (https://github.com/jmhofer/rxjava-samples) working with this PR. The code itself was very easy to adapt. The implicits seem to be working fine. 

One small thing I noticed: The very long names of the implicits are a bit distracting, imho. Should I want to use one of these functions explicitly, I'd prefer shorter names like simply `func1` instead of `scalaFunction1ToRxFunc1`, for example.
 =||= Responses to @jmhofer:
1. POM references to rxjava-core:  In the Scala case, I prefer including all of the core Rx classes directly in the rxjava-scala.jar, so that there is no dependency at all.  This avoids the problem entirely.  For rxjava-swing, I'll work on the Gradle side to make the reference correct.  This might take the form of changing the reference or actually changing the name of rxjava-core to rxjava - we'll see how friendly Gradle is.
2. Excluding inner classes:  I've also come across the Scala compiler error on Classfile parsing with excluded inner classes.  At the moment, unit tests exist in rxjava-core.jar and rxjava-scala.jar only.  Going forward:
   - rxjava-core: These unit tests only exist so that rxjava-scala can be built.  I will exclude them, add a new unfilteredJar Gradle task, and build rxjava-scala off of unfilteredJar.  
   - rxjava-scala: I will continue to include UnitTests, since it's pretty likely that Scala projects are consuming this 
   - rxjava-swing: I hadn't considered the case of Scala consuming this, but you're obviously right.  For now, I'll err on the side of caution and unilaterally add the UnitTests back to the jar.  At some later point, we might want to re-examine (rxjava-swing-scala.jar/rxjava-swing-filtered.jar).  But adding them back is the safe thing to do.  Your PR is exactly what I will do, thanks for that.
3.  Implicit names: In my experience, it's rare that I call implicit conversions by name, but I can see your point.  My only concern is ambiguous namings.  Would changing 'scalaFunction1ToRxFunc1' to 'toRxFunc1' (and other similar naming changes) be satisfying?
 =||= @mattrjacobs: All your suggestions seem sensible to me.

Concerning implicit naming: It may be relatively rare, however using the implicits often leads to your having to specify the parameter types of the closures being implicitely converted, which can be more verbose and confusing than making the conversion explicit and then being able to shorten the closure syntax.

Names like `toRxFunc1` are ok with me, not too long and still unambiguous, sounds like a good compromise.
 =||= [RxJava-pull-requests #181](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/181/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #182](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/182/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #183](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/183/) SUCCESS
This pull request looks good
 =||= [RxJava-pull-requests #188](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/188/) FAILURE
Looks like there's a problem with this pull request
 =||= Replaced by https://github.com/Netflix/RxJava/pull/319
 =||= ,0
7282,310,How to observe perpetually changing Iterable,Hi guys. Can you explain how to observer a perpetually changing Iterable? For instance, here is some code:

``` java
public class ReportConnector {

  private ConcurrentLinkedQueue<String> eventList = new ConcurrentLinkedQueue<String>();
  private Observable<String> observable;

  public ReportConnector() {
    observable = Oberservable.toObservable(eventList);
    observable.subscribe(new Action1<String>() {
      @Override
      public void call(String event) {
        System.out.println("Val sent: "+event);
      }
    });
  }

  public addEvent(String event) {
    eventList.add(event);
  }
}
```

The problem is, the observable immediately calls onComplete in the constructor after adding the subscriber, and then subsequent additions to my linked queue through the addEvent method never get processed by the subscriber. I'm sure I'm missing a big concept here, so any help in pointing me to how to do this correctly would be greatly appreciated. Thanks!,The Oberservable.toObservable(eventList) method captures the current state
of the Iterable, emits it and completes. There is no builti-in mechanism
for observing an Iterable for future changes.

If the source Iterable must exist and can't be wrapped/modified then
something (likely a thread) would need to poll that Iterable for new values
that are then emitted to an Observable via onNext and never call
onCompleted.

If the source Iterable can be wrapped or replaced, I'd make it so whenever
something is offered to the ConcurrentLinkedQueue that it also gets sent to
the Observable onNext. This is obviously far more efficient than polling an
Iterable.

Basically, wherever the events originally come from it is better to capture
that event and push it to the Observable rather than route them through an
Iterable if you can. The Observable.from(Iterable) method is just a bridge
from a snapshot of a List/Collection.

The monitoring approach could theoretically be done with a signature such
as Observable.monitor(Iterable i, Scheduler s) with the Scheduler giving it
the thread to perform the monitoring on.

Ben

On Tue, Jul 23, 2013 at 3:41 PM, Eric Nelson notifications@github.comwrote:

> Hi guys. Can you explain how to observer a perpetually changing Iterable?
> For instance, here is some code:
> 
> public class ReportConnector {
> 
>   private ConcurrentLinkedQueue<String> eventList = new ConcurrentLinkedQueue<String>();
>   private Observable<String> observable;
> 
>   public ReportConnector() {
>     observable = Oberservable.toObservable(eventList);
>     observable.subscribe(new Action1<String>() {
>       @Override
>       public void call(String event) {
>         System.out.println("Val sent: "+event);
>       }
>     });
>   }
> 
>   public addEvent(String event) {
>     eventList.add(event);
>   }}
> 
> The problem is, the observable immediately calls onComplete in the
> constructor after adding the subscriber, and then subsequent additions to
> my linked queue through the addEvent method never get processed by the
> subscriber. I'm sure I'm missing a big concept here, so any help in
> pointing me to how to do this correctly would be greatly appreciated.
> Thanks!
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/310
> .

## 

Ben Christensen - API Team
+1-310-781-5511  @benjchristensen
 =||= You might want to look at the Subject and friends.  A subject is both and observable and observer at the same time.

```
    PublishSubject<String> events = PublishSubject.create();
    events.subscribe(new Action1<String>() {
        @Override
        public void call(String event) {
            System.out.println("Val sent: " + event);
        }
    });
    events.onNext("one");
    events.onNext("two");
```
 =||= Thanks so much for your quick responses. I really appreciate it!
 =||= ,0
7282,317,AndroidScheduler.java,Initial spike for AndroidScheduler.java.

Been using this for quite some time. But I don't like the concept using calling `observer.observeOn(AndroidScheduler.getInstance())` as it sort of puts Android specific stuffs. Should RxJava support some concept of `Schedulers.mainScheduler()`? We can then set the default main schedulers using `Schedulers.setMainScheduler(AndroidScheduler.getInstance())` when app starts.,[RxJava-pull-requests #195](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/195/) FAILURE
Looks like there's a problem with this pull request
 =||= Thanks @prabirshrestha for the submission. Support for Android is something several people will be happy about getting.

Since I don't work with Android I'd like to pull @mustafasezgin into this conversation as he's using RxJava on Android at SoundCloud. Mustafa, can you review, contribute and/or answer questions?

Mustafa gave a presentation that hinted at the use of Schedulers for Android: http://backstage.soundcloud.com/2013/08/responsive-android-applications-with-sane-code/

![android-schedulers-soundcloud](https://f.cloud.github.com/assets/813492/958852/530a5bd4-0470-11e3-88c3-1c0ef2be88f8.png)

I don't like the idea of global settings like Schedulers.setMainScheduler, as libraries would be stepping on each other.

I think something such as the following is a good approach, similar to the `Schedulers` factory class in Rx core:

``` java
AndroidScheduler.MAIN_SCHEDULER
... or ...
AndroidScheduler.mainScheduler()
```
 =||= `AndroidScheduler.mainScheduler()` definitely sounds better then `AndroidScheduler.getInstance()`.

I named the method as `getInstance` so that the AndroidScheduler is similar to the SwingScheduler which uses `getInstance()`. 

I would also need help on writing the gradle build scripts.(Android SDK should also be installed in the CI server)
 =||= Android dependencies should be in a repo such as Maven Central so that someone does not need to configure their environment correctly to build. 

Is this what it needs? 

http://search.maven.org/#artifactdetails%7Ccom.android.tools%7Csdk-common%7C22.1.3%7Cjar

The gradle file will be similar to this: https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-swing/build.gradle

... but you will add this dependency:

```
compile 'com.android.tools:sdk-common:22.1.3'
```

Also add your module to this file: https://github.com/Netflix/RxJava/blob/master/settings.gradle

For example, place this on the 2nd to last line before rxjava-swing:

```
'rxjava-contrib:rxjava-android', \
```
 =||= @benjchristensen happy to help out, @mttkay (from the SoundCloud Android team) will also be valuable to the discussion.

We use the first method outlined by @benjchristensen to set a the main thread scheduler on an observable. The main thread scheduler is similar to the one submitted by @prabirshrestha with the second method being implemented using the `Handler.postDelayed()` method. For consistency with the core package I think the static method approach for the scheduler is more suited in this instance.

@mttkay wrote some helpful components related to fragments which we were also looking to opensource. Maybe we should look to getting that out sooner. @mttkay thoughts?

Also you should only need to add the main android sdk dependency http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22com.google.android%22%20AND%20a%3A%22android%22 using the _provided_ maven scope.
 =||= Thanks @mustafasezgin for getting involved. Nice to know you and @mttkay work together.

Yes, we only need the SDK as a provided not compile dependency. So like this in the build.gradle file:

```
provided 'com.google.android:android:4.1.1.4'
```
 =||= Awesome. I was playing around with Android and RxJava already, too. But I guess for me, it'll be a libgdx integration mostly.
 =||= Hey guys, indeed we have been using a more complete scheduler for a while, one that has an implementation for delayed messages too.

My suggestion is to rename `AndroidScheduler` to `AndroidSchedulers` (plural) since there may be more schedulers to be implemented for Android down the road (like scheduling via AsyncTasks). So we should have:

`AndroidSchedulers.mainThread()`

I'm also missing tests and build integration with this PR. It seems like it's a WIP, maybe we should combine our efforts around this?
 =||= Have a look at the above PR. I've pulled the scheduler component out of our production app code and into rxjava-contrib.

The build should pass, the Scala adaptor seems to be causing trouble though? Seems to neither build on the public CI nor on my local machine. Test execution time is slightly up due to the addition of Robolectric, which goes through a start-up procedure to initialize a fake Android application environment for testing.
 =||= closing in favor of #318
 =||= ,0
7282,319,typesafe-core,Here's another attempt at making rx-core typesafe and still supporting dynamic languages. The previous attempt was https://github.com/Netflix/RxJava/pull/304.  Enough changed (including the 0.10 release) since I submitted #304 that it made more sense to start fresh with this one.  All the comments from that PR still apply, and the 'subscribe on map' issue is now handled.

This will make RxJava completely static by removing all Object overloads (see https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204).

---

Implementation notes originally posted at https://github.com/Netflix/RxJava/issues/204#issuecomment-20396621:

After implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities. 

Our goals are:
- support static typing for Java/Scala/Kotlin etc by removing the Object overloads
- support any JVM language, static or dynamically typed
- allow all languages to use the same `rx.Observable` class so that we don't divide libraries with helpers such as `GroovyObservable`, `ClojureObservable` etc that then need to be converted back and forth when doing interop
- do not require special classloaders or agents to enable runtime bytecode generation
- do not remove static operators to enable proxying
- small jars and limited or no dependencies

The solution we have arrived at will work as follows:
- The rxjava-core source code will delete all Object overload methods and be pure static java.
  - Any language that supports functional interfaces directly (such as Java 8 and XTend) can use the Java core version directly.
- Languages needing specific lambda/clojure type mapping to the Func_/Action_ types will have language specific Jars created via build-time bytecode generation.
  - Any method with a Func_/Action_ argument will be overloaded with a version supporting the language requirements.

For example:

The default Java version:

``` java
public static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> predicate)
```

A Groovy version:

``` java
public static <T> Observable<T> filter(Observable<T> that, groovy.lang.Closure predicate)
```
- A jar per language will be created as follows:
  - rxjava-x.y.z.jar 
  - rxjava-groovy-x.y.z.jar 
  - rxjava-clojure-x.y.z.jar 
  - rxjava-scala-x.y.z.jar 
  - rxjava-jruby-x.y.z.jar 
  - rxjava-kotlin-x.y.z.jar 

A project will include just the jar that meets their language needs, there will no longer be a "core" jar plus the language adaptor.

The drawback of this is that mixing two of these in a classpath will result in non-deterministic loading (whichever is loaded last wins) and that is the version that will be used. This means if a library depends on rxjava.jar but is using Groovy and needs rxjava-groovy.jar it is up to the developer of that project to make sure they have only the rxjava-groovy.jar version. This is not ideal but is a one-time pain setting up a build and is better than the constant pain of missing static typing or converting to/from different Observable implementations for different languages.
- At this time we are optimizing for projects using a single language or Java + another language. If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options:
  - include an rxjava-dynamic.jar version that re-adds the Object overloads
  - include build configs for common combinations of languages such as rxjava-groovy-clojure.jar
- Language adaptations (such as clojure which has preferred idioms that necessitate wrapping) will still be possible through the language-adaptor projects and be included in the appropriate language jars.

This should not break any code but will require a slight change to the build dependencies in your project when we release this. 

We hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages.,[RxJava-pull-requests #201](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/201/) FAILURE
Looks like there's a problem with this pull request
 =||= When trying to build, I get "Could not find property 'ideaProject' on task set." (for `:language-adaptors:rxjava-scala`). What can I do against that?
 =||= Are you building using gradle or gradlew?  gradlew is a wrapper script at
the root of RxJava that allows for consistent builds (pins to gradle 1.6)

For more context on why this is a useful convention, see:
http://www.gradle.org/docs/current/userguide/gradle_wrapper.html

-Matt

On Tue, Aug 20, 2013 at 12:02 AM, Joachim Hofer notifications@github.comwrote:

> When trying to build, I get "Could not find property 'ideaProject' on task
> set." (for :language-adaptors:rxjava-scala). What can I do against that?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/pull/319#issuecomment-22926217
> .
 =||= Thanks, with `gradlew` it works. I simply didn't know about the wrapper script.
 =||= [RxJava-pull-requests #202](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/202/) FAILURE
Looks like there's a problem with this pull request
 =||= Replacing with https://github.com/Netflix/RxJava/pull/323
 =||= ,0
7282,334,Idiomatic Clojure interface,As of RxJava 0.11, the automagic conversion of `IFn` has been removed and, in it's place, there's now a set of functions and macros (`rx.lang.clojure.interop`) to ease interop. It's slightly more tedious, but the API surface area of RxJava has been reduced and it's clearer exactly what's going on now.

That said, using RxJava directly from Clojure still doesn't feel that Clojure-y. Some issues:
- Remembering to use `(rx/fn [])` now instead of just `(fn [])`.
- RxJava predicates, like those passed to `.filter`, must return a `boolean`. Failure to do so results in a `ClassCastException`.
- Argument order isn't consistent with Clojure conventions even though many names are the same
- etc.

This issue is meant to track the addition of a Clojure interface to RxJava that addresses these issues and more. The basic idea is to provide an `rx.core` namespace (I'm open to other suggestions, but I like this since the single-segment `rx` namespace is usually frowned upon in Clojure) that provides observable implementations for all the functions in `clojure.core`, at least where it makes sense. So, for example, `rx.core/map`, unlike `Observable.map` would support multiple sequences and take a plain IFn to apply to them. Similarly, rather than operators, like `Observable.toList`, `rx.core/into` would provide the same, but more powerful, semantics.

Similar namespaces for blocking ops, futures, and other useful stuff would also be included. Also a "raw" namespace will exist that provides wrappers around useful Obesrvable methods that don't have a `clojure.core` counterpart. For example, `Observable.merge` would live here.

A very old sketch of this approach can be seen here: https://github.com/daveray/rx-clj

Since then, we've internally extended these ideas and used them in production. So, the next steps will be for me (@daveray) to get that stuff all updated and tested with 0.11 and submit an initial pull request for review.

Please use this space to offer suggestions, ideas, etc. I've pursued the above approach, but I'm totally open to hearing other ideas for making RxJava easier to use from Clojure.,Is there any way in Clojure to support implicit closure/function coercion against "function interfaces" like Java 8 or Groovy 2.2 (http://docs.codehaus.org/display/GROOVY/2013/07/09/First+beta+of+Groovy+2.2+available)?

However this goes, I would like to see a solution that doesn't require adding new Clojure wrapper code every time a new method/operator is added to the core library.
 =||= Don't know why I didn't think of this, especially since I did a proof of concept of it back before RxJava was called RxJava. At compile time, generate wrapper functions from class/method info. It won't be perfect and will have some of the same problems as Matt's approach, but it will be automated and a nice intermediate step between raw java interop and the more curated approach I suggested above. I'll give it a try and report back. 
 =||= I like the idea of a more idiomatic clojure interface for RxJava. I'm integrating RxJava into some small clojure projects at Rally and would like to help.
 =||= In PR #338, I wrote some kinda messy code to try auto-generating Clojure wrapper functions for RxJava. The basic goal is, as Ben alluded to, something that takes care of `fn -> rx.util.functions.Func` conversion and is auto-generated from RxJava with minimal human intervention. Newly added methods should magically appear in the Clojure wrapper.

If you look at `observable.clj` you can see the invocation which causes the code generation. In `observable_test.clj` is basic usage showing that it actually works.

The problems @mattrjacobs encountered when doing basically the same thing from Java still remain. Figuring out exactly what to do for overloads with the same arity may be tricky. I can write a little "solver" that should be able to insert the right `instanceof` checks to dispatch correctly, at least in most cases. Pathological cases like `Observable.switchDo` where the static and non-static forms are basically indistinguishable when written as normal function application probably can't be solved automatically.

So. Feedback on this approach is encouraged and welcome. I think this would make using rxjava from Clojure mostly idiomatic although I'm still partial to the curated approach outlined above. I like only needing to know one set of sequence manipulation primitives rather than two :) 
 =||= > Pathological cases like Observable.switchDo where the static and non-static forms are basically indistinguishable when written as normal function application probably can't be solved automatically.

Is this the case even when `switchDo` as an instance has no args? I would think it wouldn't apply to this issue in that case.

Note the comment I left in the source code for `switchDo` as one I couldn't decide should be left as a static or removed: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L776

Are there any others you've come across? One of the reasons to remove most of the static methods was to remove duplicate signatures that would confuse dynamic languages (and also reduce API surface area, confusion, etc)
 =||= Well, the instance`switchDo` has no args and the static version has one `Observable` arg. In clojure, the `this` parameter from the instance method moves to the arg list, so they're effectively exactly the same.

Unless the instance version can somehow express the constraint that it only applies to `Observable<Observable<T>>`, I'd stick with just the static version.
 =||= The `switchDo` issue has been fixed by deleting the instance method in version 0.12. It has also been renamed to `switchOnNext`.
 =||= Start of wrapper for discussion: https://github.com/Netflix/RxJava/pull/338
 =||= Anyone want to continue this discussion?

@daveray I know you have for more mature Clojure bindings internally, do you want to close this and re-open a new discussion when you have a pull request ready?
 =||= Closing out ... if and when there is something concrete regarding Clojure improvements please open a new issue or contribute a PR.
 =||= ,0
7282,335,Support for Android events,Hello,

**TL;DR: I want to contribute on Android support**

In the past few weeks I'm become very interested in FRP in general, and how it applies to better wire code in GUI applications - my main interest is to build more elegant Android code.

So, I found that here on RxJava there is an initial code to support run RxJava on Android, which is really awesome! So, I've started to work on some code to try to grasp how to work with Rx.

After that, I want to have some helper methods to transform Android event listeners into RxJava's `Subject`s, so we can really start to make it useful to cleanup our `Activity`/`Fragment` code.

There is something like that waiting to be published? Can I start to draft some implementation? Someone is taking this task and want some help?

@mttkay I saw that you commited on this "area" of the project... are you the person to ask about this stuff?

Thank you all for the attention and sorry about the large message :smile: ,Hi Andrew,

at SoundCloud we're using RxJava on the service layer. With the exception of adapters, which can be hooked up nicely to an Observable exposed by a service object, we haven't given other UI components much thought. The main reason I guess being that there is less to be gained out of it. I see RxJava's main benefits in the reliability and ease gained where asynchronous event composition is required. However, neither seem very likely to me to occur in, say, a TextView or other widgets/UI components. When I say that I suppose I mean RxJava specifically, not FRP in general. ReactiveCocoa for instances takes Rx into the view layer, but it supports heterogeneous signals that can be mapped to view properties, which is very powerful since it allows a view to directly react to state change emitted by an observable sequence. With (Rx)Java one would have to jump through a few hoops to accomplish that.

That's not to say I'm not interested in investigating in that direction! If you have ideas or even some working components already I'd be curious how such a solution could look like. I'll be on vacation for 2 weeks starting Tuesday, so apologies if I reply infrequently.
 =||= That reminds me. Another area where I think RxJava adds benefits and convenience on Android is when used as a simple event bus. Due to its nature it's extremely simple to build application global pub-sub style interaction with Rx. The `Subject` class lends itself well for that, since every system event can be described using a `Subject` to which observers subscribe. I wrote a tiny event bus using a Java enum, in which every enum constant was a Subject. The enum had a `fire` method to signal each event, so that observers would receive it. The data transmitted through the subject could then be an event object. 

That way you can e.g. fan out a state change to multiple views at once. I can see also benefits in this in replacing many occasions where Intents or Handler messages are cumbersome to use.
 =||= @mttkay Thank you for the response and the nice share of experiences :smile: 

My idea with the event support is to remove the logic from `Activity` by creating new objects, in a similar way to `ViewModel`/`Passive Presenter`. So we can write our business logic and test in separation from Android code. Even without any separation, our code becomes much more declarative, and I think that we could have some benefit from this approach.

I will try to put some experimental project online and link here so you can see what I'm talking about.

Thank you again for your attention.
 =||= Hello!

Here is a [short example](https://github.com/andrewhr/rxjava-android-example) of what I'm thinking about with extending RxJava. The implementation of the `Events` and `Properties` is quite naive, but served as a sort of API exploration.

There is anyone who also thinks that this extensions are useful?
 =||= I definitely find this useful. Especially as it can be combined with Scala even for Android development.
 =||= Thanks @jmhofer for the feedback. I will continue to explore in a separate project before making any PR to official project.
 =||= Andrew,

this looks very interesting and in fact I sat down the other day to think
about how this could look like and came up with something very similar.

I was wondering if you guys already use this in production? I would not
like the idea of adding features to the library prematurely, not unless the
code has proven to work in a number of production scenarios.

I will also start to dabble with it when I'm back from vacation, I'm still
traveling for the next 10 days.

Thanks for working on this! It could go a long way in getting
rxjava-android closer to the feature set of ReactiveCocoa.
On Sep 7, 2013 3:02 AM, "Andrew Rosa" notifications@github.com wrote:

> Thanks @jmhofer https://github.com/jmhofer for the feedback. I will
> continue to explore in a separate project before making any PR to official
> project.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/335#issuecomment-23978488
> .
 =||= Hello @mttkay,

Honestly, we don't have any code in production... yet. I'm still trying to get around the concepts. But I agree with you that we need something more _solid_ to put into RxJava itself.

What I've started to do was converting some code from our apps to Rx model, and in the past days I've done for a meaningful amount of the codebase. This is helping me to evaluate and extend the helpers I've published before.

As soon I ship this application I can give more concrete feedback about the experience.

Thank you again for the attention spent here. I really appreciate!
 =||= Sounds good! Looking forward to it
 =||= Hi, @andrewhr, I also think this is very helpful. However, I have one problem about Android events. Most of Android listeners are set via set***Listeners. If some view has already been set a listener, how do you handle it? Override it directly? Or wrap the old listener in a new listener?
 =||= Hi @zsxwing!

Actually, I have only one project in production, which was ported to use the helpers similar to those on the sample project that I shared.

In the current implementation, I found the exact problem that you described. I opted for just override the listeners. The few cases where I need to reuse an observable, I just create a temporary reference for reusing. I though that it's fine because my in this first attempt I only want to experiment with some sort of API (and also want to gain some experience with the tools... this is my first real project with FRP style).

I've never tough about listener overriding before, but I've imagined some kind of Context-like object to create the observers, instead of just using static helpers... so it can keep all references and memoize if necessary. But I'm afraid that it would to some over complication :worried:
 =||= Is work still happening on this issue? 
 =||= Closing out as this thread has gone quiet ... please re-open or start something new if applicable.

The RxJava Google Groups is a good place for discussion as well: https://groups.google.com/forum/#!forum/rxjava
 =||= ,0
7282,337,Added the window() operation.,window() returns an Observable<Observable<T>> that will chunk the source observable
based on several criteria; counts, time etc.

This differs from buffer() in that the underlying observables will all onComplete()
independently from their upstream Observable.,[RxJava-pull-requests #224](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/224/) SUCCESS
This pull request looks good
 =||= For consistency with `buffer` it seems like all the `Observable.window` methods should be instance methods rather than static.
 =||= ok. Missed it when porting into 0.11.1

I've forced-pushed my amended commit.
 =||= [RxJava-pull-requests #225](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/225/) SUCCESS
This pull request looks good
 =||= Now documented on the wiki (marble diagrams TBD):

https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window
 =||= Let's switch over to https://github.com/Netflix/RxJava/pull/349 for review as this pull request is out-of-date with master.
 =||= ,0
7282,342,Rename switchDo to switchOnNext?,I really don't like the 'switchDo' name and am considering renaming to 'switchOnNext' since that's what it does. Ofcourse this is all because we can't use 'switch' as it is a reserved word. 

Agreement? Disagreement?,Just submitted pull request for this ... does anyone have an opinion? People I've asked agree with changing from `switchDo` to `switchOnNext`.
 =||= `switchOnNext` is a better name. Works for me.
 =||= I agree. `switchOnNext` is a lot better.
 =||= Proceeding then, that's enough votes for me.
 =||= Yeah, `switchOnNext` is a lot better! Since the PR is merged, can't we close this?
 =||= ,0
7282,338,Extremely rudimentary auto-generated Clojure wrapper. (DO NOT MERGE),Proof(?)-of-concept for rxjava issue #334. Please do not merge.,No feedback in a long time. Closing.
 =||= ,0
7282,339,Garbage Creation,Hi,

Do you use object pooling to prevent garbage being produced? Can this run without GC activity for a few weeks at least?

Suminda,No it does not use pooling. By definition Rx uses composition and if object allocation is a concern to you then it should not be used.  We use Rx extensively in the Netflix API without full (stop-the-world) GCs, but the young gen is constantly cleaning garbage. Our JVMs are tuned to handle the garbage throughput of Rx, Hystrix, JSON/XML/Thrift/etc serialization/deserialization and all other object allocations of the JVM. We (nor this library) do not attempt to fit the constraints of something like a financial trading application which pursues no object allocation at all. 
 =||= @benjchristensen Will you be willing to share some of the strategies you used for tuning the JVM? Which garbage collector do you use currently?
 =||= ,0
7282,337,Added the window() operation.,window() returns an Observable<Observable<T>> that will chunk the source observable
based on several criteria; counts, time etc.

This differs from buffer() in that the underlying observables will all onComplete()
independently from their upstream Observable.,[RxJava-pull-requests #224](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/224/) SUCCESS
This pull request looks good
 =||= For consistency with `buffer` it seems like all the `Observable.window` methods should be instance methods rather than static.
 =||= ok. Missed it when porting into 0.11.1

I've forced-pushed my amended commit.
 =||= [RxJava-pull-requests #225](https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/225/) SUCCESS
This pull request looks good
 =||= Now documented on the wiki (marble diagrams TBD):

https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window
 =||= Let's switch over to https://github.com/Netflix/RxJava/pull/349 for review as this pull request is out-of-date with master.
 =||= ,0
7282,336,Idiomatic Scala Support,As of version 0.11.0 Scala support is provided through the use of implicits. Conversations on Twitter are bringing up other possible improvements. Let's use this issue to discuss.  ,A few comments from my point of view (since I first looked at this project, I always wanted to use it from Scala):

Now that the core is typesafe, imho we have the first workable Scala integration (via implicits). From here on, everthing depends on how much effort we want to put into this vs how convenient it will be for the users.

What we already have is that the most important method names match (`map`, `flatMap`, `filter`). Matt also made Scala for-comprehensions work with observables.

There's a lot of room for improvements, though. It seems that due to Scala-Java interop, there are problems with type inference (I even ran into a Scala compiler crash somewhere), and sometimes `asJava` collection conversions are necessary. Also, Scala/Akka futures are not yet addressed at all. An Akka-specific scheduler would probably be awesome to have, too.

For full Scala user convenience, we'd probably have to completely wrap `rx.Observable` into its own `rx.scala.Observable`. This would mean a lot more maintenance effort for the Scala integration, of course (I don't think we can do this automatically via code generation or macros, but I'm no expert of all that). But still, I think it's well worth it to create a dedicated Scala API.
 =||= 1) Implicit-based integration with Java-based observables has a serious flaw as it doesn't support parameter type inference for lambdas. The situation isn't going to change until https://issues.scala-lang.org/browse/SI-6221 is fixed. It's definitely fixed in 2.11, and at EPFL we have a compiler plugin that backports the fix to 2.10. Probably Typesafe folks can be convinced to do the backport in one of 2.10.x releases (/cc @adriaanm @gkossakowski @retronym @JamesIry).

2) Some features that might be desirable in `rx.scala.Observable`: a) native function types, b) native collections, c) method names familiar to folks that use native collections, d) making parameter of `defer` by-name, e) creation of Observables via `apply` rather than via `from`.

3) I also don't think that macros can help with `rx.scala.Observable`, because what you're probably after isn't just a copy/paste of a Java API, but rather a redesign that takes Scala features into account. But if there are some things that can be autogenerated, I'll be happy to answer questions about how macros work and how they can be used.
 =||= IMHO, after looking at the code, using implicits convertions is not a good idea.

I think you have better to start with a complete wrapper of the API, then you'll be able to apply scala idiom (basically writing a DSL) instead of having a Java API with some facilities for converting type.

And that way you don't have to wait for https://issues.scala-lang.org/browse/SI-6221 ... which sounds anyway like a clumsy integration of Java API to me.
 =||= Here is some [background](https://github.com/Netflix/RxJava/issues/204#issuecomment-15249648) on why the current design was chosen rather than having each language with a separate version of Observable:

---

The approach of having language specific packages/classes was pursued but did not work well because Rx is a composable library. It means that every time an `Observable` is used it needs to be re-wrapped or un-wrapped by whichever language is using it.

For example ...

From Java a library is exposed that has a method like this:

``` java
rx.Observable getData()
```

From Groovy a library is exposed with a method like:

``` java
rx.groovy.GroovyObservable getOtherData()
```

Then from Scala you need to wrap them again:

``` java
rx.scala.ScalaObservable.from(getOtherData())
```

This means we have an `rx.Observable` wrapped as `rx.groovy.GroovyObservable` wrapped as `rx.scala.ScalaObservable`.

To compose the two we would have:

``` java
rx.scala.ScalaObservable.zip(rx.scala.ScalaObservable.from(
      getOtherData()), 
      rx.scala.ScalaObservable.from(getData()),
       ... scala closure here ...);
```

Now what does `ScalaObservable` return from its operators? `ScalaObservable` or `Observable`?

Should the above zip operator return `rx.scala.ScalaObservable` or `rx.Observable`? What happens if this library is consumed from another language?

If `Observable` each step along the way it must be wrapped yet again. If `ScalaObservable` it has now changed all of the return types of `rx.Observable` to a subtype.

In short, for interop between languages it very quickly becomes a mess and our primary polyglot goal was that `rx.Observable` was usable across all libraries as the single type and because the whole point of Rx is chained composition it's not as simple as just a single decoration at the beginning. It affects every single method in an API and step of the chaining.

For this reason we chose the current language-adaptor model so `rx.Observable` can remain the sole public interface across languages.
 =||= Thanks for providing the design notes!

I wonder though how often people tend to mix languages in their projects. Usability improvements in switching from a Java-based least common denominator to an idiomatic API might be significant. Does being polyglot overweigh these improvements?
 =||= I'm not sure if wrapping `Observable` for Scala (not in a subclass though) would really hurt so much. Imho it's worth a try to find out how it feels. There will be a lot of wrapping and unwrapping behind the scene though, I'm afraid.
 =||= At Netflix we are using Clojure, Groovy, Java and Scala and I know of apps running code from at least 3 of those 4 in the same JVM instance. I imagine it's not common in most environment for this type of diversity, but it is something we have wanted to support as seamlessly as possible. This is because we have wanted the `rx.Observable` to act as the interface we can expose across module boundaries as it naturally ends up at the edge of the API in methods such as `Observable<T> getDataFromService(args)`. This is part of what drove us to target the JVM with RxJava and not any specific language.

That said, an idiomatic solution that works best for pure Scala apps is more important. If we can find a solution that can retain the use of `rx.Observable` without a completely separate wrapper then great, otherwise let's have a `ScalaObservable` for pure Scala apps and a way of going back and forth across language boundaries when it's needed. Perhaps the implicits that exist right now can solve the immediate interop needs for easy interaction from Scala to Java, but the option to convert to `ScalaObservable` would also be there.

Another piece of information to guide this ... the Rx.Net version in C# is defined by simple interfaces for `Observer` and `Observable` without any of the operator interfaces on them. All of the operator methods (static and instance level) are added via extension methods. It's quite clean and makes the interfaces more flexible (anyone can easily implement them and the extension methods are 'just there' without inheritance involved).

The reason RxJava has `Observable` as a concrete class is because extension methods don't exist in Java so we don't have a choice but to have them as concrete methods to enable the fluent chaining pattern.

In Scala however we do have extension methods (implicits), macros etc that theoretically can allow the `rx.Observable` to be made into whatever it needs to be for idiomatic Scala usage, similar to how C# implements Rx.Net using extension methods. I imagine a possible issue is if existing methods on `rx.Observable` are in the way and cause problems in achieving idiomatic Scala functionality, if that's the case I'd like to understand what those issues are and if they can be resolved and if not if they really are deal breakers.

At this point I become not so helpful as I am not skilled enough in Scala to have a valid opinion or guide the conversation much further. I do have some questions though for the Scala experts here:

1) What would make `rx.Observable` idiomatic for Scala?

I'd like to see unit tests or sample code demonstrating expected behavior and usage so that we're all working towards the same goal and know when we've achieved success.

2) What about the current `rx.Observable` + Scala implicits is not working well?

3) What requirements of (1) can not be achieved with implicits and macros and requires a separate concrete class as a wrapper?

Thank you everyone for your involvement, I really do want us to find the ideal solution for Scala and then as a secondary priority make it work well across the JVM for polyglot applications.
 =||= Thank you for your swift feedback! It's a pleasure to help.

1) I'm not an Rx expert, and in fact this is the first time I see any Rx code apart from random snippets in web articles, so please don't treat this list as definitive. Comprehensive analysis would require quite some time, and I'm not sure I have it right now.

a) `Observable.from` could be replaced by `Observable.apply`, so that one can write `Observable(1, 2, 3)` instead of `Observable.from(1, 2, 3)`.

b) It shouldn't be necessary to write `asJava`, e.g. as in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L349, and `asScala` (not sure whether it's necessary now).

c) Use of mutable collections in situations like https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L350 is really inconsistent with Scala's pursuit of immutability. I wonder whether it'd be possible to write such code in a functional way.

d) Instead of taking a no-arg function, `Observable.defer` could take a by-name parameter, which would obviate the need of creating an explicit closure: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L232.

e) For a former C# developer like me, method names like `lastOrDefault` sound familiar, but for the Scala croud out there - not so much. How about changing the names and maybe even signatures, so that they mirror method names of native collections? E.g. `lastOrDefault` could become `lastOption` (also note the change from default values to options).

f) I'm also not sure whether extension methods are even necessary. From what I would guess, in C# they are forced to use them, because interfaces can't define methods with implementations (at least, that was the story with `IEnumerable` and `Enumerable`). In Scala, we can do that, so why not just put all the combinators in `Observable`?

g) `mapMany` in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L351 is essentially `flatMap`, right?

h) No idea how this name could be stated more succinctly, but `toBlockingObservable` feels a bit verbose. When I moved from C# to Scala, in people's code I felt an overall tendency to compress everything, including names. This is kind of a vague observation, so feel free to ignore it.

2) Function literals don't support inference for parameter types unless they are used in a context that requires a Scala native function type. In particular, inference won't work if function literals are supposed to be converted to something implicitly. 

E.g. in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L341 one can't drop type annotations for lambda parameters. I tried removing them and got a compilation error. (Btw why are you using 2.10.1, when 2.10.2 is already available for quite long? Did you have any problems with it?)

That's an instance of https://issues.scala-lang.org/browse/SI-6221, which has been fixed in 2.11 and probably could be backported to 2.10. If you're in need of an immediate solution, we at EPFL have a compiler plugin for 2.10 that provides a backport.
 =||= Excellent observations about the API @xeno-by. Currently, we are preparing exercises for the Coursera class [Principles of Reactive Programming](https://www.coursera.org/course/reactive). For this course we would like to make an idiomatic Scala API. @samuelgruetter is working on that. 

The cross language compatibility pointed out by @benjchristensen is a reasonable concern. However, I think there is a lot of monolingual projects out there that would greatly benefit from the idiomatic Scala library. It seems to me that  adding a Scala wrapper can be only a plus in those cases. 

For polyglot projects we could also take the Java rx.Observable as a common ground (being a return type of each operation and in API signatures). Then all of the Scala support can be added by an implicit conversion (rx.Observable => rx.ScalaObservable). 

As a long-shot maybe the interface for multi and mono lingual projects can be unified so that we do not repeat our selves. IMHO it is worth a try. 
 =||= Thanks for all the observations! I'll try to address some of the ones from @xeno-by.

1a), 1e) and 1g) are just aliasing problems, imho. We already have `flatMap` as alias for `mapMany`, and the other aliases could easily be added, either directly in `rx.Observable`, or in a Scala wrapper, if the namespace gets too big otherwise (not my preferred solution). Methods returning options will have to live in a Scala wrapper, however.

I didn't take a look at 1b) and collection conversions yet. This really shouldn't be necessary often, if at all.

1c) You're looking at test code here which tests the callback "at the end of the world". This is not really normal usage of the API. The whole RxJava codebase is refreshingly (though not completely) free of mutability, if you ask me. Also, the Rx API is actually there to allow you to handle all your events in a functional, immutable way. - In short, I don't see a problem here.

1d) is Scala-specific. By-name parameters are a great feature for methods like `defer`, I agree. We should make use of them in the Scala wrapper.

I'm not worried about 1f) either.

1h) I like the verbose name in this specific case. Imho, it's the same as `asInstanceOf` in Scala: Maybe I'm evil, but I like to punish people who do things they probably shouldn't do. :) Ok, there will of course be valid use cases for blocking observables, but there shouldn't be too many of them, hopefully.

2) is quite a big problem, if you ask me. A backport of the fix to Scala 2.10 would be great. We can probably get around this with a dedicated Scala wrapper, though.

And the reason for 2.10.1 instead of 2.10.2 is currently just a technical problem with the build system. I, too, hope that this will be fixed soon.
 =||= 1c) Even that can be made functional if you replace the subscribe() with .toList().toBlockingObservable().single();
 =||= @abersnaze You're right, good point.

I started a little experiment with a more idiomatic Scala wrapper. It's just humble beginnings currently, though. You can find it [here](https://github.com/jmhofer/RxJava/blob/scala-wrapper/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala). 

Comments and forks are welcome, of course. I started from the super-extends pull request in order to check how this whole thing feels in Scala.
 =||= Scala 2.10.2 support was added in version 0.11.2 (https://github.com/Netflix/RxJava/releases/tag/0.11.2).
 =||= > 1) Implicit-based integration with Java-based observables has a serious flaw as it doesn't support parameter type inference for lambdas. The situation isn't going to change until https://issues.scala-lang.org/browse/SI-6221 is fixed. It's definitely fixed in 2.11, and at EPFL we have a compiler plugin that backports the fix to 2.10. Probably Typesafe folks can be convinced to do the backport in one of 2.10.x releases (/cc @adriaanm @gkossakowski @retronym @JamesIry).

Sorry, we don't change type inference in minor versions unless there's a critical bug.
The risk of regression in source compatibility is too high.
 =||= > The cross language compatibility pointed out by @benjchristensen is a reasonable concern. However, I think there is a lot of monolingual projects out there that would greatly benefit from the idiomatic Scala library. It seems to me that adding a Scala wrapper can be only a plus in those cases.

I completely agree if a wrapper is the only way to achieve idiomatic support. Monolingual projects should take first priority as that is the common case.
 =||= We believe that the following solution would be best:
-   Implicit value class (let's call it `ScalaObservable` for the moment) wrapping an rx.Observable
-   all return types are `rx.Observable`
-   Since `ScalaObservable` is a value class, there is no runtime overhead for the wrapping (some explanations can be found in the second half of this [blog post](http://www.blog.project13.pl/index.php/coding/1769/scala-2-10-and-why-you-will-love-implicit-value-classes/)). This is new in Scala 2.10, and actually allows us to have extension methods similar to C#.
-   An object `FunctionConversions` containing all implicit conversions from Scala functions to Rx functions (the same as in the present [Scala adaptor](https://github.com/Netflix/RxJava/blob/rxjava-0.11.1/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L29)). These conversions are only used by the adapter, users of Scala Rx won't use them.
-   All instance methods of `rx.Observable` which take a Func or an Action have a wrapper method in `ScalaObservable` whose signature has Scala functions and whose body uses the conversions from `FunctionConversions`
-   `ScalaObservable` has map, flatMap, filter, like in the [present adaptor](https://github.com/Netflix/RxJava/blob/rxjava-0.11.1/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L108) to enable for comprehensions
-   `ScalaObservable` has `lastOption` method instead of `lastOrDefault` etc
-   functions passed by Rx Scala users to Observable needn't be implicitly converted, so we're not affected by the [bug](https://issues.scala-lang.org/browse/SI-6221) that parameter type inference of implicitly converted functions does not work in Scala 2.10
-   An `object Observable` with `apply` methods instead of `from` and `create`
-   polyglot projects can also use this approach

I've started to implement such an adapter and will post some code soon.

Note that I've not (yet) addressed the following points:
-   compatibility with Scala/Akka futures
-   how to integrate `ScalaObservable` with Scala collections to get all methods of Scala's [Traversable](http://www.scala-lang.org/api/current/index.html#scala.collection.Traversable)
 =||= @samuelgruetter Sounds awesome! Very much looking forward to your sharing the code.
 =||= You can see what I'm doing [here](https://github.com/samuelgruetter/rx-playground/blob/master/RxScalaAdapter/src/main/scala/ScalaAdapter.scala). Note that it's still very incomplete and not yet tested, but work is in progress.
 =||= Great, thanks! I'll play around with it, too.
 =||= @samuelgruetter All of that sounds great.  I'll take a look next week and offer feedback.
 =||= There's an interesting problem with `map`: If I add an explicit conversion like `ScalaObservable(numbers).map(...)`, it works, but without, i.e. `numbers.map(...)` gives an error... I'll investigate on this. You can see the corresponding test [here](https://github.com/samuelgruetter/rx-playground/blob/365a7ba8afa4feda1f5961a3a21c524092caf8f4/RxScalaAdapter/src/main/scala/rx/lang/scala/Adaptor.scala#L497)
 =||= Maybe there's a 2nd implicit somewhere, adding map?
 =||= @samuelgruetter what is the error? if @jmhofer is right you should have an `amibgous` implicit resolution error.
 =||= If anything about the core Java library is causing issues let me know.
 =||= There's no 2nd implicit, but there's a second `map`: The `map` in rx.Observable. And scalac wants to use this one and does not convert to `ScalaObservable`. However, with `reduce`, it works...
 =||= Just another guess, but then it's maybe due to the type parameter of `map` (your `reduce` doesn't have one; you renamed the one with type parameter to `fold` which luckily avoids the problem).
 =||= Covariant support has been merged into master. This also changes the type used with `Observable.create`.
 =||= I believe all of the structural changes are now merged to master. Are there any other changes that should be made before we release 0.12 so as to better support Scala integration?
 =||= I've isolated the implicit conversion problem [here](https://github.com/samuelgruetter/rx-playground/blob/master/ScalaImplicitsProblem/src/main/scala/ScalaImplicitsProblem.scala). It's a problem with the Scala compiler.
@benjchristensen looking forward to a jar with covariant observables!
 =||= @samuelgruetter I'm pretty sure no one could make the scala compiler be able to solve an ambiguity like that one.

If you where the compiler, which method you think should be choosed?

You guys should seriously consider implementing a full wrapped scala version first, and keep multi-lang support as a cherry on cake.

IMHO it's a mistake to do the opposite, maybe I'm wrong but I think most scala user will want to use it in a full scala project.

And for the course, it would be good to have an idiomatic API.
 =||= scalac is indeed inconsistent, it goes the extra mile to try an implicit view when the originally tried method is monomorphic, but doesn't do the same if it is polymorphic.

That's unlikely to change soon, even in 2.11.

But, one change that is likely in the 2.11 timeframe is first class support of SAM types, which would let you write an anonymous function that would be translated to `rx.Func1`.

BTW, it's really great to see this discussion and cooperation happening!
 =||= So, to make polymorphic methods like `map` work, we'd have to return ScalaObservables, not (Java)Observables everywhere, I guess (which doesn't pose a problem anyway as far as I can see)?

@aloiscochard: Is that what you mean by "a full wrapped scala version"? - Because I thought that @samuelgruetter's goal was already to create a full wrapped scala version.
 =||= @jmhofer yeah it's exactly what I meant :-)

By doing that you'll be able to provide the best possible syntax for RX API, looking forward next enhancement!
 =||= @samuelgruetter is there something we can do in the short-term to work around this issue? Is there anything about the core library that if changed would simplify this effort?

@aloiscochard What about the approach being pursued (if the compiler bugs didn't exist) is a mistake?
 =||= @benjchristensen I don't see any problem with switching to the approach where we stay with intermediate ScalaObservables throughout the wrapper. As `ScalaObservable` is a value class, it shouldn't even impact performance at all.
 =||= I agree with @jmhofer. I've started such a Scala Observable which always returns Scala Observable, see [here](https://github.com/samuelgruetter/rx-playground/blob/master/RxScalaAdapter/src/main/scala/rx/lang/scala/Observable.scala)
 =||= @benjchristensen I would say it's kind of bad design, a form of overloading abuse. I would go the type-class way (on a similar Wrapper than @jmhofer one) to make a map function polymorphic.

Anyway, the current approach took by @samuelgruetter looks good!
As @jmhofer said there should be no perf impact as long as you keep a value class, and from what I've seen there should be no reason to need more than one value in the wrapper.

I have some remarks but I'l make them directly on @samuelgruetter commit as I did before.
 =||= @benjchristensen I'm confused about the jar releases. I thought they have contained @jmhofer 's changes for proper covariance/contravariance handling since 0.11.2, but apparently they don't:

In `rxjava-core-0.11.3.jar`, `flatMap` looks like this:

```
public <R> Observable<R> flatMap(Func1<T, Observable<R>> func) {
    return mapMany(func);
}
```

On github master, `flatMap` looks like this (that's what I would like to have in the jar):

```
public <R> Observable<R> flatMap(Func1<? super T, ? extends Observable<? extends R>> func) {
    return mapMany(func);
}
```
 =||= @samuelgruetter If I'm not mistaken, there was no release yet after the merge of the co-/contavariance branch. 0.11.3 was right before that. I'm afraid that you'll have to wait for 0.11.4 (or 0.12, more likely), or you'll have to work directly on the repo build of RxJava.
 =||= Those changes will be in 0.12 which has not been released yet. It was merged to master yesterday. 

Before releasing I wanted to determine if this thread of discussion required any further changes to core, and I want to get in https://github.com/Netflix/RxJava/pull/349 as well since it generalizes some objects in `rx.util` which hopefully gets confirmed today.

Is there anything else that if done in core for release 0.12 would improve Scala support?
 =||= I can't currently think of anything that if done in core for release 0.12 would improve Scala support. But probably I'll find such things just after 0.12 is released ;-)
 =||= Then once I wrap up those other things (hopefully today) I will release 0.12. I fully expect we'll find more to change ... hence us not being at 1.0 yet :-)
 =||= Due to the 2 bugs, are we unable to pursue the route where `rx.Observable` is the return type at this time?

Also, since I'm unfortunately not yet very experienced with Scala, in your examples would you mind demonstrating a use case where a ScalaObservable is exposed back to Java for interop? I'm interested in understanding how the solution being worked on would function in polyglot environments (while understanding this is a secondary priority).
 =||= if you call `.wrapped` on a `ScalaObservable` you get back the original `Observable` which can be used with the Java API.

Maybe we could find a better name that wrapped, not easy though ;-)
 =||= I'd prefer calling `.wrapped` `.asJava` instead (like the collection `JavaConverters` do).
 =||= Version 0.12 has been released. 
 =||= I've forked the RxJava repo and I'm now working [here](https://github.com/samuelgruetter/RxJava/blob/idiomaticscala/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala).
 =||= @samuelgruetter great stuff!
 =||= @samuelgruetter Good idea!

And: Yay, finally a covariant observable! Awesome! I've been working towards this all the time...
 =||= Well now I have a Scala compiler bug... It's [here](https://github.com/samuelgruetter/RxJava/blob/idiomaticscala/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala#L168). I don't know yet what to do about that.
 =||= @samuelgruetter  You can work around the bug by explicitly provide a type argument. I've isolated and reported this issue, along with the workaround, here: https://issues.scala-lang.org/browse/SI-7818
 =||= Try it with an explicit type parameter for the Java method: `new Observable(JObservable.synchronize[T](asJava))`

Works for me, at least.
 =||= Thanks @retronym. Is this going to be fixed in Scala 2.10.x? I'm asking because we want to use the Rx Scala Wrapper for a course in November, and we don't want to confront students with compiler bugs. So we consider temporarily removing `extends AnyVal`, until the interplay between value classes and covariance can be considered stable.
 =||= @samuelgruetter The particular bug only affects you when you define the value class. Clients of the class are safe.
 =||= ok, so we'll keep using `extends AnyVal`, unless it leads to more problems...
 =||= This [Observable.scala](https://github.com/samuelgruetter/RxJava/blob/955fbfcdfdd2ce12ac2ee578d63c8edd734f8444/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala) now contains all methods present in the Java Observable, **but** for many of them, there is only a comment containing their signature and a note on the problem I faced. You can find all these interesting problems by searching for `TODO`.
 =||= [![Code Bounty](https://app.codebounty.co/reward/image/6b82995d8cf0ea7678754a98)](https://app.codebounty.co/reward/link/6b82995d8cf0ea7678754a98)
 =||= I'm planning to continue as follows:
-    Add some tests to `Observable.java`. Their goal is not to test the correct behavior of the methods (that's already done in the unit tests of the operations), but to test if the method signatures of `Observable` are good, and to provide small usage examples.
-    I expect these tests to reveal some issues related to covariance. Fix these.
-    Continue with the Scala adaptor.
 =||= @samuelgruetter I just took a quick look, nice progress.

Looks like most of your issues are related to covariance, I haven't look in depth but there is some trick to workaround this kind of thing in scala... not sure if possible to apply them here.

I'll try to take a look during the week and give you feedback... not sure when unfortunately.

I've seen some comments where you hesitate returning the scala wrapped version or the java one, I would say that for a first version, just return the scala one.

You can refine that later trying to find where you can return the native type, IMO it's a nice to have but clearly not absolutely needed when using the API in pure scala.

About `Future`, I think it should be quite easy to create a wrapper to expose scala future as java one, have you tried implementing the java future interface backed by a scala one?
 =||=  @samuelgruetter Could you explain the problem with the `reduce` signature please?

Do you mean by your TODO that this needs a second type parameter `U` with `U extends T` etc instead of simple wildcards in Java, too?
 =||= I think that `reduce` needs a type parameter `U` with `U super T` in the Java Observable. And similar changes will be needed for other methods as well, in order to make sure that the `T` of `Observable<T>` never occurs in a contravariant position. I'll post corresponding code soon.
 =||= I added tests to [CovarianceTest.java](https://github.com/samuelgruetter/RxJava/blob/b59b68d7361bbb01604e2feaeba904a6b4cbd85c/rxjava-core/src/test/java/rx/CovarianceTest.java), which I would like to compile, but they don't, and I think that the signatures in `Observable.java` need to be tweaked.
The tests which do not compile are marked with `might-not-compile`.
I will now try to tweak `Observable.java` as needed.
 =||= The signature of `reduce` in `Observable.java` currently looks like this:

```
public Observable<T> reduce(Func2<? super T, ? super T, ? extends T> accumulator) {
                                                        ^^^^^^^^^^^
```

The problem with this is that the underlined `T` appears in a contravariant position. This means that we cannot say anymore that `Observable<T>` is covariant in `T`, and we cannot use Observable as we would like to:

```
public void libraryFunctionActingOnMovieObservables(Observable<? extends Movie> obs) {
    Func2<Movie, Movie, Movie> chooseSecondMovie = 
        new Func2<Movie, Movie, Movie>() {
            public Movie call(Movie t1, Movie t2) {
                return t2;
            }
        };
    Observable<Movie> reduceResult = obs.reduce(chooseSecondMovie); // <- weird error
    // do something with reduceResult...
}

public void codeUsingTheFunction() {
    Observable<HorrorMovie> horrorMovies = Observable.from(new HorrorMovie());

    // do something with horrorMovies, relying on the fact that all are HorrorMovies
    // and not just any Movies...

    // pass it to library (works because it takes Observable<? extends Movie>)
    libraryFunctionActingOnMovieObservables(horrorMovies);
}
```

The above code should compile, but instead produces a weird compilation error.

Now let's see how Scala solves this: The signature of reduceLeft in the Scala immutable collections (which are covariant in their type parameter `A`) looks like this:

```
def reduceLeft[B >: A](f: (B, A) => B): B
```

The trick is to add a type parameter `B` to the method, whose lower bound is `A`. Now `A` only appears in covariant positions, and we're fine.

So I thought we could just do the "same" in Java:

```
public <U super T> Observable<U> reduce(Func2<? super U, ? super T, ? extends U> accumulator)
```

But, unfortunately, Java does not support lower bounds for type parameters.

So, this makes me think that Java's type system is not powerful enough to properly support covariant Observables.

Because of this, I will now return to the Scala adaptor, and try to implement a covariant Scala Observable, which uses casts where necessary. If we later find a way to get rid of the casts, all the better.
 =||= I think it would be possible to work around that by making `reduce` static and giving it two type parameters `<U, T extends U>`. With this, we could probably simplify the type parameters of the instance method, dropping covariance in that place, and instead get the full covariance via the static method. Scala could just use the static method. 

I'm not sure whether we want that.

Or maybe there's a more direct workaround via casting (yuck). Haven't tried anything like that out yet.
 =||= It could go direct against the internal static operators instead of us putting an unnecessary static reduce on `Observable`.

``` java
Observable.create(OperationScan.scan(observable, accumulator)).takeLast(1);
```
 =||= Varargs have been removed from `Observable`: https://github.com/Netflix/RxJava/pull/361
 =||= Investigating issues with `reduce` covariance at https://github.com/Netflix/RxJava/issues/360#issuecomment-24128500.

It works when done statically instead of via an instance method: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/ReduceTests.java#L39
 =||= I can now confirm that the solution with value classes is indeed as awesome as we expected :D
I wrote a very small example showing how Java code can use Scala code: There's a [MovieLib.scala](https://github.com/samuelgruetter/RxJava/blob/0603e395b680655a923e138582d779c65d001651/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scalatests/MovieLib.scala), which uses Scala Observables everywhere.
In a second project, there is [MovieLibUsage.java](https://github.com/samuelgruetter/RxJava/blob/0603e395b680655a923e138582d779c65d001651/language-adaptors/rxjava-scala-java/src/main/java/rx/lang/scalaexamples/MovieLibUsage.java), which uses `MovieLib` as a class which uses Java Observables everywhere, because Scala value classes are such that the Scala Observables appear as Java Observables for the Java compiler.
The only challenge here is to set up the build process correctly: In this scenario, the Scala sources have to be built first, and then the Java sources. I achieved this by making a seperate project for `MovieLibUsage`, which depends on the project containing `MovieLib`.
 =||= Value classes are awesome. This means we don't even need to convert back to Java Observables anywhere. Thanks for the example.
 =||= Sounds great @samuelgruetter, I'm happy to hear that we can achieve idiomatic Scala and Java interop cleanly without converting back and forth!

Do the compiler bugs prevent us from moving forward or are their sufficient workarounds for now?

I am planning on releasing 0.13 with the changes merged to master shortly. Is there anything else you need to core to support `rx.lang.scala.Observable`?
 =||= We have sufficient workarounds for the compiler bug.

There's nothing fundamental that we need for the Scala adapter right now, but I'm currently trying to translate the dictionary autocomplete example written in C# from this [Rx Hands On Lab](http://blogs.msdn.com/b/rxteam/archive/2010/07/15/rx-hands-on-labs-published.aspx) to Scala to see what we can already do. For this, I miss the `distinctUntilChanged` and the `throttle` operator, so these are currently on top of my whishlist ;-)
 =||= The 'throttle' operator was just merged to master as `debounce``throttleWithTimeout`. See https://github.com/Netflix/RxJava/pull/368 for an explanation of the 3 variants of`throttle` that were committed.

We do not yet have `distinctUntilChanged` but that shouldn't be hard to get added.
 =||= That's great that workarounds exist so we can move forward, I look forward to hearing how the autocomplete example works.

If you can get that functioning is that strong enough evidence to move forward with it or are there still pieces of functionality lacking?

How do you envision ongoing maintenance of this class? Do all new operators added to `rx.Observable.java` required wrapping methods, or does it pass thru if a wrapper isn't there?
 =||= If I can get the autocomplete example functioning then I think that's strong enough evidence to move forward with it. We still lack operations in the wrapper, but it should be possible to add them all.

This adapter will require some maintenance. New operators added to the Java observable will have to be added to the adapter as well, and updates of the documentation too, because the signatures are too different to automate this. 
However, if really needed, one can always call `.asJava` on a Scala observable and use the Java methods directly, and if the implicit function conversions from Scala functions to Java Func/Action are imported, one could even use Scala functions. But that's not the intended way of using it and should only be used in quick hacks.
 =||= Good to know regarding maintenance ... we'll need to figure out a reasonable way of handling that as operators get added.

Do you have an idea of when I should expect a pull request with this new Scala Observable?

Is this a breaking change to how the implicits support currently works for Scala, or does this wrapper only take effect when someone imports `rx.lang.scala.Observable` instead of `rx.Observable`? Can the existing implicits continue existing alongside?
 =||= It's not a breaking change: The old `RxImplicits` are still there and usable, but marked as deprecated.
 =||= So does it make sense to mark them deprecated since they're still usable and possibly useful for someone accessing operations that haven't made their way to this curated wrapper? Just checking.
 =||= If an operation from `rx.Observable` has not yet made it to `rx.lang.scala.Observable`, there are the following solutions (ordered by my preference):
-    report an issue to get the operation into `rx.lang.scala.Observable` ;-)
-    call `.asJava` on the Scala observable and use the implicit conversions from `rx.lang.scala.internal.ImplicitFunctionConversions`
-    use the old `RxImplicits`
 =||= Btw `RxImplicits` and `ImplicitFunctionConversions` are almost the same, except that `ImplicitFunctionConversions` does not contain an `implicit class ScalaObservable`.
 =||= Pull https://github.com/Netflix/RxJava/pull/376 has been released in [0.13.1](https://github.com/Netflix/RxJava/releases/tag/0.13.1)

Thank you @samuelgruetter!
 =||= > Btw RxImplicits and ImplicitFunctionConversions are almost the same, except that ImplicitFunctionConversions does not contain an implicit class ScalaObservable.

With that one difference does it still require the two existing, or can `ImplicitFunctionConversions` perform the same functionality as `RxImplicits` and negate it's need? Or does having `RxImplicits` around still help for any use cases?
 =||= If there is already code out there depending on `RxImplicits`, we need to keep it to remain compatible with that code. If not, we can remove `RxImplicits` without any loss of functionality.
 =||= Given that there's no loss of functionality, I think it makes the most sense to remove `RxImplicits` and not introduce the chance of newcomers to RxJava depending on unsupported functionality.  I'll generate a pull request to this effect
 =||= Removing duplication makes sense. Since `rx.lang.scala.internal.ImplicitFunctionConversions` is escape hatch (besides manually using Func1 and friends) for stuff not covered by the Scala wrapper, would it make sense for it not to be in an internal package?
 =||= @mattrjacobs Good idea.

@daveray Well the goal should be that there is no such thing as "stuff not covered by the Scala wrapper"... Having `ImplicitFunctionConversions` in an internal package would increase the pressure to keep the Scala Observable in sync, which is a desired effect. And if we add a unit test as I outlined at the bottom of [this comment](https://github.com/Netflix/RxJava/pull/376#issuecomment-24439163), keeping the Scala Observable up to date would become easier.
 =||= Removing `RxImplicits` will be breaking for people until they change their import from `rx.Observable` to `rx.lang.scala.Observable` correct? If so I will bump the version to 0.14 when I merge this change.

Can someone also please update the README (https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/README.md) to show usage information to help someone get started?
 =||= @samuelgruetter It's up to you guys. I'll just leave with this: open source projects live a lot longer than the enthusiasm of their contributors so I'm skeptical of a wrapper that assumes it will always be kept completely up-to-date with complete coverage forever. If some third party decided to create a project of custom observables beyond what's in RxJava, those would be more difficult to use, assuming users respect the implication of "internal" in the package name. I'll go back to Clojure-land now :)
 =||= @daveray ScalaObservable has a method to get the wrapped Java Observable, so you should be able to use any method from its API.
And since the project is Open Source you can always send a Pull Request and improve it ;)
 =||= @martin-g Right. And if for whatever reason some poor Scala programmer finds herself in yucky Java-land calling these mehods, at least throw her a bone and make the Func implicits available in a non-internal package.
 =||= @martin-g Correct me if I'm wrong, but dropping down to using rx.Observable still mandates passing in `Func1/Func2`/etc.  Being able to use native Scala functions and the implicits in this case seems far better than forcing user code to new up these function types and pass them in.

After thinking about it, +1 to @daveray's idea of making both the value class and implicits available (with the value class preferred).  This will allow any temporary mismatch between `rx.Observable` and `rx.lang.scala.Observable` to be addressed by implicits while not impeding non-Scala developers from moving core along.
 =||= +1 on this. There are other places where `Func*` are used, such as `BlockingObservable` not yet wrapped, and as new things are added, if they don't yet have a full wrapper there should still be a way to use them with the implicits.
 =||= > it might be cool to have a unit test in which we encode the information "which Java method corresponds to which Scala method", and using reflection, we check if there is a Scala method for each Java method. So if a method is added to the Java Observable but not to the Scala Observable, this test would fail.
> 
> And if we add a unit test as I outlined at the bottom of this comment, keeping the Scala Observable up to date would become easier.

We can't make the build fail if `rx.lang.scala.Observable` is out of sync. We can't block the project from building and releasing just because a new operator is added and the developer adding it isn't comfortable deciding what the idiomatic Scala method signature should look like.

It needs to be an async process for Scala developers to add wrapper methods/classes. Since this is open source we can't control people's schedule and require quick turnaround on adding the wrappers. Ideally that will happen when new functionality is added, but we can't make building and releasing dependent on that.

Thus, I think we need to account for the fact that most things will have wrappers but very newly added functionality or fringe functionality may not and should still have a mechanism for being used.
 =||= If you want rxjava-core to evolve independently then perhaps rxjava-scala
and other language adapters should each be a separate top-level project
with its own release cycle.

On Mon, Sep 16, 2013 at 2:55 PM, Ben Christensen
notifications@github.comwrote:

> it might be cool to have a unit test in which we encode the information
> "which Java method corresponds to which Scala method", and using
> reflection, we check if there is a Scala method for each Java method. So if
> a method is added to the Java Observable but not to the Scala Observable,
> this test would fail.
> 
> And if we add a unit test as I outlined at the bottom of this comment,
> keeping the Scala Observable up to date would become easier.
> 
> We can't make the build fail if rx.lang.scala.Observable is out of sync.
> We can't block the project from building and releasing just because a new
> operator is added and the developer adding it isn't comfortable deciding
> what the idiomatic Scala method signature should look like.
> 
> It needs to be an async process for Scala developers to add wrapper
> methods/classes. Since this is open source we can't control people's
> schedule and require quick turnaround on adding the wrappers. Ideally that
> will happen when new functionality is added, but we can't make building and
> releasing dependent on that.
> 
> Thus, I think we need to account for the fact that most things will have
> wrappers but very newly added functionality or fringe functionality may not
> and should still have a mechanism for being used.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/336#issuecomment-24548044
> .
 =||= Erik Meijer and I have discussed this but it doesn't feel like the right thing to do, as it would hurt the JVM ecosystem more than benefit it if the different languages forked from each other. 

There is no harm in a new version of RxJava being released without the Scala adaptor adding the new functionality, as that is no different than a separate RxScala project not yet supporting it on top of the RxJava core dependency.

As we approach 1.0 the rapid iteration will slow and this will become less of an issue. Around that time as well the project may migrate into a different home than here.
On September 16, 2013 at 3:20:07 PM, Chris Richardson (notifications@github.com) wrote:

If you want rxjava-core to evolve independently then perhaps rxjava-scala  
and other language adapters should each be a separate top-level project  
with its own release cycle.
 =||= I like @daveray's point: If some third party decided to create a Java project of custom observables beyond what's in RxJava, and we want to use this project from Scala, then we need the `ImplicitFunctionConversions`. So I will make this non-internal.

@benjchristensen I agree that it would be kind of crazy to make the build fail just because `rx.lang.scala.Observable` is out of sync.
 =||= Closing this out as completed ... further progress/bugs can use new issues.

Great work and thank you everyone involved on this.
 =||= ,0
