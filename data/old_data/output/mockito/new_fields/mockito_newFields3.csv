PR,Issue,Issue_Title_Linked,Issue_Body_Linked,Issue_Comment_Linked,isTrain
94,93,Improve documentation,"Documentation is missing many important features (or at least should introduce them in the main readme even they are somewhere described if you find):
- Link to the main reference documentation should be first/big:
  -> http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html
- `@Spy`: Call the real object but record what has been called
  -> http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html#spy
- `@InjectMocks`: Used as a kind of simple dependency injection.
  -> http://mockito.github.io/mockito/docs/current/org/mockito/InjectMocks.html
- `@Captor`: Used to capture what arguments where called.
  -> http://mockito.github.io/mockito/docs/current/org/mockito/Captor.html
- `any()` used to `verify()` something was called with any kind of argument.
  -> http://mockito.github.io/mockito/docs/current/org/mockito/Matchers.html#any()

For most I'd include the relevant `import` as well. I'd also put an example `verify()` with `any()` before even one verifying a specific object was called.","So you'd want this item list in the main README.md ? Or maybe something else in a started guide in the wiki ?
 =||= Docs are not great. Do you want to contribute some changes? :)

Down the road, I'd like to have Mockito 'site', static html would be enough.
 =||= I'll see to suggest a change to the README.md.
 =||= The examples could be rewritten to include some of the main features using the prefered way (e.g., I'd use BDD and annotations).
 =||= Another thing that should be done is split http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html to have the main content there in a new page (ex: `http://mockito.github.io/mockito/docs/current/index.html` or a completely new page outside) so that [Mockito class fields](http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html#field_summary) become more readable.
 =||= Possible thing to do is to add a maven central badge

[![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.mockito/mockito-core/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.mockito/mockito-core)
 =||= @bric3 Yes that could help a bit.
 =||= However I kind of like the current Mockito javadoc as is.
 =||= @bric3 The issue is that it's the main class with methods etc. and it's mixed with a good document giving the overview of all Mockito features and classes. It's like an index mixed with a class documentation. It may be also part of the reason why going to a field's link doesn't work properly.
 =||= Hey Werner. Thanks a lot for looking into improving our documentation. I'm allocating my time other parts of the system (release automation) but documentation will be next :)
 =||= I've submitted a pull request for at least the home page.

Still missing:
- Simpler setup, the maven central badge may help (even if it doesn't show the Gradle version of it)
- Moving the documentation index out of Mocking class documentation http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html
- Writing some better examples, see http://docs.typemock.com/Isolator/##Ref.chm/Documentation/Using.html for how it could be organized (the current kind of ""how-to"" organization is also good for more in depth).
 =||= > - Moving the documentation index out of Mocking class documentation http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html

Not gonna happen. It is our documentation entry point.

> - Writing some better examples, see http://docs.typemock.com/Isolator/##Ref.chm/Documentation/Using.html for how it could be organized (the current kind of ""how-to"" organization is also good for more in depth).

There's always the wiki for that :)

Closing as the PR has been merge, thx again for taking care of the doc.
 =||= ",0
103,99,RETURNS_DEEP_STUBS automatically tries to create serializable mocks,"I am just migrating from mockito 1.9.5 to 1.10.5

The following code runs fine with version 1.9.5. but breaks now:

``` java

  @Test
  public void test() {
    ToBeMocked mock = mock(ToBeMocked.class, RETURNS_DEEP_STUBS);
    assertThat(mock.getSomething()).isNotNull();
  }

  public static class ToBeMocked {

    NotSerializableReturnValue field1;

    public ToBeMocked(NotSerializableReturnValue field1) {
      this.field1 = field1;
    }

    public NotSerializableReturnValue getSomething() {
      return field1;
    }
  }

  public static class NotSerializableReturnValue {

    String field1 = """";

    public NotSerializableReturnValue(String field1) {
      this.field1 = field1;
    }

    public String getSomething2() {
      return field1;
    }
  }
```

org.mockito.exceptions.base.MockitoException: 
You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'NotSerializableReturnValue'
do not implement Serializable AND do not have a no-arg constructor.","Hey,

Perhaps Mockito is too aggressive with this validation. The thing is that this code could break if you stub some of those methods. @bric3, thoughts?

Thanks for reporting! Can you update your code and add Serializable / default constructor?
 =||= I just experienced the same issue when I wanted to test our custom DSL API on my current project. I believe there was some issue sometime ago before we moved to github about serialization, it may relate to deep stubs.
 =||= https://code.google.com/p/mockito/issues/detail?id=399 right?

I don't really understand this validation - if I have no interest in my code being serializable nor serializing a mock/stub; why do I have to make it so (and add default constructors, allowing partially constructed objects) just to use deep stubs? Shouldn't I have to opt-in if I need/want my deep stubs to be serializable or am I missing something?
 =||= @szczepiq Hi, for one occurence I was able to implement a default constructor. For another occurence, it did not feel sensible to add a default constructor. I changed this and mocked all used method calls manually. For me it's ok now. 
btw: Thank you very much for sharing and caring for mockito!
 =||= For some reason the deep stub code was enabling _children_ stubs to be always serializable which doesn't make sense. In the plane I crafted a fix. ~~I'll push it asap.~~
 =||= It should be fixed in 1.10.8
 =||= Excellent, thanks @bric3 ! Let me take this chance to add that Mockito is an excellent piece of software and a near-perfect mocking library IMO - all of your efforts are highly appreciated :) I was at a workshop with Michael Feathers recently and was asking him whether he planned to update his book Working Effectively with Legacy Code to reflect the invent of modern (non-strict!) mocking frameworks such as Mockito as in my opinion they have revolutionized dependency-breaking and bringing legacy code under test. No luck, but maybe someone should write a new updated such book :)
 =||= Hey,

1.10.8 was released to Bintray/jcenter. For some reason, maven central sync
didn't work :(

What do you think needs to be fixed so that mockito is perfect? :)

On Fri, Oct 10, 2014 at 5:33 AM, Chad notifications@github.com wrote:

> Excellent, thanks @bric3 https://github.com/bric3 ! Let me take this
> chance to add that Mockito is an excellent piece of software and a
> near-perfect mocking library IMO - all of your efforts are highly
> appreciated :) I was at a workshop with Michael Feathers recently and was
> asking him whether he planned to update his book Working Effectively with
> Legacy Code to reflect the invent of modern (non-strict!) mocking
> frameworks such as Mockito as in my opinion they have revolutionized
> dependency-breaking and bringing legacy code under test. No luck, but maybe
> someone should write a new updated such book :)
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/99#issuecomment-58608755.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= ",0
125,104,OSGi exceptions when enabling mockito-core bundle (in 1.10.0),"When trying to load mockito-core (or mockito-all) bundle I get this error:

```
com.atlassian.plugin.PluginException: org.osgi.framework.BundleException: Unresolved constraint in bundle org.mockito.mockito-core [18]: Unable to resolve 18.0: missing requirement [18.0] package; (package=org.mockito.asm.signature)
```

Version 1.9.5 doesn't have this problem","Hey,

Thanks for reporting!

Can you help us figure out what the problem is? We're not experts on OSGi I'm afraid.
 =||= JAR lib/repackaged/cglib-and-asm-1.0.jar doesn't contain org.mockito.asm.signature package. Is this on purpose? Please note that classes in org.mockito.asm.util (ie CheckSignatureAdapter) are still refering classed from package org.mockito.asm.signature. 
This leads to the point where OSGi manifest contains Import-Package instruction for package  org.mockito.asm.signature but the bundle is not able to provide this package.
 =||= > JAR lib/repackaged/cglib-and-asm-1.0.jar doesn't contain
> org.mockito.asm.signature package. Is this on purpose?

I honestly don't know. Can you help us fixing this behavior?

On Mon, Oct 13, 2014 at 4:58 PM, Krystian Brazulewicz <
notifications@github.com> wrote:

> JAR lib/repackaged/cglib-and-asm-1.0.jar doesn't contain
> org.mockito.asm.signature package. Is this on purpose? Please note that
> classes in org.mockito.asm.util (ie CheckSignatureAdapter) are still
> refering classed from package org.mockito.asm.signature.
> This leads to the point where OSGi manifest contains Import-Package
> instruction for package org.mockito.asm.signature but the bundle is not
> able to provide this package.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/104#issuecomment-58904217.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= There may be an issue when packaging Mockito. The Mockito jar does not have `org.mockito.asm.signature` either. Note that the source however of the _embedded_ CGLIB and ASM has this `signature` package : https://github.com/mockito/mockito/tree/master/cglib-and-asm/src/org/mockito/asm
 =||= I can investigate this further when I get back from vacations.
On Oct 20, 2014 2:22 AM, ""Brice Dutheil"" notifications@github.com wrote:

> There may be an issue when packaging Mockito. The Mockito jar does not
> have org.mockito.asm.signature either. Note that the source however of
> the _embedded_ CGLIB and ASM has this signature package :
> https://github.com/mockito/mockito/tree/master/cglib-and-asm/src/org/mockito/asm
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/104#issuecomment-59655038.
 =||= I hit similar problem. Possible workaround for me is to add `Export-Package: org.mockito.asm.signature`  into a manifest of bundle that wants to use Mockito.
 =||= ",0
142,128,Deep stubbing with generic responses in the call chain is not working,"Deep stubbing will throw an Exception if multiple generics occur in the call chain. For instance, consider having a mock `myMock1` that provides a function that returns a generic `T`. If `T` also has a function that returns a generic, an Exception with the message ""Raw extraction not supported for : 'null'"" will be thrown.

As an example the following test will throw an Exception:

``` Java
public class MockitoGenericsDeepStubTest {

    @Test
    public void discoverDeepMockingOfGenerics() {
        MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS);

        when(myMock1.getNested().getNested().returnSomething()).thenReturn(""Hello World."");
    }

    public static interface MyClass1 <MC2 extends MyClass2> {
        public MC2 getNested();
    }

    public static interface MyClass2<MC3 extends MyClass3> {
        public MC3 getNested();
    }

    public static interface MyClass3 {
        public String returnSomething();
    }
}
```

You can make this test run if you step into the class `ReturnsDeepStubs` and change the method `withSettingsUsing` to return `MockSettings` with `ReturnsDeepStubs` instead of `ReturnsDeepStubsSerializationFallback` as default answer:

``` Java
private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {
    MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?
            withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
            : withSettings();

    return propagateSerializationSettings(mockSettings, parentMockSettings)
            .defaultAnswer(this);
}
```

However, this breaks other tests and features.

I think, the issue is that further generics are not possible to be mocked by `ReturnsDeepStubsSerializationFallback` since the `GenericMetadataSupport` is ""closed"" at this point.

Thanks and kind regards
Tobias",nan,0
163,112,Allow instances of other classes in AdditionalAnswers.delegatesTo,"We have `AdditionalAnswers.delegatesTo`, but if an object of the wrong type is passed we get a RuntimeException:

```
java.lang.IllegalArgumentException: object is not an instance of declaring class
```

If we allow any type as long as it has the needed methods of the same signature, then we can create fake objects like:

```
class FakeSession {
    Map<String, Object> map = new HashMap<>();

    public Object getAttribute(String key) {
        return map.get(key);
    }

    public void setAttribute(String key, Object value) {
        map.put(key, value);
    }
}

@Test
public void test() {
    HttpSession session = mock(HttpSession.class,
        AdditionalAnswers.delegatesTo(new FakeSession()));

    session.setAttribute(""key"", ""value"");

    assertEquals(""value"", session.getAttribute(""key""));
}
```

This saves on implementing many methods that are not used in the test, and can be easier to write than adding separate Answers for each call. This can be used to create fakes for objects like SWT's StyledText which has a huge number of methods. Using a separate object instead of a subclass prevents code from accidentely calling the real object or requiring the real constructor to be called.

This is not type-safe but it doesn't seem any worse than the casting required in Answers, and the user will find out quickly if a required method doesn't exist by running the tests.

I propose to modify the implementation of ForwardsInvocations with something like:

```
public Object answer(InvocationOnMock invocation) throws Throwable {
    Method mockMethod = invocation.getMethod();

    if(mockMethod.getDeclaringClass().isAssignableFrom(delegatedObject.getClass())) {
        return mockMethod.invoke(delegatedObject, invocation.getArguments());
    } else {
        Method delegateMethod = delegatedObject.getClass().getMethod(
            mockMethod.getName(), mockMethod.getParameterTypes());
        return delegateMethod.invoke(delegatedObject, invocation.getArguments());
    }
}
```","I think it makes sense from the standpoint of the API (delegatesTo already receives an Object). However, there needs to be a good exception message if the method cannot be found.
 =||= ",0
163,108,Clarify Spy vs Mock CALLS_REAL_METHODS,"I'd suggest adding a comment or side note in `[@InjectMocks](http://mockito.github.io/mockito/docs/current/org/mockito/InjectMocks.html)` to explain that when you want to inject real instances (and not mocks) you have the choice (unless I'm mistaken) between `[@Spy](http://mockito.github.io/mockito/docs/current/org/mockito/Spy.html)` and `[@Mock(answer = CALLS_REAL_METHODS)](http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html#CALLS_REAL_METHODS)` but the former is preferable, because...","Injecting real instances is not supported by the current injection mechanism. The things you mentioned are barely tricks. So instead of promoting tricks it would make more sense to support real type injection.

Also I find `@Mock(answer = CALLS_REAL_METHODS)` to be somewhat bad practice. I don't think we should expose that.
 =||= It's useful when DI are not possible.
 =||= Which doesn't mean it's a not a trick. Usually it means the production and/or test code need a serous refactoring. And if it's an external type that cannot be refactored then the following principle apply _Don't mock types you don't own!_

Anyway I'm totally against exposing this bad practice in the doc, as we want to develop a better code for our peers, for the next one working on the matter.
 =||= ",0
163,112,Allow instances of other classes in AdditionalAnswers.delegatesTo,"We have `AdditionalAnswers.delegatesTo`, but if an object of the wrong type is passed we get a RuntimeException:

```
java.lang.IllegalArgumentException: object is not an instance of declaring class
```

If we allow any type as long as it has the needed methods of the same signature, then we can create fake objects like:

```
class FakeSession {
    Map<String, Object> map = new HashMap<>();

    public Object getAttribute(String key) {
        return map.get(key);
    }

    public void setAttribute(String key, Object value) {
        map.put(key, value);
    }
}

@Test
public void test() {
    HttpSession session = mock(HttpSession.class,
        AdditionalAnswers.delegatesTo(new FakeSession()));

    session.setAttribute(""key"", ""value"");

    assertEquals(""value"", session.getAttribute(""key""));
}
```

This saves on implementing many methods that are not used in the test, and can be easier to write than adding separate Answers for each call. This can be used to create fakes for objects like SWT's StyledText which has a huge number of methods. Using a separate object instead of a subclass prevents code from accidentely calling the real object or requiring the real constructor to be called.

This is not type-safe but it doesn't seem any worse than the casting required in Answers, and the user will find out quickly if a required method doesn't exist by running the tests.

I propose to modify the implementation of ForwardsInvocations with something like:

```
public Object answer(InvocationOnMock invocation) throws Throwable {
    Method mockMethod = invocation.getMethod();

    if(mockMethod.getDeclaringClass().isAssignableFrom(delegatedObject.getClass())) {
        return mockMethod.invoke(delegatedObject, invocation.getArguments());
    } else {
        Method delegateMethod = delegatedObject.getClass().getMethod(
            mockMethod.getName(), mockMethod.getParameterTypes());
        return delegateMethod.invoke(delegatedObject, invocation.getArguments());
    }
}
```","I think it makes sense from the standpoint of the API (delegatesTo already receives an Object). However, there needs to be a good exception message if the method cannot be found.
 =||= ",0
163,108,Clarify Spy vs Mock CALLS_REAL_METHODS,"I'd suggest adding a comment or side note in `[@InjectMocks](http://mockito.github.io/mockito/docs/current/org/mockito/InjectMocks.html)` to explain that when you want to inject real instances (and not mocks) you have the choice (unless I'm mistaken) between `[@Spy](http://mockito.github.io/mockito/docs/current/org/mockito/Spy.html)` and `[@Mock(answer = CALLS_REAL_METHODS)](http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html#CALLS_REAL_METHODS)` but the former is preferable, because...","Injecting real instances is not supported by the current injection mechanism. The things you mentioned are barely tricks. So instead of promoting tricks it would make more sense to support real type injection.

Also I find `@Mock(answer = CALLS_REAL_METHODS)` to be somewhat bad practice. I don't think we should expose that.
 =||= It's useful when DI are not possible.
 =||= Which doesn't mean it's a not a trick. Usually it means the production and/or test code need a serous refactoring. And if it's an external type that cannot be refactored then the following principle apply _Don't mock types you don't own!_

Anyway I'm totally against exposing this bad practice in the doc, as we want to develop a better code for our peers, for the next one working on the matter.
 =||= ",0
163,112,Allow instances of other classes in AdditionalAnswers.delegatesTo,"We have `AdditionalAnswers.delegatesTo`, but if an object of the wrong type is passed we get a RuntimeException:

```
java.lang.IllegalArgumentException: object is not an instance of declaring class
```

If we allow any type as long as it has the needed methods of the same signature, then we can create fake objects like:

```
class FakeSession {
    Map<String, Object> map = new HashMap<>();

    public Object getAttribute(String key) {
        return map.get(key);
    }

    public void setAttribute(String key, Object value) {
        map.put(key, value);
    }
}

@Test
public void test() {
    HttpSession session = mock(HttpSession.class,
        AdditionalAnswers.delegatesTo(new FakeSession()));

    session.setAttribute(""key"", ""value"");

    assertEquals(""value"", session.getAttribute(""key""));
}
```

This saves on implementing many methods that are not used in the test, and can be easier to write than adding separate Answers for each call. This can be used to create fakes for objects like SWT's StyledText which has a huge number of methods. Using a separate object instead of a subclass prevents code from accidentely calling the real object or requiring the real constructor to be called.

This is not type-safe but it doesn't seem any worse than the casting required in Answers, and the user will find out quickly if a required method doesn't exist by running the tests.

I propose to modify the implementation of ForwardsInvocations with something like:

```
public Object answer(InvocationOnMock invocation) throws Throwable {
    Method mockMethod = invocation.getMethod();

    if(mockMethod.getDeclaringClass().isAssignableFrom(delegatedObject.getClass())) {
        return mockMethod.invoke(delegatedObject, invocation.getArguments());
    } else {
        Method delegateMethod = delegatedObject.getClass().getMethod(
            mockMethod.getName(), mockMethod.getParameterTypes());
        return delegateMethod.invoke(delegatedObject, invocation.getArguments());
    }
}
```","I think it makes sense from the standpoint of the API (delegatesTo already receives an Object). However, there needs to be a good exception message if the method cannot be found.
 =||= ",0
163,162,GitHubIssues fetcher is now aware of GitHub pagination,"On each build, the build script is tested, and the `GitHubTicketFetcherTest` failed because GitHb issues API is paginated. Over time with new issues/pull request added, the first page did not contain issue number the test expected to find, leading to this failed assertion.

```
Condition not satisfied:

impr.toText() == """"""* Improvements: 2 * Allow instances of other classes in AdditionalAnswers.delegatesTo [(#112)](https://github.com/mockito/mockito/issues/112) * Clarify Spy vs Mock CALLS_REAL_METHODS [(#108)](https://github.com/mockito/mockito/issues/108)""""""
|    |        |
|    |        false
|    |        100 differences (58% similarity)
|    |        * Improvements: (1)\n  * Allow instances of other classes in AdditionalAnswers.delegatesTo [(#112)](https://github.com/mockito/mockito/issues/112)(-~--------------------------------------------------------------------------------------------------)
|    |        * Improvements: (2)\n  * Allow instances of other classes in AdditionalAnswers.delegatesTo [(#112)](https://github.com/mockito/mockito/issues/112)(\n  * Clarify Spy vs Mock CALLS_REAL_METHODS [(#108)](https://github.com/mockito/mockito/issues/108))
|    * Improvements: 1
|      * Allow instances of other classes in AdditionalAnswers.delegatesTo [(#112)](https://github.com/mockito/mockito/issues/112)
org.mockito.release.notes.improvements.DefaultImprovements@1ed22788

    at org.mockito.release.notes.improvements.GitHubTicketFetcherTest.fetches improvements from GitHub(GitHubTicketFetcherTest.groovy:19)
```

Github pagination is documented here : https://developer.github.com/guides/traversing-with-pagination/","[![Coverage Status](https://coveralls.io/builds/1802127/badge)](https://coveralls.io/builds/1802127)

Changes Unknown when pulling **3ca6233ecee5539ae86a06101386740b50466dac on fix-github-issue-fetcher** into *\* on fix-coveralls-plugin-outdated-dependency**.
 =||= A W E S O M E :)

Thanks so much! Down the road might be worth splitting the fetcher into smaller classes and adding some unit test coverage.
 =||= Agreed, but we have a greater problem now, coverage doesn't work as well anymore. If you look at the log, cobertura fails with some classes hence the lower coverage result (I suspect it is related to the missing dependency, but I'm not sure...)
- I tried to replace Cobertura with jacoco, but gralde only express obscure stacktraces, I didn't found the reason
- I tried to update Cobertura / Coveralls plugin, and it's even worse, hence all the failing travis builds on this branch fix-coveralls-plugin-outdated-dependency
 =||= ``` gradle
apply plugin : 'jacoco'
apply plugin: 'com.github.kt3k.coveralls'

jacocoTestReport {
    reports {
        xml.enabled = true // coveralls plugin depends on xml format report
        html.enabled = true
    }
}
```

```
ailed to notify ProjectEvaluationListener.afterEvaluate(), but primary configuration failure takes precedence.
java.lang.NullPointerException: Cannot get property 'plus' on null object
    at org.codehaus.groovy.runtime.NullObject.getProperty(NullObject.java:57)
    ...

* Where:
Script '/Users/brice/work/opensource/mockito/gradle/coverage.gradle' line: 4

* What went wrong:
A problem occurred evaluating script.
> Could not find method jacocoTestReport() for arguments [coverage_bz56tm90of2yklk5dd11r2maq$_run_closure1@aca79de] on root project 'mockito'.
```

... yet it is documented like that here : http://gradle.org/docs/current/userguide/jacoco_plugin.html#N138AF
 =||= My work is in this branch `fix-coveralls-plugin-outdated-dependency`, I can't wrap my head around these issue. If you can help on this gradle stuff.
 =||= ",0
171,82,New sub-project for simulating OSGi fragment class-loading issues,"This commits adds a sub-project with a small Ant script for creating three jars - Mockito, sample source and tests. It also adds a new tests for verifying package protected mocking.

The three jars by themselves are enough to trigger the same issue which has been seen in OSGi environment with mocking package visible members. It fails if tests and sources under tests are in different jar files even though they are loaded by the same class loader.

The same tests runs fine as part of the regular Gradle build.","Sorry I did not had time to test it. Do you think it is possible to replace easily _ant_ with _gradle_ ?
 =||= When type to mock comes from a 'signed' jar/package, the generated proxy class uses different package. See NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES in ClassImposterizer (you can debug and step into ClassImposterizer, see if the naming policy is applied). If the generated proxy class has different package then naturally package-visible members are not working correctly.
 =||= @szczepiq As shown in the commits, both are in the same package but in different jars.

@bric3 I'll investigate if I find some time to do it. 
 =||= Note that since some Android tests must be (or are at least recommended to be in the Google docs) in a different project than the test code, this bug affects them, though I suspect it's only an issue with Gradle projects.
 =||= @raphw could you take a look at this PR? I think it can be closed as we fixed the OSGI issues in the other PRs.
 =||= Actually the idea of this PR was to build an OSGI project woth OSGI artefacts and test mockito with those artifacts. The trouble was the fact that gradle wasn't supporting well OSGI at that time. That explains why this PR still uses the ant build script.

We may want to create an OSGI project the gradle way.
 =||= Since this ticket is really old and we use Gradle, should we close this PR but rather open an issue for it?
 =||= Yes that seems like a good resolution.
 =||= That seems fine to me as well.
 =||= ",0
171,123,Release Mockito 2.0,"Incompatible changes:
- [x] stop producing mockito-all #153
- [x] stop depending on hamcrest internally #154
- [x] use newer hamcrest #232
- [x] make the anyXxx and any(Xxx) matchers intuitive #134, #194
- ~~fix the site links~~
- [x] push cglib mockmaker to a separate jar #248
- [x] stop using ant for producing OSGi bundles. No more ant in the build #249
- [x] remove jars from source distribution #250
- ~~perhaps introduce is() matcher~~ #246
- ~~richer and smarter stubbing~~ #303
- ~~support java8 features for capturing arguments and matchers~~
- [x] make the JUnitRule and the runner verbose
- [x] ensure release notes can be neatly generated for the RC #582

Possibly compatible (and hence, could be released pre-2.0 if needed)
- [x] drop deprecated code
- [x] unincubate API
- ~~drop serialVersionUID~~","Is it still planned for 2.0 to give users an option to use an alternative to cglib (like Byte Buddy)?
 =||= This kind of feature can be added any time (e.g. it's not a backwards-incompatible change). It's just someone needs to implement it :) 

So short answer is 'no', it's not planned for 2.0 (but I would love to have this feature soon)
 =||= If possible I would really like to replace CGLIB by bytebuddy.

I wanted to craft an external MockMaker but I'm way too much overwhelmed at the moment. The code exists in my clone though.
 =||= @bric3, you mean that you're keen on changing default proxy mechanism in 2.0? I'm fine with this :) I do want to publish 2.0 this year though and I won't be very active it this part of the code. So, if you make it, it can be included :)
 =||= @szczepiq You mean by the end of 2014 ?

What I hoped was to build a mockmaker that could be tested on the 1.x. But the code may replace CGLIB now if necessary. Beta have to be tested by other people though, I especially think about uncommon environment like OSGI, etc...
 =||= 1>You mean by the end of 2014 ?

haha, yeah ;)

> What I hoped was to build a mockmaker that could be tested on the 1.x.

Like an opt-in feature for 1.x?

I definitely think that given we have the bytebuddy impl of MockMaker, we
should make it conveniently pluggable instead of just replacing cglib
completely. You mentioned earlier that you had the ByteBuddy MockMaker
working with Mockito test suite?

Cheers!

On Mon, Nov 24, 2014 at 4:18 PM, Brice Dutheil notifications@github.com
wrote:

> You mean by the end of 2014 ?
> 
> What I hoped was to build a mockmaker that could be tested on the 1.x. But
> the code may replace CGLIB now if necessary. Beta have to be tested by
> other people though, I especially think about uncommon environment like
> OSGI, etc...
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-64208043.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= > > What I hoped was to build a mockmaker that could be tested on the 1.x.
> 
> Like an opt-in feature for 1.x?

Yes. But, meanwhile replacing CGLIB in mockito 2.0.

> You mentioned earlier that you had the ByteBuddy MockMaker working with Mockito test suite?

Yes it does. I just would like to ensure it works with uncommon environment like OSGI.
 =||= Do you think it is worthwhile to keep support for cglib once we have
bytebuddy?

Do you think we should shade bytebuddy? What dependencies bytebuddy brings?

On Mon, Nov 24, 2014 at 6:26 PM, Brice Dutheil notifications@github.com
wrote:

>  What I hoped was to build a mockmaker that could be tested on the 1.x.
> Like an opt-in feature for 1.x?
> 
>  Yes. But, meanwhile replacing CGLIB in mockito 2.0.
> 
> You mentioned earlier that you had the ByteBuddy MockMaker working with
> Mockito test suite?
> 
> Yes it does. I just would like to ensure it works with uncommon
> environment like OSGI.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-64229927.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= No I don't think it is necessary, however we can make a CGLIB mock maker, for people that may depend on it.
 =||= I am curious: Do you guys have a time-line for the 2.0 release? I am more than happy to support any code-generation releated issues. However, my vacation is approaching so I will be gone for a couple of weeks starting mid-August.

In particular, I wonder you guys wanted to try integrating Byte Buddy 0.7 with support for generic type retention already in 2.0 which I hope to complete before my vacation. One word of warning: Generic types are awefully complex. Byte Buddy needs to parse stringified type information and resolve the full type hierarchy, i.e. bind type variables of super types / interfaces to their actual values in order to appropriately resolve a type variable's value while dealing with the possibility of raw types and potentially illegally formatted generic types (the JVM does not verify generic type infromation which simply exists as meta data). There is a chance for corner case errors even though I isolated the functionality pretty much to fall back to type erasure if any illegal type information is disovered. At the same time, mocks would behave better when a generic type is read by a class processing a mock.
 =||= It must happen in 2015. I hope we are ready in the next few months. In
theory, there's not much left work :)

Cheers!

On Fri, Jul 10, 2015 at 5:31 AM, Rafael Winterhalter <
notifications@github.com> wrote:

> I am curious: Do you guys have a time-line for the 2.0 release? I am more
> than happy to support any code-generation releated issues. However, my
> vacation is approaching so I will be gone for a couple of weeks starting
> mid-August.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-120399539.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= I think mockito 2.0 is nearly in shape to be released, most work should go in polishing remaining bits of the public API. IMHO current byte buddy version is fine, and already provide subtitle but needed enhancements.

More specifically on generics I believe current support is OK, after all mockito is a TDD tool for a rapid feedback loop, both on the dev workstation and the ci bots. I believe current generics support in the deepstubs answer is enough. About the issue you mention the support class I wrote is probably incomplete but enough, and I agree parsing this metadata is hard. Anyway at the moment if any extended support should be provided on this front it should be provided via a mockmaker plugin.
 =||= Thanks for the info. I just released Byte Buddy 0.7 but I recommend you to not yet update. Generic types are tricky and I already found a corner case in the bridge method resolution that does not work. I'll try to make it stable until the mid of August, though.
 =||= Any guess on when 2.0 will be released?
 =||= It's been silent for past couple of months, everybody busy, etc. Since
yesterday, I'm focusing my spare time on Mockito. I will not stop until 2.0
is out. We cannot guarantee any dates but 2.0 must be released in 2015.

On Sat, Sep 19, 2015 at 8:40 AM, David J. M. Karlsen <
notifications@github.com> wrote:

> Any guess on when 2.0 will be released?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-141681244.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Any updates on when we might see a 2.0 release?
 =||= 2015 is soon over ;) At some point, we need to do a cut in features. I think everybody is quite budy right now. As always, the time before Christmas are busy month for consultant work.
 =||= Soon. This year for sure. Sorry I was distracted! We will probably deliver
2.0 with what we have, no new fancy features ;)
On Nov 10, 2015 4:52 AM, ""Rafael Winterhalter"" notifications@github.com
wrote:

> 2015 is soon over ;) At some point, we need to do a cut in features. I
> think everybody is quite budy right now. As always, the time before
> Christmas are busy month for consultant work.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-155412454.
 =||= Can this task https://github.com/mockito/mockito/issues/300 be included in 2.0 release?
 =||= Feel free to add #374 to the todo list
 =||= 2.0  is coming so slow.
 =||= It's way too slow. I'm on it. Thank you guys for pushing.
 =||= @szczepiq How can we/the community support the mockito core team ?
 =||= > @szczepiq https://github.com/szczepiq How can we/the community support
> the mockito core team ?
> 
> You already are. You guys are great. Thank you for patience and pushing us
> to deliver.

The lagging of beta is my fault. I've started the beta cycle and I should
have completed it. I'm back in the game, though.

Once 2.x final is out we need clarify how community can drive supporting
and maintaining Mockito.

Note that Mockito is continuously delivered so you can open PR to change
the version to ""2.1.0"", and that's it :)

Cheers!

> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-206757516
 =||= @szczepiq I left a pull request for removing deprecated code which is an 2.0 milestone issue - can you pull it/looks good?
 =||= I haven't reviewed yet. THANKS!
On Sun, Apr 10, 2016 at 03:12 David J. M. Karlsen notifications@github.com
wrote:

> @szczepiq https://github.com/szczepiq I left a pull request for
> removing deprecated code which is an 2.0 milestone issue - can you pull
> it/looks good?
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-207953253
 =||= Per Mockito developers discussion:

We want to target publishing the release on July 31st with a release candidate on June 30th.

There is one issue which must be resolved for that, which is #194. Other than that I just found 1 minor TODO [in the Mockito documentation](https://github.com/mockito/mockito/blob/dff5510cb3e97dae414e58ba85825ad01b273c72/src/main/java/org/mockito/Mockito.java#L1091). The other issues can be fixed in a later minor version.
 =||= @TimvdLippe  what about https://github.com/mockito/mockito/issues/300?
 =||= @skabashnyuk I think that we still want to do this, but is not a blocker for the release. We must do it when we have time, but it is okay in my opinion to release it in a later minor version. I have to be honest that I was not participating in the original discussion so I do not know the exact details. @bric3 is the man to talk to :)
 =||= @TimvdLippe @skabashnyuk Humm I think we should really focus energy on mockito 2, TestNG could come later.
 =||= > TestNG could come later.

@bric3 No problem. But why this can't be done in parallel? Code is ready, looks like this is an infrastructure-deployment issue. Or you are planning to do something bigger than just deploy artifacts?
 =||= @skabashnyuk Currently we are focused on releasing Mockito 2.0. This leaves little to no time for other issues sadly. If you are able to configure the deployment, we are happy to accept your pull request! We can devote some of our time to the TestNG issue after we have released Mockito 2.0.
 =||= Some update.

We're not ready for the release but there's good momentum. Let's plan out
what else needs to be done (announcement information, really documentation
around why to upgrade and how, solid plan what's next after the release
candidate, etc.).

I'm confident the RC will be out in August. I plan to announce everywhere
that we plan RB in August. If we don't meet the date there will high degree
of shame ;) Thoughts?

On Sat, Jun 25, 2016 at 3:59 AM, Tim van der Lippe <notifications@github.com

> wrote:
> 
> @skabashnyuk https://github.com/skabashnyuk Currently we are focused on
> releasing Mockito 2.0. This leaves little to no time for other issues
> sadly. If you are able to configure the deployment, we are happy to accept
> your pull request! We can devote some of our time to the TestNG issue after
> we have released Mockito 2.0.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-228532419,
> or mute the thread
> https://github.com/notifications/unsubscribe/AABgp8m2jG-9Rj7USJ1V2s6GJNHLzbdwks5qPQodgaJpZM4C_fdm
> .

## 

Szczepan Faber
Founder @ mockito.org | Twitter @ szczepiq
Author @ https://www.linkedin.com/today/author/6016386
 =||= I think most of the work should be focused on the upgrade guide, there's not much left for 2.0, follow up tasks can be completed in 2.1
 =||= I think we can publish the release candidate while working on the actual upgrade guide (state this in the github release for users to follow). The only two issues that are non-documentation are #384 with PR #527 of @szczepiq and #489 with PR #491 of myself. #527 has some feedback to be processed and #491 is more of a discussion regarding the runner.

Once these two are resolved, we can merge #483 and the release candidate is published :tada: 

For an up-to-date status, see https://waffle.io/mockito/mockito and https://github.com/mockito/mockito/milestone/1
 =||= This is great stuff!!! Thanks a lot Tim for pushing the release forward & organizing it so well.

I'm making good progress on the warnings stuff for JUnit rule and the listener - will update the PR very soon.
 =||= I'm confused why this ticket is closed. I don't see 2.0 in maven central :)
 =||= @szczepiq because this issue was referenced in #483 which I just merged
 =||= ah, GH smartness :)
 =||= As promised here’s suggested plan to get 2.0 out. Please give feedback, sing up for tasks and commit to ETA so that we get 2.0 out :)

Step 1:
- [ ] prepare RC release notes + announcement (highlights, motivation, request for feedback) - #582
- [ ] review and update documentation for 2.0.0 - #596
- [ ] ensure & test manual Mockito releases - #586
- [ ] update CI / build scripts (releasing betas from branch, etc) - #594

Step 2:
- [ ] branch out / fixes to release / Travis - #594

Step 3:
- [ ] pull the trigger for RC!!!!!, close darn #123 !!!!!!
 =||= ![image](https://cloud.githubusercontent.com/assets/5948271/18092170/97fac1ca-6ecb-11e6-83e0-fd2953833359.png)
 =||= I think we have updated all relevant documentation. @bric3 once you branch out to `release/2.x` we can publish the release candidate :tada: 
 =||= I went ahead and published the release candidate. You can download `2.1.0-RC.1` at https://bintray.com/szczepiq/maven/mockito/2.1.0-RC.1#
 =||= By the way I would prefer to have mockito account on bintray 
 =||= Yes agreed. Let's extract a separate issue for that.
 =||= Mockito 2.1.0 has been released, upgrade today :tada: 
 =||= ",0
176,155,Internal Comparator violates its general contract,"Log from my test run:

java.lang.IllegalArgumentException: Comparison method violates its general contract!
    at java.util.TimSort.mergeHi(TimSort.java:868)
    at java.util.TimSort.mergeAt(TimSort.java:485)
    at java.util.TimSort.mergeForceCollapse(TimSort.java:426)
    at java.util.TimSort.sort(TimSort.java:223)
    at java.util.TimSort.sort(TimSort.java:173)
    at java.util.Arrays.sort(Arrays.java:659)
    at java.util.Collections.sort(Collections.java:217)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.orderedInstanceFieldsFrom(PropertyAndSetterInjection.java:125)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.injectMockCandidates(PropertyAndSetterInjection.java:100)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.processInjection(PropertyAndSetterInjection.java:77)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:68)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.relayProcessToNextStrategy(MockInjectionStrategy.java:89)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:71)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.relayProcessToNextStrategy(MockInjectionStrategy.java:89)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:71)
    at org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.apply(MockInjection.java:92)
    at org.mockito.internal.configuration.DefaultInjectionEngine.injectMocksOnFields(DefaultInjectionEngine.java:20)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.injectMocks(InjectingAnnotationEngine.java:100)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.processInjectMocks(InjectingAnnotationEngine.java:62)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.process(InjectingAnnotationEngine.java:56)
    at org.mockito.MockitoAnnotations.initMocks(MockitoAnnotations.java:108)","It occures when bean under test has many fields (declaredFields.size = 44)
 =||= ",0
201,200,ArgumentCaptor.fromClass's return type should match a parameterized type,"`ArgumentCaptor.fromClass`'s return type should match a parameterized type.  I.e. the expression `ArgumentCaptor.fromClass(Class<S>)` should be of type `ArgumentCaptor<U>` where `S` is a subtype of `U`.   

For example:

```
ArgumentCaptor<Consumer<String>> captor = ArgumentCaptor.fromClass(Consumer.class)
```

does not type check (i.e. it is a compile time error). It should type check. 

The reasons that it is desirable for `ArgumentCaptor.fromClass` to allow expressions such as the example above to type check are:

1) `ArgumentCaptor.fromClass` is intended to be a convenience method to allow the user to construct an ArgumentCaptor without casting the returned value.

Currently, the user can devise a workaround such as: 

```
ArgumentCaptor<? extends Consumer<String>> captor 
= ArgumentCaptor.fromClass(Consumer.class)
```

This workaround is inconvenient, and so contrary to `ArgumentCaptor.fromClass` being a convenience method.

2) It is inconsistent with `@Captor`, which can be applied to a field with a paramterized type.  I.e.

```
@Captor ArgumentCaptor<Consumer<String>> captor 
```

type checks.","PR #201
 =||= ",0
202,187,java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.String,"Exception throws on verifyZeroInteractions when using mock with default answer.
checked on versions 1.10.5-2.0.5
all ok on 1.9.5","Hi,

Do you have a JUnit test so that we could reproduce.
Also please see the [contributing guide](https://github.com/mockito/mockito/blob/master/CONTRIBUTING.md).
 =||= ``` java
public class MockitoTest extends Mockito {
    public interface TestMock {
        public boolean m1();
    };

    @Test
    public void test() {
        TestMock test = mock(TestMock.class, new Answer() {
            @Override public Object answer(InvocationOnMock invocation) throws Throwable {
                return false;
            }
        });
        test.m1();
        verifyZeroInteractions(test);
    }
}
```
 =||= Hi, sorry for the late reply.

Thanks for the testcase, indeed we missed something there.

For reference the stacktrace is :

```
java.lang.ClassCastException: java.lang.Boolean cannot be cast to java.lang.String
    at org.mockitousage.bugs.ClassCastExOnVerifyZeroInteractionsTest$TestMock$$EnhancerByMockitoWithCGLIB$$91d883c5.toString(<generated>)
    at java.lang.String.valueOf(String.java:2847)
    at java.lang.StringBuilder.append(StringBuilder.java:128)
    at org.mockito.exceptions.Reporter.noMoreInteractionsWanted(Reporter.java:420)
    at org.mockito.internal.verification.NoMoreInteractions.verify(NoMoreInteractions.java:24)
    at org.mockito.internal.MockitoCore.verifyNoMoreInteractions(MockitoCore.java:113)
    at org.mockito.Mockito.verifyZeroInteractions(Mockito.java:1674)
    at org.mockitousage.bugs.ClassCastExOnVerifyZeroInteractionsTest.test(ClassCastExOnVerifyZeroInteractionsTest.java:23)
```
 =||= Actually the usage report was improved to include the mock name, however in this usage the default answer always returns `false`. So when the String message is generated there's a CCE because the default answer returns a `boolean`.

On your side the workaround is to return valid values for these `Object` inherited methods.

On mockito side there should be two possible thing to do:
- get the name safely without invoking `toString`
- validate more aggressively answer's result
 =||= Hello, I've one doubt, can we do casting for mocking objects?. When I tried to do that I got ""java.lang.ClassCastException"". =||= ",0
207,197,Mockito.after() method accepts negative timeperiods and subsequent verifications always pass,"e.g.

```
Runnable runnable = Mockito.mock(Runnable.class);
Mockito.verify(runnable, Mockito.never()).run(); // passes as expected
Mockito.verify(runnable, Mockito.after(1000).never()).run(); // passes as expected
Mockito.verify(runnable, Mockito.after(-1000).atLeastOnce()).run(); // passes incorrectly
```","Well spotted, thx
 =||= I can try to fix that, but need to know what exactly is the issue here:
Should negative values in after method be forbidden and trigger exception to be thrown? or maybe negatives are allowed here (negative value means - immediately, pretty much it should behave like after(0) )?
 =||= I would vote for an IllegalArgumentException being thrown.
 =||= The same is happening for _timeout_ method:
e.g. 

```
       SomeClazz mock = Mockito.mock(SomeClazz.class);
       Mockito.verify(mock, timeout(-100)).someMethod(); //passes, which is incorrect
```

If method was invoked, then it passes, but this negative timeout is at least confusing:

```
        SomeClazz mock = Mockito.mock(SomeClazz.class);
        mock.someMethod();
        Mockito.verify(mock, timeout(-100)).someMethod(); //passes
```
 =||= ",0
211,188,ArgumentCaptor no longer working for varargs,I ran into the issue described here: http://stackoverflow.com/questions/27303562/why-does-upgrading-mockito-from-1-9-5-to-1-10-8-break-this-captor,"Hi sorry for the late reply.
I reproduced the issue, not sure when I will be able to fix though.
 =||= fixed by #211 
 =||= ",0
221,212,Add BDD version of verifyZeroInteractions(),"Right now my tests look like:

``` java
then(file).should().moveTo(directory);
then(log).should().warn(""Moved file""));
verifyZeroInteractions(otherFile);
```

Would be great to have BDD replacement for `verifyZeroInteractions()`. Then the test would be even nicer:

``` java
then(file).should().moveTo(directory);
then(log).should().warn(""Moved file""));
then(otherFile).shouldHaveZeroInteractions();
```","OK, are you ready for a PR ?
 =||= @bric3, please see #221
 =||= ",0
222,203,Introduce BDD InOrder verification,"Follow-up to the [discussion](https://groups.google.com/forum/#!topic/mockito/wr1As1fg_-U).

[BDDMockito](http://site.mockito.org/mockito/docs/current/org/mockito/BDDMockito.html) is great, but right now it doesn't support InOrder verification. Here is my proposition:
##### Initialization and invocations:

``` java
List firstMock = mock(List.class);
List secondMock = mock(List.class);

firstMock.add(""was called first"");
secondMock.add(""was called second"");
secondMock.add(""was called second"");

InOrder inOrder = inOrder(firstMock, secondMock);
```
##### Current non-BDD solution:

``` java
inOrder.verify(firstMock).add(""was called first"");
inOrder.verify(secondMock).add(""was called second"");
```
##### Proposition 1:

``` java
inOrder.then(firstMock).should().add(""was called first"");
inOrder.then(secondMock).should(times(2)).add(""was called second"");
```
##### Proposition 2:

``` java
then(firstMock).should(inOrder).add(""was called first"");
then(secondMock).should(inOrder, times(2)).add(""was called second"");
```

I'm open to other propositions. What do you think? 
I can proceed with PR as soon as we will agree on API.","It seems like a nice idea, let's introduce ordered BDD. I'd favor proposition 2, it reads better imho.

Since we are in a beta phase, we can try and see if the API works with this proposition. Also it should probably be easier to implement.
 =||= Also sorry for this late reply
 =||= @bric3, I've implemented the second proposition. I also like it more and implementation was really easy - please see #222.
 =||= ",0
223,206,NoJUnitDependenciesTest is failing on Windows machine.,"I found NoJUnitDependenciesTest unit test is the only unit test that fails when you run the build on windows machine (I have also Ubuntu, and it is fine for some reason on Unix platform).

Root cause: Caused by: java.lang.NoClassDefFoundError: org\mockito\internal\invocation\InvocationMarker (wrong name: org/mockito/internal/invocation/InvocationMarker)

Full Stacktrace:

java.lang.AssertionError: 'org\mockito\internal\invocation\InvocationMarker' has some dependency to JUnit
    at org.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:36)
    at org.mockitointegration.NoJUnitDependenciesTest.pure_mockito_should_not_depend_JUnit(NoJUnitDependenciesTest.java:28)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:86)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:49)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)
    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:48)
    at sun.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:105)
    at sun.reflect.GeneratedMethodAccessor36.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:360)
    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:64)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:722)
Caused by: java.lang.NoClassDefFoundError: org\mockito\internal\invocation\InvocationMarker (wrong name: org/mockito/internal/invocation/InvocationMarker)
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:791)
    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
    at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
    at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at org.mockitoutil.ClassLoaders$LocalExcludingURLClassLoader.findClass(ClassLoaders.java:156)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:423)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:356)
    at java.lang.Class.forName0(Native Method)
    at java.lang.Class.forName(Class.java:266)
    at org.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:34)
    ... 41 more","Hi,

Thanks for reporting, I don't own a Windows box, so I don't know if I will fix this one asap.
This has probably something to do with the path, that's the only thing that come to me at that time.
 =||= I reproduced problem and found solution - in a sec I will create PR
 =||= ",0
229,228,@Captor javadoc contains a wrong call example,"In the javadoc of `@Captor`:

```
verify(mock.doStuff(captor.capture()));
```

which is incorrect.","Cool thanks :)
 =||= ",0
234,233,mockito 2.0.14 fails to mock jetty httpclient,"this fails:

<pre>
     import org.eclipse.jetty.client.HttpClient;
    HttpClient httpClient = mock(HttpClient.class);
</pre>

(jetty 9.2.10.v20150310)

with mockito 2.0.2-beta i can mock that class without a problem. 

stacktrace:

<pre>
java.lang.IllegalAccessError: tried to access class org.eclipse.jetty.util.component.ContainerLifeCycle$Managed from class org.eclipse.jetty.client.HttpClient$MockitoMock$362486671
    at org.eclipse.jetty.client.HttpClient$MockitoMock$362486671.<clinit>(Unknown Source)
    at sun.reflect.GeneratedSerializationConstructorAccessor2.newInstance(Unknown Source)
    at java.lang.reflect.Constructor.newInstance(Constructor.java:408)
    at org.objenesis.instantiator.sun.SunReflectionFactoryInstantiator.newInstance(SunReflectionFactoryInstantiator.java:45)
    at org.objenesis.ObjenesisBase.newInstance(ObjenesisBase.java:73)
    at org.mockito.internal.creation.instance.ObjenesisInstantiator.newInstance(ObjenesisInstantiator.java:14)
    at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:27)
    at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:33)
    at org.mockito.internal.MockitoCore.mock(MockitoCore.java:59)
    at org.mockito.Mockito.mock(Mockito.java:1392)
    at org.mockito.Mockito.mock(Mockito.java:1270)
</pre>","Is this an OSGI package ?
 =||= Also a general principle when mocking is _to not mock types you don't own_, there's several reasons for that see that [wiki page](https://github.com/mockito/mockito/wiki/How-to-write-good-tests).

However the issue is probably true. But I cannot reproduce locally, do you have additional informations like jetty version, jvm version (OpenJDK, hotspot, J9, ...) ?
 =||= yeah, i know about that rule. this is from a really tiny method and i just want to check that it invokes the start method. 

oracle jdk8_11, jetty 9.2.10
 =||= The `Managed` inner class is package-private: http://grepcode.com/file/repo1.maven.org/maven2/org.eclipse.jetty/jetty-util/9.1.3.v20140225/org/eclipse/jetty/util/component/ContainerLifeCycle.java#ContainerLifeCycle.Managed

This class should never be accessible from `org.eclipse.jetty.client.HttpClient` or any mock which both live in another package. I assume that you have a version clash on your class path. Creating a mock can trigger lazy class path resolutions that are not even triggered in your production code via the class introspection that is required to create the mock. 
 =||= ok but the HttpClient class can be instantiated just fine by calling its constructor

client = new HttpClient();
 =||= also the managed enum is only used inside ContainerLifeCycle. 
 =||= I now see what the problem is. Byte Buddy overrides the public method `ContainerLifeCycle::addBean(Object o, Managed managed)` in order to allow mocking the method call. For this, the mock references the `Managed` class which is however package-private.

While this is a rather poorly designed API as the method should itself be package-private as it cannot be used outside of the package, Byte Buddy should be smart enough to figure this out. It is a small fix, I have it ready some time this week. Thanks for reporting!
 =||= thanks. I agree that the package structure and api design of jetty is a bit strange.
 =||= @raphw Thanks for the investigation
 =||= @christophsturm Thanks for the feddback too, note mockito 2.0.0 is still in beta phase
 =||= sure! we will just continue to use 2.0.2-beta for now which works great.
 =||= You can use a more recent beta `2.0.8-beta`, the last version before switching to bytebuddy
 =||= Byte Buddy 0.6.9 is released which should fix the issue. Sorry for the hick-up. (In JCenter, currently synchronizing to Maven Central.)
 =||= No problem, you were blazingly fast !
 =||= ",0
235,220,2.0.8-beta -> 2.0.9-beta 'Unable to initialize @Spy annotated field,"No test failures when using 2.0.8-beta, but when incrementing to 2.0.9-beta, the following error occurs:

```
org.mockito.exceptions.base.MockitoException: Unable to initialize @Spy annotated field 'monitorTaskScheduler'.
Unable to create mock instance of type 'MonitorTaskScheduler'
    at net.project.dash.monitor.MonitorTaskScheduler$MockitoMock$1184625981.getExecutorService(Unknown Source)
    at net.project.dash.monitor.MonitorTaskScheduler.<init>(MonitorTaskScheduler.java:39)
    at net.project.dash.monitor.MonitorTaskScheduler$MockitoMock$1184625981.<init>(Unknown Source)
    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)
    at org.mockito.internal.creation.instance.ConstructorInstantiator.invokeConstructor(ConstructorInstantiator.java:42)
    at org.mockito.internal.creation.instance.ConstructorInstantiator.noArgConstructor(ConstructorInstantiator.java:66)
    at org.mockito.internal.creation.instance.ConstructorInstantiator.newInstance(ConstructorInstantiator.java:17)
    at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:27)
    at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:33)
    at org.mockito.internal.MockitoCore.mock(MockitoCore.java:59)
    at org.mockito.Mockito.mock(Mockito.java:1284)
    at org.mockito.internal.configuration.SpyAnnotationEngine.newSpyInstance(SpyAnnotationEngine.java:117)
    at org.mockito.internal.configuration.SpyAnnotationEngine.process(SpyAnnotationEngine.java:67)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.processIndependentAnnotations(InjectingAnnotationEngine.java:73)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.process(InjectingAnnotationEngine.java:55)
    at org.mockito.MockitoAnnotations.initMocks(MockitoAnnotations.java:108)
    at net.project.dash.monitor.MonitorTaskSchedulerTest.setUp(MonitorTaskSchedulerTest.java:38)
```

Relevant code (MonitorTaskSchedulerTest.java)

``` java
@Spy
MonitorTaskScheduler monitorTaskScheduler;

@Before
public void setUp()
{
    MockitoAnnotations.initMocks(this);
}
```

Relevant code (MonitorTaskScheduler.java)

``` java
public class MonitorTaskScheduler
{
    public MonitorTaskScheduler()
    {
        this.futureToTaskMap = new ConcurrentHashMap<>();
    }
}
```","Can you try with 2.0.11-beta ?
 =||= Same problem with 2.0.11-beta (in fact, I started with that version, and then decremented one by one till the problem was gone).
 =||= If I had to make a (somewhat) educated guess I would say it is most likely related to 3b445aa057ada4e64b096634b011eab399f03f56
 =||= It's not really that commit, it probably have to do with the change from CGLIB to ByteBuddy. I cannot reproduce locally, can you craft a reproducible test ?
 =||= MonitorTaskScheduler.java: 

``` java
public class MonitorTaskScheduler
{
    private final Map<ScheduledFuture<?>, MonitorTask> futureToTaskMap;
    private final ScheduledExecutorService executor;

    public MonitorTaskScheduler()
    {
        futureToTaskMap = new ConcurrentHashMap<>();
        executor = (ScheduledExecutorService) getExecutorService();
    }

    @VisibleForTesting
    ExecutorService getExecutorService()
    {
        return new MonitorTaskExecutor(this);
    }
}
```

MonitorTaskSchedulerTest.java:

``` java
@Spy
MonitorTaskScheduler monitorTaskScheduler;

@Before
public void setUp()
{
    MockitoAnnotations.initMocks(this);
    doReturn(new SynchronousExecutor()).when(monitorTaskScheduler).getExecutorService();
}

@Test
public void test()
{
    monitorTaskScheduler.schedule(() -> { System.out.println(""Task"") });
}

public class SynchronousExecutor extends AbstractExecutorService
{
    private volatile boolean shutdown;

    public void shutdown()
    {
        shutdown = true;
    }

    public List<Runnable> shutdownNow()
    {
        return null;
    }

    public boolean isShutdown()
    {
        return shutdown;
    }

    public boolean isTerminated()
    {
        return shutdown;
    }

    public boolean awaitTermination(long time, TimeUnit unit) throws InterruptedException
    {
        return true;
    }

    public void execute(Runnable runnable)
    {
        runnable.run();
    }

}
```
 =||= I've identified an issue but the given code is incomplete and I don't get the same stacktrace, so it may be another issue.

Here's mine : 

``` java
public class ConstrucotrInvokingMethodShouldWorkTest {
    @Spy HasConstructorInvokingMethod hasConstructorInvokingMethod;

    @Test
    public void should_be_able_to_create_spy() throws Exception {
        MockitoAnnotations.initMocks(this);
    }

    private static class HasConstructorInvokingMethod {
        public HasConstructorInvokingMethod() {
            someMethod();
        }
        void someMethod() { }
    }
}
```

In the meantime two workaround, sticks to an older version, or modify the code so it doesn't call methods in the constructor, which may indicate the design is wrong in OOP (builders or factory to the rescue).
 =||= Actually there maybe a better workaround, using the `Mockito.spy()` factory method.

``` java
class MonitorTaskSchedulerTest {

// @Spy
MonitorTaskScheduler monitorTaskScheduler = spy(new MinitorTaskScheduler());
```

This even works with `@InjectMocks`
 =||= Sorry for not providing a complete example..was trying to copy and paste stuff from difference sources for simplification purposes. Glad you were at least able to identify an issue out of it. I will take your suggestions and do what I can. Thanks.
 =||= You're welcome, thanks for testing betas ;)
 =||= 2d036ec fixed my original issue indeed! Thanks so much, great work.
 =||= ",0
252,251,Unit tests improvements: migrate from legacy FEST Assert code to AssertJ,Triggered by #250.,nan,0
261,260,Typo in documentation,"Very minor thing, there's an extra ""at"" (@) in the documentation.

If you go to http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#33

![image](https://cloud.githubusercontent.com/assets/338917/8634099/6c7f5264-27b8-11e5-93d9-98b725c9f749.png)",nan,0
270,268,RETURN_DEEP_STUBS and toArray(T[]) stops working with versions > 1.9.5,"With version 1.9.5 the following test works without a problem:

```
  @Test
  public void toArrayTypedDoesNotWork() throws Exception {
    Container container = mock(Container.class, RETURNS_DEEP_STUBS);
    container.getInnerContainer().getTheProblem().toArray(new String[]{});
  }

  class Container {
    private InnerContainer innerContainer;

    public InnerContainer getInnerContainer() {
      return innerContainer;
    }
  }

  class InnerContainer {
    private Set<String> theProblem;

    public Set<String> getTheProblem() {
      return theProblem;
    }
  }
```

With version 1.10.0 and beyond (including 2.0.26-beta) the following exception gets thrown

```
org.mockito.exceptions.base.MockitoException: Ouch, it shouldn't happen, type 'sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl' on method : 'public abstract <T> T[] java.util.Set.toArray(T[])' is not supported : T[]
    at eu.lindenbaum.ToArrayProblemTest.toArrayTypedDoesNotWork(BookingWebServiceTest.java:102)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:78)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:212)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:68)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)

```

Using

```
    Container container = mock(Container.class, RETURNS_MOCKS);
```

instead of

```
    Container container = mock(Container.class, RETURNS_DEEP_STUBS);
```

works.","I looked at the code and it seems like there is no specific handler for generic arrays. The strange thing is that there never was one.

Did you maybe run with a different Java version in the process? Until Java 7, non-generic arrays were also represented by instances of `GenericArrayType` when returned from the generic reflection methods. Since Java 7, generic arrays with a non-generic component type are properly resolved as `Class` instances.

Nevertheless, this needs a fix in Mockito, as I understand it. I just sent a pull request.
 =||= The test code is executed using Oracle Java 8 (1.8.0.40-b25) on OSX.
I updated mockito from 1.9.5 to 1.10.0 in the process of updating from Java7 to Java8
 =||= You are right, the change came with Java 8. Fixed with my pull request.
 =||= @raphw Nice catch, and thanks for the patch :)
@scameronde Thanks for reporting :)
 =||= By the way @raphw As you may be one of the only person around mockito that can give thorough feedback on the generic support class in mockito, do you see how to improve it ?
 =||= Well, as I am currently dealing with generic types a lot I can only tell that it is quite complex to beginn with. But I am deep in the matter these days, I will look at the implementation some time and see if I can improve it. For now, it looks save, apart from the fact that you were missing generic type arrays.
 =||= Yes it was developed on java 7 and missed that. Anyway thanks again.
 =||= you got to love the open source community. Thank you a lot for the fast response and the fix.
 =||= ",0
280,243,MockUtil.isMock() no longer checks null,"In version 1.9.5, MockUtil.isMock() is defined as:

```
return instance != null && isMockitoMock(instance);
```

In v1.10.19 and HEAD, the `instance != null` check is gone.

This method is called by MockScanner when injecting mock instances on fields, where field values can be null.

Is this a bug? Or it's up to MockMaker.getHandler() to check for null?

If it's a bug, I can fix it. But then we'll need to wait for v2.0 before upgrading Mockito for the company's code base. 

If it's up to the mock maker, then I guess we need to fix Google's DexmakerMockMaker to add a line of `if (mock == null) return null;`","thanks for reporting this one !
 =||= ByteBuddyMockMaker.getHandler(Object mock) method checks for null using instanceof operator
`if (!(mock instanceof MockAccess)) {
    return null;
}`

I presume it is not a bug. 
 =||= > I presume it is not a bug.

Nope
 =||= How about we document the change in the behavior. Javadoc ok?

On Sun, Jul 19, 2015 at 11:28 PM, Brice Dutheil notifications@github.com
wrote:

> I presume it is not a bug.
> 
> Nope
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/243#issuecomment-122708060.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= `MockUtil` is an internal class, I don't think we have to document that one. But I believe we should fix the code there.
 =||= The public API (or, SPI) is MockMaker.getHandler(Object mock).

The current JavaDoc doesn't mention whether null could be passed in. Although in v1.9.5 it was guaranteed that nulls won't be passed in.

If v1.10.19 drops that guarantee, Android's [DexMakerMockMaker](https://android.googlesource.com/platform/external/dexmaker/+/34f760b98a72000325cc83c88f41de011471432e/src/mockito/java/com/google/dexmaker/mockito/DexmakerMockMaker.java) is broken because it doesn't make the effort to check for null.

I personally think it's pointless for Mockito to ever call MockMaker.getHandler(null) because nothing but null would seem reasonable to be returned anyway, so why risk the NPE?

But if this change in the implicit contract needs to happen, the document change is at MockMaker.getHandler(). Something like ""null could be passed in and implementations should return null in that case"" would be clear enough.
 =||= yes agreed with @fluentfuture 
 =||= While working on #277, I fixed the null-check in the MockScanner (as tests were failing if you would remove this check). The check can be [found here](https://github.com/mockito/mockito/pull/277/files#diff-5f69ba708be52e3b8f1216aff3582f4aR34)
 =||= ",0
287,124,"Concise way to collect multiple verify failures, ideally with JUnitCollector or  derivative","If you are using more than one verify statement as test post-conditions, it would be nice to be able to collect each failure and continue with the remaining verify statements or asserts that follow.  JUnit provides the ErrorCollector @Rule to facilitate this kid of thing, but the current [ErrorCollector API](http://junit.org/apidocs/org/junit/rules/ErrorCollector.html) requires either
- a Matcher<T> and a value to compare
- or a Callable<Object>

The Mockito verify statements only return void, however, since they depend on throwing exceptions.  I have not thought of an ideal, non-disruptive way to use JUnit's ErrorCollector to aggregate multiple Mockito verify failure","As a possible example of the way to handle it, maybe it could be modeled after the same way that AssertJ added deferred composite assertion handling through [their own JUnit @Rule](http://joel-costigliola.github.io/assertj/assertj-core-features-highlight.html#soft-assertions):
 =||= ",0
293,245,Serializable check is too harsh,"Hi, apologies if this has been discussed.

While upgrading my company's Mockito to 1.10.19, I ran into a lot of this error:

```
org.mockito.exceptions.base.MockitoException: 
You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'OpportunityClient'
do not implement Serializable AND do not have a no-arg constructor.
This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized
```

In summary, there are two cases triggering this error.
1. The SubjectUnderTest accepts an object Foo and requires it to be Serializable. And yet Foo doesn't implement Serializable nor has a default constructor.
2. Foo itself is Serializable. But the test calls `when(foo.createBar()).thenReturn(bar)`, which behind the scene puts the `bar` mock onto the state of foo, which requires bar itself to be Serializable. In production, bar isn't required to be Serializable.

I feel case 1 is possibly reasonable (although it's still kind of harsh. I'll get to it in a bit).

Case 2 should not require Bar to be Serializable as it does today. In version 1.9.5, our tests worked around it by using `mock(Bar.class, withSettings().serilizable()`. But in version 1.10.19, this workaround breaks if Bar has no default constructor.

Possibly the [Serializable Proxy Pattern](http://stackoverflow.com/questions/702357/what-is-the-serialization-proxy-pattern) could be used to solve this nicely by stashing the ""mock specifications"" into a proxy object that can later on deserialize itself back into a mock Bar with the same number of when().thenReturn().

Now let me try to explain why I think even case 1 is too harsh.

Philosophically, I feel that it's not Mockito's job to ensure the mocked object works in real life. It's a mock object after all. It isn't expected to meet all required specification of the real object.

When in a test I say `@Mock(serializable=true) Foo foo;`, I'm explicitly asking Mockito to ""please pretend my object be Serializable. I don't want to worry about the real object in this test"". Would the real object be serializable when I pass it into SubjectUnderTest? Well:
1. There is nothing guaranteeing that production code passes Foo to SubjectUnderTest. It could likely pass a cousin class RealFoo2 that implements Serializable just fine (or not, but the test doesn't help me with that). It needs to be tested, but IMHO not against a mock foo, especially when Mockito's when().thenReturn() syntax adds non-existent Serializable requirement to the mock object.
2. Given the proxy pattern, that Foo doesn't _look like_ a serializable class isn't a guarantee that it can't be. So by throwing this error, Mockito enforces stricter constraint than what's technically necessary.

I agree that checking basic Serializable requirement in Mockito can catch some bugs. If case 2 can be fixed, it's likely that case 1 would not have triggered so many false positives.

But with all our workarounds already added because of case 2 and the fair number of our tests triggering this error, the amount of work to fix all of them before we can upgrade Mockito looks daunting.

So, I guess my question is: **can we do away with MockCreationValidator.validateSerializable() or make it an opt-in?**

Sorry for the long message.","Here's a real example. The subject under test looks like this:

```
class SubjectUnderTest implements Serializable {
  private final FooFactory factory;

  SubjectUnderTest(FooFactory factory) {
    this.factory= factory;
  }

  ...
  Foo foo = factory.createFoo();
  ...
}
```

The testing framework actually tries to serialize SubjectUnderTest so FooFactory needs to be Serializable too.

The test using Mockito looks like this:

```
Foo foo = mock(Foo.class);
FooFactory mockFactory = mock(FooFactory.class, withSettings().serializable());
when(mockFactory.createFoo()).thenReturn(foo);
SubjectUnderTest subject = new SubjectUnderTest(mockFactory);
```

But when the framework serializes `subject`, we get an exception, because the line of `when(mockFactory.createFoo()).thenReturn(foo)` implicitly adds 'foo' as part of `mockFactory` state.

To work around the problem, our tests had to make foo serializable too:

```
Foo foo = mock(Foo.class, withSettings().serializable());
...
```

Again, production code doesn't need Foo to be Serializable and it may not have a default constructor.

That's status quo.

Now with v1.10.19, the above work-around breaks, because Foo doesn't implement Serializable nor has a default constructor.

Back to square one, if I had the choice, I would strongly discourage the code that mocks either FooFactory or Foo. Instead, it should just be a plain old FooFactory subclass that returns Foo. With Java 8, the syntax would actually become more concise than the mockito syntax. 

But I can't go back and fix so many teams' code. As it stands today, this is the biggest issue blocking the upgrade.

Hopefully I've made a clear case.
 =||= Thanks for reporting.

I'm ok with removing the check or making it smarter. It seems to be a legit
use case. Brice?

Cheers!

On Fri, Jul 3, 2015 at 2:50 PM, Ben Yu notifications@github.com wrote:

> Here's a real example. The subject under test looks like this:
> 
> class SubjectUnderTest implements Serializable {
>   private final FooFactory factory;
> 
>   SubjectUnderTest(FooFactory factory) {
>     this.factory= factory;
>   }
> 
>   ...
>   Foo foo = factory.createFoo();
>   ...
> }
> 
> The testing framework actually tries to serialize SubjectUnderTest so
> FooFactory needs to be Serializable too.
> 
> The test using Mockito looks like this:
> 
> Foo foo = mock(Foo.class);
> FooFactory mockFactory = mock(FooFactory.class, withSettings().serializable());
> when(mockFactory.createFoo()).thenReturn(foo);
> SubjectUnderTest subject = new SubjectUnderTest(mockFactory);
> 
> But when the framework serializes subject, we get an exception, because
> the line of when(mockFactory.createFoo()).thenReturn(foo) implicitly adds
> 'foo' as part of mockFactory state.
> 
> To work around the problem, our tests had to make foo serializable too:
> 
> Foo foo = mock(Foo.class, withSettings().serializable());
> ...
> 
> Again, production code doesn't need Foo to be Serializable and it may not
> have a default constructor.
> 
> That's status quo.
> 
> Now with v1.10.19, the above work-around breaks, because Foo doesn't
> implement Serializable nor has a default constructor.
> 
> Back to square one, if I had the choice, I would strongly discourage the
> code that mocks either FooFactory or Foo. Instead, it should just be a
> plain old FooFactory subclass that returns Foo. With Java 8, the syntax
> would actually become more concise than the mockito syntax.
> 
> But I can't go back and fix so many teams' code. As it stands today, this
> is the biggest issue blocking the upgrade.
> 
> Hopefully I've made a clear case.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/245#issuecomment-118431952.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Hi, is this reasonable? I can send a PR to remove this check, if it's okay with you guys.
 =||= Let's remove the check unless Brice objects ;)

On Fri, Sep 18, 2015 at 9:08 PM, Ben Yu notifications@github.com wrote:

> Hi, is this reasonable? I can send a PR to remove this check, if it's okay
> with you guys.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/245#issuecomment-141618665.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= @szczepiq @fluentfuture is this fix available in any of the mockito releases?
 =||= @vikkyrk since 2.0.31-beta
 =||= Thanks 
 =||= ",0
342,256,task mockitoJavadoc fails when compiling in windows,"When compiling the mockito project using gradle in a command line in Windows following compile error occurs:

javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/jdk6-project-version-insert.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/jquery-1.7.min.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/highlight-8.6-java/highlight.pack.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<link""
javadoc: error - Illegal package name: ""rel=""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/css""
javadoc: error - Illegal package name: ""href=""
javadoc: error - Illegal package name: ""{@docRoot}/js/highlight-8.6-java/styles/obsidian.css""
javadoc: error - Illegal package name: ""/>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: ""=""
javadoc: error - Illegal package name: ""&&""
javadoc: error - Illegal package name: ""parseInt($.browser.version)""
javadoc: error - Illegal package name: ""<""
javadoc: error - Illegal package name: ""9;""
javadoc: error - Illegal package name: ""if(!usingOldIE)""
javadoc: error - Illegal package name: ""{""
javadoc: error - Illegal package name: ""$(""
javadoc: error - Illegal package name: "").append(""
javadoc: error - Illegal package name: ""<link rel=\""
javadoc: error - Illegal package name: ""icon\\""
javadoc: error - Illegal package name: "" href=\""
javadoc: error - Illegal package name: ""{@docRoot}/favicon.ico?v=cafebabe\\""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: "")""
javadoc: error - Illegal package name: ""$(""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""window.parent.document).append(""
javadoc: error - Illegal package name: ""<link rel=\""
javadoc: error - Illegal package name: ""icon\\""
javadoc: error - Illegal package name: "" href=\""
javadoc: error - Illegal package name: ""{@docRoot}/favicon.ico?v=cafebabe\\""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: "")""
javadoc: error - Illegal package name: ""hljs.initHighlightingOnLoad();""
javadoc: error - Illegal package name: ""injectProjectVersionForJavadocJDK6(""
javadoc: error - Illegal package name: ""Mockito 2.0.29-beta API""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""em#mockito-version-header-javadoc7-header""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""em#mockito-version-header-javadoc7-footer""
javadoc: error - Illegal package name: "");""
javadoc: error - Illegal package name: ""}""
javadoc: error - Illegal package name: ""</script>""
javadoc: error - Illegal package name: """"
javadoc: warning - No source files for package stylesheet
javadoc: warning - No source files for package var
javadoc: warning - No source files for package usingOldIE
javadoc: warning - No source files for package $.browser.msie
javadoc: warning - No source files for package head
javadoc: warning - No source files for package shortcut
javadoc: warning - No source files for package head
javadoc: warning - No source files for package shortcut
64 errors
8 warnings

I tracked the issue down to gradle/javadoc.gradle where the gradle scripts sets the bottom property to a java script with multiple lines. 

Changing that to a single line seems to be make it possible to complete the mockitoJavaDoc task without any errors.","I think most of us work on Linux/OSX, it probably has to do with the JDK
version and windows line endings.

So minifying this javascript code may work ?

-- Brice

On Fri, Jul 10, 2015 at 8:19 AM, Meang Akira Tanaka <
notifications@github.com> wrote:

> When compiling the mockito project using gradle in a command line in
> Windows following compile error occurs:
> 
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/jdk6-project-version-insert.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name: ""{@docRoot}/js/jquery-1.7.min.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/highlight-8.6-java/highlight.pack.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""rel=""
> javadoc: error - Illegal package name: ""type=""
> javadoc: error - Illegal package name: ""text/css""
> javadoc: error - Illegal package name: ""href=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/highlight-8.6-java/styles/obsidian.css""
> javadoc: error - Illegal package name: ""/>""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: ""=""
> javadoc: error - Illegal package name: ""&&""
> javadoc: error - Illegal package name: ""parseInt($.browser.version)""
> javadoc: error - Illegal package name: ""<""
> javadoc: error - Illegal package name: ""9;""
> javadoc: error - Illegal package name: ""if(!usingOldIE)""
> javadoc: error - Illegal package name: ""{""
> javadoc: error - Illegal package name: ""$(""
> javadoc: error - Illegal package name: "").append(""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""icon\""
> javadoc: error - Illegal package name: "" href=\""
> javadoc: error - Illegal package name:
> ""{@docRoot}/favicon.ico?v=cafebabe\""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "")""
> javadoc: error - Illegal package name: ""$(""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name: ""window.parent.document).append(""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""icon\""
> javadoc: error - Illegal package name: "" href=\""
> javadoc: error - Illegal package name:
> ""{@docRoot}/favicon.ico?v=cafebabe\""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "")""
> javadoc: error - Illegal package name: ""hljs.initHighlightingOnLoad();""
> javadoc: error - Illegal package name:
> ""injectProjectVersionForJavadocJDK6(""
> javadoc: error - Illegal package name: ""Mockito 2.0.29-beta API""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name:
> ""em#mockito-version-header-javadoc7-header""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name:
> ""em#mockito-version-header-javadoc7-footer""
> javadoc: error - Illegal package name: "");""
> javadoc: error - Illegal package name: ""}""
> javadoc: error - Illegal package name: """"
> javadoc: error - Illegal package name: """"
> javadoc: warning - No source files for package stylesheet
> javadoc: warning - No source files for package var
> javadoc: warning - No source files for package usingOldIE
> javadoc: warning - No source files for package $.browser.msie
> javadoc: warning - No source files for package head
> javadoc: warning - No source files for package shortcut
> javadoc: warning - No source files for package head
> javadoc: warning - No source files for package shortcut
> 64 errors
> 8 warnings
> 
> I tracked the issue down to gradle/javadoc.gradle where the gradle scripts
> sets the bottom property to a java script with multiple lines.
> 
> Changing that to a single line seems to be make it possible to complete
> the mockitoJavaDoc task without any errors.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/256.
 =||= Fixed via 34f8c69
 =||= Hi Brice

Unfortunately it did not work... I have submitted an alternative suggestion

br

Meang
 =||= ",0
342,259,Removing new line in bottom script. it seems that javadoc…,"… on windows are considering each new line as an argument rather than considering the entire parameter as an argument

The fix that BRIC13 applied in relation to https://github.com/mockito/mockito/issues/256. Did not resolve the issue I have submitted an alternative suggestion, which seems to be working (At least it worked on my machine :p)","## [Current coverage](https://codecov.io/github/mockito/mockito?ref=596d2f5afa0fcf9f3c575577c9549b084296b356) is `83.7%`

> Merging **#259** into **master** will change coverage by **0%** by [`596d2f5`](https://github.com/mockito/mockito/commit/596d2f5afa0fcf9f3c575577c9549b084296b356)

#### Coverage Diff

``` diff
@@            master   #259   diff @@
=====================================
  Files          270    270       
  Stmts         4583   4583       
  Branches       745    745       
  Methods          0      0       
=====================================
  Hit           3836   3836       
  Partial        220    220       
  Missed         527    527       
```

---

### [Uncovered Suggestions](https://codecov.io/github/mockito/mockito/features/suggestions?ref=596d2f5afa0fcf9f3c575577c9549b084296b356)
1. `+0.15%` via [...ializableMethod.java#97...103](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/invocation/SerializableMethod.java?ref=596d2f5afa0fcf9f3c575577c9549b084296b356#97) 
2. `+0.11%` via [...lizationSupport.java#122...126](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java?ref=596d2f5afa0fcf9f3c575577c9549b084296b356#122) 
3. `+0.11%` via [...ns/PluginLoader.java#60...64](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java?ref=596d2f5afa0fcf9f3c575577c9549b084296b356#60) 
4. _[See 7 more...](https://codecov.io/github/mockito/mockito/features/suggestions?ref=596d2f5afa0fcf9f3c575577c9549b084296b356)_

> Powered by [Codecov](https://codecov.io)
 =||= ok I'd rather not do what you propose this way then. Which version of JDK are you running exactly ?
 =||= Hi Brice

I am running java 8 build 45.

Br

Meang

On Sat, Jul 11, 2015, 11:27 Brice Dutheil notifications@github.com wrote:

> ok I'd rather not do what you propose this way then. Which version of JDK
> are you running exactly ?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/259#issuecomment-120598324.
 =||= OK, I'll see what can be done, inlining this script here really hurts readability.
 =||= Fixed by #342 
 =||= ",0
373,365,Simplify the InvocationOnMock-API to get a casted argument,"The 2nd argument of  `InvocationOnMock.getArgumentAt(int,Class<T>)` can be removed cause it is not neccessary.

Intuitively on would write this to get a ""auto casted"" argument:
`String text = invocation.getArgumentAt(1,String.class)`

The type can be ommited without side effects (the implementation of InvocationOnMock discards it anyway).
`String text = invocation.getArgumentAt(1,null)`

Therefore Mockito 2.0 should consider to simplify the API and ommit the `Class`-argument here. Maybe it is also a good chance to simplify the method name too. What about  `getArgument(int index)` ?

This is how the 'new' API could look like:
`String text = invocation.getArgument(1)`","I would like to mention that sometimes class argument can be useful.

In my case I would like to catch object passed to mock and write to mongo database.
The code I would like to have is:

```
// test setup
doAnswer(invocation -> mongoTemplate.insert(invocation.getArgument(0, Person.class)))
  .when(mock)
  .myMethod(any());

// test execution 
mock.myMethod(new Person(""Joe"", ""Doe""))
```
The reason of problem is that `MongoTemplate` has 2 similar methods:
```
public <T> ExecutableInsert<T> insert(Class<T> domainType) {...) //(1)
public void insert(Object objectToSave) {..) //(2)
```
AFAIU, when I setup `doAnswer(invocation -> mongoTemplate.insert(invocation.getArgument(0))`, type inference will choose method (1) and finally I get class cast exception `Person` -> `Class`

Unfortunately, code `doAnswer(invocation -> mongoTemplate.insert((Person)invocation.getArgument(0))` does not compile

To implement my test, I have to define anonymous class `Answer` so my code is long-winded - one-liner looks much better
 =||= ",0
380,379,Verification using After and ArgumentCaptor with Times or AtLeast methods returns unexpected size of captured values list.,"Hi!
I was looking issue #345 and found that the test ""shouldReturnListOfArgumentsWithSameSizeAsGivenInAtMostVerification"" (located in VerificationAfterDelayTest.java) fails if you use atLeast() or times() instead of atMost().
I created these tests:

![screenshot from 2016-03-24 16 50 29](https://cloud.githubusercontent.com/assets/17257307/14034443/8a3d8b98-f1e0-11e5-856a-65dc20a4fa6b.png)","@thesnowgoose 
That a bug in VerificationOverTimeImpl#verify(VerificationData). The passed `VerificationData` contains all invocations, in your case ""0"",""1"" and ""2"". During the specified 200ms these invocations are verified in a loop without delay. That means if your CPU is able to verify the VerificationData 10,000 times during that 200ms the captor captures 30,000 arguments (10000 \* 3 arguments ). 

The implementation of `After` uses `VerificationOverTimeImpl` and that class performs the verify-loop until the time is elapsed.  This behaviour is fine for `Timeout` but violates the specification of  `Mockito.after(long)`, this is what the JavaDoc says:

> Allows verifying over a given period. It causes a verify to **wait for a specified period of time** for a desired interaction

In other words the `After` implementation must use some kind of `VerificationAfterDelayImpl`, that simply waits and than verify the invocations.

I have a solution and will provide a PR.
 =||= PR #380 relates to this issue.
 =||= Fixed by #380 
 =||= Why is this closed? I ran into the issue and lost about an hour before realizing it is a Mockito bug. What is the current status? It is not fixed in the 1.x branch. I am using 1.10.19 which seems the most recent version.
 =||= @jmborer can you test it with the latest 2.0.0-beta build, it should be fixed
 =||= OK. Thanx for the info, but I don't feel confortable to use a beta version to test operational sofware...
 =||= The beta is almost over, I hope to publish a release candidate in the
coming days. You should be able to upgrade without much problems, since the
breaking changes are kept at a minimum.

On Thu, 18 Aug 2016, 16:12 Jean-Marc Borer, notifications@github.com
wrote:

> OK. Thanx for the info, but I don't feel confortable to use a beta version
> to test operational sofware...
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/379#issuecomment-240735180,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb3NREzSakS3dFBKOKP-cyi5DMdb5ks5qhGhXgaJpZM4H4c7l
> .
 =||= @jmborer mockito 2 beta is fairly stable, the API should not move much. Yet there's some incompatible change with 1.x

> I don't feel confortable to use a beta version to test operational sofware...

Remember it's for tests not to run on your production servers/containers
 =||= Sure. I won't use in production. I'll wait a little until RC is out to do the migration. I already noticed it is no  longer compatible with PowerMock. I have to check if I need it anymore then my problem is solved. 
 =||= Was this actually merged into a release? I initially found the issue while running 2.0.41-beta, so I tried 2.4.0 and 2.8.9, but I'm still seeing the issue, specifically with after() and times(). 

 =||= ",0
381,312,ThrowsExceptionClass is urealiable - exception doesn't containt stack trace,"The `ThrowsExceptionClass` is using `ObjenesisHelper.newInstance` which happens to have different strategy of creating objects depending on the JVM used. 
I'm using Java HotSpot VM. On this machine ,created `Throwable`, is initalized with all nulls.
As a result calling `throwable.fillInStackTrace()` has no effect and there is no chance the stack trace is ever filled. You can easily observe this behaviour by this sample code:

``` java
Throwable t = (Throwable) ObjenesisHelper.newInstance(Throwable.class);
t.fillInStackTrace();
t.printStackTrace();
```

After a bit of struggling I ended up using `ThrowsException` instead of `ThrowsExceptionClass`.

Objenesis strategy to create instances is dependent on VM name (returned by `System.getProperty(""java.vm.name"")`) so there is no 100% guarantee that this behaviour is reproduced on your machine.","OK thanks for the report, can you make a pull request to document that behaviour for `ThrowsExceptionClass`
 =||= Thanks @zbigniewTomczak for doing the research on this.  I just added the documentation.  It's in PR #381.
 =||= ",0
386,374,Remove deprecated API from Mockito 2 ,"# This is a reminder to remove all deprecated API's from the upcoming mockito 2.

This issue blocks #123 [Release Mockito 2.0](123)

Relates to 
-  #273 [Get rid of ReturnValues](273)",nan,0
404,374,Remove deprecated API from Mockito 2 ,"# This is a reminder to remove all deprecated API's from the upcoming mockito 2.

This issue blocks #123 [Release Mockito 2.0](123)

Relates to 
-  #273 [Get rid of ReturnValues](273)",nan,0
412,407,Vararg method call on mock object fails when used org.mockito.AdditionalAnswers#delegatesTo,"I try to mock interface with varargs method and default implementation in final class and get this error:

```
java.lang.IllegalArgumentException: wrong number of arguments

    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations.answer(ForwardsInvocations.java:31)
    at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:93)
    at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
    at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:38)
    at org.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:51)
```

I run the following code:

``` java
public class DefaultAnswerDemo {

    public interface Foo {
        void bar(String baz, Object... args);
    }

    public static final class FooImpl implements Foo {

        @Override
        public void bar(String baz, Object... args) {
            System.out.println(""bar"");
        }

    }

    @Test
    public void defaultAnswerTest() {
        Foo fooImpl = new FooImpl();

        Foo foo = mock(Foo.class, withSettings()
                .defaultAnswer(delegatesTo(fooImpl)));

        foo.bar(""baz"", 12, ""45"", 67.8);
    }

}
```

This is happens because org.mockito.internal.invocation.InvocationImpl by default expands varargs arguments to flat list. And I have no idea, how correctly fix this.","This is a bug in [ForwardsInvocations](https://github.com/mockito/mockito/blob/master/src/main/java/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java#L41), as you already investigated the expanded varargs are passed to the delegate.

The current implementation does this:

```
result = delegateMethod.invoke(delegatedObject, arguments);
```

Mockito look for method with the signature `String,int,String,double` for the given arguments (""baz"",12,""45"",67.8), but such a method doesn't exists.

To fix the issue the raw/unexpanded arguments must be used

```
Object[] rawArguments = ((Invocation)invocation).getRawArguments(); 
result = delegateMethod.invoke(delegatedObject, rawArguments);
```

Now Mockito looks for method signature `String,Object[]` which is the var args method you want. Note: It is safe to cast to `Invocation` here cause answers always get a Invocation-Instance passed from `MockHandlerImpl`. 

If I find some time I will send a PR with a fix or you or some one else start to fix it. 
 =||= Here is PR. I thought about cast, but may be better pull up method [org.mockito.invocation.Invocation#getRawArguments](https://github.com/mockito/mockito/blob/master/src/main/java/org/mockito/invocation/Invocation.java#L42) to interface [org.mockito.invocation.InvocationOnMock](https://github.com/mockito/mockito/blob/master/src/main/java/org/mockito/invocation/InvocationOnMock.java)?
 =||= @andreyrmg 
Pulling `getRawArguments()` up to `InvocationOnMock` would help in this narrow use case. On the other side it bloat the public API and migth confuse clients that implement custom Answer's, which method to choose `getArguments()` or `getRawArguments()`.  

WDYT?
 =||= Yes, I agree with you. But I think, this is already a bit confusing that method `getArgument()` returns expanded varargs. Maybe we need two methods `getArguments()` and `getExpandedArguments()`?
 =||= Adding new API or changing existing behaviour need to be discussed with the core-members.

I agree with you, `getArguments()` should return unaltered/not expanded arguments. The current `getArguments()` implementation has also the problem that is can't distinguish an null-vararg argument / `varArgMethod(new Type[]{null})` from an null-varag array / `varArgMethod((Type[])null)`.
 =||= ",0
424,20,Implemented support for InOrder evaluation of Timeout VerificationMode,"Fixed for [issue 292](https://code.google.com/p/mockito/issues/detail?id=292)

Note that while the provided wrapping mechanism is generic enough to support both 'timeout' and 'after' usage, the current implementation of VerificationWithTimeoutTest.java prevents correct usage with 'after'. This is because it repeatedly verifies until the timeout has elapsed, thus marking all invocations that may have matched in the meantime as verified. This will of course 'exhaust' correct invocations and more often than not fail on the verification before the 'ager time' has elapsed.","Hi, I'm basically ok with the PR, however I have a few remarks :
- I don't like the name `VerificationWrapperInOrderWrapper`, I would prefer something more meaningful, in the same way the existing `VerificationWrapper` could be renamed as well. If you have some proposition, I'll gladly hear them.
- Also it might be interesting to refactor existing code to support `VerificationInOrderMode` so the code don't have to check against `VerificationWrapper` class
 =||= I'll review it soon. Thanks for the PR!
 =||= This is a feature I'd like too. What's the status of this? Any plans to merge it or put it on the road map?
 =||= We want to merge it but so far there wasn't enough time. Sorry!
 =||= I could also use this feature! :+1: 
 =||= @sirchia could you please rebase this PR on current master, then I can take a look and review. Sorry for the extremely delayed response, hopefully you are still interested in making this contribution up-to-date.

If this PR is not updated within 2 weeks, I will close it as stale.
 =||= @TimvdLippe I had actually done that for my own private usage a while back. I've provided a https://github.com/mockito/mockito/pull/424 that rebases the original PR by @sirchia
 =||= ",0
427,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
431,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
432,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
442,304,Problem verifying bridge methods,"Hello, I think there might be a bug in mockito when verifying bridge methods.
The bug is present both in version 2.0.31-beta, and in version 1.10.19.

``` java
import java.io.Serializable;
import org.junit.Test;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

public class MockitoBridgeTest {

    @Test
    public void test() {
        Extended ext = mock(Extended.class);
        ext.test(""123"");
        verify(ext).test(""123""); // Passes
        ((Base<String>)ext).test(""456"");
        verify(ext).test(""456""); // Fails
    }

    public interface Base<T extends Serializable> {
        int test(T value);
    }

    public interface Extended extends Base<String> {
        @Override
        int test(String value);
    }

}
```","The problem here is the following: Byte Buddy does not intercept bridge methods but assumes that these methods should be dispatched _as they are_. Therefore, the actual method is still invoked which is then intercepted. As a result, the `Method` instance that is bound to this interception is the actual method, i.e. `test(String)` and not `test(Serializable)` which was identified as the bridge. The behavior of cglib is similar.

Mockito on the other hand picks up the invoked method from the call site which is `test(Serializable)` fpr the secod example. Therefore, Mockito claims that another method is invoked. Instead, Mockito would need to resolve the method to its actual target in order to validate that this method is a bridge for `test(String)`.

I am going to look into how this can be added to Mockito. This requires resolving parameterized tyes along the hierarchy in order to find out to what method the bridge is actually pointing to.
 =||= Since somebody else has this issue, I found a workaround to make the test pass:

``` java

        ((Base<String>)ext).test(""456"");
        verify(ext).test(""456""); // Fails
        ((Base<String>)verify(ext)).test(""456""); // Passes (workaround)
```
 =||= @bric3 Would it be a feasible solution if I relied on Byte Buddy APIs to resolve this? I implemented a rather elaborate algorithm that I have tried to port to Mockito. However, its not as easy as I thought since the algorithm and related data structure are quite bound into the Byte Buddy APIs. I would of course add an interface that does not rely on Byte Buddy for querying this information but asking the library to do it would be the most straight-forward solution.
 =||= @raphw That is possible, maybe in the form of a _`Plugin`_ that ByteBuddy mockmaker implement, maybe we would need a default implementation, i.e. that does nothing.
 =||= ",0
444,438,Add ElementType.PARAMETER to @Mock,"Parameterized tests are becoming more common - JUnit 5 explicitly allows parameters and the sample [MockitoExtension](https://github.com/junit-team/junit5-samples/tree/master/junit5-mockito-extension/src/main/java/com/example/mockito) currently includes an @InjectMock to trigger the creation of a mock parameter.  It would be so much cleaner to use @Mock in both places.

This shouldn't be an issue for most legacy test systems since they don't allow test parameters (by default). ","@smoyer64 I think that is a reasonable addition. Do you maybe have a sample JUnit test case that I can add to our test suite as regression test?
 =||= @TimvdLippe,

Will this change be going into Mockito 1.x or 2.x (or both)?
 =||= @sbrannen Mockito 2.0. We might be able to port back to Mockito 1.x but I would prefer not to. Is there an explicit requirement for this change to be included in 1.x?
 =||= Regarding a regression test, this should do the job!

``` java
import static org.junit.Assert.assertTrue;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

import org.junit.Test;
import org.mockito.Mock;

/**
 * It's actually sufficient if this class compiles. The test methods
 * are therefore a bit superfluous.
 *
 * @author Sam Brannen
 */
public class MockAnnotationDeclarationTests {

    @Mock
    String foo;

    void bar(@Mock String baz) {
    }

    @Test
    public void mockAnnotationCanBeDeclaredOnField() throws Exception {
        Field field = getClass().getDeclaredField(""foo"");
        assertTrue(field.isAnnotationPresent(Mock.class));
    }

    @Test
    public void mockAnnotationCanBeDeclaredOnParameter() throws Exception {
        Method method = getClass().getDeclaredMethod(""bar"", String.class);
        assertTrue(method.getParameters()[0].isAnnotationPresent(Mock.class));
    }

}
```

So feel free to use that.

Cheers,

Sam
 =||= @TimvdLippe,

I don't suppose there is an explicit _requirement_ per se to have this support in 1.x; however, I feel it could well benefit 1.x users who also wish to use JUnit 5. Furthermore, I cannot foresee any possible negative side effects for 1.x users: it's 100% backwards compatible.
 =||= I do not think we really have an infrastructure to still publish Mockito 1 artifacts. We did however not change much in 2 and 99% of all Mockito code should run as expected after updating. Mainly, we removed deprecated code that people had years to upgrade.

I think adding this should be okay even though there is no scenario where Mockito itself would process the annotation. Would adding an annotation to the JUnit plugin not be another altivertive? I wonder if that was a cleaner solution.
 =||= > Would adding an annotation to the JUnit plugin not be another altivertive? I wonder if that was a cleaner solution.

Introducing a new annotation in Mockito's official JUnit 5 support is of course technically possible -- that's what our proof-of-concept `MockitoExtension` does today (i.e., we created an `@InjectMock` annotation).

But... I don't think I would call that a _cleaner solution_. IMHO, a single annotation from Mockito would be the cleanest solution since it would result in the **element of least surprise** for users of Mockito.

FWIW, we have already hashed out the [exact same discussion for the Spring Framework](https://jira.spring.io/browse/SPR-14057) with regard to Spring's `@Autowired` annotation. Previously, it was not allowed to be declared on a constructor or method parameter, but we changed this for Spring 4.3.
 =||= Ok, considering that JUnit and Mockito is such a common combination, let's just make it as easy as possible.
 =||= Sounds good! 👍 
 =||= Wow ... a lot of work got done while I was out celebrating Father's Day.  From a user's perspective, this all looks perfect.  How often do you get everything you ask for?  I guess I have one final  question which, since this issue is closed, is more academic - where should an official, production ready MockitoExtension for JUnit 5 be hosted?  MockitoJunit is obviously part of the Mockito project and the MokitoExtension will always rely on both Mockito and JUnit 5.

Maintaining the status quo would be fine, but it might also make sense to create a junit5-extensions project for ""common combinations"" (using the wording above), where a combination of project maintainers could collaborate on code that is essentially the intersection of their projects?  External Extensions and TestEngines are going to be documented in the JUnit 5 wiki per issue https://github.com/junit-team/junit5/issues/297 and, given the collaboration demonstrated by this thread, maybe the whole question is moot.

In any case, thanks for all the hard work that's gone into both projects!
 =||= @smoyer64 You got lucky we are working hard on releasing Mockito 2.0 :smile: 

I am not sure what the stance is of the JUnit team regarding such extensions. Could you open an issue on JUnit5 to discuss where such extensions should be placed?
 =||= @TimvdLippe 

The question has been posed to the JUnit 5 team in issue https://github.com/junit-team/junit5/issues/321.  @sbrannen is a member of that team, so I'm guessing he's already seen the question ;).  And I'm just one of those pesky users (trying to help identify use cases and stress-test the new code)!
 =||= Thanks a lot. Looking forward to their response.
 =||= ",0
451,433,Fix swinging concurrent tests,"The following concurrent tests fail currently with a >50% chance. This should be fixed!

Here is a build with multiple failed test that are related to concurrent issues #763 https://travis-ci.org/mockito/mockito/builds/128143294

```
VerificationAfterDelayTest.shouldVerifyNormallyWithSpecificTimes 
VerificationWithTimeoutTest.shouldAllowMixingOnlyWithTimeoutAndFail
VerificationWithTimeoutTest.shouldAllowMixingOtherModesWithTimeout
VerificationWithTimeoutTest.shouldAllowMixingOnlyWithTimeout 
VerificationWithTimeoutTest.shouldAllowMixingOtherModesWithTimeoutAndFail
```","Those are time-out-dependant test. Those are generally a bit hard to test but I have never seen them fail. Maybe it depends on how busy Travis is at the moment.
 =||= I have restarted. Let's see if they keep on failing. If they are passing now I would file it under flakiness and disregard the failures.
 =||= Oh right, the original PR was closed so Travis could not pull the branch :stuck_out_tongue_closed_eyes:

Looking at our build history it seems to be happening very rarely. So if it happens again we should restart the build. If it then fails again a manual inspection should be done.
 =||= ",0
454,453,Either revert recent Functional Interfaces change or change JavaDoc,"I've been reading the Javadoc regarding `ArgumentMatcher` and I noticed a couple of things. Relating back to the changes of #338 
- The example of how to override it is still based around `Object` rather than `T`
- Someone has very deliberately decided not to make it use `T` in the past and now we've changed that.

> The argument is not using the generic type in order to force explicit casting in the implementation. This way it is easier to debug when incompatible arguments are passed to the matchers. You have to trust us on this one. If we used parametrized type then ClassCastException would be thrown in certain scenarios.

My view at the time was that changing it to `T` would remove the class casting and that this would be a good thing. It was kind of necessary to have it as `T` so that the lambda expressions in Java 8 could infer the right types.

The rationale about a class cast exception giving weird results kind of makes sense, but does that really really happen? It seems it's either solve one problem or the other.

What do folks think? I'll happily amend the code either way.","I can't imagine a scenario where the parameterized type cause problems and why it aids debuging if no type parameter is used.

@all Do we have examples that illustrate the described problem? If not the JavaDoc should be removed!
 =||= #454 is one way we could wrap this up. Sorry for not noticing it sooner!
 =||= If we receive such a report, we should catch such an exception and log an appropriate error why this is happening. For now I can't see this breaking, but I am happy to be proven wrong.
 =||= ",0
462,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
471,385,OSGi metadata is incorrect,"The manifest is incorrectly exporting the org.objenesis package. This package is not included in the mockito jar, so this package needs to be imported rather than exported.","Is it a duplicate of #383? 

We need help fixing OSGi support. See my comment in #383 

Thanks for reporting!
 =||= @seanrohead Which version are you referring to? I just checked the manifest of the latest version (`2.0.63-beta`) and the only mention of `org.objenesis` in the import package section. I guess https://github.com/mockito/mockito/pull/388 fixed this issue. I would be nice if you could give `2.0.63-beta` a try and let us know if it works for you. Thanks!
 =||= It looks like the metadata is now correct, however when running tests in an osgi container, I am unable to mock classes (see error below). I built a custom version of the mockito jar and embedded the byte-buddy and objenesis classes inside the mockito jar (instead of loading them as separate bundles) and the error went away. I think the problem is that byte-buddy classloader doesn't have access to the same classes as the mockito classloader when they are in separate bundles. I'm happy to send a copy of the jar file that I was able to get to working.

This is the error I get if I use the mockito jar file in maven (org.mockito:mockito-core:2.0.70-beta):

```
com.proofpoint.governance.agent.tagging.file.sync.test.TaggedFileSyncServiceIntegrationTest STANDARD_ERROR
    org.mockito.exceptions.base.MockitoException:
    Mockito cannot mock this class: interface com.proofpoint.governance.agent.tagging.file.sync.api.ServerTaggedFileSyncService

    Mockito can only mock visible & non-final classes.
    If you're not sure why you're getting this error, please report to the mailing list.

    Underlying exception : java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#findClass

        at com.proofpoint.governance.agent.tagging.file.sync.test.osgi.FileTaggingSyncTestActivator.init(FileTaggingSyncTestActivator.java:14)
        at com.proofpoint.governance.common.osgi.api.BaseActivator.init(BaseActivator.java:36)
        at org.apache.felix.dm.DependencyActivatorBase.start(DependencyActivatorBase.java:75)
        at org.apache.felix.framework.util.SecureAction.startActivator(SecureAction.java:697)
        at org.apache.felix.framework.Felix.activateBundle(Felix.java:2226)
        at org.apache.felix.framework.Felix.startBundle(Felix.java:2144)
        at org.apache.felix.framework.Felix.setActiveStartLevel(Felix.java:1371)
        at org.apache.felix.framework.FrameworkStartLevelImpl.run(FrameworkStartLevelImpl.java:308)
        at java.lang.Thread.run(Thread.java:745)
    Caused by: java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#findClass
        at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Resolved.loadClass(ClassInjector.java:401)
        at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:210)
        at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:204)
        at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default.load(ClassLoadingStrategy.java:119)
        at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4350)
        at org.mockito.internal.creation.bytebuddy.MockBytecodeGenerator.generateMockClass(MockBytecodeGenerator.java:60)
        at org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator$CachedBytecodeGenerator.generate(CachingMockBytecodeGenerator.java:73)
        at org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator$CachedBytecodeGenerator.getOrGenerateMockClass(CachingMockBytecodeGenerator.java:65)
        at org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator.get(CachingMockBytecodeGenerator.java:28)
        at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createProxyClass(ByteBuddyMockMaker.java:54)
        at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:27)
        at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:33)
        at org.mockito.internal.MockitoCore.mock(MockitoCore.java:64)
        at org.mockito.Mockito.mock(Mockito.java:1559)
        at org.mockito.Mockito.mock(Mockito.java:1472)
        ... 9 more
    Caused by: java.lang.NoClassDefFoundError: org/mockito/internal/creation/bytebuddy/MockMethodInterceptor$MockAccess
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Resolved.loadClass(ClassInjector.java:397)
        ... 23 more
    Caused by: java.lang.ClassNotFoundException: org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$MockAccess
        at java.lang.ClassLoader.findClass(ClassLoader.java:530)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at net.bytebuddy.dynamic.loading.MultipleParentClassLoader.loadClass(MultipleParentClassLoader.java:67)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        ... 30 more
```
 =||= I think you are right and we did it wrong when we ported the old ""searching class loader"" to Byte Buddy's multiple parent class loader. The old solution strongly referenced types defined by cglib while Byte Buddy short wires the interceptors from Mockito without creating any Byte Buddy dependency. Typically, Byte Buddy's and Mockito's class loaders are equal. This is only not the case when exporting both libraries as OSGi bundles. If you bundle both libraries in the same jar, this class loader equality is reinstated which is why this works.

As a consequence of the change code generation strategy, we do not even need to export Byte Buddy, it is never exposed by Mockito in the generated code.

As you already created a custom build, can you try changing the `MockBytecodeGenerator` to create a multiple parent class loader as follows:

``` java
new MultipleParentClassLoader.Builder()
  .append(features.mockedType)
  .append(features.interfaces)
  .append(Thread.currentThread().getContextClassLoader())
  .append(MockAccess.class, DispatcherDefaultingToRealMethod.class)
  .append(MockMethodInterceptor.class, 
               MockMethodInterceptor.ForHashCode.class, 
               MockMethodInterceptor.ForEquals.class)
```

Thank you for your analysis and help so far, we appreciate it!
 =||= ",0
481,226,Exclude internal package from javadoc,"Internal package don't need to be included in the javadoc generation, just like the jdk doesn't have `com.sun` package

In the javadoc that may be done via a doclet since `exclude '**/internal/**'` raise javadoc errors

``` groovy
doclet = ""qualified.name.of.DocletExclude""
docletpath = [rootProject.file('./gradle/doclet-exclude.jar')]
```","Great idea.
 =||= ",0
483,123,Release Mockito 2.0,"Incompatible changes:
- [x] stop producing mockito-all #153
- [x] stop depending on hamcrest internally #154
- [x] use newer hamcrest #232
- [x] make the anyXxx and any(Xxx) matchers intuitive #134, #194
- ~~fix the site links~~
- [x] push cglib mockmaker to a separate jar #248
- [x] stop using ant for producing OSGi bundles. No more ant in the build #249
- [x] remove jars from source distribution #250
- ~~perhaps introduce is() matcher~~ #246
- ~~richer and smarter stubbing~~ #303
- ~~support java8 features for capturing arguments and matchers~~
- [x] make the JUnitRule and the runner verbose
- [x] ensure release notes can be neatly generated for the RC #582

Possibly compatible (and hence, could be released pre-2.0 if needed)
- [x] drop deprecated code
- [x] unincubate API
- ~~drop serialVersionUID~~","Is it still planned for 2.0 to give users an option to use an alternative to cglib (like Byte Buddy)?
 =||= This kind of feature can be added any time (e.g. it's not a backwards-incompatible change). It's just someone needs to implement it :) 

So short answer is 'no', it's not planned for 2.0 (but I would love to have this feature soon)
 =||= If possible I would really like to replace CGLIB by bytebuddy.

I wanted to craft an external MockMaker but I'm way too much overwhelmed at the moment. The code exists in my clone though.
 =||= @bric3, you mean that you're keen on changing default proxy mechanism in 2.0? I'm fine with this :) I do want to publish 2.0 this year though and I won't be very active it this part of the code. So, if you make it, it can be included :)
 =||= @szczepiq You mean by the end of 2014 ?

What I hoped was to build a mockmaker that could be tested on the 1.x. But the code may replace CGLIB now if necessary. Beta have to be tested by other people though, I especially think about uncommon environment like OSGI, etc...
 =||= 1>You mean by the end of 2014 ?

haha, yeah ;)

> What I hoped was to build a mockmaker that could be tested on the 1.x.

Like an opt-in feature for 1.x?

I definitely think that given we have the bytebuddy impl of MockMaker, we
should make it conveniently pluggable instead of just replacing cglib
completely. You mentioned earlier that you had the ByteBuddy MockMaker
working with Mockito test suite?

Cheers!

On Mon, Nov 24, 2014 at 4:18 PM, Brice Dutheil notifications@github.com
wrote:

> You mean by the end of 2014 ?
> 
> What I hoped was to build a mockmaker that could be tested on the 1.x. But
> the code may replace CGLIB now if necessary. Beta have to be tested by
> other people though, I especially think about uncommon environment like
> OSGI, etc...
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-64208043.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= > > What I hoped was to build a mockmaker that could be tested on the 1.x.
> 
> Like an opt-in feature for 1.x?

Yes. But, meanwhile replacing CGLIB in mockito 2.0.

> You mentioned earlier that you had the ByteBuddy MockMaker working with Mockito test suite?

Yes it does. I just would like to ensure it works with uncommon environment like OSGI.
 =||= Do you think it is worthwhile to keep support for cglib once we have
bytebuddy?

Do you think we should shade bytebuddy? What dependencies bytebuddy brings?

On Mon, Nov 24, 2014 at 6:26 PM, Brice Dutheil notifications@github.com
wrote:

>  What I hoped was to build a mockmaker that could be tested on the 1.x.
> Like an opt-in feature for 1.x?
> 
>  Yes. But, meanwhile replacing CGLIB in mockito 2.0.
> 
> You mentioned earlier that you had the ByteBuddy MockMaker working with
> Mockito test suite?
> 
> Yes it does. I just would like to ensure it works with uncommon
> environment like OSGI.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-64229927.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= No I don't think it is necessary, however we can make a CGLIB mock maker, for people that may depend on it.
 =||= I am curious: Do you guys have a time-line for the 2.0 release? I am more than happy to support any code-generation releated issues. However, my vacation is approaching so I will be gone for a couple of weeks starting mid-August.

In particular, I wonder you guys wanted to try integrating Byte Buddy 0.7 with support for generic type retention already in 2.0 which I hope to complete before my vacation. One word of warning: Generic types are awefully complex. Byte Buddy needs to parse stringified type information and resolve the full type hierarchy, i.e. bind type variables of super types / interfaces to their actual values in order to appropriately resolve a type variable's value while dealing with the possibility of raw types and potentially illegally formatted generic types (the JVM does not verify generic type infromation which simply exists as meta data). There is a chance for corner case errors even though I isolated the functionality pretty much to fall back to type erasure if any illegal type information is disovered. At the same time, mocks would behave better when a generic type is read by a class processing a mock.
 =||= It must happen in 2015. I hope we are ready in the next few months. In
theory, there's not much left work :)

Cheers!

On Fri, Jul 10, 2015 at 5:31 AM, Rafael Winterhalter <
notifications@github.com> wrote:

> I am curious: Do you guys have a time-line for the 2.0 release? I am more
> than happy to support any code-generation releated issues. However, my
> vacation is approaching so I will be gone for a couple of weeks starting
> mid-August.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-120399539.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= I think mockito 2.0 is nearly in shape to be released, most work should go in polishing remaining bits of the public API. IMHO current byte buddy version is fine, and already provide subtitle but needed enhancements.

More specifically on generics I believe current support is OK, after all mockito is a TDD tool for a rapid feedback loop, both on the dev workstation and the ci bots. I believe current generics support in the deepstubs answer is enough. About the issue you mention the support class I wrote is probably incomplete but enough, and I agree parsing this metadata is hard. Anyway at the moment if any extended support should be provided on this front it should be provided via a mockmaker plugin.
 =||= Thanks for the info. I just released Byte Buddy 0.7 but I recommend you to not yet update. Generic types are tricky and I already found a corner case in the bridge method resolution that does not work. I'll try to make it stable until the mid of August, though.
 =||= Any guess on when 2.0 will be released?
 =||= It's been silent for past couple of months, everybody busy, etc. Since
yesterday, I'm focusing my spare time on Mockito. I will not stop until 2.0
is out. We cannot guarantee any dates but 2.0 must be released in 2015.

On Sat, Sep 19, 2015 at 8:40 AM, David J. M. Karlsen <
notifications@github.com> wrote:

> Any guess on when 2.0 will be released?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-141681244.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Any updates on when we might see a 2.0 release?
 =||= 2015 is soon over ;) At some point, we need to do a cut in features. I think everybody is quite budy right now. As always, the time before Christmas are busy month for consultant work.
 =||= Soon. This year for sure. Sorry I was distracted! We will probably deliver
2.0 with what we have, no new fancy features ;)
On Nov 10, 2015 4:52 AM, ""Rafael Winterhalter"" notifications@github.com
wrote:

> 2015 is soon over ;) At some point, we need to do a cut in features. I
> think everybody is quite budy right now. As always, the time before
> Christmas are busy month for consultant work.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-155412454.
 =||= Can this task https://github.com/mockito/mockito/issues/300 be included in 2.0 release?
 =||= Feel free to add #374 to the todo list
 =||= 2.0  is coming so slow.
 =||= It's way too slow. I'm on it. Thank you guys for pushing.
 =||= @szczepiq How can we/the community support the mockito core team ?
 =||= > @szczepiq https://github.com/szczepiq How can we/the community support
> the mockito core team ?
> 
> You already are. You guys are great. Thank you for patience and pushing us
> to deliver.

The lagging of beta is my fault. I've started the beta cycle and I should
have completed it. I'm back in the game, though.

Once 2.x final is out we need clarify how community can drive supporting
and maintaining Mockito.

Note that Mockito is continuously delivered so you can open PR to change
the version to ""2.1.0"", and that's it :)

Cheers!

> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-206757516
 =||= @szczepiq I left a pull request for removing deprecated code which is an 2.0 milestone issue - can you pull it/looks good?
 =||= I haven't reviewed yet. THANKS!
On Sun, Apr 10, 2016 at 03:12 David J. M. Karlsen notifications@github.com
wrote:

> @szczepiq https://github.com/szczepiq I left a pull request for
> removing deprecated code which is an 2.0 milestone issue - can you pull
> it/looks good?
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-207953253
 =||= Per Mockito developers discussion:

We want to target publishing the release on July 31st with a release candidate on June 30th.

There is one issue which must be resolved for that, which is #194. Other than that I just found 1 minor TODO [in the Mockito documentation](https://github.com/mockito/mockito/blob/dff5510cb3e97dae414e58ba85825ad01b273c72/src/main/java/org/mockito/Mockito.java#L1091). The other issues can be fixed in a later minor version.
 =||= @TimvdLippe  what about https://github.com/mockito/mockito/issues/300?
 =||= @skabashnyuk I think that we still want to do this, but is not a blocker for the release. We must do it when we have time, but it is okay in my opinion to release it in a later minor version. I have to be honest that I was not participating in the original discussion so I do not know the exact details. @bric3 is the man to talk to :)
 =||= @TimvdLippe @skabashnyuk Humm I think we should really focus energy on mockito 2, TestNG could come later.
 =||= > TestNG could come later.

@bric3 No problem. But why this can't be done in parallel? Code is ready, looks like this is an infrastructure-deployment issue. Or you are planning to do something bigger than just deploy artifacts?
 =||= @skabashnyuk Currently we are focused on releasing Mockito 2.0. This leaves little to no time for other issues sadly. If you are able to configure the deployment, we are happy to accept your pull request! We can devote some of our time to the TestNG issue after we have released Mockito 2.0.
 =||= Some update.

We're not ready for the release but there's good momentum. Let's plan out
what else needs to be done (announcement information, really documentation
around why to upgrade and how, solid plan what's next after the release
candidate, etc.).

I'm confident the RC will be out in August. I plan to announce everywhere
that we plan RB in August. If we don't meet the date there will high degree
of shame ;) Thoughts?

On Sat, Jun 25, 2016 at 3:59 AM, Tim van der Lippe <notifications@github.com

> wrote:
> 
> @skabashnyuk https://github.com/skabashnyuk Currently we are focused on
> releasing Mockito 2.0. This leaves little to no time for other issues
> sadly. If you are able to configure the deployment, we are happy to accept
> your pull request! We can devote some of our time to the TestNG issue after
> we have released Mockito 2.0.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-228532419,
> or mute the thread
> https://github.com/notifications/unsubscribe/AABgp8m2jG-9Rj7USJ1V2s6GJNHLzbdwks5qPQodgaJpZM4C_fdm
> .

## 

Szczepan Faber
Founder @ mockito.org | Twitter @ szczepiq
Author @ https://www.linkedin.com/today/author/6016386
 =||= I think most of the work should be focused on the upgrade guide, there's not much left for 2.0, follow up tasks can be completed in 2.1
 =||= I think we can publish the release candidate while working on the actual upgrade guide (state this in the github release for users to follow). The only two issues that are non-documentation are #384 with PR #527 of @szczepiq and #489 with PR #491 of myself. #527 has some feedback to be processed and #491 is more of a discussion regarding the runner.

Once these two are resolved, we can merge #483 and the release candidate is published :tada: 

For an up-to-date status, see https://waffle.io/mockito/mockito and https://github.com/mockito/mockito/milestone/1
 =||= This is great stuff!!! Thanks a lot Tim for pushing the release forward & organizing it so well.

I'm making good progress on the warnings stuff for JUnit rule and the listener - will update the PR very soon.
 =||= I'm confused why this ticket is closed. I don't see 2.0 in maven central :)
 =||= @szczepiq because this issue was referenced in #483 which I just merged
 =||= ah, GH smartness :)
 =||= As promised here’s suggested plan to get 2.0 out. Please give feedback, sing up for tasks and commit to ETA so that we get 2.0 out :)

Step 1:
- [ ] prepare RC release notes + announcement (highlights, motivation, request for feedback) - #582
- [ ] review and update documentation for 2.0.0 - #596
- [ ] ensure & test manual Mockito releases - #586
- [ ] update CI / build scripts (releasing betas from branch, etc) - #594

Step 2:
- [ ] branch out / fixes to release / Travis - #594

Step 3:
- [ ] pull the trigger for RC!!!!!, close darn #123 !!!!!!
 =||= ![image](https://cloud.githubusercontent.com/assets/5948271/18092170/97fac1ca-6ecb-11e6-83e0-fd2953833359.png)
 =||= I think we have updated all relevant documentation. @bric3 once you branch out to `release/2.x` we can publish the release candidate :tada: 
 =||= I went ahead and published the release candidate. You can download `2.1.0-RC.1` at https://bintray.com/szczepiq/maven/mockito/2.1.0-RC.1#
 =||= By the way I would prefer to have mockito account on bintray 
 =||= Yes agreed. Let's extract a separate issue for that.
 =||= Mockito 2.1.0 has been released, upgrade today :tada: 
 =||= ",0
491,390,Support for JUnit 5 (JUnit Lambda),"I think we should support JUnit 5 with Mockito 2. Currently, we maintain an optional dependency on JUnit four but the JUnit 5 API is completely incompatible to the old one. I already explored the extension mechanism a bit and for our use case, it is quite trivial.

There are some caveats with JUnit 5, for example the possibility to reuse a test instance what would require us to extend the rule for reseting mocks between runs but it is more than doable. Actually, I suggest making `@Mock` a meta annotation, this way, we can completely drop the MockitoJUnitRunner runner and the MockitoJUnit rule and make the setup even easier.

The JUnit 5 API is still in alpha. How do we do this?","JUnit 5 seems to support only Java 8. Is its API Java 7 compatible? Or maybe you meant Mockito 3 (incoming just after Mockito 2, but with official Java 8 support :) )?
 =||= That is why I would suggest to put it into a side-project. JUnit 5 is compiled to Java 8 byte code but we could deliver the integration in Java 6 nevertheless. 
 =||= JUnit 5 looks very promising, extensions replacing [Runner, Rule & ClassRule](http://junit.org/junit5/#extension-model). 

Surprise surprise :sparkles: , here is a sample -> the [MockitoExtension](https://github.com/junit-team/junit5-samples/blob/master/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java)
 =||= While I do think it is worth exploring, in my eyes pushing this to Mockito 3.0 with Java 8 seems more safe. This also gives time for the JUnit team to tinker everything and push to beta, to reduce the compatibility burden for jumping on the train too soon.
 =||= Merging this into #445 
 =||= ",0
492,482,Restore depecated Answers.get() method,"Commit da5e750957b494e7fa0548bf1286d67b8b0386d5 removed the deprecated `Answers.get()` method, however the method was only deprecated in the 2.0 BETA line and never made it into a GA release. It would be helpful if the method could remain in the deprecated form in 2.0 to give people an opportunity to move away from it.

(originally raise by a Spring Boot user [here](https://github.com/spring-projects/spring-boot/pull/6323))","On a related note adding a ""as of"" to the deprecated description would also be useful:

``` java
/**
 * @deprecated as of 2.0 in favor of using the enum-constant directly. This method will be removed in a future release<br> 
 * E.g. instead of <code>Answers.CALLS_REAL_METHODS.get()</code> use <code>Answers.CALLS_REAL_METHODS</code> .
 */
```
 =||= I would agree with @philwebb that this method had been made deprecated in 2.0 (-beta.2) not in 1.10.x (in fact at first it was [removed](https://github.com/mockito/mockito/commit/34f4436d988f04eaf7635b0497067ee8df7971a6) completely and one month later [restored](https://github.com/mockito/mockito/commit/32dce3ea56fb2891b54be48c16a13d2a9eb0cd33) as deprecated), but what is more important `Answers` started implementing `Answer` then. Because of that when I was fixing that issue in Spring Boot it was hard to keep code compatible with both versions at runtime (for 1.x casting using it as Answer does not work, for never 2.x `get()` is not available). In the end I had to [do](https://github.com/spring-projects/spring-boot/pull/6323/files) ugly casting through `Object` to fool the compiler. With that Spring Boot should work fine (at least with changes related to `Answers` :) ), but there could be other tools (PowerMock?) that after removing this method cannot be easily compatible with both Mockito 1.x and 2.x. IMHO it would be good to keep this method in 2.x and remove in 3.x.
 =||= Yes that seems like a good idea. Mind want to open a pull request?
 =||= ",0
499,401,JUnit runner detects unused stubs,"It is useful to know that stubbing in the test was not used. Perhaps the stubbing is not needed? Removal of unnecessary code from the test is important for code clarity.

More details:
- we detect unused stubs only for passing tests (adding different failure to an existing failure could be confusing)
- need to have something similar for JUnit rules (will create separate ticket)
- stubbing in @Before or class constructor should be used in at least one test
- stubbing in test needs to be used in that test","The current impl is not thread safe. Reopening.
 =||= ",0
501,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
502,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
503,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
507,506,Improved exception message for wanted but not invoked,"Currently, Mockito prints following message when specific verification fails:

```
Wanted but not invoked:
mock.simpleMethod();
-> at ....

However, there were other interactions with this mock:
mock.otherMethod();
-> at ....
mock.booleanReturningMethod();
-> at ....
```

It would be useful to print the number of invocations:

```
Wanted but not invoked:
mock.simpleMethod();
-> at ....

However, there were exactly 2 interactions with this mock:
mock.otherMethod();
-> at ....
mock.booleanReturningMethod();
-> at ....
```",nan,0
510,194,Tweaks Matchers.any family matchers behavior,"This issue is a follow up of the work started in #141 by @pimterry. Also here's an extract of a message on [this thread](https://groups.google.com/forum/#!topic/mockito/8_WGBB3Jbtk) of the mailing list :

---

The origin of these methods is they come from `anything` i.e. anything matches, later for shortness and cast avoidance the aliases grew, but the API naming thus became inconsistent with what a human would expect. So this behavior is being changed in mockito 2 beta, to be precise here's the status on these API in the version 2.0.5-beta :
- `any`, `anyObject`, `any(Class)` won't check anything (at first they were just aliases for _anything_ and for cast avoidance), `null` is a valid value
- `anyX` like `anyString` will check the arg is not `null` and that has the correct type
- `anyList` will check the argument is not null and a `List` instance
- `anyListOf` (and the likes) at the moment are just aliases to their non generic counter part like `anyList`

Note this is work in progress (started here in [#141](https://github.com/mockito/mockito/pull/141)), these new behavior can / will change in the beta phase. I'm especially wondering if the `any` family should allow `null` and if not do a type check. For example with these matchers : 
- `any`, `anyObject` stay the same, they currently allow `null` and don't have to do type check anyway
- `any(Class)` currently allows `null` and doesn't do type check => allows `null` and if not checks for the given type
- `any<Collection>Of` currently doesn't allow `null` and does a type check of the collection, not elements => allows `null`, if not checks collection type, if not empty checks element type

Maybe extend/create a _symmetric_  `isA` family API that won't allow any `null` arguments.

---","`any` family is currently _(at his time up to 2.0.5-beta)_ inconsistent on the way they allow or not `null`s. Type checking is ok, but `null` check behavior consistency is also important.
 =||= AnyX gramtaically tends to imply to return false for null because any
object is not null. I agree completely the api should be consistent.

On Sun, Apr 5, 2015, 11:54 Brice Dutheil notifications@github.com wrote:

> any family is currently _(at his time up to 2.0.5-beta)_ inconsistent on
> the way they allow or not nulls. Type checking is ok, but null check
> behavior consistency is also important.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/194#issuecomment-89831862.
 =||= > AnyX gramtaically tends to imply to return false for null because any object is not null.

I'm not anymore of sure of that. Anyway the changes introduced in this API make it inconsistent.
That's why I propose any validates `null`, and if not `null` then validates the type

Also on the mentioned thread _Francisco Olarte_ was proposing a `anyNotNull` family, this could clarify the behavior on `null` of these APIs.
 =||= Agreed. Any should return false for null and false for wrong type (instance
of). Otherwise I think it would violate the principle of least surprise.

On Sun, Apr 5, 2015, 12:57 Brice Dutheil notifications@github.com wrote:

> AnyX gramtaically tends to imply to return false for null because any
> object is not null.
> 
> I'm not anymore of sure of that. Anyway the changes introduced in this API
> make it inconsistent.
> That's why I propose any validates null, and if not null then validates
> the type
> 
> Also on the mentioned thread _Francisco Olarte_ was proposing a anyNotNull
> family, this could clarify the behavior on null of these APIs.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/194#issuecomment-89842760.
 =||= I see anyString() ( and friends ) checking for null and anyObject() not doing it as an inconsistency potentially leading to user surprise. Object is as much of a class as String ( or other ).

Other thing is I fail to see is the difference ( if there is any ) between isA(Klazz) and notNull(Klazz) ( or IsNotNull, but I see that one is a forwarder ). To me they seem they do the same, given the docs, but the code is different and I'm not familiar enough with it to assert they do the same thing. When doing DSL helper libraries I've found ( the hard way ) having slightly different names for the same thing seems a good idea initially, but leads to problem along the way, so I would vote for just having one of notNull/isNotNull ( and isA if it is functionally equivalent ).
 =||= I think there might be confusion here: @szczepiq I don't think the two of you are agreeing. @bric3 seems to be saying that `any` should match nulls and anyNotNull should exist (and presumably not match null), while you're saying that `any` should not match null.

I think the problem here is that there's two use cases that currently aren't clearly separated, both of which we need to support.
1. I don't care what the value I'm matching is _at all_, I want a very simple intuitive wildcard matcher that will match absolutely anything, and will compile with no extra effort (so no casts).
2. I care about the type of the value that I'm matching, but no details beyond that. I want a matcher that will not match values with the wrong type.

I think both of these are major common use cases. If we make any of the `anyX()` methods reject nulls, they no longer support the first case, and if we leave it as-is then they currently appear to support the 2nd case but aren't really doing so, which is where all this came from originally.

I do think any API that supports use case 2 should reject nulls by default: if you're asserting specifically on the type of the value, we should push people to be clear about whether or not null is valid in the given case. I think an API for use case 1 should not reject nulls, because you want to match _everything_.

These are two quite different APIs though, and to get any kind of API consistency, we're going to need them to be separate sets of methods. I suggest:
- `any()` - matches absolutely anything, including nulls, as a generic method returning T (as now)
- `anyAsX()` and `anyAs(X.class)` - matches absolutely anything, including nulls, as a generic method returning X
  - This is as in 1.9, but with the names changed to make it clear that this is purely a type casting concern, not type checking, and intentionally being a bit more verbose to discourage unnecessary use.
  - Note that as of Java 8 target type inference considers method arguments, so you should be able to use `any()` in every case except choosing between overloaded methods (pretty rare?). In addition, note that Java 7's final update is this month, and then it's unsupported.
  - We'd also obviously document that users should prefer isA etc if they want to check the type, but I think it's much more obvious that `anyAsString()` isn't actually checking the value's a string (unlike `anyString()`, which did suggest that).
- `isA/isAn(X.class)` and `isAnX()` - matches on type, rejecting nulls
- `isNullOrAn(X.class)` and `isNullOrAnX()` - matches on type, accepting nulls

I think this makes for a relatively small change, so gives fairly easy migration, but makes it clear that the `any()` methods are all just generic wildcards (for use case 1), and provides a clear set of other methods to support actual type checking and pushing users to be clear about nullability along the way (for use case 2).

The only other option I can see we might want to do is stop supporting use case 1 entirely, make everybody be much more specific about what they want, and reject nulls everywhere. I think use case one is likely to be the most common case for use argument matchers anywhere though, far more than anything else, and we definitely definitely need to support it as an intuitive easy first-class citizen.

Thoughts? Do people agree both use cases are common and important? Does anybody have a better solution to help us get both while keeping a sensible consistent API?
 =||= On Tue, Apr 7, 2015 at 5:12 PM, Tim Perry notifications@github.com wrote:

> These are two quite different APIs though, and to get any kind of API
> consistency, we're going to need them to be separate sets of methods. I
> suggest:
> - any() - matches absolutely anything, including nulls, as a generic
>   method returning T (as now)
> - anyAsX() and anyAs(X.class) - matches absolutely anything, including
>   nulls, as a generic method returning X
>   - This is as in 1.9, but with the names changed to make it clear
>     that this is purely a type casting concern, not type checking, and
>     intentionally being a bit more verbose to discourage unnecessary use.
>   - Note that as of Java 8 target type inference considers method
>     arguments, so you should be able to use any() in every case except
>     choosing between overloaded methods (pretty rare?). In addition, note that
>     Java 7's final update is this month, and then it's unsupported.
>   - We'd also obviously document that users should prefer isA etc if
>     they want to check the type, but I think it's much more obvious that
>     anyAsString() isn't actually checking the value's a string (unlike
>     anyString(), which did suggest that).
>     - isA/isAn(X.class) and isAnX() - matches on type, rejecting nulls
> - isNullOr(X.class) and isNullOrX() - matches on type, accepting nulls
> 
> I think this makes for a relatively small change, so gives fairly easy
> migration, but makes it clear that the any() methods are all just generic
> wildcards (for use case 1), and provides a clear set of other methods to
> support actual type checking and pushing users to be clear about
> nullability along the way (for use case 2).
> 
> The only other option I can see we might want to do is stop supporting use
> case 1 entirely, make everybody be much more specific about what they want,
> and reject nulls everywhere. I think use case one is likely to be the most
> common case for use argument matchers anywhere though, far more than
> anything else, and we definitely definitely need to support it as an
> intuitive easy first-class citizen.
> 
> Thoughts? Do people agree both use cases are common and important? Does
> anybody have a better solution to help us get both while keeping a sensible
> consistent API?

​I agree all are used and importants.

I'm still struggling with the difference between `isNullOr(X.class)` and `anyAs(X.class)`. The only difference I see is if I have a class `A` with a subclass `subA`, and a class `B` with a subclass `subB`, and a couple of methods `M(A)` and `M(B)` is that `M(anyAs(subB.class))` will select `M(B)` and match on a `B`, but `M(isNullOr(subB.class)` will select it and match only on a `subB`, so I could have a broader matcher for `M(isNullOr(B.class))`.

Even if this is the case, I would just suppress the `anyAs(X.class)`, as my contrived example could be better written as `anyAs(B.class)`, In which case I would rename isNullOr to any, and isA to anyNotNull. In the naming side I find `any()` ​natural, `anyAs` forced, as I consistently read `any(X.class)`
as _'any thing which can be assigned to a variable of type X'_.

So I would end up with only two method names, any and `anyNotNull` with a parameterless plus a class parameter variant ( discounting typeing helpers like `anyNotNullString`), which would work:
1. `anyNotNull`, in any variant, does not accept nulls, any does.
2. A parameterless `any()`/`anyNotNull()` is equivalent to the same method with the declared parameter class. Note, if you can use `any[NotNull]()` in the methods there are no overloads, and the language guarantees I cannot use an incorrect type.

So, if I have a method `M(List l)`, `M(any(ArrayList.class))` would match anything which can be stored in an `ArrayList` var, subclasses and `null` included, and `anyNotNull(ArrayList.class)` will need a not null one. `M(any())` would exactly as `M(any(List.class))`. Mockito cannot check it, but I cannot write code to call `M` with a non-list argument, java is type checked. Same goes for `anyNotNull`.

OTOH, if I have `M(Set s)` too, I must use `M(any(Set.class))` or `M(any(List.class))`, just to resolve the overload, although in this case the matcher type checking is superfluous.

I do not see the point on `any(X.class)` not checking the type and having `isA(X.class)` which does, it seems confusing to me, so my proposal is basically zapping any of the variants. I mean, from the description, in the overloaded method, `M(any(ArrayList.class))` will select the list variant but
match a call with any `List` subtype, while `isNullOr(ArrayList.class)` will only match `ArrayList`s ?. I do not see this has any real use ( the parameter type must be accessible in the test, if you want any List, use `isNullOr(List.class)`).

Maybe I'm missing something, but I see `any(X.class)` redundant, better served by `isNullOr`, the rest is just naming disagreement.

​Francisco Olarte.​
 =||= The issue with getting rid of `anyAs(X.class)` is that we want two things:
- A way to match an argument without checking anything about its value (any)
- A way to match an argument and check its type (isA)

I think your solution is to just use `any()` with no parameter everywhere to cover the first case, and specify the type when you want the 2nd case. That won't work, because target type inference doesn't work for method arguments in Java < 8, so it's impossible to use any() without an argument (unless the parameter is just `Object` typed).

Specifically, in Java 7 the below won't compile:

``` java
class X {
   public bool method(List l) { ... }
}

X x = mock(X.class);

// ERROR: method(java.collections.List) cannot be applied to (java.lang.Object)
when (x.method(any()).thenReturn(true);
```

Anybody on Java < 8 has to specify the type every time they match anything, or it's impossible to make it compile. They can never really use `any()`; they always have to use `any(X.class)` (or equivalent). We need a way in Java 7 that you can say 'match absolutely anything please' that compiles, and I think `any(X.class)` or equivalent is the only option.

If you make that `any(X.class)` matcher check the type (as you suggest) then it no longer matches everything any more, and it becomes impossible to wildcard match everything in Java < 8 (without casting, but that would be pretty nasty)

Therefore if you want to be able to both match specific types and wildcard 'match everything' in Java < 8, you have to have two separate APIs to do so. The names of those APIs need to clearly tell the user which of those two things they're doing ('match anything, but cast the matcher to make it compile' vs 'match only this type').

I don't think that's avoidable. I'm very happy to take better suggestions for `anyAs(X.class)` that make it clearer it's just a convenient casting method (without making it so nasty that it stops being convenient), but that method does still need to exist I think.

In addition to all that: we'd rather the 'match a specific type' matcher didn't accept nulls by default (as your `any(List.class)` does). We need to make people opt in to matching nulls, because it's good practice, and because there's some potentially confusing behaviour there as nulls are kind of outside the type system. We also can't have the wildcard matcher reject nulls, or it's not matching everything any more. Thus, again, they need to be two different methods.
 =||= Hi Tim:

On Tue, Apr 7, 2015 at 7:37 PM, Tim Perry notifications@github.com wrote:

> The issue with getting rid of anyAs(X.class) is that we want two things:
> 
> A way to match an argument without checking anything about its value (any)
> A way to match an argument and check its type (isA)
> 
> I think your solution is to just use any() with no parameter everywhere to cover the first case, and specify the type when you want the 2nd case. That won't work, because target type inference doesn't work for method arguments in Java < 8, so it's impossible to use any() without an argument (unless the parameter is just Object typed).

I don't think you've understood my solution. From the previously
propossed one ( any() + anyAs(Class) + isA(Class) + isNullOrA(class) (
- notNull(), which is in another place ) I propose to remove anyAs,
  given it does not check type, rename isA(Class) to anyNotNull(Class),
  rename isNullOrA(Class) to any(Class) and rename ( or forward )
  notNull() to anyNotNull().

> Specifically, in Java 7 the below won't compile:
> 
> class X {
>    public bool method(List l) { ... }
> }
> 
> X x = mock(X.class);
> 
> // ERROR: method(java.collections.List) cannot be applied to (java.lang.Object)
> when (x.method(any()).thenReturn(true);

Perfect, in this case you use the propossed isNullOrA(Class), which I
proposed to rename as any(Class).

Also, just grepped and got this from one of my test files:

```
    AC1 = mock(AutoCaller.class);
    when(AC1.makeCall((AcCallRequest) any())).thenReturn(resp1);
```

In case you wonder, AutoCaller is an interface with a method
""MakeCallResponse makeCall(AcCallRequest)"", not overloaded.

I think this is clearly superior in java 7 ( I'm unable to use java 8
on those projects due to problems with the app server ). The any()
conveys the 'i do not care, just make this compile' and the cast
clearly says 'this is due to one of those java 7 shortcomings' to me.

> Anybody on Java < 8 has to specify the type every time they match anything, or it's impossible to make it compile. They can never really use any(); they always have to use any(X.class) (or equivalent). We need a way in Java 7 that you can say 'match absolutely anything please' that compiles, and I think any(X.class) or equivalent is the only option.

Which is what I proposed, you have IsNullOrA(Class), which covers
this. Correct me if wrong.

> If you make that any(X.class) matcher check the type (as you suggest) then it no longer matches everything any more, and it becomes impossible to wildcard match everything in Java < 8 (without casting, but that would be pretty nasty)

It is. The Method has a declared argument type of List, which means
the compiler will check that when you use the mock, in
x.method(whatever) whatever implements List, so isNullOrA(List.class),
or any(List.class) will allways match whatever, with an extra
redundant type check.

> Therefore if you want to be able to both match specific types and wildcard 'match everything' in Java < 8, you have to have two separate APIs to do so. The names of those APIs need to clearly tell the user which of those two things they're doing ('match anything, but cast the matcher to make it compile' vs 'match only this type').

As I said, I'm not knowdledgeable enough and haven't got time
presently to dig through the sources. If any(List.class) matches when
I pass an ArrayList to the Mock I can always wildcard by using the
declared argument type.

> I don't think that's avoidable. I'm very happy to take better suggestions for anyAs(X.class) that make it clearer it's just a convenient casting method (without making it so nasty that it stops being convenient), but that method does still need to exist I think.

Forget about my proposed renaming., With the any/anyAs/isA/IsNullOrA
proposal, is there any case in which you must use anyAs() which cannot
be solved by using isNullOrA(X.class)? I think they are synonims. The
problem I see with anyAs as stated is that, in the previous example (
without overloads ), I could code a matcher as
when(x.method(anyAs(ArrayList.class))) and it shoud fire ( as it does
not check type ) when I do x.method(new LinkedList()). I think this is
confusing and asking for problem, and by making it check the type I
could make when(x.method(anyAss(ArrayList.class))) to catch one
specific thing and after that add when(x.method(anyAs(List.class)) for
a catch all in java<8, or just plain any() in >=8.

My proposal of getting rid of anyAs can be read the other way, make
anyAs() check type and get rid of isNullOrA.

Repeating my self, I proposed to get rid of anyAs(Class) as a I feel
it seems to match something which it does not, and it cannot do
anything which cannot be done with isNullOr(class). Name it whatever,
is the functionality with worries me.

> In addition to all that: we'd rather the 'match a specific type' matcher didn't accept nulls by default (as your any(List.class) does). We need to make people opt in to matching nulls, because it's good practice, and because there's some potentially confusing behaviour there as nulls are kind of outside the type system. We also can't have the wildcard matcher reject nulls, or it's not matching everything any more. Thus, again, they need to be two different methods.

That's another thing. What I propose is to simplify so I have two
names ( anyIncludingNull, anyNotNull ) which indicate wether null is
accepted, plus two overrides, no parameters and a class parameter. The
null accepting behaviour is functionaly equivalent to haven just a
name plus a boolean parameter ( notReallyAny(boolean acceptNull) +
notReallyAny(boolean acceptNull, Class klass) ).

What makes me feel uncorfortable with the proposal is :
- Too many names, I think two suffice.
- Different names for similar methods, similar names for different
  null accepting behaviour.

Given this, I think:
- anyIncludingNul(), anyIncludingNul(Class), anyNotNull(),
  anyNotNul(Class) cover all cases, for jdk <8 & 8 ( although
  parameterless ones are not too useful in <8 ) ( your example would be
  served by when(x.method(anyIncludingNull(List.class)) ).
- names should be kept paired. You state opting in for nulls is good
  practice, I'll accept that without discussion. You say people should
  opt in to use them, I accept thas as a precondition. Writing
  anyIncludingNull is for me opting in.

But then, we want 'any()'. It's nice, sounds good, it is short, reads
good (any() in 8, I do not care, just need this to compile,
any(List.class) in 7, I do not care, but .Well, then writing 'any(' is
opting in to use nulls, so the class version should begin with 'any('
too. I have no problem with having the null accepting versions
'nonDefaultAcceptingNullsAnyMatcher', and the other one 'any', or
'isA', IDEs are really good at completing, and I can easily manage a
couple of names, but having any, anyAs, isA, isNullOrA, and notNull
horrifies me.

Well, that's all for today. I hope it clarifies my position.

Regards.
    Francisco Olarte.
 =||= Ok, I think that mostly makes sense, although I'm not clear exactly what the full API you're proposing is that fits the requirements here. Your last paragraph seems to contradict the four methods you've suggested just above.

I think you're still suggesting an `any()` method with actively different behaviour to an `any(X.class)` method though. Inconsistencies between those two are how we ended up here, because one does active type matching and the other doesn't, and you need different null matching behaviour too. In addition, you definitely need `any()` or it'll be confusing, so I don't think there's any way you can have an `any(X.class)` method that does actual matching.

Sounds like there is a route through though: what happens if we accept that Java 7 is on the way out, stick only to casts, and stop making the API confusing just to support now unsupported Java versions? That would give an API of:
- `any()` - matches anything
- `isA(X.class)` - matches things with X type, not nulls
- `isNullOrA(X.class)` - matches things with X type, or nulls

If you're using Java 8, all is good, simple and clear. If you're using Java 7 you have to cast `any()`, but `(MyClass) any()` is clearer about what it's doing than anything else we have here, actually shorter than `any(MyClass.class)` anyway, and good IDE's will automatically suggest the cast for you too, so pretty easy to find for newbies. Null behaviour is also clear here, and we're pushing people to be explicit about whether they match nulls in all arguments they care about.

How does that sound to everybody?
 =||= Hi Tim:

On Wed, Apr 8, 2015 at 8:38 PM, Tim Perry notifications@github.com wrote:

> Ok, I think that mostly makes sense, although I'm not clear exactly what the full API you're proposing is that fits the requirements here. Your last paragraph seems to contradict the four methods you've suggested just above.

Any of my paragraphs may seem contradictory, but I do not know how to
convey the info and do not know what the exact requirements are., but
anyway, lets go on.

> I think you're still suggesting an any() method with actively different behaviour to an any(X.class) method though.

In my full sugestion not exactly, I suggested any to be the same as
any(Object.class), ( declared parameter class really, but it could be
implemented this way ). It checks the passed thing is null or a
subclass of Object ( second check redundant, stated for completitude
).

> Inconsistencies between those two are how we ended up here, because one does active type matching and the other doesn't, and you need different null matching behaviour too. In addition, you definitely need any() or it'll be confusing, so I don't think there's any way you can have an any(X.class) method that does actual matching.
> 
> Sounds like there is a route through though: what happens if we accept that Java 7 is on the way out, stick only to casts, and stop making the API confusing just to support now unsupported Java versions? That would give an API of:
> any() - matches anything
> isA(X.class) - matches things with X type, not nulls
> isNullOrA(X.class) - matches things with X type, or nulls

I'm definitely in favour of sticking to casts, as they are a standard
language feature and should be clear.

Now, on your three proposed methods, you are forgetting one, which is
on another part of the current API, notNull() ( or it's cousing
notNull(Class), I do not know whic notNull is not declared generic
like any though, I think it SHOULD be for java 8 ).

You have 2 choices, 1.- accept nulls, 2.-check class, For 1 you need
either a boolean argument or different names, for 2 you need a Class
argument to check against. So, in your proposal you would have:
- accept nulls, do not check class:  any(), used as is in java 8,
  casted in 7 ( or for overload resolution in 8 ).
- accept nulls, check class: isNullOrA(Class)
- reject nulls, do not check class: notNull() ( same comments as any )
- reject nulls, check class: isA(Class)

Which is fine dandy for me ( the naming stuff is trivial to achieve
using a FranciscoOlarteAdditionalMatchers helper class )

Basically you can have a makeMatcher(boolean acceptNulls, Class klass
) and then any()==makeMatcher(true, Object.class),
isNullOrA(klass)=makeMatcher(true, klass),
notNull()=makeMatcher(false, Object.class),
isA(klass)=makeMatcher(false, klass).

> If you're using Java 8, all is good, simple and clear. If you're using Java 7 you have to cast any(), but (MyClass) any() is clearer about what it's doing than anything else we have here, actually shorter than any(MyClass.class) anyway, and good IDE's will automatically suggest the cast for you too, so pretty easy to find for newbies. Null behaviour is also clear here, and we're pushing people to be explicit about whether they match nulls in all arguments they care about.

I think the null / check behaviour is clearer if you group them
together somehow ( like I've done above ). As this gets rid of the
confusing (current) anyAs(Class). Also I think notNull(Class) must go,
as what is does is served by isA(class).

> How does that sound to everybody?

Fine for me.

---------------NOT A PROPOSAL----------------
Now, I'll explain what I proposed ( for NAMING along with some
motivations ). I think this discussion seems to prove it is not easily
understood, this is only for reference.

Note there are no functional changes with the proposal above, just
name reorganizations as I think current names are confusing ( and I
know they are for me, but this is my problem and I can solve it ).

0.- get rid of anyAs and notNull(class) ( served by isA and isNullOrA ).

1.- any() - keep as it is.
2.- isNullOrA(class): rename to any(class), as functionality is very
similar (any()==isNullOrA(DeclaredParameterClass.class))
3.- isA() - rename to anyNotNull ( it appears next to any() in methods
list, and makes the behavioural differences easy to spot. Also, if you
have a method any() and anyNotNull ( both being offered by
autocomplete ) is natural to assume that any==anyIncludingNull, which
is correct ).
4.- notNull() - rename to anyNotNull() ( to complete the matrix ).

Note: In my NAMING proposal naked any==acceptNulls, It could easily be
reversed ( any=>anyOrNull, anyNotNull=>any, it just sounds bad to me
that way ( maybe because I'm used to x(Object) and x(@NonNull Object)
and/or explicitly documenting when nulls are not allowed).

Extra things:
- anyObject() - seems to do the same thing as any, if so get rid of it
  if to avoid confusion, if not do the same as with anyString below.
- isNull(Class) - given it can be done with (Class)isNull(), get rid
  of it. No need for a class checking version on this.
- anyString: Confusing name with current behaviour, given any() accept
  nulls. Rename it to isAString and then, per rule 3 above, to
  anyNotNullString. THEN I would add an anyString, equal to
  isNullOrA(String.class) or any(String.class) per rule 2. Also,
  consider deleting it (note below)
- anyInt/anyChar/...: as with anyString, in nearly all aspects.
- anyMap/anyMapOf ( and it's friends anyList, anyCollection ): Similar
  to anyString, rename to anyNotNullMap, and then use the now free
  anyMap to build one accepting nulls.

for anyString/anyInt/..... I would consider having a basic matchers
class, with any/anyNotNull etc.., and a matchers derived class ( a la
AdditionalMatchers ) and relegate all aliases to that one, so the
javadoc for the basic matchers class concentrates on basic
functionality and the one for the aliases/forwarders just states the
equivalence ). In fact I would better put a class for just the basic
any\* matchers ( including just any(), any(Class), anyNotNull(),
anyNotNull(class) and isNull(class)), another one for
eq/startsWith/... another one for the anyString and friends. Static
imports make them easy to use in modern Java and the documentation
would be much easier to read (for me at least).

## Hope this explains my vision.

Regards.
   Francisco Olarte.
 =||= I apologize, I haven't read the entire thread. I'm still setting up my
family in CA and trying to manage prioriorities.

I think we have following use cases:
1. I don't care about the parameter
2. I care that it is not null
3. I care about the type (implies (2))

Solutions:

1) any(), perhaps kill anyObject(), needs explicit casting
2) no special API, kill isNotNull()/notNull() or just leave the
isNotNull()/notNull(), needs explicit casting
3) any(String.class) alias to isA(String.class) (or kill isA(...))

I think it is ok if only use case 3) offers API that avoids casting. E.g.
if the user wants to avoid casting he needs to specify the matcher better
(which I don't think is a problem).

Cheers!

On Thu, Apr 9, 2015 at 2:39 AM, Francisco Olarte notifications@github.com
wrote:

> Hi Tim:
> 
> On Wed, Apr 8, 2015 at 8:38 PM, Tim Perry notifications@github.com
> wrote:
> 
> > Ok, I think that mostly makes sense, although I'm not clear exactly what
> > the full API you're proposing is that fits the requirements here. Your last
> > paragraph seems to contradict the four methods you've suggested just above.
> 
> Any of my paragraphs may seem contradictory, but I do not know how to
> convey the info and do not know what the exact requirements are., but
> anyway, lets go on.
> 
> > I think you're still suggesting an any() method with actively different
> > behaviour to an any(X.class) method though.
> 
> In my full sugestion not exactly, I suggested any to be the same as
> any(Object.class), ( declared parameter class really, but it could be
> implemented this way ). It checks the passed thing is null or a
> subclass of Object ( second check redundant, stated for completitude
> ).
> 
> > Inconsistencies between those two are how we ended up here, because one
> > does active type matching and the other doesn't, and you need different
> > null matching behaviour too. In addition, you definitely need any() or
> > it'll be confusing, so I don't think there's any way you can have an
> > any(X.class) method that does actual matching.
> > 
> > Sounds like there is a route through though: what happens if we accept
> > that Java 7 is on the way out, stick only to casts, and stop making the API
> > confusing just to support now unsupported Java versions? That would give an
> > API of:
> > any() - matches anything
> > isA(X.class) - matches things with X type, not nulls
> > isNullOrA(X.class) - matches things with X type, or nulls
> 
> I'm definitely in favour of sticking to casts, as they are a standard
> language feature and should be clear.
> 
> Now, on your three proposed methods, you are forgetting one, which is
> on another part of the current API, notNull() ( or it's cousing
> notNull(Class), I do not know whic notNull is not declared generic
> like any though, I think it SHOULD be for java 8 ).
> 
> You have 2 choices, 1.- accept nulls, 2.-check class, For 1 you need
> either a boolean argument or different names, for 2 you need a Class
> argument to check against. So, in your proposal you would have:
> - accept nulls, do not check class: any(), used as is in java 8,
>   casted in 7 ( or for overload resolution in 8 ).
> - accept nulls, check class: isNullOrA(Class)
> - reject nulls, do not check class: notNull() ( same comments as any )
> - reject nulls, check class: isA(Class)
> 
> Which is fine dandy for me ( the naming stuff is trivial to achieve
> using a FranciscoOlarteAdditionalMatchers helper class )
> 
> Basically you can have a makeMatcher(boolean acceptNulls, Class klass
> ) and then any()==makeMatcher(true, Object.class),
> isNullOrA(klass)=makeMatcher(true, klass),
> notNull()=makeMatcher(false, Object.class),
> isA(klass)=makeMatcher(false, klass).
> 
> > If you're using Java 8, all is good, simple and clear. If you're using
> > Java 7 you have to cast any(), but (MyClass) any() is clearer about what
> > it's doing than anything else we have here, actually shorter than
> > any(MyClass.class) anyway, and good IDE's will automatically suggest the
> > cast for you too, so pretty easy to find for newbies. Null behaviour is
> > also clear here, and we're pushing people to be explicit about whether they
> > match nulls in all arguments they care about.
> 
> I think the null / check behaviour is clearer if you group them
> together somehow ( like I've done above ). As this gets rid of the
> confusing (current) anyAs(Class). Also I think notNull(Class) must go,
> as what is does is served by isA(class).
> 
> > How does that sound to everybody?
> 
> Fine for me.
> 
> ---------------NOT A PROPOSAL----------------
> Now, I'll explain what I proposed ( for NAMING along with some
> motivations ). I think this discussion seems to prove it is not easily
> understood, this is only for reference.
> 
> Note there are no functional changes with the proposal above, just
> name reorganizations as I think current names are confusing ( and I
> know they are for me, but this is my problem and I can solve it ).
> 
> 0.- get rid of anyAs and notNull(class) ( served by isA and isNullOrA ).
> 
> 1.- any() - keep as it is.
> 2.- isNullOrA(class): rename to any(class), as functionality is very
> similar (any()==isNullOrA(DeclaredParameterClass.class))
> 3.- isA() - rename to anyNotNull ( it appears next to any() in methods
> list, and makes the behavioural differences easy to spot. Also, if you
> have a method any() and anyNotNull ( both being offered by
> autocomplete ) is natural to assume that any==anyIncludingNull, which
> is correct ).
> 4.- notNull() - rename to anyNotNull() ( to complete the matrix ).
> 
> Note: In my NAMING proposal naked any==acceptNulls, It could easily be
> reversed ( any=>anyOrNull, anyNotNull=>any, it just sounds bad to me
> that way ( maybe because I'm used to x(Object) and x(@NonNull Object)
> and/or explicitly documenting when nulls are not allowed).
> 
> Extra things:
> - anyObject() - seems to do the same thing as any, if so get rid of it
>   if to avoid confusion, if not do the same as with anyString below.
> - isNull(Class) - given it can be done with (Class)isNull(), get rid
>   of it. No need for a class checking version on this.
> - anyString: Confusing name with current behaviour, given any() accept
>   nulls. Rename it to isAString and then, per rule 3 above, to
>   anyNotNullString. THEN I would add an anyString, equal to
>   isNullOrA(String.class) or any(String.class) per rule 2. Also,
>   consider deleting it (note below)
> - anyInt/anyChar/...: as with anyString, in nearly all aspects.
> - anyMap/anyMapOf ( and it's friends anyList, anyCollection ): Similar
>   to anyString, rename to anyNotNullMap, and then use the now free
>   anyMap to build one accepting nulls.
> 
> for anyString/anyInt/..... I would consider having a basic matchers
> class, with any/anyNotNull etc.., and a matchers derived class ( a la
> AdditionalMatchers ) and relegate all aliases to that one, so the
> javadoc for the basic matchers class concentrates on basic
> functionality and the one for the aliases/forwarders just states the
> equivalence ). In fact I would better put a class for just the basic
> any\* matchers ( including just any(), any(Class), anyNotNull(),
> anyNotNull(class) and isNull(class)), another one for
> eq/startsWith/... another one for the anyString and friends. Static
> imports make them easy to use in modern Java and the documentation
> would be much easier to read (for me at least).
> 
> ## Hope this explains my vision.
> 
> Regards.
> Francisco Olarte.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/194#issuecomment-91175598.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Hi Szczepan:

mmmm, delicious top posting...., anyway:

On Thu, Apr 9, 2015 at 3:59 PM, Szczepan Faber notifications@github.com wrote:

> I think we have following use cases:
> 1. I don't care about the parameter
> 2. I care that it is not null
> 3. I care about the type (implies (2))

I think you lack at least one ( 4.- I care it is null, but it is
already served by IsNull() ( or a casted null IIRC ) ,not discussed ).

> Solutions:
> 1) any(), perhaps kill anyObject(), needs explicit casting
> 2) no special API, kill isNotNull()/notNull() or just leave the
> isNotNull()/notNull(), needs explicit casting
> 3) any(String.class) alias to isA(String.class) (or kill isA(...))
> 
> I think it is ok if only use case 3) offers API that avoids casting. E.g.
> if the user wants to avoid casting he needs to specify the matcher better
> (which I don't think is a problem).

I don't think casting, specially in such a specialized case as
mockiing in tests, is an issue. And J8 will avoid most of it. What I
dislike of this is having mock.m((String)any()) accept nulls and
mock.m(any(String.class)) reject nulls. isA sounds/reads fine to me. I
prefer anyNotNull as name for 2 and 3 as it reads better, highlights
the relation with any ( they are the family of matchers which just
checks type, not value ), but I've reached a point where I think the
only form to expose a proposal is to implement it to expose how it
looks, which will have to wait in my case.

Also, thinking about the previous stuff, I'm beginnging to think
IsNullOrA(Class), although it has a clear definition ( I have a
mock.m(List), I want to match anything assignable to an ArrayList,
which are null or ArrayList subclasses, so mock.m(any(ArrayList)) ),
I'm not too sure about it's usefulness ( as I can do it with two
matchers, and isNull plus an isA with the same target, or use
AdditionalMatchers.or )

Francisco Olarte.
 =||= I agree with Francisco, if we're going for casts I don't think we can have `any(String.class)` still exist, because we can't make it usefully be consistent with `any()`. I think just `isA` works fine for that case though, and I find it quite readable and clear.

I do marginally prefer `notNull()` to `anyNotNull()`, just because it's shorter and simpler. I think `when(o.method(notNull(), notNull()))...` reads easier than `when(o.method(anyNotNull(), anyNotNull()))...`, and while anyNotNull makes sense in relation to any it's less clear what it does when you see it standalone. 'notNull' however is very clear indeed. It also doesn't feel quite so much like `any` and `notNull` are the same family as much as `isA/isNullOrA` are, just because `any` is kind of a special case (any + specific values are all people will probably use 1/2 the time, I expect).

I also do think `isNullOrA(X.class)` does need to exist explicitly too, just because it's a common case and having to write `or(isNull(), isA(String.class))` (or `or((String) isNull(), isA(String.class))` for Java 7) everywhere is quite substantially messier and harder to parse. Internally just being an alias to that is fine though.

Definitely feels like we're getting pretty close now! One more API update then:
- `any()` - matches anything, including nulls
- `notNull()` matches anything, except nulls
- `isA(X.class)` matches things of X type, except nulls
- `isNullOrA(X.class)` matches things of X type, including nulls
- We get rid of every other variant (`anyString()`, `isNotNull()`, etc)

I think there are some other extra variants we will still need for things like generic list type checks and varargs, but those should follow on fairly cleanly from these. Thoughts?
 =||= Hi Time:

On Thu, Apr 9, 2015 at 6:34 PM, Tim Perry notifications@github.com wrote:

> I agree with Francisco, if we're going for casts I don't think we can have any(String.class) still exist, because we can't make it usefully be consistent with any(). I think just isA works fine for that case though, and I find it quite readable and clear.

OK.

> I do marginally prefer notNull() to anyNotNull(), just because it's shorter and simpler. I think when(o.method(notNull(), notNull()))... reads easier than when(o.method(anyNotNull(), anyNotNull()))..., and while anyNotNull makes sense in relation to any it's less clear what it does when you see it standalone. 'notNull' however is very clear indeed.

OK. I donot agree with the arguments but I feel voting for notNull now
is much better than following the thread. I retract all my proposals
for anyNotNull.

--- ASIDE---

> It also doesn't feel quite so much like any and notNull are the same family as much as isA/isNullOrA are, just because any is kind of a special case (any + specific values are all people will probably use 1/2 the time, I expect).
> I think if you place them in a square, it does. isA is NW, isNullOrA
> is NE, any is SE, ¿ Which one goes into SW ? ( reminds me of the test
> I did in school ).

Also, any() is like isNullOrA(Object.class), notNull() is like
isA(Object.class).

NOT A PROPOSAL/DISCUSSION on the main issue, just put here as an
explanation of my abandoned views.
--- /ASIDE ---

> I also do think isNullOrA(X.class) does need to exist explicitly too, just because it's a common case and having to write or(isNull(), isA(String.class)) (or or((String) isNull(), isA(String.class)) for Java 7) everywhere is quite substantially messier and harder to parse. Internally just being an alias to that is fine though.

OK with it.

> Definitely feels like we're getting pretty close now! One more API update then:
> 
> any() - matches anything, including nulls
> notNull() matches anything, except nulls
> isA(X.class) matches things of X type, except nulls
> isNullOrA(X.class) matches things of X type, including nulls
> We get rid of every other variant (anyString(), isNotNull(), etc)
> 
> I think there are some other extra variants we will still need for things like generic list type checks and varargs, but those should follow on fairly cleanly from these. Thoughts?

Ok. My main problem is I find current naming extremely confussing.
Once anyAs is gone and replaced with ( more correct IMO )  isNullOrA
it nearly vanishes, but if variants are recovered/kept ( I would do it
in a separate class, which could be very easily documented at the top
and methods, otherwise they clutter the main matchers docs. Classed
are cheap, specially in test code ) keep their name coherent to the
implementation. I.e., givien anyString() can (should?) be implemented
as isA(String.class) to achieve current behaviour, name it isAString()
(same goes if behaviour is simillar to isNullOrA) ( or zap it, I
prefer just a longer way to do a thing than a confusing alternative )
( I used to try to put short names to things, but since about 20 years
ago I've been progresively going to longer and clearer, typing is
easier than thinking, YMMV ).

Francisco Olarte.
 =||= Cool, I think we're in agreement then. I'm very happy to zap lots of the extra methods like `anyString()` where Java 8 means they're not going to be useful and there's a simple easy to find alternative to them (like just casting `any()`, which most ide's will even suggest and do for you).

@bric3 @szczepiq Are you two happy if I open a PR extending my previous changes to implement this API, as in my message above?
 =||= Hi @pimterry @folarte 

Thanks for the discussion, I was also away staffed at Devoxx fr for the past week. I think there's some agreement here, I'm basically OK for these changes : 
- `<T> T any()` - matches anything, including nulls
- `<T> T notNull()` matches anything, except nulls
- `<T> T isA(Class<T> clazz)` matches things of `T` type but `null`
  => naming could be tweaked without the `is`, thus becoming `a(X.class)`, I understand this one is kinda bold.
- `<T> T isNullOrA(Class<T> clazz)` matches things of `T` type including `null`
  => naming could be tweaked without the `is`, thus becoming `nullOrA(X.class)`
- We get rid of every other variant (`anyString()`, `isNotNull(Class)`, etc)
  => there's still need for primitive matchers : `anyInt` should stay in my opinion, but this raises another issue with primitive wrappers, should they allow null, in my opinion they should not.

@szczepiq Another related task would be to deprecate APIs in the 1.x line.
 =||= Happy to drop the `is` prefix, seems shorter and clearer. This might be one place where we do want an alias, for `a(String.class)` and `an(Element.class)`, as otherwise I think it's quite difficult to read.

> - We get rid of every other variant (anyString(), isNotNull(Class), etc)
> 
> => there's still need for primitive matchers : anyInt should stay in my opinion, but this raises another issue with primitive wrappers, should they allow null, in my opinion they should not.

Do mean `anyInt()`, or `anInt()`? I think the conclusion of the above discussion is that we can't have an `anyInt()` method without breaking the API: either `anyInt()` actively matches the type and rejects null (confusingly inconsistent with `any()`), or it doesn't and it's confusing and people use it wrong (the current state of affairs).

For Java 8 `any()` should work everywhere I think, and for Java 7 you can use `(int) any()`. I can't easily test this right now; is there something about primitives, generics and our implementation that means this doesn't work? That's going to be a difficult problem to solve if so.

For `anInt()` on the other hand, it doesn't actually make the API inconsistent if we do add that as another method, so that's very doable. Not clear why we need it in this case either though.

Do you have an example that doesn't work with this as given?
 =||= Hi Brice:

On Sun, Apr 12, 2015 at 7:55 PM, Brice Dutheil notifications@github.com wrote:

> Thanks for the discussion, I was also away staffed at Devoxx fr for the past week. I think there's some agreement here, I'm basically OK for these changes :
> 
> <T> T any() - matches anything, including nulls
> <T> T notNull() matches anything, except nulls
> 
> <T> T isA(Class<T> clazz) matches things of T type but null
> => naming could be tweaked without the is, thus becoming a(X.class), I understand this one is kinda bold.

I strongly disagree with naming it a or ( sorry Tim ) an. I feel they
are too short and error prone ( and this is not COBOL, a PL/DSL is not
English ).

> <T> T isNullOrA(Class<T> clazz) matches things of T type including null
> => naming could be tweaked without the is, thus becoming nullOrA(X.class)

I stil think my any/anyNotNull overrrides where superior names, but as
this is functionally equivalent I'll just wrap it. OK so far.

> We get rid of every other variant (anyString(), isNotNull(Class), etc)
> => there's still need for primitive matchers : anyInt should stay in my opinion, but this raises another issue with primitive wrappers, should they allow null, in my opinion they should not.

I think the point of allowing nulls for primitives is a no point. If I
have a method mock.method(int) which I match with
when(mock.method(anyInt())) it doesn't matter that the matcher
receives an Integer due to boxing/reflection stuff, it will never be
null, becuase if I do ""Integer integer = null;  mock.method(integer)""
autounboxing will raise NPE before matchers get anything to say. And
if there was another override mock.method(Integer), well, first this
should have been matched by an appropiately casted any/is\* and second,
it's so perverse that user deserves whatever happens there.

Francisco Olarte.
 =||= Soon. It's next in my queue :) Thank you guys for patience.
 =||= Great discussion. Thanks everybody for chipping in. Let's get this sorted out.

> What I
> dislike of this is having mock.m((String)any()) accept nulls and
> mock.m(any(String.class)) reject nulls.

I agree. There is a gotcha: given that any(SomeType.class) is most used matcher method, it will be a pain to users to upgrade to Mockito 2.0.

However, if we tell users that any(String.class) checks type but (String) any() does not it is rather awkward message and it might confusing down the road.

By now, most users are probably used to the behavior of Mockito matchers and the pitfall is well documented ;) So there is an option to leave things as they are.

Removing any(T) pretty much means that we need to remove all matcher methods like anyString() anyList(), etc. This increases the impact on the user.

I'll think about this a bit more and get back by the end of today.
 =||= BTW. what do you guys think about #246?
 =||= I think we're down to following options. Please vote or suggest other options:
1. Shoot down any(T) and anyT() in favor of isA(). This thread seems to be converging on this approach. Consistent and clean. High impact, potential churn.
2. Change any(T) and anyT() methods to reject nulls. Suggested by the community originally, potentially confusing down the road due to inconsistence with any(). This inconsistence becomes less of a problem with java8.
3. Do (2) but also shoot down any() replacing it with anyObject() or anything() or '_' (ala spock ;). Not sure I like killing any() because it is neatly compact.
4. Leave things as they are for now. Perhaps revisit for java8 support.
 =||= Hi
​ ​
Szczepan:

> BTW. what do you guys think about #246
> https://github.com/mockito/mockito/issues/246?
> 
> ​I think it may have some problems, and be an overload abuse​. If done this
> way I would vote for having long named methods with is() being just a
> forwarder. And I think there may be some ambiguities if overloaded is() is
> used to test overloaded method ( i.e., when you mock m(is(String.class))
> are you mocking m(Class c) ( as m(eq(String.class))  )  or m(String s) with
> any string? ( It's a contrived overload, but I've seem some of these where
> the String version takes a class name, I think OSGi has some of them ).
> Having a long method (anyIstanceOf, equalTo, evenm, specially, isNull()
> which I personally prefer to is(null) ( Which overload is it going to pick,
> the Object one with a null param ) ) lets people key a little more in the
> difficult cases and does not at too many complexity or a signigicant run
> time for test code ( is() is just a one line forwarder, and it's javedoc
> can be left as such which just an @link to the unoverloaded method ).

Regarding readability, I'm not sure compact overloaded names are more
readable, they may be easier to read aloud, but you need to invoke higher
level brain functions to parse it and distinguish the overload being used,
but maybe I'm just becoming slower.

​Francisco Olarte.​
 =||= Yep, I prefer option 1.

#246 sounds like a good idea to me, but we should definitely market it very clearly as a convenience method (as Francisco mentions), and obviously keep the explicit methods, so people are aware they can opt in to explicitly choosing the relevant option if they need to or they're not sure what the overloading does.

The overload I'm most suspicious of is `is(T)`, just because it's most likely to be ambiguous, in practice and when trying to just think about what a line is doing. `is(null)` seems clear, `is(stringStartingWithHello)` is fine, but if I saw`when(is(100), is(String.class))`, I think my default would be to assume that the argument needed to literally be the class object. Not totally sure about that though, happy to go with it if others are happy.
 =||= Any progress on this? Are people happy for me to put together a potential PR for option 1, which it sounds like we've settled on, as something concrete to discuss?
 =||= My preference is to have the following matchers (option 1?):
-  `<T> T any()`  that accepts anything including `null`.  I associate _""any""_ to the _""anything""_ in my world that includes null-values and instances. It is compact and suitable for the most common cases.
- `<T> T anyObject()` or `<T> T notNull()` reject `null` values opposite to any(). The name should indicate that null is rejected to avoid confusion about its behaviour.
- `<T> T isA(Class<? extends T>)` reject `null` values and all values that are not a subtype of `T`, like instanceof.
- all `any*()` and `any(T)` should be dropped cause they have different behaviour (as described before)
 =||= > 1. Shoot down any(T) and anyT() in favor of isA(). This thread seems to be converging on this approach. Consistent and clean. High impact, potential churn.
> 2. Change any(T) and anyT() methods to reject nulls. Suggested by the community originally, potentially confusing down the road due to inconsistence with any(). This inconsistence becomes less of a problem with java8.
> 3. Do (2) but also shoot down any() replacing it with anyObject() or anything() or '_' (ala spock ;). Not sure I like killing any() because it is neatly compact.
> 4. Leave things as they are for now. Perhaps revisit for java8 support.

Let's try to be decisive :)

Tim & Christian vote for option 1) I very much appreciate those votes and option 1 does have a lot of charm :)

Myself, I vote for 2) because:
- any(T) reads better (seems more fluent), is more intuitive to write than isA(). It looks good in tests.
- it is consistent gramatically with any(), it makes the API a bit more consistent
- java8 is very popular, people use any() for matching anything and can use any(T) for matching specific type (not null)
- removing any(T) (options 1 and 3) seems like a churn and big impact on users without strong enough justification. It seems arbitrary that we remove the any(T) methods. E.g. myself as a user, I would not be convinced that migrating to Mockito 2.0 is a good idea because I need to fix hundreds of compilation errors due to removal fundamental API method (anyT/any(T)). Even if I make that search&replace, I'm not convinced that tests look better now. The change also hurts muscle memory and users would be finding themselves using any(T) methods, finding the code not compile, then realizing that aha! this method was removed. However, if we update the behavior of any() (option 2) we will provide very nice signal to users during the migration to 2.0. We could potentially expose bugs. Most users expect nulls to be rejected by any(T) - Mockito 2.0 will make expose tests that fail that assumption.

We don't have to agree. However, it would really cool if we were on the same page :) It would be so nice if everyone of us could stand behind decisions we make as a team.

We definitely need to make the decision!!! (if left undecided, we're effectively deciding on option 4).
 =||= I would like to suggest introducing the isA API alongside any. The latter would accept nulls while the former would rejecet them.

Nulls are pretty common as values so we ahould not make this more difficult than necessary. Also, tgis makes migration easier.
 =||= I already started the work on this a few days ago, and I chose to kinda follow option 2 as well, here's the plan :
- `<T> T any()` that accepts anything including `null`. I am pondering the addition of `anything` as it is the original meaning of `any`.
- `* any*()` / `<T> any(T)` will be aliases of `<T> isA(T)`, **this is the expected behaviour by users**, doing this will introduce the rejection of `null`, with Java 8 I saw young developer to switching to `any()` when `null` values where used instead of `anyInt`.

Since we want to do a release candidate I suggest that we ship the _null safe_ `any*`, and remove the `null` check if too much people complain.

cc @TimvdLippe @marcingrzejszczak @raphw @szpak 
 =||= Thanks for feedback!

+1 to your plan.

-1 to 'anything', it feels that it does not add sufficient value. It's a
longer alias - not sure why would someone want to use it.

On Mon, Jul 25, 2016 at 10:10 AM Brice Dutheil notifications@github.com
wrote:

> I already started the work on this a few days ago, and I chose to kinda
> follow option 2 as well, here's the plan :
> - <T> T any() that accepts anything including null. I am pondering the
>   addition of anything as it is the original meaning of any.
> - \* any_() / <T> any(T) will be aliases of <T> isA(T), *this is the
>   expected behaviour by users_, doing this will introduce the rejection
>   of null, with Java 8 I saw young developer to switching to any() when
>   null values where used instead of anyInt.
> 
> Since we want to do a release candidate I suggest that we ship the _null
> safe_ any*, and remove the null check if too much people complain.
> 
> cc @TimvdLippe https://github.com/TimvdLippe @marcingrzejszczak
> https://github.com/marcingrzejszczak @raphw https://github.com/raphw
> @szpak https://github.com/szpak
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/194#issuecomment-235017691,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AABgp-nrLrlhKpwIt9XZjvOvBWLNnglBks5qZO3wgaJpZM4D6d0z
> .
 =||= +1 i agree, lets try this for the RC.
 =||= ",0
514,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
515,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
525,508,Mockito.when() fails when method could originate from superclass or interface ,"I was testing/rebuilding a project with the latest mockito 2.0-beta when I noticed a couple of tests had started failing. Looked into why and was able to reduce the issue to [a reproducible test case](https://github.com/hansjoachim/mockito/blob/confusedSignature/src/test/java/org/mockito/ConfusedSignatureTest.java). 

It looks like the problem is somehow caused by the method signature for `getFoo()`. The subclass gets this method from two places, the superclass with generic return type and from the interface with a concrete one, and this seems to be confusing Mockito. 

The test works with 1.10.19, but fails with 2.0.90-beta (/latest HEAD).

PS. Feel free to replace the title with something more descriptive.","I think this is an issue with Bytebuddy, WDYT @raphw?
 =||= ~~@hansjoachim Have you tried other mockito 2 beta versions ?~~ Not needed I did a `git bisect`.
 =||= Byte Buddy overrides the method as follows:

``` java
public String getFoo() {
  return (String) MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptSuperCallable(
    this,
    mockitoInterceptor, 
    cachedMethod, 
    new Object[0],
    new Foo$Sub$MockitoMock$58829931$auxiliary$Ey71ZQFr(this)
  );
}
```

This is the expected value. Does not look like a Byte Buddy related problem to me.
 =||= After a `git bisect` the problem appeared with this commit 7fabd84fdfb2f80f8c135fe3865263c684c0d4e7

```
~/opensource/mockito ± ❯ git bisect bad
~/opensource/mockito ± ❯ git bisect good v2.0.26-beta
git bisect run ./gradlew :test --tests ""org.mockitousage.bugs.ConfusedSignatureTest""

...

[7fabd84fdfb2f80f8c135fe3865263c684c0d4e7] Updated to Byte Buddy 0.7: Adds support for preserving generic type information at runtime.
running ./gradlew :test --tests org.mockitousage.bugs.ConfusedSignatureTest
Parallel execution is an incubating feature.
:buildSrc:compileJava UP-TO-DATE
:buildSrc:compileGroovy UP-TO-DATE
:buildSrc:processResources UP-TO-DATE
:buildSrc:classes UP-TO-DATE
:buildSrc:jar UP-TO-DATE
:buildSrc:assemble UP-TO-DATE
:buildSrc:compileTestJava UP-TO-DATE
:buildSrc:compileTestGroovy UP-TO-DATE
:buildSrc:processTestResources UP-TO-DATE
:buildSrc:testClasses UP-TO-DATE
:buildSrc:test UP-TO-DATE
:buildSrc:check UP-TO-DATE
:buildSrc:build UP-TO-DATE
Version: 2.0.31-beta
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:processResources UP-TO-DATE
:classes
:compileTestJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:processTestResources UP-TO-DATE
:testClasses
:test
objc[46062]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_77.jdk/Contents/Home/bin/java and /Library/Java/JavaVirtualMachines/jdk1.8.0_77.jdk/Contents/Home/jre/lib/libinstrument.dylib. One of the two will be used. Which one is undefined.

org.mockitousage.bugs.ConfusedSignatureTest > should_work FAILED
    org.mockito.exceptions.misusing.MissingMethodInvocationException:
    when() requires an argument which has to be 'a method call on a mock'.
    For example:
        when(mock.getArticles()).thenReturn(articles);

    Also, this error might show up because:
    1. you stub either of: final/private/equals()/hashCode() methods.
       Those methods *cannot* be stubbed/verified.
       Mocking methods declared on non-public parent classes is not supported.
    2. inside when() you don't call method on mock but on some other object.
        at org.mockito.exceptions.Reporter.missingMethodInvocation(Reporter.java:102)
        at org.mockito.internal.MockitoCore.stub(MockitoCore.java:64)
        at org.mockito.internal.MockitoCore.when(MockitoCore.java:76)
        at org.mockito.Mockito.when(Mockito.java:1615)
        at org.mockitousage.bugs.ConfusedSignatureTest.should_work(ConfusedSignatureTest.java:16)

30 tests completed, 1 failed, 29 skipped
:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':test'.
> There were failing tests. See the report at: file:///Users/brice/opensource/mockito/build/reports/tests/index.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 5.939 secs
7fabd84fdfb2f80f8c135fe3865263c684c0d4e7 is the first bad commit
commit 7fabd84fdfb2f80f8c135fe3865263c684c0d4e7
Author: Rafael Winterhalter <rafael.wth@web.de>
Date:   Thu Nov 12 11:38:07 2015 +0100

    Updated to Byte Buddy 0.7: Adds support for preserving generic type information at runtime.

    For users of Mockito, this version brings the following advantages:
    1. A mocked method contains its generic type: A mocked method of type List<String> will not be erased to List. Many frameworks / libraries extract this information and would then react differently when encountering an instance of the mock class compared to the original class.
    2. Bridge methods can only be resolved appropriately when the generic type information is processed. This allows for a reliable recovery of ""visibility bridges"" which are no true bridges and are now reliably mocked.

:100644 100644 d27873a17388f63c683339dfaa640d35f0ac27ed 72f5bb3fbdf07ea04900c195c46ab3990f91135b M  build.gradle
:040000 040000 20affcb117604ba6251e1195c1820ffb09664cec aa31f07848d605ab4564587afa2c5b63daf5fca7 M  src
bisect run success
```
 =||= Strangely enough, when setting a breakpoint, the interceptor method does not seem to be invoked. I will look into it. Probably a problem with resolving bridge methods.
 =||= Yes it is weird. The issue seems to have been introduced by ByteBuddy 0.7
 =||= Things that matter, I'm using java 1.7

```
~/opensource/mockito ± ❯ java -version
java version ""1.7.0_80""
Java(TM) SE Runtime Environment (build 1.7.0_80-b15)
Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)
```
 =||= @raphw Yup the test fails with `MissingMethodInvocationException`
 =||= I found the problem. The bridge method is no longer identified for some reason, it seems like Byte Buddy struggles to determine the bridge method's target. I am going to fix this ASAP.
 =||= I fixed it. Still cleaning up for a new Byte Buddy release. Should be fixed by tomorrow or latest Friday.
 =||= Thanks @raphw !
 =||= Thank you, I've tested again and it's working now :)

I didn't see any tests added alongside the fix, and since it seems this bug was introduced a while back, I wonder if there should be one to catch regressions. If you'd like to, I can submit the test I made above in a PR. I wasn't really sure where to place the test, so if you have any suggestions for this or general style guidelines, just let me know.
 =||= The regression test was added to Bytebuddy which is the dependency with the fixed bug. However adding a regression test in Mockito seems fair too. I would add the test in the bugs package inside mockitousage iirc.
 =||= ",0
528,194,Tweaks Matchers.any family matchers behavior,"This issue is a follow up of the work started in #141 by @pimterry. Also here's an extract of a message on [this thread](https://groups.google.com/forum/#!topic/mockito/8_WGBB3Jbtk) of the mailing list :

---

The origin of these methods is they come from `anything` i.e. anything matches, later for shortness and cast avoidance the aliases grew, but the API naming thus became inconsistent with what a human would expect. So this behavior is being changed in mockito 2 beta, to be precise here's the status on these API in the version 2.0.5-beta :
- `any`, `anyObject`, `any(Class)` won't check anything (at first they were just aliases for _anything_ and for cast avoidance), `null` is a valid value
- `anyX` like `anyString` will check the arg is not `null` and that has the correct type
- `anyList` will check the argument is not null and a `List` instance
- `anyListOf` (and the likes) at the moment are just aliases to their non generic counter part like `anyList`

Note this is work in progress (started here in [#141](https://github.com/mockito/mockito/pull/141)), these new behavior can / will change in the beta phase. I'm especially wondering if the `any` family should allow `null` and if not do a type check. For example with these matchers : 
- `any`, `anyObject` stay the same, they currently allow `null` and don't have to do type check anyway
- `any(Class)` currently allows `null` and doesn't do type check => allows `null` and if not checks for the given type
- `any<Collection>Of` currently doesn't allow `null` and does a type check of the collection, not elements => allows `null`, if not checks collection type, if not empty checks element type

Maybe extend/create a _symmetric_  `isA` family API that won't allow any `null` arguments.

---","`any` family is currently _(at his time up to 2.0.5-beta)_ inconsistent on the way they allow or not `null`s. Type checking is ok, but `null` check behavior consistency is also important.
 =||= AnyX gramtaically tends to imply to return false for null because any
object is not null. I agree completely the api should be consistent.

On Sun, Apr 5, 2015, 11:54 Brice Dutheil notifications@github.com wrote:

> any family is currently _(at his time up to 2.0.5-beta)_ inconsistent on
> the way they allow or not nulls. Type checking is ok, but null check
> behavior consistency is also important.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/194#issuecomment-89831862.
 =||= > AnyX gramtaically tends to imply to return false for null because any object is not null.

I'm not anymore of sure of that. Anyway the changes introduced in this API make it inconsistent.
That's why I propose any validates `null`, and if not `null` then validates the type

Also on the mentioned thread _Francisco Olarte_ was proposing a `anyNotNull` family, this could clarify the behavior on `null` of these APIs.
 =||= Agreed. Any should return false for null and false for wrong type (instance
of). Otherwise I think it would violate the principle of least surprise.

On Sun, Apr 5, 2015, 12:57 Brice Dutheil notifications@github.com wrote:

> AnyX gramtaically tends to imply to return false for null because any
> object is not null.
> 
> I'm not anymore of sure of that. Anyway the changes introduced in this API
> make it inconsistent.
> That's why I propose any validates null, and if not null then validates
> the type
> 
> Also on the mentioned thread _Francisco Olarte_ was proposing a anyNotNull
> family, this could clarify the behavior on null of these APIs.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/194#issuecomment-89842760.
 =||= I see anyString() ( and friends ) checking for null and anyObject() not doing it as an inconsistency potentially leading to user surprise. Object is as much of a class as String ( or other ).

Other thing is I fail to see is the difference ( if there is any ) between isA(Klazz) and notNull(Klazz) ( or IsNotNull, but I see that one is a forwarder ). To me they seem they do the same, given the docs, but the code is different and I'm not familiar enough with it to assert they do the same thing. When doing DSL helper libraries I've found ( the hard way ) having slightly different names for the same thing seems a good idea initially, but leads to problem along the way, so I would vote for just having one of notNull/isNotNull ( and isA if it is functionally equivalent ).
 =||= I think there might be confusion here: @szczepiq I don't think the two of you are agreeing. @bric3 seems to be saying that `any` should match nulls and anyNotNull should exist (and presumably not match null), while you're saying that `any` should not match null.

I think the problem here is that there's two use cases that currently aren't clearly separated, both of which we need to support.
1. I don't care what the value I'm matching is _at all_, I want a very simple intuitive wildcard matcher that will match absolutely anything, and will compile with no extra effort (so no casts).
2. I care about the type of the value that I'm matching, but no details beyond that. I want a matcher that will not match values with the wrong type.

I think both of these are major common use cases. If we make any of the `anyX()` methods reject nulls, they no longer support the first case, and if we leave it as-is then they currently appear to support the 2nd case but aren't really doing so, which is where all this came from originally.

I do think any API that supports use case 2 should reject nulls by default: if you're asserting specifically on the type of the value, we should push people to be clear about whether or not null is valid in the given case. I think an API for use case 1 should not reject nulls, because you want to match _everything_.

These are two quite different APIs though, and to get any kind of API consistency, we're going to need them to be separate sets of methods. I suggest:
- `any()` - matches absolutely anything, including nulls, as a generic method returning T (as now)
- `anyAsX()` and `anyAs(X.class)` - matches absolutely anything, including nulls, as a generic method returning X
  - This is as in 1.9, but with the names changed to make it clear that this is purely a type casting concern, not type checking, and intentionally being a bit more verbose to discourage unnecessary use.
  - Note that as of Java 8 target type inference considers method arguments, so you should be able to use `any()` in every case except choosing between overloaded methods (pretty rare?). In addition, note that Java 7's final update is this month, and then it's unsupported.
  - We'd also obviously document that users should prefer isA etc if they want to check the type, but I think it's much more obvious that `anyAsString()` isn't actually checking the value's a string (unlike `anyString()`, which did suggest that).
- `isA/isAn(X.class)` and `isAnX()` - matches on type, rejecting nulls
- `isNullOrAn(X.class)` and `isNullOrAnX()` - matches on type, accepting nulls

I think this makes for a relatively small change, so gives fairly easy migration, but makes it clear that the `any()` methods are all just generic wildcards (for use case 1), and provides a clear set of other methods to support actual type checking and pushing users to be clear about nullability along the way (for use case 2).

The only other option I can see we might want to do is stop supporting use case 1 entirely, make everybody be much more specific about what they want, and reject nulls everywhere. I think use case one is likely to be the most common case for use argument matchers anywhere though, far more than anything else, and we definitely definitely need to support it as an intuitive easy first-class citizen.

Thoughts? Do people agree both use cases are common and important? Does anybody have a better solution to help us get both while keeping a sensible consistent API?
 =||= On Tue, Apr 7, 2015 at 5:12 PM, Tim Perry notifications@github.com wrote:

> These are two quite different APIs though, and to get any kind of API
> consistency, we're going to need them to be separate sets of methods. I
> suggest:
> - any() - matches absolutely anything, including nulls, as a generic
>   method returning T (as now)
> - anyAsX() and anyAs(X.class) - matches absolutely anything, including
>   nulls, as a generic method returning X
>   - This is as in 1.9, but with the names changed to make it clear
>     that this is purely a type casting concern, not type checking, and
>     intentionally being a bit more verbose to discourage unnecessary use.
>   - Note that as of Java 8 target type inference considers method
>     arguments, so you should be able to use any() in every case except
>     choosing between overloaded methods (pretty rare?). In addition, note that
>     Java 7's final update is this month, and then it's unsupported.
>   - We'd also obviously document that users should prefer isA etc if
>     they want to check the type, but I think it's much more obvious that
>     anyAsString() isn't actually checking the value's a string (unlike
>     anyString(), which did suggest that).
>     - isA/isAn(X.class) and isAnX() - matches on type, rejecting nulls
> - isNullOr(X.class) and isNullOrX() - matches on type, accepting nulls
> 
> I think this makes for a relatively small change, so gives fairly easy
> migration, but makes it clear that the any() methods are all just generic
> wildcards (for use case 1), and provides a clear set of other methods to
> support actual type checking and pushing users to be clear about
> nullability along the way (for use case 2).
> 
> The only other option I can see we might want to do is stop supporting use
> case 1 entirely, make everybody be much more specific about what they want,
> and reject nulls everywhere. I think use case one is likely to be the most
> common case for use argument matchers anywhere though, far more than
> anything else, and we definitely definitely need to support it as an
> intuitive easy first-class citizen.
> 
> Thoughts? Do people agree both use cases are common and important? Does
> anybody have a better solution to help us get both while keeping a sensible
> consistent API?

​I agree all are used and importants.

I'm still struggling with the difference between `isNullOr(X.class)` and `anyAs(X.class)`. The only difference I see is if I have a class `A` with a subclass `subA`, and a class `B` with a subclass `subB`, and a couple of methods `M(A)` and `M(B)` is that `M(anyAs(subB.class))` will select `M(B)` and match on a `B`, but `M(isNullOr(subB.class)` will select it and match only on a `subB`, so I could have a broader matcher for `M(isNullOr(B.class))`.

Even if this is the case, I would just suppress the `anyAs(X.class)`, as my contrived example could be better written as `anyAs(B.class)`, In which case I would rename isNullOr to any, and isA to anyNotNull. In the naming side I find `any()` ​natural, `anyAs` forced, as I consistently read `any(X.class)`
as _'any thing which can be assigned to a variable of type X'_.

So I would end up with only two method names, any and `anyNotNull` with a parameterless plus a class parameter variant ( discounting typeing helpers like `anyNotNullString`), which would work:
1. `anyNotNull`, in any variant, does not accept nulls, any does.
2. A parameterless `any()`/`anyNotNull()` is equivalent to the same method with the declared parameter class. Note, if you can use `any[NotNull]()` in the methods there are no overloads, and the language guarantees I cannot use an incorrect type.

So, if I have a method `M(List l)`, `M(any(ArrayList.class))` would match anything which can be stored in an `ArrayList` var, subclasses and `null` included, and `anyNotNull(ArrayList.class)` will need a not null one. `M(any())` would exactly as `M(any(List.class))`. Mockito cannot check it, but I cannot write code to call `M` with a non-list argument, java is type checked. Same goes for `anyNotNull`.

OTOH, if I have `M(Set s)` too, I must use `M(any(Set.class))` or `M(any(List.class))`, just to resolve the overload, although in this case the matcher type checking is superfluous.

I do not see the point on `any(X.class)` not checking the type and having `isA(X.class)` which does, it seems confusing to me, so my proposal is basically zapping any of the variants. I mean, from the description, in the overloaded method, `M(any(ArrayList.class))` will select the list variant but
match a call with any `List` subtype, while `isNullOr(ArrayList.class)` will only match `ArrayList`s ?. I do not see this has any real use ( the parameter type must be accessible in the test, if you want any List, use `isNullOr(List.class)`).

Maybe I'm missing something, but I see `any(X.class)` redundant, better served by `isNullOr`, the rest is just naming disagreement.

​Francisco Olarte.​
 =||= The issue with getting rid of `anyAs(X.class)` is that we want two things:
- A way to match an argument without checking anything about its value (any)
- A way to match an argument and check its type (isA)

I think your solution is to just use `any()` with no parameter everywhere to cover the first case, and specify the type when you want the 2nd case. That won't work, because target type inference doesn't work for method arguments in Java < 8, so it's impossible to use any() without an argument (unless the parameter is just `Object` typed).

Specifically, in Java 7 the below won't compile:

``` java
class X {
   public bool method(List l) { ... }
}

X x = mock(X.class);

// ERROR: method(java.collections.List) cannot be applied to (java.lang.Object)
when (x.method(any()).thenReturn(true);
```

Anybody on Java < 8 has to specify the type every time they match anything, or it's impossible to make it compile. They can never really use `any()`; they always have to use `any(X.class)` (or equivalent). We need a way in Java 7 that you can say 'match absolutely anything please' that compiles, and I think `any(X.class)` or equivalent is the only option.

If you make that `any(X.class)` matcher check the type (as you suggest) then it no longer matches everything any more, and it becomes impossible to wildcard match everything in Java < 8 (without casting, but that would be pretty nasty)

Therefore if you want to be able to both match specific types and wildcard 'match everything' in Java < 8, you have to have two separate APIs to do so. The names of those APIs need to clearly tell the user which of those two things they're doing ('match anything, but cast the matcher to make it compile' vs 'match only this type').

I don't think that's avoidable. I'm very happy to take better suggestions for `anyAs(X.class)` that make it clearer it's just a convenient casting method (without making it so nasty that it stops being convenient), but that method does still need to exist I think.

In addition to all that: we'd rather the 'match a specific type' matcher didn't accept nulls by default (as your `any(List.class)` does). We need to make people opt in to matching nulls, because it's good practice, and because there's some potentially confusing behaviour there as nulls are kind of outside the type system. We also can't have the wildcard matcher reject nulls, or it's not matching everything any more. Thus, again, they need to be two different methods.
 =||= Hi Tim:

On Tue, Apr 7, 2015 at 7:37 PM, Tim Perry notifications@github.com wrote:

> The issue with getting rid of anyAs(X.class) is that we want two things:
> 
> A way to match an argument without checking anything about its value (any)
> A way to match an argument and check its type (isA)
> 
> I think your solution is to just use any() with no parameter everywhere to cover the first case, and specify the type when you want the 2nd case. That won't work, because target type inference doesn't work for method arguments in Java < 8, so it's impossible to use any() without an argument (unless the parameter is just Object typed).

I don't think you've understood my solution. From the previously
propossed one ( any() + anyAs(Class) + isA(Class) + isNullOrA(class) (
- notNull(), which is in another place ) I propose to remove anyAs,
  given it does not check type, rename isA(Class) to anyNotNull(Class),
  rename isNullOrA(Class) to any(Class) and rename ( or forward )
  notNull() to anyNotNull().

> Specifically, in Java 7 the below won't compile:
> 
> class X {
>    public bool method(List l) { ... }
> }
> 
> X x = mock(X.class);
> 
> // ERROR: method(java.collections.List) cannot be applied to (java.lang.Object)
> when (x.method(any()).thenReturn(true);

Perfect, in this case you use the propossed isNullOrA(Class), which I
proposed to rename as any(Class).

Also, just grepped and got this from one of my test files:

```
    AC1 = mock(AutoCaller.class);
    when(AC1.makeCall((AcCallRequest) any())).thenReturn(resp1);
```

In case you wonder, AutoCaller is an interface with a method
""MakeCallResponse makeCall(AcCallRequest)"", not overloaded.

I think this is clearly superior in java 7 ( I'm unable to use java 8
on those projects due to problems with the app server ). The any()
conveys the 'i do not care, just make this compile' and the cast
clearly says 'this is due to one of those java 7 shortcomings' to me.

> Anybody on Java < 8 has to specify the type every time they match anything, or it's impossible to make it compile. They can never really use any(); they always have to use any(X.class) (or equivalent). We need a way in Java 7 that you can say 'match absolutely anything please' that compiles, and I think any(X.class) or equivalent is the only option.

Which is what I proposed, you have IsNullOrA(Class), which covers
this. Correct me if wrong.

> If you make that any(X.class) matcher check the type (as you suggest) then it no longer matches everything any more, and it becomes impossible to wildcard match everything in Java < 8 (without casting, but that would be pretty nasty)

It is. The Method has a declared argument type of List, which means
the compiler will check that when you use the mock, in
x.method(whatever) whatever implements List, so isNullOrA(List.class),
or any(List.class) will allways match whatever, with an extra
redundant type check.

> Therefore if you want to be able to both match specific types and wildcard 'match everything' in Java < 8, you have to have two separate APIs to do so. The names of those APIs need to clearly tell the user which of those two things they're doing ('match anything, but cast the matcher to make it compile' vs 'match only this type').

As I said, I'm not knowdledgeable enough and haven't got time
presently to dig through the sources. If any(List.class) matches when
I pass an ArrayList to the Mock I can always wildcard by using the
declared argument type.

> I don't think that's avoidable. I'm very happy to take better suggestions for anyAs(X.class) that make it clearer it's just a convenient casting method (without making it so nasty that it stops being convenient), but that method does still need to exist I think.

Forget about my proposed renaming., With the any/anyAs/isA/IsNullOrA
proposal, is there any case in which you must use anyAs() which cannot
be solved by using isNullOrA(X.class)? I think they are synonims. The
problem I see with anyAs as stated is that, in the previous example (
without overloads ), I could code a matcher as
when(x.method(anyAs(ArrayList.class))) and it shoud fire ( as it does
not check type ) when I do x.method(new LinkedList()). I think this is
confusing and asking for problem, and by making it check the type I
could make when(x.method(anyAss(ArrayList.class))) to catch one
specific thing and after that add when(x.method(anyAs(List.class)) for
a catch all in java<8, or just plain any() in >=8.

My proposal of getting rid of anyAs can be read the other way, make
anyAs() check type and get rid of isNullOrA.

Repeating my self, I proposed to get rid of anyAs(Class) as a I feel
it seems to match something which it does not, and it cannot do
anything which cannot be done with isNullOr(class). Name it whatever,
is the functionality with worries me.

> In addition to all that: we'd rather the 'match a specific type' matcher didn't accept nulls by default (as your any(List.class) does). We need to make people opt in to matching nulls, because it's good practice, and because there's some potentially confusing behaviour there as nulls are kind of outside the type system. We also can't have the wildcard matcher reject nulls, or it's not matching everything any more. Thus, again, they need to be two different methods.

That's another thing. What I propose is to simplify so I have two
names ( anyIncludingNull, anyNotNull ) which indicate wether null is
accepted, plus two overrides, no parameters and a class parameter. The
null accepting behaviour is functionaly equivalent to haven just a
name plus a boolean parameter ( notReallyAny(boolean acceptNull) +
notReallyAny(boolean acceptNull, Class klass) ).

What makes me feel uncorfortable with the proposal is :
- Too many names, I think two suffice.
- Different names for similar methods, similar names for different
  null accepting behaviour.

Given this, I think:
- anyIncludingNul(), anyIncludingNul(Class), anyNotNull(),
  anyNotNul(Class) cover all cases, for jdk <8 & 8 ( although
  parameterless ones are not too useful in <8 ) ( your example would be
  served by when(x.method(anyIncludingNull(List.class)) ).
- names should be kept paired. You state opting in for nulls is good
  practice, I'll accept that without discussion. You say people should
  opt in to use them, I accept thas as a precondition. Writing
  anyIncludingNull is for me opting in.

But then, we want 'any()'. It's nice, sounds good, it is short, reads
good (any() in 8, I do not care, just need this to compile,
any(List.class) in 7, I do not care, but .Well, then writing 'any(' is
opting in to use nulls, so the class version should begin with 'any('
too. I have no problem with having the null accepting versions
'nonDefaultAcceptingNullsAnyMatcher', and the other one 'any', or
'isA', IDEs are really good at completing, and I can easily manage a
couple of names, but having any, anyAs, isA, isNullOrA, and notNull
horrifies me.

Well, that's all for today. I hope it clarifies my position.

Regards.
    Francisco Olarte.
 =||= Ok, I think that mostly makes sense, although I'm not clear exactly what the full API you're proposing is that fits the requirements here. Your last paragraph seems to contradict the four methods you've suggested just above.

I think you're still suggesting an `any()` method with actively different behaviour to an `any(X.class)` method though. Inconsistencies between those two are how we ended up here, because one does active type matching and the other doesn't, and you need different null matching behaviour too. In addition, you definitely need `any()` or it'll be confusing, so I don't think there's any way you can have an `any(X.class)` method that does actual matching.

Sounds like there is a route through though: what happens if we accept that Java 7 is on the way out, stick only to casts, and stop making the API confusing just to support now unsupported Java versions? That would give an API of:
- `any()` - matches anything
- `isA(X.class)` - matches things with X type, not nulls
- `isNullOrA(X.class)` - matches things with X type, or nulls

If you're using Java 8, all is good, simple and clear. If you're using Java 7 you have to cast `any()`, but `(MyClass) any()` is clearer about what it's doing than anything else we have here, actually shorter than `any(MyClass.class)` anyway, and good IDE's will automatically suggest the cast for you too, so pretty easy to find for newbies. Null behaviour is also clear here, and we're pushing people to be explicit about whether they match nulls in all arguments they care about.

How does that sound to everybody?
 =||= Hi Tim:

On Wed, Apr 8, 2015 at 8:38 PM, Tim Perry notifications@github.com wrote:

> Ok, I think that mostly makes sense, although I'm not clear exactly what the full API you're proposing is that fits the requirements here. Your last paragraph seems to contradict the four methods you've suggested just above.

Any of my paragraphs may seem contradictory, but I do not know how to
convey the info and do not know what the exact requirements are., but
anyway, lets go on.

> I think you're still suggesting an any() method with actively different behaviour to an any(X.class) method though.

In my full sugestion not exactly, I suggested any to be the same as
any(Object.class), ( declared parameter class really, but it could be
implemented this way ). It checks the passed thing is null or a
subclass of Object ( second check redundant, stated for completitude
).

> Inconsistencies between those two are how we ended up here, because one does active type matching and the other doesn't, and you need different null matching behaviour too. In addition, you definitely need any() or it'll be confusing, so I don't think there's any way you can have an any(X.class) method that does actual matching.
> 
> Sounds like there is a route through though: what happens if we accept that Java 7 is on the way out, stick only to casts, and stop making the API confusing just to support now unsupported Java versions? That would give an API of:
> any() - matches anything
> isA(X.class) - matches things with X type, not nulls
> isNullOrA(X.class) - matches things with X type, or nulls

I'm definitely in favour of sticking to casts, as they are a standard
language feature and should be clear.

Now, on your three proposed methods, you are forgetting one, which is
on another part of the current API, notNull() ( or it's cousing
notNull(Class), I do not know whic notNull is not declared generic
like any though, I think it SHOULD be for java 8 ).

You have 2 choices, 1.- accept nulls, 2.-check class, For 1 you need
either a boolean argument or different names, for 2 you need a Class
argument to check against. So, in your proposal you would have:
- accept nulls, do not check class:  any(), used as is in java 8,
  casted in 7 ( or for overload resolution in 8 ).
- accept nulls, check class: isNullOrA(Class)
- reject nulls, do not check class: notNull() ( same comments as any )
- reject nulls, check class: isA(Class)

Which is fine dandy for me ( the naming stuff is trivial to achieve
using a FranciscoOlarteAdditionalMatchers helper class )

Basically you can have a makeMatcher(boolean acceptNulls, Class klass
) and then any()==makeMatcher(true, Object.class),
isNullOrA(klass)=makeMatcher(true, klass),
notNull()=makeMatcher(false, Object.class),
isA(klass)=makeMatcher(false, klass).

> If you're using Java 8, all is good, simple and clear. If you're using Java 7 you have to cast any(), but (MyClass) any() is clearer about what it's doing than anything else we have here, actually shorter than any(MyClass.class) anyway, and good IDE's will automatically suggest the cast for you too, so pretty easy to find for newbies. Null behaviour is also clear here, and we're pushing people to be explicit about whether they match nulls in all arguments they care about.

I think the null / check behaviour is clearer if you group them
together somehow ( like I've done above ). As this gets rid of the
confusing (current) anyAs(Class). Also I think notNull(Class) must go,
as what is does is served by isA(class).

> How does that sound to everybody?

Fine for me.

---------------NOT A PROPOSAL----------------
Now, I'll explain what I proposed ( for NAMING along with some
motivations ). I think this discussion seems to prove it is not easily
understood, this is only for reference.

Note there are no functional changes with the proposal above, just
name reorganizations as I think current names are confusing ( and I
know they are for me, but this is my problem and I can solve it ).

0.- get rid of anyAs and notNull(class) ( served by isA and isNullOrA ).

1.- any() - keep as it is.
2.- isNullOrA(class): rename to any(class), as functionality is very
similar (any()==isNullOrA(DeclaredParameterClass.class))
3.- isA() - rename to anyNotNull ( it appears next to any() in methods
list, and makes the behavioural differences easy to spot. Also, if you
have a method any() and anyNotNull ( both being offered by
autocomplete ) is natural to assume that any==anyIncludingNull, which
is correct ).
4.- notNull() - rename to anyNotNull() ( to complete the matrix ).

Note: In my NAMING proposal naked any==acceptNulls, It could easily be
reversed ( any=>anyOrNull, anyNotNull=>any, it just sounds bad to me
that way ( maybe because I'm used to x(Object) and x(@NonNull Object)
and/or explicitly documenting when nulls are not allowed).

Extra things:
- anyObject() - seems to do the same thing as any, if so get rid of it
  if to avoid confusion, if not do the same as with anyString below.
- isNull(Class) - given it can be done with (Class)isNull(), get rid
  of it. No need for a class checking version on this.
- anyString: Confusing name with current behaviour, given any() accept
  nulls. Rename it to isAString and then, per rule 3 above, to
  anyNotNullString. THEN I would add an anyString, equal to
  isNullOrA(String.class) or any(String.class) per rule 2. Also,
  consider deleting it (note below)
- anyInt/anyChar/...: as with anyString, in nearly all aspects.
- anyMap/anyMapOf ( and it's friends anyList, anyCollection ): Similar
  to anyString, rename to anyNotNullMap, and then use the now free
  anyMap to build one accepting nulls.

for anyString/anyInt/..... I would consider having a basic matchers
class, with any/anyNotNull etc.., and a matchers derived class ( a la
AdditionalMatchers ) and relegate all aliases to that one, so the
javadoc for the basic matchers class concentrates on basic
functionality and the one for the aliases/forwarders just states the
equivalence ). In fact I would better put a class for just the basic
any\* matchers ( including just any(), any(Class), anyNotNull(),
anyNotNull(class) and isNull(class)), another one for
eq/startsWith/... another one for the anyString and friends. Static
imports make them easy to use in modern Java and the documentation
would be much easier to read (for me at least).

## Hope this explains my vision.

Regards.
   Francisco Olarte.
 =||= I apologize, I haven't read the entire thread. I'm still setting up my
family in CA and trying to manage prioriorities.

I think we have following use cases:
1. I don't care about the parameter
2. I care that it is not null
3. I care about the type (implies (2))

Solutions:

1) any(), perhaps kill anyObject(), needs explicit casting
2) no special API, kill isNotNull()/notNull() or just leave the
isNotNull()/notNull(), needs explicit casting
3) any(String.class) alias to isA(String.class) (or kill isA(...))

I think it is ok if only use case 3) offers API that avoids casting. E.g.
if the user wants to avoid casting he needs to specify the matcher better
(which I don't think is a problem).

Cheers!

On Thu, Apr 9, 2015 at 2:39 AM, Francisco Olarte notifications@github.com
wrote:

> Hi Tim:
> 
> On Wed, Apr 8, 2015 at 8:38 PM, Tim Perry notifications@github.com
> wrote:
> 
> > Ok, I think that mostly makes sense, although I'm not clear exactly what
> > the full API you're proposing is that fits the requirements here. Your last
> > paragraph seems to contradict the four methods you've suggested just above.
> 
> Any of my paragraphs may seem contradictory, but I do not know how to
> convey the info and do not know what the exact requirements are., but
> anyway, lets go on.
> 
> > I think you're still suggesting an any() method with actively different
> > behaviour to an any(X.class) method though.
> 
> In my full sugestion not exactly, I suggested any to be the same as
> any(Object.class), ( declared parameter class really, but it could be
> implemented this way ). It checks the passed thing is null or a
> subclass of Object ( second check redundant, stated for completitude
> ).
> 
> > Inconsistencies between those two are how we ended up here, because one
> > does active type matching and the other doesn't, and you need different
> > null matching behaviour too. In addition, you definitely need any() or
> > it'll be confusing, so I don't think there's any way you can have an
> > any(X.class) method that does actual matching.
> > 
> > Sounds like there is a route through though: what happens if we accept
> > that Java 7 is on the way out, stick only to casts, and stop making the API
> > confusing just to support now unsupported Java versions? That would give an
> > API of:
> > any() - matches anything
> > isA(X.class) - matches things with X type, not nulls
> > isNullOrA(X.class) - matches things with X type, or nulls
> 
> I'm definitely in favour of sticking to casts, as they are a standard
> language feature and should be clear.
> 
> Now, on your three proposed methods, you are forgetting one, which is
> on another part of the current API, notNull() ( or it's cousing
> notNull(Class), I do not know whic notNull is not declared generic
> like any though, I think it SHOULD be for java 8 ).
> 
> You have 2 choices, 1.- accept nulls, 2.-check class, For 1 you need
> either a boolean argument or different names, for 2 you need a Class
> argument to check against. So, in your proposal you would have:
> - accept nulls, do not check class: any(), used as is in java 8,
>   casted in 7 ( or for overload resolution in 8 ).
> - accept nulls, check class: isNullOrA(Class)
> - reject nulls, do not check class: notNull() ( same comments as any )
> - reject nulls, check class: isA(Class)
> 
> Which is fine dandy for me ( the naming stuff is trivial to achieve
> using a FranciscoOlarteAdditionalMatchers helper class )
> 
> Basically you can have a makeMatcher(boolean acceptNulls, Class klass
> ) and then any()==makeMatcher(true, Object.class),
> isNullOrA(klass)=makeMatcher(true, klass),
> notNull()=makeMatcher(false, Object.class),
> isA(klass)=makeMatcher(false, klass).
> 
> > If you're using Java 8, all is good, simple and clear. If you're using
> > Java 7 you have to cast any(), but (MyClass) any() is clearer about what
> > it's doing than anything else we have here, actually shorter than
> > any(MyClass.class) anyway, and good IDE's will automatically suggest the
> > cast for you too, so pretty easy to find for newbies. Null behaviour is
> > also clear here, and we're pushing people to be explicit about whether they
> > match nulls in all arguments they care about.
> 
> I think the null / check behaviour is clearer if you group them
> together somehow ( like I've done above ). As this gets rid of the
> confusing (current) anyAs(Class). Also I think notNull(Class) must go,
> as what is does is served by isA(class).
> 
> > How does that sound to everybody?
> 
> Fine for me.
> 
> ---------------NOT A PROPOSAL----------------
> Now, I'll explain what I proposed ( for NAMING along with some
> motivations ). I think this discussion seems to prove it is not easily
> understood, this is only for reference.
> 
> Note there are no functional changes with the proposal above, just
> name reorganizations as I think current names are confusing ( and I
> know they are for me, but this is my problem and I can solve it ).
> 
> 0.- get rid of anyAs and notNull(class) ( served by isA and isNullOrA ).
> 
> 1.- any() - keep as it is.
> 2.- isNullOrA(class): rename to any(class), as functionality is very
> similar (any()==isNullOrA(DeclaredParameterClass.class))
> 3.- isA() - rename to anyNotNull ( it appears next to any() in methods
> list, and makes the behavioural differences easy to spot. Also, if you
> have a method any() and anyNotNull ( both being offered by
> autocomplete ) is natural to assume that any==anyIncludingNull, which
> is correct ).
> 4.- notNull() - rename to anyNotNull() ( to complete the matrix ).
> 
> Note: In my NAMING proposal naked any==acceptNulls, It could easily be
> reversed ( any=>anyOrNull, anyNotNull=>any, it just sounds bad to me
> that way ( maybe because I'm used to x(Object) and x(@NonNull Object)
> and/or explicitly documenting when nulls are not allowed).
> 
> Extra things:
> - anyObject() - seems to do the same thing as any, if so get rid of it
>   if to avoid confusion, if not do the same as with anyString below.
> - isNull(Class) - given it can be done with (Class)isNull(), get rid
>   of it. No need for a class checking version on this.
> - anyString: Confusing name with current behaviour, given any() accept
>   nulls. Rename it to isAString and then, per rule 3 above, to
>   anyNotNullString. THEN I would add an anyString, equal to
>   isNullOrA(String.class) or any(String.class) per rule 2. Also,
>   consider deleting it (note below)
> - anyInt/anyChar/...: as with anyString, in nearly all aspects.
> - anyMap/anyMapOf ( and it's friends anyList, anyCollection ): Similar
>   to anyString, rename to anyNotNullMap, and then use the now free
>   anyMap to build one accepting nulls.
> 
> for anyString/anyInt/..... I would consider having a basic matchers
> class, with any/anyNotNull etc.., and a matchers derived class ( a la
> AdditionalMatchers ) and relegate all aliases to that one, so the
> javadoc for the basic matchers class concentrates on basic
> functionality and the one for the aliases/forwarders just states the
> equivalence ). In fact I would better put a class for just the basic
> any\* matchers ( including just any(), any(Class), anyNotNull(),
> anyNotNull(class) and isNull(class)), another one for
> eq/startsWith/... another one for the anyString and friends. Static
> imports make them easy to use in modern Java and the documentation
> would be much easier to read (for me at least).
> 
> ## Hope this explains my vision.
> 
> Regards.
> Francisco Olarte.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/194#issuecomment-91175598.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Hi Szczepan:

mmmm, delicious top posting...., anyway:

On Thu, Apr 9, 2015 at 3:59 PM, Szczepan Faber notifications@github.com wrote:

> I think we have following use cases:
> 1. I don't care about the parameter
> 2. I care that it is not null
> 3. I care about the type (implies (2))

I think you lack at least one ( 4.- I care it is null, but it is
already served by IsNull() ( or a casted null IIRC ) ,not discussed ).

> Solutions:
> 1) any(), perhaps kill anyObject(), needs explicit casting
> 2) no special API, kill isNotNull()/notNull() or just leave the
> isNotNull()/notNull(), needs explicit casting
> 3) any(String.class) alias to isA(String.class) (or kill isA(...))
> 
> I think it is ok if only use case 3) offers API that avoids casting. E.g.
> if the user wants to avoid casting he needs to specify the matcher better
> (which I don't think is a problem).

I don't think casting, specially in such a specialized case as
mockiing in tests, is an issue. And J8 will avoid most of it. What I
dislike of this is having mock.m((String)any()) accept nulls and
mock.m(any(String.class)) reject nulls. isA sounds/reads fine to me. I
prefer anyNotNull as name for 2 and 3 as it reads better, highlights
the relation with any ( they are the family of matchers which just
checks type, not value ), but I've reached a point where I think the
only form to expose a proposal is to implement it to expose how it
looks, which will have to wait in my case.

Also, thinking about the previous stuff, I'm beginnging to think
IsNullOrA(Class), although it has a clear definition ( I have a
mock.m(List), I want to match anything assignable to an ArrayList,
which are null or ArrayList subclasses, so mock.m(any(ArrayList)) ),
I'm not too sure about it's usefulness ( as I can do it with two
matchers, and isNull plus an isA with the same target, or use
AdditionalMatchers.or )

Francisco Olarte.
 =||= I agree with Francisco, if we're going for casts I don't think we can have `any(String.class)` still exist, because we can't make it usefully be consistent with `any()`. I think just `isA` works fine for that case though, and I find it quite readable and clear.

I do marginally prefer `notNull()` to `anyNotNull()`, just because it's shorter and simpler. I think `when(o.method(notNull(), notNull()))...` reads easier than `when(o.method(anyNotNull(), anyNotNull()))...`, and while anyNotNull makes sense in relation to any it's less clear what it does when you see it standalone. 'notNull' however is very clear indeed. It also doesn't feel quite so much like `any` and `notNull` are the same family as much as `isA/isNullOrA` are, just because `any` is kind of a special case (any + specific values are all people will probably use 1/2 the time, I expect).

I also do think `isNullOrA(X.class)` does need to exist explicitly too, just because it's a common case and having to write `or(isNull(), isA(String.class))` (or `or((String) isNull(), isA(String.class))` for Java 7) everywhere is quite substantially messier and harder to parse. Internally just being an alias to that is fine though.

Definitely feels like we're getting pretty close now! One more API update then:
- `any()` - matches anything, including nulls
- `notNull()` matches anything, except nulls
- `isA(X.class)` matches things of X type, except nulls
- `isNullOrA(X.class)` matches things of X type, including nulls
- We get rid of every other variant (`anyString()`, `isNotNull()`, etc)

I think there are some other extra variants we will still need for things like generic list type checks and varargs, but those should follow on fairly cleanly from these. Thoughts?
 =||= Hi Time:

On Thu, Apr 9, 2015 at 6:34 PM, Tim Perry notifications@github.com wrote:

> I agree with Francisco, if we're going for casts I don't think we can have any(String.class) still exist, because we can't make it usefully be consistent with any(). I think just isA works fine for that case though, and I find it quite readable and clear.

OK.

> I do marginally prefer notNull() to anyNotNull(), just because it's shorter and simpler. I think when(o.method(notNull(), notNull()))... reads easier than when(o.method(anyNotNull(), anyNotNull()))..., and while anyNotNull makes sense in relation to any it's less clear what it does when you see it standalone. 'notNull' however is very clear indeed.

OK. I donot agree with the arguments but I feel voting for notNull now
is much better than following the thread. I retract all my proposals
for anyNotNull.

--- ASIDE---

> It also doesn't feel quite so much like any and notNull are the same family as much as isA/isNullOrA are, just because any is kind of a special case (any + specific values are all people will probably use 1/2 the time, I expect).
> I think if you place them in a square, it does. isA is NW, isNullOrA
> is NE, any is SE, ¿ Which one goes into SW ? ( reminds me of the test
> I did in school ).

Also, any() is like isNullOrA(Object.class), notNull() is like
isA(Object.class).

NOT A PROPOSAL/DISCUSSION on the main issue, just put here as an
explanation of my abandoned views.
--- /ASIDE ---

> I also do think isNullOrA(X.class) does need to exist explicitly too, just because it's a common case and having to write or(isNull(), isA(String.class)) (or or((String) isNull(), isA(String.class)) for Java 7) everywhere is quite substantially messier and harder to parse. Internally just being an alias to that is fine though.

OK with it.

> Definitely feels like we're getting pretty close now! One more API update then:
> 
> any() - matches anything, including nulls
> notNull() matches anything, except nulls
> isA(X.class) matches things of X type, except nulls
> isNullOrA(X.class) matches things of X type, including nulls
> We get rid of every other variant (anyString(), isNotNull(), etc)
> 
> I think there are some other extra variants we will still need for things like generic list type checks and varargs, but those should follow on fairly cleanly from these. Thoughts?

Ok. My main problem is I find current naming extremely confussing.
Once anyAs is gone and replaced with ( more correct IMO )  isNullOrA
it nearly vanishes, but if variants are recovered/kept ( I would do it
in a separate class, which could be very easily documented at the top
and methods, otherwise they clutter the main matchers docs. Classed
are cheap, specially in test code ) keep their name coherent to the
implementation. I.e., givien anyString() can (should?) be implemented
as isA(String.class) to achieve current behaviour, name it isAString()
(same goes if behaviour is simillar to isNullOrA) ( or zap it, I
prefer just a longer way to do a thing than a confusing alternative )
( I used to try to put short names to things, but since about 20 years
ago I've been progresively going to longer and clearer, typing is
easier than thinking, YMMV ).

Francisco Olarte.
 =||= Cool, I think we're in agreement then. I'm very happy to zap lots of the extra methods like `anyString()` where Java 8 means they're not going to be useful and there's a simple easy to find alternative to them (like just casting `any()`, which most ide's will even suggest and do for you).

@bric3 @szczepiq Are you two happy if I open a PR extending my previous changes to implement this API, as in my message above?
 =||= Hi @pimterry @folarte 

Thanks for the discussion, I was also away staffed at Devoxx fr for the past week. I think there's some agreement here, I'm basically OK for these changes : 
- `<T> T any()` - matches anything, including nulls
- `<T> T notNull()` matches anything, except nulls
- `<T> T isA(Class<T> clazz)` matches things of `T` type but `null`
  => naming could be tweaked without the `is`, thus becoming `a(X.class)`, I understand this one is kinda bold.
- `<T> T isNullOrA(Class<T> clazz)` matches things of `T` type including `null`
  => naming could be tweaked without the `is`, thus becoming `nullOrA(X.class)`
- We get rid of every other variant (`anyString()`, `isNotNull(Class)`, etc)
  => there's still need for primitive matchers : `anyInt` should stay in my opinion, but this raises another issue with primitive wrappers, should they allow null, in my opinion they should not.

@szczepiq Another related task would be to deprecate APIs in the 1.x line.
 =||= Happy to drop the `is` prefix, seems shorter and clearer. This might be one place where we do want an alias, for `a(String.class)` and `an(Element.class)`, as otherwise I think it's quite difficult to read.

> - We get rid of every other variant (anyString(), isNotNull(Class), etc)
> 
> => there's still need for primitive matchers : anyInt should stay in my opinion, but this raises another issue with primitive wrappers, should they allow null, in my opinion they should not.

Do mean `anyInt()`, or `anInt()`? I think the conclusion of the above discussion is that we can't have an `anyInt()` method without breaking the API: either `anyInt()` actively matches the type and rejects null (confusingly inconsistent with `any()`), or it doesn't and it's confusing and people use it wrong (the current state of affairs).

For Java 8 `any()` should work everywhere I think, and for Java 7 you can use `(int) any()`. I can't easily test this right now; is there something about primitives, generics and our implementation that means this doesn't work? That's going to be a difficult problem to solve if so.

For `anInt()` on the other hand, it doesn't actually make the API inconsistent if we do add that as another method, so that's very doable. Not clear why we need it in this case either though.

Do you have an example that doesn't work with this as given?
 =||= Hi Brice:

On Sun, Apr 12, 2015 at 7:55 PM, Brice Dutheil notifications@github.com wrote:

> Thanks for the discussion, I was also away staffed at Devoxx fr for the past week. I think there's some agreement here, I'm basically OK for these changes :
> 
> <T> T any() - matches anything, including nulls
> <T> T notNull() matches anything, except nulls
> 
> <T> T isA(Class<T> clazz) matches things of T type but null
> => naming could be tweaked without the is, thus becoming a(X.class), I understand this one is kinda bold.

I strongly disagree with naming it a or ( sorry Tim ) an. I feel they
are too short and error prone ( and this is not COBOL, a PL/DSL is not
English ).

> <T> T isNullOrA(Class<T> clazz) matches things of T type including null
> => naming could be tweaked without the is, thus becoming nullOrA(X.class)

I stil think my any/anyNotNull overrrides where superior names, but as
this is functionally equivalent I'll just wrap it. OK so far.

> We get rid of every other variant (anyString(), isNotNull(Class), etc)
> => there's still need for primitive matchers : anyInt should stay in my opinion, but this raises another issue with primitive wrappers, should they allow null, in my opinion they should not.

I think the point of allowing nulls for primitives is a no point. If I
have a method mock.method(int) which I match with
when(mock.method(anyInt())) it doesn't matter that the matcher
receives an Integer due to boxing/reflection stuff, it will never be
null, becuase if I do ""Integer integer = null;  mock.method(integer)""
autounboxing will raise NPE before matchers get anything to say. And
if there was another override mock.method(Integer), well, first this
should have been matched by an appropiately casted any/is\* and second,
it's so perverse that user deserves whatever happens there.

Francisco Olarte.
 =||= Soon. It's next in my queue :) Thank you guys for patience.
 =||= Great discussion. Thanks everybody for chipping in. Let's get this sorted out.

> What I
> dislike of this is having mock.m((String)any()) accept nulls and
> mock.m(any(String.class)) reject nulls.

I agree. There is a gotcha: given that any(SomeType.class) is most used matcher method, it will be a pain to users to upgrade to Mockito 2.0.

However, if we tell users that any(String.class) checks type but (String) any() does not it is rather awkward message and it might confusing down the road.

By now, most users are probably used to the behavior of Mockito matchers and the pitfall is well documented ;) So there is an option to leave things as they are.

Removing any(T) pretty much means that we need to remove all matcher methods like anyString() anyList(), etc. This increases the impact on the user.

I'll think about this a bit more and get back by the end of today.
 =||= BTW. what do you guys think about #246?
 =||= I think we're down to following options. Please vote or suggest other options:
1. Shoot down any(T) and anyT() in favor of isA(). This thread seems to be converging on this approach. Consistent and clean. High impact, potential churn.
2. Change any(T) and anyT() methods to reject nulls. Suggested by the community originally, potentially confusing down the road due to inconsistence with any(). This inconsistence becomes less of a problem with java8.
3. Do (2) but also shoot down any() replacing it with anyObject() or anything() or '_' (ala spock ;). Not sure I like killing any() because it is neatly compact.
4. Leave things as they are for now. Perhaps revisit for java8 support.
 =||= Hi
​ ​
Szczepan:

> BTW. what do you guys think about #246
> https://github.com/mockito/mockito/issues/246?
> 
> ​I think it may have some problems, and be an overload abuse​. If done this
> way I would vote for having long named methods with is() being just a
> forwarder. And I think there may be some ambiguities if overloaded is() is
> used to test overloaded method ( i.e., when you mock m(is(String.class))
> are you mocking m(Class c) ( as m(eq(String.class))  )  or m(String s) with
> any string? ( It's a contrived overload, but I've seem some of these where
> the String version takes a class name, I think OSGi has some of them ).
> Having a long method (anyIstanceOf, equalTo, evenm, specially, isNull()
> which I personally prefer to is(null) ( Which overload is it going to pick,
> the Object one with a null param ) ) lets people key a little more in the
> difficult cases and does not at too many complexity or a signigicant run
> time for test code ( is() is just a one line forwarder, and it's javedoc
> can be left as such which just an @link to the unoverloaded method ).

Regarding readability, I'm not sure compact overloaded names are more
readable, they may be easier to read aloud, but you need to invoke higher
level brain functions to parse it and distinguish the overload being used,
but maybe I'm just becoming slower.

​Francisco Olarte.​
 =||= Yep, I prefer option 1.

#246 sounds like a good idea to me, but we should definitely market it very clearly as a convenience method (as Francisco mentions), and obviously keep the explicit methods, so people are aware they can opt in to explicitly choosing the relevant option if they need to or they're not sure what the overloading does.

The overload I'm most suspicious of is `is(T)`, just because it's most likely to be ambiguous, in practice and when trying to just think about what a line is doing. `is(null)` seems clear, `is(stringStartingWithHello)` is fine, but if I saw`when(is(100), is(String.class))`, I think my default would be to assume that the argument needed to literally be the class object. Not totally sure about that though, happy to go with it if others are happy.
 =||= Any progress on this? Are people happy for me to put together a potential PR for option 1, which it sounds like we've settled on, as something concrete to discuss?
 =||= My preference is to have the following matchers (option 1?):
-  `<T> T any()`  that accepts anything including `null`.  I associate _""any""_ to the _""anything""_ in my world that includes null-values and instances. It is compact and suitable for the most common cases.
- `<T> T anyObject()` or `<T> T notNull()` reject `null` values opposite to any(). The name should indicate that null is rejected to avoid confusion about its behaviour.
- `<T> T isA(Class<? extends T>)` reject `null` values and all values that are not a subtype of `T`, like instanceof.
- all `any*()` and `any(T)` should be dropped cause they have different behaviour (as described before)
 =||= > 1. Shoot down any(T) and anyT() in favor of isA(). This thread seems to be converging on this approach. Consistent and clean. High impact, potential churn.
> 2. Change any(T) and anyT() methods to reject nulls. Suggested by the community originally, potentially confusing down the road due to inconsistence with any(). This inconsistence becomes less of a problem with java8.
> 3. Do (2) but also shoot down any() replacing it with anyObject() or anything() or '_' (ala spock ;). Not sure I like killing any() because it is neatly compact.
> 4. Leave things as they are for now. Perhaps revisit for java8 support.

Let's try to be decisive :)

Tim & Christian vote for option 1) I very much appreciate those votes and option 1 does have a lot of charm :)

Myself, I vote for 2) because:
- any(T) reads better (seems more fluent), is more intuitive to write than isA(). It looks good in tests.
- it is consistent gramatically with any(), it makes the API a bit more consistent
- java8 is very popular, people use any() for matching anything and can use any(T) for matching specific type (not null)
- removing any(T) (options 1 and 3) seems like a churn and big impact on users without strong enough justification. It seems arbitrary that we remove the any(T) methods. E.g. myself as a user, I would not be convinced that migrating to Mockito 2.0 is a good idea because I need to fix hundreds of compilation errors due to removal fundamental API method (anyT/any(T)). Even if I make that search&replace, I'm not convinced that tests look better now. The change also hurts muscle memory and users would be finding themselves using any(T) methods, finding the code not compile, then realizing that aha! this method was removed. However, if we update the behavior of any() (option 2) we will provide very nice signal to users during the migration to 2.0. We could potentially expose bugs. Most users expect nulls to be rejected by any(T) - Mockito 2.0 will make expose tests that fail that assumption.

We don't have to agree. However, it would really cool if we were on the same page :) It would be so nice if everyone of us could stand behind decisions we make as a team.

We definitely need to make the decision!!! (if left undecided, we're effectively deciding on option 4).
 =||= I would like to suggest introducing the isA API alongside any. The latter would accept nulls while the former would rejecet them.

Nulls are pretty common as values so we ahould not make this more difficult than necessary. Also, tgis makes migration easier.
 =||= I already started the work on this a few days ago, and I chose to kinda follow option 2 as well, here's the plan :
- `<T> T any()` that accepts anything including `null`. I am pondering the addition of `anything` as it is the original meaning of `any`.
- `* any*()` / `<T> any(T)` will be aliases of `<T> isA(T)`, **this is the expected behaviour by users**, doing this will introduce the rejection of `null`, with Java 8 I saw young developer to switching to `any()` when `null` values where used instead of `anyInt`.

Since we want to do a release candidate I suggest that we ship the _null safe_ `any*`, and remove the `null` check if too much people complain.

cc @TimvdLippe @marcingrzejszczak @raphw @szpak 
 =||= Thanks for feedback!

+1 to your plan.

-1 to 'anything', it feels that it does not add sufficient value. It's a
longer alias - not sure why would someone want to use it.

On Mon, Jul 25, 2016 at 10:10 AM Brice Dutheil notifications@github.com
wrote:

> I already started the work on this a few days ago, and I chose to kinda
> follow option 2 as well, here's the plan :
> - <T> T any() that accepts anything including null. I am pondering the
>   addition of anything as it is the original meaning of any.
> - \* any_() / <T> any(T) will be aliases of <T> isA(T), *this is the
>   expected behaviour by users_, doing this will introduce the rejection
>   of null, with Java 8 I saw young developer to switching to any() when
>   null values where used instead of anyInt.
> 
> Since we want to do a release candidate I suggest that we ship the _null
> safe_ any*, and remove the null check if too much people complain.
> 
> cc @TimvdLippe https://github.com/TimvdLippe @marcingrzejszczak
> https://github.com/marcingrzejszczak @raphw https://github.com/raphw
> @szpak https://github.com/szpak
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/194#issuecomment-235017691,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AABgp-nrLrlhKpwIt9XZjvOvBWLNnglBks5qZO3wgaJpZM4D6d0z
> .
 =||= +1 i agree, lets try this for the RC.
 =||= ",0
535,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
540,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
547,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
550,538,Improve error message when @InjectMocks is uses on an interface or enum field,"By accident a tests delares a field of an interface type instead of the implementing class.  

```
@InjectMocks
public InterfaceType unitUnderTest;
```

Injection is not possible on interfaces or enums. The error message should make this clear, the currenta message that doesn't help much:

```
org.mockito.exceptions.base.MockitoException: 
Cannot instantiate @InjectMocks field named 'configurationManager'.
You haven't provided the instance at field declaration so I tried to construct the instance.
However, I failed because: the type 'ConfigurationManager' is an interface.
Examples of correct usage of @InjectMocks:
   @InjectMocks Service service = new Service();
   @InjectMocks Service service;
   //also, don't forget about MockitoAnnotations.initMocks();
   //and... don't forget about some @Mocks for injection :)
```

The error message should be someting like:
`The field 'unitUnderTest' can not be annotated with @InjectMocks cause the type 'InterfaceType ' not a class!
`",nan,0
555,384,JUnit rule logs warnings about unsued / misused stubs,"### Why

When test fails, the failure might be caused by misused stubs. Hence, it might be worth to log out debugging information to the System out (e.g. misused stubs, unused stubs). For more details see documentation for [MockitoHint](https://static.javadoc.io/org.mockito/mockito-core/2.5.0/org/mockito/quality/MockitoHint.html).

### Plan
- [x] document 2.x change
- [x] tweak the warning message
- [x] add behavior to the runner
- [x] add silent runner
- [x] add silent setting to the rule (or warnings level for all / exception only / none)
- [x] deprecate/remove console spamming runner
### Impl

The JUnit rule or the runner will potentially include following info in the output (somehow): https://gist.github.com/szczepiq/38619fd8766c66c46dff4dc2b6db06ec

I'm wondering if ""Mockito.validateMockitoUsage();"" should automatically print warnings. We could provide boolean parameter to control printing of the warnings.","On it.
 =||= I like the feature! What do you think about a `rule().strict()` that doesn't emit logs but fails asap?

A note to the API:
- How do we prevent misuse like -> `rule().strict().strict()` ? What about `rule(LOG_WARNINGS)` aka `rule()`, `rule(SILENT)`, `rule(FAIL_FAST)`
 =||= Christian, very cool ideas!!! 

I'm not sure I'll have time for it before 2.0. However, I want the new default behavior in rule / runner in 2.0 so that users see what it is doing. Then we can grow and add strict mode.
 =||= @szczepiq: I like this feature very much. Also that the `MockitoJUnitRunner` fails by default is good. I think a note in the javadoc of `UnnecessaryStubbingException` to use `MockitoJUnitRunner.Silent` would be helpful.

We often have quite complex test fixtures, and it's cumbersome to switch absolutely each and every stub on or off... some methods simply have to be there; it's also not necessary to verify if they've been invoked. So it would be great to be able to disable it for some stubs, but leave it on for others.
 =||= @t1 That seems like a reasonable idea. Want to make a PR for that?
 =||= Good feedback. I think that MockitoHint class should also mention that it is possible to silence the new mechanism.
 =||= #609
 =||= The [MockitoHint](http://site.mockito.org/mockito/docs/current/org/mockito/quality/MockitoHint.html) documentation seems to indicate that this will give you warnings about mismatched arguments, when using the MockitoJUnitRunner.  However, from my experience this doesn't seem to work with Mockito 2.1.

Here's the source I'm trying:

``` java
Foo foo = mock(Foo.class);
when(foo.bar(""baz"")).thenReturn(""bar"");

foo.bar(""baz"");
foo.bar(""test""); // expected to get a warning here
```

Is there something else I need to do to enable this functionality?
 =||= Thank you for feedback!

> Is there something else I need to do to enable this functionality?

This is how they were implemented. Runner should also report mismatches because it helps with debugging. The reason it does not do it today is because I wanted to limit the noise.

We will fix this issue. Also, we will consider always printing warning when stub args mismatch, even if one does not use runner / rule.

Do you want to open a separate ticket to track this improvement?

Thanks for reporting!
 =||= I've opened #725 to track this.
 =||= Came across this after running into this in my test :
```
[MockitoHint] MyTest.checkSomething (see javadoc for MockitoHint):
[MockitoHint] 1. Unused -> at MyTest.test1(MyTest.java:584)
```
It is complaining about this (line 584):
```
   when(mockObject.getPeerHost()).thenReturn(""peer-host-from-mock"");
```
Now my issue is this: this particular method `getPeerHost()` is indeed not called when the code works as expected e.g. something like this:
```
   if (newMethod()) {
      ...
       String peerHost = mockObject.getPeerHost();
       // use peerHost in further processing
      ...
   }
```
`newMethod()` is the new code being added and should correctly return `false`. However if there is a bug in `newMethod()` and it returns `true` then I want `getPeerHost()` to return some value which will cause a failure that I can detect. So this requires me to mock a method even if it is not called in normal processing and there is no bug in the code. I think that should not generate a warning. Has this been addressed? =||= Do I need to open a new issue as I cannot reopen this? =||= > Do I need to open a new issue as I cannot reopen this?

Yes, please.

> Has this been addressed?

Yes. For example, you can use ```lenient().when(...)``` stubbing to avoid reporting an unused stubbing. However, in your test case, I would simply write ```verify(mockObject, never()).getPeerHost();```.

Hope that helps!
 =||= > Yes. For example, you can use `lenient().when(...)` stubbing to avoid reporting an unused stubbing. 

Thanks for the `lenient` tip - that helps.

> However, in your test case, I would simply write `verify(mockObject, never()).getPeerHost();`.
> 

That's more work and more white box testing than I want. Let's say this is for testing the SSL logic where peerHost (of a connection) is matched (or not matched) against ""subject-name"" in a cert under various conditions but I have common setup/initialization where I ""mock"" the peerHost of the connection. In one of the conditions the host-name match is suppressed (i.e. `newMathod()` returns `false`) but because of the common setup code I get the 'unused' warning from `MockitoHint` for that test. =||= My recommendation is to use lenient() + strict stubbing for this use case.

If you feel we should still discuss the use case ``verify(never())`` vs. ``when(...).thenThrow(...)`` then please open a separate ticket.

Hope that helps and thank you for feedback! =||= ",0
555,527,Fixes #384 - JUnit rule provides stubbing hint to help debugging tests,"Recreated the branch / recreated the PR. This is ready, I want to improve the docs (MockitoHint) before merging.

See the use case in issue #384 

I'm growing the StubbingListener and getting JUnit rule take advantage of it to report hints to the user that hopefully help debugging tests.","If there is no feedback, I'll merge in the next 48 hours.
 =||= ## [Current coverage](https://codecov.io/gh/mockito/mockito/pull/527?src=pr) is 88.07% (diff: 97.53%)

![Sunburst](https://codecov.io/gh/mockito/mockito/pull/527/graphs/sunburst.svg?size=150&src=pr)

> No coverage report found for **master** at c0a9d33.
> 
> Powered by [Codecov](https://codecov.io?src=pr). Last update [c0a9d33...b459660](https://codecov.io/gh/mockito/mockito/compare/c0a9d33ada4afcecd5c6a487d525bd3ba174a62f...b459660385c0a3678df6d7c41400347b84bbd7b1?src=pr)
 =||= @szczepiq can you squash the commits and remove/resolve all TODO comments?
 =||= Woah, that's what I'm calling feedback :) Thanks, I'll get onto it!!!
 =||= Some update: I will update this PR very soon. I'm making nice progress.
 =||= @szczepiq 
Register / remove MockitoListeners should be independent of the calling Thread. I wonder if a listener will be notified if it was registered by Thread-A and a mock is created by Thread-B.
 =||= Hey Christian!!! Good feedback! I'm scratching the idea of StubbingListener, because I cannot get this working for multi-threaded scenarios.

I made final changes, please check it out if you can. Javadoc left TODO for one of the class, otherwise I'm pretty happy :). Will get it done tomorrow. Feedback welcome (unless you want to pick on the stateless classes that could be static!!! :))). I'm merging very soon.
 =||= I'm done. Currently, the listeners need to be per thread and it's documented in the javadoc. I don't know if it is the best idea but given trade-offs, I chose this implementation.
 =||= @szczepiq 

The threading problem should be avoided before release. I looked into it worked on a fix proposal that you can find here -> [Gist](https://gist.github.com/ChristianSchwarz/26c2dc118d407a1347ea523d52cffcc1)

The idea is to store the listeners is in `ThreadSafeMockingProgress` that is used as global access instead of the `MockingProgressImpl` that is used only for the calling thread.

WDYT?
 =||= @szczepiq 

More more thing that I noticed. The listener methods should be prefixed with ""on"" like `onMockCreated(..)` and the notifing method should be prefixed with ""fire"" like `fireMockCreated()`. Currently both methods (the notifying and listener method) can't be distinguished cause both have the name `mockCreated(..)`.
 =||= @szczepiq 

`StubbingListener` should implement `MockitoListener` this way it can be registered using  `MockingProgress.addListener(..)`. After that set-/ removeStubbingListener(..) can be removed.
 =||= @ChristianSchwarz 

Great feedback, thanks!

+1 to the rename on the listeners
-1 StubbingListener changes - I'm getting rid of StubbingListener, I reopened #401 

StubbingListener does not work in multi-threaded environment where shared mock is interacted with from multiple threads. 'stubbing used' event can be triggered from multiple threads. I would have to make StubbingListener completely static to handle this scenario (which would introduce set of complexities).
 =||= Feedback incorporated :) Any final feedback?

I'll recreate PR with squashed commits tomorrow & merge. Next step for me: fix #401 
 =||= Massive change (52 files) give us a bit more time !
 =||= > Massive change (52 files) give us a bit more time !

@bric3, absolutely. In return, can you commit to review ETA? (Reopened issue #401 needs this PR merged).
 =||= @szczepiq Doing it right now ;)
 =||= OK reviewed, nice work !
 =||= Recreated with squash at #555. Addressed code feedback selectively, making subjective judgements :)
 =||= You can push force on the same branch github will figure out the difference and will close comments that have been fixed. 
 =||= @szczepiq 
Did you see the comments were i not referenced your name? Most of the them are uncommented.
 =||= ",0
560,554,Checks.checkNotNull should emit IllegalArgumentException instead of NPE,"Checks.checkNotNull emits NPE. I think it is better to emit IAE, because:
- IAE is more specific whereas NPE is more generic. Specific exception is easier to test.
- Specific exception gives better experience for users, NPE is often assumed to be developer error.

This change is not backwards compatible.

@bric3, thoughts?","Definitely! Personally I hate throwing NPEs. NPE can be thrown because you've forgotten to inject sth and your test (if you test for an NPE exception to be thrown) will pass.
 =||= Agreed 
 =||= ",0
568,401,JUnit runner detects unused stubs,"It is useful to know that stubbing in the test was not used. Perhaps the stubbing is not needed? Removal of unnecessary code from the test is important for code clarity.

More details:
- we detect unused stubs only for passing tests (adding different failure to an existing failure could be confusing)
- need to have something similar for JUnit rules (will create separate ticket)
- stubbing in @Before or class constructor should be used in at least one test
- stubbing in test needs to be used in that test","The current impl is not thread safe. Reopening.
 =||= ",0
568,332,Finalize Mockito Runners,"Currently, we have a couple of Mockito Runners that are a part of public API but they are largely unknown:
- ConsoleSpammingMockitoJUnitRunner
- VerboseMockitoJUnitRunner

They attempt to improve the testing / TDD experience by adding warnings for following scenarios:
     - a) unused stubbing
     - b) stubbed method called with different args (and a special variant of a)

Example of a warning:

---

 **\* Stubbing warnings from Mockito: ***

stubbed with those args here   -> at org.mockitousage.junitrunner.ModellingVerb
BUT called with different args -> at org.mockitousage.junitrunner.ModellingVerboseMockitoTest.shouldLogUnusedS
This stubbing was never used   -> at org.mockitousage.junitrunner.ModellingVerboseMockitoTest.shouldLogUnusedStubbingWarning
This stubbing was never used   -> at org.mockitousage.junitrunner.ModellingVerboseMockitoTest.shouldLogUnusedStubbingWarningWh

---

The rationale is explained in the javadoc of the above runners. In 2.0 let’s include stubbing warnings in the default behavior of JUnit rule and the default runner.

Challenges that need thinking through:
- feature parity with JUnit rule
- clean API so that the warning system can be integrated with other runners
- some API to get hold of those warnings programmatically
- feature toggle
  - disable completely
  - disable by test / test class / stubbing?
- how can this be tested?","> how can this be tested?

Using `JUnitCore`, there's already a few tests that uses it.

> - feature toggle
>   - disable completely
>   - disable by test / test class / stubbing?

Using the plugin switch functionality ?
Note there's some idea in the pull request to toggle stuff per test / test class. However I don't feel this is mature enough to be integrated, in mockito yet.

In my opinion the `Rule` is the the right place to configure mockito per test.
 =||= ",0
569,541,improve Mockito.mockingDetails API,"In order to make the API cleaner & expose useful information:
1. MockingDetails.getInvocations() throws meaningful exception when passed object is not a mock and documents this behavior
2. getMockedType() and getExtraInterfaces() are replaced with getMockCreationSettings() that returns MockCreationSettings instance.","OK but let's deprecate them instead of removing them (possibly in mockito 3).
 =||= Given that getMockedType() and getExtraInterfaces() are unreleased yet (e.g. 2.0), do you still opt for deprecation?
 =||= good point, let's remove them then !
 =||= ",0
576,564,Publish Mockito build results to Gradle Build Scans,Let's start publishing Mockito build results to Gradle Build Scans. This way we have extra intel about Gradle builds. This also helps friends at Gradle as they will have more projects on board!,nan,0
576,544,improve stubbing warnings formatting,"Follow up after #384, let's get the stubbing warnings look good in case there are many instances to report (text padding).","@bric3 suggested:

String.format(""%4d. %s %s %n"", x++, "". Unused... "", m.getKey().getLocation())
4 is hard coded here, but that would work up to 9999 hint. It's still possible to compute that value if hard coded value don't work.
 =||= I tested it out with lots of unstubbed calls and the current behavior is completely acceptable. Is not completely aligned but it is still decent. I'm not fixing this cosmetic issue.
 =||= ",0
589,552,Fix again javadoc stylesheet,"Previously we had a nice javadoc stylesheet. That worked well with JDK6.
Then we used travis that was only allowing OracleJDK7, that came with a better javadoc stylesheet so we dropped ours.

Now since the release of mockito 2.x is using openjdk6, we should reintroduce a better stylesheet.

Current state ❌ 
http://site.mockito.org/mockito/docs/2.0.100-beta/org/mockito/Mockito.html
<img width=""712"" alt=""screen shot 2016-08-13 at 19 41 59"" src=""https://cloud.githubusercontent.com/assets/803621/17644719/cecc5ec4-618e-11e6-912e-9b0dcd7e94db.png"">

Previous ✅ 
http://site.mockito.org/mockito/docs/2.0.0-beta/org/mockito/Mockito.html
<img width=""877"" alt=""screen shot 2016-08-13 at 19 45 32"" src=""https://cloud.githubusercontent.com/assets/803621/17644722/d71bcd08-618e-11e6-831a-a01c47e8cc61.png"">","Is this as simple as turning back on this line? https://github.com/mockito/mockito/blob/b0393eafeeb81b6c75e40a82b81672543777ca9a/gradle/javadoc.gradle#L55
 =||= Probably but I need to check before. The file may have been removed. And the javadoc tool is _picky_ especially in old version of the JDK.
 =||= Actually we should revert this commit 3a057b3eff2be528a1fed41852a990cff87a72c1, when JDK7 was the only option on travis
 =||= It seems the javadoc tool of openjdk6 generates a different HTML than Sun JDK 6. Thus the stylesheet is not working properly.

<img width=""748"" alt=""screen shot 2016-08-24 at 11 56 56"" src=""https://cloud.githubusercontent.com/assets/803621/17926642/35b9d2cc-69f2-11e6-9614-61648cafeb18.png"">

Yet again an issue with OpenJDK6...
 =||= ",0
592,552,Fix again javadoc stylesheet,"Previously we had a nice javadoc stylesheet. That worked well with JDK6.
Then we used travis that was only allowing OracleJDK7, that came with a better javadoc stylesheet so we dropped ours.

Now since the release of mockito 2.x is using openjdk6, we should reintroduce a better stylesheet.

Current state ❌ 
http://site.mockito.org/mockito/docs/2.0.100-beta/org/mockito/Mockito.html
<img width=""712"" alt=""screen shot 2016-08-13 at 19 41 59"" src=""https://cloud.githubusercontent.com/assets/803621/17644719/cecc5ec4-618e-11e6-912e-9b0dcd7e94db.png"">

Previous ✅ 
http://site.mockito.org/mockito/docs/2.0.0-beta/org/mockito/Mockito.html
<img width=""877"" alt=""screen shot 2016-08-13 at 19 45 32"" src=""https://cloud.githubusercontent.com/assets/803621/17644722/d71bcd08-618e-11e6-831a-a01c47e8cc61.png"">","Is this as simple as turning back on this line? https://github.com/mockito/mockito/blob/b0393eafeeb81b6c75e40a82b81672543777ca9a/gradle/javadoc.gradle#L55
 =||= Probably but I need to check before. The file may have been removed. And the javadoc tool is _picky_ especially in old version of the JDK.
 =||= Actually we should revert this commit 3a057b3eff2be528a1fed41852a990cff87a72c1, when JDK7 was the only option on travis
 =||= It seems the javadoc tool of openjdk6 generates a different HTML than Sun JDK 6. Thus the stylesheet is not working properly.

<img width=""748"" alt=""screen shot 2016-08-24 at 11 56 56"" src=""https://cloud.githubusercontent.com/assets/803621/17926642/35b9d2cc-69f2-11e6-9614-61648cafeb18.png"">

Yet again an issue with OpenJDK6...
 =||= ",0
597,593,Mockito Javadoc has a TODO about hamcrest,"``` java
 * TODO rework the documentation, write about hamcrest.
 *
 */
@SuppressWarnings(""unchecked"")
public class Mockito extends ArgumentMatchers {
```

https://github.com/bric3/mockito/blob/18133aa0cb5b51c0472fb8b33ab0a22aa9f0fbf3/src/main/java/org/mockito/Mockito.java#L1207-L1207

Let's remove it or fix it.","On it. Thanks!
 =||= ",0
599,598,Generated release notes contain unsorted and duplicate committers,Generated release notes contain unsorted and duplicate committers,nan,0
604,603,Release notes group improvements by labels,"For clearer release notes overlook we should group improvements by labels. 

This was originally contributed by @szpak, then lost during the early days of continuous integration, now it's back and it will rock!!!",nan,0
605,595,Handle beta non-semantic versioning scheme,"Thanks to the odd number scheme of the beta, the maven badge and other systems like **maven central** consider that version `2.0.111-beta` is more recent than `2.0.0-beta.115` or event more dangerous that `2.0.111-beta` is more recent than the actual release `2.0.0`.

That may cause problems for users that don't read the README on the projects page. This is counter intuitive and forces users to search what is the difference between those versions.

<img width=""524"" alt=""screen shot 2016-08-24 at 16 48 21"" src=""https://cloud.githubusercontent.com/assets/803621/17935365/5f186128-6a1b-11e6-85cc-6a1e4818a869.png"">

http://search.maven.org/#search%7Cga%7C1%7Cmockito-core
<img width=""1108"" alt=""screen shot 2016-08-24 at 16 53 43"" src=""https://cloud.githubusercontent.com/assets/803621/17935366/5f2adfce-6a1b-11e6-9bcc-8acd8bb40248.png"">

**Since sonatype does not allow public ways to remove artifacts, we need to create a ticket on their [JIRA](https://issues.sonatype.org/) asking for deletion of the betas, whose access is only possible to authenticated users.**

I propose to do that **after** the release of 2.0.0 !","1. Do you guys think it is a good idea to remove published artifacts from maven central?
2. What are the alternative options? (we will branch 2.1.0 soon)
 =||= No I don't think it is a good idea, but keeping them is probably a worse one, and those are beta.
Alternative, not really. 

If the design of release notes signals poor quality, then having funky intertwined versions on the central maybe another sign of poor quality. Documentation is a thing. But I rarely go on the project site when I declare a dependency version in my pom or in my gradle script.

Scenario :

> User will first upgrade to 2.0.0, and oh why not upgrade to 2.0.111-beta while 2.1.0 is getting ready.
 =||= What about releasing 2.1.0-RC.1?
On Wed, Aug 24, 2016 at 11:17 Brice Dutheil notifications@github.com
wrote:

> No I don't think it is a good idea, but keeping them is probably a worse
> one, and those are beta.
> Alternative, not really.
> 
> If the design of release notes signals poor quality, then having funky
> intertwined versions on the central maybe another sign of poor quality.
> Documentation is a thing. But I rarely go on the project site when I
> declare a dependency version in my pom or in my gradle script.
> 
> Scenario :
> 
> User will first upgrade to 2.0.0, and oh why not upgrade to 2.0.111-beta
> while 2.1.0 is getting ready.
> 
> —
> You are receiving this because you were assigned.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/595#issuecomment-242160343,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AABgp0un30R5I_hgWlY66cXz1eE9dkxrks5qjIrOgaJpZM4JsGsg
> .
 =||= Eg. Instead of 2.0 we push 2.1 and add other features in 2.2 or 2.1.x
On Wed, Aug 24, 2016 at 13:53 Szczepan Faber szczepiq@gmail.com wrote:

> What about releasing 2.1.0-RC.1?
> On Wed, Aug 24, 2016 at 11:17 Brice Dutheil notifications@github.com
> wrote:
> 
> > No I don't think it is a good idea, but keeping them is probably a worse
> > one, and those are beta.
> > Alternative, not really.
> > 
> > If the design of release notes signals poor quality, then having funky
> > intertwined versions on the central maybe another sign of poor quality.
> > Documentation is a thing. But I rarely go on the project site when I
> > declare a dependency version in my pom or in my gradle script.
> > 
> > Scenario :
> > 
> > User will first upgrade to 2.0.0, and oh why not upgrade to 2.0.111-beta
> > while 2.1.0 is getting ready.
> > 
> > —
> > You are receiving this because you were assigned.
> > 
> > Reply to this email directly, view it on GitHub
> > https://github.com/mockito/mockito/issues/595#issuecomment-242160343,
> > or mute the thread
> > https://github.com/notifications/unsubscribe-auth/AABgp0un30R5I_hgWlY66cXz1eE9dkxrks5qjIrOgaJpZM4JsGsg
> > .
 =||= I would neither recommend to remove anything from Maven Central (if they even let you). A lot of people already use the beta releases and that would break their build until the realize they need to upgrade; this is just bad publicity.

Maven Central Search sorts releases by date, not by version number. I think that we can just go for 2.0.0-rc1.
 =||= I also wonder, if `2.0.0` is considered newer than `2.0.X-beta`. Once we publish, we have to check this out. If this is working just fine, I would not take any action. However, if it is a problem, I think releasing `2.1.0` is the cleanest solution. This also makes sure that when using maven version ranges, we force the tool to download the newest version.
 =||= My thinking is that those beta versions will confuse people outside of maven central.

> Maven Central Search sorts releases by date, not by version number. I think that we can just go for 2.0.0-rc1.

I'm aware of that and the reason is that a project can release a fix version of a previous major version, hence the date sort ; it is by no mean a way to show the latest major version first. However other tools and the default search (like shown above) shows the latest **semantic version**, in the present situation version `2.0.111-beta`.
 =||= I like the proposition of @szczepiq to release a `2.1.0` instead.
 =||= Would this not confuse people wondering where 2.0 ended up?
 =||= Yes that is the downside of straight out publishing of `2.1.0`. But right now it is choosing the lesser of two evils :(
 =||= > Would this not confuse people wondering where 2.0 ended up?

How would this confusion manifest?
 =||= Maybe its not that problematic but I would wonder how I missed 2.0.
 =||= Yes that is the downside, but I think we can make it very clear in our release notes and publish it everywhere on the interwebz.
 =||= Nice team decision! I'm closing this ticket. Reopen if you feel we still need to discuss.

Summary:
- Next stable release is 2.1.0 
- Ensure it is clear in announcement / release notes

Sorry guys for creating confusing beta versioning scheme 2 years ago!!!
 =||= AFAIR I also supported the unfortunate versioning scheme... It was long time ago and I've learned  much about semantic versioning since then :)

I'm also totally against removing artifacts from Maven Central. Do you remember guys the quite recent ""troubles"" with quite popular JavaScript library removed from node.js repo?
 =||= @szpak Yeah that sucked. I really thought of this as bad thing to do, the only thing is that it's betas.
 =||= TLDR:
- Remove the betas from Maven central
- Find a way to avoid releasing betas on Maven central

Actual comment:

I don't read release notes, I don't participate in Mockito stuff. All I do is read the Javadoc. For more than a year, now, as someone who creates new projects every few days, I get pretty annoyed by the bad release management you've used. Maybe it's me, maybe it's you, I don't know. But I don't find this clean. At all.

Here's what Netbeans suggest me when I'm selecting Mockito's version.

![mockito-betas-1](https://cloud.githubusercontent.com/assets/666970/18350161/f7c71918-75d4-11e6-943a-fb772efb9c3d.png)

Oh, no final version on the first screen... Okay, let's scroll down.

![mockito-betas-2](https://cloud.githubusercontent.com/assets/666970/18350170/fee7123e-75d4-11e6-9145-8b1c2d2d126d.png)

What? I have to scroll down to the bottom 20% to find a stable version? Wait, is that a 2.1.0 beta? did I pass the 2.0.0 version? I just can't say. _scroll, scroll_. Ok, I didn't miss it: it's not yet released. But then, why do I see the 2.1.0 beta already? Shouldn't that even be alpha? I just don't know.

That means that roughly 80% of the versions given on Maven central are betas. Do you really think that this should go on? You guys have done some of the best API design when it comes to Mockito. But when it's about the release, the result is really subpar, for betas that no one will never ever use anymore.

You should ask sonatype to remove all those beta versions. As a user of what you do, I don't care about beta (maybe the last 2-3 beta versions to check what's new, but no more).

> Do you remember guys the quite recent ""troubles"" with quite popular JavaScript library removed from node.js repo?

This was a production library. Here, the original idea is to remove betas.

To avoid this in the future, please, please, fix the publishing to Maven central. Recently there has been in average roughly one release per day on Maven central. Don't release the betas there. Nothing actually forbids you to do so, but look at the mess in the two screenshots. Why not create a private repo for testing? Can't this be hosted in a specific branch on GitHub? (a repo is just a folder, right?)

I humbly ask you to do so for all of your users, for us who love what you've done so far.
 =||= I have to say that this versioning pattern, process or whatever you want to call it is confusing. You have been releasing betas for the last almost two years and there is no final release. What are you waiting for? Betas by definition are not meant to be used for production. Releasing after every checking seems absolutely crazy to me. You need to adopt some for of Scrum or Kanban process, identify your release schedule and work towards that. Any release in Maven Central should be FINAL. Betas and Release Candidates should be hosted on a separate repository. 

I still use 1.10.19 because we have a policy against the use of BETA products. Would love to upgrade.
 =||= Great feedback. Thanks guys! I can understand your frustration now.
 =||= Though I agree that averaging a new release _every day_ is ""quite something"", I would like to point out that publishing betas with _some frequency_ can help get more people to test your non-final code. Our project is comfortable using the betas and in using them filed two bugs against them (#218, #272).

I frequently check for updates using a quick alias:

``` sh
$ alias list-updates
alias list-updates='mvn -N -U versions:display-dependency-updates versions:display-plugin-updates
```

I suspect other people do something similar. If you stop publishing the betas altogether, or start publishing them to some custom repo not present in our company Nexus instance, then this user at least will stop going through the ""trouble"" of testing the betas.
 =||= We are very closing to releasing, but we had to update our documentation to provide a clear upgrade guide and motivation why you would want to upgrade to Mockito 2.X. Keep in mind that Mockito is open source and developed by volunteers who have real life jobs. The past year(s) have been very busy for the core team and lately new developers joined the team to actually publish Mockito 2.X. I expect the release candidate to be released next week.

That said, we have written a wiki page on Continuous delivery with the motivation, explanation of 2.1.0 vs 2.0.0 and lessons learned. It has not been officially published, but you can get a sneak peak reading it here: https://github.com/mockito/mockito/wiki/Mockito-Continuous-Delivery

The major selling point of CD for us as open source developers is very fast feedback on features we develop. Since we can't comprehend all possible scenarios, user feedback is extremely important for us. Therefore beta releases are used by some of our most active users to provide feedback. They are dependent on these binaries to be released.

I don't think we have to drop CD, however we can look into the possibility to publish beta releases in a different medium. This option MUST be as least impactful as possible for our active users since we are greatly dependent on their feedback and work. If we can find such a solution, I am all up for it! :smile: 
 =||= > I don't read release notes, I don't participate in Mockito stuff. All I do is read the Javadoc.

It takes 3 second to scan the first 6 lines of Mockito [README](https://github.com/mockito/mockito/blob/master/README.md) to get all the information you need. The most important stuff is even in badge form and clickable. Picking a library (version) just based on a flat auto-completion list of your IDE doesn't sound like the best thing to do. How would you know what changed?

There are a tons of OS projects that do not release versions ""in-between"", which often times leads to frustration on the client's side, because someone is always looking for `HEAD` to be available as a binary :wink: 

While I agree that Mockito could have streamlined the development of 2.0/2.1 a bit, they know (#618) and are working hard on getting it done (#123).
 =||= @lukasniemeier-zalando 

Hi, you say they do things that can be improved and they know and they're working hard on getting them done. Yet you do not allow me to find my library versions the way I want so that I can get my own things working as efficiently (to me) as possible? Well, hmm... OK. I don't understand but I accept.

As I said, the Mockito team offers a really great library. I'm totally aware that they're developing this on their free time, and I totally support this. I'm myself involved from afar in some libre projects, and not as much as I'd love to.

All I actually said is that the whole beta stuff is a mess, from an external point of view. How many people do you really think take the time to go on the library project to even go to the Javadoc? From what I see around me, I'm the only one to even visit the project page (not even to check RN). Some colleagues go only to Maven Central, pick their Javadoc directly in their IDE from the Javadoc (or source) jar. Some others copy/paste their POM from projects to projects and refer to online tutorials and Stack Overflow. We're all working in a different manner. All I said is how the beta-thing looks from the outside. Developers may have the best intentions out there, the large user base only see the result. You won't get much more people saying what I say because they just won't ever get to this page. I decided to finally come here because I like Mockito and there was something I didn't like that has bugged me for more than a year. Yes, it took me a year to come to say this.

Regarding the CD. It's an excellent manner to work things out. The only issue I see in the way it is currently done is that it's polluting your mockito ""namespace"" in Maven with 80% beta versions. Usually when I work on projects we release internally so that users test it and suggest improvements, then only we release to the production. In my view (but I might be wrong), Maven Central should only contain final releases. I think it's how things should be because that's how most of the projects I'm aware of work that way. However I'm not aware of any ""private-"" or ""beta-""repository provider for Maven artifacts. If I knew one I'd give away its name right now.
 =||= This great discussion and a very valuable lesson learned for us. Thank you
guys for feedback! We will fix the Beta versions problem.
 =||= ",0
615,497,DEEP_STUBS tries to mock final class,"```
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <version>1.10.19</version>
        <scope>test</scope>
    </dependency>
```

```
$ java -version
java version ""1.8.0_91""
Java(TM) SE Runtime Environment (build 1.8.0_91-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)
```

```
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
import static org.mockito.Mockito.mock;

import org.junit.Test;

public class MockitoBug {
  public interface Supplier<T> {
    public T get();
  }

  public interface StringSupplier extends Supplier<String> {}

  public interface InheritedSupplier extends StringSupplier {}

  @Test
  public void deepStubs() {
    StringSupplier mock = mock(StringSupplier.class, RETURNS_DEEP_STUBS);
    String s = mock.get();
    assertNull(s);
  }

  @Test
  public void inheritedDeepStubs() {
    InheritedSupplier mock = mock(InheritedSupplier.class, RETURNS_DEEP_STUBS);
    String s = mock.get();  // ClassCastException
    assertNull(s);
  }
}
```

```
java.lang.ClassCastException: org.mockito.internal.creation.cglib.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$322ebf6e cannot be cast to java.lang.String
    at MockitoBug.inheritedDeepStubs(MockitoBug.java:26)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
```

I expect the behavior for `StringSupplier` and `InheritedSupplier` to be the same: return `null` for `get`. However, `InheritedSupplier` tries to return a mock `Object` for `get`.","I have a hacky workaround using Guava's `TypeToken`:

```
  private static final MockUtil mockUtil = new MockUtil();

  @SuppressWarnings(""unchecked"")
  private static <T> T createSmartDeepMock(TypeToken<T> mockType) {
    return (T) mock(mockType.getRawType(), createSmartDeepMockAnswer(mockType));
  }

  private static Answer<?> createSmartDeepMockAnswer(TypeToken<?> mockType) {
    Map<Method, Object> mocks = new LinkedHashMap<>();

    return invocation -> {
      Method method = invocation.getMethod();
      if (mocks.containsKey(method)) {
        return mocks.get(method);
      }

      Type returnType = method.getGenericReturnType();
      TypeToken<?> resolvedReturnType = mockType.resolveType(returnType);
      Class<?> returnClass = resolvedReturnType.getRawType();

      if (!mockUtil.isTypeMockable(returnClass)) {
        return Mockito.RETURNS_DEFAULTS.answer(invocation);
      } else {
        Object mock = createSmartDeepMock(resolvedReturnType);
        mocks.put(method, mock);
        return mock;
      }
    };
  }
```
 =||= ",0
617,338,Functional interfaces for Java 8 support in Mockito 2,"Relating to Issue #337 - these are some changes that would allow more usability from Java 8 users. I'd really appreciate feedback on this.

It would make some of my callback use cases easier, and would provide a richer way of expressing assertions for arguments via argThat

One risk introduced by this change is increased use of the type parameter in ArgumentMatcher - this should be a good thing, yet I was left thinking it would surely have been done by someone else if it were easy.","## [Current coverage](https://codecov.io/gh/mockito/mockito/pull/338?src=pr) is **87.19%**

[![Sunburst](https://codecov.io/gh/mockito/mockito/pull/338/graphs/sunburst.svg?size=150&src=pr)](https://codecov.io/gh/mockito/mockito/pull/338?src=pr)

> No coverage report found for **master** at a1de9a5.
> 
> Powered by [Codecov](https://codecov.io?src=pr). Last updated by [a1de9a5...a212819](https://codecov.io/gh/mockito/mockito/compare/a1de9a5e1d38774f2f3e343e60c56e8f000b71ca...a212819ddbef77b895887bb585b25746447b4d49)
 =||= I like this change - how about you guys @bric3 @TimvdLippe ?
 =||= Yes I like it. It does require a rebase though to make sure we have enough coverage. Thanks @ashleyfrieze for spending time on improving Java 8 usability!
 =||= @ashleyfrieze are you available to update this PR with the feedback or should we take it over from here? Thanks for your contribution!
 =||= I should be able to do these code review comments - or at the least have a crack at them - in the next 24 hours or so. Sorry to drop out the loop. Blame a combination of GitHub notifications and google's Inbox for filtering them.
 =||= @ashleyfrieze No problem. Whenever you have time :)
 =||= Mockito2 is intended for version of Java pre-java 8, right?

It would be great to have a module that has some Java 8 examples of the usage of this expressed as unit tests - as per the feedback earlier on - is there a home for that?
 =||= @ashleyfrieze yes it compiles with Java 5. @raphw are you aware of a method to run unit tests on a separate jdk version?
 =||= We could create a module in the build which requires Java 8. Arguably, we could even make it somehow optional for those people still compiling in Java 5... depends on how well the build tool will let us do that. Or I could create a demo project in Java 8 that demonstrates these features and we could put it outside the main build...?
 =||= One potentially larger impact change within this pull request is to the matcher interface, making it completely generic typed - this has raised a question (above) about the removing of an instanceof test (which i'll double check). It may also have an effect on migration/compatibility. Is everyone cool with this part of the change?

```
public boolean matches(Object actual)
```

is now

```
public boolean matches(T actual)
```

Which makes Java8 happier, but is also better than the weird thing that hamcrest was allowing...

We may be able to relax it to allow subclasses of T if that's preferred?
 =||= I'm going to have to rebase this against master for it to work on merge. One issue is that the removal of `InvocationOnMock::<T> T getArgumentAt(int index, Class<T> clazz)` could cause some issues. I'll try it out. It's going to be a few days before I get there.
 =||= Are the stacktrace related changes required for this pull request? I would like to reduce the number of side-effect changes in this pull-request as it is already growing quite rapidly. I have no problem with a separate pull request to discuss these changes, just want to minimize the risk of merging in incorrect changes in an otherwise correct PR.
 =||= They were stopping me from building the code.

I know what you mean.

I could pull them into a separate pull request and then rebase this change over that...?
 =||= Let's leave them in for now, but I would like to see the comments of @bric3 on these change. Are you fine with changing the `StackTraceFilter` functionality?
 =||= Just pushed some unit tests for some matchers - mainly to remove the complaint by the coverage report - but also to verify that my change to the interface has worked.
 =||= @TimvdLippe - please note, it's a refactor, rather than a change in outcome.. The code of the test HAS been changed, the runtime code should have exactly the same behaviour it ever did... though I can't see how that test EVER passed. It's possible that in some configurations that test is not run, or that it has no impact on some JVMs. I'm building on a JDK8.
 =||= Ah okay, if it is backwards compatible then that is fine by me. I thought we were making breaking changes here. Then let's leave the changes here :heart: 
 =||= @TimvdLippe thanks. My fear, as with any noob contributing to an OS project, is that ANY change could surprisingly be a breaking one :)
 =||= I've one thing left to deal with - the JavaDoc for `doAnswer` with the new functional interfaces for composing answers. I can refine that, or I can go a step further and add to `Mockito` things like

```
public static Stubber doAnswer(Answer1 returningAnswerWith1Parameter) {}
public static Stubber doAnswer(VoidAnswer1 voidAnswerWith1Parameter) {}
.
.
.
```

which has been suggested and would make it a lot easier to use.

Can people give me thumbs up or down for whether this is a good thing to do or not. I've made a lot of line changes in the sacred `Mockito` class... dare I go further :)
 =||= One last comment on the `doAnswer`. Other than that I think this PR LGTM. Thank you for your continued effort @ashleyfrieze !
 =||= This looks really good. Let us please merge this soon.

As for writing tests: In Byte Buddy, I added some precompiled class files to the `resource` folder of the project such that they are not compiled during build. For each test I then add a regular test that first checks if the current JVM supports Java 8 or higher and if so, I explicitly run the test using `Class:forName` and then triggering a `Runnable::run` that the Java 8-specific test implements.
 =||= Landed this pull request in https://github.com/mockito/mockito/commit/14617cc9fb43d2ad4b4eb622b4c720367615608a Thank you for your continued effort @ashleyfrieze (and also fixing that nasty test as reported in #435!)
 =||= ",0
619,548,VerificationWithTimeoutTest is unstable,"See build failure: https://travis-ci.org/mockito/mockito/jobs/151406672

Full stack trace:

```
org.mockitousage.verification.VerificationWithTimeoutTest > shouldAllowTimeoutVerificationInOrder FAILED
    org.mockito.exceptions.verification.VerificationInOrderFailure: 
    Verification in order failure
    Wanted but not invoked:
    mock.oneArg('1');
    -> at org.mockitousage.verification.VerificationWithTimeoutTest.shouldAllowTimeoutVerificationInOrder(VerificationWithTimeoutTest.java:161)
    Wanted anywhere AFTER following interaction:
    mock.oneArg('x');
    -> at org.mockitousage.verification.VerificationWithTimeoutTest.shouldAllowTimeoutVerificationInOrder(VerificationWithTimeoutTest.java:155)
```","Refs #433, #446 and #451.
 =||= We may want to look at `VerificationAfterDelayTest` too.

Also see #601

I have some ideas, I'll try them when I have some time.
 =||= ",0
619,601,One test fails probably undeterministically ,"Hey,

Check console output for this build: 
https://travis-ci.org/mockito/mockito/jobs/155443990

It seems that one test from time to time for no apparent reason.

```
org.mockitousage.verification.VerificationWithTimeoutTest > canIgnoreInvocationsWithJunit FAILED
    Wanted but not invoked:
    mock.oneArg('1');
    -> at org.mockitousage.verification.VerificationWithTimeoutTest.canIgnoreInvocationsWithJunit(VerificationWithTimeoutTest.java:147)
    Actually, there were zero interactions with this mock.
        at org.mockito.internal.exceptions.Reporter.wantedButNotInvoked(Reporter.java:329)
        at org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation(MissingInvocationChecker.java:37)
        at org.mockito.internal.verification.Times.verify(Times.java:37)
        at org.mockito.internal.verification.VerificationOverTimeImpl.verify(VerificationOverTimeImpl.java:78)
        at org.mockito.internal.verification.VerificationWrapper.verify(VerificationWrapper.java:15)
        at org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)
        at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:73)
        at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:32)
        at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:36)
        at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:36)
        at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.access$000(MockMethodInterceptor.java:17)
        at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:113)
        at org.mockitousage.IMethods$MockitoMock$1357077317.oneArg(Unknown Source)
        at org.mockitousage.verification.VerificationWithTimeoutTest.canIgnoreInvocationsWithJunit(VerificationWithTimeoutTest.java:147)
```","Well, I looked closely to this test, and it fails for a very good reason.
There is absolutely no guarantee that executor will start and finish method execution on mock in given time duration. (delay value used in test)
That's why from time to time this test will fail, because verification will be 'quicker' than executor. 
 =||= Yes this is a time related test, the only thing we have done now is to augment the timeout.

There's ways to make the test deterministic though via some thread synchronisation, I'm thinking about `CountDownLatch` especially.
 =||= Yet another undeterministic result.

```
org.mockitousage.verification.VerificationAfterDelayTest > shouldReturnListOfArgumentsWithSameSizeAsGivenInAtMostVerification FAILED
    org.mockito.exceptions.base.MockitoAssertionError: Expected that more than 200ms elapsed! But was: 199ms
        at org.mockitoutil.Stopwatch.fail(Stopwatch.java:63)
        at org.mockitoutil.Stopwatch.assertElapsedTimeIsMoreThan(Stopwatch.java:45)
        at org.mockitousage.verification.VerificationAfterDelayTest.shouldReturnListOfArgumentsWithSameSizeAsGivenInAtMostVerification(VerificationAfterDelayTest.java:135)
```
 =||= Duplicates #548
Related issues / PR are #433, #446 and #451
 =||= ",0
622,620,Create and test release checklist,Create and test release checklist. I'm happy to start working on it tomorrow morning.,"Here's updated checklist. Tested as much as I could :)
- [x] pre-release:
  - [x] finish #596
  - [x] create 'release/2.x' branch
  - [x] update version in 'version.properties'
  - [x] delete top of the release notes file so that last stable 1.x is at the top
    - [x] test the release notes generation by './gradlew updateReleaseNotes'
    - [x] update the release notes once again, remove the content added by previous step
  - [x] make some javadoc change (so that the release process does not prevent publication), commit
- [x] release: git push origin release/2.x
- [x] post-release:
  - [x] add [announcement text](https://github.com/mockito/mockito/blob/rc-release-notes-demo/doc/release-notes/official.md) to the top of the release notes (can be done manually via GitHub UI) in the branch
  - [x] take a look at the mockito.org site if it needs some tweaking (release notes link to release notes document in branch, etc.)
  - [x] announce via twitter (the release notes document has one sentence at the top that is twitter-ready 😃). Twitter suggestion: ""Mockito 2: Thank you for writing great tests with us, patience waiting for v2, and kudos to fantastic contributors! https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2""
  - [x] announce on the mailing list
  - [ ] announce on reddit.com/r/java
  - [ ] announce on reddit.com/r/programming
 =||= `release/2.x` ?
 =||= > iterate on the fixes (automated release is unfortunately coupled with ‘master’ branch but it shouldn’t be difficult to fix) until this works

Done. Look at #621 
 =||= 2.x looks kind of funky ;) Is this how people do it? Tim?
On Fri, Sep 2, 2016 at 09:51 Brice Dutheil notifications@github.com wrote:

> release/2.x ?
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/620#issuecomment-244428808,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AABgp5eLzGhGMcYgQ1Yv34TRiqzoUWduks5qmFP0gaJpZM4JzXCo
> .
 =||= There is no golden rule, usually up to the team to decide. I prefer the release/2.x too
 =||= Cool, it's decided then
On Fri, Sep 2, 2016 at 10:16 Tim van der Lippe notifications@github.com
wrote:

> There is no golden rule, usually up to the team to decide. I prefer the
> release/2.x too
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/620#issuecomment-244435014,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AABgp6VbAq8bSs0UmtMWgSnZucFPm-T0ks5qmFnNgaJpZM4JzXCo
> .
 =||= I am going to instantiate this process and checklist
 =||= I have added 2 subreddits to announce to post-release
 =||= Release has been started on Travis: https://travis-ci.org/mockito/mockito/jobs/158990021
 =||= Artifact has been succesfully generated at https://jcenter.bintray.com/org/mockito/mockito-core/2.1.0-RC.1/
 =||= Announced on Twitter and mailing list. We can do Reddit later?
 =||= Why not! I don't think much people read reddit though, in my opinion we should only update channels we maintain and follow.
 =||= You would rather refrain from posting to Reddit? Fine by me, but I do think we have a potential audience there :smile: 
 =||= Not refrain, but the team may not follow this channel, I barely follow the mailing list or SO, I probably won't reddit.
 =||= Ah I see. Personally I read /r/programming so I could maintain/answer questions. Will do it all later though, maybe when we have an official release.

Since the RC has been published I am closing this ticket.
 =||= ",0
622,594,Make the build script aware of the release branch,"Releasing from the `master` branch has advantages developer wise, however when users that are hit by a bug and that `master` has significantly changed we cannot propose a stable enough release (example 2.0 betas releases, even the 1.10.x series had some instabilities API wise).

In order to enable the team and contributors in general to fix issues while still allowing bigger work on the next version I propose the following change in branch and release _process_.
1. Branch out to `release/2.x`
   1. Release `2.0.0`
   2. Patch issue
   3. Release `2.0.1`
   4. Additional work on 2.1
   5. Release `2.1.0`
   6. ...
   7. Forget about `2.1.x`
   8. Critical fixes only get released
2. Upgrade `master` to `3.0.0-beta-<build number>`
   1. Start mockito `3.0.0` progress there (like java 8 only, drop APIs)

Also with recent change in the build script we could now release and check the release version with the branch.

See 
- https://github.com/mockito/mockito/commit/b6a402f16e9222605638efe9b57eccc80a197f9e#diff-33cf41d9669aaef72ca19c641dc57d47R68
- https://github.com/mockito/mockito/issues/586#issuecomment-242076979
- https://github.com/mockito/mockito/pull/483#issuecomment-231323266","@bric3, this is great. Thank you for finally describing the workflow!!!
 =||= ~~I'll try to work on this this week. Yet this ticket is not mandatory for releasing (hence no milestone assignment).~~

EDIT in the end I couldn't find time this week fo this
 =||= The plan makes perfect sense. Let's zoom into implementation details. For example:
1. Create 2 active branches: ""master"" and ""release""
2. Set version.properties in ""master"" to 3.0.0-beta.1, automatically publish per push
3. Set version.properties in ""release"" to 2.1.0-rc.1, automatically publish per push (?)
   a. At some point change version.properties in ""release"" to ""2.1.0"", automatically publish per push

I know that travis can now get version from commit message. How would this work for keeping 2 active branches / publishing RCs?
 =||= If you want to publish a RC for the v2 branch, you checkout that branch, then commit with `Prepare release candidate [ci-release v2.1.0-RC.1]` on that branch and it should be good to go.
 =||= I'd rather go for a branch out model like described in https://github.com/mockito/mockito/issues/594#issue-172969427, so we (and interested parties) can still release a important patch for an old mockito version.
 =||= @szczepiq I'm waiting on the release note of #582 to branch out to `release/2.x`
 =||= That should be working fine right? With the versionproperties separate in each branch (and the manual releases).
 =||= Yes, but not with a single `release` branch.

> 1. Create 2 active branches: ""master"" and ""release""
 =||= Oh sorry, I misread that. Yes we must have a release branch for every major semver version. Reading is hard sometimes :stuck_out_tongue_winking_eye: So +1 for me for @bric3 model, which I also was trying to describe.
 =||= When do we use magic incantation in the commit message and when not?

There is an approach with fully automated releases:
1. Create ""v2"" branch (or something like that), that still publishes Beta.
2. Test it out, so that Beta is neatly released from ""v2"".
3. Change version in ""v2"" into RC, remove top of the release notes, push.
4. Iterate on the fixes, every push creates new RC.
5. At some point, change version to ""2.1.0"", push.
6. Any push to ""v2"" publishes new 2.1.*

For 2 active dev branches (e.g. mockito3 beta in master and v2) we need to split release notes (e.g. notes/v2.md and notes/v3.md). It's not blocking v2 release, we can do it later.

Awesome, I'm getting excited, we'll have RC before JavaOne! :)
 =||= > Any push to ""v2"" publishes new 2.1.*

I would instead have the drone only push betas. E.g. 2.1.1-beta.*.

On Thu, 1 Sep 2016, 07:18 Szczepan Faber, notifications@github.com wrote:

> When do we use magic incantation in the commit message and when not?
> 
> There is an approach with fully automated releases:
> 1. Create ""v2"" branch (or something like that), that still publishes
>    Beta.
> 2. Test it out, so that Beta is neatly released from ""v2"".
> 3. Change version in ""v2"" into RC, remove top of the release notes,
>    push.
> 4. Iterate on the fixes, every push creates new RC.
> 5. At some point, change version to ""2.1.0"", push.
> 6. Any push to ""v2"" publishes new 2.1.*
> 
> For 2 active dev branches (e.g. mockito3 beta in master and v2) we need to
> split release notes (e.g. notes/v2.md and notes/v3.md). It's not blocking
> v2 release, we can do it later.
> 
> Awesome, I'm getting excited, we'll have RC before JavaOne! :)
> 
> —
> You are receiving this because you commented.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/594#issuecomment-243978550,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDbxJRdQ7Q3PHv8p0kxCZveqCVpp9Fks5qlmA6gaJpZM4JsE40
> .
 =||= No more betas please :) Continuous delivery is signature feature of Mockito project.
 =||= While that is true, for every pull request we would release a new patch version. I am not a fan of that. Preferably update less, but more meaningful for the end-user. If you are continuously producing new non-beta artifacts, I think end-users tend to wait with upgrading instead. It's sad that gradle/maven can't import from master instead, but I think we should try to keep our semver versions clean.
 =||= This is an old debate, that we had on the mailing list a couple of years ago.

@szczepiq I know you are an advocate of each commit can be a release, I heard about your talk. This is really nice pushing forward for continuous delivery however I don't agree that every single commit should be released especially on libraries. For some projects it maybe ok, but for some I'd be more conservative.

For example 1.10.x series was nice but felt less stable to many users. Some merged PR introduced the Mockito rule and the API had to be changed. Some incorrect behavior had to be fixed, some were fixed later in the beta. I'm not sure this builds trust in the library.

Also with this big changes cannot fit in your model : should we have released in between PR of the JUnit feature, after all there was enough interesting and working features already. 
For mockito 3 we will target java 8, there's a lot of clean up, maybe some rewriting, doing so we may break things, that happens even with tests, this phase should not be seen as something else than a beta.
 =||= > For 2 active dev branches (e.g. mockito3 beta in master and v2) we need to split release notes (e.g. notes/v2.md and notes/v3.md). It's not blocking v2 release, we can do it later. 

Exactly. Note that 2.x branch should see most activities, but the scope is limited. And after 2.1 we could declare 2.x in_maintainance_ mode.
 =||= I'm happy to rekindle the discussion. If you convince me, I win win because I learn more :)

> Also with this big changes cannot fit in your model

Why cannot the big feature be developed in a branch?

> For example 1.10.x series was nice but felt less stable to many users.

""felt less stable"" - do you have concrete data?

Some thoughts:
- users don't have to upgrade to every version
- we could do minor version bump every month or so, combine the release notes and do bigger announcement

> Some merged PR introduced the Mockito rule and the API had to be changed
> Some incorrect behavior had to be fixed, some were fixed later in the beta.

I'm not convinced that this is a problem of CD. This could happen in the traditional release model, too.

I'm a fan of CD because:
- it forces to care about quality, documentation, compatibility of every PR
- it gives features to users faster
- it provides features incrementally, the smaller the change, the lower chance of regression
- it helps with project maintenance - users test and pick up new versions faster

Let's say that we don't do CD. How would the release look like? You would release once in a while using magic String in commit message?
 =||= @szczepiq I don't say abandon CD, I like the CD, for the reason you mentioned. But let's not make a  release per se, like today maybe label them as `beta` or `build` this builds shows progress and still allows interested users to try mockito current work.

> > Also with this big changes cannot fit in your model
> 
> Why cannot the big feature be developed in a branch?

Yes they can, but sometime those are incomplete or buggy. Like having thread safety, or whatever else. 
And even so when these features land it is just possible to go back on some features, APIs, behaviour that was developed in a previous release.
 =||= > > For example 1.10.x series was nice but felt less stable to many users.
> 
> ""felt less stable"" - do you have concrete data?

Actually this _data_ comes the issue and PR we had at that time, questions asked on SO and from my own colleagues experience. However I don't have those question/gh issues in mind as it's been a long time ago.
 =||= > - users don't have to upgrade to every version

Indeed.

> - we could do minor version bump every month or so, combine the release notes and do bigger announcement

Yeah that works, but with previous point I think this could just be intermediary _preview_ / _milestone_ releases along with other regular beta builds.
 =||= > Yes they can, but sometime those are incomplete or buggy. Like having thread safety, or whatever else.
> And even so when these features land it is just possible to go back on some features, APIs, behaviour that was developed in a previous release.

Let's not push buggy or incomplete features :) The stability problem should be solved by high quality PRs, well designed, documented, and tested.

We can push ""build"" versions, etc. from branch if we see that it's a good idea.

> Actually this data comes the issue and PR we had at that time, questions asked on SO and from my own colleagues experience. However I don't have those question/gh issues in mind as it's been a long time ago.

It seems there aren't concrete datapoints at this time. I'd rather not change the CD strategy, wait for concrete data, re-evaluate as needed.
 =||= In the end I couldn't work on it this week, I'll try next week.
 =||= ",0
623,596,Review and update documentation for 2.1.0,"- [x] update the migration guide (should be easy, there are not many breaking changes, if we miss out we can update in following RC)
- [x] add information about bytebuddy in the migration guide
- [x] mention noteworthy 2.0.0 features (should be easy, there are not many, plus they are already documented :)
- [x] fix odd TODO #593
- [x] review/update @since tags so that they say 2.1.0

Final steps I plan doing (by the EOD Wednesday, tomorrow), in order:
- [x] Test release from release/test (in progress, see Travis CI)
- [x] Merge/cherry-pick changes from ""release/test"" to master
- [x] Move announcement / motivation text (https://github.com/mockito/mockito/blob/rc-release-notes-demo/doc/release-notes/official.md) to top of ""What's new in Mockito 2""
- [x] Final pass over ""What's new in Mockito 2"", make the information exciting and compelling, emphasize use cases, add missing links
- [x] Update the 2.1.0 information in main Mockito class to link to ""What's new in Mockito 2"". See ""TODO 596"" in code
- [x] Review Continuous Delivery [wiki page](https://github.com/mockito/mockito/wiki/Mockito-Continuous-Delivery)
- [x] Update the announcement text (https://github.com/mockito/mockito/blob/rc-release-notes-demo/doc/release-notes/official.md) so that instead of tons of text it just links to ""What's new in Mockito 2""
- [x] Review release checklist (mostly done) - #620
- [x] Optional - Add some info in the 'What's new in Mockito 2' about the next steps for engs (e.g. ask to use the new version and give feedback).","There were separate issues for these points. For example the last point was already fixed by @brice3 in a recent PR
 =||= This list nicely summarizes the incompatible changes: https://github.com/mockito/mockito/issues?utf8=✓&q=label%3A%221.*%20incompatible%22%20
 =||= @bric3 has started the migration guide: https://github.com/mockito/mockito/wiki/What's-new-in-mockito-2
 =||= Migration guide has been updated and I did a small spell check. That LGTM.
 =||= Thanks @TimvdLippe
@raphw @szpak @marcingrzejszczak @szczepiq if you want to add other stuff to this migration guide ?
 =||= Sorry, I won't find time for anything before JavaZone next week is over. Afterwards, I will have a look!
 =||= Given long weekend coming, I can commit to finalize my review / amendments by the end of Wed next week (9/7). Apologies it is not as fast as the crew would like!

Keep in mind that you don't need me to pull the trigger!!!

Guys, we're so close now! It's exciting :)))))
 =||= @raphw No problem. Enjoy JavaZone. Also do some advertisement for mockito 2 ;)
 =||= I've checked out the migration guide and I found it really good. I was missing an example of a default method but I think @TimvdLippe added that.

I haven't done much (to say the least) with regards to this release so I don't have much to write from myself. Like I told @szczepiq and @bric3 I'm overwhelmed with other projects but I'll try to be more active in the upcoming months (don't promise anything though :/ ).

Definitely I can take over testing questions and support if there are some! :)
 =||= I just remembered this, have to add tomorrow: lazy verification.
 =||= Lazy verification mention added: https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2/_compare/e0b49e128f97d703e616c01f0a4893da5295098e...10ba7530dff7a72ef869a16872aca8514c7c8c0a
 =||= Cool. This morning I tidied up a bit the wiki, mostly these two : added side page, improved a lot the home page.
 =||= Really like these changes, looks a lot nicer!

Op wo 31 aug. 2016 om 14:30 schreef Brice Dutheil <notifications@github.com

> :
> 
> Cool. This morning I tidied up a bit the wiki, mostly these two : added
> side page, improved a lot the home page.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/596#issuecomment-243748893,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb1nMLsk4jJe-dlo4-Z7zGUXM9e_Zks5qlXPagaJpZM4JsMzb
> .
 =||= Guys, the ""What's new in Mockito 2"" is fantastic!!! Thanks a lot!
 =||= I like the ""What's new in Mockito 2"". I'm reviewing Mockito main javadoc. I might have some edits to the ""What's new"" wiki, will see :)
 =||= Yep sure ;)
 =||= @szczepiq I think we can close this issue since you reviewed Mockito class :P
 =||= I have some edits, hold on :) I'll finish by tomorrow!
 =||= Ok we ll monitor the check boxes ;)
 =||= @szczepiq Be sure to check out this wiki page as well. https://github.com/mockito/mockito/wiki/Mockito-Continuous-Delivery

And fix or correct issues, I think this could be a starting point if you want to extract the _CDD_
 =||= > Move announcement / motivation text (https://github.com/mockito/mockito/blob/rc-release-notes-demo/doc/release-notes/official.md) to top of ""What's new in Mockito 2""

I would rather not do this since it clutters the content. That wikipage should be only about ""What's new in Mockito 2"", not what is upcoming in Mockito 3.

> Final pass over ""What's new in Mockito 2"", make the information exciting and compelling, emphasize use cases, add missing links

Not sure what you mean with ""exciting and compelling"" but I would rather not change the current text of the features. Let's keep it formal and clear.
 =||= @TimvdLippe migration guide does not mention two BDD enhancements I've developed: #212 and #311. I think it's worth sharing it with the world :)
 =||= @mkordas Yes definitely, I have added them!
 =||= @TimvdLippe thank you!
 =||= > I would rather not do this since it clutters the content. That wikipage should be only about ""What's new in Mockito 2"", not what is upcoming in Mockito 3.

Good feedback. I'll think how to do it best.

> Not sure what you mean with ""exciting and compelling"" but I would rather not change the current text of the features. Let's keep it formal and clear.

By compelling I mean ensuring that every feature describes the 'why' well enough (e.g., ""why should I care about the feature""). Perhaps this requirement is already met. If that's the case, I don't need to make changes :)
 =||= Ah I didn't finish all I wanted :(. I'm pretty happy though. If someone else want's to pick up the work, go for it and pull the trigger :) Otherwise I can pick up the work tomorrow.

@TimvdLippe, I considered your feedback about the 'what's new' page. Eventually, I went ahead and added introduction section. I hope it's ok ;) I added table of contents for people to quickly jump to improvements or incompatibilities. I didn't change much of the original text after all. It's well written. @bric3 , @TimvdLippe GREAT WORK!!!! You contributed not only great code but also great docs. Too many times I see that docs are not emphasized enough in software projects. Docs are part of the product and must be as high quality as code. Thanks for honoring this principle in Mockito.

Damn, I'm proud of this release and you guys!!!!!!!!!! :)))))))))))))))))))))))))))))))))
 =||= The introduction looks good! Glad the wording of the changes remained
fairly the same :)

On Thu, 8 Sep 2016, 06:55 Szczepan Faber, notifications@github.com wrote:

> Ah I didn't finish all I wanted :(. I'm pretty happy though. If someone
> else want's to pick up the work, go for it and pull the trigger :)
> Otherwise I can pick up the work tomorrow.
> 
> @TimvdLippe https://github.com/TimvdLippe, I considered your feedback
> about the 'what's new' page. Eventually, I went ahead and added
> introduction section. I hope it's ok ;) I added table of contents for
> people to quickly jump to improvements or incompatibilities. I didn't
> change much of the original text after all. It's well written. @bric3
> https://github.com/bric3 , @TimvdLippe https://github.com/TimvdLippe
> GREAT WORK!!!! You contributed not only great code but also great docs. Too
> many times I see that docs are not emphasized enough in software projects.
> Docs are part of the product and must be as high quality as code. Thanks
> for honoring this principle in Mockito.
> 
> Damn, I'm proud of this release and you guys!!!!!!!!!!
> :)))))))))))))))))))))))))))))))))
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/596#issuecomment-245493487,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb9MBUfxlvQ7_h2rI6y6cpZQ8a237ks5qn5UlgaJpZM4JsMzb
> .
 =||= Made more progress. I didn't finish on time. My new ETA is weekend :) However, you don't need me to do the release :)
 =||= I'l just wait for #628 to be merged then I'll make this branch `release/2.x`
 =||= Woah, I'm done!

T_H_A_N_K_S for patience and for pushing me & all of us to make progress on the release.
 =||= ",0
627,594,Make the build script aware of the release branch,"Releasing from the `master` branch has advantages developer wise, however when users that are hit by a bug and that `master` has significantly changed we cannot propose a stable enough release (example 2.0 betas releases, even the 1.10.x series had some instabilities API wise).

In order to enable the team and contributors in general to fix issues while still allowing bigger work on the next version I propose the following change in branch and release _process_.
1. Branch out to `release/2.x`
   1. Release `2.0.0`
   2. Patch issue
   3. Release `2.0.1`
   4. Additional work on 2.1
   5. Release `2.1.0`
   6. ...
   7. Forget about `2.1.x`
   8. Critical fixes only get released
2. Upgrade `master` to `3.0.0-beta-<build number>`
   1. Start mockito `3.0.0` progress there (like java 8 only, drop APIs)

Also with recent change in the build script we could now release and check the release version with the branch.

See 
- https://github.com/mockito/mockito/commit/b6a402f16e9222605638efe9b57eccc80a197f9e#diff-33cf41d9669aaef72ca19c641dc57d47R68
- https://github.com/mockito/mockito/issues/586#issuecomment-242076979
- https://github.com/mockito/mockito/pull/483#issuecomment-231323266","@bric3, this is great. Thank you for finally describing the workflow!!!
 =||= ~~I'll try to work on this this week. Yet this ticket is not mandatory for releasing (hence no milestone assignment).~~

EDIT in the end I couldn't find time this week fo this
 =||= The plan makes perfect sense. Let's zoom into implementation details. For example:
1. Create 2 active branches: ""master"" and ""release""
2. Set version.properties in ""master"" to 3.0.0-beta.1, automatically publish per push
3. Set version.properties in ""release"" to 2.1.0-rc.1, automatically publish per push (?)
   a. At some point change version.properties in ""release"" to ""2.1.0"", automatically publish per push

I know that travis can now get version from commit message. How would this work for keeping 2 active branches / publishing RCs?
 =||= If you want to publish a RC for the v2 branch, you checkout that branch, then commit with `Prepare release candidate [ci-release v2.1.0-RC.1]` on that branch and it should be good to go.
 =||= I'd rather go for a branch out model like described in https://github.com/mockito/mockito/issues/594#issue-172969427, so we (and interested parties) can still release a important patch for an old mockito version.
 =||= @szczepiq I'm waiting on the release note of #582 to branch out to `release/2.x`
 =||= That should be working fine right? With the versionproperties separate in each branch (and the manual releases).
 =||= Yes, but not with a single `release` branch.

> 1. Create 2 active branches: ""master"" and ""release""
 =||= Oh sorry, I misread that. Yes we must have a release branch for every major semver version. Reading is hard sometimes :stuck_out_tongue_winking_eye: So +1 for me for @bric3 model, which I also was trying to describe.
 =||= When do we use magic incantation in the commit message and when not?

There is an approach with fully automated releases:
1. Create ""v2"" branch (or something like that), that still publishes Beta.
2. Test it out, so that Beta is neatly released from ""v2"".
3. Change version in ""v2"" into RC, remove top of the release notes, push.
4. Iterate on the fixes, every push creates new RC.
5. At some point, change version to ""2.1.0"", push.
6. Any push to ""v2"" publishes new 2.1.*

For 2 active dev branches (e.g. mockito3 beta in master and v2) we need to split release notes (e.g. notes/v2.md and notes/v3.md). It's not blocking v2 release, we can do it later.

Awesome, I'm getting excited, we'll have RC before JavaOne! :)
 =||= > Any push to ""v2"" publishes new 2.1.*

I would instead have the drone only push betas. E.g. 2.1.1-beta.*.

On Thu, 1 Sep 2016, 07:18 Szczepan Faber, notifications@github.com wrote:

> When do we use magic incantation in the commit message and when not?
> 
> There is an approach with fully automated releases:
> 1. Create ""v2"" branch (or something like that), that still publishes
>    Beta.
> 2. Test it out, so that Beta is neatly released from ""v2"".
> 3. Change version in ""v2"" into RC, remove top of the release notes,
>    push.
> 4. Iterate on the fixes, every push creates new RC.
> 5. At some point, change version to ""2.1.0"", push.
> 6. Any push to ""v2"" publishes new 2.1.*
> 
> For 2 active dev branches (e.g. mockito3 beta in master and v2) we need to
> split release notes (e.g. notes/v2.md and notes/v3.md). It's not blocking
> v2 release, we can do it later.
> 
> Awesome, I'm getting excited, we'll have RC before JavaOne! :)
> 
> —
> You are receiving this because you commented.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/594#issuecomment-243978550,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDbxJRdQ7Q3PHv8p0kxCZveqCVpp9Fks5qlmA6gaJpZM4JsE40
> .
 =||= No more betas please :) Continuous delivery is signature feature of Mockito project.
 =||= While that is true, for every pull request we would release a new patch version. I am not a fan of that. Preferably update less, but more meaningful for the end-user. If you are continuously producing new non-beta artifacts, I think end-users tend to wait with upgrading instead. It's sad that gradle/maven can't import from master instead, but I think we should try to keep our semver versions clean.
 =||= This is an old debate, that we had on the mailing list a couple of years ago.

@szczepiq I know you are an advocate of each commit can be a release, I heard about your talk. This is really nice pushing forward for continuous delivery however I don't agree that every single commit should be released especially on libraries. For some projects it maybe ok, but for some I'd be more conservative.

For example 1.10.x series was nice but felt less stable to many users. Some merged PR introduced the Mockito rule and the API had to be changed. Some incorrect behavior had to be fixed, some were fixed later in the beta. I'm not sure this builds trust in the library.

Also with this big changes cannot fit in your model : should we have released in between PR of the JUnit feature, after all there was enough interesting and working features already. 
For mockito 3 we will target java 8, there's a lot of clean up, maybe some rewriting, doing so we may break things, that happens even with tests, this phase should not be seen as something else than a beta.
 =||= > For 2 active dev branches (e.g. mockito3 beta in master and v2) we need to split release notes (e.g. notes/v2.md and notes/v3.md). It's not blocking v2 release, we can do it later. 

Exactly. Note that 2.x branch should see most activities, but the scope is limited. And after 2.1 we could declare 2.x in_maintainance_ mode.
 =||= I'm happy to rekindle the discussion. If you convince me, I win win because I learn more :)

> Also with this big changes cannot fit in your model

Why cannot the big feature be developed in a branch?

> For example 1.10.x series was nice but felt less stable to many users.

""felt less stable"" - do you have concrete data?

Some thoughts:
- users don't have to upgrade to every version
- we could do minor version bump every month or so, combine the release notes and do bigger announcement

> Some merged PR introduced the Mockito rule and the API had to be changed
> Some incorrect behavior had to be fixed, some were fixed later in the beta.

I'm not convinced that this is a problem of CD. This could happen in the traditional release model, too.

I'm a fan of CD because:
- it forces to care about quality, documentation, compatibility of every PR
- it gives features to users faster
- it provides features incrementally, the smaller the change, the lower chance of regression
- it helps with project maintenance - users test and pick up new versions faster

Let's say that we don't do CD. How would the release look like? You would release once in a while using magic String in commit message?
 =||= @szczepiq I don't say abandon CD, I like the CD, for the reason you mentioned. But let's not make a  release per se, like today maybe label them as `beta` or `build` this builds shows progress and still allows interested users to try mockito current work.

> > Also with this big changes cannot fit in your model
> 
> Why cannot the big feature be developed in a branch?

Yes they can, but sometime those are incomplete or buggy. Like having thread safety, or whatever else. 
And even so when these features land it is just possible to go back on some features, APIs, behaviour that was developed in a previous release.
 =||= > > For example 1.10.x series was nice but felt less stable to many users.
> 
> ""felt less stable"" - do you have concrete data?

Actually this _data_ comes the issue and PR we had at that time, questions asked on SO and from my own colleagues experience. However I don't have those question/gh issues in mind as it's been a long time ago.
 =||= > - users don't have to upgrade to every version

Indeed.

> - we could do minor version bump every month or so, combine the release notes and do bigger announcement

Yeah that works, but with previous point I think this could just be intermediary _preview_ / _milestone_ releases along with other regular beta builds.
 =||= > Yes they can, but sometime those are incomplete or buggy. Like having thread safety, or whatever else.
> And even so when these features land it is just possible to go back on some features, APIs, behaviour that was developed in a previous release.

Let's not push buggy or incomplete features :) The stability problem should be solved by high quality PRs, well designed, documented, and tested.

We can push ""build"" versions, etc. from branch if we see that it's a good idea.

> Actually this data comes the issue and PR we had at that time, questions asked on SO and from my own colleagues experience. However I don't have those question/gh issues in mind as it's been a long time ago.

It seems there aren't concrete datapoints at this time. I'd rather not change the CD strategy, wait for concrete data, re-evaluate as needed.
 =||= In the end I couldn't work on it this week, I'll try next week.
 =||= ",0
630,629,Javadoc CSS width issue,"There is some minor problem with element width (CSS) on javadoc site.
Some elements are too wide and are causing horizontal scroll bar to show up.

I post picture to show what is going on.

https://s9.postimg.io/xlbg2e0ul/mockito_javadoc.png","I don't had the problem when I tested the css the problem but that depend on the browser. 

If you know how to fix it that would be awesome!
 =||= Just saw the PR thanks!
 =||= Probably after this change there will be still horizontal scroll-bar because I saw some other elements longer then 100% (with padding, margins and borders) . Even if they are - they will not be as significant as ones solved in PR.
 =||= ",0
635,439,ArgumentCaptor and ArgumentMatcher can't be mixed in varargs,"In the given test below the ArgumentCaptor should captor only the char 'c':

```
    @Captor
    private ArgumentCaptor<Character> argumentCaptor;

    @Test
    public void capturesVararg() throws Exception {
        mock.varargs(42, 'c');

        verify(mock).varargs(eq(42), argumentCaptor.capture());

       assertThat(argumentCaptor.getAllValues()).containsExactly('c');
    }
```

The test fails with this message:

```
Actual and expected should have same size but actual size was:
  <2>
while expected size was:
  <1>
Actual was:
  <[42, 'c']>
Expected was:
  <['c']>
```

Note that we see here 2 bugs:
- a wrong argument index was captored
- an `int`was captored by an  `ArgumentCaptor<Character>` -> #565","Yes `ArgumentCaptor` was not designed to be type aware. Though I like API with the least surprises, it should be fixed.

Thanks for reporting.
 =||= Note to my self: here is the solution [Gist ](https://gist.github.com/ChristianSchwarz/d755aa54e3637b0bd5f76bde3b882605)
 =||= This improvement makes Mockito easier to use and more intuitive. That's exactly the direction we should take Mockito. Thanks!!!
 =||= ",0
635,583,ArgumentCaptor: NPE when an null array is passed to a varargs method,"A NullPointerException is thrown if an null array is passed to a varargs method.

```
@Test
public void shouldCaptureVarArgs_nullArrayArg() {
        String[] argArray = null;
        mock.varargs(argArray);

        verify(mock).varargs(captor.capture()); //<- Kaboom NPE
}
```

Since an vararg is simply an array the ArgumentCaptor should reject it silently. This relates to #565.

```
java.lang.NullPointerException
    at java.lang.reflect.Array.getLength(Native Method)
    at org.mockito.internal.invocation.InvocationMatcher.captureVarargsPart(InvocationMatcher.java:142)
    at org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:122)
    at org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:24)
    at org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:18)
    at org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(NumberOfInvocationsChecker.java:43)
    at org.mockito.internal.verification.Times.verify(Times.java:40)
    at org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)
    at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:73)
    at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:32)
    at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)
    at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:36)
    at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.access$0(MockMethodInterceptor.java:32)
    at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:113)
    at org.mockitousage.IMethods$MockitoMock$81506210.varargs(Unknown Source)
    at org.mockitousage.matchers.VarargsTest.shouldCaptureVarArgs_nullArrayArg(VarargsTest.java:182)
```","Probably related to #567
 =||= ",0
637,521,Remove com.sun.* references,"Currently build with gradle 3.0-milestone-2 fails with:

```
:buildSrc:compileJava/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:4: error: package com.sun.tools.doclets.formats.html does not exist
import com.sun.tools.doclets.formats.html.HtmlDoclet;
                                         ^
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:20: error: cannot find symbol
        return HtmlDoclet.optionLength(var0);
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:25: error: cannot find symbol
        return HtmlDoclet.start((RootDoc) Proxy.newProxyInstance(clz.getClassLoader(), clz.getInterfaces(), new ExcludeHandler(root)));
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:29: error: cannot find symbol
        return HtmlDoclet.validOptions(var0, var1);
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:33: error: cannot find symbol
        return HtmlDoclet.languageVersion();
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
Note: /mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
5 errors
 FAILED
```

Related to #520.","This doclet is required to skip generating Javadoc for internal classes. Is there a mention in the Java 9 jdk of this breaking change?
 =||= This seems the corresponding JIRA ticket: https://bugs.openjdk.java.net/browse/JDK-8154399
 =||= I'm on a mobile device so couldn't check much, but the ticket mention a replacement for `com.sun....Standard` with the rewritten javadoc tool (`jdk.javadoc.doclets.StandardDoclet`) I didn't saw yet the `HtmlDocklet` yet it should be there as well.
 =||= I will be taking a stab at this tomorrow after switching to Java 8.
 =||= I think we have to (in jdk9) to move to `StandardDoclet`: http://hg.openjdk.java.net/jdk9/dev/langtools/file/6077dc32728a/src/jdk.javadoc/share/classes/jdk/javadoc/doclets/StandardDoclet.java However, this class does not exist in jdk8 so I am not sure what our options are.
 =||= I think we could have both doclet in [javadoc.gradle](https://www.theguardian.com/lifeandstyle/2016/apr/29/how-to-have-a-great-conversation-with-someone-who-is-going-to-die)

``` java
if (JavaVersion.current().isJava9Compatible()) {
    options.doclet ""org.mockito.javadoc.Java9JavadocExclude""
} else {
    options.doclet ""org.mockito.javadoc.JavadocExclude""
}
```

[Gradle 3 `JavaVersion` javadoc](https://docs.gradle.org/current/javadoc/org/gradle/api/JavaVersion.html)
 =||= @bric3 Yes that was what I implemented at https://github.com/mockito/mockito/pull/639/files#diff-39cbd22b5198600bd49c364c42e0aaa9R17 :)
 =||= Has been fixed in several PRs and the doclet was later removed. =||= ",0
637,561,Update Gradle to 3.0,Gradle 3.0 is released so we can look into upgrading. Potentially we can rewrite our scripts into Kotlin.,"After we branch out `release/2.x` ;)
 =||= Kotlin? We need to discuss it before ;)
 =||= Yes we can discuss it in this issue. I have not looked into Kotlin at all so have no opinion atm. You do?
 =||= There are some limitations in Kotlin scripts. It is highlighted also in the [release notes](https://docs.gradle.org/3.0/release-notes):

> ... we are working intensely to make Gradle Script Kotlin fully production ready by the end of the year ...

In addition we have quite extensive build logic written in Groovy and I don't know it is worth to rewrite it just to have nicer code completion in Idea for those not very often times where there is something to change.
 =||= Seem decent arguments to not switch to Kotlin yet :+1: 
 =||= However gradle 3.0 still allows groovy, so that's not a blocker to switch
 =||= And should ""always"" will:

> Groovy is still the primary build language for Gradle scripts and will **always** be supported
 =||= +1 to keeping groovy build scripts :)
 =||= We cannot do it right now because Gradle 3.0 does not build with java6 and current release is still for java6 :( Let's close and revisit later. We won't forget to bump Gradle :)
 =||= We will switch from Java 6 soon and this issue has not been resolved yet. Therefore reopening to be tracked in waffle.
 =||= ",0
637,521,Remove com.sun.* references,"Currently build with gradle 3.0-milestone-2 fails with:

```
:buildSrc:compileJava/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:4: error: package com.sun.tools.doclets.formats.html does not exist
import com.sun.tools.doclets.formats.html.HtmlDoclet;
                                         ^
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:20: error: cannot find symbol
        return HtmlDoclet.optionLength(var0);
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:25: error: cannot find symbol
        return HtmlDoclet.start((RootDoc) Proxy.newProxyInstance(clz.getClassLoader(), clz.getInterfaces(), new ExcludeHandler(root)));
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:29: error: cannot find symbol
        return HtmlDoclet.validOptions(var0, var1);
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:33: error: cannot find symbol
        return HtmlDoclet.languageVersion();
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
Note: /mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
5 errors
 FAILED
```

Related to #520.","This doclet is required to skip generating Javadoc for internal classes. Is there a mention in the Java 9 jdk of this breaking change?
 =||= This seems the corresponding JIRA ticket: https://bugs.openjdk.java.net/browse/JDK-8154399
 =||= I'm on a mobile device so couldn't check much, but the ticket mention a replacement for `com.sun....Standard` with the rewritten javadoc tool (`jdk.javadoc.doclets.StandardDoclet`) I didn't saw yet the `HtmlDocklet` yet it should be there as well.
 =||= I will be taking a stab at this tomorrow after switching to Java 8.
 =||= I think we have to (in jdk9) to move to `StandardDoclet`: http://hg.openjdk.java.net/jdk9/dev/langtools/file/6077dc32728a/src/jdk.javadoc/share/classes/jdk/javadoc/doclets/StandardDoclet.java However, this class does not exist in jdk8 so I am not sure what our options are.
 =||= I think we could have both doclet in [javadoc.gradle](https://www.theguardian.com/lifeandstyle/2016/apr/29/how-to-have-a-great-conversation-with-someone-who-is-going-to-die)

``` java
if (JavaVersion.current().isJava9Compatible()) {
    options.doclet ""org.mockito.javadoc.Java9JavadocExclude""
} else {
    options.doclet ""org.mockito.javadoc.JavadocExclude""
}
```

[Gradle 3 `JavaVersion` javadoc](https://docs.gradle.org/current/javadoc/org/gradle/api/JavaVersion.html)
 =||= @bric3 Yes that was what I implemented at https://github.com/mockito/mockito/pull/639/files#diff-39cbd22b5198600bd49c364c42e0aaa9R17 :)
 =||= Has been fixed in several PRs and the doclet was later removed. =||= ",0
639,520,Provide Java 9 compatibility,"Once having Mockito 2.0 out the door it would be good to explore Java 9 compatibility.

Basic todo list:
- [x] - migration to Gradle 3.0 (2.x doesn't support Java 9)
- [x] - Travis build with Java 9
- [x] - successful Mockito project build with Java 9
- [x] - fix all disabled tests when the new ASM version is available - #863

Open Java 9 related [issues](https://github.com/mockito/mockito/issues?q=is%3Aissue+is%3Aopen+label%3Ajava-9).","I agree with that however note that mockito 2.1 should still be Java 5 compatible (we still build Java 5 binaries with Java 6).
Before that we need to branch mockito 2.x to support old JDKs and make mockito 3 Java 8 min.
 =||= > we still build Java 5 binaries with Java 6

I'm afraid we are [not](https://github.com/mockito/mockito/blob/master/build.gradle#L14-L15):

```
sourceCompatibility = 1.6
targetCompatibility = 1.6
```

If Java 5 is in fact a target of Mockito 2.0 I could add Animal sniffer verification that we don't use Java 6 API in the code.

We would probably need to decide if 2.1 is just for things that were able to finish before 2.0-final (and important bugfixes) or there are plans to keep a serious development of 2.x line after 2.1 (with backporting non Java 8 specific changes from 3.x branch).
 =||= Damn I didn't see this change. I'm on my phone.

However that's fine for me.
 =||= Maybe something to mention in the migration guide though.
 =||= Otherwise for  2.1 I think we will only include few API refactoring like `ArgumentCaptor`. And bugfixes otherwise it will delay serious work on mockito 3.
Also I don't want to backport java 8 code to mockito 2.
My idea is to have a `2.x` branch, we can adjust the build script to release on this branch too.
 =||= Just for information, the parts Mockito uses of Byte Buddy are already fully Java 9 compatible. I do not see any problems on migration.
 =||= I think this is ready now? =||= ASM 6 is still in alpha: http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.ow2.asm%22%20AND%20a%3A%22asm%22 =||= Really don't focus too much on Java 9 it's still months away.  =||= For your information, logback uses Mockito version 1.10.19 which is apparently not Java 9 compatible. It follows that logback build fails under Java 9.  =||= Mockito 2 is Java 9 compatible. =||= Great. Thank you. =||= Running on version 1.9.5 with Jigsaw b162 with --permit-illegal-access.

I'm seeing the following warning.  
WARNING: Illegal access by org.mockito.cglib.core.ReflectUtils$2 (file:gradle_cache/caches/modules-2/files-2.1/org.mockito/mockito-all/1.9.5/79a8984096fc6591c1e3690e07d41be506356fa5/mockito-all-1.9.5.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) 

Maybe related:
WARNING: Illegal access by net.sf.cglib.core.ReflectUtils$1 (file:gradle_cache/caches/modules-2/files-2.1/cglib/cglib-nodep/3.2.4/42c972dee25a436b32c6027e848287ff47ed6750/cglib-nodep-3.2.4.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) 

Is this fixed in 2.x?  Or is there handling if this call fails?

 =||= It might be fixed with Mockito 2 yes, as we are not using CGLib anymore. No promises though 😉  =||= I confirmed that the org.mockito.cglib.core.ReflectUtils is gone in 2.x and mockito no longer depends on net.sf.cglib.core.
 =||= Byte Buddy 1.7.2 now supports Java 9 class files. =||= >Byte Buddy 1.7.2 now supports Java 9 class files.

Should we just bump bytebuddy to the latest version? Cheers! =||= Closing as at last #863 has been fixed as well. Java 9 woohoo 🎉  =||= ",0
646,640,Improve exception message to hint at upgrading java minor version to latest,Driven by #636,"Can be closed...
 =||= ",0
651,650,Update AssertJ to 3,"Since AssertJ 3 relies on Java 8, we can now update on master. It seems that there are very few breaking changes so hopefully this should not be a big hassle.",nan,0
654,653,Typos in FailureDetecter,`FailureDetecter` should be `FailureDetector`. Its method `isSussessful()` should probably be `isSuccessful()`.,"PR? :)
 =||= Check. See #654.
 =||= ",0
670,669,Publish mockito artifacts to 'mockito' organization in Bintray,"Instead of publishing to 'szczepiq' user, the artifacts should be published to 'mockito' organization in Bintray.","In progress. I transferred ownership of ""szczepiq/maven"" repository to the ""mockito"" org. It takes forever to complete in Bintray UI api. Keeping thumbs up ;)

I spent 1.5 hours poking around oss nexus and bintray. Too long to get stuff done.
 =||= Things that matter can take time ;)
 =||= Reopening because it is not merged yet to the main branch (this also make it appear in release notes twice as PR and as an issue).
 =||= Let's close it. We will merge all from release branch -> master anyway.
 =||= ",0
709,692,Host javadocs at javadoc.io,"javadoc.io offers free hosting of javadoc, see: http://www.javadoc.io/doc/org.mockito/mockito-core/2.2.0

It's completely free - no effort is needed from our end - they get javadoc from central.

Using this service, we could simplify our release pipeline and avoid growing mockito git repo with every release (javadocs are checked-in). Downside is that there is some delay in showing the docs and it's another 3rd party integration.

Currently, our release pipeline for javadoc does not fully support 2 concurrent dev branches. Releasing 3.x experimental version will replace the 'current' permalink for javadocs. I'm not very keen on spending effort on fixing that if we can get javadocs for free from an external service.

Thoughts?","I agree that's a good idea and that will simplify the build script too.

EDIT: Our gh-pages contains javadoc only. Mayeb we could remove the branch that will lighten the repository (at broken link expense, though the javadoc is available elsewhere)
 =||= How is removing the branch lighten the repo given the repo contains all history?

We could keep the latest 1.x release, 2.x releases for the time being.
 =||= > How is removing the branch lighten the repo given the repo contains all history?
> We could keep the latest 1.x release, 2.x releases for the time being.

That's the thing : if we remove the `gh-pages` reference, I believe that git will eventually perform a gc and then remove the unreachable commits history. However if we keep `gh-pages` indeed this GC won't happen.
 =||= Cool
 =||= I'm exploring 2 options now:
- move to javadoc.io, nice service, but
  - there is a delay in showing docs after release
  - no way to link to specific class of latest release - sent an email to javadoc.io with question
- move javadoc to separate repo under 'mockito' project
 =||= Updated site links and README.md links. I need to go over the wikis and update links there. After that, we can build a plan for getting rid of the html from the repo and make the repo smaller. Thanks for getting into the conversation with javadoc.io!!!
 =||= I think we can close this one?
 =||= yes
 =||= Shall we remove gh-pages branch ?
 =||= Yes lets remove that
 =||= Note it may break current links (https://www.google.fr/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=mockito%20javadoc)
 =||= I thought about that after posting my comment. Maybe we let it redirect to javadoc.io?
 =||= Is it even possible with github pages ?
 =||= Redirect should be possible. I'd recommend holding off removing gh-pages for now.
 =||= Let's close this one and track more work here: #753
 =||= Agreed
 =||= ",0
711,707,Improve usability of arity Answers with regards to checked exceptions,"Recently introduced Answer1 style answers don't declare Throwable. They should! Otherwise the user is forced to add boilerplate code to AnswerX implementations, whenever they use methods that declare checked exceptions. Plus, AnswerX should behave exactly as good old Answer interface!

Reported via the [mailing-list](https://groups.google.com/d/msgid/mockito/82d08ba9-5536-495e-90db-78c1062b6400%40googlegroups.com)","Given how Answer is supposed to be used it is a safe change to do. Plus, it is marked as @Incubating :)
 =||= ",0
745,665,Use package-info.java instead of the old html file,"`package-info.java` can be annotated, and reflection can be used, this may be useful at some point, or not.",nan,0
746,727,Copyright notice missing on files,Let's add automation that will make consistent copyright notice on all source files.,"If nobody's working on it I can send you a PR.
 =||= @DmitriyZaitsev Looking forward to it 😄 
 =||= ",0
763,762,Public javadoc offers links to internal classes,"In few places in public javadoc we offer links to internal classes. Instead, we should document the public API without links to private classes. How to find offenders? Generate javadoc and look for:

- \<code\>ReturnsEmptyValues
- \<code\>org.mockito.internal",nan,0
771,731,Consider rerunning failed tests,"Consider rerunning failed tests to avoid https://travis-ci.org/mockito/mockito/jobs/172673452

Some options:
 - rerun test Gradle task
 - rerun test rule http://stackoverflow.com/questions/8295100/how-to-re-run-failed-junit-tests-immediately","-1 for rerunning, the test should be fixed see #704
 =||= Agreed with @ChristianSchwarz we should fix the test instead, this test has a behavior difficult to test both locally and in a container, previous approach with `CountDownLatch` in #619 worked but was imperfect and still broke under the constrained Travis environment. @ChristianSchwarz approach is different but proved to be working more consistently.

For reference the original issue is #548 
 =||= It's classic craftsmanship VS pragmatism.

I hate re-running builds and tests. However, I am pragmatic and I hate wasting time even more :)
 =||= @szczepiq 
#704 has landed, this ticked can be closed

> It's classic craftsmanship VS pragmatism.

[..] VS ""recklessness""  :grimacing:

Image there is a rare race condition in the code under test. Possibly the race condition will not appear in a future run, who to detect the bug this way?  
 =||= Closing per #704
 =||= Thank you guys for attempting to fix the verification with timeout test! It still seem to fail: https://travis-ci.org/mockito/mockito/jobs/174991791 (I merged from release/2.x so it contained @ChristianSchwarz fix).

> Image there is a rare race condition in the code under test. Possibly the race condition will not appear in a future run, who to detect the bug this way?

Rerun does not have to be dumb, it can only allow to rerun tests that we know that are flaky (and need fixing or accepting their imperfection).
 =||= https://travis-ci.org/mockito/mockito/jobs/175262785
 =||= Agreed there's still not so rare build failures, I had to restart the job 177057772 manually. I've been seeng this just as often since #704 merge.

<details><summary>

job logs</summary>



```
Worker information
hostname: travis-worker-gce-org-prod2-4:4d952407-384a-4d90-a194-6a04d5b5e251
version: v2.5.0 https://github.com/travis-ci/worker/tree/da3a43228dffc0fcca5a46569ca786b22991979f
instance: testing-gce-e550a994-d659-4a46-bccf-eed57dafea15:travis-ci-jvm-precise-1471814223
startup: 21.62330554s
Build system information
Build language: java
Build group: stable
Build dist: precise
Build id: 177057771
Job id: 177057772
travis-build version: 0d606872a
Build image provisioning date and time
Sun Aug 21 21:33:22 UTC 2016
Operating System Details
Distributor ID: Ubuntu
Description:    Ubuntu 12.04.5 LTS
Release:    12.04
Codename:   precise
Linux Version
3.13.0-92-generic
Cookbooks Version
f77e708 https://github.com/travis-ci/travis-cookbooks/tree/f77e708
Git version
git version 1.8.5.6
bash version
GNU bash, version 4.2.25(1)-release (x86_64-pc-linux-gnu)
Copyright (C) 2011 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>

This is free software; you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
GCC version
gcc (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

LLVM version
clang version 3.4 (tags/RELEASE_34/final)
Target: x86_64-unknown-linux-gnu
Thread model: posix
Pre-installed Ruby versions
ruby-2.2.5
Pre-installed Node.js versions
v0.10.36
Pre-installed Go versions
1.4.2
mysql --version
mysql  Ver 14.14 Distrib 5.5.50, for debian-linux-gnu (x86_64) using readline 6.2
Pre-installed PostgreSQL versions
9.1.23
9.2.18
9.3.14
9.4.9
Redis version
redis-server 3.0.6
riak version
2.0.2
memcached version
1.4.13
MongoDB version
MongoDB 2.4.14
CouchDB version
couchdb 1.6.1
Neo4j version
1.9.4
Cassandra version
2.0.9
ElasticSearch version
1.4.0
Installed Sphinx versions
2.0.10
2.1.9
2.2.6
Default Sphinx version
2.2.6
Installed Firefox version
firefox 38.4.0esr
PhantomJS version
1.9.8
ant -version
Apache Ant(TM) version 1.8.2 compiled on December 3 2011
mvn -version
Apache Maven 3.2.5 (12a6b3acb947671f09b81f49094c53f426d8cea1; 2014-12-14T17:29:23+00:00)
Maven home: /usr/local/maven
Java version: 1.7.0_80, vendor: Oracle Corporation
Java home: /usr/lib/jvm/java-7-oracle/jre
Default locale: en, platform encoding: UTF-8
OS name: ""linux"", version: ""3.13.0-92-generic"", arch: ""amd64"", family: ""unix""
gradle -version

------------------------------------------------------------
Gradle 2.2.1
------------------------------------------------------------

Build time:   2014-11-24 09:45:35 UTC
Build number: none
Revision:     6fcb59c06f43a4e6b1bcb401f7686a8601a1fb4a

Groovy:       2.3.6
Ant:          Apache Ant(TM) version 1.9.3 compiled on December 23 2013
JVM:          1.7.0_80 (Oracle Corporation 24.80-b11)
OS:           Linux 3.13.0-92-generic amd64

lein1 version
WARNING: You're currently running as root; probably by accident.
Press control-C to abort or Enter to continue as root.
Set LEIN_ROOT to disable this warning.
WARNING: You're currently running as root; probably by accident.
Press control-C to abort or Enter to continue as root.
Set LEIN_ROOT to disable this warning.
Downloading Leiningen now...
Using JLine for console I/O; install rlwrap for optimum experience.
Leiningen 1.7.1 on Java 1.7.0_80 Java HotSpot(TM) 64-Bit Server VM
lein2 version
WARNING: You're currently running as root; probably by accident.
Press control-C to abort or Enter to continue as root.
Set LEIN_ROOT to disable this warning.
Downloading Leiningen to /home/travis/.lein/self-installs/home/travis/.lein/leiningen-2.5.1-standalone.jar now...
Leiningen 2.5.1 on Java 1.7.0_80 Java HotSpot(TM) 64-Bit Server VM
lein version
WARNING: You're currently running as root; probably by accident.
Press control-C to abort or Enter to continue as root.
Set LEIN_ROOT to disable this warning.
Downloading Leiningen to /home/travis/.lein/self-installs/home/travis/.lein/leiningen-2.5.1-standalone.jar now...
Leiningen 2.5.1 on Java 1.7.0_80 Java HotSpot(TM) 64-Bit Server VM

$ export DEBIAN_FRONTEND=noninteractive
Reading package lists...
Building dependency tree...
Reading state information...
libc6 is already the newest version.
0 upgraded, 0 newly installed, 0 to remove and 102 not upgraded.
$ git clone --depth=50 --branch=remove-internal-javadoc-links https://github.com/mockito/mockito.git mockito/mockito
Cloning into 'mockito/mockito'...
remote: Counting objects: 3100, done.
remote: Compressing objects: 100% (1762/1762), done.
remote: Total 3100 (delta 1276), reused 2086 (delta 919), pack-reused 0
Receiving objects: 100% (3100/3100), 1.17 MiB | 0 bytes/s, done.
Resolving deltas: 100% (1276/1276), done.
Checking connectivity... done.

$ cd mockito/mockito
$ git checkout -qf 7a4bee38654b052361153cadc1dda5ede068d0ff
Set hostname to mockito-cd
$ sudo hostname mockito-cd

## Managed by Chef on packer-57ba1a4f-8735-ef55-49ff-0a97bf85bb9d.c.eco-emissary-99515.internal :heart_eyes_cat:
## cookbook:: travis_build_environment
##     file:: templates/default/etc/cloud/templates/hosts.tmpl.erb

127.0.1.1 testing-gce-e550a994-d659-4a46-bccf-eed57dafea15 testing-gce-e550a994-d659-4a46-bccf-eed57dafea15 ip4-loopback precise64

sudo: unable to resolve host mockito-cd

## Managed by Chef on packer-57ba1a4f-8735-ef55-49ff-0a97bf85bb9d.c.eco-emissary-99515.internal :heart_eyes_cat:
## cookbook:: travis_build_environment
##     file:: templates/default/etc/cloud/templates/hosts.tmpl.erb

127.0.1.1 testing-gce-e550a994-d659-4a46-bccf-eed57dafea15 testing-gce-e550a994-d659-4a46-bccf-eed57dafea15 ip4-loopback precise64


Setting environment variables from repository settings
$ export NEXUS_TOKEN_USER=[secure]
$ export NEXUS_TOKEN_PWD=[secure]
$ export GH_TOKEN=[secure]
$ export MOCKITO_BINTRAY_API_KEY=[secure]
$ export TEST_ENV_VAR=[secure]

Setting environment variables from .travis.yml
$ export TERM=dumb
$ export GRADLE_OPTS=""-XX:+UseCompressedOops -Djava.awt.headless=true""

$ jdk_switcher use openjdk6
Switching to OpenJDK6 (java-1.6.0-openjdk-amd64), JAVA_HOME will be set to /usr/lib/jvm/java-6-openjdk-amd64
$ export TERM=dumb
Setting up build cache
$ export CASHER_DIR=$HOME/.casher
$ Installing caching utilities


attempting to download cache archive
fetching remove-internal-javadoc-links/cache-linux-precise-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855--jdk-openjdk6.tgz
found cache


adding /home/travis/.gradle/caches to cache
adding /home/travis/.gradle/wrapper to cache

$ java -Xmx32m -version
java version ""1.6.0_39""
OpenJDK Runtime Environment (IcedTea6 1.13.11) (6b39-1.13.11-0ubuntu0.12.04.1)
OpenJDK 64-Bit Server VM (build 23.25-b01, mixed mode)
$ javac -J-Xmx32m -version
javac 1.6.0_39
$ export TRAVIS_COMMIT_MESSAGE=$(git log --format=%B -n 1 $TRAVIS_COMMIT)

$ echo ""$TRAVIS_COMMIT_MESSAGE""
Disables the testng javadoc task

This task is not configured and shows errors and warning.
Also the test-ng project is not released yet.

$ true

$ ./gradlew ciBuild release -Dscan
Starting a new Gradle Daemon for this build (subsequent builds will be faster).
Support for running Gradle using Java 6 has been deprecated and will be removed in Gradle 3.0
Parallel execution is an incubating feature.
:buildSrc:clean UP-TO-DATE
:buildSrc:compileJava UP-TO-DATE
:buildSrc:compileGroovy UP-TO-DATE
:buildSrc:processResources UP-TO-DATE
:buildSrc:classes UP-TO-DATE
:buildSrc:jar
:buildSrc:assemble
:buildSrc:compileTestJava UP-TO-DATE
:buildSrc:compileTestGroovy UP-TO-DATE
:buildSrc:processTestResources UP-TO-DATE
:buildSrc:testClasses UP-TO-DATE
:buildSrc:test UP-TO-DATE
:buildSrc:check UP-TO-DATE
:buildSrc:build
Version: 2.2.20
:compileJava
:extTest:compileJava UP-TO-DATE
:extTest:processResources UP-TO-DATE
:extTest:classes UP-TO-DATE
:extTest:jar
:extTest:assemble
:extTest:processTestResources
:testng:processResources UP-TO-DATE
:testng:processTestResources
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:testng:compileJava
:testng:classes
:testng:jar
:testng:sourcesJar
:testng:assemble
:testng:compileTestJava
:testng:testClasses
:testng:test
:testng:check
:testng:build
Installing sw-precache globally
:javadocJar
:sourcesJar
:assemble
:licenseMain
Unknown file extension: src/main/java/org/mockito/internal/util/concurrent/LICENSE
Unknown file extension: src/main/java/org/mockito/internal/util/concurrent/README.md
:licenseMain UP-TO-DATE
:licenseTest
Missing header in: src/test/java/org/mockitousage/CompilationWarningsTest.java
Missing header in: src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java
Missing header in: src/test/java/org/mockitousage/junitrunner/SilentRunnerTest.java
Missing header in: src/test/java/org/mockitousage/junitrunner/UnusedStubsExceptionMessageTest.java
Missing header in: src/test/java/org/mockitousage/junitrunner/StrictRunnerTest.java
Missing header in: src/test/java/org/mockitousage/verification/DelayedExecution.java
Missing header in: src/test/java/org/mockitousage/junitrule/StubbingWarningsMultiThreadingTest.java
Missing header in: src/test/java/org/mockitousage/junitrule/StubbingWarningsJUnitRuleTest.java
Missing header in: src/test/java/org/mockitousage/junitrule/SilentJUnitRuleTest.java
Missing header in: src/test/java/org/mockitousage/junitrule/RuleTestWithParameterConstructorTest.java
Missing header in: src/test/java/org/mockitousage/junitrule/VerificationCollectorImplTest.java
Missing header in: src/test/java/org/mockitousage/junitrule/RuleTestWithFactoryMethodTest.java
Missing header in: src/test/java/org/mockitousage/junitrule/MockitoJUnitRuleTest.java
Missing header in: src/test/java/org/mockitousage/debugging/InvocationsPrinterTest.java
Missing header in: src/test/java/org/mockitousage/junitrule/InvalidTargetMockitoJUnitRuleTest.java
Missing header in: src/test/java/org/mockitousage/internal/junit/UnusedStubbingsFinderTest.java
Missing header in: src/test/java/org/mockitousage/bugs/DiamondInheritanceIsConfusingMockitoTest.java
Missing header in: src/test/java/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java
Missing header in: src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
Missing header in: src/test/java/org/mockitousage/bugs/ConfusedSignatureTest.java
Missing header in: src/test/java/org/mockitousage/bugs/EqualsWithDeltaTest.java
Missing header in: src/test/java/org/mockitousage/bugs/creation/PublicMethodInParentWithNonPublicTypeInSignatureTest.java
Missing header in: src/test/java/org/mockitousage/bugs/CompareMatcherTest.java
Missing header in: src/test/java/org/mockitousage/bugs/creation/otherpackage/PublicParentClass.java
Missing header in: src/test/java/org/mockitousage/bugs/injection/Issue353InjectionMightNotHappenInCertainConfigurationTest.java
Missing header in: src/test/java/org/mockitousage/bugs/creation/ConstructorInvokingMethodShouldNotRaiseExceptionTest.java
Missing header in: src/test/java/org/mockitousage/bugs/deepstubs/DeepStubsWronglyReportsSerializationProblemsTest.java
Missing header in: src/test/java/org/mockitousage/bugs/creation/api/PublicClass.java
Missing header in: src/test/java/org/mockitousage/performance/StubOnlyAvoidMemoryConsumptionTest.java
Missing header in: src/test/java/org/mockitousage/basicapi/ResetInvocationsTest.java
Missing header in: src/test/java/org/mockitousage/bugs/deepstubs/DeepStubFailingWhenGenericNestedAsRawTypeTest.java
Missing header in: src/test/java/org/mockitousage/matchers/VarargsTest.java
Missing header in: src/test/java/org/mockitousage/stubbing/StubbingWithDelegateVarArgsTest.java
Missing header in: src/test/java/org/mockitousage/stubbing/StubbingReturnsSelfTest.java
Missing header in: src/test/java/org/mockitointegration/NoJUnitDependenciesTest.java
Missing header in: src/test/java/org/mockitoutil/ClassLoadersTest.java
Missing header in: src/test/java/org/mockitoutil/SimplePerRealmReloadingClassLoader.java
Missing header in: src/test/java/org/mockitoutil/ClassLoaders.java
Missing header in: src/test/java/org/mockitoutil/TestBaseTest.java
Missing header in: src/test/java/org/mockitoutil/VmArgAssumptions.java
Missing header in: src/test/java/org/mockitoutil/SimpleClassGenerator.java
Missing header in: src/test/java/org/mockitoutil/Stopwatch.java
Missing header in: src/test/java/org/mockitoutil/JUnitResultAssert.java
Missing header in: src/test/java/org/mockitoutil/SimpleSerializationUtil.java
Missing header in: src/test/java/org/mockito/verification/NegativeDurationTest.java
Missing header in: src/test/java/org/mockito/AnnotationsAreCopiedFromMockedTypeTest.java
Missing header in: src/test/java/org/mockito/internal/util/TimerTest.java
Missing header in: src/test/java/org/mockito/internal/util/PlatformTest.java
Missing header in: src/test/java/org/mockito/internal/util/DefaultMockingDetailsTest.java
Missing header in: src/test/java/org/mockito/internal/util/reflection/GenericArrayReturnTypeTest.java
Missing header in: src/test/java/org/mockito/internal/util/reflection/SuperTypesLastSorterTest.java
Missing header in: src/test/java/org/mockito/internal/util/reflection/GenericTypeExtractorTest.java
Missing header in: src/test/java/org/mockito/internal/verification/DescriptionTest.java
Missing header in: src/test/java/org/mockito/internal/util/io/IOUtilTest.java
Missing header in: src/test/java/org/mockito/internal/verification/VerificationOverTimeImplTest.java
Missing header in: src/test/java/org/mockito/internal/invocation/TypeSafeMatchingTest.java
Missing header in: src/test/java/org/mockito/internal/verification/VerificationWithDescriptionTest.java
Missing header in: src/test/java/org/mockito/internal/junit/JUnitRuleTest.java
Missing header in: src/test/java/org/mockito/internal/junit/StubbingArgMismatchesTest.java
Missing header in: src/test/java/org/mockito/internal/junit/UnusedStubbingsTest.java
Missing header in: src/test/java/org/mockito/internal/junit/ArgMismatchFinderTest.java
Missing header in: src/test/java/org/mockito/internal/creation/DelegatingMethodTest.java
Missing header in: src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java
Missing header in: src/test/java/org/mockito/internal/creation/bytebuddy/AbstractByteBuddyMockMakerTest.java
Missing header in: src/test/java/org/mockito/internal/creation/bytebuddy/TypeCachingMockBytecodeGeneratorTest.java
Missing header in: src/test/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMakerTest.java
Missing header in: src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java
Missing header in: src/test/java/org/mockito/internal/configuration/ClassPathLoaderTest.java
Missing header in: src/test/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMakerTest.java
Missing header in: src/test/java/org/mockito/internal/configuration/plugins/PluginFinderTest.java
Missing header in: src/test/java/org/mockito/internal/matchers/InstanceOfTest.java
Missing header in: src/test/java/org/mockito/internal/framework/DefaultMockitoFrameworkTest.java
Missing header in: src/test/java/org/mockito/internal/hamcrest/MatcherGenericTypeExtractorTest.java
Missing header in: src/test/java/org/mockito/internal/matchers/text/MatcherToStringTest.java
Missing header in: src/test/java/org/mockito/internal/matchers/text/ValuePrinterTest.java
Missing header in: src/test/java/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocationsTest.java
Missing header in: src/test/java/org/mockito/internal/matchers/StringMatchersTest.java
Missing header in: src/test/java/org/mockito/exceptions/stacktrace/StackTraceCleanerTest.java
:license
:createTestResources
:compileTestJavaNote: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.

:removeTestResources
:processTestResources UP-TO-DATE
:testClasses
:test
:extTest:compileTestJava
:extTest:testClasses
:extTest:test
:extTest:check
:extTest:build

org.mockitousage.verification.VerificationWithTimeoutTest > shouldAllowMixingOtherModesWithTimeoutAndFail FAILED
    Wanted but not invoked:
    mock.oneArg('c');
    -> at org.mockitousage.verification.VerificationWithTimeoutTest.shouldAllowMixingOtherModesWithTimeoutAndFail(VerificationWithTimeoutTest.java:103)
    Actually, there were zero interactions with this mock.
        at org.mockito.internal.exceptions.Reporter.wantedButNotInvoked(Reporter.java:329)
        at org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation(MissingInvocationChecker.java:38)
        at org.mockito.internal.verification.AtLeast.verify(AtLeast.java:31)
        at org.mockito.internal.verification.VerificationOverTimeImpl.verify(VerificationOverTimeImpl.java:78)
        at org.mockito.internal.verification.VerificationWrapper.verify(VerificationWrapper.java:19)
        at org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)
        at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:73)
        at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:32)
        at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:36)
        at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)
        at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:120)
        at org.mockitousage.IMethods$MockitoMock$442824988.oneArg(Unknown Source)
        at org.mockitousage.verification.VerificationWithTimeoutTest.shouldAllowMixingOtherModesWithTimeoutAndFail(VerificationWithTimeoutTest.java:103)

1666 tests completed, 1 failed, 48 skipped
:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':test'.
> There were failing tests. See the report at: file:///home/travis/build/mockito/mockito/build/reports/tests/index.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 1 mins 29.851 secs

Publishing build information...
https://gradle.com/s/rad43ogqfwgoi



The command ""./gradlew ciBuild release -Dscan"" exited with 1.
$ rm -f $HOME/.gradle/caches/modules-2/modules-2.lock

store build cache

change detected (content changed, file is created, or file is deleted):
/home/travis/.gradle/caches/2.14.1/plugin-resolution/cache.properties.lock
/home/travis/.gradle/caches/2.14.1/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/cache.properties
/home/travis/.gradle/caches/2.14.1/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/cache.properties.lock
/home/travis/.gradle/caches/2.14.1/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/classes/_BuildScript_.class
/home/travis/.gradle/caches/2.14.1/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/classes/_BuildScript_$_run_closure1.class
/home/travis/.gradle/caches/2.14.1/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/classes/_BuildScript_$_run_closure1$_closure2.class
/home/travis/.gradle/caches/2.14.1/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/classes/_BuildScript_$_run_closure1$_closure2$_closure4.class
/home/travis/.gradle/caches/2.14.1/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-16

...

changes detected, packing new archive
.
.
.
uploading archive


Done. Your build exited with 1.
```

</details>
 =||= https://travis-ci.org/mockito/mockito/jobs/177380695

Do I see this test failing even more frequently than before the recent changes to this test? Revert? :)
 =||= I don't know it may very well of the travis instances activities. Anyway I just wrote a retry rule since there's none coming with junit.
It's not perfect but this wrong to restart manually the jobs.
 =||= ",0
780,765,Cannot build Mockito on Windows 64b with Java 8 ,"Hi guys,

 I am trying to build Mockito on my Windows 64 machine with jdk1.8.0_66 and the build is failing. I tried the `master `branch and also the `release/2.x` branch, both are having the same problem. 

When I run `gradlew clean build` I am getting:

```
mockito\src\test\java\org\mockitousage\matchers\MatchersTest.java:599: error: unclosed character literal
        mock.oneArg(Character.valueOf('Ôé¼'));
                                      ^
mockito\src\test\java\org\mockitousage\matchers\MatchersTest.java:599: error: illegal character: '\u201a'
        mock.oneArg(Character.valueOf('Ôé¼'));
                                        ^
mockito\src\test\java\org\mockitousage\matchers\MatchersTest.java:599: error: illegal character: '\u00ac'
        mock.oneArg(Character.valueOf('Ôé¼'));
                                         ^
mockito\src\test\java\org\mockitousage\matchers\MatchersTest.java:599: error: unclosed character literal
        mock.oneArg(Character.valueOf('Ôé¼'));
                                          ^
mockito\src\test\java\org\mockitousage\matchers\MatchersTest.java:599: error: ';' expected
        mock.oneArg(Character.valueOf('Ôé¼'));
                                            ^
5 errors
:compileTestJava FAILED
:removeTestResources

FAILURE: Build failed with an exception.
```


After removing the line containing `        mock.oneArg(Character.valueOf('€'));` inside **MatchersTest.java** on line 599, the build works OK.

Anyone else facing similar trouble? 
  

","On Linux this is working fine. I thought that @bric3 (who made the test in https://github.com/mockito/mockito/commit/c9e8562c994d23286d326a8ee19e2598d36ebfda) is on a Mac. I suppose we can alter the value just fine for Windows. We do not build our tests on Windows ourselves, so thanks for trying it out!
 =||= This looks like a character encoding issue, could be any tool.
The last time I checked on Windows there was nothing wrong. I'll recheck when I have access to a windows box.
 =||= Thanks guys! FYI: Just checked on different Windows 64 and build fails there as well.
 =||= Just checked on a Windows VM and the problem does not happen here. Strange. =||= I managed to build it on my Windows 7 64B machine by using `gradlew build -Dfile.encoding=UTF-8`

How I found out:

According to http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html the Java compiler javac uses the default system encoding if the `-encoding` is not specified. My system default encoding in the machine is `Cp1252`, retrieved as a result of gradle task:

```
task printSystemEncoding << {
    println System.getProperty(""file.encoding"")
}
```

Another solution what worked for me was to configure directly the `javac` task to use the `encoding` flag with utf8:

```
tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}
```

The problem is probably that the file `MatchersTest.java` is saved in encoding which is not compatible with the default Windows `Cp1252`. I would like to **suggest** adjustment of the test / providing of default encoding set to utf-8 inside the build. =||= ",0
803,801,Mockito 2 fails when running on IBM J9 (SR1 FP10) VM,"Mocking an interface fails when running on IBM's JDK with the error attached below. 
Works well on Oracle JDK 1.8.0_91.

Attaching a small project that can be used to reproduce the issue: [mockito-ibm-jdk-test.zip](https://github.com/mockito/mockito/files/633253/mockito-ibm-jdk-test.zip)

Original Mailing list post: https://groups.google.com/forum/#!topic/mockito/IWPQj2bg280

Output from `java -version` of the failing version:
```
java version ""1.8.0""
Java(TM) SE Runtime Environment (build pwa6480sr1fp10-20150711_01(SR1 FP10))
IBM J9 VM (build 2.8, JRE 1.8.0 Windows 7 amd64-64 Compressed References 20150630_255633 (JIT enabled, AOT enabled)
J9VM - R28_jvm.28_20150630_1742_B255633
JIT  - tr.r14.java_20150625_95081.01
GC   - R28_jvm.28_20150630_1742_B255633_CMPRSS
J9CL - 20150630_255633)
JCL - 20150711_01 based on Oracle jdk8u51-b15
```
Error message and stack trace:
```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface service.Service.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.

Java               : 1.8
JVM vendor name    : IBM Corporation
JVM vendor version : 2.8
JVM name           : IBM J9 VM
JVM version        : pwa6480sr1fp10-20150711_01 (SR1 FP10)
JVM info           : JRE 1.8.0 Windows 7 amd64-64 Compressed References 20150630_255633 (JIT enabled, AOT enabled)
J9VM - R28_jvm.28_20150630_1742_B255633
JIT  - tr.r14.java_20150625_95081.01
GC   - R28_jvm.28_20150630_1742_B255633_CMPRSS
J9CL - 20150630_255633
OS name            : Windows 7
OS version         : 6.1


Underlying exception : java.lang.IllegalArgumentException: object is not an instance of declaring class
	at org.mockito.internal.runners.SilentJUnitRunner$1.withBefores(SilentJUnitRunner.java:29)
	at org.junit.runners.BlockJUnit4ClassRunner.methodBlock(BlockJUnit4ClassRunner.java:276)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.mockito.internal.runners.SilentJUnitRunner.run(SilentJUnitRunner.java:39)
	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:39)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:103)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
Caused by: java.lang.IllegalArgumentException: object is not an instance of declaring class
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:95)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55)
	at java.lang.reflect.Method.invoke(Method.java:507)
	at net.bytebuddy.description.type.TypeDescription$Generic$AnnotationReader$ForTypeArgument.resolve(TypeDescription.java:3843)
	at net.bytebuddy.description.type.TypeDescription$Generic$AnnotationReader$Delegator$Chained.resolve(TypeDescription.java:3468)
	at net.bytebuddy.description.type.TypeDescription$Generic$AnnotationReader$ForTypeArgument.resolve(TypeDescription.java:3803)
	at net.bytebuddy.description.type.TypeDescription$Generic$AnnotationReader$Delegator.asList(TypeDescription.java:3439)
	at net.bytebuddy.description.type.TypeDescription$Generic$OfNonGenericType$ForLoadedType.getDeclaredAnnotations(TypeDescription.java:4208)
	at net.bytebuddy.implementation.attribute.AnnotationAppender$ForTypeAnnotations.apply(AnnotationAppender.java:720)
	at net.bytebuddy.implementation.attribute.AnnotationAppender$ForTypeAnnotations.onNonGenericType(AnnotationAppender.java:701)
	at net.bytebuddy.implementation.attribute.AnnotationAppender$ForTypeAnnotations.onNonGenericType(AnnotationAppender.java:415)
	at net.bytebuddy.description.type.TypeDescription$Generic$OfNonGenericType.accept(TypeDescription.java:4075)
	at net.bytebuddy.implementation.attribute.AnnotationAppender$ForTypeAnnotations.onParameterizedType(AnnotationAppender.java:682)
	at net.bytebuddy.implementation.attribute.AnnotationAppender$ForTypeAnnotations.onParameterizedType(AnnotationAppender.java:415)
	at net.bytebuddy.description.type.TypeDescription$Generic$OfParameterizedType.accept(TypeDescription.java:4998)
	at net.bytebuddy.implementation.attribute.MethodAttributeAppender$ForInstrumentedMethod.apply(MethodAttributeAppender.java:195)
	at net.bytebuddy.implementation.attribute.MethodAttributeAppender$Compound.apply(MethodAttributeAppender.java:490)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyBody(TypeWriter.java:612)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod.apply(TypeWriter.java:533)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForCreation.create(TypeWriter.java:3910)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1693)
	at net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder.make(SubclassDynamicTypeBuilder.java:172)
	at net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder.make(SubclassDynamicTypeBuilder.java:153)
	at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2568)
	at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase$Delegator.make(DynamicType.java:2670)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:84)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$CachedBytecodeGenerator.getOrGenerateMockClass(TypeCachingBytecodeGenerator.java:91)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:38)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:68)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:39)
	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:26)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)
	at org.mockito.Mockito.mock(Mockito.java:1637)
	at org.mockito.internal.configuration.MockAnnotationProcessor.process(MockAnnotationProcessor.java:33)
	at org.mockito.internal.configuration.MockAnnotationProcessor.process(MockAnnotationProcessor.java:16)
	at org.mockito.internal.configuration.DefaultAnnotationEngine.createMockFor(DefaultAnnotationEngine.java:39)
	at org.mockito.internal.configuration.DefaultAnnotationEngine.process(DefaultAnnotationEngine.java:63)
	at org.mockito.internal.configuration.InjectingAnnotationEngine.processIndependentAnnotations(InjectingAnnotationEngine.java:59)
	at org.mockito.internal.configuration.InjectingAnnotationEngine.process(InjectingAnnotationEngine.java:43)
	at org.mockito.MockitoAnnotations.initMocks(MockitoAnnotations.java:67)
	... 19 more
```","Hi thanks for the report @grimsa 

I don't have access to an J9 virtual machine. It's probably something related to internal types of J9 that affects parts of byte-byddy (like the one show in the [stack trace](https://github.com/raphw/byte-buddy/blob/byte-buddy-1.5.5/byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java#L3803-L3851)). So not sure when this bug can be fixed. =||= There are some hoops to jump through to get IBM's J9 VM (I assume due to some licensing issue). But it can be downloaded with no registration in a [bundle with WebSphere Liberty](https://developer.ibm.com/assets/wasdev/#asset/runtimes-webprofile7-ibm-java) (located in wlp/java/java).

Running `java -version` on it produces the following:
```
java version ""1.8.0""
Java(TM) SE Runtime Environment (build pwa6480sr3fp10-20160720_02(SR3fp10))
IBM J9 VM (build 2.8, JRE 1.8.0 Windows 7 amd64-64 Compressed References 20160719_312156 (JIT enabled, AOT enabled)
J9VM - R28_Java8_SR3_20160719_1144_B312156
JIT  - tr.r14.java_20160629_120284.01
GC   - R28_Java8_SR3_20160719_1144_B312156_CMPRSS
J9CL - 20160719_312156)
JCL - 20160719_01 based on Oracle jdk8u101-b13
```
But what is important is that I ran the test on this version and Mockito **worked as expected**.

We're running on a fairly old IBM JDK (back from 2015 06), so maybe we brought it on ourselves...

If you are still interested in looking into it, I could figure out a way to get you that failing version of J9. =||= Ah, it's possible that early Java 8 VM of IBM had issues as well. Actually @raphw identified issues with early hotspot VM, they had bugs that were fixed in 1.80.u45. Since it's old and a more recent version of the VM appears to fix the issue, I'm not sure it's worth the effort.

Eventually we can print a message that can warn J9 users. Warning on a specific version is possible but the version scheme is confusing to say the least. I'm tempted to label it as _won't fix_.

Anyway thanks for the link, I'm using OSX though. It's always possible to create a virtual box from scratch, however it takes time. =||= I see there's some code in `org.mockito.internal.util.Platform` that checks for JDK version, but I don't see an obvious and clean way to add this J9 version check, especially as we don't know an exact version from which it works as expected.

I'd agree with labeling it with _wont-fix_, although you could consider mentioning it in the Wiki (e.g. in [What's new in Mockito 2](https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2)) =||= > as we don't know an exact version from which it works as expected.

Yes exactly.

Sure I'll mention it in the wiki. Closing as won't fix for now. =||= Added some info regarding VM in the wiki page. and I created a PR that warns the user of early IBM J9 VMs =||= ",0
807,770,Opt-in stubbing strictness implemented in JUnit rules,"New API (for rationale, see #769):

```java
//Existing API:
@Rule public MockitoRule mockito = MockitoJUnit.rule()

//Proposed improvements:
rule().strictness(Strictness.LENIENT)
rule().strictness(Strictness.WARN)       // <-- is the default
rule().strictness(Strictness.STRICT_STUBS)  // <-- Mockito 3.0 default
```

What ""strict stubbing"" means?
- Improved debuggability: the test fails early when code under test invokes stubbed method with different arguments.
- Cleaner tests without unnecessary stubbings: the test fails when there are any unused stubs declared.
- Cleaner, more DRY tests (""Don't Repeat Yourself""): If you use Mockito.verifyNoMoreInteractions() you no longer need to explicitly verify stubbed invocations. They are automatically verified.

For background and motivation, check out [Szczepan's article on LinkedIn](https://www.linkedin.com/pulse/curious-how-get-even-cleaner-tests-new-mockito-features-faber).","## [Current coverage](https://codecov.io/gh/mockito/mockito/pull/770?src=pr) is 86.76% (diff: 93.90%)


> No coverage report found for **release/2.x** at fc9329c.

> Powered by [Codecov](https://codecov.io?src=pr). Last update [fc9329c...0d0cc4d](https://codecov.io/gh/mockito/mockito/compare/fc9329cba14c55310c3d4640b6667cf0230d042a...0d0cc4dd51c9455e2b7aa8001c27b61871ecc820?src=pr) =||= Thanks for feedback!!! This RB is in progress. I'm so itching to work on this! =||= Added this API in recent update:

```java
public interface StubbingLookUpListener {

    /**
     * Called by the framework when Mockito looked up an answer for invocation on a mock.
     *
     * @param invocation - the invocation on the mock
     * @param stubbingFound -  can be null - it indicates that the invocation was not stubbed. If not null, it means that the stubbing was found on the mock.
     */
    void onStubbingLookUp(Invocation invocation, MatchableInvocation stubbingFound);
```

Feedback welcome. =||= @szczepiq: I'm not a native speaker, but I think `StubbingLookUpListener` should be `StubbingLookupListener` (lower case `u`)?   =||= Thanks guys for great code review feedback!!! All suggestions make perfect sense.

While I still work on this feature / PR, the best feedback you can give me is at higher level (e.g. public API changes, the change to public behavior). I'm worried that smaller code suggestions will get lost as I shuffle the code ;) =||= The feature is shaping up. If you review, keep an eye on the public API changes and the new behavior (the tests explain the new behavior) - I'm really keen on feedback on those. Rule strictness will be enabled by following API and I tentatively plan to make it a default in Mockito 3:

```java
MockitoJUnit.rule().strictStubs()
```

Thanks for keeping an eye on this and the review!!! =||= I'm close to ready with this PR. Missing:
 - documentation
 - exposing of strictStubs() method =||= Could you please give me some time to review this big PR? Dont have time
right now, but soon will!

On Fri, 25 Nov 2016, 16:42 Szczepan Faber, <notifications@github.com> wrote:

> I'm close to ready with this PR. Missing:
>
>    - documentation
>    - exposing of strictStubs() method
>
> —
> You are receiving this because you commented.
>
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/pull/770#issuecomment-262982296>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb0preXieUrShUK-9T3zm_mcEANH9ks5rBwH6gaJpZM4K3Xkn>
> .
>
 =||= @TimvdLippe, no worries, I can wait. Plus, I haven't finished yet. =||= Pushed in few refactorings, mostly using the new SafeJUnitRule test utility (btw. I love it :D).

I plan to work on the docs and public api exposure in the next round. The code is reviewable now. =||= Ok, documentation ready and public api exposed :D

Thank you guys for following this PR and guiding the implementation via code review feedback!!! =||= Updated the code based on latest code review feedback. TODOs:
- review public API changes in the mockito PR
- add blurp to the main mockito class =||= Nice feedback @ChristianSchwarz , thank you!

>silent() is renamed to silentStubs(). What do you think?

I'd still stay with silent() and strictStubs(). However, I'm open to discussion about the best API. Other ideas:

1. MockitoJUnit.rule(Strictness.STRICT_STUBS) // <-- easy to discover
2. Annotation:

```java
@Mockito(strictStubs=true) // <-- would work with both runner and the rule
public class SomeTest {
  @Rule public MockitoRule rule = MockitoJUnit.rule(); 
}
``` =||= The feature is complete. I don't plan to make changes except of some public API changes that are currently discussed. Please review! =||= I really prefer the `Strictness` enum to enable strict mocks.

1. > MockitoJUnit.rule(Strictness.STRICT_STUBS) // <-- easy to discover

    Although I'd prefer something like :

    ```java
    MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);
    ```

    Pushing the idea forward, it would look like :

    ```java
    MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS)
                       .logger(my_logger)
                       .annotationEngine(...)
                       .injectionEngine(...);
    ```

    This configuration design is discoverable and evolutive.

2. > Annotation `@Mockito`

    From experience I'd like to avoid annotation overload, so I'd prefer a programatic way of changing some option like strictness

    ```java
    @Test public assert_some_behaviour() {
      mockitoRule.options().strictness(Strictness.NONE);
      // ...
    }
    ``` =||= Very nice feedback @bric3!

>Since the API is incubating, it can be removed safely (users have been warned) even in minor version to follow ideas expressed in above comments.

Absolutely! Despite that, I want us to make well thought out API decision and bring to our users an opinionated feature. Hence, let's keep the discussion going for a little bit, before we merge.

>I really prefer the Strictness enum to enable strict mocks

I really like your suggestion with an enum!

>From experience I'd like to avoid annotation overload, so I'd prefer a programatic way of changing some option like strictness

I really like this idea!

I'm with you about the annotations. One value I see in annotations is that we would have _exactly_ the same API for runner and the rule. They both can use the annotation.

I'll design the API based on @bric3 feedback and present it here for more feedback. In the meantime, tell us what you think! =||= Based on feedback, I came up with this API (for rationale, see #769):

```java
//Existing API:
@Rule public MockitoRule mockito = MockitoJUnit.rule()

//Proposed improvements:
rule().strictness(Strictness.LENIENT)
rule().strictness(Strictness.WARN)       // <-- is the default
rule().strictness(Strictness.STRICT_STUBS)  // <-- Mockito 3.0 default
```
Potential future changes (based on feedback / necessity):
```java
//Further work on ""strictness"":
rule().strictness(Strictness.STRICT_MOCKS)  // <-- different than strict stubs
rule().strictness(Strictness.STRICT_MOCKS_WARN)

//Exposing the listener API used by JUnit rules:
rule().listener(MockitoTestListener)

//Annotation API that also integrates seamlessly with MockitoJUnitRunner
@Mockito(strictness = Strictness.STRICT_STUBS)
public class SomeTest {

	@Test public void shouldWork() {
		//...	
	}

	@Mockito(strictness = Strictness.LENIENT)
	@Test public void shouldWork() {
		//...	
	}
}
``` =||= This feature is ready to merge. Please make a final pass! =||= @TimvdLippe, I'm about to merge it. Do you still want to review? Any feedback about the new public API.

@ChristianSchwarz, feedback? =||= Thanks @TimvdLippe !!! I assume that you're ok with public API changes, e.g. new rule().strict() method. I made subjective tweaks based on your feedback and will merge the change today! =||= @szczepiq Yes I am okay with the API. I do think the Event Object should be fixed, other than that LGTM =||= >@szczepiq Yes I am okay with the API. I do think the Event Object should be fixed, other than that LGTM

Thank you! FYI - Since the listener is internal, I don't plan to introduce an event at this time.

 =||= Was about to merge it but did a final pass over the changed API and found out that I'm leaking private API via MockCreationSettings :) Will fix this shortly. =||= I cannot reopen PR after it has been force-pushed. Learning Git/GitHub every day :) =||= ",0
813,798,Update Jacoco to stable minor version 0.7.8 when released,"See https://github.com/jacoco/jacoco/issues/467#issuecomment-264311016

The snapshot version of Jacoco are removed and could fail our CI. The version of Jacoco is required to build on JDK9",Release approaching ;) =||= `0.7.8` has been released: https://github.com/jacoco/jacoco/issues/467#issuecomment-266305876 =||= Fixed by #798. =||= ,0
821,820,[VarArgs] unexpected behaviour of returnsArgAt(int),"I stumble about a test that failed after refactoring an array parameter to an varargs.

The following test succeed:
```java
interface Foo{
        int[] getOdd(int[] input);
}

@Test
public void test() throws Exception {
    when(foo.getOdd(any())).then(returnsArgAt(0));
        
    int[] odd = mock.getOdd(new int[]{1,3,5});
    assertThat(odd).contains(1,3,5);
}
```
Now lets change the parameter _input_ to an varargs.
```java
interface Foo{
        int[] getOdd(int... input);
}
```
The test fails now with:

```
org.mockito.exceptions.misusing.WrongTypeOfReturnValue: 
The argument of type 'int' cannot be returned because the following 
method should return the type 'int[]'
 -> foo.getOdd()
```

This is not expected cause the change is source and binary(?) compatible, an varargs-parameter is still an array. ReturnsArgumentAt interprets the vararg array items as real parameters. In other words it tries to return an element type where the array type is required.

Can the behaviour of interpreting vararg elements like parameters be changed so an vararg is treated as an array? E.g. in Mockito 3? There are several other cases were the current vararg handling leads to unexpected behaviour.","I think your second example has a typo, since there are no var args in the example =||= thanks fixed =||= Good catch!
By the way, the mock reference is both foo and mock =||= While it is source and binary compatible, vararg method are different than plain old array method, reflection allows to distinguish that. The issue is in `ReturnsArgumentAt.returnedTypeOnSignature` where there's a special handling for varargs. =||= I'm working on the fix (currently adding some unit tests) =||= This should be fixed by #821 =||= ",0
823,818,StackOverflow occurs when mocking a HashMap with mockmaker,"As investigated in #752, mocking a `HashMap` halts with a stack overflow when using `mock-maker-inline`:

```
Mockito.mock(HashMap.class);

Exception in thread ""Reference Handler"" java.lang.StackOverflowError
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
	at java.lang.Class.getDeclaredMethod(Class.java:2128)
	at java.util.HashMap.get(HashMap.java:556)
	at sun.reflect.Reflection.filterMethods(Reflection.java:291)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
	at java.lang.Class.getDeclaredMethod(Class.java:2128)
	at java.util.HashMap.get(HashMap.java:556)
	at sun.reflect.Reflection.filterMethods(Reflection.java:291)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
	at java.lang.Class.getDeclaredMethod(Class.java:2128)
	at java.util.HashMap.get(HashMap.java:556)
	at sun.reflect.Reflection.filterMethods(Reflection.java:291)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
	at java.lang.Class.getDeclaredMethod(Class.java:2128)
	at java.util.HashMap.get(HashMap.java:556)
	at sun.reflect.Reflection.filterMethods(Reflection.java:291)
```

This does not occur when mocking `Map`.
Verified against Mockito 2.2.28.",nan,0
826,820,[VarArgs] unexpected behaviour of returnsArgAt(int),"I stumble about a test that failed after refactoring an array parameter to an varargs.

The following test succeed:
```java
interface Foo{
        int[] getOdd(int[] input);
}

@Test
public void test() throws Exception {
    when(foo.getOdd(any())).then(returnsArgAt(0));
        
    int[] odd = mock.getOdd(new int[]{1,3,5});
    assertThat(odd).contains(1,3,5);
}
```
Now lets change the parameter _input_ to an varargs.
```java
interface Foo{
        int[] getOdd(int... input);
}
```
The test fails now with:

```
org.mockito.exceptions.misusing.WrongTypeOfReturnValue: 
The argument of type 'int' cannot be returned because the following 
method should return the type 'int[]'
 -> foo.getOdd()
```

This is not expected cause the change is source and binary(?) compatible, an varargs-parameter is still an array. ReturnsArgumentAt interprets the vararg array items as real parameters. In other words it tries to return an element type where the array type is required.

Can the behaviour of interpreting vararg elements like parameters be changed so an vararg is treated as an array? E.g. in Mockito 3? There are several other cases were the current vararg handling leads to unexpected behaviour.","I think your second example has a typo, since there are no var args in the example =||= thanks fixed =||= Good catch!
By the way, the mock reference is both foo and mock =||= While it is source and binary compatible, vararg method are different than plain old array method, reflection allows to distinguish that. The issue is in `ReturnsArgumentAt.returnedTypeOnSignature` where there's a special handling for varargs. =||= I'm working on the fix (currently adding some unit tests) =||= This should be fixed by #821 =||= ",0
830,822,Bogus NPE if any() is used with primitive type arguments,"Mockito: 2.3.0, Java 8

When mocking a method invocation, if any() is used instead of anyInt() for exampe in the .when method call, a bogus NPE is thrown. There is quite a lot of explanations to the root cause of that, but it does not contain this hint.

I would expect either a compilation error or a more explanatory exception.
Code: https://gist.github.com/axos88/163061ed82fcfdd9756d60d12eba8809

```
java.lang.NullPointerException
	at xxx.WtfTest.testCaseNPE(WtfTest.java:34)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.mockito.internal.runners.SilentJUnitRunner.run(SilentJUnitRunner.java:39)
	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:39)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:103)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:237)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)


You cannot use argument matchers outside of verification or stubbing.
Examples of correct usage of argument matchers:
    when(mock.get(anyInt())).thenReturn(null);
    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());
    verify(mock).someMethod(contains(""foo""))

Also, this error might show up because you use argument matchers with methods that cannot be mocked.
Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().
Mocking methods declared on non-public parent classes is not supported.

```






","There is also some weirdness that the mockFoo's value is set to null between the invocation of when() and .foo(), on line 33. =||= @axos88 
This behaviour can't be avoided cause java doesn't allow return type overloads like `int any()`, `T any()` , ...,  therefore Mockito provides `any<primitve>()` methods.   =||= **tl;dr**

This cannot be avoided as @ChristianSchwarz has just wrote. That's one of corner area of Java itself where can't really do something. 

**long story**

With the signature of `any()`, `javac` thinks 

* that `any()` can return an `Integer` => insert cast Object to Integer
* that the `Integer` can be unboxed => invoke `intValue`

However `any`

* has return type `T` whose implicit upper bound is `Object` => `Integer` matches for `javac`
* returns `null` reference => OK for `Integer`

The NPE is raised on the callsite by code that wasn't explicitly written, and we can't really do something here. Note the javadoc of `any()` do say to use the primitive variants :

```
For primitive types use {@link #anyChar()} family...
``` =||= I understand, but a note about this in the output of the exception about this possibility would be welcome:

```
You cannot use argument matchers outside of verification or stubbing.
Examples of correct usage of argument matchers:
    when(mock.get(anyInt())).thenReturn(null);
    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());
    verify(mock).someMethod(contains(""foo""))

Also, this error might show up because you use argument matchers with methods that cannot be mocked.
Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().
Mocking methods declared on non-public parent classes is not supported.
``` =||= I'm not sure this is related, what fails is a NullPointerException that is raised by the JVM on the callsite of the matcher.
The mockito exception message seems related to another issue, and the exception type that have this message can only be `InvalidUseOfMatchersException`. =||= It seems like the NPE has an InvalidUseOfMatchersException as its cause =||= Ah I see what's happening, JUnit Runner performs an additional check after a test, and then report a matcher misuse. Because the matchers were not _consumed_ byt the mock, the NPE is raised first.

Indeed we can mention that in the message.
Thanks for insisting on this ! =||= Closing this one since there's now the PR #830  =||= Hi @bric3 , I believe this issue is appearing again, please see my below junit example:
```
public class MockitoTest {

    @Test
    public void testDoAThing() {
        final TestThing thing = Mockito.mock(TestThing.class);

        Mockito.when(thing.doAThing(Mockito.any(), Mockito.any()))
            .thenReturn(""asd"");
    }

    public static class TestThing {
        public String doAThing(String foo, boolean second) {
            return second ? foo + ""asd"" : foo;
        }
    }
}
```

When running this test I get the following output:
```
java.lang.NullPointerException
	at com.mytest.MockitoTest.testDoAThing(MockitoTest.java:12)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
```

No mention of the above error or any real indication what is happening - I ended up using trial and error to determine what was going wrong. =||= ",0
831,825,#719 Test clean up according to discussions for RememberingListeners,"According to issue @719 we wanted to clean up the tests for `RememberingListener`s.

The tests should follow the same style and conventions.
Set up should not contain variables used by all the tests.","## [Current coverage](https://codecov.io/gh/mockito/mockito/pull/825?src=pr) is 86.67% (diff: 100%)
> Merging [#825](https://codecov.io/gh/mockito/mockito/pull/825?src=pr) into [release/2.x](https://codecov.io/gh/mockito/mockito/branch/release/2.x?src=pr) will not change coverage

```diff
@@           release/2.x       #825   diff @@
=============================================
  Files              284        284          
  Lines             5666       5666          
  Methods              0          0          
  Messages             0          0          
  Branches           924        924          
=============================================
  Hits              4911       4911          
  Misses             563        563          
  Partials           192        192          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [2105afc...ef9e856](https://codecov.io/gh/mockito/mockito/compare/2105afc9792643c362f46a64d92a15e9642e6e8e...ef9e8565a5fc60ec7711f48d7943dd0c9fec13f3?src=pr) =||= @bric3 I've inlinded `Foo.class.getDeclaredMethod(""doSomething"", String.class)`
Regarding putting the method `notifiedFor` into org.mockitoutil.Conditions.
The method is not same between `InvocationListenerCallbackTest` and `VerificationListenerCallBackTest` and they both use a different implementation of `RememberingListener`.
I would like to wait for more test classes wanting to do the same thing and then move it. Else we need to move also the class and find new suitable names for the classes.
Unless you have another idea to improve this? =||= I just tried the webview to resolve conflicts, it's ok but limited, and it creates a commit named like `Merge branch 'release/2.x' into verification-listeners-cleanup`. I'd rather have more control on this. =||= > Regarding putting the method notifiedFor into org.mockitoutil.Conditions.
The method is not same between InvocationListenerCallbackTest and VerificationListenerCallBackTest and they both use a different implementation of RememberingListener.
I would like to wait for more test classes wanting to do the same thing and then move it. Else we need to move also the class and find new suitable names for the classes.
Unless you have another idea to improve this?

OK fair enough :) =||= ",0
839,838,Feature request: ArgumentMatchers.matches(Pattern regex),"you ladies and gentlemen are geniuses by the way.

ArgumentMatchers.match( String regex ) exists... but wouldn't it be slightly better if it were match( Pattern regex )? (i.e. catering for multi-line Strings, etc.).

Also, devising a regex which distinctly does NOT match a given String is non-trivial.  And yet not atypical of a mocking use case.  Hence I suggest you clever people take the heavy lifting away from grunts like me by offering ArgumentMatchers.doesNotMatch( Pattern regex ).

I posed this question today on Stack Overflow [here](http://stackoverflow.com/questions/41270738/mockito-argumentmatchers-doesnotmatch?noredirect=1#comment69745269_41270738).  

------

**EDIT 1** by @bric3 : removed the issue guidelines
**EDIT 2** by @bric3 : Renamed the issue title. Previous title was `Feature request: ArgumentMatchers.doesNotMatch( Pattern regex )`","As the question is answered in SO, you can negate matchers using `AdditionalMatchers.not()`.

I think I can close this issue. =||= OK... but this question highlights the fact that the online documentation and tutorials are not optional, they are essential ... and they are currently inadequate.  People who are willing to learn shouldn't have to pose a question for such an obvious use case on SO. =||= Hi,

I closed the issue because it is about a feature request that is not valid since the feature is already present in a different form. Now documentation and tutorial is another thing.

`AdditionalMatchers` is mentionned on the first line of the [ArgumentMatchers javadoc](https://static.javadoc.io/org.mockito/mockito-core/2.4.0/org/mockito/ArgumentMatchers.html). The Mockito javadoc gives plenty of code examples on the public API, which is already more than most javadoc in almost every project. 

I'm not saying it can't improved or we won't improve it, it can and we will! On the matter at hand those matchers can be promoted a bit more to enhance discoverability.

Regarding tutorials I believe it is the responsibility of respective blog authors.

In the mean time pull requests are welcome, and the wiki can be edited by any benevolent soul. =||= Also it seems I skipped the part on the `Pattern` class, reopening for the `matches(Pattern)` matcher.

 =||= Oh... good.  No really!  The multi-line challenge has me foxed... indeed.  :) =||= The builds should propagate within an hour (note that badges or search.maven.org may not be up to date) =||= Hi Brice... thanks for doing this so quickly.  I have upgraded my gradle.build and got hold of your new build.  But I am still having problems using ""not"" with this... if you have a moment maybe you might look at my new edit at [SO](http://stackoverflow.com/questions/41270738/mockito-argumentmatchers-doesnotmatch). =||= It looks like an import issue, either for `not` or `matches`. I've tested it yesterday, when I added the API. =||= Yes, you're right: it's an AssertJ confusion: Eclipse imported NotFilter.not() automatically.  Apologies. =||= ",0
843,840,Tweak JUnit rule strictness at the method level,"Team, I would really appreciate feedback about this enhancement.

There is a feature request reported - a way to exempt from unnecessary stubbing at method level (#792). The feature request makes sense to me. Currently, if the user wants to opt-out from JUnit rule or JUnit runner strictness, he needs to do it at the scope of the entire class. Ideally, we can opt-out from strictness at finer granularity level (method or even at mock level).

Inspired by @bric3 [idea](https://github.com/mockito/mockito/issues/792#issuecomment-265762478) I'd like to get your feedback about this API enhancement for strict JUnit rules.

Example test class:

```java
public class MyTest {
    //Mockito stubbing is strict in the entire test class
    @Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);

    @Test public void lenient_mockito() throws Throwable {
        //making Mockito lenient only for this test method
        //below API already exist but it does not have any effect inside of the test method
        mockito.strictness(Strictness.LENIENT);

        //rest of the test
    }
}
```

Pros:
 - we already have 'strictness' method in the MockitoRule API so it's not adding any new API
 - least surprise principle - users might expect this behavior to work but currently 'strictness' method _creates_ new instance of the rule and _not_ change the state of the rule.

Cons:
 - it's slightly not intuitive that 'strictness' method actually changes state (it's not a setter).","Instead of a call to the rule (which I would expect to cause side-effects when I see the code) I think it is clearer to use an annotation on the method. Something like `@MockitoStrictness(LENIENT)` =||= Annotations are clearer and they are a good idea, we discussed it in #792, @bric3 was not in favor of annotations.

Call to the rule is something we would offer in the meantime, before we have annotations. Long term, I think annotations are a way forward.

I'm waiting for more feedback and I'm leaning to implement this new rule behavior regardless if we decide to do annotations or not :) =||= Yes I'm not in favor of annotation, but I'm not totally against either. However annotation API, is to be carefully designed as there is way less flexibility, override, argument types, etc.

**Pros**

* I believe a programtic way offers more choice for users and framework developers, including mockito.

> * least surprise principle - users might expect this behavior to work but currently 'strictness' method creates new instance of the rule and not change the state of the rule.

That's maybe the biggest issue here. To bypass this the code will need to have some way to define a global state. in spseudo code :

```java
// for
MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);

public MockitoRule strictness(Strictness strictness) {
    return new JUnitRule(internalRuleRef, logger, strictness);
}

private JUnitRule(AtomicReference<JUnitRule> internalRef, MockitoLogger logger, Strictness strictness) {
    this.internalRule.set(new JUnitRule(logger, strictness)); // existing constructor, but should be another class ideally.
}

public Statement apply(Statement base, FrameworkMethod method, Object target) {
    return internalRule.apply(base, method, target);
}
```

**Cons**

> * it's slightly not intuitive that 'strictness' method actually changes state (it's not a setter).

Nowadays people understand fluent API outside javabean's setters or getters. I don't think that's really an issue there, especially if there's code example in the javadoc.

 =||= Great feedback, @bric3

I'll take a stab at making strictness() method working for us. I should be able to use a single test listener inside a rule and make this listener mutable so that it can have different behavior between test runs. =||= A solution could be that the Rule also watches for annotations and calls the corresponding method. That would require a follow-up PR of #843. WDYT? =||= >A solution could be that the Rule also watches for annotations and calls the corresponding method. That would require a follow-up PR of #843. WDYT?

I like this idea a lot. There are 2 main reasons I like it:
 - annotation looks nice and clean in test code
 - annotation would also work with JUnit runner (when we make it work with runner :). For the runner, we cannot change it's state programmatically because it is a static instance attached to the test class via @RunWith annotation. With JUnit rule the situation is different - we have an instance of a rule during test execution. =||= There's also another option like : 

```java
rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);


// in some code block
ruleHandler = rule.handler() // no argument = getter
ruleHandler.strictness(Stritness.LENIENT) // takes arg = modify behavior
```

 =||= Thanks @bric3 for feedback! I'd rather stick to strictness() method instead of introducing handler(). It feels the API is simpler and more intuitive to use.




 =||= Fixed by #843  =||= ",0
847,845,Rename MockMethodDispatcher.class to MockMethodDispatcher.raw on build,"The `org.mockito.internal.creation.bytebuddy.MockMethodDispatcher.class` file should be renamed to `org.mockito.internal.creation.bytebuddy.MockMethodDispatcher.raw` on building Mockito. This way, class loaders are no longer capable of loading the class directly what should never happen. Doing so, the bootstrap injection mechanism cannot be superseeded by child-first class loaders which break mockability due to the dispatcher class being loaded twice by two different class loaders.

This problem was observed with the Robolectrics class loader.

Additionally, the following change is required in the `InlineByteBuddyMockMaker` when creating the boot jar

```java
String source = ""org/mockito/internal/creation/bytebuddy/MockMethodDispatcher"";
outputStream.putNextEntry(new JarEntry(source + "".class""));
InputStream inputStream = InlineByteBuddyMockMaker.class.getClassLoader().getResourceAsStream(source + "".raw"");
if (inputStream == null) {
  throw new MockitoInitializationException(join(
    ""The MockMethodDispatcher class file could not be located "" + source,
    """",
    ""The class loader responsible: "" + InlineByteBuddyMockMaker.class.getClassLoader()
  ));
}
try {
  int length;
  byte[] buffer = new byte[1024];
  while ((length = inputStream.read(buffer)) != -1) {
    outputStream.write(buffer, 0, length);
  }
} finally {
  inputStream.close();
}
outputStream.closeEntry();
```","If the renaming is only needed when creating a distribution jar, you can customize the jar task with something like this:

`jar {
  rename ""org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.class"", ""org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.raw""
}`

If you need to rename this file after compilation, you could use the `doLast` section of the `classes` task:

`doLast {
  file(""${buildDir}/main/org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.class"").renameTo(""${buildDir}/main/org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.raw"")
}` =||= I discovered the Robolectric ClassLoader issue as well while updating the Mockito mockmaker to ByteBuddy internally. My fix now has the correct class hierarchy, but it now fails to properly resolve the `MockMethodDispatcher`. Should we revert this change (and figure out a way to work with both the broken ClassLoader and the fixed version)? =||= For now, I have patched the Robolectric ClassLoader to special case the class:

```java
String extension = className.equals(""org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher"") ? ""raw"" : ""class"";
    String classFilename = className.replace('.', '/') + ""."" + extension;
```
However, this introduces a version complexity matrix. E.g.:

broken Robolectric works with current Mockito
fixed Robolectric does not work with current Mockito
fixed Robolectric + workaround works with current Mockito

How can we remove the workaround in Robolectric while at the same time remove the workaround in Mockito while adhering to SemVer in BOTH projects? =||= Current thinking is (on Mockito build time) keep the `.class` and copying to `.raw`. Then we can update Mockito to just use `.class` and old Robolectric ignores `.raw`, while the new Robolectric uses the original `.class`. =||= ",0
861,860,Jacoco 0.7.8 breaks tests for the new plugin mechanism,"Jacoco 0.7.8 breaks the tests for the new plugin mechanism (#811) with:

```
:test

org.mockitoutil.ClassLoadersTest > cannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded FAILED
    java.lang.AssertionError: 
    Expecting a throwable with cause being an instance of:
     <java.lang.NoClassDefFoundError>
    but was an instance of:
     <java.lang.IllegalStateException: java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$2 with modifiers ""private static transient"">
        at org.mockitoutil.ClassLoadersTest.cannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded(ClassLoadersTest.java:324)

org.mockitoutil.ClassLoadersTest > can_run_in_given_classloader FAILED
    java.lang.IllegalStateException: Given task could not be loaded properly in the given classloader 'org.mockitoutil.ClassLoadersTest$1@46dcdf84', error 'java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$1 with modifiers ""private static transient""

        Caused by:
        java.lang.IllegalStateException: java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$1 with modifiers ""private static transient""

            Caused by:
            java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$1 with modifiers ""private static transient""

org.mockito.internal.configuration.GlobalConfigurationTest > returns_mockito_annotation_engine_of_Plugins_if_no_MockitoConfiguration FAILED
    java.lang.IllegalStateException: Given task could not be loaded properly in the given classloader 'org.mockito.internal.configuration.GlobalConfigurationTest$1@5adb485', error 'java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockito.internal.configuration.GlobalConfigurationTest$1 with modifiers ""private static transient""

        Caused by:
        java.lang.IllegalStateException: java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockito.internal.configuration.GlobalConfigurationTest$1 with modifiers ""private static transient""

            Caused by:
            java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockito.internal.configuration.GlobalConfigurationTest$1 with modifiers ""private static transient""

1701 tests completed, 3 failed, 42 skipped
:test FAILED
```

The corresponding Travis build: https://travis-ci.org/mockito/mockito/jobs/187043982#L431",@bric3 Can you identify the minimal scenario that reproduce this issue to be able to report it to the JaCoCo team? =||= ,0
865,857,New strict mocking API - MockitoSession,"### Background

- Mockito strictness (improved debuggability, cleaner tests) is described in [a blog post](http://blog.mockito.org/2017/01/clean-tests-produce-clean-code-strict.html) and in issue #769
- Strict stubbing is already supported with JUnit rules - #807
- Open PR for supporting strict stubbing with JUnit Runners - #854
- This ticket intends to discuss the goals and implementation of strict stubbing without JUnit Rules / Runner

### Initial design

```java
public class SampleTest {   
    @Mock IMethods mock;
    
    //Initialize mocks similar to MockitoAnnotations.initMocks(this), also configures strictness
    MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();

    @After public void after() {
        //After the test has completed, we detect unused stubs and validate mockito usage
        mockito.finishMocking();
    }

    //start and finish mocking invocations can be hidden in a common test base class
    //or abstracted out in unit test framework specific way (custom rule, etc.)

    @Test public void some_test() {
        //...
    }
}    
```

### Alternative new public API methods

(no longer considered since the feature is merged)

```java
//1
MockitoMocking mockito = Mockito.startMocking(this, Strictness.STRICT_STUBS);
mockito.finishMocking();
//2
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
//3
MockitoSession mockito = MockitoSessionBuilder.mockitoSession().testClassInstance(this).strictness(Strictness.STRICT_STUBS).start();
mockito.stop();
```

### Discussion

- other ideas to meet the goal (better debuggability / cleaner tests without JUnit)
- good naming / API for the feature
- consistency with existing support for strictness with Runner and the Rule

We would love to hear your feedback!","Here's my opinion :

* Regarding alternative 1/2/3, I prefer the API with an actual variable. Using static methods requires a hidden thread local state, while it's ok for stubbing, I think this could be bad design choice for the mockiting session. Also without `MockitoSession` variable it's hard to interact with, and always requires some static method.
* Not in favor of option 1, as it kinda dismiss the builder style API. And it's probably harder to evolve such API in a non breaking way.
* Not in favor of option 3, regarding the `testClassInstance` as it does not explain what it does with the test class instance. While `initMocks` suggests the behavior behind this.
* I don't mind having the static factory method on either `MockitoSession` or `Mockito`, both are good. A `Mockito` start point would probably be more discoverable though and will get along other lifecycle Mockito methods, like `reset`, `validateUsage`, etc... While `MockitoSession` could be an opportunity to have a more focused API. =||= @bric3, great feedback!!!

I summarized my POV in (https://github.com/mockito/mockito/pull/865#discussion_r96154733).

>Regarding alternative 1/2/3, I prefer the API with an actual variable.

All options are using variable, I removed it for clarity (but it became less clear :) I will update the ticket.

>I don't mind having the static factory method on either MockitoSession or Mockito, both are good. A Mockito start point would probably be more discoverable though and will get along other lifecycle Mockito methods, like reset, validateUsage, etc... While MockitoSession could be an opportunity to have a more focused API.

Yes. Both approaches have pros and cons. Let's go ahead with Mockito.mockitoSession() at this time. =||= > All options are using variable, I removed it for clarity (but it became less clear :) I will update the ticket.

ok 

> Yes. Both approaches have pros and cons. Let's go ahead with Mockito.mockitoSession() at this time.

That's fine by me :) =||= Closed via #865 =||= ",0
865,898,Design MockitoSession API improvements for unit test frameworks,"It is desired that JUnit rule / runner uses MockitoSession API (#865) so that they dogfood our public API. In order to do that we need to do more design work.

Mockito Session API (#865) is geared towards using it in 'setup' and 'tear down' methods of the unit test framework. In 'tear down' method, the user does not have access to the exception (test failure). In JUnit rule, we do have access to the exception and we can leverage it for better user experience. We can prevent dual failure when validating mockito usage fails, on top of the actual test failure. Dual failure could be confusing to the user. When Mockito Session API is used, we cannot really avoid dual failure. Dual failure is relatively minor problem, the test failure is reported by JUnit first, before any potential framework validation problem.

JUnit runner is even more interesting. Unlike the rule, the runner has access to extra test lifecycle events like ""before all tests"" and ""after all tests"".

This ticket is a placeholder for design work on growing MockitoSession API so that it can be used by runner and the rule. While growing MockitoSession API we can potentially expose MockitoTestListener. All that work has lower priority than getting the MockitoSession API released. I suggest we even wait for user's feedback before we start growing MockitoSession API.",This was fixed in #865 =||= ,0
865,384,JUnit rule logs warnings about unsued / misused stubs,"### Why

When test fails, the failure might be caused by misused stubs. Hence, it might be worth to log out debugging information to the System out (e.g. misused stubs, unused stubs). For more details see documentation for [MockitoHint](https://static.javadoc.io/org.mockito/mockito-core/2.5.0/org/mockito/quality/MockitoHint.html).

### Plan
- [x] document 2.x change
- [x] tweak the warning message
- [x] add behavior to the runner
- [x] add silent runner
- [x] add silent setting to the rule (or warnings level for all / exception only / none)
- [x] deprecate/remove console spamming runner
### Impl

The JUnit rule or the runner will potentially include following info in the output (somehow): https://gist.github.com/szczepiq/38619fd8766c66c46dff4dc2b6db06ec

I'm wondering if ""Mockito.validateMockitoUsage();"" should automatically print warnings. We could provide boolean parameter to control printing of the warnings.","On it.
 =||= I like the feature! What do you think about a `rule().strict()` that doesn't emit logs but fails asap?

A note to the API:
- How do we prevent misuse like -> `rule().strict().strict()` ? What about `rule(LOG_WARNINGS)` aka `rule()`, `rule(SILENT)`, `rule(FAIL_FAST)`
 =||= Christian, very cool ideas!!! 

I'm not sure I'll have time for it before 2.0. However, I want the new default behavior in rule / runner in 2.0 so that users see what it is doing. Then we can grow and add strict mode.
 =||= @szczepiq: I like this feature very much. Also that the `MockitoJUnitRunner` fails by default is good. I think a note in the javadoc of `UnnecessaryStubbingException` to use `MockitoJUnitRunner.Silent` would be helpful.

We often have quite complex test fixtures, and it's cumbersome to switch absolutely each and every stub on or off... some methods simply have to be there; it's also not necessary to verify if they've been invoked. So it would be great to be able to disable it for some stubs, but leave it on for others.
 =||= @t1 That seems like a reasonable idea. Want to make a PR for that?
 =||= Good feedback. I think that MockitoHint class should also mention that it is possible to silence the new mechanism.
 =||= #609
 =||= The [MockitoHint](http://site.mockito.org/mockito/docs/current/org/mockito/quality/MockitoHint.html) documentation seems to indicate that this will give you warnings about mismatched arguments, when using the MockitoJUnitRunner.  However, from my experience this doesn't seem to work with Mockito 2.1.

Here's the source I'm trying:

``` java
Foo foo = mock(Foo.class);
when(foo.bar(""baz"")).thenReturn(""bar"");

foo.bar(""baz"");
foo.bar(""test""); // expected to get a warning here
```

Is there something else I need to do to enable this functionality?
 =||= Thank you for feedback!

> Is there something else I need to do to enable this functionality?

This is how they were implemented. Runner should also report mismatches because it helps with debugging. The reason it does not do it today is because I wanted to limit the noise.

We will fix this issue. Also, we will consider always printing warning when stub args mismatch, even if one does not use runner / rule.

Do you want to open a separate ticket to track this improvement?

Thanks for reporting!
 =||= I've opened #725 to track this.
 =||= Came across this after running into this in my test :
```
[MockitoHint] MyTest.checkSomething (see javadoc for MockitoHint):
[MockitoHint] 1. Unused -> at MyTest.test1(MyTest.java:584)
```
It is complaining about this (line 584):
```
   when(mockObject.getPeerHost()).thenReturn(""peer-host-from-mock"");
```
Now my issue is this: this particular method `getPeerHost()` is indeed not called when the code works as expected e.g. something like this:
```
   if (newMethod()) {
      ...
       String peerHost = mockObject.getPeerHost();
       // use peerHost in further processing
      ...
   }
```
`newMethod()` is the new code being added and should correctly return `false`. However if there is a bug in `newMethod()` and it returns `true` then I want `getPeerHost()` to return some value which will cause a failure that I can detect. So this requires me to mock a method even if it is not called in normal processing and there is no bug in the code. I think that should not generate a warning. Has this been addressed? =||= Do I need to open a new issue as I cannot reopen this? =||= > Do I need to open a new issue as I cannot reopen this?

Yes, please.

> Has this been addressed?

Yes. For example, you can use ```lenient().when(...)``` stubbing to avoid reporting an unused stubbing. However, in your test case, I would simply write ```verify(mockObject, never()).getPeerHost();```.

Hope that helps!
 =||= > Yes. For example, you can use `lenient().when(...)` stubbing to avoid reporting an unused stubbing. 

Thanks for the `lenient` tip - that helps.

> However, in your test case, I would simply write `verify(mockObject, never()).getPeerHost();`.
> 

That's more work and more white box testing than I want. Let's say this is for testing the SSL logic where peerHost (of a connection) is matched (or not matched) against ""subject-name"" in a cert under various conditions but I have common setup/initialization where I ""mock"" the peerHost of the connection. In one of the conditions the host-name match is suppressed (i.e. `newMathod()` returns `false`) but because of the common setup code I get the 'unused' warning from `MockitoHint` for that test. =||= My recommendation is to use lenient() + strict stubbing for this use case.

If you feel we should still discuss the use case ``verify(never())`` vs. ``when(...).thenThrow(...)`` then please open a separate ticket.

Hope that helps and thank you for feedback! =||= ",0
867,866,"When custom exception fillInstackTrace() returns null, Exception mock cannot work properly","```java
public class CustomException extends Exception {

    public CustomException() {
        super();
    }

    @Override
    public Exception fillInStackTrace() {
        return null;
    }
}
```

TestCase like this
```java
 when(demo.process()).thenThrow(new CustomException())

//... test code
```

```
java.lang.NullPointerException
	at org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter.filter(ConditionalStackTraceFilter.java:23)
	at org.mockito.internal.stubbing.answers.ThrowsException.answer(ThrowsException.java:32)
	at org.mockito.internal.stubbing.StubbedInvocationMatcher.answer(StubbedInvocationMatcher.java:35)
	at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:95)
```","This is a bug in the user code. Yet Mockito should handle that gracefully.

Thanks for reporting. =||= ",0
868,860,Jacoco 0.7.8 breaks tests for the new plugin mechanism,"Jacoco 0.7.8 breaks the tests for the new plugin mechanism (#811) with:

```
:test

org.mockitoutil.ClassLoadersTest > cannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded FAILED
    java.lang.AssertionError: 
    Expecting a throwable with cause being an instance of:
     <java.lang.NoClassDefFoundError>
    but was an instance of:
     <java.lang.IllegalStateException: java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$2 with modifiers ""private static transient"">
        at org.mockitoutil.ClassLoadersTest.cannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded(ClassLoadersTest.java:324)

org.mockitoutil.ClassLoadersTest > can_run_in_given_classloader FAILED
    java.lang.IllegalStateException: Given task could not be loaded properly in the given classloader 'org.mockitoutil.ClassLoadersTest$1@46dcdf84', error 'java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$1 with modifiers ""private static transient""

        Caused by:
        java.lang.IllegalStateException: java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$1 with modifiers ""private static transient""

            Caused by:
            java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$1 with modifiers ""private static transient""

org.mockito.internal.configuration.GlobalConfigurationTest > returns_mockito_annotation_engine_of_Plugins_if_no_MockitoConfiguration FAILED
    java.lang.IllegalStateException: Given task could not be loaded properly in the given classloader 'org.mockito.internal.configuration.GlobalConfigurationTest$1@5adb485', error 'java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockito.internal.configuration.GlobalConfigurationTest$1 with modifiers ""private static transient""

        Caused by:
        java.lang.IllegalStateException: java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockito.internal.configuration.GlobalConfigurationTest$1 with modifiers ""private static transient""

            Caused by:
            java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockito.internal.configuration.GlobalConfigurationTest$1 with modifiers ""private static transient""

1701 tests completed, 3 failed, 42 skipped
:test FAILED
```

The corresponding Travis build: https://travis-ci.org/mockito/mockito/jobs/187043982#L431",@bric3 Can you identify the minimal scenario that reproduce this issue to be able to report it to the JaCoCo team? =||= ,0
880,879,Grammar issue in ArgumentMatchers' javadoc.,"[`ArgumentMatchers`' javadoc](https://static.javadoc.io/org.mockito/mockito-core/2.6.1/org/mockito/ArgumentMatchers.html) states that:

> This implementation is due static type safety imposed by java compiler. 

There's a word missing there. It should read:

> This implementation is due **to** static type safety imposed by java compiler. 

Version info:
- First noticed this on 2.5.5
- Confirmed it still existed in 2.5.6, 2.5.7 and 2.6.1
- Probably also existed in previous versions.","@TimvdLippe should this issue be closed now that the PR is merged, or should this fix be backported to the 2.x branch too? =||= @mureinik Oh right it was to the wrong branch 😭 That's my mistake. I will backport it manually =||= ",0
881,879,Grammar issue in ArgumentMatchers' javadoc.,"[`ArgumentMatchers`' javadoc](https://static.javadoc.io/org.mockito/mockito-core/2.6.1/org/mockito/ArgumentMatchers.html) states that:

> This implementation is due static type safety imposed by java compiler. 

There's a word missing there. It should read:

> This implementation is due **to** static type safety imposed by java compiler. 

Version info:
- First noticed this on 2.5.5
- Confirmed it still existed in 2.5.6, 2.5.7 and 2.6.1
- Probably also existed in previous versions.","@TimvdLippe should this issue be closed now that the PR is merged, or should this fix be backported to the 2.x branch too? =||= @mureinik Oh right it was to the wrong branch 😭 That's my mistake. I will backport it manually =||= ",0
881,879,Grammar issue in ArgumentMatchers' javadoc.,"[`ArgumentMatchers`' javadoc](https://static.javadoc.io/org.mockito/mockito-core/2.6.1/org/mockito/ArgumentMatchers.html) states that:

> This implementation is due static type safety imposed by java compiler. 

There's a word missing there. It should read:

> This implementation is due **to** static type safety imposed by java compiler. 

Version info:
- First noticed this on 2.5.5
- Confirmed it still existed in 2.5.6, 2.5.7 and 2.6.1
- Probably also existed in previous versions.","@TimvdLippe should this issue be closed now that the PR is merged, or should this fix be backported to the 2.x branch too? =||= @mureinik Oh right it was to the wrong branch 😭 That's my mistake. I will backport it manually =||= ",0
884,882,Upgrading to Objenesis 2.5,"Mockito already uses Objenesis 2.4.
However Objenesis 2.5 was just released and supports the latest [JDK 9 build 151 jigsaw](http://objenesis.org/notes.html)",nan,0
885,878,@Spy dosn't report the correct error when it can't instantiate abstract class,"The annotation engine doesn't inform the user correctly when the spying an inner `private static abstract class`.

```
org.mockito.exceptions.base.MockitoException: Unable to initialize @Spy annotated field 'a'.
null

	at org.mockito.internal.configuration.SpyAnnotationEngine.process(SpyAnnotationEngine.java:70)
	at org.mockito.internal.configuration.InjectingAnnotationEngine.processIndependentAnnotations(InjectingAnnotationEngine.java:59)
	at org.mockito.internal.configuration.InjectingAnnotationEngine.process(InjectingAnnotationEngine.java:41)
```

Indeed when the class is private, javac still generates a synthetic 1-arg constructor taking the enclosing class.

That should be easy to improve, as the `SpyAnnotationEngine` just needs to report an error message for this case.",nan,0
886,871,Travis builds from non-core developers fail on assertEnvVariables,"Example build: https://travis-ci.org/mockito/mockito/jobs/188911380

Seems that this does not affect core developers, as my build has been succesful: https://travis-ci.org/mockito/mockito/builds/188321204 as well as those in #865 and #859","I think the easiest solution is to not assert the GH_TOKEN if the build is a pull request =||= Can't we just disable the checks if the repo is not mockito/mockito ? =||= Pull requests always have `mockito/mockito` as repository? =||= No only ours, external contributors have a fork. Since the GH_TOKEN assertion don't fail for our pull request I think this is safe assumption. =||= @szczepiq could you make this high priority on your list? Failing builds discourages external developers from publishing their work =||= ",0
887,882,Upgrading to Objenesis 2.5,"Mockito already uses Objenesis 2.4.
However Objenesis 2.5 was just released and supports the latest [JDK 9 build 151 jigsaw](http://objenesis.org/notes.html)",nan,0
891,874,Overridden abstract methods using generics are not longer called for partial mock (working with Mockito 1.10.19),"Hi,

We migrated to Mockito 2.x not so long ago and we came across a test that used to works back in Mockito 1 (1.10.19) and no longer works with the latest 2.x version (2.5.6).

Here is the SSCCE to replicate the issue:

```
package com.some.company;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;

import javax.swing.JButton;

import org.junit.Test;

public class Mockito2Issue
{
	public abstract class SomeAbstractClass<T>
	{
		protected abstract String getRealValue(T value);

		public String getValue(T value)
		{
			return getRealValue(value);
		}
	}

	public class SomeConcreteClass<T extends java.awt.Component> extends SomeAbstractClass<T>
	{
		@Override
		protected String getRealValue(T value)
		{
			return ""RealValue"";
		}
	}

	@Test
	public void testBug() throws IOException, InstantiationException, IllegalAccessException, InvocationTargetException
	{
		SomeConcreteClass<java.awt.Component> testBug = spy(new SomeConcreteClass<java.awt.Component>());
		assertEquals(""RealValue"", testBug.getValue(new JButton()));
	}
}
```

**Before (1.10.19):**
Used to works

**After (2.5.6)**
```
java.lang.AssertionError: expected:<RealValue> but was:<null>
	at org.junit.Assert.fail(Assert.java:91)
	at org.junit.Assert.failNotEquals(Assert.java:645)
	at org.junit.Assert.assertEquals(Assert.java:126)
	at org.junit.Assert.assertEquals(Assert.java:145)
	at com.some.company.Mockito2Issue.testBug(Mockito2Issue.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
```

We performed a few side tests and here are the results:
- if we change the method `getRealValue` in class `SomeAbstractClass` to be non-abstract but rather throw an exception, the test pass:
```
		protected String getRealValue(T value)
		{
			throw new UnsupportedOperationException();
		}
```
- if we no longer use generic on the method (e.g. using Object rather than T), the test pass.

Can you take a look at this?


Environment details:

Component | Version
--------- | ------
OS | Ubuntu 16.10
Java | Oracle Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Eclipse | Neon.2
JUnit | 4.8.2
Mockito | 1.10.19 (before), 2.5.6 (after)","This is probably a regression after adopting Byte-Buddy. @raphw did you encounter such issues with Byte-Buddy? =||= It is indeed a problem in Byte Buddy when processing raw types (Mockito extends the generic type without implementing the type variable) in the method graph compiler. I already added a test case to Byte Buddy and I will try to fix the problem some time next week.

I do now understand the problem. Mockito extends `SomeConcreteClass` as a raw type as it does not define any type variables. By this, any type is considered as raw in alignment with the Java specification. Therefore, `getRealValue(Object)` and `getRealValue(Component)` are not merged in the graph and the attempt to invoke `getRealValue(Object)` results in returning `null` via the default answer as it is no longer considered a bridge.

This is actually a bit tricky but I will think of something. =||= Tracked in: https://github.com/raphw/byte-buddy/issues/255 =||= Thanks @domtoupin for the SSCCE !
Thanks @raphw for the quick tracking of the issue. =||= ",0
896,895,Documentation missing clarification for consecutive stubbing,"The [documentation](https://static.javadoc.io/org.mockito/mockito-core/2.6.3/org/mockito/Mockito.html#10) for consecutive stubbing is missing a clarification.

When multiple when/thenReturn statements are being used instead of chaining .thenReturn() statements, each stubbing overrides the existing one.

","I am going to submit a Pull Request, adding an additional clarification with code example in the docs. =||= ",0
905,814,Javadoc links in main Mockito doc are not linkable,"The links to line items in the main [Mockito documentation](https://static.javadoc.io/org.mockito/mockito-core/2.3.0/org/mockito/Mockito.html) are not linkable, e.g. I cannot create a link to item no. 40 in the list.","I don't see what you mean I have no problem for that : 

* https://static.javadoc.io/org.mockito/mockito-core/2.3.0/org/mockito/Mockito.html#40
* https://static.javadoc.io/org.mockito/mockito-core/2.3.0/org/mockito/Mockito.html#strict_mockito =||= At first it seems to be working, but the actual issue is that the first link of @bric3 does work, but the second does not. The problem is that the headers have the second link, so they must be updated to use numbers instead. =||= ",0
907,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
908,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
912,765,Cannot build Mockito on Windows 64b with Java 8 ,"Hi guys,

 I am trying to build Mockito on my Windows 64 machine with jdk1.8.0_66 and the build is failing. I tried the `master `branch and also the `release/2.x` branch, both are having the same problem. 

When I run `gradlew clean build` I am getting:

```
mockito\src\test\java\org\mockitousage\matchers\MatchersTest.java:599: error: unclosed character literal
        mock.oneArg(Character.valueOf('Ôé¼'));
                                      ^
mockito\src\test\java\org\mockitousage\matchers\MatchersTest.java:599: error: illegal character: '\u201a'
        mock.oneArg(Character.valueOf('Ôé¼'));
                                        ^
mockito\src\test\java\org\mockitousage\matchers\MatchersTest.java:599: error: illegal character: '\u00ac'
        mock.oneArg(Character.valueOf('Ôé¼'));
                                         ^
mockito\src\test\java\org\mockitousage\matchers\MatchersTest.java:599: error: unclosed character literal
        mock.oneArg(Character.valueOf('Ôé¼'));
                                          ^
mockito\src\test\java\org\mockitousage\matchers\MatchersTest.java:599: error: ';' expected
        mock.oneArg(Character.valueOf('Ôé¼'));
                                            ^
5 errors
:compileTestJava FAILED
:removeTestResources

FAILURE: Build failed with an exception.
```


After removing the line containing `        mock.oneArg(Character.valueOf('€'));` inside **MatchersTest.java** on line 599, the build works OK.

Anyone else facing similar trouble? 
  

","On Linux this is working fine. I thought that @bric3 (who made the test in https://github.com/mockito/mockito/commit/c9e8562c994d23286d326a8ee19e2598d36ebfda) is on a Mac. I suppose we can alter the value just fine for Windows. We do not build our tests on Windows ourselves, so thanks for trying it out!
 =||= This looks like a character encoding issue, could be any tool.
The last time I checked on Windows there was nothing wrong. I'll recheck when I have access to a windows box.
 =||= Thanks guys! FYI: Just checked on different Windows 64 and build fails there as well.
 =||= Just checked on a Windows VM and the problem does not happen here. Strange. =||= I managed to build it on my Windows 7 64B machine by using `gradlew build -Dfile.encoding=UTF-8`

How I found out:

According to http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html the Java compiler javac uses the default system encoding if the `-encoding` is not specified. My system default encoding in the machine is `Cp1252`, retrieved as a result of gradle task:

```
task printSystemEncoding << {
    println System.getProperty(""file.encoding"")
}
```

Another solution what worked for me was to configure directly the `javac` task to use the `encoding` flag with utf8:

```
tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}
```

The problem is probably that the file `MatchersTest.java` is saved in encoding which is not compatible with the default Windows `Cp1252`. I would like to **suggest** adjustment of the test / providing of default encoding set to utf-8 inside the build. =||= ",0
912,904,Remove unnecessary classes,"Looking at https://codecov.io/gh/mockito/mockito/list/e92b0be0c6362157e2c8ae349a2b9d1295065d2e/src and sorting it by coverage, it appears that there are some classes that are completely untested. Taking another closer look reveals some candidate classes that can be removed. For example `MockitoLimitations` is [only used in the Reporter](https://github.com/mockito/mockito/search?utf8=%E2%9C%93&q=MockitoLimitations), the field can therefore be placed in the Reporter directly.

There are also some debugging and util classes that seem unused. If we do decide to retain them, I think we should test them to actually make sure they are working properly.",nan,0
914,426,Refactor instance based utility classes to static utility classes,"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`","@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= ",0
916,915,Release process failed on 'bumpVersion' release step,"Mockito build failed on ""bumpVersion"" release step ([full log](https://travis-ci.org/mockito/mockito/jobs/196275405), [gist](https://gist.github.com/szczepiq/6fe5853d1f31585605c7ffe645347c69)).

### Root cause

""org.mockito.release-workflow"" plugin ([GitHub repo](https://github.com/mockito/mockito-release-tools)) adds ""incrementVersion"" API method that Mockito uses for release automation. The method is available to users via: ""project.versionFile.incrementVersion()"" in the .gradle files. This method contains a bug: it does not work properly when the version declared in the file does not end with linebreak

### Actions

1. [x] Fix the Mockito 2.7.0 release (no release notes, no tag)
2. [x] Document steps to troubleshoot such problem with release pipeline, and steps to resolve - #916
3. [x] Report and fix bug in release-workflow plugin - [issue reported](https://github.com/mockito/mockito-release-tools/issues/1).
4. [x] Ensure Mockito uses latest version of release tools [""org.mockito.release-workflow"" plugin](https://github.com/mockito/mockito-release-tools) - reported #917","This is a duplicate of #913  =||= Hey @TimvdLippe, I didn't see the other issue reported. I'd prefer to keep this one open because it has more details. =||= BTW. thank you for fast reaction and reporting the issue :) I'm looking into it now. =||= Instead of reopening, you can add the details to the other issue. It does not make sense to keep 2 open =||= I would have to literally copy everything from this ticket to your original report, updating the title, description, etc. I'm not sure if it makes sense right now. I'm using this ticket as a work log. I'll close it once I finish. =||= Already fixed! Reference tickets will be worked on. =||= ",0
931,929,New 'mockito-inline' artifact does not work,"mockito-inline 2.7.2

build.gradle:
```groovy
apply plugin: 'java'

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

repositories {
    jcenter()
}

dependencies {
    testCompile 'junit:junit:4.12'
    testCompile 'org.mockito:mockito-inline:2.7.2'
}
```

Test target:
```java
final class Foo {

}
```

Test for Foo:
```java
public class FooTest {

    @Test
    public void test() {
        Mockito.mock(Foo.class);
    }

}
```

Test command:
```
$ ./gradlew clean test
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test

com.example.FooTest > test FAILED
    org.mockito.exceptions.base.MockitoException at FooTest.java:10

1 test completed, 1 failed
:test FAILED

FAILURE: Build failed with an exception.
```

Test report:
```
org.mockito.exceptions.base.MockitoException: 
Cannot mock/spy class com.example.Foo
Mockito cannot mock/spy because :
 - final class
	at com.example.FooTest.test(FooTest.java:10)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:377)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
	at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
```

### Reason

`mockito-extensions/org.mockito.plugins.MockMaker` is not included in the mockito-inline.jar.
```
$ jar tvf mockito-inline-2.7.2.jar 
     0 Sat Feb 04 12:02:54 JST 2017 META-INF/
    25 Sat Feb 04 12:02:54 JST 2017 META-INF/MANIFEST.MF
```

In [the inline subproject](https://github.com/mockito/mockito/tree/release/2.x/subprojects/inline), org.mockito.plugins.MockMaker is in `src/resources/mockito-extensions` directory.
Is this correct?

In [the android subproject](https://github.com/mockito/mockito/tree/release/2.x/subprojects/android), the file is in src/**main**/resources/mockito-extensions.","Reproducible project:
[mockito_issue_929.zip](https://github.com/mockito/mockito/files/756407/mockito_issue_929.zip)
 =||= Seems like our Gradle build is not set up to include this file on Travis. It does work on my local machine, though. Strange things, thanks for reporting! =||= ",0
933,927,Mockito can't unbox Void,"Hi,

The following [bug](https://github.com/powermock/powermock/issues/708) was created for PowerMock:  

> PowerMockito doesn't seem to unbox java.lang.Void.
> I am writing a test for my code that uses Google cloud storage API to delete a file. Google API returns Void for deleting a file. Code works fine but when I instruct my test as PowerMockito.doNothing().when(delete).execute(); It complains that execute has a return value of Void.

But PowerMock just delegates call to Mockito in this case and Mockito throws exception: 

```
org.mockito.exceptions.base.MockitoException: 
Only void methods can doNothing()!
Example of correct use of doNothing():
    doNothing().
    doThrow(new RuntimeException())
    .when(mock).someVoidMethod();
Above means:
someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called
```

I have doubts about expected behaviour. For one side, method return something, but it return a `Void` which always is just `Void` and nothing could be changed. 

Anyway, it could be fixed only on Mockito side (without dirty hacks). ",nan,0
935,685,Support constructor parameters for spying on abstract classes,"Nice, self-contained enhancement that makes Mockito API more robust. The implementation does not require proficiency with Mockito codebase.

### Feature

We already support spying on abstract classes by allowing parameterless constructor. However, there is no support for constructor parameters. This has been asked about long time ago. Mockito API is not robust enough if it supports mocking with constructor **but** not when one has any constructor parameters.

``` java
//current api:
Foo spy = mock(Foo.class, withSettings() .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
//existing method (will remain):
MockSettings useConstructor();

//new api (change existing method):
Foo spy = mock(Foo.class, withSettings() .useConstructor(""someArg"").defaultAnswer(CALLS_REAL_METHODS));
//changed method:
MockSettings useConstructorArgs(Object ... args);
```

### Open questions

- in case we find multiple matching constructors, do we just use the 1st matching (option 1) or throw an exception (option 2)?

I'd say we go for option 1 because it's simpler to implement and seems more convenient (works out of the box for certain use cases). If we go for option 2 we need to inform the user what to do to resolve the problem (for example document and suggest @fluentfuture idea of creating an inner implementation)

- do we add new method or add vararg to existing useConstructor() method?

We decided that using existing method is simpler, keeps the API small and is easy to discover.

### Implementation notes

- the main complexity is to identify and detect the right constructor to use based on types of parameters supplied by the user
- we already deal with detecting constructors for the @InjectMocks functionality - there should be code to reuse

### Test coverage

- see existing tests that cover ""useConstructor"" method for
- ensure decent, informative exception messages
  - if user supplies wrong constructor args (wrong types, we cannot find matching constructor)
  - if the constructor throws some exception (constructors of some types have code that can fail)
  - when one uses existing parameter-less ""useConstructor"" method but the mocked class requires constructor args, the exception message should tell the user about new ""useConstructorArgs"" method.
- what if arguments supplied by the user match more than 1 constructor - either we fail gracefully with decent message or we pick one of the constructors.
- update documentation to describe new feature. Update documentation for existing parameter-less ""useConstructor"" method. Update documentation in main Mockito class if it references “useConstructor”.
- other use cases?","I've thought about some variant of this feature for a while, so here's some feedback.

It'd be nice if we have some concrete use cases to study.

In my own experience, I have mostly managed to avoid needing this feature by spying non-static abstract class.

For example, if the abstract class I'm spying on needs two constructor parameters, I do this:

```java
public class FooTest {
  @Spy private MockAbstractFoo foo;
  private final Bar bar = ...;

  private Baz baz() {...}

  abstract class MockAbstractFoo extends AbstractFoo {
    MockAbstractFoo() {
      super(bar, baz());
    }
  }
}
```

Fwiw:
1. This is static type safe, and refactoring friendly. So I find it preferable when it meets my needs.
2. The constructor can use instance fields or instance methods of the enclosing test object.
3. The main drawback is that you can't easily construct difference instances with different constructor parameters. On the other hand, I strive to keep my abstract classes stateless so I rarely need to pass constructor parameters anyway.

 =||= I forgot to mention that it is possible with today's API to pass different constructor parameters, through MockSettings. Like the following:
```java

class MockFooFactory {
  private final Bar bar;
  private final Baz baz;

  MockFooFactory(Bar bar, Baz baz) {...}

  public AbstractFoo create() {
    return Mockito.mock(MockFoo.class, withSettings()
        .useConstructor().outerInstance(this).defaultAnswer(CALLS_READ_METHODS));
  }

  abstract class MockFoo extends AbstractFoo {
    MockFoo() {
      super(bar, baz);
    }
  }
}
```
Then just call it with:
```java
new MockFooFactory(bar, baz).create();
```

Again, this is static type safe and IDE friendly compared to reflection-based API.

The `withSettings()` thing has a bit of discoverability problem and I suppose not many people know they can do this. Alternatively, I would love to have a simpler API, like:
```java
Mockito.spy(outerInstance, MockFoo.class);
```
 =||= I think that overloading `useConstructor()` is a much cleaner approach than adding a new `useConstructorArgs(Object...)` method.
It also makes the method much easier to discover, as it's right there, and the user's IDE will offer the argument list.

I've coded this approach in PR #935. Feedback is more than welcome! =||= Agreed that ```useContructor(args...)``` reads nicer.

Personally, I'm not convinced that the dynamic type support is worth the effort. It seems to be a slippery slope toward defeating Java static type safety, which reminds me of the ancient JMock vs. EasyMock comparison where the former relied on type-less reflection while the latter is static type safe. If Java doesn't allow you to call `new Foo(Object, Object)`, does Mockito have to open that back door (when the enclosing class trick could be used to achieve the goal, albeit slightly indirectly)?

That said, if you do decide to add this feature, there are a few implementation caveats that we need to be careful about:
* Overload resolution. It's not hard to imagine passing an arg whose static type suggests constructor overload1 to be invoked, but the runtime type actually invokes overload2. In other words, `new Foo(a, b) {...}` and `useConstructor(a, b)` result in different constructor being invoked.
* Generics. There is no way to verify that the passed in `List<Something>` is actually a `List<String>`, even at runtime, risking unchecked type errors.
* Visibility. What happens if the constructor has both public constructor and package-private constructor both could have been chosen for the given args?




 =||= I happened to need to dig up the history of @Spy AbstractClass in #106. And I found that all my concerns against constructor-args were already stated in that thread. And it was clear that @szczepiq is fine with the trade-off.

So, while I disagree with the design decision, my apologies for repeating myself over again. :) =||= Thank you very much for contribution. It's really nice work! =||= ",0
942,680,Allow spying on interfaces so that it is convenient to work with Java 8 default methods,"## Problem

While Mockito supports and stubs by default the _default methods_ in interfaces, the stubbing code can be a bit non intuitive, e.g.

``` java
interface DM {
    int contract();
    default int default_contract() { return contract() + 1; }
}

DM dm = mock(DM.class);
given(dm.contract()).willReturn(2);

// necessary otherwise default method is stubbed
given(dm.default_contract()).willCallRealMethod();

assertThat(dm.default_contract()).isEqualTo(3);
```

This behavior is unintuitive to users who expect the default methods to trigger real implementation (callRealMethod() by default). See also user report at #940.

## Suggested plan

:1st_place_medal: Contributions are welcome!

- [x] relax validation and allow interfaces to be spied. This way users can invoke spy(SomeInterface) or use @Spy with interfaces. This way, we don't need to mark default methods with ""callRealMethod"".
- [x] ensure test coverage for mocking
  - interfaces with and without default methods
  - concrete classes that extend interface with default methods (perhaps already covered)
- [x] document this use case. On main Mockito javadoc the use can search for ""default"" and find information about default methods behavior. Suggested by user at #940.
- [ ] create a separate ticket for Mockito 3 (""2.* incompatible"" label) to discuss whether we should change the default behavior for defender/default methods. Perhaps they should automatically call real method regardless if someone uses spy() or mock() with the interface. Also we should consider mocking/spying on concrete classes that extend from interface with default methods.

## Discontinued ~~original plan~~

Below idea was discontinued:

Replace `DM` by `Map`, `default_contract()` by `getOrDefault()`, `contract()` by `get()` or `containsKey()` and you have a problem with designs that are used in the JDK itself.

I think mockito can improve on this by configuring the mock to invoke concrete default methods rather than stubbing them. This could be done the following way (_api naming in progress_) : 
- `mock(DM.class, USE_DEFAULT_METHODS)`
  
  The issue with that approach is that a default answer is mutually exclusive with other answers. e.g. if one wants to use `RETURNS_SMART_NULLS` and default methods this cannot work with the current design.
- `mock(DM.class, withSettings().useDefaultMethods())`
  
  This approach is interesting as it allows to configure the behaviour with possibly any answer. However this may require some changes with our internal answers, not a deal breaker though.","> mock(DM.class, withSettings().useDefaultMethods())

I like that. 'spyDefaultMethods'?

BTW. What's better/more intuitive default for default methods? real method invocation or empty/unstubbed value?
 =||= I think that depends on the mocked type. I'd say :
- interface => use default methods by default
- concrete => I'm not sure I'd rather not make those default

`spyDefaultMethod` is wrong because the primary objective is not to spy them.
 =||= So potentially this is Mockito 3 backwards incompatible change (when changing defaults). Thanks for bringing this up!
 =||= For this thing only this could be potntially backward incompatible. Yet for this thing only I'm not yet sure we should change the default between 2.x and 3.x whatever the introduction or not of `useDefaultMethods` in `2.x`. 

I'm a bit undecided at that moment. I may have a better opinion when the code is actually done. 

Right now the code base of mockito 2.x runs Java6 so we don't have Java 8 tests, Mockito 3 (master) is Java 8 and we'll introduce Java 8 specific tests.
 =||= Makes perfect sense.

We already have code in 2.x that detects java 8. Up to you how to push that further ;)
 =||= If starting from scratch, I couldn't think of a use case that'd benefit from stubbing the default methods by default.

But maybe that use case does exist, or at least for backward compatibility it's too late to change?

Either way, I propose we do not need to add a default Answer or anything to mock(). 

Default methods in interfaces are much like concrete methods in abstract classes. `spy(AnAbstractClass.class)` today already _by default_ invokes concrete methods unless they are explicitly stubbed. It seems natural to me that we just relax the restriction on `spy(SomeInterface.class)` to accept interface as a parameter instead of throwing illegal usage exception as it does today.
 =||= @fluentfuture Can you elaborate on that : 

> It seems natural to me that we just relax the restriction on `spy(SomeInterface.class)` to accept interface as a parameter instead of throwing illegal usage exception as it does today.

Yes backward compatiblity is a primary concern. Yet if the change makes sense and doesn't impact users in a bad way it can be discussed.
Also maybe we could backport behavior and API from master to release/2x. =||= Sure.

Today, if java.util.Consumer were an abstract class defined as:

```java
public abstract class Consumer<T> {
  public Consumer<T> andThen(Consumer<? super T> that) {
    return v -> {accept(v); that.accept(v);};
  }

  public abstract void accept(T value);
}
```

I can `@Spy` it to have `andThen()` called by default:
```java
@Spy private final Consumer<String> consumer1;
@Spy private final Consumer<String> consumer2;

@Test public void testCompose() {
  consumer1.andThen(consumer2).accept(""hi"");
  verify(consumer1).accept(""hi"");
  verify(consumer2).accept(""hi"");
}
```

It doesn't work with Consumer being interface with `andThen()` being an equivalent default method:

```java
public interface Consumer<T> {
  default Consumer<T> andThen(Consumer<? super T> that) {
    return v -> {accept(v); that.accept(v);};
  }

  void accept(T value);
}
```

But that is just because we are having a validation that rejects spy(Consumer.class). That validation can be removed because it doesn't hurt even if you spy(AnInterface.class) and even if that interface has no default method, because it will just work the same way as mock(AnInterface.class).

Here's a [commit](https://github.com/fluentfuture/mockito/commit/afdd5ebc32de38d098c517bda32c83e194371574) in my fork that removes the validation and the above test passes.


By the way, I retract my suggestion to make `mock(AnInterface.class)` to call default methods, because then it would break the symmetry with `mock(AnEquivalentAbstractClass.class)`, which can be surprising. =||= Ah I see.

Imho spying an interface `spy(Interface.class)` is wrong, even when there's default methods, it doesn't feel like a a spy. As spy have more meaning to spy concrete code.

Instead mocking an interface `mock(Interface.class)` to call default methods only seems ok. And maybe backward compatible. Although I would like opt-in/out mechanism.
But mocking an abstract class `mock(AnEquivalentAbstractClass.class)` should never call concrete code. =||= I agree that the spy() name is kinda misleading for the behavior of ""mock only abstract methods"".

I originally proposed fake() or other names but spy() was chosen none-the-less.

I don't defend the spy() name but it's what we have, so there may be some value to consistency.

 =||= `spy` is a specialized mock that seems to _speak_ for everyone, maybe `fake` can be another compelling specilization.

At this moment not sure if we will, but maybe in the future. =||= Here's how I found peace with the spy() name:

Yes it calls the non-abstract methods, which isn't spying (more like fake). But it also allows you to explicitly stub them with `when()` or to `verify()` them, so in that sense, it can still be called a spy. =||= Regarding ""interface"" vs. ""abstract class"", I personally think we should try not to be picky about the difference.

Some project scoped or company scoped APIs out there aren't designed to be implemented/subclassed directly by users. For these APIs, going from an abstract class to interface or vice versa is reserved as an implementation detail change.

The worst that should happen with changing abstract class to interface is that a handful of direct subclasses break compilation and need to be fixed to use the ""implements"" keyword.

It'd be a much bigger burden if all the sudden a lot of tests that used to spy() on the abstract class fail just because of the abstract -> interface change.

Specifically, now with Java 8, I'd expect some abstract classes to become interfaces with default methods because the only reason they were abstract classes in the first place was to be able to have some default methods (for fluent chaining and stuff). =||= Interesting feedback. I still have mixed feeling about relaxing spy to allow an interface.
I'll sleep on it, and think about it as your migration use case is legitimate.

And anyway this address only a part of the original issue. =||= @bric3 Can you explain which part isn't addressed in the original issue, assuming we put aside the mock() vs. spy() naming difference? =||= @fluentfuture I meant regarding configurability of stubbing default method for a mock, not a spy.

Yet the use cases discussed above are defintely additional scenario to account for when we will implement the stuff. =||= @bric3 Are you okay with allowing @Spy on interfaces? If so, I'll send a PR. =||= @fluentfuture yes. I have worked on it in #906. But I won't have a computer near me for a week still. =||= Great discussion. 

+1 to allow spying on interfaces
-1 to adding new public API method like 'fake' - it would make the api more complicated just for the sake of a single use case
+ 0.5 to changing the default behavior of Mockito 3 to 'spy' interface defender methods by default. This way it is the most intuitive behavior users expect. See https://github.com/mockito/mockito/issues/940 =||= I attempted to update the ticket description to reflect the outcome of the discussion. Feel free to change if needed. =||= If I were going to add another method I would call it `stub` based on [Martin Fowler's article describing the 3]( https://martinfowler.com/articles/mocksArentStubs.html).

Seems like `@Incubating Mockito.spy( Class<?> clazz )` more or less does what I expect. Ultimately finding that behavior though required quite a bit of research.

Whether or not adding `Mockito.stub( Class<?> clazz )` method would be worth it I can't say because I don't feel like I'm familiar enough with the underlying implementation/behavior to know how different `mock` and `spy` are. If those are just configuration differences then it's probably worth it, if there's more to it, maybe not. If `stub` could `CALL_REAL_METHODS`, but only work for `abstract` and `interface` and not be able to do `verify` that would make it different from a `spy`, imo.

Either way, more docs seem necessary. I might try to put those together for #940  =||= I somehow missed this ticket. 

Mockito should imho follow the idea of defender methods and allow API-evolution without  breaking client code/test. I other words if a class under test evolves and calls defender methods on a mocked interface the tests should not fail or should not be rewritten by replacing `@Mock` with `@Spy` or setting up special mocking settings like `withSettings().useDefaultMethods()`.

I think it is possibe to rewrite the `mock(..)` implementation to generate stubbed calls to default methods  without special mock settings.  

```java
public <T> T mock(Class<T> type){
    T mock=MOCKITO_CORE.mock(type);
    if (!typeToMock.isInterface())
            return mock;

    for (Method method : typeToMock.getDeclaredMethods()) {
        if (method.isDefault()) {
            doCallRealMethod().when(mock);
            callWithAnyMatchers(mock, method);
        }
    }
    return mock;
}

private static void callWithAnyMatchers(Object mock, Method method) {
    Class<?>[] parameterTypes = method.getParameterTypes();
    List<Object> defaultValues = new ArrayList<Object>();
    for (Class<?> type : parameterTypes) {
            defaultValues.add(Mockito.any(type));
    }
    
    try {
        method.invoke(mock, defaultValues.toArray());
    } catch (Exception e) {
        throw new MockitoException(e.getMessage(), e);
    }
}


```
This way clients can redefine the defender stubbings like overriding it in an implementation. 

@bric3 
@szczepiq 
@fluentfuture 
What do you think?


 =||= Is it any different from API-evolution of abstract classes?

In template-method pattern, if the SUT calls an abstract method, and then later evolves to call a default method that indirectly calls the abstract method, the exact same problem can happen, no?

This kind of evolution has always been possible. And it's not clear to me that the user always means to only stub/verify the abstract method. Sometimes the user may just want to stub/verify the method directly called, abstract or not.

It seems to me not the mocking framework's responsibility to guess the user's intention. Instead, if the user wants to stub/verify the direct method invocation, use `@Mock;` while if the user wants to stub/verify abstract methods, use `@Spy`.

 =||= > Is it any different from API-evolution of abstract classes?
>
>In template-method pattern, if the SUT calls an abstract method, and then later evolves to call a default method that indirectly calls the abstract method, the exact same problem can happen, no?

I agree if you see it like that they are pretty equal.

I want to avoid that `@Spy` is misused to stub in the first place. The word ""spying"" implies that there is something to spy on (the SUT), but for interfaces the ""spying"" make no sense we would spy on a mocked interface. 

>It seems to me not the mocking framework's responsibility to guess the user's intention. 

I agree here too! What about a littel helper that create stubbings that call the real default method:  `Mockito.delegateDefaultMethodsToReal(mockedInterface)`
 =||= I still suggest `stub` as the method name for that per previous reasons cited =||= Did a bit of archeology. #106 has a discussion both about the API and the naming.

In that thread I argued against `spy`: ""All the use cases I know of for partial mocking don't need spying"". 

At the time ""stub"" wasn't suggested but now I think about it, it seems to make sense.

Although, changing it may mean to introduce a new `@Stub` annotation, and deprecate `@Spy AbstractClass`, if we are willing to consider the ship not sailed yet. =||= Interesting discussion! Thank you for all suggestions.

>the tests should not fail or should not be rewritten by replacing @Mock with @Spy or setting up special mocking settings like withSettings().useDefaultMethods().

You are right. Ideally the tests only fail when a bug is introduced.

I have a feeling the discussion is getting broader and I am not sure if still discusses the issue reported :) My immediate reaction to new `@Stub` interface and potential deprecation of `@Spy` is -1 because I don't see clear value. However, please formulate a separate ticket with the use case, code samples, and the team will for sure review it!

Coming back to the original issue: relaxing spy annotation for interfaces is useful for spying on interfaces with default methods. The use case is reasonable and team is +1 to the change. Do we have new data / use cases that indicate that this change inappropriate? =||= ",0
972,688,Enabled mocking interface clone method,"Mocking a `clone()` method on an interface appears to no longer be working with **Mockito 2.1.0**. The below code works fine with **Mockito 1.10.19** but throws an `IllegalAccessError` with **Mockito 2.1.0**:

```
public interface CloneableInterface extends Cloneable {
   CloneableInterface clone();
}

public class CloneableInterfaceTest {

   @Test
   public void test() {      
      CloneableInterface i = Mockito.mock(CloneableInterface.class);
      Mockito.when(i.clone()).thenReturn(i); // Throws IllegalAccessError
   }
}
```

Result of running above test:

```
java.lang.IllegalAccessError: CloneableInterface$MockitoMock$833899610.clone()LCloneableInterface;
```

Environment: **JDK 1.8.0_102, JUnit 4.11, Mockito 2.1.0, Gradle 3.0, Windows 10**

EDIT: Link to [SO post](http://stackoverflow.com/questions/39967723/mocking-interface-clone-method)","I see what is happening here. Since `Object::clone` is protected and since Java favors subclass inheritance over interface inheritance, the subclass overrides clone as a `protected` method, rather than a `public` method. Of course, Mockito should render all mock methods public, currently we are not doing this but this is trivial to fix.

Thanks for reporting this.
 =||= @raphw thanks for the quick response. Ah, your root cause analysis makes sense. I suppose this is a bit of a corner case and completely understand why it would have been overlooked. Looking forward to the fix as this is the final item blocking us from upgrading to 2.1.0. Thanks for all the great work.
 =||= @jpenglert It should be fixed in `Mockito 2.2.1`, thanks a lot for reporting!
 =||= Unfortunately maven sync is disabled thanks to #683 
 =||= Triggered central sync. @bric3, I will enable sync now. I wanted to manually verify few releases.
 =||= Thanks @szczepiq 
 =||= This bug appears to be back after I upgraded from Mockito 2.2.1 -> 2.7.13. The original test case I posted is failing in the same manner. I ran the above test case with various versions and it appears the 2.7.12 re-introduced this bug. Perhaps #963 is responsible?

Would it be possible to add my test case to the mockito test suite to ensure this regression doesn't happen in the future? =||= We should add it, I originally added a modified version to Byte Buddy but it seems to have missed an aspect. Feel free to send a PR. =||= I already located and fixed the error. I forgot to adjust the visibility for bridge methods. =||= I'll make a PR for the acceptance test. =||= I just release a new Byte Buddy version but I did not correctly apply the fix. Next version! =||= ",0
979,974,MockitoJUnitRunner.StrictStubs does not detect 'Unnecessary Stubbing' when inline mock maker is enabled,"- mockito-core 2.7.13
- OpenJDK 1.8.0_121
- Ubuntu 16.10
- Enable `mock-maker-inline` (or use `mockito-inline` artifact)

If running the following test, 'Unnecessary Stubbing' is not detected.

```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    ArrayList<String> mock;

    @Test
    public void should_pass() {
        when(mock.get(0)).thenReturn(""foo"");
        assertEquals(""foo"", mock.get(0));
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.get(1)).thenReturn(""foo"");
    }

}
```

In the above code, 'Unnecessary Stubbing' is detected by changing ArrayList to List.
```java

    @Mock
//    ArrayList<String> mock;
    List<String> mock;

```

This problem does not occur with default mock maker.","This is working as intended. You should not mock Data classes such as `List`. The new mock maker is stricter in this regard as we could not ship another breaking change for the original mock maker.

We could add an explicit exception when we encounter these classes, instead of silently continueing. WDYT @raphw ? =||= I am sorry that my test case was bad.

The following test **passes** using inline mock maker.
This test does not use data classes.
```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    C mock;

    @Test
    public void should_pass() {
        when(mock.doIt()).thenReturn(""foo"");
        assertEquals(""foo"", mock.doIt());
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.doIt()).thenReturn(""foo"");
    }

    public static class C {
        public String doIt() {
            throw new UnsupportedOperationException();
        }
    }

}
```

Using default mock maker, this test **fails**.
This is the result that I expect.
```
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected in test class: MockitoTest
Clean & maintainable test code requires zero unnecessary code.
Following stubbings are unnecessary (click to navigate to relevant line of code):
  1. -> at com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)
Please remove unnecessary stubbings or use 'silent' option. More info: javadoc for UnnecessaryStubbingException class.

	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:49)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:161)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
```

Does **new mock maker** mean **inline mock maker**?
According to the results of this test, inline mock maker seems to be less strict than default mock maker.
Sorry if I have misunderstood.
 =||= Ah that is a better testcase. Definitely a bug! =||= Just tested this on master and the result is the same for both mock makers where neither test detects the unneccessary stubbung. I do not know this part of Mockito too well but I assume there is a bug in this component. =||= I wrote a new test for this issue.

```java
public class StrictStubsRunnerByMockingAbstractClassTest {

    private final JUnitCore jUnitCore = new JUnitCore();

    @Test
    public void test_for_abstract_method_should_detect_unnecessary_stubbings() {
        runTest(ForAbstractMethod.class);
    }

    @Test
    public void test_for_concrete_method_should_detect_unnecessary_stubbings() {
        runTest(ForConcreteMethod.class);
    }

    private void runTest(Class<?> testClass) {
        Result result = jUnitCore.run(testClass);
        List<Failure> failures = result.getFailures();
        assertThat(failures.size(), equalTo(1));
        Failure failure = failures.get(0);
        assertThat(failure.getException(), instanceOf(UnnecessaryStubbingException.class));
    }

    static abstract class TestTarget {

        abstract String abstractMethod();

        String concreteMethod() {
            throw new UnsupportedOperationException();
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForAbstractMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
            mock.abstractMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForConcreteMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
            mock.concreteMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
        }

    }

}
```

To test this test on the master, I put this into the following directory.
1. src/test/java/org/mockitousage/junitrunner (using the default mock maker)
1. inline/src/test/java/org/mockitoinline (using the inline mock maker)

In the first case, this test passed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :test --tests ""org.mockitousage.junitrunner.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:createTestResources
:compileTestJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:removeTestResources
:processTestResources UP-TO-DATE
:testClasses
:test

BUILD SUCCESSFUL

Total time: 5.707 secs
```

However, in the second case it failed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :inline:test --tests ""org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:jar
:inline:compileJava UP-TO-DATE
:inline:processResources
:inline:classes
:inline:compileTestJava
:inline:processTestResources UP-TO-DATE
:inline:testClasses
:inline:test

org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest > test_for_concrete_method_should_detect_unnecessary_stubbings FAILED
    java.lang.AssertionError: 
    Expected: <1>
         but: was <0>
        at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
        at org.junit.Assert.assertThat(Assert.java:956)
        at org.junit.Assert.assertThat(Assert.java:923)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.runTest(StrictStubsRunnerByMockingAbstractClassTest.java:36)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.test_for_concrete_method_should_detect_unnecessary_stubbings(StrictStubsRunnerByMockingAbstractClassTest.java:30)

2 tests completed, 1 failed
:inline:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':inline:test'.
> There were failing tests. See the report at: file:///home/tmura/IdeaProjects/mockito/subprojects/inline/build/reports/tests/index.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 3.505 secs

```

For the abstract method, 'Unnecessary Stubbing' was detected correctly, but it did not detected for the concrete method.
 =||= I thnk I have found the cause of this problem.
When using the inline mock maker, it seems that LocationImpl cannot get the stubbed location of the concrete method correctly.

`UnusedStubbingFinder` which detects 'Unnecessary stubbing' calls `LocationImpl#toString()` to get the stabbed location.

The code below is the implementation of `LocationImpl#toString()`.
```java
StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);
if (filtered.length == 0) {
    return ""-> at <<unknown line>>"";
}
return ""-> at "" + filtered[0].toString();
```

This method filters the stack trace elements of `stackTraceHolder` to get the location.
`stackTraceHolder` is a Throwable object that is created in the constructor of `LocationImpl`.

The stack trace elements of this object are as follows:

- Stubbing the concrete method with the default mock maker
```
0 = {StackTraceElement@1679} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1680} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1681} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1682} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1683} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptSuperCallable(MockMethodInterceptor.java:102)""
5 = {StackTraceElement@1684} ""com.example.MockitoTest$C$MockitoMock$648066763.doIt(Unknown Source)""
6 = {StackTraceElement@1685} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the abstract method with the inline mock maker
```
0 = {StackTraceElement@2201} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@2202} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@2203} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@2204} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@2205} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:120)""
5 = {StackTraceElement@2206} ""com.example.MockitoTest$C$MockitoMock$1683798279.doIt(Unknown Source)""
6 = {StackTraceElement@2207} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the concrete method with the inline mock maker
```
0 = {StackTraceElement@1927} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1928} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1929} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1930} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1931} ""org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handle(MockMethodAdvice.java:76)""
5 = {StackTraceElement@1932} ""com.example.MockitoTest$C.doIt(MockitoTest.java:30)""
6 = {StackTraceElement@1933} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

The resulting location should be `#6`, but in the last case it is `#5`.
Because `stackTraceFilter` does not exclude `#5`.
 =||= Yes, this is expected. The inline mock maker inlines the code and does therefore not add a stack frame. This is a bug in the `UnusedStubbingFinder` which should not rely on the stack shape.

@TimvdLippe Do you have time to look at this? =||= Thank you guys for really thorough debugging!

>This is a bug in the UnusedStubbingFinder which should not rely on the stack shape.

There is a reason why the finder relies on the String representation of line where the unused stub is declared. I documented it in the [Javadoc](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java#L46), hopefully it is more less clear :) I'm not saying we should keep the current implementation, I'm ok changing it, I just wanted to give more data points.

After reading this thread my gut feel tells me that the stack trace filter (different component than unused stubbing detection) may not be coping well with inline mocking. This could also have impact on stack trace filtering in general for inline mocking, the quality of exception messages, etc.

@tmurakami, you made fantastic debugging effort to nail down the problem. Can you investigate if stack trace filter needs adapting for inline mocking and potentially submit a PR? =||= With the stack trace filter, I actually did change the implementation to adjust this behavior such that it works. I was not aware that the stubbing finder replicated something similar. =||= @szczepiq, @raphw, I can submit the PR, but this problem seems to have already been fixed by @raphw.
Should I submit the PR?
 =||= Please submit, I only fixed the issue partially. =||= ",0
980,976,Make MockSettings.useConstructor able to choose the right constructor,"## Use case

We recently added a very nice new feature #935 - ability to mock abstract classes / use real constructor for creating mocks. Currently we fail fast when multiple constructors are found matching provided arguments. However, Mockito could potentially do a better job identifying which constructor to use. Example scenario:

```java
class A {}
class B extends A {}
class C extends B {}

class Foo {
  Foo(A a) {};
  Foo(B b) {};
}

//Below fails with current implementation:
mock(Foo, withSettings().useConstructor(new A()));
mock(Foo, withSettings().useConstructor(new B()));
//However, we could make above work because the constructor argument are not really ambiguous

//Example use case of ambiguous constructor that we can remain failing on
mock(Foo, withSettings().useConstructor(new C()));
```

## Implementation

To get started, see CreatingMocksWithConstructorTest class. Unless the code changes, the interesting test method is [this one](https://github.com/mockito/mockito/blob/release/2.x/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java#L150).","@mureinik, do you want to take a stab at this one? :) =||= @szczepiq sure, I'll take a crack at it, but let's first decide what exactly we want to do. 

First, a note - `mock(Foo, withSettings().useConstructor(new A()));` most definitely works with the current implementation, contrary to the comment in the above snippet.

I propose the following definition, which is pretty much what the compiler does when facing a call like `new Foo(new B())`:
- An argument will be called _better matching_ parameter X over parameter Y if the argument can be applied to either parameter X or parameter Y and X is a more specific type than Y.<br/>
For completeness' sake: An argument will be called _worse matching_ parameter X over parameter Y if it is _better matching_ parameter Y over X; An argument will be called _equally matching_ parameter X over parameter Y if it is neither _better matching_ or _worse matching_ parameter X over parameter Y.

- An argument list will be called _better matching_ a constructor's parameters list X over Y if one or more of the arguments are _better matching_ their respective parameters and the rest are _equally matching_ their respective parameters.<br/>
Note that if the argument list is larger than one argument, this is not a total order. If constructor X is _better matching_ an argument list than constructor Z and constructor Y is _better matching_ the same argument list than constructor Z, nothing can be said about the relationship between X and Y.

Using these definitions, we can implement the following behavior:
- If no constructor matches the argument list, an exception is thrown (as it is with the current implementation).
- If a single constructor matches the argument list, it's used (as it is with the current implementation).
- If multiple constructors match the argument list, and one is _better matching_ than any other constructor, it is used (new behavior).
- If multiple constructors match the argument list, and there isn't one that is _better matching_ than all the  the other constructors, an exception is thrown (similar to the current implementation, although the error message may be more precise - see below).

I'll attempt to clarify this with an example.

Consider the following:

```java
class A {}
class B extends A {}
class C extends B {}

class Foo {
  Foo(A x, A y) {}
  Foo(A x, B y) {}
  Foo(B x, A y) {}
}

A a = new A();
B b = new B();
C c = new C();

// Works, Foo(A, A) is called, obviously.
mock(Foo.class, withSettings().useConstructor(a, a)); 

// Works, Foo(A, B) is called.
// Since B is more specific than A, Foo(A, B) is better matching than Foor(A, A).
mock(Foo.class, withSettings().useConstructor(a, b)); 

// Works, Foo(B, A) is called, following the same logic as above
mock(Foo.class, withSettings().useConstructor(b, a)); 

// Works, Foo(B, A) is called, following the same logic as above
mock(Foo.class, withSettings().useConstructor(a, c)); 

// Does not work, as we can't decide between Foo(A, B) and Foo(B, A)
mock(Foo.class, withSettings().useConstructor(b, b)); 
```

If this approach makes sense, I'll cook up a patch that implements it, so we have something concrete to discuss. =||= @szczepiq feel free to assign this issue to me. I don't think I have the permissions to do so myself. =||= ",0
983,982,Break cyclical compile time dependency on hideRecursiveCall,"I am working on upgrading the version of mockito in AOSP to 2.7.13 using byte buddy and byte buddy android rather than dexmaker.

As part of that I need to exclude a number of classes which will not compile on Android because it does not support Java agents/instrumentation. The mockito code has always been very well organized and made that very simple to do but in the latest version I found a minor issue.

The files I need to exclude are:
- src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
- src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
- src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java

Unfortunately, when I do that I get a compile error because MockMethodAdvice is trying to use hideRecursiveCall from InlineByteBuddyMockMaker. I looked at the code and it seems as though InlineByteBuddyMockMaker depends on InlineBytecodeGenerator which depends on MockMethodAdvice which depends on hideRecursiveCall from InlineByteBuddyMockMaker.

The only places that actually use hideRecursiveCall are MockMethodAdvice and InlineByteBuddyMockMakerTest. That depends on InlineByteBuddyMockMaker which depends on InlineBytecodeGenerator which depends on MockMethodAdvice which depends on hideRecursiveCall from InlineByteBuddyMockMaker.

So, moving hideRecursiveCall from InlineByteBuddyMockMaker to MockMethodAdvice breaks a dependency cycle and allows the InlineByteBuddyMockMaker.java file to be excluded without problem. Also, MockMethodAdvice seems to be a better place for it.

If you are happy with this proposal or can suggest a better place for hideRecursiveCall then I am happy to submit a fix for this.","That seems like a reasonable issue. Looking forward to your pull request @paulduffin ! =||= Should I make the change in release/2.x?

On 8 March 2017 at 12:57, Tim van der Lippe <notifications@github.com>
wrote:

> That seems like a reasonable issue. Looking forward to your pull request
> @paulduffin <https://github.com/paulduffin> !
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/982#issuecomment-285033757>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AEtcQ-KnL90mWa9jxuLBhEsA8QmxpSJzks5rjqXXgaJpZM4MWrIj>
> .
>
 =||= Yes please :) =||= Done. =||= ",0
985,981,Update documentation about mockito-inline artifact,"Mockito documentation currently does not explain ""mockito-inline"" artifact that is used for inline mocking (mocking finals). The main Mockito class still contains information on how to configure the inline mocking using a classpath resource.",nan,0
985,929,New 'mockito-inline' artifact does not work,"mockito-inline 2.7.2

build.gradle:
```groovy
apply plugin: 'java'

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

repositories {
    jcenter()
}

dependencies {
    testCompile 'junit:junit:4.12'
    testCompile 'org.mockito:mockito-inline:2.7.2'
}
```

Test target:
```java
final class Foo {

}
```

Test for Foo:
```java
public class FooTest {

    @Test
    public void test() {
        Mockito.mock(Foo.class);
    }

}
```

Test command:
```
$ ./gradlew clean test
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test

com.example.FooTest > test FAILED
    org.mockito.exceptions.base.MockitoException at FooTest.java:10

1 test completed, 1 failed
:test FAILED

FAILURE: Build failed with an exception.
```

Test report:
```
org.mockito.exceptions.base.MockitoException: 
Cannot mock/spy class com.example.Foo
Mockito cannot mock/spy because :
 - final class
	at com.example.FooTest.test(FooTest.java:10)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:377)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
	at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
```

### Reason

`mockito-extensions/org.mockito.plugins.MockMaker` is not included in the mockito-inline.jar.
```
$ jar tvf mockito-inline-2.7.2.jar 
     0 Sat Feb 04 12:02:54 JST 2017 META-INF/
    25 Sat Feb 04 12:02:54 JST 2017 META-INF/MANIFEST.MF
```

In [the inline subproject](https://github.com/mockito/mockito/tree/release/2.x/subprojects/inline), org.mockito.plugins.MockMaker is in `src/resources/mockito-extensions` directory.
Is this correct?

In [the android subproject](https://github.com/mockito/mockito/tree/release/2.x/subprojects/android), the file is in src/**main**/resources/mockito-extensions.","Reproducible project:
[mockito_issue_929.zip](https://github.com/mockito/mockito/files/756407/mockito_issue_929.zip)
 =||= Seems like our Gradle build is not set up to include this file on Travis. It does work on my local machine, though. Strange things, thanks for reporting! =||= ",0
995,989,Misleading behavior of Mockito.verifyZeroInteractions(),"## Problem

Mockito.verifyZeroInteractions() actually does not do what it advertises. The purpose of this ticket is to discuss whether to change the behavior of this method in Mockito 3.

## Details

Based on user feedback at #977, from @ffissore, ""verifyZeroInteractions"" API can be misleading. When you read that method in test code, you expect zero interactions with specified mocks. However, ""verifyZeroInteractions"" is only an alias to ""verifyNoMoreInteractions"" and in fact, it **does not** guarantee that there were zero interactions. Let's use examples to illustrate the problem

## Feedback needed

Please comment / vote / state your opinion about changing the behavior of ""verifyZeroInteractions"" so that it actually ensures that there were **zero** interactions with the mock (regardless if previously verified or not).

## Examples

Below examples illustrate current behavior of Mockito 2.x, in case you are puzzled what this ticket is about.

Example 1 - verifyNoMoreInteractions

```java
mock.foo();
verify(mock).foo();
verifyNoMoreInteractions(mock); //pretty clear I think
```

Example 2 - verifyZeroInteractions

```java
mock.foo();
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
//and we already have verified the only method invoked on the mock
```

Example 3 - verifyZeroInteractions with regular stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
```

Example 4 - verifyZeroInteractions with new strict stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());

verifyZeroInteractions(mock);
//above passes because with strict stubbing
//stubbed method are implicitly verified when they are ""used""
//this is one of key features of strict stubbing (DRY, don't repeat yourself)
```",This was fixed in #989 =||= ,0
1011,911,Mockito Continuous Delivery Pipeline 2.0,"Proposed changes on easy-to-grasp diagrams are documented on [Mockito blog article](http://blog.mockito.org/2017/02/mockito-continuous-delivery-pipeline-2.0.html).

## Current release model

Every code change results in a new version in Central repository (not snapshot, a real version). More information on [Continuous Delivery in Mockito](https://github.com/mockito/mockito/wiki/Continuous-Delivery-Overview).

Given high rate of new versions, the community and current tooling is not comfortable in taking in new Mockito versions at fast pace. More feedback and the discussion in issue #618.

## Proposed changes

Release every change but not all releases go to Central. Push to standard repository (JCenter / Maven Central) only substantial releases. Push remaining versions to less prominent, but still public space for early adopters.

Glossary: What are major, minor, patch versions? Explanatory example: Version 2.6.5 has major=2, minor=6, patch=5.

1. Every merged pull request produces new version that lands in Bintray ""mockito/maven"" repo.
2. Some versions we produce are ""notable versions"", by default those are new major (3.0.0, 4.0.0) and new minor versions (3.1.0, 3.2.0). In contrast to regular new versions, the notable versions are included in well-known central repositories: JCenter and Maven Central.

For more details, see the wiki page paragraph on [continuous delivery](https://github.com/mockito/mockito/wiki/Continuous-Delivery-Details#cd).

## Action list
- [x] - Configure 2.7.22 as last notable version because it was the last version published to central
- Release notes:
  - [ ] - detailed release notes link to notable release notes and vice versa
  - [x] - release notes inform where the jars can be found (https://github.com/mockito/mockito-release-tools/issues/4)
  - [ ] - link to wiki documentation
- [ ] - Publish next notable version
- [x] - procedure of promoting to notable release is documented - https://github.com/mockito/mockito/blob/release/2.x/README.md#how-to-release-new-version
- [x] - the new release model is comprehensively documented - https://github.com/mockito/mockito/wiki/Continuous-Delivery-Details#cd

Optional:

- [ ] - release notes have clean format (https://github.com/mockito/mockito-release-tools/issues/3)
- [ ] - notable release (target repo) can be forced by commit message

## Implementation details

- https://github.com/mockito/mockito/wiki/Continuous-Delivery-Details#cd
- https://github.com/mockito/mockito/blob/release/2.x/README.md#how-to-release-new-version","> Every minor or major version change lands in both

I do agree for major, but for minor I am not sure. I think we should not immediately release a new minor version when 1 function was added, most notably because we might want to add a range of functions in all separate PRs (since they are separate logical units). Therefore I would say to not do it automatically, but presumably faster than with patch releases. E.g. minor every week published, patch every month.

> Example: “community” repo has 2.8.1, 2.8.2, 2.8.3, at the end of the month, 2.8.3 is promoted to production.

This means that 2.81 and 2.8.2 are never available on production? I do think we should push this for 1. consistency in release versions and 2. if someone finds an issue with a version in `production`, he/she can bisect using the in-between patch releases to see which version contained the error.

> I'm not completely happy with repository naming ""community"" and ""production""

Maybe `trunk` and `production`?

> New version is published under following conditions

I would like to add an override here for to be able to push a new version. E.g. not pushing an existing version to production, but publishing a new version without manually editing javadoc to artificially trigger the release mechanism


Overall I agree with the proposal, just some small comments. Glad that we are taking action in this direction 👍  =||= Great feedback thank you!

>I do agree for major, but for minor I am not sure. I think we should not immediately release a new minor version when 1 function was added, most notably because we might want to add a range of functions in all separate PRs (since they are separate logical units). 

""minor"" version (e.g. middle number :) is not automatically bumped by the system. It's us (or the PR submitter) that makes a judgement call to explicitly bump minor version. This decision is based on the gravity of the changes. We don't bump minor version unless it has substantial changes. If it does have substantial changes, it probably should be released to mass audience. At least this is my reasoning. If we don't automatically publish minor versions we can end up with versioning scheme where ""community"" and ""prod"" repo have pretty much random versions. If we publish minor versions automatically, ""prod"" contains announcable, significant versions that add substantial value, e.g. 3.1.0, 3.2.0, 3.3.0 and occasional patch release like 3.3.1. ""community"" repo would have all changes 3.1.0, 3.1.1, 3.1.2, 3.1.3, 3.2.0, etc. Thoughts?

>This means that 2.8.1 and 2.8.2 are never available on production? I do think we should push this for 1. consistency in release versions and 2. if someone finds an issue with a version in production, he/she can bisect using the in-between patch releases to see which version contained the error.

The idea is to only include substantial versions in official repo. If the user wants to bisect, he needs configure ""community"" repo explicitly in pom / build.gradle. In short, the answer to your question is yes, 2.8.1 and 2.8.2 will never be in ""production"" repo.

>Maybe trunk and production?

Let's keep thinking. Some other ideas: all-versions/announcable-versions, all-artifacts/significant-artifacts, early-adopters/slow-adopters.

Given that ""minor"" version (e.g. middle one) is updated explicitly by the PR submitter, he controls 

>I would like to add an override here for to be able to push a new version. 

Good idea. I will add it to the design.

Really nice feedback. Thanks! We can tweak/iterate the process as we learn more, too. =||= > We don't bump minor version unless it has substantial changes.

Makes sense, 👍 

> In short, the answer to your question is yes, 2.8.1 and 2.8.2 will never be in ""production"" repo.

I think for clarity's sake, they should be pushed. It would be weird to browse maven central and see missing versions. Let's see what the others think.

> Let's keep thinking.

Latest - Stable? =||= > > In short, the answer to your question is yes, 2.8.1 and 2.8.2 will never be in ""production"" repo.

> I think for clarity's sake, they should be pushed. It would be weird to browse maven central and see missing versions. Let's see what the others think.

I can think of two popular projects which sometines skip versions:
- [Maven](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.maven%22%20AND%20a%3A%22maven%22), missing versions eg 3.3.2, 3.3.4-3.3.8 (and upcoming 3.5.0 will skip 3.4.0)
- [Tomcat](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.tomcat%22%20AND%20a%3A%22tomcat%22), missing versions eg 8.5.10, 8.5.7, 8.0.40 =||= @arend-von-reinersdorff, thank you for feedback and examples!
@TimvdLippe, currently, I most like following naming scheme for repositories: ""all-versions"" and ""notable-versions"". =||= This looks good! I agree with the model where minor versions are in release channel (notable-versions) and patch versions are in beta channel (all-versions), modulo hot fixes. If patch versions are pushed to notable-versions _at the time they are released_, you defeat the purpose of the release channel; your ""notable versions"" channel would churn multiple times daily again.

Maybe Mockito can push all interleaved patch versions available only on the beta channel to the release channel when the release channel is updated? For example:

Before:
```
release channel – 2.3.0
beta – 2.3.0, 2.3.1, 2.3.2
```

After:
```
release channel – 2.3.0, 2.3.1, 2.3.2, 2.3.3 (hotfix)
beta – 2.3.0, 2.3.1, 2.3.2, 2.3.3
```

This may go against the principle of least surprise, since someone browsing the version history of release channel will notice that suddenly not one but three new versions became visible. This may be acceptable if bisecting and keeping full version history on the release channel are important for the project. As I said before, I don't have a strong preference for this model, except to say that patch versions should not appear in the release channel _at the time of their release_ unless they are hot fixes.

 =||= I have an alternative opinion from everything proposed so far. I propose introducing the usage of the `classifier` attribute to differentiate between community and production releases. With this proposal the current CD procedure would be left unchanged and consumers who want to subscribe to the latest releases can continue to do so with no changes. For those consumers who want to limit the thrashing on taking updates they can do so by declaring a `weekly` classifier. The only change to the current release process would to be to release the most recent tag with the additional classifier attached. It could be weekly or monthly.

```xml
<!-- Current usage, unchanged! -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.7.5</version>
</dependency>

<!-- Using the `weekly` classifier -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <classifier>weekly</classifier>
    <version>2.7.1</version>
</dependency>
```

This could also be inverted to restore the delayed release process to the majority of consumers and allow opting in to the daily/continuous releases.

```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <classifier>daily</classifier>
    <version>2.7.5</version>
</dependency>

<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.7.1</version>
</dependency>
``` =||= @mattnelson That is an interesting concept I had not heard of! I am not sure though if it would be valid for our usecase, but definitely worth investigating. =||= @mattnelson, interesting idea! At this point I want avoid using classifiers because they would complicate things. If you get this working for some project or there is a reference project that uses this method, we would like to know the experiences.

@tinkerware, thanks for feedback!
 =||= @szczepiq I think we can close this issue as well and direct any further discussion to the shipkit repository? =||= Closing this per rationale in #618 and our implementation available at https://github.com/mockito/shipkit =||= ",0
1016,991,Add BaseArgumentMatcher to ease migration from pre 2.x,"Pre 2.x ArgumentMatcher was a class that provided a default
implementation of describeTo(Description). The new
BaseArgumentMatcher class provides an equivalent implementation
of toString() making it easier for pre 2.x code that did not
override the describeTo(Description) method to be migrated.","I am currently working on migrating Android code to use mockito 2.7.13. We have a lot of implementations of ArgumentMatcher that relied on the default implementation of describeTo(Description) provided by the 1.10.19 ArgumentMatcher class which is not provided by the 2.x ArgumentMatcher interface (no default methods yet). This new class will aid in that migration. =||= # [Codecov](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=h1) Report
> Merging [#991](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=desc) into [release/2.x](https://codecov.io/gh/mockito/mockito/commit/9b98d71fa2444b0ebc35265d79458e5432cb5396?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/mockito/mockito/pull/991/graphs/tree.svg?height=150&width=650&token=MX80sLdeR0&src=pr)](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=tree)

```diff
@@              Coverage Diff               @@
##             release/2.x     #991   +/-   ##
==============================================
  Coverage          86.86%   86.86%           
  Complexity          2290     2290           
==============================================
  Files                287      287           
  Lines               5801     5801           
  Branches             684      684           
==============================================
  Hits                5039     5039           
  Misses               571      571           
  Partials             191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=footer). Last update [9b98d71...5ebb567](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). =||= I am all for ease of migration, glad you are using Mockito in your Android project! Is there a particular reason it was not possible to create this class in your project and extend from there? Or did you do so, but you would like to upstream it for other developers? =||= You misunderstand me, it is not an Android project, it is Android itself, i.e. AOSP.

We have a local patch to mockito that adds a compatibility class and we would rather not maintain a local class and it just seems like something that other people moving to 2.x might appreciate. =||= Ah oke, all makes sense! This would be fine by me :) =||= This is really nice improvement and I like the use case it solves. Thank you!

1. Before we merge it, I'd like us to discuss high level design
 - is this matcher implementation useful outside of the context of 2.x migration? I suspect it is. If that's the case, we need to surface this new implementation in Javadoc in other places
 - can we come up with a solution that does not require base class? Base classes are less convenient to work with and make the API slightly more complicated. They also need more documentation because users have 2 alternatives - use the interface of the base method. Can we detect if matcher has custom toString() in runtime? If so, we could use decamelized class name automatically if the instance does not have custom toString()
 - let's mark this API incubating in case we want to experiment with the idea I mentioned earlier

2. Feedback about the implementation
 - there are no tests
 - Javadoc needs to be updated in other places, too (some examples: ArgumentMatcher, argThat method, etc). Otherwise this class will be very hard to discover and users would not use it.
 - there is no @since tag
 - otherwise, nice & clean implementation. Thank you for neat javadocs and code comments!!! =||=    1. Ok
      - Yes it is useful outside of 2.x migration, at least as useful as
      the old ArgumentMatcher was.
      - I suppose that you could use reflection to detect whether the class
      has overridden the toString() method but that seems like quite a
      heavyweight solution. It would not work for any implementations that
      override and call super.toString(), e.g. to add additional information to
      the default implementation. If you targeted Java 8 I would say
that default
      method would be a better solution.
      - I am not quite sure what incubating means but that is fine with me.
      2. It was a quick proof of concept to illustrate what I was thinking
   not intended to be submitted as is.
      - Ok.
      - Can you give me a definitive list of the places to update and
      suggestions as to what to add to each? I find that otherwise we end up
      going backwards and forwards as I try and guess what you want.
      - Ok.
      - Thanks.


On 17 March 2017 at 17:25, Szczepan Faber <notifications@github.com> wrote:

> This is really nice improvement and I like the use case it solves. Thank
> you!
>
>    1. Before we merge it, I'd like us to discuss high level design
>
>
>    - is this matcher implementation useful outside of the context of 2.x
>    migration? I suspect it is. If that's the case, we need to surface this new
>    implementation in Javadoc in other places
>    - can we come up with a solution that does not require base class?
>    Base classes are less convenient to work with and make the API slightly
>    more complicated. They also need more documentation because users have 2
>    alternatives - use the interface of the base method. Can we detect if
>    matcher has custom toString() in runtime? If so, we could use decamelized
>    class name automatically if the instance does not have custom toString()
>    - let's mark this API incubating in case we want to experiment with
>    the idea I mentioned earlier
>
>
>    1. Feedback about the implementation
>
>
>    - there are no tests
>    - Javadoc needs to be updated in other places, too (some examples:
>    ArgumentMatcher, argThat method, etc). Otherwise this class will be very
>    hard to discover and users would not use it.
>    - there is no @since <https://github.com/since> tag
>    - otherwise, nice & clean implementation. Thank you for neat javadocs
>    and code comments!!!
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/pull/991#issuecomment-287418708>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AEtcQ3_gVd-VoUNKmMsJUErwhN5cl6LVks5rmsIDgaJpZM4MgxWG>
> .
>
 =||= You can denote this class as incubating by adding `@Incubating` to the declaration.

I would go for the following mentions:
- Let's mention this class in [this list](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/ArgumentMatcher.java#L16)
- Let's mention this class in [2.1.0 migration guide](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/ArgumentMatcher.java#L88)

That should be sufficient for now. This class is merely for ease of migration, I think we should discourage its usage if the user can afford to do so. =||= I think I have messed up this PR. I usually work in Gerrit and it is better there to do an amend and a force push. Let me know what you want me to do. I am happy to close this off and do a new PR. =||= @szczepiq you asked about whether the toString() method is needed and whether the default behavior could be provided separately. I just found out that it already is in org.mockito.internal.matchers.text.MatcherToString. It traverses the class hierarchy looking for a toString() method and if it cannot find one then it defaults to the decamelizer form.

As a result I have removed the toString() implementation in BaseArgumentMatcher. That means it provides little benefit for anything other than migration. Based on that I think it would be much better if these classes were in a separate package and maybe even in their own compat subproject. =||= I improved the testing of BaseArgumentMatcher and found a problem with my previous type safe matching mechanism, fixing it made it a lot more complicated so I junked it and refactored TypeSafeMatching class to allow me to reuse it with BaseArgumentMatcher in order to provide similar capabilities. =||= Oof this is getting out of hand pretty quickly :O We have to see if we can make this compatibility matcher easily, without modifying too much in core. =||= Wow, thank you for trying to close down this use case!

Given that it's getting complicated we can choose to document this use case on a wiki, with a code sample to drop to the code. This is an edge case for incremental migrations for some users, so perhaps it does not have to be part of the main code? If you all +1 to include it in the code I suggest to make it really explicit in the API for clarity (use 'org.mockito.migration' package, call the matcher: MockitoV1CompatibilityMatcher, perhaps make it deprecated so that it's clear that users should not use it forever ;).

I'm +1 to keep the API small, avoid adding the matcher and document the migration path on the wiki. We can link to that wiki from the javadoc. =||= @szczepiq, @TimvdLippe 

Ok, so change the name and package to make it clearer, to 'org.mockito.migration.MockitoV1CompatibilityMatcher'? Is that name acceptable to both of you?

Tim, would you prefer that I keep these changes completely isolated from the main code? That would involve duplicating a little bit of the code but I am happy to do that.

That raises the next question what about packaging? Should I add a subproject called migration into which I add this code? That would isolate it even more.

I was planning on adding the ErrorProne checks that will help automate migration to an errorProne subproject. =||= As a Mockito maintainer, my main goal is easy upgrades for our users. Your contribution helps greatly with that! However, it seems that integrating it is more difficult than anticipated. Therefore  little duplication sounds better to me, than the extra changes in core.

I think a separate package is very good for this, as it signals to our users that the implementation is for migration only. We can add this to the package-info for example.

So all in all, if we can find a solution that is minimal, yet greatly improves the usability of the library: yes please. I think we are close with this PR, but some minor tweaks are required to keep the codebase as nice as it is now ;) =||= Do you want me to put this in a subproject? e.g. subproject/migration? If so presumably it will have its own artifact as well. =||= If you can do that without spending too much time/resources, I would be :+1: to that! =||= I will need to backport this to a branch based off 1.10.19. Anyone upgrading from 1.10.19 would first get the 1.10.20 (or 1.10.19-migration) version which would contain a version of MockitoV1CompatibilityMatcher that they could extend instead of extending ArgumentMatcher directly. Could you create a new 1.10.x-migration branch that I could send some pull requests to?

FYI. I just found out that I have a load of code that depends on 1.9.5 so I will be looking at doing something similar to allow easy upgrading from 1.9.5 to 1.10.19. =||= Oh and to keep it simple, you can probably copy your (great!) commit message in the documentation. That should be sufficient to inform other users. =||= @paulduffin I think you can close this PR and we need to cherry-pick your release/1.x commit to release/2.x, right? =||= The cherry pick won't work I will still need 2.x specific patches. However, if you want me to cherry pick from 1.x and then add the necessary changes on top as a separate commit and then create a pull request I would be happy to do that. =||= @paulduffin so if I understand you correctly, this PR can be merged as-is and we need to publish the 1.x artifact from the current `release/1.x` branch? =||= It could yes. I still have some changes that I need to make, error prone checkers/fixers to add but if you want to publish then feel free. =||= It's been some time since we reviewed this PR :) What is the current status? @paulduffin, is the PR ready to go based on your understanding of the status? =||= I am currently working with the error prone team to get some changes into
Error Prone to make it work better with open source code. I am also working
on Error Prone checks for detecting common problems with Mockito as well as
to aid in migration. I have not forgotten about this work, there is still
quite a lot to be done.

On 20 May 2017 at 20:43, Szczepan Faber <notifications@github.com> wrote:

> It's been some time since we reviewed this PR :) What is the current
> status? @paulduffin <https://github.com/paulduffin>, is the PR ready to
> go based on your understanding of the status?
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/pull/991#issuecomment-302894482>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AEtcQ0ZSlKC-FxQfuIAOAS7JjqJq-3Xnks5r70JsgaJpZM4MgxWG>
> .
>
 =||= I am closing this right now as we are not going to land this for 2.x. We will provide a better migration path for future breaking changes. =||= ",0
1018,911,Mockito Continuous Delivery Pipeline 2.0,"Proposed changes on easy-to-grasp diagrams are documented on [Mockito blog article](http://blog.mockito.org/2017/02/mockito-continuous-delivery-pipeline-2.0.html).

## Current release model

Every code change results in a new version in Central repository (not snapshot, a real version). More information on [Continuous Delivery in Mockito](https://github.com/mockito/mockito/wiki/Continuous-Delivery-Overview).

Given high rate of new versions, the community and current tooling is not comfortable in taking in new Mockito versions at fast pace. More feedback and the discussion in issue #618.

## Proposed changes

Release every change but not all releases go to Central. Push to standard repository (JCenter / Maven Central) only substantial releases. Push remaining versions to less prominent, but still public space for early adopters.

Glossary: What are major, minor, patch versions? Explanatory example: Version 2.6.5 has major=2, minor=6, patch=5.

1. Every merged pull request produces new version that lands in Bintray ""mockito/maven"" repo.
2. Some versions we produce are ""notable versions"", by default those are new major (3.0.0, 4.0.0) and new minor versions (3.1.0, 3.2.0). In contrast to regular new versions, the notable versions are included in well-known central repositories: JCenter and Maven Central.

For more details, see the wiki page paragraph on [continuous delivery](https://github.com/mockito/mockito/wiki/Continuous-Delivery-Details#cd).

## Action list
- [x] - Configure 2.7.22 as last notable version because it was the last version published to central
- Release notes:
  - [ ] - detailed release notes link to notable release notes and vice versa
  - [x] - release notes inform where the jars can be found (https://github.com/mockito/mockito-release-tools/issues/4)
  - [ ] - link to wiki documentation
- [ ] - Publish next notable version
- [x] - procedure of promoting to notable release is documented - https://github.com/mockito/mockito/blob/release/2.x/README.md#how-to-release-new-version
- [x] - the new release model is comprehensively documented - https://github.com/mockito/mockito/wiki/Continuous-Delivery-Details#cd

Optional:

- [ ] - release notes have clean format (https://github.com/mockito/mockito-release-tools/issues/3)
- [ ] - notable release (target repo) can be forced by commit message

## Implementation details

- https://github.com/mockito/mockito/wiki/Continuous-Delivery-Details#cd
- https://github.com/mockito/mockito/blob/release/2.x/README.md#how-to-release-new-version","> Every minor or major version change lands in both

I do agree for major, but for minor I am not sure. I think we should not immediately release a new minor version when 1 function was added, most notably because we might want to add a range of functions in all separate PRs (since they are separate logical units). Therefore I would say to not do it automatically, but presumably faster than with patch releases. E.g. minor every week published, patch every month.

> Example: “community” repo has 2.8.1, 2.8.2, 2.8.3, at the end of the month, 2.8.3 is promoted to production.

This means that 2.81 and 2.8.2 are never available on production? I do think we should push this for 1. consistency in release versions and 2. if someone finds an issue with a version in `production`, he/she can bisect using the in-between patch releases to see which version contained the error.

> I'm not completely happy with repository naming ""community"" and ""production""

Maybe `trunk` and `production`?

> New version is published under following conditions

I would like to add an override here for to be able to push a new version. E.g. not pushing an existing version to production, but publishing a new version without manually editing javadoc to artificially trigger the release mechanism


Overall I agree with the proposal, just some small comments. Glad that we are taking action in this direction 👍  =||= Great feedback thank you!

>I do agree for major, but for minor I am not sure. I think we should not immediately release a new minor version when 1 function was added, most notably because we might want to add a range of functions in all separate PRs (since they are separate logical units). 

""minor"" version (e.g. middle number :) is not automatically bumped by the system. It's us (or the PR submitter) that makes a judgement call to explicitly bump minor version. This decision is based on the gravity of the changes. We don't bump minor version unless it has substantial changes. If it does have substantial changes, it probably should be released to mass audience. At least this is my reasoning. If we don't automatically publish minor versions we can end up with versioning scheme where ""community"" and ""prod"" repo have pretty much random versions. If we publish minor versions automatically, ""prod"" contains announcable, significant versions that add substantial value, e.g. 3.1.0, 3.2.0, 3.3.0 and occasional patch release like 3.3.1. ""community"" repo would have all changes 3.1.0, 3.1.1, 3.1.2, 3.1.3, 3.2.0, etc. Thoughts?

>This means that 2.8.1 and 2.8.2 are never available on production? I do think we should push this for 1. consistency in release versions and 2. if someone finds an issue with a version in production, he/she can bisect using the in-between patch releases to see which version contained the error.

The idea is to only include substantial versions in official repo. If the user wants to bisect, he needs configure ""community"" repo explicitly in pom / build.gradle. In short, the answer to your question is yes, 2.8.1 and 2.8.2 will never be in ""production"" repo.

>Maybe trunk and production?

Let's keep thinking. Some other ideas: all-versions/announcable-versions, all-artifacts/significant-artifacts, early-adopters/slow-adopters.

Given that ""minor"" version (e.g. middle one) is updated explicitly by the PR submitter, he controls 

>I would like to add an override here for to be able to push a new version. 

Good idea. I will add it to the design.

Really nice feedback. Thanks! We can tweak/iterate the process as we learn more, too. =||= > We don't bump minor version unless it has substantial changes.

Makes sense, 👍 

> In short, the answer to your question is yes, 2.8.1 and 2.8.2 will never be in ""production"" repo.

I think for clarity's sake, they should be pushed. It would be weird to browse maven central and see missing versions. Let's see what the others think.

> Let's keep thinking.

Latest - Stable? =||= > > In short, the answer to your question is yes, 2.8.1 and 2.8.2 will never be in ""production"" repo.

> I think for clarity's sake, they should be pushed. It would be weird to browse maven central and see missing versions. Let's see what the others think.

I can think of two popular projects which sometines skip versions:
- [Maven](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.maven%22%20AND%20a%3A%22maven%22), missing versions eg 3.3.2, 3.3.4-3.3.8 (and upcoming 3.5.0 will skip 3.4.0)
- [Tomcat](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.tomcat%22%20AND%20a%3A%22tomcat%22), missing versions eg 8.5.10, 8.5.7, 8.0.40 =||= @arend-von-reinersdorff, thank you for feedback and examples!
@TimvdLippe, currently, I most like following naming scheme for repositories: ""all-versions"" and ""notable-versions"". =||= This looks good! I agree with the model where minor versions are in release channel (notable-versions) and patch versions are in beta channel (all-versions), modulo hot fixes. If patch versions are pushed to notable-versions _at the time they are released_, you defeat the purpose of the release channel; your ""notable versions"" channel would churn multiple times daily again.

Maybe Mockito can push all interleaved patch versions available only on the beta channel to the release channel when the release channel is updated? For example:

Before:
```
release channel – 2.3.0
beta – 2.3.0, 2.3.1, 2.3.2
```

After:
```
release channel – 2.3.0, 2.3.1, 2.3.2, 2.3.3 (hotfix)
beta – 2.3.0, 2.3.1, 2.3.2, 2.3.3
```

This may go against the principle of least surprise, since someone browsing the version history of release channel will notice that suddenly not one but three new versions became visible. This may be acceptable if bisecting and keeping full version history on the release channel are important for the project. As I said before, I don't have a strong preference for this model, except to say that patch versions should not appear in the release channel _at the time of their release_ unless they are hot fixes.

 =||= I have an alternative opinion from everything proposed so far. I propose introducing the usage of the `classifier` attribute to differentiate between community and production releases. With this proposal the current CD procedure would be left unchanged and consumers who want to subscribe to the latest releases can continue to do so with no changes. For those consumers who want to limit the thrashing on taking updates they can do so by declaring a `weekly` classifier. The only change to the current release process would to be to release the most recent tag with the additional classifier attached. It could be weekly or monthly.

```xml
<!-- Current usage, unchanged! -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.7.5</version>
</dependency>

<!-- Using the `weekly` classifier -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <classifier>weekly</classifier>
    <version>2.7.1</version>
</dependency>
```

This could also be inverted to restore the delayed release process to the majority of consumers and allow opting in to the daily/continuous releases.

```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <classifier>daily</classifier>
    <version>2.7.5</version>
</dependency>

<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.7.1</version>
</dependency>
``` =||= @mattnelson That is an interesting concept I had not heard of! I am not sure though if it would be valid for our usecase, but definitely worth investigating. =||= @mattnelson, interesting idea! At this point I want avoid using classifiers because they would complicate things. If you get this working for some project or there is a reference project that uses this method, we would like to know the experiences.

@tinkerware, thanks for feedback!
 =||= @szczepiq I think we can close this issue as well and direct any further discussion to the shipkit repository? =||= Closing this per rationale in #618 and our implementation available at https://github.com/mockito/shipkit =||= ",0
1021,1020,Use JDK 7 with Java 6 compatibility for building release artifacts,"We need community feedback if it is ok to change the JDK we use to build release artifacts for mockito. 

###  Problem

Currently Mockito is build on JDK 6. This ensures it will work with Java 6. However, this causes issues like ""sun.security.validator.ValidatorException: PKIX path building failed"" (https://github.com/mockito/mockito-release-tools/issues/60). This issues makes it problematic for us to setup up continuous delivery automation with Travis CI and Gradle.

### Question

Is ok to start building release artifacts of Mockito 2.x with JDK 7 (with Java 6 compatibility)? This will help with release automation and also is safer because Java 6 is no longer supported by Oracle.

Thank you in advance for answers!","This would be a major breaking change, so I am not for this. Can we contact Travis to investigate what the issue is? =||= Why would this be a breaking change? We would compile with Java 6 compatibility and generate bytecode that works on Java 6. =||= Ah, I misunderstood. So we build on JDK7, but set it to be Java 6 compatibility. Afaik, Gradle does not complain about Java 6 incompatible changes on newer JDKs, but the risk is probably low.

Could we maybe remove the release tool from the JDK6 Travis build, thus releasing on JDK7, but still build on JDK6 on Travis too? =||= @TimvdLippe https://github.com/xvik/gradle-animalsniffer-plugin can be use to detect constructions not compatible with Java 6. I use it in a few projects and at least `String.isEmpty()` is recognized correctly. =||= @szpak Ah cool, TIL! Yes then let's go ahead and adopt that plugin + switch to JDK7 =||= I will add that plugin in 2.x branch as a preparation to the switch. =||= @szpak, animalsniffer looks interesting! Why do we need animal sniffer given that we can compile on JDK7 with **source** and **target** compatibility set to 1.6? =||= Because these are actually not checked. See the recent PR of the diamond generic which locally had not installed the jdk6 =||= See this specific comment: https://github.com/mockito/mockito/pull/1014#issuecomment-290741441 =||= @szczepiq Source/target version result in byte code to be in the correct version/format. It doesn't check if a given construction (e.g. a method) was available in a given JDK version. =||= E.g. `Objects.isNull(""aa"");` builds fine with Java 7+ in Mockito (without AnimalSniffer). Created #1021. =||= @szpak, thank you this makes perfect sense! I thought that Java is smarter :)

@TimvdLippe, diamond is detect and flagged when we use sourceCompatibility = 1.6. That's the whole point of the 'sourceCompatibility' setting. The reason it was not detected in the PR you mentioned is that the PR changed the code in extTest and that code is test code without configured source compatibility (it does not have to, it is not code that we ship to the client).

I'm not in favor of introducing animal sniffer plugin. I'd rather keep things simple and just run builds on Java6. Extra plugins / dependencies are stuff we have to maintain. =||= The sooner we drop java 6/7 the better. It delays our work on mockito 3 for Java 8 / 9.

We should avoid as much as possible feature work on Mockito 2. =||= @szczepiq As an alternative you can [try](https://docs.gradle.org/3.5-rc-3/userguide/java_plugin.html#sec:java_cross_compilation) to use Java 6 to only compile code while Gradle is executed with Java 7. It would also allow to use newer Gradle in 2.x branch. =||= Closing as we switched to JDK7 build in #1021. =||= ",0
1045,1044,"Mistake in Contribution guide, Code style example","In contribution guide, code style, Alignment section the example for points 4 and 5 are identical, even though the point No 5 describes totally different case.",nan,0
1048,911,Mockito Continuous Delivery Pipeline 2.0,"Proposed changes on easy-to-grasp diagrams are documented on [Mockito blog article](http://blog.mockito.org/2017/02/mockito-continuous-delivery-pipeline-2.0.html).

## Current release model

Every code change results in a new version in Central repository (not snapshot, a real version). More information on [Continuous Delivery in Mockito](https://github.com/mockito/mockito/wiki/Continuous-Delivery-Overview).

Given high rate of new versions, the community and current tooling is not comfortable in taking in new Mockito versions at fast pace. More feedback and the discussion in issue #618.

## Proposed changes

Release every change but not all releases go to Central. Push to standard repository (JCenter / Maven Central) only substantial releases. Push remaining versions to less prominent, but still public space for early adopters.

Glossary: What are major, minor, patch versions? Explanatory example: Version 2.6.5 has major=2, minor=6, patch=5.

1. Every merged pull request produces new version that lands in Bintray ""mockito/maven"" repo.
2. Some versions we produce are ""notable versions"", by default those are new major (3.0.0, 4.0.0) and new minor versions (3.1.0, 3.2.0). In contrast to regular new versions, the notable versions are included in well-known central repositories: JCenter and Maven Central.

For more details, see the wiki page paragraph on [continuous delivery](https://github.com/mockito/mockito/wiki/Continuous-Delivery-Details#cd).

## Action list
- [x] - Configure 2.7.22 as last notable version because it was the last version published to central
- Release notes:
  - [ ] - detailed release notes link to notable release notes and vice versa
  - [x] - release notes inform where the jars can be found (https://github.com/mockito/mockito-release-tools/issues/4)
  - [ ] - link to wiki documentation
- [ ] - Publish next notable version
- [x] - procedure of promoting to notable release is documented - https://github.com/mockito/mockito/blob/release/2.x/README.md#how-to-release-new-version
- [x] - the new release model is comprehensively documented - https://github.com/mockito/mockito/wiki/Continuous-Delivery-Details#cd

Optional:

- [ ] - release notes have clean format (https://github.com/mockito/mockito-release-tools/issues/3)
- [ ] - notable release (target repo) can be forced by commit message

## Implementation details

- https://github.com/mockito/mockito/wiki/Continuous-Delivery-Details#cd
- https://github.com/mockito/mockito/blob/release/2.x/README.md#how-to-release-new-version","> Every minor or major version change lands in both

I do agree for major, but for minor I am not sure. I think we should not immediately release a new minor version when 1 function was added, most notably because we might want to add a range of functions in all separate PRs (since they are separate logical units). Therefore I would say to not do it automatically, but presumably faster than with patch releases. E.g. minor every week published, patch every month.

> Example: “community” repo has 2.8.1, 2.8.2, 2.8.3, at the end of the month, 2.8.3 is promoted to production.

This means that 2.81 and 2.8.2 are never available on production? I do think we should push this for 1. consistency in release versions and 2. if someone finds an issue with a version in `production`, he/she can bisect using the in-between patch releases to see which version contained the error.

> I'm not completely happy with repository naming ""community"" and ""production""

Maybe `trunk` and `production`?

> New version is published under following conditions

I would like to add an override here for to be able to push a new version. E.g. not pushing an existing version to production, but publishing a new version without manually editing javadoc to artificially trigger the release mechanism


Overall I agree with the proposal, just some small comments. Glad that we are taking action in this direction 👍  =||= Great feedback thank you!

>I do agree for major, but for minor I am not sure. I think we should not immediately release a new minor version when 1 function was added, most notably because we might want to add a range of functions in all separate PRs (since they are separate logical units). 

""minor"" version (e.g. middle number :) is not automatically bumped by the system. It's us (or the PR submitter) that makes a judgement call to explicitly bump minor version. This decision is based on the gravity of the changes. We don't bump minor version unless it has substantial changes. If it does have substantial changes, it probably should be released to mass audience. At least this is my reasoning. If we don't automatically publish minor versions we can end up with versioning scheme where ""community"" and ""prod"" repo have pretty much random versions. If we publish minor versions automatically, ""prod"" contains announcable, significant versions that add substantial value, e.g. 3.1.0, 3.2.0, 3.3.0 and occasional patch release like 3.3.1. ""community"" repo would have all changes 3.1.0, 3.1.1, 3.1.2, 3.1.3, 3.2.0, etc. Thoughts?

>This means that 2.8.1 and 2.8.2 are never available on production? I do think we should push this for 1. consistency in release versions and 2. if someone finds an issue with a version in production, he/she can bisect using the in-between patch releases to see which version contained the error.

The idea is to only include substantial versions in official repo. If the user wants to bisect, he needs configure ""community"" repo explicitly in pom / build.gradle. In short, the answer to your question is yes, 2.8.1 and 2.8.2 will never be in ""production"" repo.

>Maybe trunk and production?

Let's keep thinking. Some other ideas: all-versions/announcable-versions, all-artifacts/significant-artifacts, early-adopters/slow-adopters.

Given that ""minor"" version (e.g. middle one) is updated explicitly by the PR submitter, he controls 

>I would like to add an override here for to be able to push a new version. 

Good idea. I will add it to the design.

Really nice feedback. Thanks! We can tweak/iterate the process as we learn more, too. =||= > We don't bump minor version unless it has substantial changes.

Makes sense, 👍 

> In short, the answer to your question is yes, 2.8.1 and 2.8.2 will never be in ""production"" repo.

I think for clarity's sake, they should be pushed. It would be weird to browse maven central and see missing versions. Let's see what the others think.

> Let's keep thinking.

Latest - Stable? =||= > > In short, the answer to your question is yes, 2.8.1 and 2.8.2 will never be in ""production"" repo.

> I think for clarity's sake, they should be pushed. It would be weird to browse maven central and see missing versions. Let's see what the others think.

I can think of two popular projects which sometines skip versions:
- [Maven](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.maven%22%20AND%20a%3A%22maven%22), missing versions eg 3.3.2, 3.3.4-3.3.8 (and upcoming 3.5.0 will skip 3.4.0)
- [Tomcat](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.tomcat%22%20AND%20a%3A%22tomcat%22), missing versions eg 8.5.10, 8.5.7, 8.0.40 =||= @arend-von-reinersdorff, thank you for feedback and examples!
@TimvdLippe, currently, I most like following naming scheme for repositories: ""all-versions"" and ""notable-versions"". =||= This looks good! I agree with the model where minor versions are in release channel (notable-versions) and patch versions are in beta channel (all-versions), modulo hot fixes. If patch versions are pushed to notable-versions _at the time they are released_, you defeat the purpose of the release channel; your ""notable versions"" channel would churn multiple times daily again.

Maybe Mockito can push all interleaved patch versions available only on the beta channel to the release channel when the release channel is updated? For example:

Before:
```
release channel – 2.3.0
beta – 2.3.0, 2.3.1, 2.3.2
```

After:
```
release channel – 2.3.0, 2.3.1, 2.3.2, 2.3.3 (hotfix)
beta – 2.3.0, 2.3.1, 2.3.2, 2.3.3
```

This may go against the principle of least surprise, since someone browsing the version history of release channel will notice that suddenly not one but three new versions became visible. This may be acceptable if bisecting and keeping full version history on the release channel are important for the project. As I said before, I don't have a strong preference for this model, except to say that patch versions should not appear in the release channel _at the time of their release_ unless they are hot fixes.

 =||= I have an alternative opinion from everything proposed so far. I propose introducing the usage of the `classifier` attribute to differentiate between community and production releases. With this proposal the current CD procedure would be left unchanged and consumers who want to subscribe to the latest releases can continue to do so with no changes. For those consumers who want to limit the thrashing on taking updates they can do so by declaring a `weekly` classifier. The only change to the current release process would to be to release the most recent tag with the additional classifier attached. It could be weekly or monthly.

```xml
<!-- Current usage, unchanged! -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.7.5</version>
</dependency>

<!-- Using the `weekly` classifier -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <classifier>weekly</classifier>
    <version>2.7.1</version>
</dependency>
```

This could also be inverted to restore the delayed release process to the majority of consumers and allow opting in to the daily/continuous releases.

```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <classifier>daily</classifier>
    <version>2.7.5</version>
</dependency>

<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.7.1</version>
</dependency>
``` =||= @mattnelson That is an interesting concept I had not heard of! I am not sure though if it would be valid for our usecase, but definitely worth investigating. =||= @mattnelson, interesting idea! At this point I want avoid using classifiers because they would complicate things. If you get this working for some project or there is a reference project that uses this method, we would like to know the experiences.

@tinkerware, thanks for feedback!
 =||= @szczepiq I think we can close this issue as well and direct any further discussion to the shipkit repository? =||= Closing this per rationale in #618 and our implementation available at https://github.com/mockito/shipkit =||= ",0
1048,77,Getting an absolute count of calls to a mocked method,"We can do this:

```
verify(mock1, times(3)).thisMethod();
verify(mock2, times(3)).thatMethod();
```

But we cannot do something like this, as far as I can see:

```
verifyEquals(times(mock1.thisMethod()), times(mock2.thatMethod()));
```

That is, I would like to verify that two mocked methods are called the same unspecified number of times. The number of calls made to a method appears to be already available, so this would be just querying the value directly, not indirectly via `times()`, `atLeast()`, etc.

I also [posed this question to StackOverflow](http://stackoverflow.com/q/25543250/1270789), and one answer, on using an `Answer`, seems good; perhaps a standard `Answer` implementation `CountsCalls` or similar should be the solution?","You can use a custom  VerificationMode to count the invocations, here you go:

```
public class InvocationCounter {

    public static <T> T countInvocations(T mock, AtomicInteger count) {
        return Mockito.verify(mock, new Counter(count));
    }

    private InvocationCounter(){}

    private static class Counter implements VerificationInOrderMode, VerificationMode {
        private final AtomicInteger count;

        private Counter(AtomicInteger count) {
            this.count = count;
        }

        public void verify(VerificationData data) {
            count.set(data.getAllInvocations().size());
        }

        public void verifyInOrder(VerificationDataInOrder data) {
            count.set(data.getAllInvocations().size());
        }

        @Override
        public VerificationMode description(String description) {
            return VerificationModeFactory.description(this, description);
        }

    }

}
```

And then use it like this (works also with void return types):

```
@Mock
private Function<String, Integer> callable;

AtomicInteger count= new AtomicInteger(); //here is the actual invocation count stored

countInvocations(callable,count).apply( anyString());

assertThat(count.get(),is(2));
```
 =||= Mockito.mockingDetails(mock).getInvocations() API can be used to get the invocations. It's coming with 2.0. I'm closing this ticket if that's ok!
 =||= ",0
1052,984,Release commits do not trigger code coverage report,"Found out at https://github.com/mockito/mockito/pull/980#issuecomment-285124740
This was initially fixed in #493, but I think the adoption of the new mockito-release-tools repository introduced this regression. All pull requests now have a failing status as CodeCov is unable to provide any feedback.

Commits should instead of `[ci skip]` use `[ci skip-release]`. Therefore Travis will kick off, but the release mechanism is not triggered.","Sorry for slow turnaround. It will get fixed soon! =||= My understanding is that code cov comparisons need every commit to produce report. Otherwise codecov ""cannot find base report"".

Running build for every commit defeats the purpose of ""ci skip"" :) Can we work with codecov tooling to accommodate this? Even if we make automated commits trigger builds, we still want to use ""ci skip"" at times.

Do you advocate to use ""ci skip release"" in place of ""ci skip"" for mockito project in general? =||= Asked upstream: https://github.com/codecov/support/issues/355#issuecomment-292707657 =||= Thank you for asking! I'll unassign myself from the ticket for the time being. =||= Created ticket for it: https://github.com/mockito/mockito-release-tools/issues/92 =||= This was fixed some time ago, probably in #1052. =||= ",0
1062,105,Continuous deployment should not release new version if binaries are equal,"Continuous deployment should not release new version if binaries are equal. Sometimes we check-in code that does not require new version (for example, changes to README.md, itp). We should add some logic that prevents releasing a brand new version if the current binaries are the same as previously released.",nan,0
1076,1071,Mockito AdditionalAnswers.returnsFirstArg() doesn't work with generic first arg,"_Issue concerning [this stackoverflow question](http://stackoverflow.com/questions/30670275/mockito-returnsfirstarg-doesnt-work-with-generic-first-arg).
I've checked it's not working both Mockito 1.x and 2.x._


-------------------



I'm trying to mock the typed method `getNameElement` of Interface `RoomGeneralService` to return the first arg, using Mockito `AdditionalAnswers.returnsFirstArg` functionality:

**Interface to mock**:

    interface PrimaryKeyElement<T> {
       public String getNameElement(T primaryKey);
    }

    interface RoomGeneralService extends PrimaryKeyElement<String> {
       // ...
    }

**My test** (note the imports)

    import static org.mockito.AdditionalAnswers.returnsFirstArg;
    import static org.mockito.Matchers.any;
    import static org.mockito.Matchers.anyString;
    import static org.mockito.Mockito.when;
    import org.mockito.runners.MockitoJUnitRunner;
    
    @RunWith(MockitoJUnitRunner.class)
    public class SampleTest {
    
       @Mock
       RoomGeneralService roomGeneralService;
    
       @Test
       public void testFoo() throws Exception {
          when(roomGeneralService.getNameElement(anyString())).thenAnswer(returnsFirstArg());
          //...
       }
    }

Also I've tried with other combinations, but without success so far:

    when(roomGeneralService.getNameElement(Matchers.<String>any())).thenAnswer(returnsFirstArg());
    doAnswer(returnsFirstArg()).when(roomGeneralService.getNameElement(anyString()));
    doReturn(returnsFirstArg()).when(roomGeneralService.getNameElement(anyString()));

**Error received**:

> The reason for this error can be :
> 1. The wanted argument position is incorrect.
> 2. The answer is used on the wrong interaction.
> 
> Position of the wanted argument is 0 and the possible argument indexes
> for this method are :
>     [0] Object

**Workaround**:

I know I can create my own answer, and in fact it's working fine if instead of use `returnFirstArg()` I do something like this:

    when(roomGeneralService.getNameElement(anyString())).thenAnswer(new Answer<String>() {
       @Override
       public String answer(InvocationOnMock invocation) throws Throwable {
          return (String) invocation.getArguments()[0];
       }
    });

But I would use `returnFirstArg()` as in the rest of my tests (tests look cleaner), as well as mocking is working fine if the method `getNameElement` would receive an `String` instead a `T` arg.

Thanks for the help.","@troig Mockito checks if the argument type is compatible with the return type to make a misuse ot the API as soon as posible visible.  In this case the argument-type Object is inferred from the generic type T, due to type erasure. Since Object is not a subtype of String Mockito throws the exception you see.

Solution: The issue can by fixed by inferring the argument-type of the actual argument-instance.
 In case the argument-type is a primitive or the arg is null Mockito must fallback and use the type provided by method signature. 

I have a solution ~~that currently doesn't work due to regressions introduced with #1032 (vararg-expansion is broken)~~.
 =||= Thanks @ChristianSchwarz for you quick answer! =||= ",0
1079,1065,Complement error message,Exception from [cannotStubVoidMethodWithAReturnValue](https://github.com/mockito/mockito/blob/aeed5fe3b06912c35a4fd70fa61b45e1feedc9a1/src/main/java/org/mockito/internal/exceptions/Reporter.java#L447) does not inform about `doNothing()` method. But I think in many cases it is what user want to do.,Feel free to open a PR to fix this issue :smile: Thanks for the report. =||= ,0
1084,143,git --author does not work from CI,git --author does not work from CI for some reason and the automatic release does not work properly,"I wanted to get onto this, but in the Git log I see:

```
commit f80dd4a95d78d15dfea814877d143e8e31cfd880
Author: Continuous Delivery Drone <continuous.delivery.drone@gmail.com>
Date:   Sat Aug 13 18:05:32 2016 +0000

    Increment version '2.0.101-beta' -> '2.0.102-beta' by Travis CI build 1128 [ci skip-release]
```

It was a long time ago, maybe it was fixed in the meantime? @szczepiq could you elaborate more about this issue?
 =||= I think this was probably fixed in the mean time. Therefore closing this issue.
 =||= ",0
1084,145,"Mock refers to ""super"", preventing it from being used as a mixin.","By supporting _givenHashCode, `Mock` refers to `super`, preventing its use a Mixin.

This means if I want to mock out unimplemented functions in an abstract class, I can't.

Here is an example of some interfaces and abstract implementations:

``` dart
abstract class Foo {
  String bar();
}

abstract class AbstractFoo implements Foo {
  String bar() => baz();

  String baz();
}
```

I'd like to just extend `AbstractFoo` but also use `Mock` to mock out `baz`:

``` dart
abstract class MockMixin {
  // Instead of 'noSuchMethod', so we don't use 'super.noSuchMethod'.
  handleNoSuchMethod(Invocation invocation) { ... }
}

// Test the implementation of 'AbstractFoo', and use stubs for the remaining abstract methods.
class MockFoo extends AbstractFoo with MockMixin {
  noSuchMethod(Invocation invocation) => handleNoSuchMethod(invocation);
}

void main() {
  var foo = new MockFoo();
  when(foo.baz()).thenReturn('baz');
  expect(foo.bar(), 'baz');
}
```

I think it would be alright if there was a base `MockMixin`. The current `Mock` could just extend that for people who would prefer extending it. I'd be OK with writing a PR for this feature, but wanted to suggest it first.","Hey,

Thanks for the suggestion!

Can you tell us a high level motivation for this feature? Is it targeted for newer versions of java or for scala? Not sure if this is related but have you seen the recent support in Mockito for mocking abstract classes?
 =||= ",0
1090,1083,Mockito 2 mock-maker-inline not able to mock Object methods on an interface,"Hi there,

I recently upgraded from Mockito `1.9.5` to `2.7.22` (mockito-inline), and some tests started failed as Mockito is unable to mock `Object.toString()` method on an interface.

It appears to be that the inline mock maker cannot mock Object methods on an interface, using a class (HashSet for the below example) or mockito-core instead of mockito-inline makes it work.

***System:***
```
OS:       Windows 10 (version 1703)
Java:     JDK 1.8u131
Mockito:  org.mockito:mockito-inline:2.7.22 //org.mockito:mockito-core:2.7.22 works fine!
Junit:    junit:junit:4.12
```

***Sample example that fails:***
```java
import org.junit.Assert;
import org.junit.Test;
import org.mockito.Mockito;
import java.util.Set;

public class TestInterfaceToString {
    @Test
    public void testInterfaceToString() {
        Set set = Mockito.mock(Set.class); // Change Set.class to HashSet.class makes it work
        Mockito.when(set.toString()).thenReturn(""bla"");
        Assert.assertEquals(""bla"", set.toString());
    }
}
```

***Output:***
```bash
""C:\Program Files\Java\jdk1.8.0_131\bin\java"" -Didea.test.cyclic.buffer.size=1048576 ""-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2017.1.2\lib\idea_rt.jar=58071:C:\Program Files\JetBrains\IntelliJ IDEA 2017.1.2\bin"" -Dfile.encoding=UTF-8 -classpath ""C:\Program Files\JetBrains\IntelliJ IDEA 2017.1.2\lib\idea_rt.jar;C:\Program Files\JetBrains\IntelliJ IDEA 2017.1.2\plugins\junit\lib\junit-rt.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext\zipfs.jar;C:\Users\Mina\Documents\IdeaProjects\TestingMockito2\out\production\TestingMockito2;C:\Users\Mina\.m2\repository\org\mockito\mockito-inline\2.7.22\mockito-inline-2.7.22.jar;C:\Users\Mina\.m2\repository\org\mockito\mockito-core\2.7.22\mockito-core-2.7.22.jar;C:\Users\Mina\.m2\repository\net\bytebuddy\byte-buddy\1.6.11\byte-buddy-1.6.11.jar;C:\Users\Mina\.m2\repository\net\bytebuddy\byte-buddy-agent\1.6.11\byte-buddy-agent-1.6.11.jar;C:\Users\Mina\.m2\repository\org\objenesis\objenesis\2.5\objenesis-2.5.jar;C:\Users\Mina\.m2\repository\junit\junit\4.12\junit-4.12.jar;C:\Users\Mina\.m2\repository\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar"" com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 TestInterfaceToString

org.mockito.exceptions.misusing.MissingMethodInvocationException: 
when() requires an argument which has to be 'a method call on a mock'.
For example:
    when(mock.getArticles()).thenReturn(articles);

Also, this error might show up because:
1. you stub either of: final/private/equals()/hashCode() methods.
   Those methods *cannot* be stubbed/verified.
   Mocking methods declared on non-public parent classes is not supported.
2. inside when() you don't call method on mock but on some other object.

	at TestInterfaceToString.setUp(TestInterfaceToString.java:20)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

Process finished with exit code -1
```

Cheers,
Mina
","Your jdk seems fairly outofdate. Could you update to a more recent version?
That should probably fix the issue.

On Mon, 15 May 2017, 02:56 Mina Asham, <notifications@github.com> wrote:

> Hi there,
>
> I recently upgraded from Mockito 1.9.5 to 2.7.22, and some tests started
> failed as Mockito is unable to mock Object.toString() method on an
> interface.
>
> Sample example that fails:
>
> import org.junit.Before;import org.junit.Test;import org.mockito.Mock;import org.mockito.MockitoAnnotations;
> import java.util.Set;
> import static org.junit.Assert.assertEquals;import static org.mockito.Mockito.when;
> public class TestInterfaceToString {
>
>     @Mock
>     private Set set;
>
>     @Before
>     public void setUp() {
>         MockitoAnnotations.initMocks(this);
>
>         when(set.toString()).thenReturn(""bla"");
>     }
>
>     @Test
>     public void testInterfaceToString() {
>         assertEquals(""bla"", set.toString());
>     }
> }
>
> Output:
>
> ""C:\Program Files\Java\jdk1.8.0_45\bin\java"" -Didea.test.cyclic.buffer.size=1048576 ""-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2017.1.2\lib\idea_rt.jar=58071:C:\Program Files\JetBrains\IntelliJ IDEA 2017.1.2\bin"" -Dfile.encoding=UTF-8 -classpath ""C:\Program Files\JetBrains\IntelliJ IDEA 2017.1.2\lib\idea_rt.jar;C:\Program Files\JetBrains\IntelliJ IDEA 2017.1.2\plugins\junit\lib\junit-rt.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_45\jre\lib\ext\zipfs.jar;C:\Users\Mina\Documents\IdeaProjects\TestingMockito2\out\production\TestingMockito2;C:\Users\Mina\.m2\repository\org\mockito\mockito-inline\2.7.22\mockito-inline-2.7.22.jar;C:\Users\Mina\.m2\repository\org\mockito\mockito-core\2.7.22\mockito-core-2.7.22.jar;C:\Users\Mina\.m2\repository\net\bytebuddy\byte-buddy\1.6.11\byte-buddy-1.6.11.jar;C:\Users\Mina\.m2\repository\net\bytebuddy\byte-buddy-agent\1.6.11\byte-buddy-agent-1.6.11.jar;C:\Users\Mina\.m2\repository\org\objenesis\objenesis\2.5\objenesis-2.5.jar;C:\Users\Mina\.m2\repository\junit\junit\4.12\junit-4.12.jar;C:\Users\Mina\.m2\repository\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar"" com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 TestInterfaceToString
>
> org.mockito.exceptions.misusing.MissingMethodInvocationException: when() requires an argument which has to be 'a method call on a mock'.
> For example:
>     when(mock.getArticles()).thenReturn(articles);
>
> Also, this error might show up because:
> 1. you stub either of: final/private/equals()/hashCode() methods.
>    Those methods *cannot* be stubbed/verified.
>    Mocking methods declared on non-public parent classes is not supported.
> 2. inside when() you don't call method on mock but on some other object.	at TestInterfaceToString.setUp(TestInterfaceToString.java:20)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Process finished with exit code -1
>
> Using the class HashSet instead of the interface Set would make the class
> work, but this feels like a bug to me, I haven't seen anything in the
> release notes about it, am I missing something or is this a new bug?
>
> Cheers,
> Mina
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1083>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb4Zc3QNKX3Ro3ar2baAGlN5uKNujks5r56LIgaJpZM4NakOe>
> .
>
 =||= Update above for clarity, also added some system specs and minified the example a bit. =||= @TimvdLippe Is running a recent JDK version a hard requirement for mocking `final` classes/methods via `org.mockito:mockito-inline`? If so please state the minium version needed. =||= @johnjohndoe There is not a minium JDK version for Mockito, but there are a small subset of errors that are JDK related and fixed in more recent versions. I think all versions > 1.8.45 are good enough for this subset. =||= This is failing on 1.8.131 anyways, so I don't think it a JDK issue.
This only fails with `org.mocker:mockito-inline` but works fine on `org.mockito:mockito-core`, I suspect the inline mocker is not able to extend interfaces properly? =||= If it is also failing with the latest JDK, it probably is an issue with ByteBuddy-Android. CC @raphw  =||= Yes, its a bug in the inline mock maker. Fixed in attached PR. =||= ",0
1091,1088,Javadoc Example Throws Unexpected Exception," Verify(mockedList, atLeast(2)).add(""five times""); - would throw
org.mockito.exceptions.verification.TooLittleActualInvocations

Correcting this would help to make sure new devs are not confused by the verify use case there.

<img width=""678"" alt=""screen shot 2017-05-17 at 8 40 03 pm"" src=""https://cloud.githubusercontent.com/assets/10499046/26181818/2241904c-3b41-11e7-8f71-6974d46d5579.png"">","What would you consider to be the correct behaviour here? At a push I might propose a slight change in naming to ""TooFewActualInvocations"" but the core behaviour is the same.

Your example is confusing because your ""atLeast(2)"" verification is on .add(""five times""), which suggests five invocations of add() with that String, but there are no invocations with that String.

What do you expect to see here? =||= I think the expectation is that the code works when it is copy pasted to IDE and executed. Why don't we fix it by changing ""five times"" to ""three times""? Do you want to contribute? Please do! :) =||= Oh wait, I see now. It's a problem with [the documentation](http://static.javadoc.io/org.mockito/mockito-core/2.8.9/org/mockito/Mockito.html#4). Sure thing, I can update that no problem. =||= Thanks folks.  =||= ",0
1109,1107,No release build for 2.8.39 - possible bug in Travis CI,"For some reason, Travis CI did not trigger the main build for version 2.8.39. In the travis dashboard for that build I can see only [3 child jobs](https://travis-ci.org/mockito/mockito/builds/237813636) whereas normally there are [4 child jobs](https://travis-ci.org/mockito/mockito/builds/237433149).

@szpak, have you seen something like that before? I'm restarting the build, let's see what happens :)","No, I haven't seen anything like that before. There were no changes in .travis.yml and I have no idea what one of the jobs is missing. Probably (I hope) it will be automatically fixed by the next commit. It may be good to report it to Travis. =||= Just merged another PR, will see how many child jobs Travis triggers this time :) =||= Another instance of this problem. I've contacted Travis CI support, put you guys on cc. =||= Commented on the ticket in Travis issue tracker (https://github.com/travis-ci/travis-ci/issues/4681#issuecomment-306102865). Here's the message from Travis CI support:

```
Thanks for reaching out and I'm sorry for this change in behavior.

This is the result of a change we released 3 days ago and it's detailed here: https://github.com/travis-ci/travis-ci/issues/4681. In brief, if you have no matrix expansion on the top level, and there is at least one job defined in `matrix.include`, the top level job is no longer included in the build matrix.

You should be able to get your old build configuration back by adding the following under `matrix.include`:


matrix:
  include:
  - jdk: oraclejdk7
  - jdk: oraclejdk7
    env: SKIP_RELEASE=true MOCK_MAKER=mock-maker-inline
  ⋮
```

I'm trying it now ;) =||= ",0
1119,1117,Answer with delay in mock or spy to improve testing of asynchronous code,"I'm currently using Mockito for component testing of microservices.  All code should be run, up to the boundary at which another microservice is called.  In the component test, the mocks return very quickly, but obviously in integration testing, the real calls return much more slowly.  Some threading problems are revealed by the slow returns that would have been revealed in the component test if the returns could be forced to come back more slowly.  Since integration tests are *painfully* slow to start, this would save me, the developer, considerable time in debugging this kind of issue once I discover it in the integration tests.

Because it's so easy to write, I've already solved it with a class called AnswerWithDelay.  It takes another answer as a parameter, and inserts a little sleep before it returns.

If desired, I can turn this little helper into a PR for mockito. Or perhaps there's already something there that does this, that I've overlooked.

Best Regards,
Myrle

```
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT,
        classes = {AbstractRhythmTest.TestConfiguration.class},
        properties = {""rhythm.user=homer"", ""rhythm.beatCheckRate=500""}
)
public class AbstractRhythmTest {
  //...
  static class AnswerWithDelay<T> implements Answer<T> {
    private final int sleepyTime;
    private final Answer<T> answer;

    AnswerWithDelay(final int sleepyTime, final Answer<T> answer) {
      this.sleepyTime = sleepyTime;
      this.answer = answer;
    }

    @Override
    public T answer(final InvocationOnMock invocation) throws Throwable {
      TimeUnit.MILLISECONDS.sleep(sleepyTime);
      return answer.answer(invocation);
    }
  }

  Beat createBeat(
          final String applicationIdentifier,
          final String beatIdentifier,
          final int alignmentHour,
          final LocalDateTime expectedBeatTimestamp) throws InterruptedException {
    final String tenantIdentifier = tenantDataStoreContext.getTenantName();

    final Beat beat = new Beat();
    beat.setIdentifier(beatIdentifier);
    beat.setAlignmentHour(alignmentHour);

    Mockito.doAnswer(new AnswerWithDelay<>(2_000, new Returns(Optional.of(PermittableGroupIds.forApplication(applicationIdentifier))))).when(beatPublisherServiceSpy).requestPermissionForBeats(Matchers.eq(tenantIdentifier), Matchers.eq(applicationIdentifier));
    Mockito.doAnswer(new AnswerWithDelay<>(2_000, new Returns(true))).when(beatPublisherServiceSpy).publishBeat(Matchers.eq(beatIdentifier), Matchers.eq(tenantIdentifier), Matchers.eq(applicationIdentifier),
            AdditionalMatchers.or(Matchers.eq(expectedBeatTimestamp), Matchers.eq(getNextTimeStamp(expectedBeatTimestamp))));

    this.testSubject.createBeat(applicationIdentifier, beat);

    Assert.assertTrue(this.eventRecorder.wait(EventConstants.POST_BEAT, new BeatEvent(applicationIdentifier, beat.getIdentifier())));

    Mockito.verify(beatPublisherServiceSpy, Mockito.timeout(2_500).times(1)).requestPermissionForBeats(tenantIdentifier, applicationIdentifier);

    return beat;
  }
  //...
}
```","If the implementation is clean and generic, I would be in favor of it =||= @szpak For what version is that feature planned (Or has it been already released)? =||= ",0
1121,1110,PowerMock and MockMaker: API change request.  ,"Hi guys,

I've taken a time for reviewing PowerMock code to find place where it use internal Mockito API. I'd like to discuss what could be done to avoid. 

First think that I'd like to talk about it's MockMaker. PowerMock uses it custom MockMaker, which it past was used only for two things: 

- cache a class create by CgLib
- return fake `InternalMockHandler` for static mocks. 

The first case is no more actual, because ByteBuddy uses current context ClassLoader, so `MockClassLoader` is used. But the second case still actual. But investigation shows that returning fake `InternalMockHandler` is required only for one case right now. 

Method `org.mockito.internal.exceptions.Reporter.noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations)` tries to `safelyGetMockName(undesired.getMock())`. Finally, call comes to `org.mockito.internal.util.MockUtilisMock(Object mock)`. It tries to get `MockHandler` for mock, but it mock is static and it's not a PowerMockMaker, then `null` is returned. 
I was surprised that having `PowerMockMaker` is required  only for such thing. If speak, honestly, I don't have any idea, how it can be fixed on Mockito site. Maybe you have any thoughts? 

The second point, it's a way how Mockito loads plugins.  We had some discussion within #1006. Main point provided @podarsmarty (as for me main) that if there are two files `org.mockito.plugins.MockMaker`  in class path, then order of loading plugins are unpredictable. Such undetermined behaviour could introduce some fluky bugs, when for example one plugin specified in project and other in  dependency jar. And for example it works, but later author of dependency jar make refactoring and change package or something like this. As result other plugin is loaded by Mockito  and tests start failed.  

For PowerMock it is issue, because is has own `MockMaker`, which is required only if test runs with PowerMock. But, unfortunately, if PowerMock in class path it will be used always.  If a developer wants to use `mock-maker-inline` to be able to mock final without PowerMock, then it was impossible until PowerMock 1.7.0, where I added ability to specify  `MockMaker` to which `PowerMockMaker` delegates calls. As for me, it will be good to have ability to separate custom `MockMaker` and Mockito build-in `MockMaker`. So custom `MockMaker` could know which build-in `MockMaker` should be used to delegate call if its required. ","@thekingnothing, do you live in Krakow? I spent most of my adult life in Krakow ;)

Thank you for reaching out to us so that we can work together. That's how this should be done - we design the APIs between open source components so that our users get higher quality products (e.g. products that don't break on version upgrade :).

I'm also surprised that those are the only issues with using Mockito's private API. Something tells me there is more. Let's keep working on this an expose all integration points.

>Method org.mockito.internal.exceptions.Reporter.noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) tries to safelyGetMockName(undesired.getMock()). Finally, call comes to org.mockito.internal.util.MockUtilisMock(Object mock). It tries to get MockHandler for mock, but it mock is static and it's not a PowerMockMaker, then null is returned.
I was surprised that having PowerMockMaker is required only for such thing. If speak, honestly, I don't have any idea, how it can be fixed on Mockito site. Maybe you have any thoughts?

Multiple methods from Reporter class attempt to use 'safelyGetMockName'. I assume you use 'noMoreInteractionsWanted' as an example. Getting mock name is only used to make verification errors cleaner. It's not a critical feature, without it the errors are still decent.

To get started, I suggest to hack Mockito code and return empty String if getting mock name throws an exception. This way you can push forward and identify other contention points. Once we get full picture we can design public API that will solve all use cases cases for integration with PowerMock.

>The second point, it's a way how Mockito loads plugins. We had some discussion within #1006. Main point provided @podarsmarty (as for me main) that if there are two files org.mockito.plugins.MockMaker in class path, then order of loading plugins are unpredictable. Such undetermined behaviour could introduce some fluky bugs, when for example one plugin specified in project and other in dependency jar. And for example it works, but later author of dependency jar make refactoring and change package or something like this. As result other plugin is loaded by Mockito and tests start failed.

I totally agree that random order of loading plugins is undesired. We don't have a clean way of solving this problem at the moment. It needs more brainstorming. Ideas are welcome :)

>For PowerMock it is issue, because is has own MockMaker, which is required only if test runs with PowerMock. But, unfortunately, if PowerMock in class path it will be used always. If a developer wants to use mock-maker-inline to be able to mock final without PowerMock, then it was impossible until PowerMock 1.7.0, where I added ability to specify MockMaker to which PowerMockMaker delegates calls. As for me, it will be good to have ability to separate custom MockMaker and Mockito build-in MockMaker. So custom MockMaker could know which build-in MockMaker should be used to delegate call if its required.

This is an interesting use case. Let me understand it: an author of custom MockMaker would like to have access to default Mockito MockMaker so that she can delegate some invocations to it? In Mockito we can introduce public API to expose the default mock maker (or means to obtain the default mock maker). =||= > @thekingnothing, do you live in Krakow? I spent most of my adult life in Krakow ;)

Yeah, I'm living in Krakow for one year. Nice city, except winter time. I mean issue with air in winter :) 

> I'm also surprised that those are the only issues with using Mockito's private API. Something tells me there is more.

It's just begin, I only started (demon laughing). There a lot of issue and thing todo. PowerMock has been being developed for 9 years in isolation and there are a lot of hacks (sometimes really dirty).  I started with easiest issue. All other could take more time to explain and fix: directly creating mocks, registration invocation control, creating mock handler, verify static and so on. 

> Multiple methods from Reporter class attempt to use 'safelyGetMockName'. I assume you use 'noMoreInteractionsWanted' as an example. 

No, `noMoreInteractionsWanted` and `noMoreInteractionsWantedInOrder`  it's only one case right now. All other methods which use `safelyGetMockName` is not called in context of static mocking. PowerMock handle all these cases by itself. As result Mockito `mockMaker` always can returns handler and mock name could be obtained.

> I totally agree that random order of loading plugins is undesired. We don't have a clean way of solving this problem at the moment. It needs more brainstorming. Ideas are welcome :)

First of all it will be nice to show warning like JVM shows on Mac ;) A developer will be aware about issue. I clear understand that most of developers are ignoring such messages. But at least some of them will know that they test are unstable. 

> objc[48004]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/bin/java (0x103ae94c0) and /Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x104b544e0). One of the two will be used. Which one is undefined.

> In Mockito we can introduce public API to expose the default mock maker (or means to obtain the default mock maker).

Yeah, it will be create to have ability to obtain default mock maker (or other plugin) instead writing something like `private final MockMaker cglibMockMaker = new CglibMockMaker();`
  
 =||= >No, noMoreInteractionsWanted and noMoreInteractionsWantedInOrder it's only one case right now. All other methods which use safelyGetMockName is not called in context of static mocking. 

Ok, thanks! Hack Mockito codebase and keep pushing forward. Safely getting mock name is a simple issue to fix so let's move on and identify hard problems :)

>First of all it will be nice to show warning like JVM shows on Mac ;)

We can show a warning. I'd like us to brainstorm and understand what options we have here to fix this caveat. This problem should be fairly common when plugin system is based of metadata declared in the classpath.

>Yeah, it will be create to have ability to obtain default mock maker (or other plugin) instead writing something like private final MockMaker cglibMockMaker = new CglibMockMaker();

Does PowerMock still use CglibMockMaker? This class no longer exists in Mockito 2.x codebase. =||= > Hack Mockito codebase and keep pushing forward. 

Just to make sure that we're on the same page. Does you mean to raise a pull request with the change on reporter? 

 =||= > Does PowerMock still use CglibMockMaker? This class no longer exists in Mockito 2.x codebase.

PowerMock have used  repackaged `CglibMockMaker` until version 1.7.0. I've dropped all repackaged Cglib code a few hours ago. 
I was going to release PowerMock 1.7.0 on next week, but I think I'll postpone it until issue with `saflyGetMockName` will be fixed and released. 
It will give me ability to delete PowerMockMaker and make code simple.  =||= Answers to your questions below :) Thank you for pushing this forward!

>Just to make sure that we're on the same page. Does you mean to raise a pull request with the change on reporter?

I was hoping you can hack the code, test locally if things work, and expose harder problems. I need to think a little bit about what's the best way to solve the Reporter.

Are you sure that there are no other ```import ""org.mockito.internal""``` in Powermock codebase?

>PowerMock have used repackaged CglibMockMaker until version 1.7.0. I've dropped all repackaged Cglib code a few hours ago.

Got it. Thank you! =||= I have investigated Powermockito codebase and found out that the problem is that MockHandler API in Mockito is not quite finished. Therefore Powermockito had to create custom implementation of MockHandler despite our Javadoc saying:

> This api is work in progress. Do not provide your own implementations.

(I'm not complaining, I very much sympathize. Many times I needed to resort to using internal API because I had no choice. Thanks again for engaging with us on cleaning the APIs between both libraries!)

@thekingnothing, if we make the MockHandler API public, will this work for you? I've initiated the efforts here: https://github.com/mockito/mockito/pull/1121 My initial thought is that after #1121 is applied, we can just move the InternalMockHandler methods onto MockHandler and delete InternalMockHandler. In Powermockito you can then create implementation of MockHandler that works with static mocking. How does it sound? =||= I'm sorry, I didn't have a time to answer earlier. I was driving a car to Prague and back. I'm still limited in access and writing from mobile phone. Sorry for some inaccuracies.


> Are you sure that there are no other import ""org.mockito.internal"" in Powermock codebase?


I'm sure that there are a lot of such places in codebase, because PowerMock has package `org.powermock.api.mockito.internal` where locate classes which either extends Mockito internal API or provides hacks for it.


> @thekingnothing, if we make the MockHandler API public, will this work for you?


As we discuss earlier, if you resolve an issue with `saflyGetMockName`, then there will be no reason to implement `MockMaker` and `MockHandler` by PowerMock. I'll remove `PowerMockMaker` as result `PowerMockInternalMockHandler` will be removed.


Let's move to another issue:


-  to create a mock, PowerMock uses MockMaker. But to get an instance of MockMaker I have to call `Plugins.getMockMaker()` - internal API call

- Then to create a mock I have to pass a `MockHandler` to `createMock`. I found only one way to do it use `MockHandlerFactory` - one more internal use

- to create `MockHandler` the settings is required. Everything is pretty good with `Mockito.withSettings`, except that I need to set mock type.

- the instance of `MockHandler` is used to create `MockitoMethodInvocationControl`. This class is full of internal calls and dirty hacks.


Btw, one of hack in `MockitoMethodInvocationControl` , as I remember, that it replaces a field in `mockHandler`, by own copy-past implementation only for one purpose: fix and issue with getting mock name in `toString()`. So `saflyGetMockName` not only place with such issue. But I think, I have to revisit this part of code and double check it. If getting mock name works for 'noMoreInteractionsWanted` it should work for `toString`. Hmm, maybe it will be better to keep PowerMockMacker.

Best regrads,
Arthur Zagretdinov

On 12 Jun 2017, at 06:57, Szczepan Faber <notifications@github.com<mailto:notifications@github.com>> wrote:


I have investigated Powermockito codebase and found out that the problem is that MockHandler API in Mockito is not quite finished. Therefore Powermockito had to create custom implementation of MockHandler despite our Javadoc saying:

This api is work in progress. Do not provide your own implementations.

(I'm not complaining, I very much sympathize. Many times I needed to resort to using internal API because I had no choice. Thanks again for engaging with us on cleaning the APIs between both libraries!)

@thekingnothing<https://github.com/thekingnothing>, if we make the MockHandler API public, will this work for you? I've initiated the efforts here: #1121<https://github.com/mockito/mockito/pull/1121> My initial thought is that after #1121<https://github.com/mockito/mockito/pull/1121> is applied, we can just move the InternalMockHandler methods onto MockHandler and delete InternalMockHandler. In Powermockito you can then create implementation of MockHandler that works with static mocking. How does it sound?

—
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub<https://github.com/mockito/mockito/issues/1110#issuecomment-307689935>, or mute the thread<https://github.com/notifications/unsubscribe-auth/AMkKAFA6px5b5jlYHTkvPbx7ttm7T8rWks5sDMUfgaJpZM4Nw8mA>.
 =||= @thekingnothing Just a question to understand the ""saflyGetMockName"" problem: What is missing here on the mockito side or what is not working as you expect? Do you get null as mock name?

@szczepiq  As far as I can see InternalMockHandler needs to be part of the public API since `MockUtil.getMockHandler(T mock)` returns this type. An other option would be to move its's methods to the super class. =||= >@szczepiq As far as I can see InternalMockHandler needs to be part of the public API since MockUtil.getMockHandler(T mock) returns this type. An other option would be to move its's methods to the super class.

Yup, that's the plan :) I was thinking of just moving those methods onto MockHandler and killing InternalMockHandler. Thanks for joining the discussion! =||= >I'm sorry, I didn't have a time to answer earlier. I was driving a car to Prague and back. I'm still limited in access and writing from mobile phone. Sorry for some inaccuracies.

No worries. Hopefully you had good time in Prague!

>As we discuss earlier, if you resolve an issue with `saflyGetMockName`, then there will be no reason to implement `MockMaker` and `MockHandler` by PowerMock. I'll remove `PowerMockMaker` as result `PowerMockInternalMockHandler` will be removed.

Making ""saflyGetMockName"" lenient is only good for short term experimentation. In the future, other features of Mockito will be accessing MockHandler in Powermockito static scenarios and it can cause failures. Let's come up with a proper solution :) Plus, if we make MockHandler public, Powermockito use will be better: we will actually print decent static mock name in verification errors.

Please give public MockHandler a second thought and get back to us with any feedback. You would be able to keep PowerMockInternalMockHandler, just make it extend public type MockHandler. =||= > What is missing here on the mockito side or what is not working as you expect? Do you get null as mock name?

It throws `NotAMockException` for case of static mocking. The `saflyGetMockName` tries to get mockHandler from mockMaker. If PowerMock doesn't provide custom implementation  of `MockMaker` then mock handler is null and exception is thrown.
If `PowerMockMaker` is used, then it leads to issues with `mock-maker-inline` for non-PowerMock tests.
As for me,  consequences of  `PowerMockMaker` worse than empty empty string as mock name.

Best regrads,
Arthur Zagretdinov

On 13 Jun 2017, at 16:03, Christian Schwarz <notifications@github.com<mailto:notifications@github.com>> wrote:


@thekingnothing<https://github.com/thekingnothing> Just a question to understand the ""saflyGetMockName"" problem: What is missing here on the mockito side or what is not working as you expect? Do you get null as mock name?

@szczepiq<https://github.com/szczepiq> As far as I can see InternalMockHandler needs to be part of the public API since MockUtil.getMockHandler(T mock) returns this type. An other option would be to move its's methods to the super class.

—
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub<https://github.com/mockito/mockito/issues/1110#issuecomment-308126025>, or mute the thread<https://github.com/notifications/unsubscribe-auth/AMkKAF_Axzuc6xy3CbBUqIA7f7TheHfPks5sDpaQgaJpZM4Nw8mA>.
 =||= >-  to create a mock, PowerMock uses MockMaker. But to get an instance of MockMaker I have to call `Plugins.getMockMaker()` - internal API call

We should be able to address this by adding public API for default MockMaker instance. Easy to address. I haven't put enough thought to it but it seems easy so let's move on to next problem.

> - Then to create a mock I have to pass a `MockHandler` to `createMock`. I found only one way to do it use `MockHandlerFactory` - one more internal use

Why do you need to create instances of MockHandlers? Can you point some code? Keep in mind that we are making MockHandler public so you should be able to provide your own implementation if needed.

> - to create `MockHandler` the settings is required. Everything is pretty good with `Mockito.withSettings`, except that I need to set mock type.

Why setting mock type is problematic? Is it for static mocking scenario? Can you point some code?

> - the instance of `MockHandler` is used to create `MockitoMethodInvocationControl`. This class is full of internal calls and dirty hacks.

:) we will resolve them all :)

Nice progress!

I suggest we do this: I will push to my branch Mockito with cleaned up MockHandler API. You can build Mockito jar from source, from that branch and see how it fits Powermockito use case. Let's see how much internal API we can resolve by cleaning up MockHandler API. I will make changes on ""sf"" branch by the end of today.

Thanks again for working on this! =||= I have two concerns regarding keeping `PowerMockInternalMockHandler`

1.   It requires implementing `PowerMock` and leads to issue with `mock-maker-inline`. 
1.   PowerMock never use `PowerMockInternalMockHandler`  by itself. only for handling case ""static mock name`

I'm entering on thin ice. If I choice to keep `PowerMockInternalMockHandler` and have more logic in it,  I have to keep in mind that PowerMock works with EasyMock. As I see, I have two options: have better integration with Mockito, but duplicate logic for EasyMock and Mockito. Or implement some general things same for EasyMock and Mockito, but not use full power integration with Mockito. 

> Why do you need to create instances of MockHandlers? Can you point some code? Keep in mind that we are making MockHandler public so you should be able to provide your own implementation if needed.

The instance is used later to handle static/non-public method call by `MockitoMethodInvocationControl`.  MockitoMethodInvocationControl implements MethodInvocationControl, `MethodInvocationControl` is a proxy for Mockito and EasyMock API. 

When method is called, PowerMock looks for `MethodInvocationControl` for the method's signature and delegates handling call to `MethodInvocationControl`. In Mockito case, `MockitoMethodInvocationControl` uses  `MockHandler`  to handle method invocation. 

```

Invocation invocation = new InvocationImpl(
            interceptionObject,
            new DelegatingMethod(method),
            arguments,
            SequenceNumber.next(),
            cleanTraceRealMethod,
            new LocationImpl()
        );
        
        try {
            return mockHandler.handle(invocation);
        } catch (NotAMockException e) {
            if (invocation.getMock()
                          .getClass()
                          .getName()
                          .startsWith(""java."") && MockRepository.getInstanceMethodInvocationControl(invocation.getMock()) != null) {
                return invocation.callRealMethod();
            } else {
                throw e;
            }
        } catch (MockitoAssertionError e) {
            InvocationControlAssertionError.updateErrorMessageForMethodInvocation(e);
            throw e;
        }

``` 

[source](https://github.com/powermock/powermock/blob/e7a20f6507ee28675567893384ceaba64d61245c/powermock-api/powermock-api-mockito2/src/main/java/org/powermock/api/mockito/internal/invocation/MockitoMethodInvocationControl.java)

> Why setting mock type is problematic? 

`MockSettings` does not have public method to set type. 

> Is it for static mocking scenario? Can you point some code?

I have to check when it is required. 

 ```

        final MockSettingsImpl<T> settings;
        final MockMaker mockMaker = getMockMaker();
        
        if (mockSettings == null) {
            settings = (MockSettingsImpl) Mockito.withSettings();
        } else {
            settings = (MockSettingsImpl) mockSettings;
        }
        
        if (isSpy) {
            settings.defaultAnswer(Mockito.CALLS_REAL_METHODS);
        }
        
        settings.setMockName(new MockNameImpl(mockName));
        //settings.setTypeToMock(type);
        
        InternalMockHandler mockHandler = MockHandlerFactory.createMockHandler(settings);
        
        T mock = mockMaker.createMock(settings, mockHandler);

```

[source]( 
https://github.com/powermock/powermock/blob/e7a20f6507ee28675567893384ceaba64d61245c/powermock-api/powermock-api-mockito2/src/main/java/org/powermock/api/mockito/internal/mockcreation/DefaultMockCreator.java)

> Please give public MockHandler a second thought and get back to us with any feedback. You would be able to keep PowerMockInternalMockHandler, just make it extend public type MockHandler.
> I suggest we do this: I will push to my branch Mockito with cleaned up MockHandler API. You can build Mockito jar from source, from that branch and see how it fits Powermockito use case. Let's see how much internal API we can resolve by cleaning up MockHandler API. I will make changes on ""sf"" branch by the end of today.

Anyway, I'm going to focus on release in near few days. I have to clear documentation for the release. After release, I'll build PowerMock with your change and check. 

Thank you for providing me help with it! :)  =||= Thank you for all the information - it is super useful! I will work on the MockHandler API (this needs to be sorted out anyway). Later, I will reply with more details to your last comment. =||= I'm making progress on exposing MockHandler API but it is taking more time than I have anticipated. Hah, I love engineering :D !!!

>I'm entering on thin ice. If I choice to keep PowerMockInternalMockHandler and have more logic in it, I have to keep in mind that PowerMock works with EasyMock. As I see, I have two options: have better integration with Mockito, but duplicate logic for EasyMock and Mockito. Or implement some general things same for EasyMock and Mockito, but not use full power integration with Mockito.

I suspect that own implementation of MockHandler unavoidable. MockUtil.getMockHandler() is used in bunch of other places and fixing the Reporter case with mock name will be a very short term solution.

Let's push forward with making MockHandler public. I suspect that once this API is neatly public, you should be able to implement PowerMockMaker that supports static mocking scenarios. I'll keep you posted on the progress!

 =||= @thekingnothing, how can I try out Powermockito? When I clone the repo and import it to IDEA, tests don't work in IDEA. This makes it hard to debug. I love debugging to learn how stuff works. Can you tell me how do I import Powermockito code to IDEA so that I can run some static mocking testing with Powermockito? Thanks in advance :) =||= > I suspect that own implementation of MockHandler unavoidable. MockUtil.getMockHandler() is used in bunch of other places and fixing the Reporter case with mock name will be a very short term solution.

Okay, I'm throwing in the towel :) I'll keep own implementation of MockHandler. in this case, it's hight important have ability use `PluginLoader` to prevent issues like https://github.com/powermock/powermock/issues/811

> @thekingnothing, how can I try out Powermockito? When I clone the repo and import it to IDEA, tests don't work in IDEA. This makes it hard to debug. I love debugging to learn how stuff works. Can you tell me how do I import Powermockito code to IDEA so that I can run some static mocking testing with Powermockito?

What issue did you have? Have you tried to build it with gradle?  I've just cloned repository from master and imported to IntelliJ Idea as Gradle project and was able to run static tests.  

Anyway, it was a tricky moment that modules depended on mockito had two test/source sets that pointed to same java source path. It was done to be able to test same code against mockito 1.x and mockito 2.x I've created a new branch `mockito2` where I dropped supporting Mockito 1.x and removed all complicated logic from Gradle. Could you try with the branch?  =||= > I've created a new branch mockito2 where I dropped supporting Mockito 1.x and removed all complicated logic from Gradle. Could you try with the branch?

I will try it. Thank you!

>Okay, I'm throwing in the towel :) I'll keep own implementation of MockHandler. in this case, it's hight important have ability use PluginLoader to prevent issues like powermock/powermock#811

Ok :) BTW. I made progress in my branch but it's late and will check in the morning what's the status. I think I managed to expose the API so that Powermockito can stop depending on the internal API wrt to the MockHandler. =||= @thekingnothing, can you try out building Mockito from ""sf"" branch? ""./gradlew build"" produces binaries, ""./gradlew publishToMavenLocal"" builds and installs binaries to local maven repo. Things I changed:
 - MockHandler API is public and you can provide your own implementation :) Just don't provide your own implementation of mockHandler.getInvocationContainer()
 - you can create an instance of MockCreationSettings using a new public API: ""Mockito.withSettings().name(""foo"").build()"".

Let us know how it goes! =||= @szczepiq, thank you! 

I built Mockito from branch and tried to run(after all compile issues were resolved) and one major issue appeared. 
`PowerMockitoStubberImpl` has the method `addAnswersForStubbing` which use deleted `MockHandler.setAnswersForStubbing`.

```
    @SuppressWarnings(""unchecked"")
    private void addAnswersForStubbing(MockitoMethodInvocationControl invocationControl) {
        final MockHandler mockHandler = invocationControl.getMockHandler();
        final List list = Whitebox.getInternalState(this, List.class);
        try {
            Whitebox.invokeMethod(mockHandler, ""setAnswersForStubbing"", list);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

```

What do you think better to do in this case?  =||= > you can create an instance of MockCreationSettings using a new public API: ""Mockito.withSettings().name(""foo"").build()"".

Great! Now, `PowerMockMaker` has been cleared from internal imports 

```
import org.mockito.Mockito;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.InvocationContainer;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
import org.powermock.configuration.GlobalConfiguration;
```

But I have to cast to `MockSettingsImpl` still in `DefaultMockCreator`, because if a `mockSettings` is specified I have two options: 
- implement logic of cloning `mockSettings`. But it also requires using internal Mockito's classes  
- set name and type to existing `mockSettings`

Is it possible to add method to builder creating mockSetting from existing settings?
 =||= >But I have to cast to MockSettingsImpl still in DefaultMockCreator, because if a mockSettings is specified I have two options:

I need to understand the use case more. Can you point out to the code?

>set name and type to existing mockSettings

This seems like a reasonable option. Would this work for you?

Happy we are making progress! =||= > I need to understand the use case more. Can you point out to the code?

Example from the `DefaultMockCreator`. I didn't commit code after refactoring,  but it's very close to old code.
```
    private static <T> MockSettingsImpl<T> getMockSettings(final String mockName, final Class<T> type, final boolean isSpy, final MockSettings mockSettings) {
        final MockSettingsImpl<T> settings;
        if (mockSettings == null) {
            settings = (MockSettingsImpl) Mockito.withSettings();
        } else {
            settings = (MockSettingsImpl) mockSettings;
        }
        
        if (isSpy) {
            settings.defaultAnswer(Mockito.CALLS_REAL_METHODS);
        }
        
        settings.setMockName(new MockNameImpl(mockName));
        settings.setTypeToMock(type);
        return settings;
    }
``` =||= >Is it possible to add method to builder creating mockSetting from existing settings?

There are 2 separate asks here:
1. Create settings object conveniently, with the type
2. Creating settings object from other settings object (e.g. copy)

I fully understand the use case behind 1) - in static mocking scenario you need custom mock handler with custom mock name. I don't understand why we need 2) and the code sample does not explain why. I hope you don't really need 2) given 1) is implemented ;)

For 1), you can already do it with the code that I pushed to the branch, new ""build"" public method: ```withSettings().build(Foo.class)```

Let us know how things are and what your progress is! =||= > For 1), you can already do it with the code that I pushed to the branch, new ""build"" public method: withSettings().build(Foo.class)

I change code in branch and use a new API. It helps clear `PowerMockMaker` from internals calls. 

Where are a least two reason why the 2) is asked: 

1. Set default answer if `PowerMockito.spy(Class<T> type)` or `PowerMockito.spy(T object)` (this part can be refactored, if take into account that public API does not provide ability to create spy with settings)
1. NPE exception in `SubclassByteBuddyMockMaker` and `InlineByteBuddyMockMaker` if mock type is not set, but a user provides custom settings via ` mockStatic(Class<?> classToMock, MockSettings mockSettings)` for example. 

```
java.lang.NullPointerException
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.prettifyFailure(SubclassByteBuddyMockMaker.java:90)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:77)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
	at org.powermock.api.mockito.mockmaker.PowerMockMaker.createMock(PowerMockMaker.java:50)
	at org.powermock.api.mockito.internal.mockcreation.DefaultMockCreator.createMethodInvocationControl(DefaultMockCreator.java:116)
```

```
90:     if (mockFeatures.getTypeToMock().isArray()) {
            throw new MockitoException(join(
                    ""Mockito cannot mock arrays: "" + mockFeatures.getTypeToMock() + ""."",
                    """"
                    ), generationFailed);
        }
``` =||= Thank you for working on this! I would love to see us getting to the conclusion - nice demonstration of 2 library owners working together to develop clean & flexible API :)

>if take into account that public API does not provide ability to create spy with settings

Here's how you can create spy with settings:

```java
        return mock(classToSpy, withSettings()
                .useConstructor()
                .defaultAnswer(CALLS_REAL_METHODS));
```

>NPE exception in SubclassByteBuddyMockMaker and InlineByteBuddyMockMaker if mock type is not set

Can you address this issue by making sure Powermockito mocks have the mock type?

Where are we at this point? What are the remaining gaps? =||= > Thank you for working on this! I would love to see us getting to the conclusion - nice demonstration of 2 library owners working together to develop clean & flexible API :)

Thank you for assisting me. I'm also really happy to see how we move. It's a big win for community!  

> Can you address this issue by making sure Powermockito mocks have the mock type? 
Here we come to main reason why I asked ""Creating settings object from other settings object (e.g. copy)"". I need ability to set mock type and mock name to already defined mock settings.    =||= >Here we come to main reason why I asked ""Creating settings object from other settings object (e.g. copy)"". I need ability to set mock type and mock name to already defined mock settings.

Ok :) Can you point me to the code where it is needed? I'd like to fully understand the use case. The previous code you showed did not validate this need. Or perhaps you you can walk me through the workflow that explains the need for copying settings object? Ideally, I'd like to grow public API in smallest possible steps to keep it clean.

Thank you for patience! =||= accidentaly closed :) =||= Okay, let's go through the flow. 

The `PowerMockito` has methods:

```
    public static synchronized void mockStatic(Class<?> type, Class<?>... types) {
        ThreadSafeMockingProgress.mockingProgress().reset();
        DefaultMockCreator.mock(type, true, false, null, null, (Method[]) null);
        if (types != null && types.length > 0) {
            for (Class<?> aClass : types) {
                DefaultMockCreator.mock(aClass, true, false, null, null, (Method[]) null);
     }
   }
   }
```

```
    public static void mockStatic(Class<?> classToMock, MockSettings mockSettings) {
        ThreadSafeMockingProgress.mockingProgress().reset();
        DefaultMockCreator.mock(classToMock, true, false, null, mockSettings, (Method[]) null);
  }
  }
 }
```

Both methods call 

`public <T> T createMock(Class<T> type, boolean isStatic, boolean isSpy, Object delegator,
                            MockSettings mockSettings, Method... methods)`

from `DefaultMockGreator`.

But one method passes `mockSettings` provided by user, the second passes `null`. 
As result I have to check it later in `private static <T> MockData<T> createMethodInvocationControl(final String mockName, Class<T> type,
                                                                 Method[] methods, boolean isSpy, Object delegator,
                                                                 MockSettings mockSettings)`

```
        
        if (mockSettings == null) {
            settings = (MockSettingsImpl) Mockito.withSettings();
        } else {
            settings = (MockSettingsImpl) mockSettings;
        }
        
        if (isSpy) {
            settings.defaultAnswer(Mockito.CALLS_REAL_METHODS);
        }
        
        settings.setMockName(new MockNameImpl(mockName));
        settings.setTypeToMock(type);
```

If for the first case when `settings` is null, I can use a new API and create a new settings with type. But for the second case it's impossible without using internal API. 


 =||= Thank you very much for very comprehensive description! With the new public API you can replace:

```java
settings.setTypeToMock(type);
```
with:
```
settings.build(type); //this actually returns new object that you can use to create mocks.
```

Can you try it out and let me know if it works? =||= Thank you! It's my fall. I was thinking that you added a method to an other class. I'm sorry for misunderstanding. 
Now, I'm getting stuck with setting name. The following method is used to calculate mock name. 

```
    
    private String toInstanceName(Class<?> clazz, final MockSettings mockSettings) {
        // if the settings define a mock name, use it
        if (mockSettings instanceof MockSettingsImpl<?>) {
            String settingName = ((MockSettingsImpl<?>) mockSettings).getName();
            if (settingName != null) {
                return settingName;
            }
        }
        
        // else, use the class name as mock name
        String className = clazz.getSimpleName();
        if (className.length() == 0) {
            return clazz.getName();
        }
        // lower case first letter
        return className.substring(0, 1).toLowerCase() + className.substring(1);
    }
```

What could happen if PowerMock does not set a mock name? Will be name set by default by Mockito?  =||= >Now, I'm getting stuck with setting name

In what way you are stuck?

>What could happen if PowerMock does not set a mock name?

Try it out ;) From looking at Powermockito code, I think you should be able to get it working:
 - I think that ""toInstanceName"" method can be removed.
 - In ""createMethodInvocationControl"" method, when ""mockSettings"" is null, just create new settings object and pass the desired mocked type to new ""build()"" method I have added to the public API (you need to use Mockito branch I have created for you).

Hope that helps! =||= @thekingnothing, friendly ping :) =||= Thank you for reminding :) I have a personal issue, so I don't have enough time right now. But I hope, I'll find a few minutes to check it on next weekend.
 =||= Sounds good. I [wrote an article](https://www.linkedin.com/pulse/mockito-vs-powermock-opinionated-dogmatic-static-mocking-faber) what we are doing, your name is there, we need to finish it off :) =||= I still haven't had time to check settings. But I recall another issue, after you moved the `setAnswersForStubbing` from `MockHandler`

Could you check the [PowerMockitoStubberImpl](
https://github.com/powermock/powermock/blob/8b9cbbef00be3f035b1b9a7e4b2ee61f9db8572b/powermock-api/powermock-api-mockito2/src/main/java/org/powermock/api/mockito/internal/expectation/PowerMockitoStubberImpl.java) class? 

It has method that call `setAnswersForStubbing` via reflection.  What you can suggest to do in this case? 

```
    @SuppressWarnings(""unchecked"")
    private void addAnswersForStubbing(MockitoMethodInvocationControl invocationControl) {
        final MockHandler mockHandler = invocationControl.getMockHandler();
        final List list = Whitebox.getInternalState(this, List.class);
        try {
            Whitebox.invokeMethod(mockHandler, ""setAnswersForStubbing"", list);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
``` =||= I've finally got the time to look at and fix issue after changing settings API.  Everything looks good now: test are green. Hence we can move to a next issue. 

There are three Mockito's internal imports are left in `DefaultMockCreator`: 

* org.mockito.internal.configuration.plugins.Plugins — is used to get `MockMaker`. 
* org.mockito.internal.handler.MockHandlerFactory — is used to get an instance of a `MockHandler`. I'll replace it by PowerMock implementation. but this implementation will also use  internal classes like `MockHandlerImpl` and `NullResultGuardian`
* org.mockito.internal.util.reflection.LenientCopyTool — is used to copy values in case of spy.  =||= Fantastic! Thank you!

Can you check in your changes to the branch so that I can poke around the new implementation? I should be able to get answers / suggestions on the way forward soon. =||= I've already pushed my changes to 'mockito2' branch today in the morning.
 =||= >I've already pushed my changes to 'mockito2' branch today in the morning.

Great! I will pull the changes and look into the code sometime today. =||= I looked at the state of things and more work is needed. Can you help me understand why Powermock needs to explicitly create MockMaker instance to create mocks? Submitted PR with the idea here: https://github.com/powermock/powermock/pull/816 =||= We probably need to get on a video call to close down this project faster :) =||= > We probably need to get on a video call to close down this project faster :)

I think that it is a great idea. I'm still limited in time, but I hope it will be possible to schedule such call.  =||= > Can you help me understand why Powermock needs to explicitly create MockMaker instance to create mocks? 

PowerMock uses  `MockitoMethodInvocationControl` to handle static or non-public method invocation , new instance call and calls to system classes. There are two implementations of the `MethodInvocationControl`: `MockitoMethodInvocationControl` and `EasyMockMethodInvocationControl`. 

Mockito implementation is heavy rely on `MockHanlder`. PowerMock has to have access to mock's mockhandler. One of the way, that is used now, it's to create a instance of `MockHanlder`, the create a mock with using the created mockhanlder and then pass the same instance to `MockitoMethodInvocationControl`. 
The second way, create mock with settings by using public API, then if possible cast mock to `MockAccess` and get mockhanlder. 
Both approaches use internal Mockito API. 

Hmm, I've just realized that there is one more way to achieve the same goal. Create mock with using public API and then get MockHandler from `MockUtil`. Maybe it's possible. 

Anyway, PowerMock needs a public API to create a mock with settings and then get MockHandler for the mock. 
 =||= >Hmm, I've just realized that there is one more way to achieve the same goal. Create mock with using public API and then get MockHandler from MockUtil. Maybe it's possible.

Yup, that's exactly what I'm suggesting! Can you try to go on that path? In the meantime I'll figure out a way to offer public API to call ""handle"" method on the MockHandler. =||= Okay, I'll move forward with `MockUtil`. Only one concern, `MockUtil` is internal class. Is it possible to provide public API to get `MockHandler` for mock?  =||= I am working on adding that public API. Please continue with assumption
that this will be ready soon! ;)
On Sat, Jul 15, 2017 at 10:05 Arthur Zagretdinov <notifications@github.com>
wrote:

> Okay, I'll move forward with MockUtil. Only one concern, MockUtil is
> internal class. Is it possible to provide public API to get MockHandler
> for mock?
>
> —
> You are receiving this because you modified the open/close state.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1110#issuecomment-315518117>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AABgp7464XO7y1OdxI9dQf-AXPCVfd91ks5sOHLFgaJpZM4Nw8mA>
> .
>
-- 
Szczepan Faber
Founder @ http://mockito.org | Twitter https://twitter.com/mockitoguy
Author @ https://www.linkedin.com/in/szczepiq/recent-activity/posts/
 =||= I  already did it and pushed change to mockito2 branch. I've isolated most of dependency on Mockito internals in two classes [MockHandlerAdaptor](https://github.com/powermock/powermock/blob/mockito2/powermock-api/powermock-api-mockito2/src/main/java/org/powermock/api/mockito/invocation/MockHandlerAdaptor.java) and [MockitoMethodInvocationControl](https://github.com/powermock/powermock/blob/mockito2/powermock-api/powermock-api-mockito2/src/main/java/org/powermock/api/mockito/invocation/MockitoMethodInvocationControl.java)
When Mockito API will be ready you have a way to tested it by replacing code in these two classes.   =||= Can you check out Mockito 'sf' branch?
 - see ```StaticMockingExperimentTest``` that attempts to simulate static mocking with the current state of Mockito API (I know it is crude but... Rome wasn't built in a day :)
 - getting mock handler: ```Mockito.mockingDetails(mock).getMockHandler()```
 - creating invocation instances: ```Mockito.framework().createInvocation(...)```

I suspect that with that API you should be able to remove the internal API use completely. Please give it a shot :) =||= I'll move PowerMock to a new API and come back with feedback ASAP.  =||= Fantastic, thank you! =||= Friendly ping :) =||= Thank you for ping.

I looked at new API and your example. I partially applied them. But I've got stuck with replacing RealMethod with Callable. I have to refactor PowerMock code to be able to pass target to MockitoMethodInvocationControl.

I hope, I'll have a time to finish with it on the weekend. =||= Sounds good. Let me know if you need anything from me. =||= I closed the issue accidentally. 

Unfortunately, I didn't have enough time to resolve all issues. I'm continue working on it. 

But I have a question about stubbing . How do you see the flow with using this API for stubbing in case of static/private methods. 

```

  //register stubbed return value
        doReturn(""hey"").when(mock);

```

```
 =||= Ok, thank you for update! In 'sf' branch of Mockito project you can
find ""StaticMockingExperimentTest"". In this test, I simulated verification
and stubbing for static methods. Long term, we can improve the API. However
for now I hope it's enough for you to experiment and get it working :)
 =||= @szczepiq thank you for your talk in Krakow :) I was really glad to meet with you. I've moved significantly since Monday. I about to manage all issue that was raised. One think left to do - implementing verifyZeroIteration/verifyNoMoreIteration. And here I have two issues: 

1. Verify in case of constructor call 
1. Verify static and current PowerMock API 

According to current PowerMock API verify static starts like replayAll in EasyMock without pointing exactly a mock. 

```
verifyStatic();
ClassWithStatic.callStatic();

verifyStatic();
SecondClassWithStatic.callStatic();
```

This issue I'm going to fix by making current API as deprecated in PowerMock 1.x and replace by 

```
verifyStatic(ClassWithStatic.class);
ClassWithStatic.callStatic();

```

To fix first we need to thing about possibility to create an invocation for constructor.  =||= You're welcome! I am very happy you are making progress!!!

>This issue I'm going to fix by making current API as deprecated in PowerMock 1.x and replace by

The suggested API looks good from the standpoint of consistency / familiarity with existing Powermock API.

>To fix first we need to thing about possibility to create an invocation for constructor.

This is really hard. I was thinking about it recently and haven't come up with anything useful, yet. Will keep pondering about it. =||= I think I found a way to deal with mocking 'new'! How about we adapt constructor for method:

```java
interface ConstructorMethodAdapter {
  Object construct(Constructor constructor, Object ... args);
}
```

I simulated this idea in this new test, please take a look at it ;)

https://github.com/mockito/mockito/commit/ce8b7a4c53aefe569b947e9a0e453a1f0a1dbd18#diff-1225e53bd1e5da3454db07f964d72364R150

The test is already pushed to the 'sf' branch. =||= Hey @thekingnothing, with the ""ConstructorMethodAdapter"" trick, you should be able to mock 'new'. Is there any other gap we need to close down to clean up the interface? =||= I haven't tried your approach yet.

I focused on deprecating `verifyStatic`, releasing the PowerMock 1.7.1 to let community know about incompatible changes  in PowerMock 2.0.

I'm finishing with removing `verifyStatic` and I hope I'll have a time to try your approach with `ConstructorMethodAdapter`.

Best regrads,
Arthur Zagretdinov

On 13 Aug 2017, at 16:21, Szczepan Faber <notifications@github.com<mailto:notifications@github.com>> wrote:


Hey @thekingnothing<https://github.com/thekingnothing>, with the ""ConstructorMethodAdapter"" trick, you should be able to mock 'new'. Is there any other gap we need to close down to clean up the interface?

—
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub<https://github.com/mockito/mockito/issues/1110#issuecomment-322045089>, or mute the thread<https://github.com/notifications/unsubscribe-auth/AMkKAA_APUrwXDVtQfSFlKa_eVyd5sVOks5sXwaCgaJpZM4Nw8mA>.
 =||= Hi @szczepiq , how are you? :) I have a good news. We about to finish. There are two places are left in PowerMock where Mockito's internal packages age import.

First place, it is the annotation engine: PowerMock extends Mockito's `SpyAnnotationEngine` and `InjectingAnnotationEngine` classes and use `PowerMockito` for cases when Mockito cannot create a mock. I'm going to rewrite this part and unify with EasyMock implementation with general logic like 
1. Call mocking framework engine with public API like `MockitoAnnotation.init()` in Mockito case 
1. Catch exception and re-throw exception with modified message with suggestion to use PowerMock annotation on fields that cannot be mocked by Mockito
1. Call PowerMock annotation inject engine 

The second place, is more interesting. PowerMock has to detect if invocation is already caught by Mockito and Mockito tries to invoke real method.
 
```
/*
           * If we come here and it means that the class has been modified by
           * PowerMock. If this handler has a delegator (i.e. is in spy mode in
           * the current implementation) and it has been caught by the Mockito
           * proxy before our MockGateway we need to know if the method is private
           * or not. Because if the previously described preconditions are met and
           * the method is not private it means that Mockito has already processed
           * the method invocation and we should NOT delegate the call to Mockito
           * again (thus we return proceed). If we would do that Mockito will
           * receive multiple method invocations to proxy for each method
           * invocation. For privately spied methods Mockito haven't received the
           * invocation and thus we should delegate the call to the Mockito proxy.
           */
        final Object returnValue;
        if (isCanBeHandledByMockito(method) && hasBeenCaughtByMockitoProxy()) {
            returnValue = MockGateway.PROCEED;
        }

```
It has very ugly implementation right now. 

```
    private boolean hasBeenCaughtByMockitoProxy() {
        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
        StackTraceFilter filter = new StackTraceFilter();
        /*
        * We filter the stack-trace to check if ""Mockito"" exists as a stack trace element. (The filter method
        * remove all Mockito stack trace elements). If the filtered stack trace length is not equal to the original stack trace length
        * this means that the call has been caught by Mockito.
        */
        final StackTraceElement[] filteredStackTrace = filter.filter(stackTrace, true);
        return filteredStackTrace.length != stackTrace.length;
    }

```  
 
Do you have idea how to avoid such dirty code?  =||= >Hi @szczepiq , how are you? :) I have a good news. We about to finish

Great! When we are ready, I will need to spend some time to polish Mockito changes and poll the community for feedback. It probably will take me a week.

>First place, it is the annotation engine: PowerMock extends Mockito's SpyAnnotationEngine and InjectingAnnotationEngine classes and use PowerMockito for cases when Mockito cannot create a mock.

Your idea with wrapping Mockito's exceptions seems like a reasonable plan at the time being. It's not a clean solution but it feels that we should focus on the core use cases and eliminate the internal API use. Then we can make the solution perfect.

I am wondering how this Powermockito API will blend with Mockito's JUnit Rule / Mockito JUnit Runner / MockitoSession. When we finish, I'd like to help reviewing Powermockito test coverage and possibly suggest few additions :)

>The second place, is more interesting. PowerMock has to detect if invocation is already caught by Mockito and Mockito tries to invoke real method

Very interesting. Let me think about this use case. Can you point me to the code in Powermockito codebase and what branch I can find your changes? =||= > Very interesting. Let me think about this use case. Can you point me to the code in Powermockito codebase and what branch I can find your changes?

Branch: 2.x/mockito2, class `MockitoMethodInvocationControl`. 

> I am wondering how this Powermockito API will blend with Mockito's JUnit Rule / Mockito JUnit Runner / MockitoSession. 

I think the same way, as it work right now. If a developer use PowerMockRunner then all fields annotated with  `@Mock`  are created and injected into `@InjectMocks`. So there is no reason to use  
Mockito's JUnit Rule / Mockito JUnit Runner. 
 =||= Thank you! I loaded Powermockito to the IDEA and most tests worked :)

I have some ideas how to approach the problem with MockitoMethodInvocationControl. I'm using ""samples.powermockito.junit4.annotationbased.SpyAnnotationTest#spyingOnPrivateMethodsWorksWithSpyAnnotation"" for debugging this use case. I'll let you know by the end of today what's up. =||= I have been debugging the issue and submitted a pull request to Powermock with an idea to tackle the private spy use case: https://github.com/powermock/powermock/pull/834 Let me know if you can leverage this idea to move forward!

Thank you for working on this! =||= I have checked the pull request. I think, I have got your idea, but it will work only in case if a mock is created with using `PowerMockito`. But if a mock is created with using `Mockito` and added to `@PrepareForTest` then it will be loop with stack overflow.
 =||= > But if a mock is created with using `Mockito` and added to `@PrepareForTest` then it will be loop with stack overflow.

Thank you for review! Can you point me to the unit test that demonstrates this use case? Powermock documentation indicates that we need to use both `@PrepareForTest` and `PowerMockRunner` alltogether. I have tried below but it does not seem to reproduce the scenario (test is based on existing ""SpyAnnotationTest"" test class in the powermock codebase):

```java
@RunWith(PowerMockRunner.class)
@PrepareForTest(PrivatePartialMockingExample.class)
public class SpyAnnotation2Test {

	@Test
	public void spyingOnPrivateMethodsWorksWithSpyAnnotation() throws Exception {
		PrivatePartialMockingExample underTest = Mockito.spy(new PrivatePartialMockingExample());

		final String expected = ""TEST VALUE"";
		final String nameOfMethodToMock = ""methodToMock"";
		final String input = ""input"";
		when(underTest, nameOfMethodToMock, input).thenReturn(expected);

		assertEquals(expected, underTest.methodToTest());

		verifyPrivate(underTest).invoke(nameOfMethodToMock, input);
	}
}
``` =||= I have double checked the case that I meant. It's not an issue any more. I think that  it was the issue with Cglib approach, because fix for the issue also included changes in Cglib handlers and determining is class a proxy.

For case that you debugged - your will work regarding what API is used.

If PowerMock is used then marker will show that a method is already handled.
If Mockito - then MockitoInvocationControl will not be created.

One case better to check: verifying public methods for mocks created with PowerMock and  inline mock maker.

As I remember, inline mock maker uses current thread context class loader to redefine class. In case of PowerMock class loader, PowerMock code will be injected at the beginning of redefined class. As result, PowerMock code could be called first. =||= In what way powermock supports Mockito’s plugins such as MockMaker? In what way the inline MockMaker is supported?

In my ‘sf’ branch in Mockito I added a new experimental public API so that you can get hold of default Mockito plugins:

```Java
Mockito.framework().getMockitoPlugins().getDefaultPlugin(MockMaker.class);
```

However, I am not sure how this API is useful because I see that Powermock has some complexity around inline mock maker. =||= > In what way powermock supports Mockito’s plugins such as MockMaker? In what way the inline MockMaker is supported?

PowerMock requires that there is no `org.mockito.plugins.MockMaker` in classpath except one that locates in `powermock-api-mockito.jar` in case if PowerMock is used and locates in classpath. It's needed to avoid possible issues when another MockMaker will be loaded instead `PowerMockMaker`.

But PowerMock provides ability to configure to which MockMaker the `PowerMockMaker` has to delegate calls. 

> However, I am not sure how this API is useful because I see that Powermock has some complexity around inline mock maker.

Yes, I've already implemented another approach, so it will not help me. 
 =||= I've checked behaviour with inline-mock-maker and tests are passed. 

I think, you may start finalising public API and cleaning code. I'll do required changes on PowerMock side and then also clean and a bit refactor code.   =||= >I've checked behaviour with inline-mock-maker and tests are passed.

Great!

>I think, you may start finalising public API and cleaning code. 

Will do!

>I'll do required changes on PowerMock side and then also clean and a bit refactor code.

Can you make sure that none of the Powermock code imports ""org.mockito.internal.*"" packages? Internal classes, e.g. classes that reside underneath ""org.mockito.internal.*"" can change without notice with any version of Mockito, those classes are not considered public API. In current ""mockito2"" branch in Powermock I still references to internal Mockito classes.

Do I need to provide you public API to get hold of the default implementation of MockMaker (inline or not)? =||= > Can you make sure that none of the Powermock code imports ""org.mockito.internal."" packages? Internal classes, e.g. classes that reside underneath ""org.mockito.internal."" can change without notice with any version of Mockito, those classes are not considered public API. In current ""mockito2"" branch in Powermock I still references to internal Mockito classes.

I can find several places where `org.mockito.internal` is mentioned in code:

1. Annotation processing - will be rewritten, not an issue 
1. Checking if method was called - as I'll change it as we discuss 
1. Several test - some of them will be refactored, for some of them it's not a big deal because string `org.mockito.internal` is used just as test data
1. Configuration - using `mock-maker-inline` as alias `org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker` - it has to be changed maybe. 

> Do I need to provide you public API to get hold of the default implementation of MockMaker (inline or not)?

No, I don't need a public API for getting an instance of `MockMaker`. But it will be useful to get class of default MockMaker or class base on alias.   =||= Thank you for reviewing the code!

>No, I don't need a public API for getting an instance of MockMaker. But it will be useful to get class of default MockMaker or class base on alias.

I see. Let me know if you need the instance. Exposing implementation class name is something I would like to avoid because the implementation class is internal and we want the flexibility of replacing it if needed. I can provide you the instance, but if you don't need the instance, I'd rather implement as little new public API as possible.

That said, I do believe that you need public API from Mockito to give you the instance of default MockMaker :) Please confirm =||= That I really need, chain of response for MockMaker with ability setting order/priorities. In this case, I will put PowerMockMaker first in the chain, handle call only for mock created with PowerMockito and continue chain otherwise.

Second option- it's get an insane of `MockMaker` base on class name or allies , because PowerMock provides the same flexibility as Mockito. A developer may specify a class or allies in configuration.
 =||= From our conversation and my understanding how Powermock works, it looks like you need access to default MockMakers ;) I'll provide API for that. I think it is a reasonable addition to Mockito public API. =||= Access to instance of default MockMaker will not help me, because I'll still create an instance of InlineMockMaker which locates in internal package.

Supporting of inline maker is one of higher demanded feature.


Best regrads,
Arthur Zagretdinov

On 18 Aug 2017, at 19:07, Szczepan Faber <notifications@github.com<mailto:notifications@github.com>> wrote:


From our conversation and my understanding how Powermock works, it looks like you need access to default MockMakers ;) I'll provide API for that. I think it is a reasonable addition to Mockito public API.

—
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub<https://github.com/mockito/mockito/issues/1110#issuecomment-323408603>, or mute the thread<https://github.com/notifications/unsubscribe-auth/AMkKAFMi0auTj3FIcoAfmwAAGCqjhSpJks5sZcSggaJpZM4Nw8mA>.
 =||= Main idea, is that Android developers, especially Kotlin developers, want to use PowerMock for mocking static methods and Mockito for any other purpose like mocking final classes. But Mockito allows to declare only one MockMaker in class path. So if PowerMock put the file for in jar as it is done now, then a developer cannot declare and use inline MockMaker. 



 =||= For what it is worth I opened a ticket for both Mockito and PowerMock to
address this but it was closed saying it will be addressed in Mockito 3. I
have old branches that allow a user to switch manually. =||= There is no reason to provide ability for manual switching. It will face the same issue - using Mockito and PowerMock internal packages. =||= I've added new public api and changed existing API in my experimental branch 'sf'. Please try it out before I start polishing the code further. Here're the changes I made:

```java
//for MockMakers:
Mockito.framework().getPlugins().getDefaultPlugin(MockMaker.class);
Mockito.framework().getPlugins().getInlineMockMaker();

//changed a little bit how Invocations are created:
Mockito.framework().getInvocationFactory().createInvocation(...);
```

Please confirm that this is all we need to get rid of all ""org.mockiton.internal"" from Powermock codebase.
 =||= Exciting :) We're almost done! =||= Once this process is completed, we should publish a new version to maven
central and announce on like Twitter. I have been following this thread for
a while now, this is great work! =||= Thank you! I agree completely. I am also looking forward to the happy ending :) =||= > Please confirm that this is all we need to get rid of all ""org.mockiton.internal"" from Powermock codebase.

I confirm. I've just push changes where ""org.mockiton.internal"" is used only in one place. It is annotation processing. As I mentioned earlier, I'm going create a additional task for it and completely rewrite this part, because EasyMock version also have such problem. I'm going to create a one annotation engine for Mockito and EasyMock.  =||= I've started code clean up and one interesting idea came to my mind. If I'm able to create a custom implementation of `MockitoSettings`, then I'll implement all mock creating logic in `PowerMockCreator` instead using custom class that uses `Mockito.mock`. 

In this case, `PowerMockito` could delegate all calls to `Mockito` with custom `MockitoSettings`. What do you think?  =||= > I confirm. I've just push changes where ""org.mockiton.internal"" is used only in one place.

Fantastic!!!

>I've started code clean up and one interesting idea came to my mind. If I'm able to create a custom implementation of MockitoSettings, then I'll implement all mock creating logic in PowerMockCreator instead using custom class that uses Mockito.mock.

Do you mean something like that:

```Java
//instead:
PowerMockito.mockStatic(MyClass.class, Mockito.withSettings().name(""foo""));
//you would do:
Mockito.mock(MyClass.class, PowerMockito.withSettings().staticMock().name(""foo""));
```

Very interesting! Can you scope this and list down the pros & cons of both approaches?

Cons:
 - Mockito teams considers adding new methods to MockSettings as compatible changes because we don't recommend MockSettings to be subclassed. We need that ability, otherwise we would have to ship a major version of Mockito every time we add a new method to ""Mockito"" or ""MockSettings"" classes. If you provide custom interface that extends MockSettings you might be exposed to incompatible changes with minor versions of Mockito. We could potentially discuss this point and figure out a solution that would work for Powermockito.
 - New API would be different from what your users are accustomed to and might be more problematic to roll out, discourage from upgrading. Users still have to know about Powermockito static method entry point, regardless if it is PowerMockito.mock or PowerMockito.withSettings

Prons (I'm not sure, you can help out with this):
 - Are you looking to remove Powermockito class and have less code to maintain? Is it the goal that sparked this idea?
 - It would be cool to unify the API so that to use Powermockito the one uses normal Mockito API and drops some annotation to the class or method to signify to use Powermockito behind the hood. It does seem like a lot of work, though.

Hope that helps! =||= > Are you looking to remove Powermockito class and have less code to maintain? Is it the goal that sparked this idea?

No, I'm not going to drop `PowerMockito`, because is has API for new and private code mocking. I thinking about putting code that create mock in one place. Right now the creating mock logic is spread between at least two classes: `PowerMockMaker` and `DefaultMockCreator`. First implements Mockito's interface and has logic with handler and so on, the second is use to create mock by PowerMock and validate mock (duplicates `TypeMockability`).

>  Do you mean something like that:

> //instead:
> PowerMockito.mockStatic(MyClass.class, Mockito.withSettings().name(""foo""));
> //you would do:
> Mockito.mock(MyClass.class, PowerMockito.withSettings().staticMock().name(""foo""));

It's one of the option. `PowerMockito` will still have `mockStatic` as shortcut for `PowerMockito.withSettings().staticMock()`. 

> It would be cool to unify the API so that to use Powermockito the one uses normal Mockito API and drops some annotation to the class or method to signify to use Powermockito behind the hood. It does seem like a lot of work, though.

I agree, that it will be nice to have PowerMock as plugin to Mockito for mocking cases such as mock static, system and new. All these 3 cases could be covered by using Java Agent and class redefining with using ByteBuddy and without using custom class loader. 
 =||= I think that we can stop for now. Make Mockito release with new API, first beta PowerMock 2.0 and continue discuss feature change. We have achieved our goal - removing using Mockito private API.  =||= I have raised a pull request https://github.com/powermock/powermock/pull/837 to merge all change and prepare for release. I'm waiting only while Mockito code will be cleaned and released.  =||= Sounds good. We're on it! =||= I made first pass on the changes and the public API. Looks good, we are not far from being ready to merge!

### New public API

org.mockito.MockSettings#build
org.mockito.MockingDetails#getMockHandler
org.mockito.MockitoFramework#getPlugins
org.mockito.MockitoFramework#getInvocationFactory
Deprecated org.mockito.internal.InternalMockHandler
org.mockito.invocation.InvocationContainer
org.mockito.invocation.InvocationFactory
org.mockito.invocation.MockHandler#getMockSettings
org.mockito.invocation.MockHandler#getInvocationContainer
org.mockito.NotExtensible

### TODO @szczepiq

1. Verify Powermock needs it
2. Add missing documentation / tests
3. Add (@)Since tag =||= Mockito 2.10.0 has been published!!! Wooot!

Nice work everybody, it tooks us 3 months but we made it :) @thekingnothing let us know if you need something! =||= Yeah! It was a great job. @szczepiq thank you a lot for help! I'm preparing a first beta release with using Mockito public API.  =||= @thekingnothing, how are things? Were you able to push a stable release of Powermock with new version of Mockito? Do you need help? Is there a ticket in Powermock that we can track?

Cheers! =||= @szczepiq, I'm continue working on PowerMock 2.0.0 release, but it's too early to talk about a stable release. I focused on JDK 9.0 support in past two weeks which was required for Kafka and Maven Surefire (https://github.com/powermock/powermock/issues/783). 

I also dropped the first public beta with supporting new Mockito API and I'm collecting first issues, like https://github.com/powermock/powermock/issues/853. 

Yes, there is a ticket where all issues to fix/implement are listed 
https://github.com/powermock/powermock/issues/725

 =||= ",0
1122,1117,Answer with delay in mock or spy to improve testing of asynchronous code,"I'm currently using Mockito for component testing of microservices.  All code should be run, up to the boundary at which another microservice is called.  In the component test, the mocks return very quickly, but obviously in integration testing, the real calls return much more slowly.  Some threading problems are revealed by the slow returns that would have been revealed in the component test if the returns could be forced to come back more slowly.  Since integration tests are *painfully* slow to start, this would save me, the developer, considerable time in debugging this kind of issue once I discover it in the integration tests.

Because it's so easy to write, I've already solved it with a class called AnswerWithDelay.  It takes another answer as a parameter, and inserts a little sleep before it returns.

If desired, I can turn this little helper into a PR for mockito. Or perhaps there's already something there that does this, that I've overlooked.

Best Regards,
Myrle

```
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT,
        classes = {AbstractRhythmTest.TestConfiguration.class},
        properties = {""rhythm.user=homer"", ""rhythm.beatCheckRate=500""}
)
public class AbstractRhythmTest {
  //...
  static class AnswerWithDelay<T> implements Answer<T> {
    private final int sleepyTime;
    private final Answer<T> answer;

    AnswerWithDelay(final int sleepyTime, final Answer<T> answer) {
      this.sleepyTime = sleepyTime;
      this.answer = answer;
    }

    @Override
    public T answer(final InvocationOnMock invocation) throws Throwable {
      TimeUnit.MILLISECONDS.sleep(sleepyTime);
      return answer.answer(invocation);
    }
  }

  Beat createBeat(
          final String applicationIdentifier,
          final String beatIdentifier,
          final int alignmentHour,
          final LocalDateTime expectedBeatTimestamp) throws InterruptedException {
    final String tenantIdentifier = tenantDataStoreContext.getTenantName();

    final Beat beat = new Beat();
    beat.setIdentifier(beatIdentifier);
    beat.setAlignmentHour(alignmentHour);

    Mockito.doAnswer(new AnswerWithDelay<>(2_000, new Returns(Optional.of(PermittableGroupIds.forApplication(applicationIdentifier))))).when(beatPublisherServiceSpy).requestPermissionForBeats(Matchers.eq(tenantIdentifier), Matchers.eq(applicationIdentifier));
    Mockito.doAnswer(new AnswerWithDelay<>(2_000, new Returns(true))).when(beatPublisherServiceSpy).publishBeat(Matchers.eq(beatIdentifier), Matchers.eq(tenantIdentifier), Matchers.eq(applicationIdentifier),
            AdditionalMatchers.or(Matchers.eq(expectedBeatTimestamp), Matchers.eq(getNextTimeStamp(expectedBeatTimestamp))));

    this.testSubject.createBeat(applicationIdentifier, beat);

    Assert.assertTrue(this.eventRecorder.wait(EventConstants.POST_BEAT, new BeatEvent(applicationIdentifier, beat.getIdentifier())));

    Mockito.verify(beatPublisherServiceSpy, Mockito.timeout(2_500).times(1)).requestPermissionForBeats(tenantIdentifier, applicationIdentifier);

    return beat;
  }
  //...
}
```","If the implementation is clean and generic, I would be in favor of it =||= @szpak For what version is that feature planned (Or has it been already released)? =||= ",0
1129,1127,Version not released to Maven Central,"2 days ago I requested a [build](https://github.com/mockito/mockito/commit/04961ae3cc8093916f563d7edc223224d757a4a1) with Maven Central sync (having notable changes merged). Looking into release configuration I used `[ci maven-central-release]` and it seems to be [enabled](https://travis-ci.org/mockito/mockito/jobs/242215132#L842) in Travis.

However, that release is not [available](https://maven-badges.herokuapp.com/maven-central/org.mockito/mockito-core) in Maven Central (2.8.9 is the newest as time of raising this issue instead of 2.8.44).

@szczepiq Is there anything else (with the current release mechanism) that is needed to do to build a ""notable version""?","I think we need to set a property on our project, looking at the line above in the Travis build you linked: 
```
project property 'maven-central-release' exists: false
``` =||= Looking! Thank you for reporting! =||= Great bug report guys! It was very easy to nail down the issue! =||= Please review / merge: https://github.com/mockito/mockito/pull/1129 =||= Worked perfectly - https://repo1.maven.org/maven2/org/mockito/mockito-core/2.8.47/ =||= ",0
1136,1135,[mock-maker-inline] Method calls on mock forwarded to real instance,"With mock-maker-inline enabled, given package-private abstract class SuperClass and a public subclass Subclass, a mocked instance of Subclass sometimes incorrectly calls into real methods on the super class. Here's a super simple example where I'm able to reproduce this:

```
/*pkg private*/ abstract class SuperClass {
    public abstract String getString();

    public void getStringLength() {
        getString().length();
    }
}

public class SubClass extends SuperClass {
    @Override
    public String getString() {
        return ""foo"";
    }
}
```

And then in a test:

```
public class MyTest {
    @Rule public final MockitoRule mMockitoRule = MockitoJUnit.rule();
    @Mock private SubClass mMockSubClass;

    @Test
    public void doTest() {
        mMockSubClass.getStringLength();
    }
}
```

This would fail with the following exception because the real getStringLength() method on SuperClass is being called:

```
java.lang.NullPointerException
	at com.example.SuperClass.getStringLength(SuperClass.java:7)
	at com.example.SubClass.getStringLength(SubClass.java:3)
	at com.example.MyTest.doTest(MyTest.java:15)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.mockito.internal.junit.JUnitRule$1.evaluateSafely(JUnitRule.java:63)
	at org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:43)
...
```

Interestingly enough, if SuperClass' visibility is changed from package private to public, then things work just fine. This is a pretty critical problem for us since we are trying to mock some library classes that we don't control and this is the class hierarchy the library has.

",nan,0
1145,1144,Unnecessary release was triggered,It seems that Shipkit was not able to avoid unnecessary release (see the [release notes](https://github.com/mockito/mockito/blob/release/2.x/doc/release-notes/official.md)). I will look into that. Our goal is not avoid shipping new version if binaries don't change.,This should be fixed now. =||= ,0
1146,86,"New lightweight, stub-only mocks for scenarios where high performance is needed","It is possible to create ""stub-only"" mocks that don't track invocations and hence might be useful for scenarios where low memory footprint / high speed is desired.

``` java
Foo lightweight = mock(Foo.class, withSettings().stubOnly());
```

For more information please see: https://code.google.com/p/mockito/issues/detail?id=84",nan,0
1162,1155,thenThrow(Class) should only throw checked exceptions that match the signature of the stubbed method,"Hi,

- mockito-core 2.8.47

```java
public class FooTest {

    @Test(expected = MockitoException.class)
    public void using_thenThrow_Throwable() {
        C mock = mock(C.class);
        // Set a checked exception that does not matche the method signature
        when(mock.doIt()).thenThrow(new Exception());
    }

    @Test(expected = MockitoException.class)
    public void using_thenThrow_Class() {
        C mock = mock(C.class);
        // Set a checked exception that does not matche the method signature
        when(mock.doIt()).thenThrow(Exception.class);
    }

    static class C {
        String doIt() {
            return null;
        }
    }

}
```

`using_thenThrow_Throwable()` passes, but `using_thenThrow_Class()` fails.

```
java.lang.AssertionError: Expected exception: org.mockito.exceptions.base.MockitoException
```

The Javadoc of `OngoingStubbing#thenThrow(Class)` says, *If the throwable class is a checked exception then it has to match one of the checked exceptions of the stubbed method signature*.
However, the result of `using_thenThrow_Class()` shows that it is not so.","I am going to fix this. 

ThrowsExceptionClass must simply implement ValidableAnswer...



 =||= Thank you for reporting. Indeed it is a bug. =||= ",0
1165,1152,[Kotlin] Mocking fails when one suspend function calls other suspend function,"When trying to mock class that has `suspend` function that calls other `suspend` function, it fails with exception: 
```
Exception in thread ""main"" org.mockito.exceptions.base.MockitoException:
Mockito cannot mock this class: class com.myapp.SuspendableClass.
Can not mock final classes with the following settings :
- explicit serialization (e.g. withSettings().serializable())
- extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class com.myapp.SuspendableClass]
at com.myapp.DupaKt$main$1.doResume(dupa.kt:25)
at kotlin.coroutines.experimental.jvm.internal.CoroutineImpl.resume(CoroutineImpl.kt:54)
at kotlinx.coroutines.experimental.DispatchTask.run(CoroutineDispatcher.kt:120)
at kotlinx.coroutines.experimental.EventLoopBase$QueuedRunnableTask.run(EventLoop.kt:189)
at kotlinx.coroutines.experimental.EventLoopBase.processNextEvent(EventLoop.kt:129)
at kotlinx.coroutines.experimental.BlockingCoroutine.joinBlocking(Builders.kt:225)
at kotlinx.coroutines.experimental.BuildersKt.runBlocking(Builders.kt:150)
at kotlinx.coroutines.experimental.BuildersKt.runBlocking$default(Builders.kt:142)
at com.myapp.DupaKt.main(dupa.kt:24)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class com.myapp.SuspendableClass]
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
... 9 more
Caused by: java.lang.IllegalStateException:
Byte Buddy could not instrument all classes within the mock's type hierarchy

This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
- Compiled by older versions of scalac
- Classes that are part of the Android distribution
at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:120)
at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:97)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:201)
at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:182)
at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)
at org.mockito.Mockito.mock(Mockito.java:1729)
at org.mockito.Mockito.mock(Mockito.java:1642)
... 9 more
Caused by: java.lang.IllegalStateException: public final java.lang.Object com.myapp.SuspendableClass.fetch(boolean,kotlin.coroutines.experimental.Continuation) is inconsistent at 1: java/lang/Object
at net.bytebuddy.asm.Advice$StackMapFrameHandler$Default.translateFrame(Advice.java:1200)
at net.bytebuddy.asm.Advice$StackMapFrameHandler$Default.translateFrame(Advice.java:1141)
at net.bytebuddy.asm.Advice$AdviceVisitor.visitFrame(Advice.java:6636)
at net.bytebuddy.jar.asm.ClassReader.a(Unknown Source)
at net.bytebuddy.jar.asm.ClassReader.b(Unknown Source)
at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)
at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)
at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2910)
at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1628)
at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:171)
at net.bytebuddy.dynamic.scaffold.inline.AbstractInliningDynamicTypeBuilder.make(AbstractInliningDynamicTypeBuilder.java:92)
at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2560)
at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:167)
at sun.instrument.TransformerManager.transform(TransformerManager.java:188)
at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)
at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)
at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:117)
... 23 more

Process finished with exit code 1
```

This is the simples example I could come up with to present this bug:
```
class SuspendableClass {
    suspend fun fetch(updateOnly: Boolean = true): Int {
//uncomment to fix mocking
//        runBlocking {
        fetchConcrete()
//        }
        return 2
    }

    suspend fun fetchConcrete() = 1
}

fun main(args: Array<String>) = runBlocking<Unit> {
    val mockClass = Mockito.mock(SuspendableClass::class.java)

    Mockito.`when`(mockClass.fetch()).thenReturn(10)

    MatcherAssert.assertThat(mockClass.fetch(), IsEqual(10))
    Mockito.verify(mockClass).fetch()
}
```

Important notes:
- mock-maker-inline is used to mock `final` classes
- mockito version: 2.8.47
- making class and all it's methods `open` allows mocking
- running inner `suspend` function inside `runBlocking` allows mocking","Paging @elizarov as the original author of suspending function support. =||= Thank you for descriptive report and submitting a sample! @elizarov, @raphw, any thoughts about this issue? =||= This has nothing to do with the fact that these functions are suspended but is probably a bug in the Kotlin compiler:

> Caused by: java.lang.IllegalStateException: public final java.lang.Object com.myapp.SuspendableClass.fetch(boolean,kotlin.coroutines.experimental.Continuation) is inconsistent at 1: java/lang/Object

Byte Buddy complains that the Kotlin compiler specified a stack map frame of type `Object` for the function where it expects a `boolean` (at index 1). This means that the Kotlin compiler overrides the original arguments of the method with new local variables what makes it impossible to - for example - extract them for calling the original method. It is simply not possible to instrument it for us.

I would report this to the Kotlin team. javac never issues such stack map frames and a lot of tool struggle with such ""special handling"" as you cannot really enhance a method or use agents on them as most people expect it. =||= @raphw Here is the byte code that is produced by Kotlin compiler version 1.1.4-eap-77 for the `fetch` function. On this bytecode ByteBuddy complains with:

```
java.lang.IllegalStateException: public final java.lang.Object SuspendableClass.fetch(boolean,kotlin.coroutines.experimental.Continuation) is inconsistent at 1: java/lang/Object
``` 

As you can see from the below bytecode, the boolean local variable 1 (`update`) is consistently manipulated as boolean type (`Z`). In fact, there are only two instructions ever touch it (at bci 104 and bci 129) to save/load into field of boolean (`Z`) type. Also, notice that all stack frames mention the proper type for local variable 1 (stack frame type `int`) and LocalVariableTable has its correct name and type. 

All in all, I don't see any miscomplication of this particular function by Kotlin compiler.

```
  public final java.lang.Object fetch(boolean, kotlin.coroutines.experimental.Continuation<? super java.lang.Integer>);
    descriptor: (ZLkotlin/coroutines/experimental/Continuation;)Ljava/lang/Object;
    flags: ACC_PUBLIC, ACC_FINAL
    Code:
      stack=4, locals=6, args_size=3
         0: aload_2
         1: instanceof    #10                 // class SuspendableClass$fetch$1
         4: ifeq          36
         7: aload_2
         8: checkcast     #10                 // class SuspendableClass$fetch$1
        11: astore_2
        12: aload_2
        13: invokevirtual #14                 // Method SuspendableClass$fetch$1.getLabel:()I
        16: ldc           #15                 // int -2147483648
        18: iand
        19: ifeq          36
        22: aload_2
        23: dup
        24: invokevirtual #14                 // Method SuspendableClass$fetch$1.getLabel:()I
        27: ldc           #15                 // int -2147483648
        29: isub
        30: invokevirtual #19                 // Method SuspendableClass$fetch$1.setLabel:(I)V
        33: goto          46
        36: new           #10                 // class SuspendableClass$fetch$1
        39: dup
        40: aload_0
        41: aload_2
        42: invokespecial #23                 // Method SuspendableClass$fetch$1.""<init>"":(LSuspendableClass;Lkotlin/coroutines/experimental/Continuation;)V
        45: astore_2
        46: aload_2
        47: getfield      #27                 // Field SuspendableClass$fetch$1.data:Ljava/lang/Object;
        50: astore_3
        51: aload_2
        52: getfield      #31                 // Field SuspendableClass$fetch$1.exception:Ljava/lang/Throwable;
        55: astore        4
        57: invokestatic  #37                 // Method kotlin/coroutines/experimental/intrinsics/IntrinsicsKt.getCOROUTINE_SUSPENDED:()Ljava/lang/Object;
        60: astore        5
        62: aload_2
        63: invokevirtual #14                 // Method SuspendableClass$fetch$1.getLabel:()I
        66: tableswitch   { // 0 to 1
                       0: 88
                       1: 125
                 default: 153
            }
        88: aload         4
        90: dup
        91: ifnull        95
        94: athrow
        95: pop
        96: aload_0
        97: aload_2
        98: aload_2
        99: aload_0
       100: putfield      #40                 // Field SuspendableClass$fetch$1.L$0:Ljava/lang/Object;
       103: aload_2
       104: iload_1
       105: putfield      #44                 // Field SuspendableClass$fetch$1.Z$0:Z
       108: aload_2
       109: iconst_1
       110: invokevirtual #19                 // Method SuspendableClass$fetch$1.setLabel:(I)V
       113: invokevirtual #48                 // Method fetchConcrete:(Lkotlin/coroutines/experimental/Continuation;)Ljava/lang/Object;
       116: dup
       117: aload         5
       119: if_acmpne     147
       122: aload         5
       124: areturn
       125: aload_2
       126: getfield      #44                 // Field SuspendableClass$fetch$1.Z$0:Z
       129: istore_1
       130: aload_2
       131: getfield      #40                 // Field SuspendableClass$fetch$1.L$0:Ljava/lang/Object;
       134: checkcast     #2                  // class SuspendableClass
       137: astore_0
       138: aload         4
       140: dup
       141: ifnull        145
       144: athrow
       145: pop
       146: aload_3
       147: pop
       148: iconst_2
       149: invokestatic  #54                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
       152: areturn
       153: new           #56                 // class java/lang/IllegalStateException
       156: dup
       157: ldc           #58                 // String call to 'resume' before 'invoke' with coroutine
       159: invokespecial #61                 // Method java/lang/IllegalStateException.""<init>"":(Ljava/lang/String;)V
       162: athrow
   LocalVariableTable:
        Start  Length  Slot  Name   Signature
           96      57     0  this   LSuspendableClass;
           96      57     1 updateOnly   Z
           96      57     2 continuation   Lkotlin/coroutines/experimental/Continuation;
      StackMapTable: number_of_entries = 8
        frame_type = 255 /* full_frame */
          offset_delta = 36
          locals = [ class SuspendableClass, int, class java/lang/Object ]
          stack = []
        frame_type = 255 /* full_frame */
          offset_delta = 9
          locals = [ class SuspendableClass, int, class SuspendableClass$fetch$1 ]
          stack = []
        frame_type = 254 /* append */
          offset_delta = 41
          locals = [ class java/lang/Object, class java/lang/Throwable, class java/lang/Object ]
        frame_type = 70 /* same_locals_1_stack_item */
          stack = [ class java/lang/Throwable ]
        frame_type = 29 /* same */
        frame_type = 83 /* same_locals_1_stack_item */
          stack = [ class java/lang/Throwable ]
        frame_type = 65 /* same_locals_1_stack_item */
          stack = [ class java/lang/Object ]
        frame_type = 5 /* same */
``` =||= A few other comments. It reproduces with a simpler code. You don't need a `boolean` parameter to reproduce the problem. It fails with a parameter-less function, too. I've put a reproducer code into this project: 
https://github.com/elizarov/CoroutinesMockitoPlayground
You can check it out to confirm the problem. The simpler reproducer code is here:
https://github.com/elizarov/CoroutinesMockitoPlayground/blob/master/src/main/kotlin/SuspendableClass.kt
The test case is here:
https://github.com/elizarov/CoroutinesMockitoPlayground/blob/master/src/test/kotlin/SuspendableClassTest.kt

Running this test case produces the following cause of the failure to mock this class which comes from ByteBuddy:
```
java.lang.IllegalStateException: public final java.lang.Object SuspendableClass.fetch(kotlin.coroutines.experimental.Continuation) is inconsistent at 0: java/lang/Object
	at net.bytebuddy.asm.Advice$StackMapFrameHandler$Default.translateFrame(Advice.java:1200)
	at net.bytebuddy.asm.Advice$StackMapFrameHandler$Default.translateFrame(Advice.java:1141)
	at net.bytebuddy.asm.Advice$AdviceVisitor.visitFrame(Advice.java:6636)
	at net.bytebuddy.jar.asm.ClassReader.a(Unknown Source)
	at net.bytebuddy.jar.asm.ClassReader.b(Unknown Source)
	at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)
	at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2910)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1628)
	at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:171)
	at net.bytebuddy.dynamic.scaffold.inline.AbstractInliningDynamicTypeBuilder.make(AbstractInliningDynamicTypeBuilder.java:92)
	at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2560)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:167)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)
	at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:117)
	... 45 more
```
 =||= @raphw I _think_ I understand what's going there. See, the first full-frame that is emitted by Kotlin compiler:

```
StackMapTable: number_of_entries = 8
        frame_type = 255 /* full_frame */
          offset_delta = 36
          locals = [ class SuspendableClass, int, class java/lang/Object ]
          stack = []
```

It declares that local variable 2 is of class `java.lang.Object`. However, the actual parameter to the method that will fall into this local variable is of class `kotlin.coroutines.experimental.Continuation`. It is a perfectly legal from the standpoint of JVM specification, since `Continuation` is a subclass of `Object`. However, ByteBuddy contains the following check at  https://github.com/raphw/byte-buddy/blob/master/byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java#L4008

```
if (!toFrame(methodDescription.getParameters().get(index).getType().asErasure()).equals(localVariable[index + offset])) { ...
```
 
that basically requires that frame type is equal to parameter type, which is a stronger requirement than mandated by JVM specification.

I've build a custom version of ByteBuddy with this check commented out (I'd really see any value in it, just a too strict/defensive constraint). With this custom version of ByteBuddy, mockito test for final Kotlin suspending function passes. =||= This is a pull request with a fix to byte-buddy: https://github.com/raphw/byte-buddy/pull/332 =||= This a pull request with the corresponding mockito test https://github.com/mockito/mockito/pull/1165 =||= I had time to look at it now and you are right about the problem. Your solution does however not work, the problem goes a bit deeper.

We need to be able to access the arguments after the original code was added. The inline mock maker basically takes a method:

```java
void foo(String a) {
  // code here
}
```
and transforms it to something similar to:
```java
void foo(String a) {
  // Mockito code start
  if (someCriteria) {
    // code here
   value = returnValue;
  }
  // Mockito code end
  return returnValue;
}
```
Where Mockito code is added at the end, we still need to be able to dereference the original arguments what is no longer possible about passing the full frame if the first argument was for example rendered to be an `Object`. Of course, this is allowed by the spec but it is highly uncommon. `javac` does not do it, `scalac` does not do it and most runtime tools (Javassist, Byte Buddy) cannot work with such a limitation. If the value was dereferenced, class verification would fail and it is a better outcome to raise a controlled error for most Java agent applications as this does not break the application.

As a workaround, I considered to make a copy of the original argument values in a dedicated index range but it is a bit costly and can break for methods that already have a large number of arguments. I would need to spend some time to implement this feature and I am not sure if I like the solution either.

Is there a particular reason that Kotlin even touches the argument indices? For best compatibility, the argument indices should never be reassigned. It is just to customary for Java agents and the like to work properly. =||= @raphw Let me add some additional observations here:

* If there is a goal to determine _original_ arguments at the end of the method, then they _must_ be stored to separate local variables at the beginning of the method. To see why, try instrumenting this java method and check what arguments ByteBuddy sees when the method exits:

```
void foo(String a) {
    a = ""Ha, ha!"";
}
```

* The `Continuation` parameter that is the cause of the problem here is not the actual parameter in Kotlin. It is not present in function's declaration nor on its call site. It is fully synthetic. Note, that in order to support Kotlin's suspending functions Mockito was also modified to ignore this parameter, so it is never going to be looked at by Mockito.

* This particular frame (at bci 36) has `Object` type for this continuation parameter as an artifact of ASM's frame computation logic. In fact, Kotlin always stores an object that is an instance of `Continuation` into this local variable, but, somehow, when computing the frames, the `Object` type is derived as LCA at this bytecode offset. We can fix this particular full frame (at bci 36), but ByteBuddy check will still fail at the next full frame (at bci 46), because it declares that this local variable now has a type of class `SuspendableClass$fetch$1`. It is an instance of `Continuation`, too. However, this more specific frame information is now critical to the subsequent logic of the compiled code, because we need to spill coroutine state into that object before suspending and it must be of this more specific type in order for the subsequent code to be verifiable. So we cannot really fix it in any satisfactory manner, but by saving a copy of the original parameter for ByteBuddy's pleasure, which is counter-intuitive, since if ByteBuddy want to use the original parameters, then it should have been taking care to save those parameters itself (see the Java example in the beginning).

Having said all of the above, compilation of suspending functions in Kotlin is under a constant enhancement now and will be changed several more times in the future releases. One of the future changes might or might not remove this particular effect that is causing a problem with ByteBuddy. I still believe, though, that ByteBuddy should save original parameters if it cares about them at the method's exit or should not be performing those strict type checks if it does not really care about preservation of parameters (which seems to be the case as of now).
 


 =||= This would not be a problem in our case as the above method could be transformed into something like:
```
void foo(String a) {
  if (notAMockCall) {
    a = ""Ha, ha!"";
  } else {
    // full stack frame with (this, String)
    // our logic
  }
}`
```
If our code is reached and we access the arguments, we can tell that the actual code was guarded by a conditional and they were not altered. The problem with stack map frames is that they are not conditional. If the guarded code contains a stack map frame that overrides the argument types, we can no longer access them even if the guarded code was never run.

I am aware of this being an assumption but despite Kotlin, no popular compiler for a JVM language overrides the indices that describe the method arguments. To overcome this limitation, Byte Buddy needs to be extended and I hope to do this sometime in the future but for the close future, I will not find time to do so.

As a general advice, I find it however advisable to stay as close to javac-compatible byte code as possible as many tools out there are based on such assumptions, simply because they work 99.99% of the time and a lot of Java agents rely on this. The original choice for this solution is also based on byte code efficiency as extending (large) methods too much costs significant runtime and can tip over the JIT compiler. There are always tradeoffs to consider.

An easy fix would be to enable frame computation by ASM for the agent but this adds significantly to the runtime and can cause failures when stack map frames result in class loading during the agent's application what can cause circularity errors. Does the Kotlin compiler use ASM's frame computation? =||= @raphw Notice, that the problematic frame in question is in the middle of the method body, so the transformation you've described above is not going to cause any problems. See:

```
void foo(String a) {
  if (notAMockCall) {
    // somewhere in the middle of the body we are redefining local variable with different type
    // it is Ok, because we are not going to go into an else branch with a modified frame
  } else {
    // original stack frame implied by parameters
    // our logic
  }
}
```

Kotlin compiler is not redefining the (implicit) stack frame that every method has at its beginning. So, the transformation that mockito is doing with ByteBuddy is 100% safe. Moreover, I did actually check that the resulting code (with a patched version of ByteBuddy without the check) not only passes verification, but works as expected.

All in all, I don't see any reason to have a strict check on stack frames declared somewhere in the middle of method's bytecode.

Answering your other question, Kotlin compiler does use ASM to compute stack frames (and it always returns `Object` type in `getCommonSuperClass` which explains the stack frame that we see).
 =||= Byte Buddy offers access to arguments according to the signature of

> LSuspendableClass;ILkotlin/coroutines/experimental/Continuation;

whereas the state after the available frames becomes

> LSuspendableClass;ILjava/lang/Object;

The way that Byte Buddy advice works is by inlining precompiled byte code into an existing method and for this purpose, it validates that the above signature of the initial arguments is still intact even if the code is never executed as the verifier might complain. This is a very cheap check to apply and works almost all of the time. As a matter of fact, this is the first time I meet this problem outside of working with ProGuard.

It is true that this works out without the security check in this case as Byte Buddy collects all arguments into an object array but if you did for example replace the third frame with a primitive value or delete it alltogether, this would no longer be possible if such a stack map frame was issued in non-reached code. The verifier does not apply any dynamic analysis here, it only checks if the stack map frame that is expected matches the current state from top to bottom of the method.

As I said, Byte Buddy could be smarter here by analyzing byte code on the fly but stack map frame analysis at runtime is a very tricky business as so many frameworks like Spring rely on optional types where ASM's stack map frame feature would fail, too. Therefore, Byte Buddy relies on the consistency of the stack map frames for the original arguments or aborts the transformation.

In the future, I hope to add another mode where this form of stack map frame pattern is supported or where Byte Buddy makes a copy of all references what would probably be the most correct. It is however not done by removing the check which is important to avoid verification errors which Byte Buddy implicitly promises to avoid.

This is on my list of things to do but nowhere in the near future as I currently prioritize Java 9 compatibility. I will keep you posted once I update this.

PS: why don't you issue the stack map frames yourself? You should have the necessary information in your compiler anyways and the inferred computation by ASM is rather expensive and sometimes error prone. =||= @raphw It is just easier to do it with ASM and it is fast for us due to the way `getCommonSuperClass ` is defined to always return `Object` (it is a Kotlin-specific optimization, you cannot do this trick on a general bytecode), so it converges quickly.
 
I see that ByteBuddy supports `Advice.OnMethodExit` with `Advice.Argument`. However, it means that it must save the original argument value on the method entry anyway, or it will no longer be equal the original argument value on method exit. 

Anyway, notice that Mockito does not use `Advice.Argument` with `Advice.OnMethodExit`. So, as a quick solution for Mockito, can we, please, change this check, so that it requires exact stack frames in the middle of the method only when `Advice.OnMethodExit` has at least one `Advice.Argument` or `Advice.AllArguments` parameter and avoid/remove this check otherwise? 
 =||= Well, this is somewhat expected as you often skip the original method execution in such circumstances, for example for a proxying solution where you would inoke another method instead, thus being able to rely on unchanged parameters.

I will look into providing a solution, maybe by not allowing dereferencing arguments in exit advice if they are inconsistent. I hope to find some time for this rather sooner than later, but I will not allow a hacky solution into Byte Buddy for a short term gain either.

Beyond, I just tried to reproduce this issue with Javassist's ""insertAfter"" and it yields similar issues; therefore, you might want to clean up your frame generation at some point anyways as a lot of Javaagents implicitly rely on this property, despite what the spec says. =||= I have a solution drafted out that does not increase the amout of byte codes. Hope to complete it by the end of September. =||= The bytecode generation strategy was adjusted in Kotlin 1.1.4-3 which fixes this issue. See [KT-19713](https://youtrack.jetbrains.com/issue/KT-19713) for details. I've updated PR #1165 with the test for this issue to Kotlin 1.1.4-3 and it passes. I suggest to close this issue and to merge PR #1165  into Mockito codebase to increase test coverage.  =||= Closing per above comment. Thanks for the effort and extra explanation @elizarov ! =||= I'm getting this again with 2.17.0. It works with 2.16.0 =||= @raphw @elizarov Hm, this might be a regression between Kotlin and Bytebuddy? =||= @TimvdLippe Sorry, I forgot to mentioned that I don't use Kotlin, but I'm using scala =||= Just to give update, I think it is related to bytebuddy 1.8.0. I force mockito 2.17.0 to use bytebuddy 1.7.9 and it works properly. =||= I will look into this, I did a complete rework of the stack map frame handling but I assume there is a regression somewhere. The idea is that this should no longer be a problem alltogether.

This rewrite was really complex and its impossible to catch everything. Could you do me a favor and try with Byte Buddy built from master? I already fixed a few bugs I was made aware of. I wonder if the one you noticed is related.

Thanks for your help! =||= How can I get Byte Buddy from master? =||= Check it out from GitHub and build it with Maven locally. =||= The master failed to build?
[![Build Status](https://travis-ci.org/raphw/byte-buddy.svg?branch=master)](https://travis-ci.org/raphw/byte-buddy) =||= @sinwe maybe is not your case, but I found this issue by searching in google... so this comment could be helpful for somebody else:

In my case, errors started after installing JAVA 10 in my laptop.
Switching back to JAVA 8 made mockito working as expected again.

(I'm using kotlin). =||= @raphw, I tried to use master and it is passing for me. =||= ",0
1172,353,@Mock-annotated fields are null for inner test classes (e.g. when using junit-hierarchicalcontextrunner),"Using the two current versions of Mockito (1.10.19 and 2.x-beta) and the JUnit-Mockito-Rule together with JUnit extensions like [junit-hierarchicalcontextrunner](https://github.com/bechte/junit-hierarchicalcontextrunner/) that use inner classes causes fails with `NullPointerException`s:

``` java
@RunWith(HierarchicalContextRunner.class)
public class HierarchicalMockitoTest {
    @Rule
    public MockitoRule mockitoRule = MockitoJUnit.rule();

    @Mock
    private Runnable runnable;

    public class Context {
        @Test
        public void test() throws Exception {
            runnable.run();
        }
    }
}
```

With older 1.x versions that didn't not contain the new JUnit rule API (e.g. where `MockitoJUnitRule` was not deprecated yet) the above test pass. I guess the reason is that the old rule's constructor had the current test instance passed in. In newer versions the rule uses the `target` from `org.junit.rules.MethodRule#apply()` which in this example is an instance of `HierarchicalMockitoTest.Context` so the `@Mock`-annotated fields of the outer classes are not seen and the mocks won't get instantiated.","@UrsMetz This is not yet supported, feel free to craft a pull request for that ;)
 =||= @bric3 I will look into that and eventually craft a pull request.

Maybe it was not clear from my original post: This is a regression because when updating to the latest 1.x release tests like the one above will fail: when though the constructor of `MockitoJUnitRule` gets the target (e.h. `this`) passed it doesn't use it in the newest version and as a consequence the test fails with a `NullPointerExeception`. Earlier version used the parameter so that the mocks got initiated and the test was green. So even when the old now deprecated API is used tests start to fail after updating Mockito. So maybe a back port to the 1.x branch should be considered too?
 =||= Oh I didn't get that indeed. Actually the this was removed because JUnit passes the target when the rule is applied see [MockitoJunitRule](https://github.com/bric3/mockito/blob/master/src/main/java/org/mockito/junit/MockitoJUnitRule.java#L39-L39). With these _exotic_ JUnit runners I'm not sure how to solve this in a proper way, maybe adding a hierarchical mockito rule.
 =||= Or maybe with such exotic runner, the PR could be on their project ? https://github.com/bechte/junit-hierarchicalcontextrunner/
 =||= I was also thinking whether it is not a issue with the junit-hierarchicalcontextrunner. I will investigate this and either raise an issue over there (and reference this issue) or take a stab at a fix and pull request for Mockito. I'm not one hundred percent sure whether it worked in all corner case with the old version where the parameter of `MockitoJUnitRule` was used instead of the parameter `target` of the `apply` method of the rule. I will also look into that.
 =||= @bric3 After playing a bit around with the example above and different versions of Mockito (pre 1.10.17 where the internal implementation of the JUnit rule changed and >= 1.10.17) I figured out that only some corner cases worked in the old version (exactly those we are using right now in my team at work); now different case work and the old cases stopped working. As you said it seems to be an issue with junit-hierarchicalcontextrunner. I raised the issue bechte/junit-hierarchicalcontextrunner#26 over there.
 =||= @UrsMetz Cool if you're ok with that let's close the issue there ?
 =||= Sure, I'm closing it.
 =||= Cool thanks :)
 =||= I think there is still a bug with JUnitRule.  I built the master branch of the project which includes @UrsMetz's pull request in that project and ran the sample test class at the top, but I received the following exception prior to reaching the code that causes the NullPointerException.  The root cause is JUnitRule attempting to add a UniversalTestListener a second time to a ThreadSafeMockingProcess (Mockito currently does not readily provide the full stack trace at this time).

```
org.mockito.exceptions.misusing.UnfinishedMockingSessionException: 
Unfinished mocking session detected.
Previous MockitoSession was not concluded with 'finishMocking()'.
For examples of correct usage see javadoc for MockitoSession class.
	at org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:42)
	at org.mockito.internal.junit.JUnitRule$1.evaluateSafely(JUnitRule.java:52)
	at org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:43)
	at de.bechte.junit.runners.context.statements.StatementExecutor.execute(StatementExecutor.java:28)
	at de.bechte.junit.runners.context.processing.MethodExecutor.run(MethodExecutor.java:83)
	at de.bechte.junit.runners.context.processing.MethodExecutor.run(MethodExecutor.java:57)
	at de.bechte.junit.runners.context.statements.RunChildren.evaluate(RunChildren.java:38)
	at de.bechte.junit.runners.context.statements.RunAll.evaluate(RunAll.java:27)
	at de.bechte.junit.runners.context.statements.StatementExecutor.execute(StatementExecutor.java:28)
	at de.bechte.junit.runners.context.HierarchicalContextRunner.run(HierarchicalContextRunner.java:134)
	at de.bechte.junit.runners.context.processing.ContextExecutor.run(ContextExecutor.java:26)
	at de.bechte.junit.runners.context.processing.ContextExecutor.run(ContextExecutor.java:15)
	at de.bechte.junit.runners.context.statements.RunChildren.evaluate(RunChildren.java:38)
	at de.bechte.junit.runners.context.statements.RunAll.evaluate(RunAll.java:27)
	at de.bechte.junit.runners.context.statements.StatementExecutor.execute(StatementExecutor.java:28)
	at de.bechte.junit.runners.context.HierarchicalContextRunner.run(HierarchicalContextRunner.java:134)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
``` =||= The HierarchicalMockitoTest fails even with @UrsMetz's fix for [bechte/junit-hierarchicalcontextrunner#26](https://github.com/bechte/junit-hierarchicalcontextrunner/issues/26).  Since a new version of the dependency has not been released, the test failure can be demonstrated by following the steps below (after a new version of the dependency has been released, building my feature branch will be sufficient):

1. Build and install (requires Maven) https://github.com/bechte/junit-hierarchicalcontextrunner/tree/master.  This pulls in @UrsMetz's fix with a version 4.12.2-SNAPSHOT.
1. Clone https://github.com/mouyang/mockito/tree/mouyang-gh-353.  In build.gradle, change [this line](https://github.com/mockito/mockito/compare/release/2.x...mouyang:mouyang-gh-353?expand=1#diff-c197962302397baf3a4cc36463dce5eaR81) to `testCompile 'de.bechte.junit:junit-hierarchicalcontextrunner:4.12.2-SNAPSHOT'` to match the artifact produced previously.
1. `./gradlew build` as-is results in a pass.
1. `./gradlew build` with my change to JUnitRule reverted results in HierarchicalJUnitRuleTest.java failing due to the UnfinishedMockingSessionException I cited previously.

This issue would have happened with any Runner that enabled hierarchical test classes ([such as the NitorCreations NestedRunner](https://github.com/NitorCreations/CoreComponents/tree/master/junit-runners)).  JUnitRule overwrites the MockitoSession instantiated in the outer call in the nested case; this seems wrong and it seems reasonable to augment the existing session with the mocks from the inner class.

I haven't submitted a PR at this time, eventhough the test suite passed, because I have no idea if my changes are oblivious to other exception cases.  But I would like to re-open a discussion on this ticket since I still believe this is a legitimate issue.  Thanks. =||= @mouyang I had a quick look at it (I don't know why but I had to tweak `gradle.build` in your repo a bit further so that the `junit-hierarchicalcontextrunner` SNAPSHOT version in my local Maven repository was found as a `testCompile` dependency: I had to add a top level `repositories` section with `mavenLocal()` in it).

I can reproduce your error when using some 2.x versions of Mockito (I tried 2.13.0, 2.1.0-beta.125, and the master).
With a Mockito version 1.x and 2.0.0-beta.118 I cannot reproduce the failure.
So at the time when I was working on this it worked(tm) ;-), but with the current 2.x version it is broken. So I think you're right that there is an issue (please note that I'm not a maintainer of Mockito. I just saw that there was some activity on an old issue I once created). =||= From your clarifications it makes more sense to keep this ticket closed, and for me to create a new ticket for my issue as it is clearly different. Thanks @UrsMetz! =||= ",0
1172,354,Subsequent Mocking fails if I give an exception,"```
when(myClient.getResult(eq(0))).thenThrow(InvalidIdException.class);
when(myClient.getResult(not(eq(0)))).thenReturn(new Address());
```

Executing line 2 causes InvalidIdException to be thrown. Writing a try catch doesn't look ideal to me. Any suggestions ?

A workaround Im using for now :

```
when(myClient.getResult(not(eq(0)))).thenReturn(new Address());
when(myClient.getResult(eq(0))).thenThrow(InvalidIdException.class);

```","I found the issue anyway. Matchers.any and all the others return a default value of 0. This caused the problem for me. Apart from changing that to INT_MAX or maybe -1, I dont see much we can do here lol

Would be interesting if someone did have a solution for this. Feel free to close otherwise. Thanks for the awesome library :)
 =||= ",0
1181,1179,Mockito 2.9.0 is significantly slower,"We just tried to upgrade to Mockito 2.9.0 (from 2.8.47) and found that our individual tests went from about 1 second to run per test to about 24 seconds to run per test.

We tried to find which release version causes the tests to run slow and found that version 2.8.50 is the first version that causes the slowdown (versions 2.8.48 and 2.8.49 run fine)

Our environment:
- Java 1.8.0_144
- Android Gradle Project (using Gradle 4.1 and Android Studio 3.0 Beta3)
- Kotlin 1.1.4-2
- JUnit 4.12

Other test dependencies
- Dagger 2.11
- threetenbp:1.3.6
- org.xerial:sqlite-jdbc:3.20.0","@raphw Seems to be #1136 is the culprit. Any insight or immediate thoughts about it? =||= @jeffdcamp Thanks for the description. Are you using the Android mock maker or the final mock maker? Could you attach a profiler when running the tests to see what takes so much time?

Just to be sure: you verified that 2.8.50 causes the same performance problems? =||= If you are using the final mock maker, I see how the resolution could be problematic using the method graph compiler. This is quite expensive and I did not think much about it when implementing the correct solution. We should definetly cache the result. =||= @jeffdcamp Could you build Mockito from the branch `performance-fix` and try it out? I wonder if that fixes the regression. Thanks =||= @raphw  We are not using ""Android mock maker or the final mock maker"".   Yes... 2.8.50 is the version that causes the slowdowns (we tried both  2.8.48 and 2.8.49, and those 2 versions work fine).

I'll try to perform a build of Mockito ""performance-fix"" branch =||= @raphw I just built the ""performance-fix"" branch and changed the dependency on our project to ""2.9.1"" and that did not fix the slow down.

The following is using version 2.9.1 (Note the long run times):

![image](https://user-images.githubusercontent.com/1479095/29842041-d956de70-8cc4-11e7-9329-a7d1e88f9abc.png)

The following is using version 2.8.47:

![image](https://user-images.githubusercontent.com/1479095/29842193-58a65034-8cc5-11e7-8e13-9e023502340b.png)
 =||= And you really get the same behavior in 2.8.50? This seems unlikely if you are not using the inline mock maker. (Are you sure you have no mock maker configured?) The only change from 2.8.49 to 2.8.50 is in the class `MockMethodAdvice` which should not even get loaded unless you are using the mock maker in which case the versions should be identical.

Maybe the performance regression happens with 2.8.49, too? This would make more sense as it includes a major version update of Byte Buddy.

Could you run the tests while profiling with something like JProfiler (there is a free trial) to see where the tests spend their time compared to before the update? =||= @raphw I just went to the git log and checked-out and built revision ""Fixed flaky Bintray badge Szczepan Faber* 6/22/17 4:16 PM (1a60a8496d4b704cac115608ca67840c7d8a6865)"" and tests runs fast.... 

I then checked-out revision and built revision ""Fixes #1135: Properly resolve visibility bridges. (#1136) Rafael Winterhalter* 6/24/17 2:29 AM (fa66960eeb74473822fe9081246f360964da6023)"" and the tests run slow...

I'll see what I can do to profile.... =||= Thanks for investigating! 

This is just super strange, I have no idea how this could affect the subclass mock maker.

When profiling with JProfiler, run a CPU sample for the `org.mockito` and `net.bytebuddy` namespaces. =||= @raphw Is it possible that when tests are run/executed in Android Studio / IntelliJ it might cause mock maker fire off? (sorry I don't know much about ""mock maker"") =||= That should not happen, for Kotlin, it might however make sense as most types are final by default.

You can set a break point in the `MockUtil::createMock` method and see what instance of `MockMaker` you have (Inline or Subclass) to see what plugin is loaded. =||= It appears to be ""InlineByteBuddyMockMaker"" =||= In this case, you are using the inline mock maker to support mocking of final types. I am afraid that the lookup of visibility bridges still takes too long. I will try to further improve the runtime. =||= Awesome!  Let me know if there is anything else you would like me to test/try/identify =||= I tried caching the entire graph. Could you try the performance-fix branch once more? =||= It's fixed!

The latest code on the ""performance-fix"" branch is back to expected speeds!  Good work!

 =||= Its still preliminary as it leaks memory, unfortunately. I have to work a bit more with it before merging.

Good to know that the approach is right, though! Thanks for checking =||= Let me know if you would like me to rerun my tests with updated code. =||= Thanks @jeffdcamp for the report and awesome @raphw to find the fix so quickly :heart:  =||= Does the inline work for you in 2.9.0? Several tests here fail when mocking kotlin classes, but work in 2.8.47 =||= @PaulWoitaschek, take a look at the #1183 =||= ",0
1184,1182,Travis CI ERROR: JAVA_HOME is set to an invalid directory,"Travis CI builds started failing with ""ERROR: JAVA_HOME is set to an invalid directory: /usr/lib/jvm/java-7-oracle"". [Example failure](https://travis-ci.org/mockito/mockito/jobs/270842998).

```
$ ./gradlew build idea -s -PcheckJava6Compatibility && ./gradlew ciPerformRelease
ERROR: JAVA_HOME is set to an invalid directory: /usr/lib/jvm/java-7-oracle
Please set the JAVA_HOME variable in your environment to match the
location of your Java installation.
```

It looks like there was some incompatible change rolled out in Travis CI.",This was fixed in #1184 =||= ,0
1186,1180,Stubbing superclass' method using Mockito inline propagate to the real method call,"Hi my java env is 
```
java version ""1.8.0_74""
Java(TM) SE Runtime Environment (build 1.8.0_74-b02)
Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)
```
OS Version
`MacOS Sierra 10.12.6`

Mockito version: 
`mockito-inline:2.9.0`

For this simple snippet:
```
    public class StringList extends ArrayList<String>{

    }
```
then stubbing the size() method
```
StringList stringList = mock(StringList.class);
doReturn(10).when(stringList).size();

```
stringList.size() will always return 0, and size() is acually called in ArrayList instread of the stub
the above code works perfectly with mockito-core, for a workaround, StringList can be written in 
```
    public class StringList extends ArrayList<String>{
        @Override
        public int size(){
            return 0;
        }
    }
```
then size() can be stubbed.
I only need mockito inline to mock a single final class in one test case, but mockito-inline took over my entire module's unit tesst, I'm wondering if there's a way to choose mockito-core or inline for each test?

and I'm not sure if this is related, if stub in this way
` when(stringList.size()).thenReturn(11);`
Mockito reports

> org.mockito.exceptions.misusing.MissingMethodInvocationException: 
> when() requires an argument which has to be 'a method call on a mock'.
> For example:
>     when(mock.getArticles()).thenReturn(articles);
> 
> Also, this error might show up because:
> 1. you stub either of: final/private/equals()/hashCode() methods.
>    Those methods *cannot* be stubbed/verified.
>    Mocking methods declared on non-public parent classes is not supported.
> 2. inside when() you don't call method on mock but on some other object.

","If I am not mistaken we explicitly disallow mocking of such Data classes.
If you need to stub a list, then just create a list with the value you
expect. For more information see
https://github.com/mockito/mockito/wiki/How-to-write-good-tests#dont-mock-value-objects

On Wed, 30 Aug 2017, 07:49 Hu Yao <notifications@github.com> wrote:

> Hi my java env is
>
> java version ""1.8.0_74""
> Java(TM) SE Runtime Environment (build 1.8.0_74-b02)
> Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)
>
> OS Version
> MacOS Sierra 10.12.6
>
> Mockito version:
> mockito-inline:2.9.0
>
> For this simple snippet:
>
>     public class StringList extends ArrayList<String>{
>
>     }
>
> then stubbing the size() method
>
> StringList stringList = mock(StringList.class);
> doReturn(10).when(stringList).size();
>
>
> stringList.size() will always return 0, and size() is acually called in
> ArrayList instread of the stub
> the above code works perfectly with mockito-core, for a workaround,
> StringList can be written in
>
>     public class StringList extends ArrayList<String>{
>         @Override
>         public int size(){
>             return 0;
>         }
>     }
>
> then size() can be stubbed.
> I only need mockito inline to mock a single final class in one test case,
> but mockito-inline took over my entire module's unit tesst, I'm wondering
> if there's a way to choose mockito-core or inline for each test?
>
> and I'm not sure if this is related, if stub in this way
> when(stringList.size()).thenReturn(11);
> Mockito reports
>
> org.mockito.exceptions.misusing.MissingMethodInvocationException:
> when() requires an argument which has to be 'a method call on a mock'.
> For example:
> when(mock.getArticles()).thenReturn(articles);
>
> Also, this error might show up because:
>
>    1. you stub either of: final/private/equals()/hashCode() methods.
>    Those methods *cannot* be stubbed/verified.
>    Mocking methods declared on non-public parent classes is not supported.
>    2. inside when() you don't call method on mock but on some other
>    object.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1180>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb0hKkSOylN62U_1YZ8p5KRQWf8-vks5sdXZagaJpZM4PHgWw>
> .
>
 =||= @TimvdLippe sorry I didn't intend to mock List, I happened to use the List as a simple example, this case happens when mocking superclass' method which is not overridden in child class. =||= This seems to be a regression in version 2.9.0 with `mock-maker-inline`. In our code base we hit the issue with some code that mocks Elasticsearch 2.3.5's [`DeleteRequestBuilder`](https://github.com/elastic/elasticsearch/blob/v2.3.5/core/src/main/java/org/elasticsearch/action/delete/DeleteRequestBuilder.java). Simplified example:
```java
DeleteRequestBuilder b = mock(DeleteRequestBuilder.class);
assertNull(b.get());
```
This passes with Mockito 2.8.47, but causes an NPE with Mockito 2.9.0, because the ""real"" method is invoked:
```
java.lang.NullPointerException
	at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:86)
	at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:56)
	at org.elasticsearch.action.ActionRequestBuilder.get(ActionRequestBuilder.java:64)
```

CC @raphw since the issue only happens when `mock-maker-inline` is enabled.  =||= I found the error which lies in the new bridge method sensitive override detection mechanism. I added a test case and hope everything works again in the new version. =||= I fixed this in #1179, please reopen the issue if it is not resolved. =||= Hi @raphw, I just built and installed 1c61f1a91a7d5d8367b3dbddb6270afdd96c8f6a using `./gradlew publishToMavenLocal`. The above issue still reproduces, unfortunately. =||= Darn, I reproduced the issue as a test case but I assume it was insufficient to capture the full problem.

Thanks for double-checking, I will hav another look.

PS: You did build the release 2.x branch? Alternatively, the build should be released by now. =||= Ah, I just double-checked and it seems like the actual fix got lost in git rebase. I will fix this tonight! =||= New try! =||= Thanks! Just built `v2.9.2` locally and I can confirm the issue is fixed. :white_check_mark: 

Dare I ask: since this release resolves a regression, do you plan to publish it on Maven Central? =||= Should be published automatically. @szczepiq? =||= Nah, by default they only go to Bintray. (I can configure our Nexus to proxy to Bintray, but I prefer to keep the number of non-Maven Central hosted dependencies as small as possible. Also, by publishing on Maven Central a larger audience will find the fix using the `versions-maven-plugin`.) =||= >Should be published automatically. @szczepiq?

We currently don't publish automatically to Maven Central based on the feedback from community that there are too many versions of Mockito around :) We might get back to publishing every version as we did before.

I plan to ship 2.10 soon for https://github.com/mockito/mockito/pull/1121 so it will land in Maven Central! =||= ",0
1192,1191,Ensure spring-boot can use Mockito public API,"### Problem

Mockito framework integrators need robust public APIs from us. This way, they ship great Mockito integrations to their customers. We want to avoid the situation where framework integrators have to use Mockito internal APIs. This leads to overhead, relying on stale versions of Mockito, class conflicts in runtime.

spring-boot currently uses some internal API from Mockito. See https://github.com/spring-projects/spring-boot/issues/10352 for the problem statement, solution options and chosen design. 

### Solution

As discussed in spring-boot ticket, here's the API we would like to prototype:

- New ""VerificationStartedListener""
- The instance of listener can be passed on mock creation
- Listener is notified when 'Mockito.verify' is invoked but before the verification is triggered
- It is possible to replace the mock object that is being verified (key feature needed by spring-boot)

### Example usage

```Java
mock(Foo.class, withSettings().verificationStartedListeners(new VerificationStartedListener() {
  public void onVerifyStarted(VerificationStartedEvent event) {
    event.getMock();
    event.setMock(arbitrayObject);
  }
}
```","I put together a prototype in ""mockito-spring-boot"" branch. Opened PR #1192 for visibility. How to use it?

- clone mockito and check out ""mockito-spring-boot"" branch
- ./gradlew publishToMavenLocal
- grab newly published version of mockito from maven local and try it out!
- I don't have Javadocs yet. This test class documents the new API (hopefully :) -> https://github.com/mockito/mockito/pull/1192/commits/1d2cd207621c13251ef89b4d7e6ca9178f8115e8?diff=unified#diff-c7b40da00e36958d90e247ac5f759871R23

Suggested next steps:

- @wilkinsona, let me know if this is enough for you to try it out!
- we can use the PR that I have opened for review comments regarding the API =||= @szczepiq This looks great. I've built the `mockito-spring-boot` branch and prototyped the updates required for Spring Boot to use it: https://github.com/wilkinsona/spring-boot/tree/gh-10352. All our tests pass and, as you can hopefully see, Boot's code is now significantly simpler. Thanks very much. =||= Fantastic! I will polish the code / documentation and get the release out soon. Thank you for testing this out and suppling sample project! =||= @wilkinsona, can you try out one more time for us please?

I've cleaned up the implementation and the PR in Mockito is ready to go. I want to make sure that we ship code that works for Spring Boot. I have added some extra validation for setMock() method. Other than that I think that the API has not changed since I provided the experimental. The code is in the same branch.

Thank you in advance! :) =||= @szczepiq Thanks for the opportunity to double-check things. I've built the current head of the `mockito-spring-boot` branch and updated [my prototype](https://github.com/wilkinsona/spring-boot/tree/gh-10352) to use the resulting 2.11.0 binaries. The only change that was necessary was to update the version number so things look good from my perspective. =||= We released new version today: 2.11.0. It includes the new API that Spring Boot can use. =||= @wilkinsona - thank you for help and nice collaboration! =||= Closing per https://github.com/spring-projects/spring-boot/commit/027c5a0e35b81259191cae8236a1939e5e4827de :tada:  =||= ",0
1195,1189,JDK9: set a stable module name with `Automatic-Module-Name` entry in MANIFEST,"JDK9 is out and introduces a module system.

Mockito does not currently use modules. When we use it in a JDK9 modular application, Java turns the JAR into a so-called automatic module, whose name is derived from the JAR archive name (*mockito*, in this case). However, the default name does not follow the recommended module naming conventions (reverse-dns style, module name derived from the main exported package).

It is possible to specify a stable automatic module name through a `Automatic-Module-Name` manifest entry, while still targeting JDK8:

```
Automatic-Module-Name: org.mockito
```

Selecting a stable module name is very important, because Java does not allow two modules to own the same package, and you may end up with a module hell. The naming issues are well-explained on Stephen Colebourne's blog:

 * http://blog.joda.org/2017/04/java-se-9-jpms-module-naming.html
 * http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html <- the explanation of module hell problem

And the comment of Mike Reinhold, chief Java architect:

> Strongly recommend that all modules be named according to the reverse Internet domain-name convention. A module's name should correspond to the name of its principal exported API package, which should also follow that convention. If a module does not have such a package, or if for legacy reasons it must have a name that does not correspond to one of its exported packages, then its name should at least start with the reversed form of an Internet domain with which the author is associated.","If we can make this work on JDK6-8, I am all for it. If you can, please submit a PR that we can review :) =||= This change is compatible with JDK6-8, because you only add an entry to `MANIFEST.mf` file. Older Java versions simply ignore it, and JDK9 uses it as a stable automatic module name (instead of generating it from JAR archive name).

If you drop the support for older JDKs somewhere in the future, you can create a true module with the same name and the change will be invisible to JDK9 modular applications:

```java
module org.mockito {
   requires ...;
}
```

PR -> I'd love to, but I'm tracking the Jigsaw support in more projects and I'm afraid I don't have enough time to update them all. So I will see. =||= ",0
1202,1198,"""Could not initialize inline Byte Buddy mock maker"" with Gradle 4.x","I tried to add Java 9 build for the Mockito 2.x branch which in turn requires Gradle upgrade to 4.x. Unfortunately with Gradle 4.x (tested with 4.0.1 and 4.2.1) 38 inline mock maker related tests are broken (without `MOCK_MAKER` env variable defined).

For example:
```
org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMakerTest > should_create_mock_from_interface FAILED
    org.mockito.exceptions.base.MockitoInitializationException: 
    Could not initialize inline Byte Buddy mock maker. (This mock maker is not supported on Android.)

    Java               : 1.8
    JVM vendor name    : Oracle Corporation
    JVM vendor version : 25.144-b01
    JVM name           : OpenJDK 64-Bit Server VM
    JVM version        : 1.8.0_144-b01
    JVM info           : mixed mode
    OS name            : Linux
    OS version         : xxx
        at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.<init>(InlineByteBuddyMockMaker.java:171)
        at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMakerTest.<init>(InlineByteBuddyMockMakerTest.java:35)

        Caused by:
        java.lang.IllegalStateException: 
        The MockMethodDispatcher class file is not locatable: org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.raw

        The class loader responsible for looking up the resource: sun.misc.Launcher$AppClassLoader@73d16e93
```

Travis build reproducing that issue with Oracle JDK (just Gradle upgrade in the `brokenWithGradle4` branch):
https://travis-ci.org/mockito/mockito/jobs/283893407#L793

I don't know why the Gradle upgrade can result in that behavior. Especially that ""The MockMethodDispatcher class file is not locatable: org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.raw"" sounds strange.

@raphw Under what circumstances that BB error can occur (even abstracting it from Gradle)?","Gradle is supposed to rename the `org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.class` file to `org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.raw` during its build. This is necessary to prohibit the class from being loaded by any class loader as we explicily inject it into the bootstrap class loader using the instrumentation API. 

It seems like this does no longer work as the runtime cannot locate this name. I guess it was not renamed and is still available under `.class`. =||= It looks like this one is failing due to this (https://docs.gradle.org/4.0/release-notes.html#location-of-classes-in-the-build-directory) change in Gradle 4.0 and the fact that `inline-mock.gradle` is using the old hardcoded path. =||= Yup, that was a problem @raphw. Thanks @epeee for an implementation hint. =||= @szpak , @epeee , @raphw : Can you please help me understand what i should do to make it work in my android project? It has mockito-core and mockito-android v. 2.21.0 and also powermockito2 api and the project has both Java and kotlin classes. I would like to test the kotlin classes.  =||= @hearbeathorror This issue has been closed almost a year ago and it is rather loosely related to your problem. I propose you to ask a question using [Stack Overflow](https://stackoverflow.com/questions/tagged/mockito) or the [mailing list](https://groups.google.com/forum/#!forum/mockito). However, you mix many various elements which can cause some issues. =||= ",0
1203,1191,Ensure spring-boot can use Mockito public API,"### Problem

Mockito framework integrators need robust public APIs from us. This way, they ship great Mockito integrations to their customers. We want to avoid the situation where framework integrators have to use Mockito internal APIs. This leads to overhead, relying on stale versions of Mockito, class conflicts in runtime.

spring-boot currently uses some internal API from Mockito. See https://github.com/spring-projects/spring-boot/issues/10352 for the problem statement, solution options and chosen design. 

### Solution

As discussed in spring-boot ticket, here's the API we would like to prototype:

- New ""VerificationStartedListener""
- The instance of listener can be passed on mock creation
- Listener is notified when 'Mockito.verify' is invoked but before the verification is triggered
- It is possible to replace the mock object that is being verified (key feature needed by spring-boot)

### Example usage

```Java
mock(Foo.class, withSettings().verificationStartedListeners(new VerificationStartedListener() {
  public void onVerifyStarted(VerificationStartedEvent event) {
    event.getMock();
    event.setMock(arbitrayObject);
  }
}
```","I put together a prototype in ""mockito-spring-boot"" branch. Opened PR #1192 for visibility. How to use it?

- clone mockito and check out ""mockito-spring-boot"" branch
- ./gradlew publishToMavenLocal
- grab newly published version of mockito from maven local and try it out!
- I don't have Javadocs yet. This test class documents the new API (hopefully :) -> https://github.com/mockito/mockito/pull/1192/commits/1d2cd207621c13251ef89b4d7e6ca9178f8115e8?diff=unified#diff-c7b40da00e36958d90e247ac5f759871R23

Suggested next steps:

- @wilkinsona, let me know if this is enough for you to try it out!
- we can use the PR that I have opened for review comments regarding the API =||= @szczepiq This looks great. I've built the `mockito-spring-boot` branch and prototyped the updates required for Spring Boot to use it: https://github.com/wilkinsona/spring-boot/tree/gh-10352. All our tests pass and, as you can hopefully see, Boot's code is now significantly simpler. Thanks very much. =||= Fantastic! I will polish the code / documentation and get the release out soon. Thank you for testing this out and suppling sample project! =||= @wilkinsona, can you try out one more time for us please?

I've cleaned up the implementation and the PR in Mockito is ready to go. I want to make sure that we ship code that works for Spring Boot. I have added some extra validation for setMock() method. Other than that I think that the API has not changed since I provided the experimental. The code is in the same branch.

Thank you in advance! :) =||= @szczepiq Thanks for the opportunity to double-check things. I've built the current head of the `mockito-spring-boot` branch and updated [my prototype](https://github.com/wilkinsona/spring-boot/tree/gh-10352) to use the resulting 2.11.0 binaries. The only change that was necessary was to update the version number so things look good from my perspective. =||= We released new version today: 2.11.0. It includes the new API that Spring Boot can use. =||= @wilkinsona - thank you for help and nice collaboration! =||= Closing per https://github.com/spring-projects/spring-boot/commit/027c5a0e35b81259191cae8236a1939e5e4827de :tada:  =||= ",0
1214,1211,improve @deprecated JavaDoc of MockitoDebugger,"The `@deprecated` JavaDoc of :
 * method: `Mockito.debug()` 
 * class: `MockitoDebugger` 
 * method `MockitoDebugger.printInvocations()`

... should point to `Mockito.mockingDetails(..).printInvocations()`. Currently its too hard to find the rigth entry point for the replacement.",nan,0
1216,1206,Mockito should not copy annotations in all cases,"When mocking an interface, Mockito 2.10.0 copies the annotations on the interface to the generated class.
I believe, Mockito  2.10.0  should just implement the class, as if the one would do new Interface(){...}
In fact, migrating to mockito 2.10 broke the tests of my working production code.
However, when mocking a class, the current behavior could be the expected behavior.

I have provided a very simple test case here: https://github.com/ctolkmit/mockito-tests, the Test-Case ""interfaceMock()"" fails. 

At least, it should be optional (via MockSettings?) to control this behavior.","> I believe, Mockito 2.10.0 should just implement the class, as if the one would do new Interface(){...}

I agree. Java does it that way. When an interface is implemented by a class the annotations are not present, no matter if the annotation is marked with `@Inherit` or not.

>However, when mocking a class, the current behavior could be the expected behavior.

The class object of a mocked class should look close as possible as one of the mocked type. Therefore I would assume that annotations are copied. 

Currently Mocktio uses as default the `SubclassByteBuddyMockMaker` which well subclasses the type to mock. You can try to use the Inline-Mock-Maker (by adding the dependency `org.mockito:mockito-inline:2.10.0` ). I don't know how it acually works, but it may behave differently since it don't subclass the type to mock as far as i know.

 =||= adding `org.mockito:mockito-inline:2.10.0` to my project did not change any test results =||= Okay, thanks for checking it out. 

Possibly @raphw has a good explanation for the current behaviour. =||= We introduced this as a feature since the mock class should be a representation of the mocked type. Many times, this is rather an advantage than a disadvantage. You are however right that it should be something that can be controlled in the mock options. We will look into it.

Already today, you can trick Mockito into not copying the annotations by creating a mock of type object and adding the interface as ""additional interface"". =||= @raphw - great trick, I think this will work in my environment for the moment. =||= @raphw 

> We introduced this as a feature since the mock class should be a representation of the mocked type. 

Out of interest: Shouldn't annotations never by copied from interfaces? I mean if an interface is implemented, the compiler don't copy any annotation to the class. So it is a bit surprising that mockito does it.  I would expect this only for mocked classes.  

> Already today, you can trick Mockito into not copying the annotations by creating a mock of type object and adding the interface as ""additional interface"".

This should IMHO the default behaviour when an interface is mocked. Maybe mockito should take this into account. Actually I don't see a case where this would be an disadvantage. =||= @ChristianSchwarz I would completely agree :) =||= This has been addressed in #1216 =||= ",0
1217,1183,UnfinishedVerificationException with Kotlin after updating to 2.9.0,"Mockito update 2.8.47 → 2.9.0 brought us the exception when running the following test.

```kotlin
package redacted.package.name

import org.junit.Test
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify

class MockitoTest {

    @Test fun test() {
        val value = spy({})
        value.invoke()

        verify(value).invoke()
    }

    @Test fun testAgain() {
        val value = spy({})
        value.invoke()

        verify(value).invoke()
    }
}
```

```
org.mockito.exceptions.misusing.UnfinishedVerificationException: 
Missing method call for verify(mock) here:
-> at redacted.package.name.MockitoTest.testAgain(MockitoTest.kt:20)

Example of correct verification:
    verify(mock).doSomething()

Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.
Those methods *cannot* be stubbed/verified.
Mocking methods declared on non-public parent classes is not supported.

	at redacted.package.name.MockitoTest.test(MockitoTest.kt:10)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy1.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:146)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:128)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
	at java.lang.Thread.run(Thread.java:748)
``` 

Please notice that the following test will produce no errors.

```kotlin
package redacted.package.name

import org.junit.Test
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify

class MockitoTest {

    @Test fun test() {
        val value = spy({})
        value.invoke()

        verify(value).invoke()
    }
}
```

This works as well, so I assume it can be Kotlin-lamda-related.

```kotlin
package redacted.package.name

import io.reactivex.functions.Action
import org.junit.Test
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify

class MockitoTest {

    class ActionImpl : Action {
        override fun run() = Unit
    }

    @Test fun test() {
        val value = spy(ActionImpl())
        value.run()

        verify(value).run()
    }

    @Test fun testAgain() {
        val value = spy(ActionImpl())
        value.run()

        verify(value).run()
    }
}
```

Also, important detail. Running from IDE works fine, only Gradle runner is affected.

```
./gradlew :module:testDebugUnitTest
```","FYI the same thing happens with Mockito 2.10.0. =||= Should be fixed on master already. =||= @raphw Can you please point me at the commit? =||= https://github.com/mockito/mockito/commit/9848cec9ebb28791bca565200cdacf337730a015 =||= @raphw Just double-checked 2.10.0 and the issue is still the same 😞  =||= Ah, too bad. I will have a look. It surely is related to our performance optimizations of detecting overridden calls to avoid repeated mocking down the hierarchy. =||= The issue remains when using 2.11.0 as well. =||= I have added a test case on a branch now and started investigating. Seems like there is some issue with the sefl-invocation check such that the apply call is not recognized as a mock invocation. =||= It seems like this is an issue within bridge method resolution. Kotlin creates several methods with equal Java signature. Given test test class:
```java
class example.FunctionTest$testAgain$value$1
```

The Kotlin compiler implements two methods:
```java
java.lang.Object example.FunctionTest$testAgain$value$1.invoke()
void example.FunctionTest$testAgain$value$1.invoke()
```

From the view of the Java language, these two methods have an identical invocation signature and Byte Buddy attempts to resolve one method as a bridge method of the other one what is not correct for the Kotlin language.

I am currently trying to figure out why Kotlin is doing that, this would also break interoperability from Java. Unfortunately, this is not an easy mistake to work around either as we need to resolve bridge methods in order to handle Java classes correctly. And even with Kotlin, Java classes will always be involved via the core class library such that one cannot simply offer a language switch.

The fact that this broke recently is a result of fixing this resolution for Java which was necessary due to a bug in this mechanism. =||= Just checked the 2.12.0 and the issue seems to be fixed indeed. Thanks! =||= ",0
1218,1215,ClassFormatError when trying to mock certain interfaces,"Hi, 

I stumbled over some strange behaviour when trying to update from a 1.x version of Mockito to 2.x. One of my interfaces would no longer want to be mocked, throwing a MockitoException, with an error message of *Mockito cannot mock this class: interface &lt;MyInterfaceName&gt;*, ultimately triggered by a *java.lang.ClassFormatError: Duplicate field name&signature in class file &lt;MyInterfaceName&gt;$MockitoMock$1318839329*

This is the shortest code snippet I could come up with to reproduce the issue:

```java
import org.mockito.Mockito;

public class ClassFormatErrorTest {

    public static void main(String[] args) {
        // the next line will throw a MockitoException, caused by an
        // IllegalStateException, ultimately caused by ClassFormatError
        Mockito.mock(SimpleInterface.class);
    }

    private interface SimpleInterface {
        String getNameOfYs(X x, String str1, String str2, String str3);
        String getNameOfXs(Y y, String str1, String str2, String str3);
    }

    private class X {}
    private class Y {}
}
```

Software versions used:
* JVM version 1.8.0_151-b12 from Oracle (the issue also occurred with the version before)
* mockito-core 2.11.0 (also tried a few older versions, with the same result)
* on a Debian Linux system

Running above code creates the following output:

```
Exception in thread ""main"" org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface ClassFormatErrorTest$SimpleInterface.
Most likely it is due to mocking a private class that is not visible to Mockito

	at ClassFormatErrorTest.main(ClassFormatErrorTest.java:8)
Caused by: java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#defineClass
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Direct.defineClass(ClassInjector.java:412)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:185)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:187)
	at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:79)
	at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4456)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:115)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1821)
	at org.mockito.Mockito.mock(Mockito.java:1734)
	... 1 more
Caused by: java.lang.ClassFormatError: Duplicate field name&signature in class file ClassFormatErrorTest$SimpleInterface$MockitoMock$1318839329
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Direct.defineClass(ClassInjector.java:408)
	... 20 more
```

Before I created this short, self contained, single class example, I tried with the interface and two classes as separate files, with the same result, so it is not a problem of inner classes.

:exclamation: note that the interface's method names are important, they have to end in the class names + ""s"", otherwise the problem does not show.
:exclamation: also note that the methods have to take 4 parameters (works perfectly with only 3)","You found a bug in Byte Buddy. It computes a hash value for a unique identifier of a value and does not take the method types into account correctly what yields the same name for a field. This is illegal. Thanks for the report, this will be fixed in the next release. =||= So, this is the best bug I might ever have encountered. Byte Buddy requires stable names for fields that cache a value. I considered that using the hash of a `Method` would be good enough as those hashes should not collide.

Turns out that for your exact signature, due to the complementary use of X and Y in both methods, the hash calculation of `java.lang.reflect.Method` yields the exact same hash code. I need to add a check to Byte Buddy which assures that a new name is found if such a collision occurs.

This is primary because of the poor choice of hashing in the JVM but it is a really rare case despite the hash function. Thank you for reporting! =||= I have improved the collission strategy in Byte Buddy and I hope that this will be no more issue with the next release. If you change anything about your methods, the problem should no longer occur but I understand that this is not a good long term solution, I hope for your patience for the next releases of Byte Buddy and Mockito. =||= Thanks for picking this up so quickly. In the meantime, I have slightly changed my method names. Not nice, but seems to be the least effort workaround. Fortunately, I don't need to worry about backwards compatibility in this case. I'll go back to the original names with the next update of Mockito. =||= Great, thanks for your patience and again, this is really unlucky. Changing a single letter anywhere in your signature or types fixes your problem in the meantime. =||= ",0
1219,117,NullPointerException when using argThat() for long parameter in verify,"A minimal code example:

``` java
  @Test
  public void shouldNotBeBroken() throws Exception {
    TakesALong takesALong = mock(TakesALong.class);

    verify(takesALong).call(argThat(CoreMatchers.equalTo(11L)));
  }

  static interface TakesALong {
    void call(long l);
  }
```

This leads to an NPE logged as happening at the 'verify' call, which made me think that the the result of `verify(takesALong)` was null, but it seems like the NPE has a somewhat incomplete stack trace. Variations that don't show this problem include:
- changing the interface to take a `Long` instead of a `long`, or
- using `longThat(Matcher<Long>)` instead of `argThat()`

If it is considered an error to use `argThat` where you're passing in a long, then I think at least there should be a better error message.","I agree that better error message would be great. Do you have suggestions how to implement it?

There's a 'longThat' method that can be used in this context.

Hope that helps!
 =||= Is that `longThat` method different from the one I mentioned in the bug report? I've been able to solve my problem (IIRC, I used the `longThat(Matcher<Long>)` version), so the point of this report is to help prevent others from running into the same issue.

I don't have any suggestions for how to implement it - the stack trace confuses me a lot and I wouldn't know where to start looking for the problem. Do you have any pointers where to start? I'm completely unfamiliar with the Mockito source unfortunately..
 =||= Thanks for reporting the issue! It is very useful to build this documentation.

I'm not sure if it is feasible to improve the error message in this case. E.g. the implementation of argThat() does not know the receiver object nor the method. I used to think that this is not possible. However, your initial report got me thinking. Perhaps we can inspect the generic type of the matcher and if it is a primitive wrapper, it can return 0 or false. We would really appreciate your contribution :)

You could start with a failing test case (you have it already) and try to add some smartness to the implementation of argThat method.
 =||= > Perhaps we can inspect the generic type of the matcher and if it is a primitive wrapper, it can return 0 or false.

That is probably feasible, but this won't be of any use in most cases, because most of us use existing _matchers_ where most are generic with an `Object` upper bound.
 =||= Yeah, it would be good. Who wants to contribute the fix?

On Fri, Apr 3, 2015, 07:35 Brice Dutheil notifications@github.com wrote:

> Perhaps we can inspect the generic type of the matcher and if it is a
> primitive wrapper, it can return 0 or false.
> 
> That is probably feasible, but this won't be of any use in most cases,
> because most of us use existing _matchers_ where most are generic with an
> Object upper bound.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/117#issuecomment-89305725.
 =||= Is this still an ongoing issue? I am willing to do some investigation on this one.
 =||= I did some investigation and the problem is at [the GenericTypeExtractor](https://github.com/mockito/mockito/blob/15688023419199b0a27b15a8d782848cdfaa9530/src/main/java/org/mockito/internal/util/reflection/GenericTypeExtractor.java#L78).
When executing the posted testcase, the Matcher that is created is [IsEqual](https://github.com/hamcrest/JavaHamcrest/blob/c47a7b873345ee46073707d35c6f0cc847c4baf1/hamcrest-core/src/main/java/org/hamcrest/core/IsEqual.java).
When executing `getActualTypeArguments()` on `BaseMatchers.class`, it returns `Type[] {TypeVariableImpl}` with name `T`, as `BaseMatchers` is the declared superclass of `IsEqual`.

This behaviour is because `IsEqual` is declared as generic with `<T>`. Therefore I sadly don't see a feasible solution and would alter the documentation to state that primitives should use the other methods such as `longThat(long)`.
 =||= Ah, I had high hopes for the type extracting :(. Looks like the argXxx methods need to be included in MockitoHamcrest. Do you want to contribute? 
 =||= I can contribute yes (but have a lot of PRs open already, might cause some flooding). But what do you mean with `argXXX`?

Do you mean a signature like `public static long argThat(Matcher<Long> matcher)`? I am not sure if it compiles but I can try it out.

Still I don't think the underlying issue is solved, because `IsEqual<T>` with `T=Long` will not match the `Matcher<Long>`, but that would be left for experimentation.
 =||= > Do you mean a signature like public static long argThat(Matcher<Long> matcher)? I am not sure if it compiles but I can try it out.

It doesn't compile, `argThat(Matcher<Long>)` has the same erasure as `argThat(Matcher<T>)`. I guess this issue can't be fixed. 
The workaround is to use `MockitoHamcrest.longThat(Matcher<Long>)` or better `Mockito.eq(long)`.

IMO this issue can be closed.
 =||= I agree, maybe with future JDK version we could do something, not right now. Thanks @ChristianSchwarz for this archeological dive in mockito issues ;)
 =||= Also remove `bug` label, because it's not really a bug in mockito.
 =||= @bric3 Please reopen.

> It doesn't compile, argThat(Matcher<Long>) has the same erasure as argThat(Matcher<T>). I guess this issue can't be fixed. 

I was wrong. After looking #246 I noticed that this issue can be fixed! Two methods don't have the same erasure if the return type is different. The java 8 compiler generates a warning in this case, don't know about other versions. We need to provide overloads for all primitives like this:

```
public static long argThat(Matcher<Long> matcher) {
        reportMatcher(matcher);
        return 0;
}
```

For the provided test case the expected `MockitoException` _""Wanted but not invoked ...""_ is thrown.
 =||= @ChristianSchwarz nope that doesn't work, while java byte code allows to have method based on the complete signature (ie name, arg types and return type), the compiler just look at the name and arg types.

The following code don't compile : 

```
long argThat(Matcher<Long> matcher) {}
int argThat(Matcher<Integer> matcher) {}
```
 =||= @bric3 
Crazy the JDT compiler has no problem with your sample, it even works at runtime. After some investigation I found this answer on [stackoverflow ](http://stackoverflow.com/a/5562274/932656). It ~~should  worked with javac too~~ **worked until Java 7**, as the JLS seems to allow it due to a hole in the specs (if i understand that correct).

Also interesting: [With generics, the return type is part of the method signature.](http://vanillajava.blogspot.de/2011/02/with-generics-return-type-is-part-of.html).

But I agree, keep it closed for now.
 =||= This hack does not work with Java 8.
 =||= Jup!

It's a bug in eclipse JDT that only occures with a non standard JRE execution environment and compiler compliance setup. I filed an issue for the JDT-Team: [Bug 499817](https://bugs.eclipse.org/bugs/show_bug.cgi?id=499817)
 =||= Again, something against Eclipse. It's not the first bad bug using Eclipse compiler.

-- Brice

On Wed, Aug 17, 2016 at 12:39 PM +0200, ""Christian Schwarz"" notifications@github.com wrote:

Jup!

It's a bug in eclipse JDT that only occures with a non standard JRE execution environment and compiler compliance setup. I filed an issue for the JDT-Team: Bug 499817

—
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub, or mute the thread.
 =||= ",0
1221,445,Introduce MockitoExtension for JUnit Jupiter (a.k.a. JUnit 5),"## New Features in JUnit 5

The JUnit Jupiter extension model in JUnit 5 introduces support for constructor and method parameter resolution (i.e., dependency injection).

Specifically, third parties can implement the `ParameterResolver` extension API to inject dependencies, mocks, etc. into constructors and methods. In addition, the `TestInstancePostProcessor` extension API can be implemented to post-process a test instance (e.g., to perform field injection).

## Status Quo

Mockito supports _field injection_ for mocks via the `@Mock` annotation. In addition, #438 allows `@Mock` to be declared on parameters for constructors and methods which makes `@Mock` support an ideal candidate for both the `TestInstancePostProcessor` and `ParameterResolver` extension APIs in JUnit Jupiter. In fact, the JUnit Team has already developed a proof of concept: see the `MockitoExtension` in the [junit5-mockito-extension](https://github.com/junit-team/junit5-samples/tree/master/junit5-mockito-extension) sample project.

## Deliverables

- [x] Introduce an official `MockitoExtension` for JUnit Jupiter to replace the proof of concept from the JUnit team.","I think this issue can be merged with #390. Our plan there was to introduce JUnit 5 compatibility in Mockito 3.0 (since 2.0 is on the verge on being released in a couple of weeks).
 =||= Sorry: I overlooked #390.

Feel free to _merge_ it as you see fit.

thanks!
 =||= Let's track the JUnitExtension in this issue and list the specifications of the `MockitoExtension` for JUnit 5. The first point is to improve Parameterized compatibility.
 =||= @sbrannen Any news on this ?
 =||= @bric3, the `MockitoExtension` from the JUnit Team is usable with Mockito 2.0 snapshots and current versions of JUnit Jupiter (JUnit 5).

So, it's really up to the Mockito Team to decide when they want to take it over.
 =||= @sbrannen this one -> [example/mockito/MockitoExtension](https://github.com/junit-team/junit5-samples/blob/master/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java) ?
 =||= Yep, that's the one.
 =||= Thanks @sbrannen.
I was wondering if any API change would happen on JUnit 5. We will take over in mockito 3 once we are ready to switch branches for mockito 2
 =||= > I was wondering if any API change would happen on JUnit 5.

Well... that's the million dollar question -- isn't it? 😉 

All kidding aside, we are currently working on JUnit Jupiter 5.0 M3, but we still have quite a way to go before a GA release. So, although I cannot promise that the `Extension` APIs won't change any before GA, it appears that the APIs currently implemented by the `MockitoExtension` should remain rather stable.
 =||= OK that's good to know. Anyway we have to release 2.1 before starting 3.0 anyway. And a some API design work on 2.1 too, that may delay JUnit5 integration in the 3.0 beta phase.
 =||= Shall we start with fleshing out the specifications of the extension? Would like to have a working prototype when JUnit 5 is released, ETA Q1 2017. =||= Yes go for it, I'll create a submodule junit 5 at this time since JUnit 5 is a near complete rewrite, with a lot of binary incompatibilities. =||= +1

Do we want to completely decouple mockito-core module from JUnit? =||= @szczepiq I am not sure, but supporting both `JUnit4` and `JUnit5` in `mockito-core` seems problematic. We have seen similar issues with `Spring` having to support both Mockito 1 and 2. Therefore I think it is better to refactor Mockito 3 such that we publish 2 new artifact: `mockito-junit4` and `mockito-junit5` which provide the integration layer between Mockito and Junit.

@sbrannen Are you aware of other framework users depending on JUnit which employ this approach or is there a different and better solution? =||= In the `spring-test` module for the Spring Framework, we provide support for TestNG, JUnit 4, and JUnit Jupiter (what you call JUnit 5) alongside each other, just in different packages. 

That's all within a single JAR, and there are no issues since each of those is an optional dependency (in terms of the Maven POM).

Thus, projects that consume `spring-test` can pick which testing framework they wish to use (or potentially use TestNG, JUnit 4, and JUnit Jupiter all simultaneously,  however unlikely that may be).

As long as it's clear what developers need to consume for a given testing framework, it shouldn't be a problem having a single artifact. For example, with Spring, JUnit 4 users use the `SpringRunner`; whereas, JUnit Jupiter users use the `SpringExtension`.

 =||= If you do opt for separate modules (i.e., Maven artifacts), I would recommend against `mockito-junit5`, since what you are really providing is an extension for JUnit Jupiter -- which is the new programming model in JUnit 5.

The problem with naming such an artifact `mockito-junit5` is that there may well be a JUnit 6 or 7 still based on the JUnit Jupiter programming and extension models, and then the artifact name containing a `5` would no longer make sense.

FYI: I have just changed the title of this issue to reflect this fact. =||= Okay that seems reasonable, so let's take the package approach! My experience with jar configurations is limited, so in terms of the configuration of users' `pom.xml` I do not 100% understand how that is going to work. But I think we can figure that one out. Thanks for the explanation @sbrannen ! =||= @sbrannen thank you for describing and suggesting an approach. I like the idea of separation at the Java package level in the same jar. We can go for separate jars only when we have to (e.g. when JUnit versions clash). Do you have integration tests that demonstrate correct behavior with different test frameworks / different versions of test frameworks?

 =||= > Do you have integration tests that demonstrate correct behavior with different test frameworks / different versions of test frameworks?

Is that a rhetorical question? 😉 

Yes, of course we have tests for the Spring Framework. I'd be ashamed to let `spring-test` ship without an automated test suite.

Regarding the package structure, if you look [here](https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/main/java/org/springframework/test/context) you'll see the following:

- `org.springframework.test.context.junit4`
- `org.springframework.test.context.junit.jupiter`
- `org.springframework.test.context.testng`

So that's how we split up the functionality within the `spring-test` JAR.

We naturally have unit and integration tests for our JUnit 4, JUnit Jupiter, and TestNG support which you can find in various subpackages [here](https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/context).

Within the IDE, we execute TestNG tests with the TestNG plugin (e.g., for Eclipse); we execute JUnit 4 tests with the IDE's built-in support; and we execute JUnit Jupiter tests with the `JUnitPlatform` runner (at least within Eclipse for the time being). For the latter, see [SpringJUnitJupiterTestSuite](https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/test/java/org/springframework/test/context/junit/SpringJUnitJupiterTestSuite.java).

Within the [Gradle build](https://github.com/spring-projects/spring-framework/blob/master/build.gradle#L1123-L1152), we execute TestNG, JUnit 4, and JUnit Jupiter tests via Gradle's standard `test` task. In other words, in order to keep Spring's build as simple as possible, we don't yet use the JUnit Platform Gradle Plugin to execute JUnit Jupiter tests natively. Instead, we let the Gradle `test` task pick up the `SpringJUnitJupiterTestSuite` as a JUnit 4 test (which in turn executes all of our JUnit Jupiter tests as a suite).

I'm not sure if I've now said too much or too little. So if you still have questions, just ask!

Regards,

Sam =||= This week I had an interesting discussion with 2 of my student colleagues who are currently analyzing and documenting the architecture of JUnit. In this discussion we talked about the architecture in general as well as the extensions and in particular the MockitoExtension.

In this discussion I expressed my concerns regarding the new approach with injecting Mocks based on parameters. My colleagues told me that JUnit5 focuses more on testing with interfaces, in which the tests are also interfaces. Since interfaces do not have fields, field injection of mocks is not possible. Therefore the JUnit team proposes/chose to inject mocks via parameters.

Maintaining mocks is one of the most precarious tasks when working on a test suite and we at Mockito regularly receive feedback where Mocks are misbehaving. This is the exact reason that we are shipping features such as `Strict Stubbing` which reduce the amount of confusion and mistakes developers can make. By limiting the developer in making mistakes, we can prevent tests to incorrectly pass while in fact they are relying on misconfigured mocks.

As a result, our general goal for Mockito 3 is to leverage the available tools even more to prevent developers from making mistakes. Most notably I am personally advocating for increasing type-safety of our various features such that developers can rely on the compiler to warn them. Since running tests is a costly task and sometimes takes over an hour before CI finished all tests, the earlier developers can receive feedback regarding misconfiguration, the better.

Having said that, let's go back to the parameter injection currently available with JUnit5. While the status quo is field injection, a compiler can warn developers when they have a typo in the usage of a Mock. E.g. when a user wants to use `mock1`, while the field is actually named `mock2`, the compiler errors to notify the developer he/she made a mistake. Parameter injection does not have this behavior, as it is relying merely on the parameter name (or the name supplied to `@Mock`) which is plain String comparison.

While we are striving to prevent developers of making mistakes by leveraging the compiler, adopting parameter injection feels like a step back to me.

For this reason I am not in favor of going for parameter injection, but given the need for writing tests as interfaces I am not sure what our options are.

Of course we have not started writing an extension, so I have not tried this out. But I do think we should resolve this issue before coming up with a good story for Mockito 3 + JUnit5.

CC @LiamClark @Tarovk =||= How is parameter injection different from field injection?

_Edit:_ To rephrase my question a bit: How is field injection safer than parameter injection? Is there some Mockito feature I'm not aware of? =||= @marcphilipp I think he was talking about this error case:
```java
public class Test {
	@Mock Dependency mock1;
	@Before public void setUp() {
		when(mock1.foo()).thenBar();
	}
	@Test public void test() {
		// mock2 is a compile error
		new SUT(mock2).target();
	}
}
```

```java
class Test {
	@BeforeEach void setUp(@Mock Dependency mock1) {
		when(mock1.foo()).thenBar();
	}
	@Test void test(@Mock Dependency mock2) { // or @Mock(name=""mock2"")
		// mock2 is a newly created a mock without .foo() stubbing
		new SUT(mock2).target();
	}
}
```
The extension can't know if you intentionally want a new mock in your test method or you made a typo, while javac knows that you're referencing a non-existent field.

Re edit: The current extension impl caches the mocks: https://github.com/junit-team/junit5-samples/blob/026a9d9abe06b6173398c1a2518793259cd190f2/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java#L57 =||= @marcphilipp it is possible I am misunderstanding the proposed solution. @TWiStErRob beat me to it with an example testcase which I was indeed referring to. =||= Thanks for the explanation and the example. That helped! 🙂

With strict stubbing, the example in the error case would throw a ""validation error"" in the end, right?

Since we cannot force people to compile with `-parameters`, I think there are at least these possible approaches:

1. Treat every mock parameter like a different mock unless it has an explicit name.
2. Treat mock parameters for the same type like they're the refer to the same mock unless they have different explicit names.
3. Don't support injecting mocks into methods besides test methods at all.

What I like about being able to use method parameters: The mock is local to one test method. You can use different or even no mocks in different test methods. =||= > With strict stubbing, the example in the error case would throw a ""validation error"" in the end, right?

Yes, but at run-time instead of at compile-time. Nonetheless better then nothing :stuck_out_tongue: 

> What I like about being able to use method parameters: The mock is local to one test method. You can use different or even no mocks in different test methods.

I do understand the reasoning, but if you need a Mock that is local to a test method, why not a simple `Mock mock = mock(Mock.class)` at the start of the method? This usually also nicely fits in a `given-when-then` structure of test methods.

Just to note: I would really like to take advantage of Parameter mocking, but thus far I am afraid of creating more problems and confusion than it actually solves. Maybe we can come up with a golden solution :smile:  =||= No worries, I hear you and understand your concerns. We should definitely try to find the best solution. 🙂 =||= +1 for locality and Treating every mock parameter like a different mock unless it has an explicit name.

It also discourages complex mocking in interface tests. =||= +1 agree with locality, common setup in `@Before` usually creates more problems than solves. =||= For locality developers can already call `mock()` themselves. However @LiamClark pointed out during a chat that `@Mock` on a parameter can safely handle generics. For example when mocking Streams. That seems like a valid usecase. If we can solve this issue without ambiguity between multiple mocks, that could work. =||= Also `@Mock` feels a bit more declarative then mock(ClassLiteral.class) =||= @LiamClark not to mention all parameters that annotation can have versus the equivalent `MockSettings` builder =||= JUnit5 has been released and as such we probably need to create an official extension. Hopefully I have time in the near future, but feel free to contribute a PR if you have time. =||= What are the requirements for a MVP? =||= On the top of my head runner-like functionality with:
1. Initialize `@Mock` and `@InjectMocks`
1. Check verificationstate after test ran
1. Clean up MockitoFramework listeners
1. Check for strict stubs =||= Okay I am looking into it...

* Should it target mockito 2? 
* Is a new subproject required? =||= Yes to both! =||= What should go into the junit5-subproject? The implementation, the junit5 tests or both ? 
 =||= The implementation of a Mockito extension for Junit5. It is probably coming down to a single or a couple of classes. =||= Any news on this issue? =||= @marcphilipp Development started in #1221. There we hit #1232 which is an internal issue. There are several implicit assumptions in our internal API that were true for JUnit4, but are no longer valid for JUnit5. If I understand the issue correctly, the current extension has to supported nested classes. With JUnit4 we did not support this, but with JUnit5 we have to do this.

Timeline-wise, I am not sure how much time one of the @mockito/core developers has to review #1221 and fix our internal API. Especially as `MockitoSession` is part of our public API, we have little wiggle room. I know that the Software Quality and Testing course in quarter 4 of our university wants to use Mockito and JUnit5, so I probably need to discuss with @LiamClark what the details of that is. I might be able to find some time in that regard to work on this issue.

All in all, while implementation seemed easy at first, we hit some unfortunate core issues in our public API that need to be addressed. Once we figured that out, it should be fairly straightforward to finish the extension. =||= Thanks for the update! Let me know if I can help in any way. 🙂  =||= Thank @marcphilipp for a friendly ping and @TimvdLippe for recapping the status.

I'm making progress on getting Strictness configurable: #792. This should remove a complexity from the JUnit5 extension PR that @ChristianSchwarz was working on. I hope that Christian can resume work. If not, we can review the design and someone will take a stab at it. How about you @marcphilipp? =||= I can resume to work on it . Actually I am short on time so a ""pre""-review of  #1221 would help. Maybe some one can start with #1232 in the mean time. =||= Regarding #1232: another option would be to not support nesting of test classes. I think we actively have to consider this option, given our public API was apparently coupled to the JUnit4 implementation and we can not ship breaking changes per our policy. =||= Well, it's `@Incubating` so you could still change it, right? 😉

Besides, I think neither of the two proposals would break compatibility, would they? But then again, we should discuss this over at #1232. 🙂  =||= Hm, looking at it again, it seems that the breaking change is actually in an internal API, namely [`TestFinishedEvent`](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/junit/TestFinishedEvent.java#L11), which is created in `MockitoSession`. As such, I think we should be okay actually. I will do a proper investigation this weekend (hopefully, else next week) and update #1221. I hope you are okay with that @ChristianSchwarz ? Once that is done, I can more definitively say the impact on our API and whether we are risking a breaking change. I have good hopes now we might actually dodge that. =||= `TestFinishedEvent.getTestClassInstance()` and `TestFinishedEvent.getTestMethodName()` are currently only used (twice) like this:
```java
String testName = event.getTestClassInstance().getClass().getSimpleName() 
                  + ""."" + event.getTestMethodName();
```

Currently, `DefaultMockitoSession` always uses `null` for `TestFinishedEvent.getTestMethodName()` which strikes me as odd. I think it would be better if `TestFinishedEvent` only had two methods: `getFailure()` and `getTestName()`. Then, `MockitoSessionBuilder` could get a `testName(String)` builder method and `DefaultMockitoSessionBuilder` could pass it to `DefaultMockitoSession` and so on.

Alternatively, `MockitoSessionBuilder` could get a `testMethodName()` builder method and pass that on.

Moreover, I think `MockitoSessionBuilder` should allow to configure a `MockitoLogger`. This way, frameworks like JUnit could pass in a custom implementation. For JUnit Jupiter, a `MockitoLogger` that publishes report entries instead of writing to stdout (which causes problems will parallel execution) comes to mind.

Thoughts? =||= @marcphilipp 
@TimvdLippe 
Good idea to continue the discussion about #1232 in that ticket, i copied your the relevant comments over there. =||= it would be nice if the MockitoExtension works together with `@TestFactory` based methods. When I use the extension created by the JUnit team, I need to manually reset mocks within the dynamic test method. 

@sbrannen you guys already thought about how to integrate that? =||= @paulmiddelkoop There's no lifecycle support for dynamic tests and we currently have no plans to add any, i.e. there's no hook to reset mocks after a dynamic test. You could use `MockitoSession` in your `@TestFactory` method directly. 🤔 =||= I agree with @marcphilipp: due to the lack of lifecycle support for dynamic tests (see the [Dynamic Test Lifecycle](https://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests) _note_ in the User Guide), you'll have to reset mocks manually.

Note, however, that you'll likely want to reset them within each `Executable` (i.e., lambda expression or method reference) returned by your `@TestFactory` method.

 =||= Thanks @marcphilipp and @sbrannen for the explanation. Any reason why there is no lifecycle support for dynamic tests? 

For now I ended up with a utility function for this:
```kotlin
    fun dynamicMockitoTest(testInstance: Any, displayName: String, executable: () -> Unit): DynamicTest {
        val mockito = Mockito.mockitoSession()
            .initMocks(testInstance)
            .strictness(Strictness.STRICT_STUBS)
            .startMocking()
        try {
            return dynamicTest(displayName, executable)
        } finally {
            mockito.finishMocking()
        }
    }
```

However this will not work if I also have regular `@Test` methods and implement the MockitoExtension to also use the MockitoSession instead of `MockitoAnnotations.initMocks(testInstance)`. It will result in a ""Previous MockitoSession was not concluded with 'finishMocking()"" error which is logical. I could put the `ExtendWith(MockitoExtension::class)` on every `@Test` method instead of the class as a solution, I guess. 

I think a simpler integration is needed for a good adoption of dynamic tests. It's a regular use case to use mocking inside dynamic tests, right?
 =||= > Any reason why there is no lifecycle support for dynamic tests?

Dynamic tests are intended for simple use cases that do not need lifecycle callback support. If one needs lifecycle callback support, it is then recommended to use parameterized tests.

> However this will not work if I also have regular `@Test` methods...

Actually, that won't work at all, not even for dynamic tests.

Your current code example initializes and resets mocks around the _construction_ of the `DynamicTest` instance; whereas, it must do that at _execution_ time (i.e., when the `Executable` is actually invoked by JUnit Jupiter).

You would instead need to create your own _wrapper_ around the invocation of your `executable`, and that wrapper would need to implement the try-finally logic around the execution of the actual `executable`.

> I think a simpler integration is needed for a good adoption of dynamic tests. It's a regular use case to use mocking inside dynamic tests, right?

We don't know. The dynamic test support is an _experimental_ feature. So that remains to be seen. 😉  =||= @paulmiddelkoop if you create an extension method you don't need to pass in `this@FooTest` every time:
```kotlin
fun Any.dynamicMockitoTest(displayName: String, executable: () -> Unit): DynamicTest =
	dynamicTest(displayName) {
		val mockito = Mockito.mockitoSession()
				.initMocks(this@dynamicMockitoTest)
				.strictness(Strictness.STRICT_STUBS)
				.startMocking()
		try {
			executable()
		} finally {
			mockito.finishMocking()
		}
	}
```
and the usages of `dynamicTest` and `dynamicMockitoTest` should look the same. (This version also includes what @sbrannen said to delay the try-finally execution.)

> So that remains to be seen.

Well, now you have two votes for mocking in dynamic tests. =||= @paulmiddelkoop & @TWiStErRob, if you want support for lifecycle callbacks for dynamic tests in JUnit Jupiter, the best place to make your wishes heard is https://github.com/junit-team/junit5/issues/378. =||= What is the ETA for Mockito 3.x? I'd love to see this feature. =||= The intent now is to ship junit5 support in a separate artifact with mockito 2 =||= @TimvdLippe That is great news - maybe the milestone should be updated to reflect this?
For any others waiting for this https://github.com/JeffreyFalgout/junit5-extensions/tree/master/mockito-extension might be of help in the meantime.  =||= A little house-keeping:

The change in #438 was made to allow Mocks to be generated for the parameters to test and support methods. =||= @smoyer64 That is correct. I wanted to publish the extension as it was lingering for too long and thus did not want to wait on discussion about ""new features"" (compared to the 4 runner). Please open a new issue to discuss that change. =||= @TimvdLippe 

I haven't had a chance to try out the official ``MockitoExtension`` you published yesterday (I'm watching for it in Maven Central but rereading your post perhaps I should be watching Sonatype's OSS-SNAPSHOTS), so I wasn't aware that the version you published was missing this functionality.  I just thought it was important to lump these two requests together.

The ``MockitoExtension`` prototype that published as a sample by the JUnit 5 team has this feature so I guessed I assumed the official version did too?  In any case, I think it's a really useful feature for cases where not every test needs a specific ``Mock`` (and the injected ``Mock`` has different behaviors if used in more than one test) so I'd be happy to write up a feature request.

I have to admit I was pretty excited to see this released yesterday since it would provide an official way to use Mockito with JUnit 5.  Unfortunately we're already using the ``ParameterResolver`` from the prototype ``MockitoExtension`` so I guess we're in for a bit more of a wait.  Let me know if I can help. =||= @smoyer64 as I said I am open for adding that feature, but I would like to discuss it first in a separate issue. So please open one with your use-case so we can discuss 😄  =||= @TimvdLippe Sorry I wasn't clear in my last comment.  I do realize that this issue is closed and went off to write the feature request you asked for (and got side-tracked by an emergency with one of the non-profits I help run).  I also looked at all the JUnit 5 related issues that were already posted.  Would it be worth having a JUnit 5 label to help organize them?

In any case, I've now added #1348 ... please let me know if additional information is needed.

Thanks for all the hard work you've done to provide official JUnit 5 support in Mockito! =||= Since this is one of the top Google results for trying to get this working, and I'll likely Google it again, I'd like to add that this is in the mockito-junit-jupiter project. [Maven Central link mockito-junit-jupiter](https://mvnrepository.com/artifact/org.mockito/mockito-junit-jupiter) =||= ",0
1228,1130,Mockito should annotate when() methods with a custom annotation @CheckReturnValue,"Static code checkers like error-Prone and FindBugs will help detecting invalid usage of Mockito in single-call situations if Mockito source code were annotated with @CheckReturnValue.

See:
* https://github.com/joel-costigliola/assertj-core/issues/157
* http://errorprone.info/bugpattern/CheckReturnValue
* https://github.com/joel-costigliola/assertj-core/pull/695
* https://github.com/joel-costigliola/assertj-core/blob/master/src/main/java/org/assertj/core/util/CheckReturnValue.java

Note like for AssertJ, any annotation with name should do, no need to depend on a specific library with  @CheckReturnValue.",That seems fine to me. Please submit a pull request :smile:  =||= ,0
1229,107,Improve internal implementation so that it is possible to implement mocking abstract classes,Improve internal implementation so that it is possible to implement mocking abstract classes. Required for smooth implementation of #106,nan,0
1242,1239,Enable Checkstyle rule for checking existence of license headers,"Whenever we add new files to the repository, we usually forget to add our license headers. This results in PRs such as #1227 where retroactively we add the license headers.

CheckStyle has a rule called [`Header`](http://checkstyle.sourceforge.net/config_header.html) which can enforce that we add our license header. I would propose to start enabling this rule to make sure all our source files comply to our licensing.

@mockito/core yay/nay?","Think it makes sense to add a check since we have it. Without it, the project will just always be inconsistent. =||= Absolutely +1. Thank you! =||= ",0
1244,1233,Mockito build should not try to install anything to /usr/lib/node_modules by default,"The build of the recent Mockito is trying to install some Node JS modules globally in the system on just `gw check`. Probably no-one sane runs the build from root, but it's a bad practice IMHO.

```
> Task :javadoc
...
Installing sw-precache globally
npm WARN checkPermissions Missing write access to /usr/lib/node_modules
npm ERR! path /usr/lib/node_modules
npm ERR! code EACCES
npm ERR! errno -13
npm ERR! syscall access
npm ERR! Error: EACCES: permission denied, access '/usr/lib/node_modules'
npm ERR!  { Error: EACCES: permission denied, access '/usr/lib/node_modules'
npm ERR!   stack: 'Error: EACCES: permission denied, access \'/usr/lib/node_modules\'',
npm ERR!   errno: -13,
npm ERR!   code: 'EACCES',
npm ERR!   syscall: 'access',
npm ERR!   path: '/usr/lib/node_modules' }
npm ERR! 
npm ERR! Please try running this command again as root/Administrator.

npm ERR! A complete log of this run can be found in:
npm ERR!     /home/foo/.npm/_logs/2017-10-29T23_39_39_312Z-debug.log
NPM is not installed. Aborting generating service-worker
```

I would prefer to even do not install npm modules locally (in the user home directory) in the default build. Only on Travis (or on demand) with the extra `-P` switch.","Yeah I have been getting more annoyed about this npm install. Sadly the
theory of the service-worker does not work in practice with javadoc.
Probably its best just to revert it all. Nice experiment, sadly didnt work
out as desired :(

On Mon, 30 Oct 2017, 00:48 Marcin Zajączkowski, <notifications@github.com>
wrote:

> The build of the recent Mockito is trying to install some Node JS modules
> globally in the system on just gw check. Probably no-one sane runs the
> build from root, but it's a bad practice IMHO.
>
> > Task :javadoc
> ...
> Installing sw-precache globally
> npm WARN checkPermissions Missing write access to /usr/lib/node_modules
> npm ERR! path /usr/lib/node_modules
> npm ERR! code EACCES
> npm ERR! errno -13
> npm ERR! syscall access
> npm ERR! Error: EACCES: permission denied, access '/usr/lib/node_modules'
> npm ERR!  { Error: EACCES: permission denied, access '/usr/lib/node_modules'
> npm ERR!   stack: 'Error: EACCES: permission denied, access \'/usr/lib/node_modules\'',
> npm ERR!   errno: -13,
> npm ERR!   code: 'EACCES',
> npm ERR!   syscall: 'access',
> npm ERR!   path: '/usr/lib/node_modules' }
> npm ERR!
> npm ERR! Please try running this command again as root/Administrator.
>
> npm ERR! A complete log of this run can be found in:
> npm ERR!     /home/foo/.npm/_logs/2017-10-29T23_39_39_312Z-debug.log
> NPM is not installed. Aborting generating service-worker
>
> I would prefer to even do not install npm modules locally (in the user
> home directory) in the default build. Only on Travis (or on demand) with
> the extra -P switch.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1233>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb94gDamGIwuYA1kWznAMgBmMgKCuks5sxQ63gaJpZM4QKiAB>
> .
>
 =||= Happy to see this fixed! =||= ",0
1247,904,Remove unnecessary classes,"Looking at https://codecov.io/gh/mockito/mockito/list/e92b0be0c6362157e2c8ae349a2b9d1295065d2e/src and sorting it by coverage, it appears that there are some classes that are completely untested. Taking another closer look reveals some candidate classes that can be removed. For example `MockitoLimitations` is [only used in the Reporter](https://github.com/mockito/mockito/search?utf8=%E2%9C%93&q=MockitoLimitations), the field can therefore be placed in the Reporter directly.

There are also some debugging and util classes that seem unused. If we do decide to retain them, I think we should test them to actually make sure they are working properly.",nan,0
1250,1243,Provide Java 10 compatibility,"I ran the JUnit 5 build on jdk-10-ea and encountered a Mockito-related issue.

```
  JUnit Jupiter:TestFactoryTestDescriptorTests:streamsFromTestFactoriesShouldBeClosed()
    MethodSource [className = 'org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptorTests', methodName = 'streamsFromTestFactoriesShouldBeClosed', methodParameterTypes = '']
    => org.mockito.exceptions.base.MockitoException: 

Mockito cannot mock this class: interface org.junit.jupiter.api.extension.ExtensionContext.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.

Java               : 10
JVM vendor name    : Oracle Corporation
JVM vendor version : 10-ea+29
JVM name           : Java HotSpot(TM) 64-Bit Server VM
JVM version        : 10-ea+29
JVM info           : mixed mode
OS name            : Linux
OS version         : 4.11.6-041106-generic

Underlying exception : java.lang.UnsupportedOperationException: Cannot define class using reflection
```

See full log at: https://travis-ci.org/junit-team/junit5/builds/296747184
See JUnit 5 issue that tracks JDK-9+ related issues at: https://github.com/junit-team/junit5/issues/1063

I guess, there's command line switch that transforms the exception into a warning.

",":cold_sweat: And we were just able to fix compatibility issues with JDK9 :joy: Is there a small reproduction example that we can add to our test suite and debug with? =||= No, no small sample, yet. But I guess you'll see similar issues when adding a ""jdk-10"" axis to your Travis CI build matrix. You're welcome to copy the installation script from https://github.com/junit-team/junit5/blob/jdk-10/src/scripts/install-jdk.sh ... usage in `.travis.yml` could look like:
```
install:
# ""dot source"" the jdk installation script
  - . ./src/scripts/install-jdk.sh

script:
  - ./gradlew build --scan --stacktrace
``` =||= It's ByteBuddy, @raphw `java.lang.IllegalArgumentException: Unknown Java version: 10
	at net.bytebuddy.ClassFileVersion.ofJavaVersion(ClassFileVersion.java:135)`

[ClassFileVersion](https://github.com/raphw/byte-buddy/blob/master/byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java) does not support ""10"", yet.

```
Underlying exception : java.lang.UnsupportedOperationException: Cannot define class using reflection

	at org.junit.jupiter.engine.execution.ExecutableInvokerTests.<init>(ExecutableInvokerTests.java:46)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:488)
	at org.junit.platform.commons.util.ReflectionUtils.newInstance(ReflectionUtils.java:347)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:60)
	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.instantiateTestClass(ClassTestDescriptor.java:197)
	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.instantiateAndPostProcessTestInstance(ClassTestDescriptor.java:188)
	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.lambda$testInstanceProvider$1(ClassTestDescriptor.java:181)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:80)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:60)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$2(HierarchicalTestExecutor.java:92)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$2(HierarchicalTestExecutor.java:92)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:51)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)
	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:65)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
Caused by: java.lang.UnsupportedOperationException: Cannot define class using reflection
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Unavailable.defineClass(ClassInjector.java:821)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:185)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:187)
	at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:79)
	at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4456)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:115)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:51)
	at org.mockito.Mockito.mock(Mockito.java:1798)
	at org.mockito.Mockito.mock(Mockito.java:1711)
	... 50 more
Caused by: java.lang.IllegalArgumentException: Unknown Java version: 10
	at net.bytebuddy.ClassFileVersion.ofJavaVersion(ClassFileVersion.java:135)
	at net.bytebuddy.ClassFileVersion$VersionLocator$ForJava9CapableVm.locate(ClassFileVersion.java:357)
	at net.bytebuddy.ClassFileVersion.ofThisVm(ClassFileVersion.java:147)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$CreationAction.run(ClassInjector.java:301)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$CreationAction.run(ClassInjector.java:290)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.<clinit>(ClassInjector.java:70)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:184)
	... 67 more

``` =||= Okay, that should be an easy fix: https://github.com/raphw/byte-buddy/blob/032d63eefca08d33b45e85e184dad28f752c6d76/byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java#L133 that depends on lines like https://github.com/raphw/byte-buddy/blob/032d63eefca08d33b45e85e184dad28f752c6d76/byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java#L72

E.g. if ASM defines an Opcode for Java 10, Byte Buddy can work on Java 10, such that Mockito works on Java 10, such that JUnit5 works on Java 10 :joy:  =||= ...every 6 month. 🎉 

There must be better solution. Mock w/o generating byte code? Proxies? ;) =||= @raphw (I assume you have an OW2 ASM account, if you don't I can do it as well)

Could you open an issue over at their gitlab (https://gitlab.ow2.org/asm/asm/issues) to add support for Java 10 (and to make sure they update on time for future Java releases)? =||= All right, issue has been filed upstream at https://github.com/raphw/byte-buddy/issues/370 We can close this issue once BB is fixed and bumped in Mockito =||= Nice! Thank you for following up on this! =||= This is fixed on master and will be part of the next Byte Buddy update. =||= @raphw Awesome work with the speedy fix. Soon we will need to enable Java 10 testing on Travis too, but let's create a separate issue for that 😄  =||= I wonder if they already make the images accessible. But I agree: there will probably be regular breakages, what makes monitoring it worthwhile. =||= You can install JDK10 via https://github.com/junit-team/junit5/blob/jdk-10/src/scripts/install-jdk.sh =||= Thanks for the fix @raphw 

Fixed issue from the initial description via https://github.com/junit-team/junit5/commit/68d801aeb34e9964a77d622b0ab3c267151954e1
 =||= We are publishing a new version as we speak. Should land in maven central by tomorrow or so 🎉  =||= https://bintray.com/mockito/maven/mockito/2.12.0 has been published. Doesn't show up in https://mvnrepository.com/artifact/org.mockito/mockito-core but I think it should ""just work"". =||= ",0
1257,1254,"Wanted but not invoked on 2.12.0, but not on 2.11.0","After updating Mockito from 2.11.0 to 2.12.0 the following test fails with `Wanted but not invoked`.

The weird thing is this happens only when running tests using Gradle. Android Studio runs the same test as successful. Just like #1183.

```java
package package.redacted;

import org.junit.Test;
import org.mockito.Mockito;

public class ViewModelTest {

    class View {
        private Runnable actionCallback = null;

        void callAction(Runnable callback) {
            actionCallback = callback;
        }

        void simulateActionCalled() {
            if (actionCallback != null) {
                actionCallback.run();
            }
        }

        void showResult() {
        }
    }

    class ViewModel {

        public ViewModel(final View view) {
            view.callAction(new Runnable() {
                @Override
                public void run() {
                    view.showResult();
                }
            });
        }
    }

    @Test public void test() {
        View view = Mockito.spy(new View());
        ViewModel viewModel = new ViewModel(view);

        view.simulateActionCalled();

        Mockito.verify(view).showResult();
    }
}
```
```
Wanted but not invoked:
view.showResult();
-> at package.redacted.ViewModelTest$View.showResult(ViewModelTest.java:22)

However, there were exactly 2 interactions with this mock:
view.callAction(
    package.redacted.ViewModelTest$ViewModel$1@26645040
);
-> at package.redacted.ViewModelTest$ViewModel.<init>(ViewModelTest.java:28)

view.simulateActionCalled();
-> at package.redacted.ViewModelTest.test(ViewModelTest.java:41)


	at package.redacted.ViewModelTest$View.showResult(ViewModelTest.java:22)
	at package.redacted.ViewModelTest.test(ViewModelTest.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy1.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:108)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:146)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:128)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
	at java.lang.Thread.run(Thread.java:748)
```","I'm observing a similar issue. Only happens with `mockito-inline`. Don't have time right now to distill the affected tests into a minimal reproduction case. Maybe @raphw has a hunch. =||= Alright, decided to look for a minimal reproduction case after all. This is what I came up with:
```java
package com.example

import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;

import org.testng.annotations.Test;

public final class MockitoIssue1254Test {
    @Test
    public void test() {
        Dummy d = spy(new Dummy());
        d.foo();
        verify(d).bar(eq(""baz""));
    }

    static class Dummy {
        public void foo() {
            bar(""baz"");
        }

        // Also fails if public.
        void bar(String s) {}
    }
}
```

Causes:
```
Wanted but not invoked:
dummy.bar(""baz"");
-> at com.example.MockitoIssue1254Test$Dummy.bar(MockitoIssue1254Test.java:23)

However, there was exactly 1 interaction with this mock:
dummy.foo();
-> at com.example.MockitoIssue1254Test.test(MockitoIssue1254Test.java:13)
```

This test does pass with Mockito 2.11.0. It also passes with Mockito 2.12.0, provided `mockito-inline` is disabled. =||= Probably another error in the logic for self-invocation detection. I will have a look! =||= Ok, this was just me forgetting how my implementation intially worked. I fixed it locally and will push a fix soon. =||= Same for mocked methods on Spy. On 2.12.0 real method is called. =||= When is this going to be on Maven Central? =||= We could trigger a new release, @TimvdLippe, would you find some time? =||= Yeah I can try it tomorrow :)

Op di 5 dec. 2017 om 20:55 schreef Rafael Winterhalter <
notifications@github.com>:

> We could trigger a new release, @TimvdLippe
> <https://github.com/timvdlippe>, would you find some time?
>
> —
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1254#issuecomment-349422044>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb3sUMqw_c_exn9HiMDi5ls1QmDHdks5s9Z_LgaJpZM4QZVVK>
> .
>
 =||= Version 2.13.0 should be published and available soon in Maven Central!

P.S. @mockitoguy the `[ci maven-central-release]` was working flawlessly :tada:  =||= Danke! Bedankt! Many thanks! =||= Can confirm that finally our suite of 13+ K Kotlin tests work after fixing #1183 and this one ✨ Thanks! =||= >P.S. @mockitoguy the [ci maven-central-release] was working flawlessly 🎉

Awesome! Thank you for pushing out the version! =||= ",0
1257,1256,Unbounded recursion when spying with `mockito-inline`,"Consider the following code:
```java
@Test
public void test() {
    ConcurrentMap<String, String> map = spy(new ConcurrentHashMap<>());
    map.putIfAbsent(""a"", ""b"");
}
```

Running it causes a `StackOverflowError`:
```
Configuring TestNG with: TestNG60Configurator
Exception in thread ""TestNG-test=Surefire test-1"" java.lang.StackOverflowError
        at org.mockito.internal.creation.bytebuddy.MockMethodDispatcher.get(MockMethodDispatcher.java:20)
        at java.util.concurrent.ConcurrentHashMap.containsKey(ConcurrentHashMap.java:964)
        at org.mockito.internal.util.concurrent.WeakConcurrentMap.containsKey(WeakConcurrentMap.java:74)
        at org.mockito.internal.util.concurrent.WeakConcurrentMap$WithInlinedExpunction.containsKey(WeakConcurrentMap.java:261)
        at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.isMock(MockMethodAdvice.java:116)
        at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.isMocked(MockMethodAdvice.java:121)
        at java.util.concurrent.ConcurrentHashMap.containsKey(ConcurrentHashMap.java:964)
        at org.mockito.internal.util.concurrent.WeakConcurrentMap.containsKey(WeakConcurrentMap.java:74)
        at org.mockito.internal.util.concurrent.WeakConcurrentMap$WithInlinedExpunction.containsKey(WeakConcurrentMap.java:261)
        at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.isMock(MockMethodAdvice.java:116)
        at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.isMocked(MockMethodAdvice.java:121)
        at java.util.concurrent.ConcurrentHashMap.containsKey(ConcurrentHashMap.java:964)
        ...
```

Tested with Mockito 2.11.0 and 2.12.0. Do not happen if I disable `mockito-inline`. CC @raphw.","I will have a look, thanks! =||= The problem is that we use a hash map internally to store mock dispatchers. We need to exclude this map from checking for being a mock explicitly as the check involves reading from the map what triggers the recursion. =||= ",0
1257,1254,"Wanted but not invoked on 2.12.0, but not on 2.11.0","After updating Mockito from 2.11.0 to 2.12.0 the following test fails with `Wanted but not invoked`.

The weird thing is this happens only when running tests using Gradle. Android Studio runs the same test as successful. Just like #1183.

```java
package package.redacted;

import org.junit.Test;
import org.mockito.Mockito;

public class ViewModelTest {

    class View {
        private Runnable actionCallback = null;

        void callAction(Runnable callback) {
            actionCallback = callback;
        }

        void simulateActionCalled() {
            if (actionCallback != null) {
                actionCallback.run();
            }
        }

        void showResult() {
        }
    }

    class ViewModel {

        public ViewModel(final View view) {
            view.callAction(new Runnable() {
                @Override
                public void run() {
                    view.showResult();
                }
            });
        }
    }

    @Test public void test() {
        View view = Mockito.spy(new View());
        ViewModel viewModel = new ViewModel(view);

        view.simulateActionCalled();

        Mockito.verify(view).showResult();
    }
}
```
```
Wanted but not invoked:
view.showResult();
-> at package.redacted.ViewModelTest$View.showResult(ViewModelTest.java:22)

However, there were exactly 2 interactions with this mock:
view.callAction(
    package.redacted.ViewModelTest$ViewModel$1@26645040
);
-> at package.redacted.ViewModelTest$ViewModel.<init>(ViewModelTest.java:28)

view.simulateActionCalled();
-> at package.redacted.ViewModelTest.test(ViewModelTest.java:41)


	at package.redacted.ViewModelTest$View.showResult(ViewModelTest.java:22)
	at package.redacted.ViewModelTest.test(ViewModelTest.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy1.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:108)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:146)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:128)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
	at java.lang.Thread.run(Thread.java:748)
```","I'm observing a similar issue. Only happens with `mockito-inline`. Don't have time right now to distill the affected tests into a minimal reproduction case. Maybe @raphw has a hunch. =||= Alright, decided to look for a minimal reproduction case after all. This is what I came up with:
```java
package com.example

import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;

import org.testng.annotations.Test;

public final class MockitoIssue1254Test {
    @Test
    public void test() {
        Dummy d = spy(new Dummy());
        d.foo();
        verify(d).bar(eq(""baz""));
    }

    static class Dummy {
        public void foo() {
            bar(""baz"");
        }

        // Also fails if public.
        void bar(String s) {}
    }
}
```

Causes:
```
Wanted but not invoked:
dummy.bar(""baz"");
-> at com.example.MockitoIssue1254Test$Dummy.bar(MockitoIssue1254Test.java:23)

However, there was exactly 1 interaction with this mock:
dummy.foo();
-> at com.example.MockitoIssue1254Test.test(MockitoIssue1254Test.java:13)
```

This test does pass with Mockito 2.11.0. It also passes with Mockito 2.12.0, provided `mockito-inline` is disabled. =||= Probably another error in the logic for self-invocation detection. I will have a look! =||= Ok, this was just me forgetting how my implementation intially worked. I fixed it locally and will push a fix soon. =||= Same for mocked methods on Spy. On 2.12.0 real method is called. =||= When is this going to be on Maven Central? =||= We could trigger a new release, @TimvdLippe, would you find some time? =||= Yeah I can try it tomorrow :)

Op di 5 dec. 2017 om 20:55 schreef Rafael Winterhalter <
notifications@github.com>:

> We could trigger a new release, @TimvdLippe
> <https://github.com/timvdlippe>, would you find some time?
>
> —
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1254#issuecomment-349422044>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb3sUMqw_c_exn9HiMDi5ls1QmDHdks5s9Z_LgaJpZM4QZVVK>
> .
>
 =||= Version 2.13.0 should be published and available soon in Maven Central!

P.S. @mockitoguy the `[ci maven-central-release]` was working flawlessly :tada:  =||= Danke! Bedankt! Many thanks! =||= Can confirm that finally our suite of 13+ K Kotlin tests work after fixing #1183 and this one ✨ Thanks! =||= >P.S. @mockitoguy the [ci maven-central-release] was working flawlessly 🎉

Awesome! Thank you for pushing out the version! =||= ",0
1258,106,Partial,"Hi, Here's the implementation of the partial mock support I was talking about:

```
partialMock(Class);
partialMock(Object enclosingInstance, Class innerClass);
```

The second overload is the one solution to the arbitrary constructor parameter issue:

```
@Mock private Collaborator1 mockCollaborator1;
@Mock private Collaborator2 mockCollaborator2;
@PartialMock private MockWorker worker;

abstract class MockWorker extends Worker {
  MockWorker() {
    super(mockCollaborator1, mockCollaborator2);
  }
}
```

I didn't name it spy() for the following reasons:
1. spy() doesn't work for final methods. It would be surprising if user's partial mock works without ""final"" and stops working when ""final"" is added. The non-abstract methods aren't meant to be mocked after all.
2. With partial mock, one goal is to allow having state in the object. The shallow copying of spy() won't always work when there is mutable state, especially if there are private methods in the class that spy cannot intercept.
3. ""Spy"" conceptually needs a target object to spy on. Without a target, spy(Foo.class) feels non-intuitive.
4. All the use cases I know of for partial mocking don't need spying.
5. If really needed, one can always explicitly `spy(partialMock(Foo.class))`.

Annotation support isn't added yet.","Another use case I considered but would like to get some feedback before adding to the javadoc.

As the FAQ puts it:

> Technically speaking Mockito is a Test Spy framework...
> Test Spy framework allows to verify behaviour (like mocks) and stub methods (like good old hand-crafted stubs).

But it leaves one question open: should one ever use the ""good old hand-crafted stubs"" at all? If yes, under what scenario?

A main reason that people use the `when().thenReturn()` DSL instead of the hand-crafted stubs is that for interfaces with many methods, hand-crafting the stub means to write lots of extra boilerplate override methods that aren't interesting to the test.

But with partial mock, the above is no longer true. It's easy enough to hand-roll an abstract stub class, implementing only the interesting methods, and then partialMock() it.

Between the two different ways of stubbing (plain old `@Override` vs. `when().thenReturn()`), here's a guideline I've been following with success:
- `when().thenReturn()` is best used to stub data logically related to the current test. That is, it's best used in the individual test methods. The DSL reads nicely in the BDD given-when-then style.
- For stubbing shared data that aren't logically specific to any individual test, plain old abstract classes work better, because the `when().thenReturn()` DSL can usually lead to messy setUp() method with stubbing of several different objects crammed together. In other words, prefer `partialMock(StubFoo.class)` over `when().thenReturn()` statements in setUp().
 =||= Hey

Thanks so much for taking the time to implement this. Here's some feedback about your design decisions:
1. I respect the arguments for avoiding reusing 'spy' nomenclature. For good or bad, Mockito 'spies' are called 'partial mocks'. This pattern is also used in other mocking libraries, like spock. IMHO, adding a separate method may confuse users.
2. I think that the message that hand stubs are recommended for stubbing that typically ends up in setUp() method is a bit too strong. From my experience, rolling out hand stubs typically indicates design smell - there's too much 'ask' style interactions, and too little 'tell' style interactions. The latter better isolate responsibilities leading to cleaner design.

Now let's look into the code :)
 =||= Oh right, I reviewed the codes :)

One thing that stands out is that partial mock seems to be driving the API and the implementation towards a new kind of mock. Ideally, we would like to avoid it. In Mockito, we're trying to generalize more and avoid creation of new kinds of mocks.

To accept the PR, we would like to simplify the API and implementation. API:
1. Mockito.spy(Foo.class, Object ... constructorArgs)
2. withSettings().constructorArgs(Object ... args)
3. withSettings().outerInstance(Object object)

1) delegates to: mock(Foo.class, withSettings().constructorArgs(Object ... constructorArgs).defaultAnswer(CALLS_REAL_METHODS)
Also, this should work with regular mocks, too. E.g. if someone specifies the constructorArgs (we can call it differently, e.g. 'usesConstructor', etc.) then the instance is created via the constructor, instead of by using the Objenesis.

This can be implemented incrementally. For example:
1. add 'constructorArgs/usesConstructor' support
2. add 'outerInstance/enclosingInstance' support
3. add spy method

This is great stuff. Thanks for this PR. Sorry I cannot merge it in this form just yet. Perhaps I'll add some code to get this started.
 =||= Thanks for spending the time reviewing this code!

I was thinking that I cannot make spy work while also keeping final methods in fakes work.

But reading your reply a few times convinced me that I misunderstood how spies work. And it's actually pretty trivial to implement. 

So, in short. I was wrong. `spy(Class)` tastes sweet!

What do you think of the new revision?
- Mockito.spy(Foo.class, Object ... constructorArgs)

Again. I don't feel we need to support arbitrary constructor args. It's not statically type safe or refactoring friendly; there are ambiguity issues w.r.t constructor overloads . And lastly while 0-constructor-arg abstract classes without state can be fine (like, AbstractList), abstract classes with state feels more often a design smell.
- withSettings().outerInstance(Object object)

Hmm. Kinda feel that the API of `spy(outer, InnerClass.class)` reads more intuitive: the outer object is the qualifier for the inner class, just as how we say `outer.new InnerClass()`.

Also, unlike other mock settings that apply to every method that accepts it, outerInstance() is only meaningful to `spy(). mock(Foo.class, settings.outerInstance(outer))` would be meaningless.
 =||= on my radar, I'll reply tomorrow ;)

On Sat, Oct 18, 2014 at 1:31 AM, fluentfuture notifications@github.com
wrote:

> Thanks for spending the time reviewing this code!
> 
> I was thinking that I cannot make spy work while also keeping final
> methods in fakes work.
> 
> But reading your reply a few times convinced me that I misunderstood how
> spies work. And it's actually pretty trivial to implement.
> 
> So, in short. I was wrong. I like spy()!
> 
> What do you think of the new revision?
> 
> About the 3 items in your suggested API:
> 1. Mockito.spy(Foo.class, Object ... constructorArgs)
> 
> Again. I don't feel we need to support arbitrary constructor args. It's
> not type safe. I fear that adding this support would encourage bad-designed
> abstract classes. If 0-constructor-arg abstract classes without state are
> fine (like, AbstractList), abstract classes with state feel almost always a
> smell.
> 1. withSettings().outerInstance(Object object)
> 
> Hmm. Kinda feel that the API of spy(outer, InnerClass.class) reads more
> intuitive: the outer object is the qualifier for the inner class, just as
> how we say ""outer.new InnerClass()"". Agree? It's your call. If you prefer
> outerInstance(), I'll change.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/106#issuecomment-59589093.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= > Again. I don't feel we need to support arbitrary constructor args. It's not statically type safe or refactoring friendly; there are ambiguity issues w.r.t constructor overloads . And lastly while 0-constructor-arg abstract classes without state can be fine (like, AbstractList), abstract classes with state feels more often a design smell.

I agree with everything you wrote. Thing is, we cannot really objectively say that stateful abstract classes are ok only when have 0-arg constructor. Consequently, we cannot restrict the API based on this assumption. Users will come up with use case for argumented abstract classes and it will be hard to defend it. Also, Mockito needs to balance out the 'toolkit' approach (unopinionated) with 'framework' approach (opinionated). To describe this further: from the standpoint of API design we _can_ declare that in our opinion mocking abstract classes is a design smell and we don't want to support it officially (we could however, open some extension points for users to implement it 'unofficially'). But we cannot really say that _some_ abstract classes are ok to mock and some not. At least, this is my view on the subject and I respect if you have a different POV.

IMHO, We don't have to provide constructor args in the first iteration but we should plan for it API-wise so that adding this feature later does not incur any deprecation or API awkwardness. We should also avoid documenting that we are not planning to do the constructor args because we believe it is a smell. However, we can document that _typically_ mocking abstract classes hints at design smell, etc.

> Hmm. Kinda feel that the API of spy(outer, InnerClass.class) reads more intuitive

spy() method and the withSettings() method are not ""alternative"" implementations :) All spy() methods need to delegate to a mock() method that has specific, spy-related withSettings(). Other words: every possible kind of mock can be created using this entry point of the API: http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.MockSettings) Think about the spy() method (and overloaded mock() methods) as a convenience methods / syntax sugar over the main mock creation entry point.

> spy(outer, InnerClass.class)

I'd rather avoid overloaded spy() method that uses outer instance initially. It feels that mocking inner abstract classes is somewhat an edge case (arguably). We could provide an API for this via withSettings() though. From my objective standpoint it feels that it's more important to support constructor arguments than to support mocking inner classes (e.g. I would dare to say that there are more use cases that support the former feature).

I haven't yet looked in the code :)
 =||= I reviewed the code. Please don't get disheartened by the amount of review items :) I'm enjoying this conversation immensely and I'm really happy that you will contribute it! It will be a great feature in Mockito.

I've done some refactorings in Mockito regarding mock initialization and I will push it now. Merging your stuff will be hard and I'm sorry for this. I hope that the code after the refactorings will be easier for you to implement the feature ;)
 =||= Pushed. Take a look at org.mockito.internal.creation.cglib.ClassImposterizerTest#shouldCreateClassByConstructor
 =||= Thanks for explaining the rationale so clearly and patiently! Some further clarifications below in hope that I could sell the idea better. :)

I'll work on the refactoring and merging later.

> Thing is, we cannot really objectively say that stateful abstract classes are ok only when have 0-arg constructor. Consequently, we cannot restrict the API based on this assumption. Users will come up with use case for argumented abstract classes and it will be hard to defend it. Also, Mockito needs to balance out the 'toolkit' approach (unopinionated) with 'framework' approach (opinionated). To describe this further: from the standpoint of API design we can declare that in our opinion mocking abstract classes is a design smell and we don't want to support it officially (we could however, open some extension points for users to implement it 'unofficially'). But we cannot really say that some abstract classes are ok to mock and some not. At least, this is my view on the subject and I respect if you have a different POV.

Agreed. The ""opinion"" is but one reason though. Another one is that it's not type safe, and would pose a difficulty to tools like IDE later when someone is trying to find references to a constructor.

While Mockito doesn't need to be an opinionated framework, I think it's fair to say that Mockito can choose to only implement a feature that it does better than alternatives.

I imagine if someday someone wants to spy a class with constructor args, my suggestion would be to create a simple subclass wrapper:

```
@Mock private Collaborator collaborator;
@Spy private MockFoo foo;
abstract class MockFoo extends AbstractFoo {
  MockFoo() {
    super(collaborator, blah);
  }
}
```

This way everything is still nicely compiler and tool friendly. One major difference between Mockito/EasyMock and jMock (at least the earlier versions) is that they are type safe. Supporting arbitrary constructor args using Object[] takes a step away from the type safety.

There may still be the 20% use case where the constructor args have to be provided dynamically so the inner class approach won't work. I wasn't sure if Mockito should charge itself to support this kind of rare edge cases. Starting from a minimalist perspective, I went with ""when in doubt, leave it out"".

I'm certainly biased. If that doesn't make the case. I respect your decision. :)

> I'd rather avoid overloaded spy() method that uses outer instance initially. It feels that mocking inner abstract classes is somewhat an edge case (arguably). We could provide an API for this via withSettings() though. From my objective standpoint it feels that it's more important to support constructor arguments than to support mocking inner classes (e.g. I would dare to say that there are more use cases that support the former feature).

Regarding the pros/cons between constructor-args vs. inner class. My view is quite different. I see ""constructor-args"" as a crude half-baked product that no one except perhaps framework builders should ever use. There are even ambiguity problems we have to solve. What do we do for the following case?

```
abstract class WithParams {
  WithParams(Comparable, Runnable) {}
  WithParams(Serializable, Enum) {}
}

Comparable comparable = enum1;
Runnable runnable = enumThatImplementsRunnable;
spy(WithParams.class, comparable, runnable);
```

And what about generics?

```
abstract class WithParams {
  WithParams(Set<String>) {}
  WithParams(Iterable<Foo>) {}
}

spy(WithParams.class, fooSet);
```

Thanks to erasure, Mockito will have no way to figure out that fooSet's static type is `Set<Foo>`, so it'll still be puzzled even though from user's perspective there is no ambiguity whatsoever.

In both cases, the problem is that Mockito has no access to the declared ""static"" type that the compiler uses and users typically think in terms of. Mockito has access to the runtime types, which, if relied upon, can sometimes cause surprising behavior.

On the other hand, inner class is type safe, tool friendly, no surprise; constructor-args isn't.
We can use inner class to solve most use cases that seemingly need constructor-args.

Perhaps we can study a few use cases and see how the two contemplated APIs each pans out?

Re: withSettings(): I respect your preference for what the API looks like. So I'll just make sure my concerns are heard.

I have no concern passing these extra state through the settings object internally. The concern is with the overly wide API surface added if we allow users to do:

```
spy(anObject, withSettings().withEnclosingInstance(instance));
```

or.

```
mock(Foo.class, withSettings().withEnclosingInstance(...));
```

None of the above make logical sense so could turn out to be surprising to some users. If enclosingInstance is only logical to the spy(Class) method alone, do we want to make it possible to (mis)use to all the other API methods when users hit autocomplete?

Also consider this a slippery slope argument. If the other mock/fake methods later gain their own extra parameters that only make sense to individual API methods (as opposed to the cross-cutting settings today in MockSettings), do we cram them all into the MockSettings object so that users would have to bookmark in their mind things like: ""setting 1 should only be used for API 1 and API 2 but not API 3 or API4; setting 2 is good for API 2 only; setting 3 is for API 2 and API 5"".

It's contrived. But I feel by adding enclosingInstance to MockSettings, it's the first step toward that direction.
 =||= I fear my long reply did a poor job advertising the inner class support. Let me try in a mock FAQ style.

#### Why do I ever want to test a non-static inner class? Isn't it an implementation detail?

No. You don't.

The inner class support isn't really for _testing_ your production inner classes. Rather, the idea is to reduce most abstract classes with constructor parameters to an inner class **enclosed by the test**.

Let's look at an example. How do you test the following class?

```
abstract class MyAbstractClass {
  MyAbstractClass(Collaborator collaborator) {...}

  abstract void doSomething();
}
```

The constructor has a parameter which is a collaborator. You can `spy` it by creating an inner class in the test as such:

```
public class MyAbstractClassTest {

  @Mock private Collaborator mockCollaborator;
  @Spy private MockAbstractClass foo;

  public void test1() {
    ...
    verify(foo).doSomething();
  }

  abstract class MockAbstractClass extends MyAbstractClass {
    MockAbstractClass() {
      super(mockCollaborator);
    }
  }
}
```

#### Why inner class? Why not just pass the constructor arguments directly?

A few problems with that approach:
1. It's not statically type safe. We could have provided `spy(Class, Object... constructorArgs)`. But then you lose static type checking. And when someone tries to figure out ""who are the callers?"". The spy() call evades that kind of static analysis and makes it harder to understand the bigger picture of the code.
2. Overload ambiguities make it difficult to implement in a least astonishment way. Consider the following class:

```
abstract class MyAbstractClass {
  MyAbstractClass(Iterable<User> users);
  MyAbstractClass(Set<String> userIds);
}
```

The following `spy` call would be ambiguous:

```
Set<User> users = ...;
MyAbstractClass my = spy(MyAbstractClass.class, users);
```

While both you and compiler know for sure `users` is a set of User, thanks to type erasure, Mockito only knows `users.getClass()`, which is Set. Is it an `Iterable<String>` or `Set<User>`? No idea.

And that's just one parameter.

#### Sure. But you can throw an exception in case of ambiguity. I'm not sure how often people create potentially ambiguous overloads.

It can happen in practice that at day 1 there is only one constructor and then later on more are added. Despite the best practice of avoiding potentially ambiguous overloads, it occasionally happens, some even for good reasons. For example:

```
MyThing(Iterable<User> whenSizeIsUnknown) {...}
MyThing(Collection<User> whenSizeIsKnown) {...}
```

Seems harmless, right?

So overall, we figured that it's better (and easy enough with inner class) for the programmer to explicitly tell us which constructor to use and which parameters and types to pass to it, than Mockito making _mostly-right-but-sometimes-surprising_ guesses.
Like:

```
public class TheTest {
  private Set<User> users;
  @Spy MockClass sut;
  ...

  abstract class MockClass extends MyAbstractClass {
    MockClass() {
      super(users);  // no amgibuity
    }
  }
}
```
 =||= Hey,

I admire your energy in selling the idea :). More feedback:
- Majority of users (that I've seen) take advantage of @InjectMocks which already removes the type safety regarding the constructors.
- We already have to deal with constructor selection for the @InjectMocks
- Personally I find the choice between statically typed inner abstract classes VS duck-typed constructor parameters the matter of taste. Myself, I would choose test clarity and reduced boilerplate over better refactoring/searchability support for constructors.
- I like this little pattern of yours. I think it is cool. Yet, I'm not prepared to shape Mockito API to force this pattern. It seems too opinionated. I'd rather give choice and have Mockito support both approaches.

We don't have to support constructor args. We can wait for community feedback. Perhaps nobody asks for it and everybody is happy :)

Let's conclude on the api:

```
spy(Foo.class)
mock(Foo.class, withSettings().innerOf(someObject).usingConstructor())
//options: ""enclosingInstance"", ""constructor"", ""constructorArgs""
```

Makes sense? :)
 =||= > We already have to deal with constructor selection for the @InjectMocks

It's not very comparable, right? In `@InjectMocks`, all the static types of the fields and the constructor signature are available to Mockito. If the constructor's signature is `Foo(Set<User>)`, Mockito has full information of the signature. So there isn't any ambiguity problem.

When we do support duck typing, my suggestion would be something similar to EasyMock's ConstructorArgs (http://easymock.org/api/org/easymock/ConstructorArgs.html), which explicitly passes in the Constructor object to avoid constructor selection problem. It's not as handy, yes, but as you said, most users use `@InjectMocks` or `@Spy` anyway.

But yes, let's leave constructor-args for future iterations.

For now, the remaining gaps between use cases I'm having in mind and the suggested syntax:
1. What if Foo's constructor is private and cglib cannot call it? My current implementation skips calling such constructor, as a way for users to suppress constructor when it does undesirable things. But if it does skip, `useConstructor()` would seem imprecise. `useNonPrivateConstructor()`? A bit mouthful, no?
2. In the current implementation, `spy(ClassWithParameteredConstructor.class)` skips constructor, should it throw exception instead?
3. In the current implementation, spy(InnerClass.class) throws exception, are you okay with that?

Thanks!
 =||= Okay. I merged with upstream. I believe I've also implemented the suggested changes.

Please take another look.

Thanks!
 =||= [![Coverage Status](https://coveralls.io/builds/1377760/badge)](https://coveralls.io/builds/1377760)

Changes Unknown when pulling **e91eac2cb1eb620624dd6a251eeaf2904f79e113 on fluentfuture:partial** into *\* on mockito:master**.
 =||= [![Coverage Status](https://coveralls.io/builds/1377862/badge)](https://coveralls.io/builds/1377862)

Changes Unknown when pulling **fd861ec940adae96b21310fa4e25d99ad2581ed0 on fluentfuture:partial** into *\* on mockito:master**.
 =||= This is looking good. I should merge soon. 

> a. What if Foo's constructor is private and cglib cannot call it? My current implementation skips calling such constructor, as a way for users to suppress constructor when it does undesirable things.

If the users configures 'useConstructor' I think that mockito should attempt to find matching constructor. If it cannot be found or used, we I'd throw a meaningful exception.

> b. In the current implementation, spy(ClassWithParameteredConstructor.class) skips constructor, should it throw exception instead?

I think we would apply the same strategy as for a)

> c. In the current implementation, spy(InnerClass.class) throws exception, are you okay with that?

Yes, so long the exception message is clear and informs how to resolve the problem, etc.
 =||= > Private constructor

There is a use case we are missing if we throw on private constructor: sometimes you may want to fake a class that didn't expose its constructor, by exposing a static factory instead, or, if the constructor does bad things (like, connect to database).

If we throw on private constructor, there would be absolutely no way to fake it, unless we create another way for user to say ""fake it, but don't call constructor"".

It's weird if the user called `useConstructor()` yet it ends up not using constructor. But if user only called `spy(Foo.class)`, I think it's not weird if we skip private constructor.

What do you think of `useConstructorIfPossible()`?
 =||= Sorry I hadn't realize Travis wasn't happy with the broken javadoc link.

Fixed now.

Let me know what you think of the current design.

Thanks!
 =||= Hey, I'll allocate some time to it soon. Needed to finish off some
automation work first. You've started on a core feature so it's lagging a
bit.

Cheers!

On Wed, Nov 5, 2014 at 4:29 AM, fluentfuture notifications@github.com
wrote:

> Sorry I hadn't realize Travis wasn't happy with the broken javadoc link.
> 
> Fixed now.
> 
> Let me know what you think of the current design.
> 
> Thanks!
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/106#issuecomment-61754985.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= I've merged this PR in slightly changed form. Let me know if you want to improve it one way or another :)
 =||= Awesome! Thanks.

Do you like me to add the `@Spy AbstractClass` support, or you'll just do it?
 =||= Do you mean changing the @Spy annotation so that it out-of-the box works with AbstractClasses? For sure :) Let's do separate PR/ticket for it.

BTW. I'd like to mention you in the release notes by name. Can you reveal yourself (or configure your github account :)
 =||= Hi, thanks for taking over and cleaning it up!

I have a question about the current implementation.

If I'm reading the code correctly, `spy(AbstractClass.class)` can construct an instance using the proxy class's constructor.

But it should have mocked the abstract methods rather than CALL_REAL_METHOD on them.

The following test shows what I expect to happen but fails in the current master branch:

```
    static abstract class AbstractThing {
        abstract String message();
        String fullMessage() {
            return ""Hi "" + message();
        }
    }

    @Test
    public void abstract_method() {
        AbstractThing thing = Mockito.spy(AbstractThing.class);
        assertEquals(""Hi null"", thing.fullMessage());
    }
```

In summary, abstract methods by default should use the standard Mockito stubbing. Only the real non-abstract methods are by default invoked. The PartialMockAnswer class in this PR was supposed to implement this logic.
 =||= Good point! I missed that ;) Do you want to fix it in a separate PR?
 =||= I have a design question to run by you before creating the PR.

Do you think it makes sense to change CALLS_REAL_METHOD directly? It seems useless for it to call abstract methods only to throw an AbstractMethodError.

So perhaps CALLS_REAL_METHOD can be made a bit smarter to delegate to RETURNS_DEFAULTS when it knows it's pointless to call abstract method?

I guess then spy() doesn't need to change.
 =||= I think this is a good idea! I'm curious, what's the current behavior when CALLS_REAL_METHOD is used for abstract method? What's the behavior when someone tries to mock an interface and sets the default answer to be CALLS_REAL_METHOD?

Thanks for your insights!
 =||= Here's the error I just got from using CALLS_REAL_METHOD on interface methods:

```
org.mockito.exceptions.base.MockitoException: 
Cannot call abstract real method on java object!
Calling real methods is only possible when mocking non abstract method.
  //correct example:
  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();
```
 =||= Cool. We can make CALLS_REAL_METHOD smarter I think. Let's also update it's
documentation.

Thanks a lot for your help!!!!

On Sat, Nov 22, 2014 at 5:31 PM, Ben Yu notifications@github.com wrote:

> Here's the error I just got from sing CALLS_REAL_METHOD on interface
> methods:
> 
> org.mockito.exceptions.base.MockitoException:
> Cannot call abstract real method on java object!
> Calling real methods is only possible when mocking non abstract method.
>   //correct example:
>   when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/106#issuecomment-64085824.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= Sorry, Szczepan. Two more questions while implementing `@Spy`.

I think we agreed that for this code `@Spy AbstractClass foo`, we'll use `Mockito.spy(AbstractClass.class)`.

The question is about `@Spy NonAbstractClass foo`. 

Currently, `@Spy` fails on interface or abstract classes. For concrete classes, it first tries to instantiate an instance by calling no-arg constructor of it, and then spy on that instance. 

Now with support for abstract class, there is a chance that we could handle all 3 cases consistently: just do `Mockito.spy(TheType.class)`. This approach feels appealing to me because there is less special casing and is easier to understand.

Which approach would you prefer the `@Spy` annotation to do?
 =||= Your suggestion makes perfect sense (e.g. simplify, use new feature). BTW.
can you write such emails to the dev list?

On Sun, Nov 23, 2014 at 6:11 AM, Ben Yu notifications@github.com wrote:

> Sorry, Szczepan. Two more questions while implementing @Spy.
> 
> I think we agreed that for this code @Spy AbstractClass foo, we'll use
> Mockito.spy(AbstractClass.class).
> 
> The question is about @Spy NonAbstractClass foo.
> 
> Currently, @Spy fails on interface or abstract classes. For concrete
> classes, it first tries to instantiate an instance by calling no-arg
> constructor of it, and then spy on that instance.
> 
> Now with support for abstract class, there is a chance that we could
> handle all 3 cases consistently: just do Mockito.spy(TheType.class). This
> approach feels appealing to me because there is less special casing and is
> easier to understand.
> 
> Which approach would you prefer the @Spy annotation to do?
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/106#issuecomment-64107128.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= ",0
1268,1262,Improve documentation about partial mocks and doReturn() style of stubbing,"I think the documentation here is wrong:
https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/Mockito.java#L1646 

I believe the doReturn() syntax should be used there instead. At least when I do that it works but when I do the when(myFoo.myMethod()).thenReturn() that line itself runs the real impl of myMethod.
","Fixed here: #1268 =||= Thanks!
On Fri, Dec 15, 2017 at 7:28 AM Serge Bishyr <notifications@github.com>
wrote:

> Fixed here: #1268 <https://github.com/mockito/mockito/pull/1268>
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1262#issuecomment-352033630>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AgI9iOvIZKCGxxM1g7uKBfkAxIkTuwc-ks5tApAzgaJpZM4Qiwjq>
> .
>
 =||= ",0
1270,1130,Mockito should annotate when() methods with a custom annotation @CheckReturnValue,"Static code checkers like error-Prone and FindBugs will help detecting invalid usage of Mockito in single-call situations if Mockito source code were annotated with @CheckReturnValue.

See:
* https://github.com/joel-costigliola/assertj-core/issues/157
* http://errorprone.info/bugpattern/CheckReturnValue
* https://github.com/joel-costigliola/assertj-core/pull/695
* https://github.com/joel-costigliola/assertj-core/blob/master/src/main/java/org/assertj/core/util/CheckReturnValue.java

Note like for AssertJ, any annotation with name should do, no need to depend on a specific library with  @CheckReturnValue.",That seems fine to me. Please submit a pull request :smile:  =||= ,0
1272,792,New lenient() strictness setting available at mock and at stubbing level,"## Problems

Overview of strictness: #769

1. It is not possible to have any common stubbing when using Strictness.STRICT_STUBS. Strict stubs is very useful and it is most likely the future default for Mockito 3. Common stubbing typically is a part of ""before"" method or a test utility class that generates mocks.

```java
public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);

@Before public void before() {
  //a) common stubbing, needed for most test methods
  when(mock.foo()).thenReturn(""bar"");  
}
```

2. API caveats:

```java
@Test public void demo() {
  //b) not possible to stub the same method using 'when', with different args:
  when(mock.foo(1)).thenReturn(1);
  when(mock.foo(2)).thenReturn(2); // <- will throw PotentialStubbingProblem

  //c) code under test cannot use stubbed call with different argument (sometimes we need it)
  when(mock.foo(1)).thenReturn(1);
  mock.foo(2); // <- will throw PotentialStubbingProblem whether we need it or not
}
```

## Suggested solution

New public API overview:

```java
@Test public void demo() {
  //1. New method on MockSettings interface:
  Foo mock = Mockito.mock(Foo.class, withSettings().lenient());

  //2. New method on Mockito class:
  Mockito.lenient().when(mock.foo(1)).thenReturn(1);
  Mockito.lenient().doReturn(1).when(mock).foo(1);
}
```

Details:
 - Why 2 new public methods? Sometimes common stubbing has a form of one or few stubbings in ""before"" method - it's best to configure leniency per stubbing. Sometimes a mock object has many common stubbings (described in detail in the ticket thread below) - it's best to configure leniency per mock.

## Examples

1. Common stubbing

```java
public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);
@Mock(lenient = true) Foo mock;

@Before public void before() {
  //a) common stubbing, needed for most test methods
  when(mock.foo()).thenReturn(""bar"");  
}
```

2. API caveats:

```java
@Test public void demo() {
  //b) not possible to stub the same method using 'when', with different args:
  lenient().when(mock.foo(1)).thenReturn(1);
  when(mock.foo(2)).thenReturn(2); // <- works!

  //c) code under test cannot use stubbed call with different argument (sometimes we need it)
  lenient().when(mock.foo(1)).thenReturn(1);
  mock.foo(2); // <- works!
}
```

## Original report

The new UnnecessaryStubbingException logic is great. However, it is sometimes useful to disable this detection for specific methods. Could it be possible to add an annotation that says ""unnecessary stubs should not be detected in this method""?

This would also make it easier to migrate from Mockito 1.* to Mockito 2. This is the case in the project I am currently working at, where we have created some utility methods that creates a mock and configures it to fit most of our use cases. As we use this method at many places, where different configuration is needed, it will cause a lot of unnecessary stubbing. Thus, we would like to keep this method out of unneccessary stubbing-check, while doing this check on the rest of the code base.","Thank you very much for this feedback!

Do you use the silent JUnit Runner currently to avoid the exception in your scenario?

Your feedback and recent code review from @bric3 made me think about enabling/disabling stubbing strictness per method or per class using annotations. For example (brainstorming):

```java
@Mockito(strictStubs = true)
public class SomeTest {

  @Test
  @Mockito(strictStubs = false)
  public void someTestMethod() {

  }
}
``` =||= Thanks for following up on this!

Yes, we currently use the silent runner, which works fine, but of course lacks the stubbing checking that we would like to have on the rest of the methods.

Annotations for this sounds to me like a good solution to the problem. It would be really great if this annotation could also be used on helper methods, such as in our scenario:
```

@Mockito(strictStubs = true)
public class SomeTest {

@Test
public void someTestMethod() {
    Code code = createCode(""A"");
}

@Mockito(strictStubs=false)
 private Code createCode(String codetype) {
    Code code = mock(Code.class);
    doReturn(codetype).when(code).getCodetype(); // Not always, but in most cases, invoked
 }
}

```
 =||= Thanks for the suggestions! My feedback / questions:

1. Is there a reason why you use the runner and not Mockito JUnit rule?
2. The annotation API would not work on the helper methods, only on the test methods. It's because the rule only captures and provides the test method to the implementation. =||= Thanks for your feedback!

1. No, not really. We have not really looked at the difference nor taken a conscious choice on this.
2. Oh, I see. That means that it would be hard to use annotations to do this the way I was hoping was possible. Ideally, it would be great if we could enable unnecessary stubbing in general, but configure it so a developer could call the createCode method without having to mind the unnecessary stubbing here. Or perhaps by setting some properties on the JUnitRunner? So that createCode could be something like

    ```java
    private Code createCode(String codetype) {
       jUnitRunner.DISABLE_STUBBING_CHECK();
       Code code = mock(Code.class);
       doReturn(codetype).when(code).getCodetype(); // Not always, but in most cases, invoked
       jUnitRunner.ENABLE_STUBBING_CHECK();
    }
    ```

I am not that into the Mockito codebase, but I would guess that this could require quite some rewrite?

 (And it also indicates that our usage of helper methods are probably not a smart path to follow...) =||= My point on helper method or helper object for mocks is usually that the model shows mock anti pattern. Or that the granularity of the test is not narrow enough. Usually that means that a concrete object should be **built** instead, not a mock.

The idea may be intersting though, probably not in mockito 2. In mockito 3 (JDK8) maybe we could introduce apis like this :

```java
mockitoRule.inConfiguration()
                     .strictness(Strictness.LENIENT)
                     .stub(() -> { 
                           doReturn(codetype).when(code).getCodetype(); // possible stub
                           // ...
                     });
```

_The above snippet is mostly exploring idea for this kind of API as I don't have these kind of needs at this time, it may be just wrong in many aspects._ =||= See #840 - I created a proposal for solving this use case for JUnit rules =||= As an alternative solution, could you use the MockSettings? e.g. something like ..

```
Code code = mock(Code.class, withSettings().noUnnecssaryStubbing());
``` =||= I also found a use case:

I'm mocking ZK which uses a lot of map-like structures which are exposed via accessors (`getAttributes()`, `getAttribute(String)`, `getAttribute(String, boolean)`, `setAttribute()`, ...).

In my test setup, I create a map and I'm using `thenAnswer()` and `doAnswer()` to link the accessor methods to my test map. The code then looks like this:

```
    private Map<String, Object> desktopAttributes = new LinkedHashMap<>();
...
            desktopAttributes.put(ATTR_EVENT_QUEUES, desktopEventQueues);

            MockDesktop desktop = mock(MockDesktop.class);
            when(desktop.getAttributes()).thenReturn(desktopAttributes);
            when(desktop.getAttribute(ArgumentMatchers.anyString()))
            .thenAnswer(answer -> {
                String name = answer.getArgument(0);
                Object value = desktopAttributes.get(name);
                return value;
            });
            when(desktop.getAttribute(ArgumentMatchers.anyString(), Mockito.anyBoolean()))
            .thenAnswer(answer -> {
                String name = answer.getArgument(0);
                Object value = desktopAttributes.get(name);
                return value;
            });
            doAnswer(answer -> {
                String name = answer.getArgument(0);
                Object value = answer.getArgument(1);
                desktopAttributes.put(name, value);
                return null;
            }).when(desktop).setAttribute(Mockito.anyString(), Mockito.any());
            doAnswer(answer -> {
                String name = answer.getArgument(0);
                Object value = answer.getArgument(1);
                desktopAttributes.put(name, value);
                return null;
            }).when(desktop).setAttribute(Mockito.anyString(), Mockito.any(), Mockito.anyBoolean());
            when(desktop.hasAttribute(Mockito.anyString()))
            .thenAnswer(answer -> {
                String name = answer.getArgument(0);
                return desktopAttributes.containsKey(name);
            });
            when(desktop.hasAttribute(Mockito.anyString(), Mockito.anyBoolean()))
            .thenAnswer(answer -> {
                String name = answer.getArgument(0);
                return desktopAttributes.containsKey(name);
            });
```

I need this code block three times (desktop attribute map, session attributes, servlet context attributes). I prefer mocking over mock objects since the interfaces have hundreds of methods.

I have put this code into a shared JUnit rule. It's lazy but it's also generic: Since the rule doesn't know what parts of ZK the test will call, it can't tell which accessor methods will be needed. But I still need to know when a method is called which wasn't mocked.

Therefore, I need a way to tell Mockito ""there might be unused stubs in the following code block but that's ok since it's shared by many tests"". An annotation on the test won't work since the code is in a JUnit rule. I could pass the MockitoRule to my rule, so this approach would work:

    mockitoRule.lenientStubbing(() -> { ... }); =||= @digulla, thank you for reporting! Some feedback:

- The code looks really hard to read (many lines of mock interactions). I suggest to rethink testing strategy, refactor the code under test so that it is easier to test, or roll out hand mocks.
- Given above, we cannot consider it as a legit use case. We want to avoid implementing features / API for code that should be cleaned up / refactored for simplicity and testability.
- Given that #840 solves this use case ('strictness' method on the rule object), I'm closing this ticket.

Ah, it was interesting to refresh my memory about this ticket :) Hope that helps! =||= @mockitoguy  Sorry, that doesn't help at all.

With ~200K on StackOverflow, that was the most simple solution I could come up with. You're welcome to show me a better solution.

The testing strategy is sound. It doesn't break easily or unexpectedly and is easy to understand for new members of the team. I could copy only the necessary lines to new tests but that would mean I would be the only one who can write new tests. Also: Violates DRY.

Refactoring is not possible. ZK is a UI framework with a huge code base and many projects use it. Asking to change the API is like asking to ""fix"" the Java Collections API: Understandable, maybe even reasonable but unrealistic.

Hand mocks would mean I would have to write about a lot of useless code which violates your own rule to keep tests simple.

So I'm between a rock and a hard place: You're right for open source projects which no one uses or green field commercial projects. For existing commercial projects that I can't move, it's not helpful. They have ugly and unmodifiable APIs, so I have to move the only place where I have influence: That's the tests.

So for now, I have to disable a good feature of Mockito and can no longer make sure that my tests stay clean. That really sucks. =||= Thank you for describing your context! Let me think about this and I'll get back. =||= I guess my use case is ""I'm writing a mocking framework for some commercial API which helps other developers to write tests."" That means I'll always overmock. In my case, I have to mock several Map-like APIs which are exposed in several beans without a common interface (just like the attribute maps in J2EE ServletContext and ServletRequest and the headers in ServletResponse). =||= @digulla that pretty much matches my use case too. IMHO a good solution would be to be able to specify ‘Silent’ at mocked object level rather that the test class level.  =||= I like the idea of adding new public API for this use case.

@digulla, with my earlier reply, I did not intend to depreciate your efforts in getting clean tests for your entire team. It’s great that you’re pushing for this!

The use case you describe could be solved more cleanly with hand stubs. Sometimes simpler code is actually more code :) What do you think about this idea:
 - noop implementation of the 3rd party interface. Generated automatically with IDE, cheap to maintain regardless of amount of methods because they are all noop. Low to zero cognitive overhead for the team.
 - hand stub implementation, extends the noop implementation. Tailored for what exactly the tests need.

Coming back to Mockito for this use case. I bet that our users would disable strictness per entire test, rather than build hand stubs (even if hand stubs would be a better solution). Disabling strictness per entire test nullifies strictness benefits. To provide best dev experience, Mockito should honor this use case and offer a better API.

There are 2 main alternatives:

1) strictness per mock, as suggested

```java
mock(Foo.class, withSettings().strictness(Strictness.LENIENT));
mock(Foo.class, withSettings().lenient()); //alias
```

2) strictness per stubbing, for example:

```java
lenient().when(mock.foo()).thenReturn(“boo”);
lenient().doReturn(“boo”).when(mock).foo();
```

Any feedback?

Thank you guys for feedback and for pushing us to reconsider. We're trying to keep Mockito API slim and avoid solving use cases better solved by refactoring / cleanup the code. =||= I did wonder about something like ...

```
@Mock (strictness= Strictness.LENIENT) 
private Foo mockFoo;
```

as well, but I wonder if that syntax would over-encourage people to use the feature; IME I think the sort of test frameworks, fixtures etc. where I see this to be most useful probably use the mock(Foo.class) mechanism for instantiating mocks.  =||= @mockitoguy 

>There are 2 main alternatives:

I see a third one. As discussed in the JUnit 5 PR (#1221) and the [mockito google group](https://groups.google.com/forum/#!topic/mockito/R1L1aG2RgBQ) I would like to propose an annotation base approach that can be applied also at test-class and test-method level. This keeps the API consistent and slim (at least when JUnit5 is used).

```
@Mock
@Strictness(LENIENT)
Foo mock;
``` =||= @ChristianSchwarz, you're right! Sorry for discounting the annotation option. =||= I plan to tidy up this ticket in the next few days so that it documents the use case, the implementation options and the desired implementation.

@ChristianSchwarz, strictness per method is not an ideal solution for the use case described in this ticket:
 1. every time someone uses shared stub object, he needs to remember to use lenient strictness on the method level
 2. method level strictness turns off useful stubbing validation for all mocks in the method, rather than only for the mocks that really need it.
 3. it does not communicate the intent well. The reader of the test method does not know why lenient strictness is needed for method. This also can lead to cargo culting - developer copy paste-ing test methods along with strictness setting, without known why they need it.

I must admit that the @Strictness annotation does look handsome in the test :)

What do you think about option 1 and 2? Do we want to implement both? Perhaps we start with mock level annotation for now. It solves the use case very well and is not very controversial. =||= @mockitoguy 

> @ChristianSchwarz, strictness per method is not an ideal solution for the use case described in this ticket:

Thats why I proposed to use the `@Strictness` annotation at field level for this use-case too. 

The `@Strictness` annotation at field level would also fit into the annotation proposal for JUnit5.  This in return would lead to a clean single API, where strictness is defined at field, method and class level the same way using `@Strictness`.

> What do you think about option 1 and 2? 

I would prefer option 1 cause:
 * It feels consistent with other mock setting configurations
 * It allows to implement the annotation based proposal too
 * option 2 would add an other alias like API for stubbing, thats uncool

>Do we want to implement both? 

Option1 + `@Strictness` ? Yes!

>Perhaps we start with mock level annotation for now. It solves the use case very well and is not very controversial.

`@Mock` + `@Strictness(...)`  or `@Mock(strictness=...)` ? I would opt for `@Strictness(...)`  cause it allows more uses cases. =||= >That's why I proposed to use the @Strictness annotation at field level for this use-case too.

That's fair!

Let's discuss the 2 contention points:

1. It is awkward that some mock properties are configured as parameter of the existing @Mock annotation, while some other (Strictness) is a standalone annotation.
2. We need to support Strictness at mock level via imperative API, e.g. ""withSettings().lenient()"" method (or something like that). This is one of our principles of API development (which we should document :), annotations are ""syntax sugar"" - all Mockito features are available via imperative API. Given that we implement ""withSettings().lenient()"", why do we need @Strictness annotation at all? I'm pushing on this, because the only thing better than clean API is clean and simple API. The less methods, annotations, complexity - the better! =||= @mockitoguy  Re ""hand stubbed"": That doesn't work since Java doesn't allow multiple inheritance. I just pasted a small part of the actual test setup. My setup class can mock several aspects of the ZK API: Session and request attributes, event queues, view models, injection. What I end up with a mix of lenient and dedicated mocks.

With a hand stubbed approach, I would have to copy a lot of code from test to test. My goal is to have lenient mocks for unimportant parts like session attributes (code under test will complain when they are missing) but strict checking for things like events published (I really don't want to miss those).

The test can then say ""hey, wire up event publishing"" if they expect events. Without the setup, any code using events will just crash with NPE. With the setup, Mockito should complain when no events related code was executed to keep the tests clean (to avoid devs doing copy&paste of code they don't understand).

Re annotations: I don't think that the annotations are a good solution here. They are nice for code which needs to be migrated from old Mockito but for new code, they are too coarse for all my use cases.

On the other hand, I don't like the idea of having to add `withSettings().lenient()` in many places. It would be great if I could execute a bunch of stub calls in a single lenient code block. If that was possible, I'd opt for an annotation on the setup method which calls the `when()`/`doReturn()` but I don't think there is an easy way to implement this when the setup method is not inside the test class but in a JUnit `@Rule` implementation. =||= Thank you for reply! I'm still interested in your use case hence my further questions.

>With a hand stubbed approach, I would have to copy a lot of code from test to test. 

Why? Hand stub implementation should have all the common reusable code. In the test, you can just call ""mock.setupEventPublishing()"" or something like that.

>On the other hand, I don't like the idea of having to add withSettings().lenient() in many places. It would be great if I could execute a bunch of stub calls in a single lenient code block.

Provided that we add both: stubbing + mock level strictness setting, then you have 2 options:

1. Only add ""withSettings().lenient()"" at mock creation time, only for mocks that act as ""reusable business stubs"" (wasn't sure how to call them). When you write stubbings, you don't specify ""lenient()"".
2. For other cases, where you have a default stubbing reused in most of the test methods, you declare the default stubbing using ""lenient()"" method at the stubbing level.

Thoughts? =||= @mockitoguy Thanks. I feel that I don't have a completely clear picture, yet.

> Hand stub

So a base class with a lot of empty methods and then using spy() to overwrite them? That might work but I don't like spy() (had too many problems with that approach in the past).

It still feels like more effort than simply wire some map methods to API methods using `Answer`.

> 2 options

Option #1 is too coarse for me. With option #2, I would have to add 7 lines of code to the block in https://github.com/mockito/mockito/issues/792#issuecomment-344198135 and you were complaining that the code was already too complicated :-)

That's why I suggested to have an ""enable some options for a code"" block approach. In my case, I could then wrap the call to the `setupDesktopAttributes()` method with that. =||= >So a base class with a lot of empty methods and then using spy() to overwrite them?

Hand stub/mock is a class that is completely tailored for the business of your tests. Sometimes referred as ""test fixture code"", ""test utils"", ""test support classes"". Hand mocks don't use Mockito, not even spy(). Hand stub needs to be coded and maintained but it provides superior readability and usefulness because it is tailored to your domain.

>Option #1 is too coarse for me. With option #2, I would have to add 7 lines of code to the block

We could potentially provide a method like:

```java
Mockito.lenient(() -> { ... });
```

Not sure about this, though. It's a very different API than what we have so far. Per-mock + per-stubbing leniency feels like a happy medium: if repeated ""lenient()"" is a problem, you can configure it per the entire mock. Per-mock is coarse grained but on the other hand it is conventional and simple. Big ""lenient"" block might lead to weird test code, developers putting more code inside the block, the intent of the code getting obscured. =||= Updated the description with the problem statement and proposed API changes. Feedback before we start coding? =||= Update: work in progress in PR #1272.

Friendly ping for review of the design outlined in this ticket description! =||= I'm pondering the two API designs: `mock(..., withSettings().lenient())` and `lenient().when(...)`
I feel it would be better if the two were more similar.

Why not `when(..., withSettings().lenient())`? That way, the API would be more symmetric. When adding more settings, they would naturally flow into the existing code. But it would be hard to add options only for `mock()` (= problems can only be discovered at runtime).

What about  `mock(...).lenient()`? Or `lenient().mock(...)`? That would be the opposite approach to make the two APIs similar. Here, the chaining pattern can make sure that you can't use options that are illegal.

Also, this is shorter. I feel `withSettings()` adds a lot of visual bloat.

 =||= > I'm pondering the two API designs: mock(..., withSettings().lenient()) and lenient().when(...)
I feel it would be better if the two were more similar.

Yeah, possibly. We also want to have those new API methods consistent / similar with the existing API:
 - currently the way to configure mocks is: withSettings() or annotation
 - stubbing is inconsistent (when vs. doReturn, when vs. given) due to the API evolution and Java limitations. There is no concept of configuring a ""stubbing"" in Mockito API currently (assuming that declaring what happens when stubbed method is called is part of the stubbing, and not an operation of ""configuring stubbing"").

> Why not ```when(..., withSettings().lenient())?```

How would this play with doReturn syntax?

> What about ```mock(...).lenient()?``` Or ```lenient().mock(...)?```

The former is not possible because ```mock()``` returns the type we're mocking. The latter is interesting, problem is that it is inconsistent with how currently mocks are configured (withSettings()).



Thank you for thoughtful feedback! =||= How about a fluent API to mock several methods of a mock at once? That way, I could specify the lenient once at the top? =||= >How about a fluent API to mock several methods of a mock at once? That way, I could specify the lenient once at the top?

Can you write a comment with an example how it would look? This would help us make a decision. Sorry for late answer. Xmas break :) I made progress on the ticket, though! =||= I'm finalizing the implementation in #1272, it will be released within days. =||= ",0
1280,108,Clarify Spy vs Mock CALLS_REAL_METHODS,"I'd suggest adding a comment or side note in `[@InjectMocks](http://mockito.github.io/mockito/docs/current/org/mockito/InjectMocks.html)` to explain that when you want to inject real instances (and not mocks) you have the choice (unless I'm mistaken) between `[@Spy](http://mockito.github.io/mockito/docs/current/org/mockito/Spy.html)` and `[@Mock(answer = CALLS_REAL_METHODS)](http://mockito.github.io/mockito/docs/current/org/mockito/Mockito.html#CALLS_REAL_METHODS)` but the former is preferable, because...","Injecting real instances is not supported by the current injection mechanism. The things you mentioned are barely tricks. So instead of promoting tricks it would make more sense to support real type injection.

Also I find `@Mock(answer = CALLS_REAL_METHODS)` to be somewhat bad practice. I don't think we should expose that.
 =||= It's useful when DI are not possible.
 =||= Which doesn't mean it's a not a trick. Usually it means the production and/or test code need a serous refactoring. And if it's an external type that cannot be refactored then the following principle apply _Don't mock types you don't own!_

Anyway I'm totally against exposing this bad practice in the doc, as we want to develop a better code for our peers, for the next one working on the matter.
 =||= ",0
1290,1288,Duplicated word on #66,"Fixed a duplicated word on `#66` of the current file.


check list

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/2.x/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [ ] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [ ] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [ ] Mention `Fixes #<issue number>` in the description _if relevant_
 - [ ] At least one commit should mention `Fixes #<issue number>` _if relevant_
","# [Codecov](https://codecov.io/gh/mockito/mockito/pull/1288?src=pr&el=h1) Report
> Merging [#1288](https://codecov.io/gh/mockito/mockito/pull/1288?src=pr&el=desc) into [release/2.x](https://codecov.io/gh/mockito/mockito/commit/f2bec90dca3b3aa4f91e7da0b6888574177ce732?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/mockito/mockito/pull/1288/graphs/tree.svg?token=MX80sLdeR0&src=pr&height=150&width=650)](https://codecov.io/gh/mockito/mockito/pull/1288?src=pr&el=tree)

```diff
@@              Coverage Diff               @@
##             release/2.x    #1288   +/-   ##
==============================================
  Coverage          88.08%   88.08%           
  Complexity          2321     2321           
==============================================
  Files                284      284           
  Lines               5857     5857           
  Branches             702      702           
==============================================
  Hits                5159     5159           
  Misses               519      519           
  Partials             179      179
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/mockito/mockito/pull/1288?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/mockito/mockito/pull/1288?src=pr&el=footer). Last update [f2bec90...60dab69](https://codecov.io/gh/mockito/mockito/pull/1288?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= Hey @kant! Thank you for contribution. I've included the fix in my PR: #1290 (minus the link change that @TimvdLippe reported).

I will close this PR for now. =||= ",0
1301,1232,[JUnit5] MockitoSession#initMocks should support multiple test instances  ,"In order to support nested tests in JUnit5 (see #1221)  MockitoSession#initMocks should allow to pass more than one test instance or allow multiple calls on initMocks with different test instances.

In other words/code:

```
 Mockito.mockitoSession()
            .initMocks(rootTestInstance)
            .initMock(nestedTestInstance)
```

or 

```
 Mockito.mockitoSession()
            .initMocks(rootTestInstance,nestedTestInstance)
```




            ","Related discussion from #1221 
----

@TimvdLippe https://github.com/mockito/mockito/issues/445#issuecomment-357918936
> Regarding #1232: another option would be to not support nesting of test classes. I think we actively have to consider this option, given our public API was apparently coupled to the JUnit4 implementation and we can not ship breaking changes per our policy.


----

@marcphilipp https://github.com/mockito/mockito/issues/445#issuecomment-358106441
> Well, it's @Incubating so you could still change it, right? 😉
> 
> Besides, I think neither of the two proposals would break compatibility, would they? But then again, we should discuss this over at #1232. 🙂

----

@TimvdLippe https://github.com/mockito/mockito/issues/445#issuecomment-358286590
> Hm, looking at it again, it seems that the breaking change is actually in an internal API, namely TestFinishedEvent, which is created in MockitoSession. As such, I think we should be okay actually. I will do a proper investigation this weekend (hopefully, else next week) and update #1221. I hope you are okay with that @ChristianSchwarz ? Once that is done, I can more definitively say the impact on our API and whether we are risking a breaking change. I have good hopes now we might actually dodge that.


----

@marcphilipp https://github.com/mockito/mockito/issues/445#issuecomment-358407562
> `TestFinishedEvent.getTestClassInstance()` and `TestFinishedEvent.getTestMethodName()` are currently only used (twice) like this:
> 
> ```
> String testName = event.getTestClassInstance().getClass().getSimpleName() 
>                   + ""."" + event.getTestMethodName();
> ```
>
> Currently, `DefaultMockitoSession `always uses null for `TestFinishedEvent.getTestMethodName() `which strikes me as odd. I think it would be better if TestFinishedEvent only had two methods: `getFailure()` and getTestName(). Then, MockitoSessionBuilder could get a testName(String) builder method and DefaultMockitoSessionBuilder could pass it to DefaultMockitoSession and so on.
> 
> Alternatively, `MockitoSessionBuilder `could get a `testMethodName()` builder method and pass that on.
> 
> Moreover, I think `MockitoSessionBuilder `should allow to configure a `MockitoLogger`. This way, frameworks like JUnit could pass in a custom implementation. For JUnit Jupiter, a `MockitoLogger `that publishes report entries instead of writing to stdout (which causes problems will parallel execution) comes to mind.
> 
> Thoughts? =||= @TimvdLippe 

> I will do a proper investigation this weekend (hopefully, else next week) and update #1221. I hope you are okay with that @ChristianSchwarz ?

Of course,go ahead!
 =||= @marcphilipp 
>Moreover, I think `MockitoSessionBuilder` should allow to configure a `MockitoLogger`.
>
>Thoughts?

Make sense, should be a new issue.
 =||= Hey guys! What's the next step for closing this issue getting us closer to supporting JUnit5?

@ChristianSchwarz - can you update the ticket and clarify the public API change? Do you suggest adding new ""initMock()"" method? Do you suggest vararg, or consecutive invocation, or both? I would suggest to go for the simplest compatible API change - keeping the existing method, just making it vararg. Will you be able to work on this?

@marcphilipp - thank you for suggestions! For internal refactorings, we are pretty open - do what you think is good for the codebase. For public API changes/additions, we push back by default and we make sure that the use case is very compelling.

Thanks!!! =||= I would say we can change it to a vararg. This ticket basically addresses https://github.com/mockito/mockito/pull/1221/files#diff-6d0d68d3f3e6a783328fbe723a822668R36 which is unfortunate to do right now. If we change it to vararg, we can transform the `testClassInstances` List to an array and make it work :tada:  =||= ",0
1307,1306,InvocationFactory.createInvocation's realmethod cannot throw a Throwable,"InvocationFactory.createInvocation takes a Callable that is used to call the real method of the Invocation. If the Invocation throws an Exception the Exception is forwarded from the Callable. Unfortunately Callable can only throw an Exception, not a Throwable.

Hence if the real method throws a Throwable that is neither an Error, RuntimeException or Exception it cannot be forwarded.

I recommend for InvocationFactory.createInvocation to take realMethod argument that can throw a full Throwable.

This is required for fixing: linkedin/dexmaker#64",nan,0
1310,1279,Cannot override stubbed method that calls a stubbed method,"Mockito 2.13.0

Overriding stubbed method that calls a stubbed method in its answer may result in a number of different failure modes:

1) WrongTypeOfReturnValue is thrown.

```java
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import org.junit.Test;

public class TestStubbing {
    @Test
    public void test() throws Exception {
        Foo foo = mock(Foo.class);
        Bar bar = mock(Bar.class);

        when(foo.doFoo()).thenAnswer(invocation -> String.valueOf(bar.doBar()));
        assertEquals(""0"", foo.doFoo());

        when(foo.doFoo()).thenReturn("""");
        assertEquals("""", foo.doFoo());
    }

    interface Foo {
        String doFoo();
    }

    interface Bar {
        int doBar();
    }
}
```

2) Wrong method is stubbed.

```java
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import org.junit.Test;

public class TestStubbing {
    @Test
    public void test() throws Exception {
        Foo foo = mock(Foo.class);
        Bar bar = mock(Bar.class);

        when(foo.doFoo()).thenAnswer(invocation -> bar.doBar());
        assertEquals(0, foo.doFoo());
        assertEquals(0, bar.doBar());

        when(foo.doFoo()).thenReturn(1);
        assertEquals(1, foo.doFoo());
        assertEquals(0, bar.doBar());
    }

    interface Foo {
        int doFoo();
    }

    interface Bar {
        int doBar();
    }
}
```

3) StackOverflowError is thrown.

```java
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import org.junit.Test;

public class TestStubbing {
    @Test
    public void test() throws Exception {
        Foo foo = mock(Foo.class);
        Bar bar = mock(Bar.class);

        when(foo.doFoo()).thenAnswer(invocation -> bar.doBar());
        assertEquals(0, foo.doFoo());

        when(foo.doFoo()).thenAnswer(invocation -> bar.doBar() + 1);
        assertEquals(1, foo.doFoo());
    }

    interface Foo {
        int doFoo();
    }

    interface Bar {
        int doBar();
    }
}
```

The cause is that in the MockingProgressImpl the OngoingStubbing for doFoo() invocation is replaced with the OngoingStubbing for doBar() invocation.","One potential solution is to restore the OngoingStubbing after evaluating the answer.
[MockHandlerImpl.java.patch.txt](https://github.com/mockito/mockito/files/1590092/MockHandlerImpl.java.patch.txt) =||= Wow, thank you for reporting and digging deep into this problem. You nailed down another edge case of Mockito syntax! (ping @TimvdLippe, you're collecting problems with existing syntax).

One solution to this problem is using ""doReturn"" syntax. However, it does not really help the user. At minimum, the error message of WrongTypeOfReturnValue and friends should indicate this potential problem.

>One potential solution is to restore the OngoingStubbing after evaluating the answer

This is potentially a good idea. Can you hack it together and submit a PR? Let's see if it breaks any existing tests.

I'm a little bit worried fixing this bug because it is an incompatible change and there might be tests out there that depend on the existing behavior.

StackOverflowError needs fixing, too. It's great that you have found all problems with this use case.

BTW. I'm traveling so please pardon spotty replies. =||= I can confirm that the prototype in #1264 does not require any changes to make this work. You can see the full passing test suite at https://github.com/mockito/mockito/pull/1264/commits/a479368f17c1d2ea2e48e96b68559e457fb2d1a0 =||= Created a PR #1296 with [the above patch](https://github.com/mockito/mockito/files/1590092/MockHandlerImpl.java.patch.txt) applied. =||= @r-smirnov, thank you very much!!! I've opened a separate PR with your commits #1310, please take a look, read the description and let me know if something is amiss.

Your PR is a fantastic contribution (I thought that his problem is not fixable!!!) and I'm really looking forward to merging! =||= ",0
1310,1296,Add files via upload,Applied patch from issue #1279 ,"# [Codecov](https://codecov.io/gh/mockito/mockito/pull/1296?src=pr&el=h1) Report
> Merging [#1296](https://codecov.io/gh/mockito/mockito/pull/1296?src=pr&el=desc) into [release/2.x](https://codecov.io/gh/mockito/mockito/commit/70a7cf8c17bcbf0ffb5316d6dd2457d9708bbe5f?src=pr&el=desc) will **increase** coverage by `<.01%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/mockito/mockito/pull/1296/graphs/tree.svg?src=pr&token=MX80sLdeR0&width=650&height=150)](https://codecov.io/gh/mockito/mockito/pull/1296?src=pr&el=tree)

```diff
@@                Coverage Diff                @@
##             release/2.x    #1296      +/-   ##
=================================================
+ Coverage          88.08%   88.08%   +<.01%     
  Complexity          2321     2321              
=================================================
  Files                284      284              
  Lines               5857     5858       +1     
  Branches             702      702              
=================================================
+ Hits                5159     5160       +1     
  Misses               519      519              
  Partials             179      179
```


| [Impacted Files](https://codecov.io/gh/mockito/mockito/pull/1296?src=pr&el=tree) | Coverage Δ | Complexity Δ | |
|---|---|---|---|
| [.../org/mockito/internal/handler/MockHandlerImpl.java](https://codecov.io/gh/mockito/mockito/pull/1296/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9oYW5kbGVyL01vY2tIYW5kbGVySW1wbC5qYXZh) | `100% <100%> (ø)` | `12 <0> (ø)` | :arrow_down: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/mockito/mockito/pull/1296?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/mockito/mockito/pull/1296?src=pr&el=footer). Last update [70a7cf8...bf05447](https://codecov.io/gh/mockito/mockito/pull/1296?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= Added test =||= @bric3 - great to see you online!!! Hope things are settling for you and you're getting more sleep :)

I'm reviewing and trying out this change now. =||= @r-smirnov, this is an amazing bugfix for the problem that I initially thought was not fixable. Thank you very much!!! I've opened a separate PR with your commits at #1310 (I tried to push to your repo but it was not possible because your branch got out of sync). I wanted to address the feedback from @bric3 and try out this change to make sure the solution is what we want.

@mockito/developers, please take a look at #1310 - this bugfix carries incompatible behavior change that I think is justified given circumstances. Please weight on this. =||= ",0
1319,1314,Undesired invocation message improvements,"Let’s take a look at the following code.

```kotlin
package whatever

import org.junit.Test
import org.mockito.Mockito

class MultipleUndesiredInvocations {

    interface Inner {
        fun call()
    }

    interface SideEffect {
        fun call()

        class Impl(private val inner: Inner) : SideEffect {
            override fun call() = inner.call()
        }
    }

    interface Outer {
        fun call()

        class Impl(private val inner: Inner, sideEffect: SideEffect) : Outer {

            init {
                sideEffect.call()
            }

            override fun call() {
                inner.call()
            }
        }
    }

    @Test
    fun test() {
        val inner = Mockito.mock(Inner::class.java)
        val sideEffect = SideEffect.Impl(inner)
        val outer = Outer.Impl(inner, sideEffect)

        outer.call()

        Mockito.verify(inner).call()
    }
}
```
The `test` will fail, of course. The following message will be shown.
```
org.mockito.exceptions.verification.TooManyActualInvocations: 
inner.call();
Wanted 1 time:
-> at whatever.MultipleUndesiredInvocations.test(MultipleUndesiredInvocations.kt:43)
But was 2 times. Undesired invocation:
-> at whatever.MultipleUndesiredInvocations$Outer$Impl.call(MultipleUndesiredInvocations.kt:30)
```
It is kind of fine, but the undesired call (for me) is actually inside the `SideEffect` class.

Is it possible to extend the message to show all undesired invocations somehow? It would be extremely helpful when debugging failed tests similar to the sample above — i. e. when a side-effect calls the target object. ","Good idea. Do you want to submit a PR? =||= @mockitoguy I can work on it.
Also, to make it consistent I would suggest to extend the message to include all the invocations for other cases. As example for `TooLittleActualInvocations`. =||= Submitted PR #1319  =||= ",0
1320,111,Improve automation: fix binary comparison - avoidance of uncessary publication,"The binary comparison does not work:
- some problem with SerializableNoOp
- poms are always different due to changed version","@szczepiq want to close this one ?
 =||= Yes, it's done, thanks!
 =||= ",0
1321,1313,InlineByteBuddyMockMaker does not clean up stale mocks,"**Repro:**

1. Mockito 2.15.2 using mockito-inline
2. With -Xmx64m run
```
@RunWith(JUnit4.class)
public class Stress {
    private static final int NUM_RUNS = 20000;

    public static class TestClass {
        public String returnA() {
            return ""A"";
        }
    }

    /**
     * Test that mocks that are not referenced anymore are properly cleaned up.
     */
    @Test
    public void callALotOfMocks() {
        for (int i = 0; i < NUM_RUNS; i++) {
            TestClass mock = mock(TestClass.class);
            when(mock.returnA()).thenReturn(""B"");

            assertEquals(""B"", mock.returnA());

            if (i % 1024 == 0) {
                System.out.println(""Mocked "" + i + ""/"" + NUM_RUNS);
            }
        }
    }
}
```

**Expected:**

The test eventually finishes

**Observed:**

> Mocked 0/20000
> Mocked 1024/20000
> Mocked 2048/20000
> Mocked 3072/20000
> Mocked 4096/20000
> Mocked 5120/20000
> Mocked 6144/20000
> Mocked 7168/20000
> Mocked 8192/20000
> Mocked 9216/20000
> Mocked 10240/20000
> Mocked 11264/20000
> Exception in thread ""main"" java.lang.OutOfMemoryError: GC overhead limit exceeded
> 	at java.lang.StringCoding$StringDecoder.decode(StringCoding.java:149)
> 	at java.lang.StringCoding.decode(StringCoding.java:193)
> 	at java.lang.String.<init>(String.java:426)
> 	at java.util.jar.Attributes.read(Attributes.java:418)
> 	at java.util.jar.Manifest.read(Manifest.java:199)
> 
> Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread ""main""
> 
> Process finished with exit code 1

**Analysis:**

The `InlineByteBuddyMockMaker` uses a Map<WeakRef\<Mock\>, Handler> in the `mocks` field to store the mocks and their handlers. It relies that the mocks get garbage collected to remove the entry in the map. Unfortunately if there is an invocation on the mock, the handlers keep strong references to the mock in `InterceptedInvocation.mock`, `RealMethodCall.instance`, and `SerializableRealMethodCall.instance`. These are (strong) references by the handler. Hence the mock never gets cleaned up and the map grows indefinitely.

This is not a problem if the mocks get `Mockito.reset` properly or if using a mock maker that does not store the handlers.","Fantastic analysis, thank you! Do you want to take a stab at fixing it?

(ping @raphw, original author of the this mock maker). =||= I will have a look. Great analysis indeed. We will have to weakly reference any mock instance stored in Mockito. This is a straight forwars fi, I hope. =||= I will do it once I have time. (The kid, you k ow.) =||= I saw two problems we need to keep in mind:
- How to weak references interact with serializability
- We have to be vigilant to prevent premature cleaning up of the mock. Is there any possible case where we can gain access to the the invocations / handler without a reference to the mock? =||= I uploaded a fix proposal as fb37a2e even though
- I don't like that we use different kind of invocations for some tests
- The tests pass and I think I serialize properly, but I am not 100% sure as I never dealt with serialization before =||= Hey guys! I was reviewing @moltmann's PR and I'm wondering what are the alternative options to solve the problem. Can we attach a state to the mock object so that MockMakers can do their magic without keeping weak maps of all mocks? @raphw, thoughts? =||= Unfortunately, I do not think that there is an alternative to weak references.

The Java instrumentation API allows the retransformation of Java byte code, it does not allow changing the shape of a class, e.g. adding fields. Naturally, the dispatcher would be placed in such a field such that the life time of a dispatcher would be implicitly bound to the mock instance. But since we cannot add this field, we have to place the instance outside of it such that we have to use weak references to reach the same effect.

Therefore, I fear that this is the only way to go.  =||= Thank you for explanation!

One alternative/supplemental option is to make the lifecycle of mocks more formal. For example, JUnit rule / runner / mockito session can inform the mock maker that ""we're done with mock x"". =||= @mockitoguy If you can make this work, great. I see my mockmaker to be used to a legacy test suites though as they want to just mock one final method and not create a new test suite. Some older suites might not use junit or any other fancy feature.

Hence I would like to find a solution that does not require any changes outside of mockito. =||= @mockitoguy Is there any further change you want to c0ad83a? =||= ",0
1327,1326,Reduce memory consumption of the typical LocationImpl,"I recently noticed very heavy memory usage on our testsuite (which is using mockito) so I started profiling.

I eventually found #1313 but that's already being worked on. Also spotted a low hanging fruit: our testsuite is allocating about 6 *million* instances of `LocationImpl`.
It looks like I can't avoid that easily, however each `LocationImpl` also allocates a new `StackTraceFilter`, which can be easily avoided when the default is being applied; sending a PR shortly.

This should save us about 6 million empty and pointless `StackTraceFilter` :)",nan,0
1349,1346,Different mocks are used for @Mock and @InjectMock in the same test class with JUnit 5 extension,"I've been playing with the new JUnit 5 support in Mockito 2.17.0. I have found that with `@Mock` and `@InjectMocks` used in the same test class different mocks are injected. I would expect to have the same mock reused (as it works with JUnit 4 or manual `@Mock` initialization).

Sample code:
```
@ExtendWith(MockitoExtension.class)
public class SpaceShip5BugMiniTest {

    @InjectMocks
    private SpaceShip spaceShip;

    @Mock
    private TacticalStation tacticalStation;

    @Test
    public void shouldInjectMocks() {
        assertThat(tacticalStation).isNotNull();
        assertThat(spaceShip.getTacticalStation()).isEqualTo(tacticalStation);  
        //Bug ↑ - different mocks are use in @Mock and @InjectMock
    }
}
```

Error message:
```
org.opentest4j.AssertionFailedError: 
Expecting:
 <""tacticalStation (TacticalStation$MockitoMock$991606095@61d6015a)"">
to be equal to:
 <""tacticalStation (TacticalStation$MockitoMock$991606095@b62d79)"">
but was not.
Expected :tacticalStation
Actual   :tacticalStation
```

The minimal (non-)working example is available [here](https://github.com/szpak/code-examples-and-poc/tree/mockito2junit5-bug/mockito2-junit5).

@TimvdLippe Do you have an idea what could be wrong?

Mockito 2.17.0 (2.17.1 is not being released due to (https://github.com/mockito/shipkit/issues/679), junit-jupiter 5.1.0, OpenJDK 1.8.0_161, Linux.

### Checklist:
 - [x] The mockito message in the stacktrace have useful information, but it didn't help
 - [x] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [x] Provide versions (mockito / jdk / os / any other relevant information)
 - [x] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/master/.github/CONTRIBUTING.md)","Hm that seems really weird. Could you please post the implementation of `TacticalStation` and `SpaceShip` (although I am assuming they are simple POJO's?) =||= (Oh never mind, I missed the small link at the end of the example to https://github.com/szpak/code-examples-and-poc/tree/mockito2junit5-bug/mockito2-junit5/src/main/java/info/solidsoft/blog/mockito/junit5 ) =||= @szpak Please see https://github.com/mockito/mockito/blob/5e9a3c62fc1ca4cf12d5d19580613f418cebc895/subprojects/junit-jupiter/src/test/java/org/mockitousage/InjectMocksTest.java for a working test. I could make these tests fail with adding `final` to the field declaration, so that is what is going wrong. Removing `final` makes the tests pass.

What I do not understand is how this could work with JUnit 4, as we have not changed any of that code. We are completely reusing all of that logic. =||= It also works with `final` if `MockitoAnnotations.initMocks(this);` is used. Therefore, I would suspect the way how it is triggered/executed in JUnit 5 extension. =||= @TimvdLippe @szpak I have debugged this issue a bit. Here is what I found: it does look like the problem is with triggering the same logic from `MockitoExtension.class`. 
The root cause of the problem is that `beforeEach` creates two `testInstances` of the same test class for each test. 
Looks like method `collectParentTestInstances` is adding the same testInstance to the list of test instances.
I can try to work on this issue if no one is assigned to is already.
 =||= PRs appreciated!

On Mon, 26 Mar 2018, 10:55 Serge Bishyr, <notifications@github.com> wrote:

> @TimvdLippe <https://github.com/TimvdLippe> @szpak
> <https://github.com/szpak> I have debugged this issue a bit. Here is what
> I found: it does look like the problem is with triggering the same logic
> from MockitoExtension.class.
> The root cause of the problem is that beforeEach creates two testInstances
> of the same test class for each test.
> Looks like method collectParentTestInstances is adding the same
> testInstance to the list of test instances.
> I can try to work on this issue if no one is assigned to is already.
>
> —
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1346#issuecomment-376094135>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb9w69sJERNCP5FZJXPrwdq0ltsI9ks5tiK0ZgaJpZM4S6Huw>
> .
>
 =||= Have added PR #1349 with the fix for the issue =||= It works flawlessly. Thanks @SeriyBg!

@TimvdLippe As this bug can impact all those people preferring a constructor injection, what do you thing about releasing the new minor version (e.g. after #1350 is hopefully merged :) ) to Maven Central? =||= @szpak Yes after #1350 we will probably publish a new version. You can however already use the latest version from Bintray =||= I know Tim that I can, but JUnit 5 support is a notable feature and having it working correctly in the latest non-development version (available in Maven Central) seems very sensible for me. Great, that we agree on releasing a new stable (but IHMO still 2.17.x) version soon. =||= I'm seeing this same bug when using `SpringExtension.class` along with `MockitoExtension.class`:

```
@ExtendWith({MockitoExtension.class, SpringExtension.class})
public class InjectMocksTest {
  static class TacticalStation {}

  static class SpaceShip {
    private final TacticalStation tacticalStation;

    public SpaceShip(final TacticalStation tacticalStation) {
      this.tacticalStation = tacticalStation;
    }

    public TacticalStation getTacticalStation() {
      return tacticalStation;
    }
  }

  @InjectMocks
  private SpaceShip spaceShip;

  @Mock
  private TacticalStation tacticalStation;

  @Test
  public void shouldInjectMocks() {
    assertThat(tacticalStation).isNotNull();
    assertThat(spaceShip.getTacticalStation()).isEqualTo(tacticalStation);
    //Bug ↑ - different mocks are use in @Mock and @InjectMock
  }
}
```

This is using Mockito 3.1.0, JUnit 5.6.0, and Spring Boot 5.3.0.RELEASE. =||= > I'm seeing this same bug when using `SpringExtension.class` along with `MockitoExtension.class`:
> 
> ```
> @ExtendWith({MockitoExtension.class, SpringExtension.class})
> public class InjectMocksTest {
>   static class TacticalStation {}
> 
>   static class SpaceShip {
>     private final TacticalStation tacticalStation;
> 
>     public SpaceShip(final TacticalStation tacticalStation) {
>       this.tacticalStation = tacticalStation;
>     }
> 
>     public TacticalStation getTacticalStation() {
>       return tacticalStation;
>     }
>   }
> 
>   @InjectMocks
>   private SpaceShip spaceShip;
> 
>   @Mock
>   private TacticalStation tacticalStation;
> 
>   @Test
>   public void shouldInjectMocks() {
>     assertThat(tacticalStation).isNotNull();
>     assertThat(spaceShip.getTacticalStation()).isEqualTo(tacticalStation);
>     //Bug ↑ - different mocks are use in @Mock and @InjectMock
>   }
> }
> ```
> 
> This is using Mockito 3.1.0, JUnit 5.6.0, and Spring Boot 5.3.0.RELEASE.

Yes I am also facing this issue. Mine is also exactly the same scenario. Below are my dependencies,
org.junit.jupiter:junit-jupiter-engine:5.6.0
org.springframework.boot:spring-boot-starter:2.2.6.RELEASE
org.springframework.boot:spring-boot-starter-test:2.2.6.RELEASE
org.mockito:mockito-junit-jupiter:3.1.0 =||= ",0
1350,1348,Support @Mock injection in JUnit 5 method parameters,"JUnit 5 has the ability to ""inject"" parameters into test methods via an extensible ``ParameterResolver`` interface.  The JUnit 5 users guide provides an example that shows how such a ``ParameterResolver`` can supply mock objects as test parameters as follows (shamelessly copied from https://junit.org/junit5/docs/current/user-guide/#writing-tests-dependency-injection):

```
@ExtendWith(MockitoExtension.class)
class MyMockitoTest {

    @BeforeEach
    void init(@Mock Person person) {
        when(person.getName()).thenReturn(""Dilbert"");
    }

    @Test
    void simpleTestWithInjectedMock(@Mock Person person) {
        assertEquals(""Dilbert"", person.getName());
    }

}
```

The prototype ``MockitoExtension`` provided in the JUnit 5 samples project shows a simple implementation of the required ``supportsParameter()`` and ``resolveParameter()`` methods. (See: https://github.com/junit-team/junit5-samples/blob/r5.1.0/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java)

[ ]   Add the ability to inject mock objects into test method parameters to the official ``MockitoExtension``.  References #445","I am 👍 for this feature with the following use case:

Initialization of local variable mocks. Previously this would be `Mock<Generic> mock = mock(Mock.class)`. However, this loses the type-signature of `Generic`. With parameter mocks, we can do `@Mock Mock<Generic> mock` and still maintain the generic type signature. =||= I should also note that I haven't personally used parameter resolution the way it's shown above.  Our team generally either injects the mock object at the class level and configures it in ``@BeforeEach`` **OR** we inject the mock object in the test method and configure it at the top of the test method's block. =||= Yes agreed. Rather than some ""magic"" shared by methods, I think a generics-type-safe replacement for local mock initialization is a lot better. =||= I just edited the description of this issue to include a link to the sample ``MockitoExtension`` (I had intended to provide that reference originally).  I don't know if I'd refer to the the methods sharing the parameter instance as ""magic"" but without looking at the code it certainly isn't clear that the parameters are the shared if the types and names match.  I definitely think that there are use-cases for this technique and the use of ``ExtensionContext.Store`` is a great way to provide references to objects from different methods.  My main concern is that when there is a name collision and the types match, you might end up with behavior that's really hard to understand (without knowing how the underlying extension works).

I'm not sure I'm a fan of the syntax you described above as it seems more redundant than ``@Mock MyWeirdThing myWeirdMock`` - I'm guessing I'm misunderstanding your intention (I get the erasure part). =||= In Junit 4, local mock initialization would be 

```java
class Test {
  @Test
  public void test() {
    Mock<String> mock = Mockito.mock(Mock.class);
  }
  class Mock<T> {}
}
```
This would issue a warning saying that the generic type of `String` is not correctly created by `Mockito.mock`. (Even though we know that our mocks will work)

With this feature, in JUnit 5, we can have:

```java
class Test {
  @Test
  public void test(@Mock Mock<String> mock) {
  }
  class Mock<T> {}
}
```
And the compiler will not warn any longer. =||= I don't remember ever seeing that warning - Perhaps because I've always used the Mockito runner or rule? =||= Correct. You do not get that warning when using the runner. But then you have mocks that are used in every single test. This targets the use case where you need 1 extra mock in only 1 testcase. =||= And if the ``MockitoExtension`` is the JUnit 5 replacement for the runner or rule, why wouldn't those warnings also be suppressed? =||= Because the point of Mock initialization is different. JUnit 4 only supported for attributes. We are now talking about method parameters. Hopefully when I implement this logic, it is more clear to you 😄  =||= I'm not trying to be argumentative ... but as a pretty heavy user of the prototype ``MockitoExtension`` in the https://github.com/junit-team/junit5-samples project we'd have a lot of tests to update with this syntax.  We'll also need to make sure the example in the users guide and (if they're kept) the code in the junit-samples project matches the official implementation.  At this point I should probably let junit-team (I wish I could use a mention here) coordinate that with you.

@sbrannen @marcphilipp @sormuras =||= Looking at the source of https://github.com/junit-team/junit5-samples/blob/7bf40178345d5ca837579c8ddb8c025401a98788/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java I think we should be fine. I will let you know when the PR is open so that you can test that out.

One note: the Mockito team was not involved with the development of the prototype, but I think we will approach very similar capabilities. =||= I was looking at https://github.com/junit-team/junit5-samples/blob/master/junit5-mockito-extension/src/test/java/com/example/mockito/MockitoExtensionWithNestedTests.java because it's got a bunch of use cases including test-local mocks and the ""magic"" you referred to above.  Thinking though the syntax change you're describing, I'll assume that the tests would still run but with the same warning?

I do realize that the Mockito team didn't produce the prototype and it would be unrealistic to think that you should be permanently limited by it architecturally.  I did however think that the syntax ""proposed"" by the prototype was consistent with the field injection that already existed in Mockito.  I'm going to assume that what is produced as the official extension will be well integrated and well maintained - and I never complain about stable tooling! =||= Opened #1350 with a proposal implementation. =||= Okay, to write down the reason I think mock sharing by parameter is not a good idea:

First of all, there is a lot of duplicate code. For every test method, you need to list the mocks, which results in duplicate. Rather, using fields for these mocks removes the duplication.

Secondly, by relying on fields, the compiler will complain when you make a typo (or change a type). With parameters, you rely on the name (String-based) and the type declared. Both are not compiler safe.

Lastly, because you can rely on fields, refactoring is a lot easier, as IDE's support renaming by field. This is not possible for parameters.

For these 3 reasons, I see field mock sharing superior to parameter mock sharing and am therefore against introducing this logic in the parameter resolution. =||= > For these 3 reasons, I see field mock sharing superior to parameter mock sharing and am therefore against introducing this logic in the parameter resolution.

I totally understand the rationale. 👍  =||= What about support for `@Spy` and `@Captor`? Should new issues be created, or can it be part of this one? =||= `@Spy` makes no sense, as it requires a concrete instance. `@Captor` could be done. Let's discuss that in a different issue :+1: as this issue has been resolved. =||= My memory was incorrect, as #1350 has NOT been merged yet. =||= >`@Spy` makes no sense

You are completely right 😄.

I've created #1382 for adding support for `@Captor` =||= There's `Mockito.spy(Class)` which would work for a method parameter. =||= @marcphilipp Ah, yes I see now. Not sure how useful that actually is, as I only learned today we expose that API 😂  =||= ",0
1368,1367,Interface mock in a child class loader fails since Mockito 2.18.0,"Mocking an interface in a child classloader fails if the interface was already mocked in a parent class loader after upgrading to 2.18.0.

I can't currently provide a reproducer as tests pass in isolation. The test failure can be observed only running the whole test suite. The issue occurs only with 2.18.0, 2.17.0 works.

Exception message:

```
Mockito cannot mock this class: interface org.eclipse.persistence.jpa.JpaEntityManager.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 1.8
JVM vendor name    : Oracle Corporation
JVM vendor version : 25.151-b12
JVM name           : Java HotSpot(TM) 64-Bit Server VM
JVM version        : 1.8.0_151-b12
JVM info           : mixed mode
OS name            : Mac OS X
OS version         : 10.13.4


Underlying exception : java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#defineClass
	at org.springframework.data.jpa.provider.PersistenceProviderUnitTests.mockProviderSpecificEntityManagerInterface(PersistenceProviderUnitTests.java:88)
	at org.springframework.data.jpa.provider.PersistenceProviderUnitTests.detectsEclipseLinkPersistenceProvider(PersistenceProviderUnitTests.java:58)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:236)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:134)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:113)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:103)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:74)
Caused by: java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#defineClass
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Direct.defineClass(ClassInjector.java:413)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:186)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:199)
	at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:79)
	at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4225)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:124)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:345)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:160)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:354)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1875)
	at org.mockito.Mockito.mock(Mockito.java:1784)
	... 32 more
Caused by: java.lang.SecurityException: class ""org.mockito.codegen.JpaEntityManager$MockitoMock$2038182397""'s signer information does not match signer information of other classes in the same package
	at java.lang.ClassLoader.checkCerts(ClassLoader.java:898)
	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:668)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:761)
	at sun.reflect.GeneratedMethodAccessor28.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Direct.defineClass(ClassInjector.java:409)
	... 51 more
```

Link to test code:
[PersistenceProviderUnitTests.java](https://github.com/spring-projects/spring-data-jpa/blob/70d1012ac3ae12f7c7ad4060318ac61a8059db19/src/test/java/org/springframework/data/jpa/provider/PersistenceProviderUnitTests.java#L83).","@raphw Probably yet another edge-case in ByteBuddy :cry:  =||= Ah, of course. We must not define a protection domain for the codegen package anymore since we have already defined a class in this package in order to resolve the method handle lookup in case of Java 11 where the class now has Mockito's protection domain.

That is a trivial fix. =||= ",0
1369,1364,Unable to mock interfaces in Android instrumentation tests,"Consider the following Android instrumentation test:

```
@Test
public void testMockito() {
    final Collection mockCollection = Mockito.mock(Collection.class);

    Assert.assertTrue(true);
}
```

When run, I see the following output:

```
Testing started at 21:54 ...

04/08 21:54:01: Launching testMockito()
No apk changes detected since last installation, skipping installation of D:\Code\TestApp\app\build\outputs\apk\debug\app-debug.apk
$ adb push D:\Code\TestApp\app\build\outputs\apk\androidTest\debug\app-debug-androidTest.apk /data/local/tmp/com.example.zolbr.testapp.test
$ adb shell pm install -t -r ""/data/local/tmp/com.example.zolbr.testapp.test""
Success


Running tests

$ adb shell am instrument -w -r   -e debug false -e class 'com.example.zolbr.testapp.ExampleInstrumentedTest#testMockito' com.example.zolbr.testapp.test/android.support.test.runner.AndroidJUnitRunner
Client not ready yet..
Started running tests

org.mockito.exceptions.base.MockitoException:
Mockito cannot mock this class: interface java.util.Collection.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.



IMPORTANT INFORMATION FOR ANDROID USERS:

The regular Byte Buddy mock makers cannot generate code on an Android VM!
To resolve this, please use the 'mockito-android' dependency for your application:
http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22mockito-android%22%20g%3A%22org.mockito%22

Java               : 0.9
JVM vendor name    : The Android Project
JVM vendor version : 2.1.0
JVM name           : Dalvik
JVM version        : 0.9
JVM info           : null
OS name            : Linux
OS version         : 3.18.56+


Underlying exception : java.lang.IllegalArgumentException: Could not create type
at com.example.zolbr.testapp.ExampleInstrumentedTest.testMockito(ExampleInstrumentedTest.java:40)
at java.lang.reflect.Method.invoke(Native Method)
at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.junit.runners.Suite.runChild(Suite.java:128)
at org.junit.runners.Suite.runChild(Suite.java:27)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
at android.support.test.internal.runner.TestExecutor.execute(TestExecutor.java:58)
at android.support.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:375)
at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2074)
Caused by: java.lang.IllegalArgumentException: Could not create type
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:139)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:345)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:160)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:354)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
at org.mockito.android.internal.creation.AndroidByteBuddyMockMaker.createMock(AndroidByteBuddyMockMaker.java:39)
at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
at org.mockito.Mockito.mock(Mockito.java:1875)
at org.mockito.Mockito.mock(Mockito.java:1784)
... 28 more
Caused by: java.lang.IncompatibleClassChangeError: The method 'int java.lang.Object.hashCode()' was expected to be of type interface but instead was found to be of type virtual (declaration of 'net.bytebuddy.dynamic.scaffold.MethodRegistry$Handler$ForImplementation' appears in /data/app/com.example.zolbr.testapp.test-OVcvUgjejP8CYF6lGYt9Pg==/base.apk)
at net.bytebuddy.dynamic.scaffold.MethodRegistry$Handler$ForImplementation.hashCode(Unknown Source:2)
at java.util.HashMap.hash(HashMap.java:338)
at java.util.HashMap.put(HashMap.java:611)
at java.util.HashSet.add(HashSet.java:219)
at net.bytebuddy.dynamic.scaffold.MethodRegistry$Default.prepare(MethodRegistry.java:409)
at net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder.make(SubclassDynamicTypeBuilder.java:162)
at net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder.make(SubclassDynamicTypeBuilder.java:155)
at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2669)
at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:123)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
... 39 more
```

This only occurs when using mockito-android 2.18.0:

```
androidTestImplementation 'org.mockito:mockito-android:2.18.0'
```

Downgrading to 2.17.0 fixes this issue.

This occurs on a Windows 10 dev machine running Android Studio 3.1.","This appears to be regression introduced in ByteBuddy. @raphw would you mind investigating? =||= I have same question, can anyone help? =||= I identified the issue. It has to do how hashCode and equals are invoked on interface types. OpenJDK allows for a different convention then what Android accepts. I will fix that with the next release, stick to the old version until then. (It is already fixed on master for Byte Buddy but it is part of the build routine.) =||= Should be fixed in 2.18.2. =||= When will 2.18.2 be available? My project is unable to pick this version up:

```
Failed to resolve: org.mockito:mockito-core:2.18.1
Show in File
Show in Project Structure dialog
```

which makes sense since from the looks of it there is no `ci maven-central-release` commit for 2.18.2. =||= It is availble on bintray. You can add the bintray repository to your
pom.xml to find it.

On Wed, 18 Apr 2018, 04:05 Zach Olbrys, <notifications@github.com> wrote:

> When will 2.18.2 be available? My project is unable to pick this version
> up:
>
> Failed to resolve: org.mockito:mockito-core:2.18.1
> Show in File
> Show in Project Structure dialog
>
> which makes sense since from the looks of it there is no ci
> maven-central-release commit for 2.18.2.
>
> —
> You are receiving this because you commented.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1364#issuecomment-382222421>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb_wMgNVW_Sp-pgm391qwCz2L62Gtks5tpp9lgaJpZM4TL0h6>
> .
>
 =||= I've downloaded the jar from here: https://bintray.com/mockito/maven/mockito-development/2.18.2 and added it to my project, but the problem persists. =||= With the same exception message? =||= stacktrace:
```
org.mockito.exceptions.base.MockitoException:
Mockito cannot mock this class: interface com.example.IExample.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.



IMPORTANT INFORMATION FOR ANDROID USERS:

The regular Byte Buddy mock makers cannot generate code on an Android VM!
To resolve this, please use the 'mockito-android' dependency for your application:
http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22mockito-android%22%20g%3A%22org.mockito%22

Java               : 0.9
JVM vendor name    : The Android Project
JVM vendor version : 2.1.0
JVM name           : Dalvik
JVM version        : 0.9
JVM info           : null
OS name            : Linux
OS version         : 4.4.88-gda039c93611c


Underlying exception : java.lang.IllegalArgumentException: Could not create type
at com.example.ExampleTest.<init>(ExampleTest.kt:35)
at java.lang.reflect.Constructor.newInstance0(Native Method)
at java.lang.reflect.Constructor.newInstance(Constructor.java:334)
at org.junit.runners.BlockJUnit4ClassRunner.createTest(BlockJUnit4ClassRunner.java:217)
at org.junit.runners.BlockJUnit4ClassRunner$1.runReflectiveCall(BlockJUnit4ClassRunner.java:266)
at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
at org.junit.runners.BlockJUnit4ClassRunner.methodBlock(BlockJUnit4ClassRunner.java:263)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.junit.runners.Suite.runChild(Suite.java:128)
at org.junit.runners.Suite.runChild(Suite.java:27)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
at android.support.test.internal.runner.TestExecutor.execute(TestExecutor.java:58)
at android.support.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:375)
at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2075)
Caused by: java.lang.IllegalArgumentException: Could not create type
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:140)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
at org.mockito.android.internal.creation.AndroidByteBuddyMockMaker.createMock(AndroidByteBuddyMockMaker.java:39)
at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)
at org.mockito.Mockito.mock(Mockito.java:1729)
at org.mockito.Mockito.mock(Mockito.java:1642)
... 28 more
Caused by: java.lang.AbstractMethodError: abstract method ""net.bytebuddy.dynamic.loading.ClassLoadingStrategy org.mockito.internal.creation.bytebuddy.SubclassLoader.getStrategy(java.lang.Class)""
at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:94)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
... 39 more
``` =||= It seems like you are using a new version of Mockito Core but an old version of Mockito Android. We had to change an internal API that both versions require to communicate to fix another bug. =||= ",0
1375,1372,Migrate settings.gradle to settings.gradle.kts,a very first step towards  #1359,"Awesome, thanks for taking a stab at this. I will need to see this in the editor and how it all works. Will hopefully have some time next weekend to do so! =||= It looks like we have to wait for Gradle 4.7 due to failing builds while using Java 10.
This problem should be fixed in https://github.com/gradle/kotlin-dsl/releases/tag/v0.16.3 (will be part of Gradle 4.7). =||= # [Codecov](https://codecov.io/gh/mockito/mockito/pull/1372?src=pr&el=h1) Report
> Merging [#1372](https://codecov.io/gh/mockito/mockito/pull/1372?src=pr&el=desc) into [release/2.x](https://codecov.io/gh/mockito/mockito/commit/4f72147c464c1a8a642d01fc3334e98e92b464cd?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/mockito/mockito/pull/1372/graphs/tree.svg?width=650&height=150&token=MX80sLdeR0&src=pr)](https://codecov.io/gh/mockito/mockito/pull/1372?src=pr&el=tree)

```diff
@@              Coverage Diff               @@
##             release/2.x    #1372   +/-   ##
==============================================
  Coverage          88.61%   88.61%           
  Complexity          2357     2357           
==============================================
  Files                292      292           
  Lines               5949     5949           
  Branches             719      719           
==============================================
  Hits                5272     5272           
  Misses               497      497           
  Partials             180      180
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/mockito/mockito/pull/1372?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/mockito/mockito/pull/1372?src=pr&el=footer). Last update [4f72147...d93a46f](https://codecov.io/gh/mockito/mockito/pull/1372?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= I am still interested in using Kotlin rather than Groovy for our build files. However, the files changed a bit. Do you want to open a new PR for that? =||= @TimvdLippe a new PR is ready for review. =||= ",0
1378,1240,Mockito Inline can't mock Finatra Response Class,"Seen a few of these lying around, but my stacktrace is also different.

I was trying to mock the Finatra `ResponseBuilder` class.

```
You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class com.twitter.finatra.http.response.ResponseBuilder, interface com.twitter.inject.Logging, interface com.twitter.util.logging.Logging]
	at <testclass.java>
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at org.junit.runners.BlockJUnit4ClassRunner.createTest(BlockJUnit4ClassRunner.java:217)
	at org.junit.runners.BlockJUnit4ClassRunner$1.runReflectiveCall(BlockJUnit4ClassRunner.java:266)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.BlockJUnit4ClassRunner.methodBlock(BlockJUnit4ClassRunner.java:263)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:377)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
	at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [class com.twitter.finatra.http.response.ResponseBuilder, interface com.twitter.inject.Logging, interface com.twitter.util.logging.Logging]
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	... 43 more
Caused by: java.lang.UnsupportedOperationException: class redefinition failed: attempted to change the schema (add/remove fields)
	at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:117)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:97)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:201)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:182)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)
	at org.mockito.Mockito.mock(Mockito.java:1729)
	at org.mockito.Mockito.mock(Mockito.java:1642)
	... 43 more
```
","I'm also unable to mock a final class, I'm using JDK 9 and the project is using kotlin. I'm not sure if it's a related issue, I did try to do some debugging but to no avail. Interestingly, only the first mock fails.

```kotlin
try {
    mock<WorldContext>()
} catch (e: Throwable) {

}
// success
val a = mock<WorldContext>()
```

Complete stacktrace:

```
Mockito cannot mock this class: class io.polymorphicpanda.faux.ecs.WorldContext.
Can not mock final classes with the following settings :
 - explicit serialization (e.g. withSettings().serializable())
 - extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class io.polymorphicpanda.faux.ecs.WorldContext, interface io.polymorphicpanda.faux.ecs.Context]
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: class io.polymorphicpanda.faux.ecs.WorldContext.
Can not mock final classes with the following settings :
 - explicit serialization (e.g. withSettings().serializable())
 - extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class io.polymorphicpanda.faux.ecs.WorldContext, interface io.polymorphicpanda.faux.ecs.Context]
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$worldContext$2.invoke(WorldSpec.kt:91)
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$worldContext$2.invoke(WorldSpec.kt:18)
	at org.jetbrains.spek.engine.lifecycle.LifecycleAwareAdapter.invoke(LifecycleAwareAdapter.kt:21)
	at org.jetbrains.spek.engine.lifecycle.LifecycleAwareAdapter.getValue(LifecycleAwareAdapter.kt:17)
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$world$2.invoke(WorldSpec.kt:37)
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$world$2.invoke(WorldSpec.kt:18)
	at org.jetbrains.spek.engine.lifecycle.LifecycleAwareAdapter.invoke(LifecycleAwareAdapter.kt:21)
	at org.jetbrains.spek.engine.lifecycle.LifecycleAwareAdapter.getValue(LifecycleAwareAdapter.kt:17)
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$1.invoke(WorldSpec.kt:40)
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$1.invoke(WorldSpec.kt:18)
	at org.jetbrains.spek.engine.SpekTestEngine$Collector$action$action$1.invoke(SpekTestEngine.kt:175)
	at org.jetbrains.spek.engine.SpekTestEngine$Collector$action$action$1.invoke(SpekTestEngine.kt:133)
	at org.jetbrains.spek.engine.Scope$Action.execute(Scope.kt:48)
	at org.jetbrains.spek.engine.Scope$Action.execute(Scope.kt:32)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:83)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$null$2(HierarchicalTestExecutor.java:92)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$null$2(HierarchicalTestExecutor.java:92)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:51)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)
	at org.jetbrains.spek.tooling.runner.junit.JUnitPlatformSpekRunner.run(JUnitPlatformSpekRunner.kt:107)
	at org.jetbrains.spek.tooling.MainKt.main(Main.kt:58)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class io.polymorphicpanda.faux.ecs.WorldContext, interface io.polymorphicpanda.faux.ecs.Context]
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	... 52 more
Caused by: java.lang.IllegalStateException: 
Byte Buddy could not instrument all classes within the mock's type hierarchy

This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
 - Compiled by older versions of scalac
 - Classes that are part of the Android distribution
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:120)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:97)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:200)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:181)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1821)
	... 52 more
Caused by: java.lang.ClassCircularityError: java/lang/WeakPairMap$Pair$Weak
	at java.base/java.lang.WeakPairMap$Pair.weak(WeakPairMap.java:201)
	at java.base/java.lang.WeakPairMap.putIfAbsent(WeakPairMap.java:123)
	at java.base/java.lang.Module.implAddReads(Module.java:396)
	at java.base/java.lang.Module.implAddReads(Module.java:357)
	at java.base/java.lang.System$2.addReads(System.java:2146)
	at java.base/jdk.internal.module.Modules.addReads(Modules.java:85)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.lambda$getDynamicModule$4(Proxy.java:884)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue$Memoizer.get(AbstractClassLoaderValue.java:327)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue.computeIfAbsent(AbstractClassLoaderValue.java:203)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.getDynamicModule(Proxy.java:875)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.mapToModule(Proxy.java:814)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.<init>(Proxy.java:631)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.<init>(Proxy.java:636)
	at java.base/java.lang.reflect.Proxy.lambda$getProxyConstructor$0(Proxy.java:415)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue$Memoizer.get(AbstractClassLoaderValue.java:327)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue.computeIfAbsent(AbstractClassLoaderValue.java:203)
	at java.base/java.lang.reflect.Proxy.getProxyConstructor(Proxy.java:413)
	at java.base/java.lang.reflect.Proxy.newProxyInstance(Proxy.java:999)
	at java.base/sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:305)
	at java.base/sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:303)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/sun.reflect.annotation.AnnotationParser.annotationForMap(AnnotationParser.java:303)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:293)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72)
	at java.base/java.lang.reflect.Executable.declaredAnnotations(Executable.java:605)
	at java.base/java.lang.reflect.Executable.declaredAnnotations(Executable.java:603)
	at java.base/java.lang.reflect.Executable.getDeclaredAnnotations(Executable.java:591)
	at java.base/java.lang.reflect.Constructor.getDeclaredAnnotations(Constructor.java:579)
	at net.bytebuddy.description.method.MethodDescription$ForLoadedConstructor.getDeclaredAnnotations(MethodDescription.java:912)
	at net.bytebuddy.description.method.MethodDescription$AbstractBase.asToken(MethodDescription.java:695)
	at net.bytebuddy.description.method.MethodDescription$AbstractBase.asToken(MethodDescription.java:334)
	at net.bytebuddy.description.method.MethodList$AbstractBase.asTokenList(MethodList.java:53)
	at net.bytebuddy.dynamic.scaffold.InstrumentedType$Factory$Default$1.represent(InstrumentedType.java:223)
	at net.bytebuddy.ByteBuddy.redefine(ByteBuddy.java:698)
	at net.bytebuddy.ByteBuddy.redefine(ByteBuddy.java:676)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:167)
	at java.instrument/java.lang.instrument.ClassFileTransformer.transform(ClassFileTransformer.java:246)
	at java.instrument/sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	at java.instrument/sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:550)
	at java.base/java.lang.WeakPairMap$Pair.weak(WeakPairMap.java:201)
	at java.base/java.lang.WeakPairMap.putIfAbsent(WeakPairMap.java:123)
	at java.base/java.lang.Module.implAddReads(Module.java:396)
	at java.base/java.lang.Module.implAddReads(Module.java:357)
	at java.base/java.lang.System$2.addReads(System.java:2146)
	at java.base/jdk.internal.module.Modules.addReads(Modules.java:85)
	at java.base/jdk.internal.module.Modules.transformedByAgent(Modules.java:166)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:157)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:117)
	... 65 more


``` =||= We are seeing the same issue using JDK 9 and Kotlin =||= Same issue for JDK10 and Kotlin (and Java) =||= @raphw, I’ve just tried `2.17.3` from `dl.bintray.com/mockito/maven` with `bytebuddy:1.8.1` and this kind of errors still happens. This happened for me after migrating from JDK 8 to JDK 9. A coworker of mine updated his Android Studio from 3.0 to 3.1 and observes the same thing in IDE (running tests via Gradle works fine though). This version of AS actually bundles JDK 8, but the updated revision (I guess). We’ve tried the `2.17.3` as well with no luck. =||= Seems like some JDK internals were switched out such that Byte Buddy tries to instrument classes that it needs itself to apply the instrumentation. This requiressome whitelisting on our side, I believe. =||= Also seeing this when running tests for Spek 2.x (spekframework/spek#318) on JDK9 https://travis-ci.org/patrickpilch/spek/jobs/346058522
I've tried forcing the Byte Buddy version to 1.8.3 but the problem remained.

<details>
<summary>Complete stacktrace</summary>
<p>

```
Mockito cannot mock this class: class org.spekframework.spek2.runtime.lifecycle.LifecycleManager.
Can not mock final classes with the following settings :
 - explicit serialization (e.g. withSettings().serializable())
 - extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class org.spekframework.spek2.runtime.lifecycle.LifecycleManager, class java.lang.Object]"" type=""org.mockito.exceptions.base.MockitoException""><![CDATA[org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: class org.spekframework.spek2.runtime.lifecycle.LifecycleManager.
Can not mock final classes with the following settings :
 - explicit serialization (e.g. withSettings().serializable())
 - extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class org.spekframework.spek2.runtime.lifecycle.LifecycleManager, class java.lang.Object]
	at org.spekframework.spek2.junit.TestDescriptorAdapterFactoryTest.setup(TestDescriptorAdapterFactoryTest.kt:57)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:389)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)
	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.invokeMethodInExtensionContext(ClassTestDescriptor.java:289)
	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.lambda$synthesizeBeforeEachMethodAdapter$11(ClassTestDescriptor.java:277)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$null$2(TestMethodTestDescriptor.java:132)
	at org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeMethodsOrCallbacksUntilExceptionOccurs(TestMethodTestDescriptor.java:152)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeEachMethods(TestMethodTestDescriptor.java:131)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:106)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:83)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$null$2(HierarchicalTestExecutor.java:92)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$null$2(HierarchicalTestExecutor.java:92)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:51)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)
	at org.junit.platform.console.tasks.ConsoleTestExecutor.executeTests(ConsoleTestExecutor.java:65)
	at org.junit.platform.console.tasks.ConsoleTestExecutor.lambda$execute$0(ConsoleTestExecutor.java:57)
	at org.junit.platform.console.tasks.CustomContextClassLoaderExecutor.invoke(CustomContextClassLoaderExecutor.java:33)
	at org.junit.platform.console.tasks.ConsoleTestExecutor.execute(ConsoleTestExecutor.java:57)
	at org.junit.platform.console.ConsoleLauncher.executeTests(ConsoleLauncher.java:85)
	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:75)
	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:48)
	at org.junit.platform.console.ConsoleLauncher.main(ConsoleLauncher.java:40)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [class org.spekframework.spek2.runtime.lifecycle.LifecycleManager, class java.lang.Object]
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:345)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:160)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:354)
	... 59 more
Caused by: java.lang.IllegalStateException: 
Byte Buddy could not instrument all classes within the mock's type hierarchy

This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
 - Compiled by older versions of scalac
 - Classes that are part of the Android distribution
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:120)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:97)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:345)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:160)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:354)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:200)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:181)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1855)
	... 59 more
Caused by: java.lang.ClassCircularityError: java/lang/WeakPairMap$Pair$Weak
	at java.base/java.lang.WeakPairMap$Pair.weak(WeakPairMap.java:201)
	at java.base/java.lang.WeakPairMap.putIfAbsent(WeakPairMap.java:123)
	at java.base/java.lang.Module.implAddReads(Module.java:396)
	at java.base/java.lang.Module.implAddReads(Module.java:357)
	at java.base/java.lang.System$2.addReads(System.java:2146)
	at java.base/jdk.internal.module.Modules.addReads(Modules.java:85)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.lambda$getDynamicModule$4(Proxy.java:884)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue$Memoizer.get(AbstractClassLoaderValue.java:327)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue.computeIfAbsent(AbstractClassLoaderValue.java:203)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.getDynamicModule(Proxy.java:875)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.mapToModule(Proxy.java:814)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.<init>(Proxy.java:631)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.<init>(Proxy.java:636)
	at java.base/java.lang.reflect.Proxy.lambda$getProxyConstructor$0(Proxy.java:415)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue$Memoizer.get(AbstractClassLoaderValue.java:327)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue.computeIfAbsent(AbstractClassLoaderValue.java:203)
	at java.base/java.lang.reflect.Proxy.getProxyConstructor(Proxy.java:413)
	at java.base/java.lang.reflect.Proxy.newProxyInstance(Proxy.java:999)
	at java.base/sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:305)
	at java.base/sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:303)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/sun.reflect.annotation.AnnotationParser.annotationForMap(AnnotationParser.java:303)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:293)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72)
	at java.base/java.lang.reflect.Executable.declaredAnnotations(Executable.java:605)
	at java.base/java.lang.reflect.Executable.declaredAnnotations(Executable.java:603)
	at java.base/java.lang.reflect.Executable.getDeclaredAnnotations(Executable.java:591)
	at java.base/java.lang.reflect.Constructor.getDeclaredAnnotations(Constructor.java:579)
	at net.bytebuddy.description.method.MethodDescription$ForLoadedConstructor.getDeclaredAnnotations(MethodDescription.java:917)
	at net.bytebuddy.description.method.MethodDescription$AbstractBase.asToken(MethodDescription.java:695)
	at net.bytebuddy.description.method.MethodDescription$AbstractBase.asToken(MethodDescription.java:334)
	at net.bytebuddy.description.method.MethodList$AbstractBase.asTokenList(MethodList.java:53)
	at net.bytebuddy.dynamic.scaffold.InstrumentedType$Factory$Default$1.represent(InstrumentedType.java:223)
	at net.bytebuddy.ByteBuddy.redefine(ByteBuddy.java:698)
	at net.bytebuddy.ByteBuddy.redefine(ByteBuddy.java:676)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:167)
	at java.instrument/java.lang.instrument.ClassFileTransformer.transform(ClassFileTransformer.java:246)
	at java.instrument/sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	at java.instrument/sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:550)
	at java.base/java.lang.WeakPairMap$Pair.weak(WeakPairMap.java:201)
	at java.base/java.lang.WeakPairMap.putIfAbsent(WeakPairMap.java:123)
	at java.base/java.lang.Module.implAddReads(Module.java:396)
	at java.base/java.lang.Module.implAddReads(Module.java:357)
	at java.base/java.lang.System$2.addReads(System.java:2146)
	at java.base/jdk.internal.module.Modules.addReads(Modules.java:85)
	at java.base/jdk.internal.module.Modules.transformedByAgent(Modules.java:166)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:157)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:117)
	... 72 more
```
</p>
</details> =||= Could someone create a reproduction of this issue in a small isolated repository? It seems like I cannot reproduce the issue.

Also, I wonder what the remaining stack frames are, could someone post these? =||= @raphw I created a repo which reproduces the problem: https://github.com/guenhter/mockito-final-class-kotlin-problem =||= @mockitoguy 
The same issue was reproduced for mocking Aspose library classes (com.aspose). Lib was compiled via aspose-jdk1.6. `aspose-jdk1.6` can be added to observed classes list in exception info =||= ",0
1387,1386,"Add AtMostOnce(),rename one testClass and one TODO.","Hi,

I would like to make a quick contribution on this project.

I add atMostOnce(), it seem's not to be a big feature. I just want to highlight the fact you have the function atLeastOnce() but nothing for the atMostOnce case. 

I rename the testClass ThreadVerifiesContinuoslyInteractingMockTest on ThreadVerifiesContinuouslyInteractingMockTest and the TODO on toString() from HamcrestArgumentMatcher<T>.
",nan,0
1391,1390,MockitoExtension cannot be registered as a global junit5 extension.,"`MockitoExtension` doesn't expose its constructor so it can't be loaded by `ServiceLoader.`

When trying to register `MockitoExtension` for automatic use using a file named `META-INF\services\org.junit.jupiter.api.extension.Extension` and content `org.mockito.junit.jupiter.MockitoExtension`

the below error is thrown, using mockito-junit-jupiter 2.18.3

```
org.junit.jupiter.api.extension.Extension: org.mockito.junit.jupiter.MockitoExtension Unable to get public no-arg constructor
java.util.ServiceConfigurationError: org.junit.jupiter.api.extension.Extension: org.mockito.junit.jupiter.MockitoExtension Unable to get public no-arg constructor
	at java.base/java.util.ServiceLoader.fail(ServiceLoader.java:581)
	at java.base/java.util.ServiceLoader.getConstructor(ServiceLoader.java:672)
	at java.base/java.util.ServiceLoader.access$1000(ServiceLoader.java:390)
	at java.base/java.util.ServiceLoader$LazyClassPathLookupIterator.hasNextService(ServiceLoader.java:1232)
	at java.base/java.util.ServiceLoader$LazyClassPathLookupIterator.hasNext(ServiceLoader.java:1264)
	at java.base/java.util.ServiceLoader$2.hasNext(ServiceLoader.java:1299)
	at java.base/java.util.ServiceLoader$3.hasNext(ServiceLoader.java:1384)
	at java.base/java.lang.Iterable.forEach(Iterable.java:74)
	at org.junit.jupiter.engine.extension.ExtensionRegistry.registerAutoDetectedExtensions(ExtensionRegistry.java:102)
	at org.junit.jupiter.engine.extension.ExtensionRegistry.createRegistryWithDefaultExtensions(ExtensionRegistry.java:86)
	at org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor.prepare(JupiterEngineDescriptor.java:37)
	at org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor.prepare(JupiterEngineDescriptor.java:28)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.prepare(HierarchicalTestExecutor.java:89)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:74)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:92)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$100(JUnitPlatformTestClassProcessor.java:77)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:73)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy1.stop(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:123)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:155)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:137)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1135)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
	at java.base/java.lang.Thread.run(Thread.java:844)
Caused by: java.lang.NoSuchMethodException: org.mockito.junit.jupiter.MockitoExtension.<init>()
	at java.base/java.lang.Class.getConstructor0(Class.java:3302)
	at java.base/java.lang.Class.getConstructor(Class.java:2110)
	at java.base/java.util.ServiceLoader$1.run(ServiceLoader.java:659)
	at java.base/java.util.ServiceLoader$1.run(ServiceLoader.java:656)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/java.util.ServiceLoader.getConstructor(ServiceLoader.java:667)
	... 46 more
```

 - [X] The mockito message in the stacktrace have useful information, but it didn't help
 - [X] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [X] Provide versions (mockito / jdk / os / any other relevant information)
 - [X] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [X] Read the [contributing guide](https://github.com/mockito/mockito/blob/master/.github/CONTRIBUTING.md)",nan,0
1402,1401,VarargsMatcher doesn't work correctly when using HamcrestMatchers in Mockito 2,"```
class A {
    private B b;
    public A(B b) {
        this.b = b;
    }
    public Integer perform() {
        return b.run(""abcd"", 1L, 2L);
    }
}

class B {
    public Integer run(String str, Long... price) {
        return 10;
    }
}

class HamcrestVarArgsMatcher extends TypeSafeMatcher<Long> implements VarargMatcher {
    protected boolean matchesSafely(Long item) {
        return item < 3;
    }
    public void describeTo(Description description) {
    }
}

class Test {
   @Test
   public void varArgsMatcherUsingHamcrestMatcherWorks() {
        B b = Mockito.mock(B.class);
        A a = new A(b);

        when(b.run(eq(""abcd""), MockitoHamcrest.argThat(new HamcrestVarArgsMatcher()))).thenReturn(15);

        assertThat(a.perform(), is(15)); // Actually returns 0
    }
}
```",nan,0
1426,1419,Provide Java 11 compatibility,"I ran tests with JAva 11 and getting the follwing exception. may be asm 6.2 fixes this?


org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface de.espirit.firstspirit.access.Language.

If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : ""Oracle Corporation""
JVM vendor version : 11-ea+18
JVM name           : Java HotSpot(TM) 64-Bit Server VM
JVM version        : 11-ea+18
JVM info           : mixed mode
OS name            : Linux
OS version         : 4.9.0-6-amd64


You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [interface java.lang.Comparable, interface de.espirit.firstspirit.access.Language]
	at de.espirit.firstspirit.generate.TestPluggableUrlCreator.setUp(TestPluggableUrlCreator.java:51)
	at jdk.internal.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [interface java.lang.Comparable, interface de.espirit.firstspirit.access.Language]
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:344)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:159)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:353)
Caused by: java.lang.IllegalStateException: 
Byte Buddy could not instrument all classes within the mock's type hierarchy

This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
 - Compiled by older versions of scalac
 - Classes that are part of the Android distribution
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:120)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:97)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:344)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:159)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:353)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:200)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:181)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1855)
	at org.mockito.Mockito.mock(Mockito.java:1787)
Caused by: java.lang.IllegalArgumentException: Unsupported class file major version 55
	at net.bytebuddy.jar.asm.ClassReader.<init>(ClassReader.java:166)
	at net.bytebuddy.jar.asm.ClassReader.<init>(ClassReader.java:148)
	at net.bytebuddy.jar.asm.ClassReader.<init>(ClassReader.java:136)
	at net.bytebuddy.utility.OpenedClassReader.of(OpenedClassReader.java:54)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2912)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1634)
	at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:171)
	at net.bytebuddy.dynamic.scaffold.inline.AbstractInliningDynamicTypeBuilder.make(AbstractInliningDynamicTypeBuilder.java:92)
	at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2669)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:181)
	at java.instrument/java.lang.instrument.ClassFileTransformer.transform(ClassFileTransformer.java:246)
	at java.instrument/sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	at java.instrument/sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:563)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:167)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:117)




","asm 6.2 alone does not fix this, neither does upgrading to latest bytebuddy help here.
The combination of asm 6.2, latest bytebuddy, a minor code change in mockito and setting `-Dnet.bytebuddy.experimental=true` helps here. =||= mockito-core-2.21.0.jar 	
byte-buddy-1.8.15.jar

with org.mockito.plugins.MockMaker ""mock-maker-inline"" the fix is not working with java 1.8_172 and java  11-ea+24.

without ""mock-maker-inline"" it works

org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface de.espirit.or.schema.EntityType.

If you're not sure why you're getting this error, please report to the mailing list.


Java               : 1.8
JVM vendor name    : Oracle Corporation
JVM vendor version : 25.172-b11
JVM name           : Java HotSpot(TM) 64-Bit Server VM
JVM version        : 1.8.0_172-b11
JVM info           : mixed mode
OS name            : Mac OS X
OS version         : 10.13.6


You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [interface de.espirit.or.schema.EntityType, interface java.io.Serializable]

	at de.espirit.firstspirit.access.editor.TestEntityAssociate.beforeEach(TestEntityAssociate.java:27)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [interface de.espirit.or.schema.EntityType, interface java.io.Serializable]
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:344)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:159)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:353)
	... 23 more
Caused by: java.lang.IllegalStateException: 
Byte Buddy could not instrument all classes within the mock's type hierarchy

This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
 - Compiled by older versions of scalac
 - Classes that are part of the Android distribution
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:164)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:141)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:344)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:159)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:353)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:200)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:181)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:69)
	at org.mockito.Mockito.mock(Mockito.java:1895)
	at org.mockito.Mockito.mock(Mockito.java:1804)
	... 23 more
Caused by: java.lang.NoSuchFieldError: ASM_API
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator$ParameterWritingVisitorWrapper$ParameterAddingClassVisitor.<init>(InlineBytecodeGenerator.java:251)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator$ParameterWritingVisitorWrapper$ParameterAddingClassVisitor.<init>(InlineBytecodeGenerator.java:246)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator$ParameterWritingVisitorWrapper.wrap(InlineBytecodeGenerator.java:242)
	at net.bytebuddy.asm.AsmVisitorWrapper$Compound.wrap(AsmVisitorWrapper.java:645)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining$RedefinitionClassVisitor.visit(TypeWriter.java:3672)
	at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:492)
	at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:355)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2915)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1634)
	at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:171)
	at net.bytebuddy.dynamic.scaffold.inline.AbstractInliningDynamicTypeBuilder.make(AbstractInliningDynamicTypeBuilder.java:92)
	at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2669)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:215)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)
	at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:161)
	... 37 more =||= We are experiencing the same error with Java 11 and inline mocks. =||= Having similar issue with mockito and Java 11. Unable to mock any class/interface, do we need implement any method for class loading,since defineclass method removed  in Java11 ? I even edited my java.policy for assertion exception.
https://dzone.com/articles/jdk-11-and-proxies-in-a-world-past-sunmiscunsafe
http://hg.openjdk.java.net/jdk9/hs/jdk/rev/0d2ab72ba600
mockito -2.21.0,
bytebuddy-1.8.15

Below is the exception:
org.mockito.exceptions.base.MockitoException: 

Mockito cannot mock this class: class com.xxx.xxx.toolkit.config.Configuration.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : Oracle Corporation
JVM vendor version : 11-ea+26
JVM name           : Java HotSpot(TM) 64-Bit Server VM
JVM version        : 11-ea+26
JVM info           : mixed mode
OS name            : Mac OS X
OS version         : 10.13.4


Underlying exception : java.lang.IllegalStateException: Error invoking java.lang.invoke.MethodHandles$Lookup#defineClass
Caused by: java.lang.IllegalStateException: Error invoking java.lang.invoke.MethodHandles$Lookup#defineClass
Caused by: java.security.AccessControlException: access denied (""java.lang.RuntimePermission"" ""defineClass"")
 =||= Same problem here... =||= Seeing a related error:
```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface cloud.cosmin.checklister.repo.ListRepo.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : AdoptOpenJDK
JVM vendor version : 11.0.1+13
JVM name           : OpenJDK 64-Bit Server VM
JVM version        : 11.0.1+13
JVM info           : mixed mode
OS name            : Linux
OS version         : 4.15.0-39-generic


Underlying exception : java.lang.UnsupportedOperationException: Cannot define class using reflection
	at cloud.cosmin.checklister.rest.ListControllerTest.setUp(ListControllerTest.java:37)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:106)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38)
	at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:117)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:155)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:137)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.UnsupportedOperationException: Cannot define class using reflection
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Unavailable.defineClass(ClassInjector.java:821)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:185)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:187)
	at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:79)
	at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4457)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:121)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1855)
	at org.mockito.internal.configuration.MockAnnotationProcessor.process(MockAnnotationProcessor.java:36)
	at org.mockito.internal.configuration.MockAnnotationProcessor.process(MockAnnotationProcessor.java:16)
	at org.mockito.internal.configuration.IndependentAnnotationEngine.createMockFor(IndependentAnnotationEngine.java:38)
	at org.mockito.internal.configuration.IndependentAnnotationEngine.process(IndependentAnnotationEngine.java:62)
	at org.mockito.internal.configuration.InjectingAnnotationEngine.processIndependentAnnotations(InjectingAnnotationEngine.java:57)
	at org.mockito.internal.configuration.InjectingAnnotationEngine.process(InjectingAnnotationEngine.java:41)
	at org.mockito.MockitoAnnotations.initMocks(MockitoAnnotations.java:69)
	... 48 more
Caused by: java.lang.IllegalStateException: Could not find sun.misc.Unsafe
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe$Dispatcher$Disabled.initialize(ClassInjector.java:1366)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe.inject(ClassInjector.java:1202)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$ForUnsafeInjection.load(ClassLoadingStrategy.java:458)
	at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:79)
	at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4457)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Indirect.make(ClassInjector.java:684)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$CreationAction.run(ClassInjector.java:302)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$CreationAction.run(ClassInjector.java:290)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.<clinit>(ClassInjector.java:70)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:184)
	... 71 more
Caused by: java.lang.NoSuchMethodException: sun.misc.Unsafe.defineClass(java.lang.String, [B, int, int, java.lang.ClassLoader, java.security.ProtectionDomain)
	at java.base/java.lang.Class.getMethod(Class.java:2109)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe$Dispatcher$CreationAction.run(ClassInjector.java:1269)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe$Dispatcher$CreationAction.run(ClassInjector.java:1257)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe.<clinit>(ClassInjector.java:1136)
	... 80 more
``` =||= @cstroe Are you sure that you don't have some older byte-buddy version on the classpath?

(of course I assume that use you the latest version of Mockito and Byte Buddy provided by it). =||= @szpak Your intuition is correct.  I am using Spring Boot version `2.0.5.RELEASE`, and it is using an older version of the Mockito library.  In order to use the newest Mockito, I had to change my Gradle config:
```
    testCompile('org.springframework.boot:spring-boot-starter-test') {
        exclude group: ""org.mockito"", module: ""mockito-core""
    }
    testCompile(""org.mockito:mockito-core:2.23.4"")
```

That fixed my errors.  Thank you for the help. =||= Great to hear.

Btw, Spring Boot provides also an easier way to override dependency [versions](https://docs.spring.io/platform/docs/Cairo-BUILD-SNAPSHOT/reference/html/getting-started-overriding-versions.html). Here, overriding Mockito would be enough.

Btw, AFAIR only Spring Boot 2.1 declared Java 11 compatibility. Therefore, you may want to upgrade to prevent further surprises :). =||= > testCompile('org.springframework.boot:spring-boot-starter-test') {
>         exclude group: ""org.mockito"", module: ""mockito-core""
>     }
>     testCompile(""org.mockito:mockito-core:2.23.4"")

this works like a charm, Thank You! =||= > 
> 
> > testCompile('org.springframework.boot:spring-boot-starter-test') {
> > exclude group: ""org.mockito"", module: ""mockito-core""
> > }
> > testCompile(""org.mockito:mockito-core:2.23.4"")
> 
> this works like a charm, Thank You!

Anyone has an idea how to do this in pom.xml? =||= @JiDarwish It's basic maven dependency management ;)

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-test</artifactId>
  <scope>test</test>
  <exclusions>
    <exclusion>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
    </exclusion>
  </exclustions>
</dependency>
<dependency>
  <groupId>org.mockito</groupId>
  <artifactId>mockito-core</artifactId>
  <version>2.23.4</version>
  <scope>test</scope>
</dependency>
``` =||= @bric3 I did exactly the same, still didn't help :-(

> Java               : 11
> JVM vendor name    : Oracle Corporation
> JVM vendor version : 11.0.2+9
> JVM name           : OpenJDK 64-Bit Server VM
> JVM version        : 11.0.2+9
> JVM info           : mixed mode
> OS name            : Mac OS X
> OS version         : 10.14.4 =||= Ok, adding bytebuddy dep. on top of that helped! =||= > @JiDarwish It's basic maven dependency management ;)
> 
> ```
> <dependency>
>   <groupId>org.springframework.boot</groupId>
>   <artifactId>spring-boot-starter-test</artifactId>
>   <scope>test</test>
>   <exclusions>
>     <exclusion>
>       <groupId>org.mockito</groupId>
>       <artifactId>mockito-core</artifactId>
>     </exclusion>
>   </exclustions>
> </dependency>
> <dependency>
>   <groupId>org.mockito</groupId>
>   <artifactId>mockito-core</artifactId>
>   <version>2.23.4</version>
>   <scope>test</scope>
> </dependency>
> ```

If your project extend `spring-boot-starter-parent` you might just add : 
```
	<properties>
		<mockito.version>2.23.4</mockito.version>
	</properties>
```

In your Maven file.  =||= ",0
1439,1438,ignoreStubs documentation should be updated for strictness,"Driven by #1436, we need to update 'ignoreStubs' docs to include information about Mockito strictness (effectively replaces the need for 'ignoreStubs').",Thank you for contribution! =||= ,0
1446,1444,Artifact ID changes,"Since `2.20.0` Mockito Maven artifact IDs [have changed](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.mockito%22).

* `mockito-android` → `android`
* `mockito-inline` → `inline`
* `mockito-junit-jupiter` → `junit-jupiter`

Not sure if it is an intended change or not, so decided to clarify things a bit. So... Is it an intended change? It isn’t mentioned in the changelog.","It's a bug. Thank you for reporting! =||= @epeee, can you take a look at this? =||= Upstream bug in Shipkit: https://github.com/mockito/shipkit/issues/741 =||= @mockitoguy sorry, I was busy yesterday. 
I can have a look at the upstream bug in shipkit tomorrow. =||= Not sure if it is related but the `2.20.1` is available in JCenter but not in Maven Central. =||= There is some delay. Bintray log shows that the sync was successful. Let's wait until the end of the day.

Thanks for checking! =||= OSS repo has the right artifacts so I think it's just a delay before it's searchable in central. Proof - [pom.xml](https://oss.sonatype.org/service/local/artifact/maven/redirect?r=releases&g=org.mockito&a=mockito-inline&v=2.20.1&e=pom) in the Sonatype OSS 'release' repo.

Let's keep the ticket open until we add tests for the artifacts. @ming13, do you want to contribute a test that would verify artifact IDs? This should be a form of a Gradle task. =||= The issue is fixed in 2.20.1. I've added tests to prevent the issue in the future.

Thanks again for reporting!!! =||= ",0
1450,1444,Artifact ID changes,"Since `2.20.0` Mockito Maven artifact IDs [have changed](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.mockito%22).

* `mockito-android` → `android`
* `mockito-inline` → `inline`
* `mockito-junit-jupiter` → `junit-jupiter`

Not sure if it is an intended change or not, so decided to clarify things a bit. So... Is it an intended change? It isn’t mentioned in the changelog.","It's a bug. Thank you for reporting! =||= @epeee, can you take a look at this? =||= Upstream bug in Shipkit: https://github.com/mockito/shipkit/issues/741 =||= @mockitoguy sorry, I was busy yesterday. 
I can have a look at the upstream bug in shipkit tomorrow. =||= Not sure if it is related but the `2.20.1` is available in JCenter but not in Maven Central. =||= There is some delay. Bintray log shows that the sync was successful. Let's wait until the end of the day.

Thanks for checking! =||= OSS repo has the right artifacts so I think it's just a delay before it's searchable in central. Proof - [pom.xml](https://oss.sonatype.org/service/local/artifact/maven/redirect?r=releases&g=org.mockito&a=mockito-inline&v=2.20.1&e=pom) in the Sonatype OSS 'release' repo.

Let's keep the ticket open until we add tests for the artifacts. @ming13, do you want to contribute a test that would verify artifact IDs? This should be a form of a Gradle task. =||= The issue is fixed in 2.20.1. I've added tests to prevent the issue in the future.

Thanks again for reporting!!! =||= ",0
1458,793,Expose StubbingLookupListener publicly and create listener distinction,"Make StubbingLookupListener public. Originating ticket: #770

As a rule of a thumb we try to expose the internal APIs that the top level features are built upon. Since StubbingLookupListener is useful for us to implement strictness, let's get the former exposed as public API. This way we build stronger framework with the concept of ""onion skin API"".",If exposed publicly the API should use an event object. (See https://github.com/mockito/mockito/pull/770#discussion_r91054474) =||= ,0
1463,1460,verifyZeroInteractions(stub-only-mock) does not throw exception,"Hi,

`verifyZeroInteractions(stub-only-mock)` doesn't throw exception.
I think it should throw `CannotVerifyStubOnlyMock` exception as `verify()` does, for consistency.
```java
@Test
public void test_stub_only_not_verifiable_verify_zero_interactions() {
    // given
    IMethods localMock = mock(IMethods.class, withSettings().stubOnly());
    localMock.objectReturningMethod(200);

    try {
        // when
        verifyZeroInteractions(localMock);
        fail();
    } catch (CannotVerifyStubOnlyMock e) {
        // then, exception should be thrown
    }
}
```
Thanks,
Sangwoo",nan,0
1501,1500,Mockito 2.x.x does not support Kotlin release coroutines,"In https://github.com/mockito/mockito/pull/1032 support for Kotlin suspend function has been introduced.

But the change contains a hard-coded class name of `Continuation` (https://github.com/elizarov/mockito/blob/bf092378fc42f31efa054b4e5e555c10c33f5994/src/main/java/org/mockito/internal/creation/SuspendMethod.java#L10) that is going to be renamed eventually.

Kotlin compiler with languge-version set to 1.3 generates suspend function with continuation parameter of type `kotlin.coroutines.Continuation` and with the current state of mockito it becomes impossible to mock them properly
",nan,0
1539,1522,Correct usage of strict stubbings -> PotentialStubbingProblem: Strict stubbing argument mismatch,"Hi guys,

This is following is almost a copy paste from the mockito google group/forum, which I was recommended to do:
https://groups.google.com/forum/#!topic/mockito/WDKfavtJkCg

**Relevant Versions:**
```
OS : Fedora Linux 4.18.14-200.fc28.x86_64
mockito : 2.23.0
junit : 5.3.1
JDK : Oracle 10.0.2 (happens under 8 and OpenJDK 11.0.1 too)
IntelliJ : 2018.3 EAP

    testCompile group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: '5.3.1'
    testRuntime group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.3.1'
    testCompile group: 'org.mockito', name: 'mockito-junit-jupiter', version: '2.23.0'
```
**Actual Question:**

I had some questions regarding use cases of new ""Strict"" stubbing.

With Junit5 & `@ExtendWith(MockitoExtension.class)` I've noticed that it errors out when I think it shouldn't (when compared with Junit4 & `@RunWith(MockitoJUnitRunner.class)` )
I have a very simple test case, which I consider to be both good code, and good mocking. Which gets highlighted as incorrect stubbing usage under Strict (default) checking

```
package com.example;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class MockitoTest {

    @Mock
    private Map<String, Object> mockMap;
    @Mock
    private Object mockObject;

    @Test
    void shouldBeAbleToMock() {
        // When
        when(mockMap.get(""A"")).thenReturn(""Apple"");
        when(mockMap.get(""B"")).thenReturn(mockObject);

        // Then
        assertEquals(""Apple"", mockMap.get(""A""));
        assertEquals(mockObject, mockMap.get(""B""));
    }
}
```

The above gives the following stacktrace when run:
```
org.mockito.exceptions.misusing.PotentialStubbingProblem: 
Strict stubbing argument mismatch. Please check:
 - this invocation of 'get' method:
    mockMap.get(""B"");
    -> at com.example.MockitoTest.shouldBeAbleToMock(MockitoTest.java:25)
 - has following stubbing(s) with different arguments:
    1. mockMap.get(""A"");
      -> at com.example.MockitoTest.shouldBeAbleToMock(MockitoTest.java:24)
Typically, stubbing argument mismatch indicates user mistake when writing tests.
Mockito fails early so that you can debug potential problem easily.
However, there are legit scenarios when this exception generates false negative signal:
  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API
    Please use 'will().given()' or 'doReturn().when()' API for stubbing.
  - stubbed method is intentionally invoked with different arguments by code under test
    Please use default or 'silent' JUnit Rule (equivalent of Strictness.LENIENT).
For more information see javadoc for PotentialStubbingProblem class.

    at com.example.MockitoTest.shouldBeAbleToMock(MockitoTest.java:25)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:564)
    at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:515)
    at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:171)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:167)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:114)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:59)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:105)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)
    at java.base/java.util.ArrayList.forEach(ArrayList.java:1378)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:110)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)
    at java.base/java.util.ArrayList.forEach(ArrayList.java:1378)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:110)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
    at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
    at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
    at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220)
    at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188)
    at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202)
    at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181)
    at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)
    at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:74)
    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
```

I've found 1 other reference to this issue online, which was here:
https://stackoverflow.com/questions/52139619/simulation-of-service-using-mockito-2-leads-to-stubbing-error

The above stated you could work around the issue by changing the code as follows:
```
// From this
when(mockMap.get(""A"")).thenReturn(""Apple"");
when(mockMap.get(""B"")).thenReturn(mockObject);

// To this
when(mockMap.get(anyString())).thenAnswer(invocation -> {
    Object arg = invocation.getArgument(0);
    if (""A"".equals(arg)) return ""Apple"";
    if (""B"".equals(arg)) return system;
});
```

Is this a bug, or is this intentional going forwards?

Thanks for your time!


check that

 - [✓] The mockito message in the stacktrace have useful information, but it didn't help
 - [✓] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [✓] Provide versions (mockito / jdk / os / any other relevant information)
 - [✓] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [✓] Read the [contributing guide](https://github.com/mockito/mockito/blob/master/.github/CONTRIBUTING.md)

","I'm not sure if I'm on the right track with this, or is this helps anyone else, but I had the same problem and solved it by using the `doReturn().when()` version of mockito instead of `when().thenReturn()` =||= @bwhiting2356  This works to resolve the issue, but it causes a new issue.  When I use `doReturn().when()` it turns off the `UnnecessaryStubbingException` that we rely on.  Any idea how to overload method stubbing while still being strict? =||= I think the `strict` and `lenient` thing has not been thought trough.  It's quite common to stub a method twice with different parameter values.  For example when code needs to fetch two (or more) values from a dependency you would stub for those two values.  Now this generates an `UnnecessaryStubbingException`, while it clearly **is** necessary for proper working of the test.

The solution using an `Answer` class is not a good one, in fact, I'm of the opinion you want to avoiding using `Answer` objects as much as possible. =||= Finding exactly the same issue as described above using `@RunWith(MockitoExtension.class)`

```
<dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.junit.vintage</groupId>
      <artifactId>junit-vintage-engine</artifactId>
      <scope>test</scope>
    </dependency>
```
version 5.3.2 of the above dependencies and 

```
<dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-junit-jupiter</artifactId>
      <version>2.23.0</version>
      <scope>test</scope>
    </dependency>
```

@hjohn @bwhiting2356  @jmart1 be interested to hear how you resolved this... =||= Bump!
 =||= @jaygehlot I'm afraid I've just turned it off, as I do with all warnings that create too many false positives.  Keeping an eye on this issue still in case it gets fixed. =||= ",0
1543,793,Expose StubbingLookupListener publicly and create listener distinction,"Make StubbingLookupListener public. Originating ticket: #770

As a rule of a thumb we try to expose the internal APIs that the top level features are built upon. Since StubbingLookupListener is useful for us to implement strictness, let's get the former exposed as public API. This way we build stronger framework with the concept of ""onion skin API"".",If exposed publicly the API should use an event object. (See https://github.com/mockito/mockito/pull/770#discussion_r91054474) =||= ,0
1543,1466,Expose StubbingLookupListener publicly (#793),This PR makes `StubbingLookupListener` public and adds `MockObjectListener` as parent of `InvocationListener` and `StubbingLookupListener`. (#793),"# [Codecov](https://codecov.io/gh/mockito/mockito/pull/1466?src=pr&el=h1) Report
> Merging [#1466](https://codecov.io/gh/mockito/mockito/pull/1466?src=pr&el=desc) into [release/2.x](https://codecov.io/gh/mockito/mockito/commit/ee175c682aca82ac25fd2d00250f5188d6a9e954?src=pr&el=desc) will **increase** coverage by `0.03%`.
> The diff coverage is `93.75%`.

[![Impacted file tree graph](https://codecov.io/gh/mockito/mockito/pull/1466/graphs/tree.svg?src=pr&token=MX80sLdeR0&width=650&height=150)](https://codecov.io/gh/mockito/mockito/pull/1466?src=pr&el=tree)

```diff
@@                Coverage Diff                @@
##             release/2.x    #1466      +/-   ##
=================================================
+ Coverage             88%   88.03%   +0.03%     
- Complexity          2378     2386       +8     
=================================================
  Files                298      298              
  Lines               6020     6036      +16     
  Branches             729      734       +5     
=================================================
+ Hits                5298     5314      +16     
  Misses               541      541              
  Partials             181      181
```


| [Impacted Files](https://codecov.io/gh/mockito/mockito/pull/1466?src=pr&el=tree) | Coverage Δ | Complexity Δ | |
|---|---|---|---|
| [.../internal/junit/DefaultStubbingLookupListener.java](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9qdW5pdC9EZWZhdWx0U3R1YmJpbmdMb29rdXBMaXN0ZW5lci5qYXZh) | `95.83% <ø> (ø)` | `11 <0> (ø)` | :arrow_down: |
| [.../internal/junit/MismatchReportingTestListener.java](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9qdW5pdC9NaXNtYXRjaFJlcG9ydGluZ1Rlc3RMaXN0ZW5lci5qYXZh) | `100% <ø> (ø)` | `4 <0> (ø)` | :arrow_down: |
| [...mockito/internal/progress/MockingProgressImpl.java](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9wcm9ncmVzcy9Nb2NraW5nUHJvZ3Jlc3NJbXBsLmphdmE=) | `97.26% <ø> (ø)` | `29 <0> (ø)` | :arrow_down: |
| [...ito/internal/listeners/StubbingLookupNotifier.java](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9saXN0ZW5lcnMvU3R1YmJpbmdMb29rdXBOb3RpZmllci5qYXZh) | `94.73% <ø> (ø)` | `3 <0> (ø)` | :arrow_down: |
| [...o/internal/junit/UnnecessaryStubbingsReporter.java](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9qdW5pdC9Vbm5lY2Vzc2FyeVN0dWJiaW5nc1JlcG9ydGVyLmphdmE=) | `100% <ø> (ø)` | `4 <0> (ø)` | :arrow_down: |
| [.../mockito/internal/junit/UniversalTestListener.java](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9qdW5pdC9Vbml2ZXJzYWxUZXN0TGlzdGVuZXIuamF2YQ==) | `92.85% <100%> (ø)` | `11 <1> (ø)` | :arrow_down: |
| [...a/org/mockito/internal/junit/NoOpTestListener.java](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9qdW5pdC9Ob09wVGVzdExpc3RlbmVyLmphdmE=) | `100% <100%> (ø)` | `3 <1> (ø)` | :arrow_down: |
| [.../org/mockito/internal/handler/MockHandlerImpl.java](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9oYW5kbGVyL01vY2tIYW5kbGVySW1wbC5qYXZh) | `100% <100%> (ø)` | `8 <0> (ø)` | :arrow_down: |
| [.../internal/junit/StrictStubsRunnerTestListener.java](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9qdW5pdC9TdHJpY3RTdHVic1J1bm5lclRlc3RMaXN0ZW5lci5qYXZh) | `100% <100%> (ø)` | `3 <1> (ø)` | :arrow_down: |
| [...o/internal/creation/settings/CreationSettings.java](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9jcmVhdGlvbi9zZXR0aW5ncy9DcmVhdGlvblNldHRpbmdzLmphdmE=) | `98.21% <100%> (+0.34%)` | `26 <6> (+4)` | :arrow_up: |
| ... and [3 more](https://codecov.io/gh/mockito/mockito/pull/1466/diff?src=pr&el=tree-more) | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/mockito/mockito/pull/1466?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/mockito/mockito/pull/1466?src=pr&el=footer). Last update [ee175c6...96b6417](https://codecov.io/gh/mockito/mockito/pull/1466?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= Replaced by #1543.

@marchpig. I needed to do a number of changes on top of your PR. I started reviewing and giving feedback but that was becoming too much (this PR introduces an incompatible change in MockCreationListener). Can you help and review #1543?

Thank you very much for your contribution! With your other PR (#1463), I should be able to merge it! =||= ",0
1544,1541,Mock object premature garbage collected when using 'One-liner stubs',"### Problem:
'One-liner stubs' may throw an exception because the actual mock object is already garbage collected when trying to return the mock.

### Reproduce:
1. Mockito 2.23.5 using mockito-inline
2. -Xmx256m

```
public class OneLinerStubStressTest {

    public class TestClass {
        public String getStuff() {
            return ""A"";
        }
    }

    private static String generateString() {
        final int length = 10000;
        final StringBuilder stringBuilder = new StringBuilder(length);
        for (int i = 0; i <= length; i++) {
            stringBuilder.append(""B"");
        }
        return stringBuilder.toString();
    }

    @Test
    public void call_a_lot_of_mocks() {
        final String returnValue = generateString();
        for (int i = 0; i < 40000; i++) {
            final TestClass mock = when(mock(TestClass.class).getStuff())
                                   .thenReturn(returnValue).getMock();
            assertEquals(returnValue, mock.getStuff());
        }
    }
}
```
#### Expected:
Test finishes successfully

#### Actual:
```
java.lang.IllegalStateException: The mock object was garbage collected. This should not happen in normal circumstances when using public API. Typically, the test class keeps strong reference to the mock object and it prevents getting the mock collected. Mockito internally needs to keep weak references to mock objects to avoid memory leaks for certain types of MockMaker implementations. If you see this exception using Mockito public API, please file a bug. For more information see issue #1313.
        at org.mockito.internal.invocation.mockref.MockWeakReference.get(MockWeakReference.java:32)
        at org.mockito.internal.invocation.InterceptedInvocation.getMock(InterceptedInvocation.java:103)
        at org.mockito.internal.stubbing.InvocationContainerImpl.invokedMock(InvocationContainerImpl.java:157)
        at org.mockito.internal.stubbing.ConsecutiveStubbing.getMock(ConsecutiveStubbing.java:28)
```

### Analysis:
As part of #1313 `DefaultInvocationFactory` and `InterceptedInvocation` were refactored to keep week reference to the mock. This was necessary in order to get rid of strong references by the handlers which caused memory leaks. On the other hand this requires to have a strong reference to the mock in the test class in order to prevent premature garbage collection. Unfortunately if using 'One-liner stubs' (https://static.javadoc.io/org.mockito/mockito-core/2.23.4/org/mockito/Mockito.html#one_liner_stub) the mock object may be premature cleaned up. This occurs because we gain access to the `InterceptedInvocation` when calling `getMock()` (which tries to get the mock from the invocation), without having any strong reference to the mock itself. At this point the mock may already be cleaned up.",Great investigation! Do you have a suggestion on how to resolve this? =||= Tried different approaches. I believe I found one solution that works well. Created a PR. =||= ,0
1546,1545,Enable Gradle Build cache for faster local builds,"Let's enable Gradle build cache for faster local builds.

https://docs.gradle.org/current/userguide/build_cache.html",nan,0
1549,151,Investigate why #125 did not trigger release,Investigate why #125 did not trigger release,"gc old issues
 =||= ",0
1552,155,Internal Comparator violates its general contract,"Log from my test run:

java.lang.IllegalArgumentException: Comparison method violates its general contract!
    at java.util.TimSort.mergeHi(TimSort.java:868)
    at java.util.TimSort.mergeAt(TimSort.java:485)
    at java.util.TimSort.mergeForceCollapse(TimSort.java:426)
    at java.util.TimSort.sort(TimSort.java:223)
    at java.util.TimSort.sort(TimSort.java:173)
    at java.util.Arrays.sort(Arrays.java:659)
    at java.util.Collections.sort(Collections.java:217)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.orderedInstanceFieldsFrom(PropertyAndSetterInjection.java:125)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.injectMockCandidates(PropertyAndSetterInjection.java:100)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.processInjection(PropertyAndSetterInjection.java:77)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:68)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.relayProcessToNextStrategy(MockInjectionStrategy.java:89)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:71)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.relayProcessToNextStrategy(MockInjectionStrategy.java:89)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:71)
    at org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.apply(MockInjection.java:92)
    at org.mockito.internal.configuration.DefaultInjectionEngine.injectMocksOnFields(DefaultInjectionEngine.java:20)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.injectMocks(InjectingAnnotationEngine.java:100)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.processInjectMocks(InjectingAnnotationEngine.java:62)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.process(InjectingAnnotationEngine.java:56)
    at org.mockito.MockitoAnnotations.initMocks(MockitoAnnotations.java:108)","It occures when bean under test has many fields (declaredFields.size = 44)
 =||= ",0
1554,155,Internal Comparator violates its general contract,"Log from my test run:

java.lang.IllegalArgumentException: Comparison method violates its general contract!
    at java.util.TimSort.mergeHi(TimSort.java:868)
    at java.util.TimSort.mergeAt(TimSort.java:485)
    at java.util.TimSort.mergeForceCollapse(TimSort.java:426)
    at java.util.TimSort.sort(TimSort.java:223)
    at java.util.TimSort.sort(TimSort.java:173)
    at java.util.Arrays.sort(Arrays.java:659)
    at java.util.Collections.sort(Collections.java:217)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.orderedInstanceFieldsFrom(PropertyAndSetterInjection.java:125)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.injectMockCandidates(PropertyAndSetterInjection.java:100)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.processInjection(PropertyAndSetterInjection.java:77)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:68)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.relayProcessToNextStrategy(MockInjectionStrategy.java:89)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:71)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.relayProcessToNextStrategy(MockInjectionStrategy.java:89)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:71)
    at org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.apply(MockInjection.java:92)
    at org.mockito.internal.configuration.DefaultInjectionEngine.injectMocksOnFields(DefaultInjectionEngine.java:20)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.injectMocks(InjectingAnnotationEngine.java:100)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.processInjectMocks(InjectingAnnotationEngine.java:62)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.process(InjectingAnnotationEngine.java:56)
    at org.mockito.MockitoAnnotations.initMocks(MockitoAnnotations.java:108)","It occures when bean under test has many fields (declaredFields.size = 44)
 =||= ",0
1555,154,stop depending on hamcrest internally,In order to avoid compatibility/upgrade problems we will stop depending on hamcrest internally. Hamcrest will be an optional dependency of Mockito.,"What's the progress on this? I'd like to use Mockito with my unit tests and I'm running JUnit 4.11 that is bundled with Eclipse 4.4 that I'm using.
 =||= Is Hamcrest dependency a blocker for using Mockito with Eclipse 4.4 ?

-- Brice

On Tue, Jan 27, 2015 at 10:10 AM, Tobias Eriksson notifications@github.com
wrote:

> What's the progress on this? I'd like to use Mockito with my unit tests
> and I'm running JUnit 4.11 that is bundled with Eclipse 4.4 that I'm using.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/154#issuecomment-71613024.
 =||= @bric3 It seems that way. Eclipse 4.4 comes with JUnit 4.11 and Hamcrest 1.3, which apparently doesn't work with Mockito? Therefore when I try to run my JUnit plug-in tests for an Eclipse 4.4 RCP application it doesn't work.
 =||= I use Mockito 1.9.5 and 1.10.16 with JUnit 4.11 and 4.12 combined with Hamcrest 1.3 in several applications and didn't have any issues.
 =||= Fells more of an Eclipse issue, if an IDE cannot work with the project
classpath...

The team / the code is clearly not near any Mockito 2.0 _final_ release.
Anyway, this task is not even started, and it will target Mockito 2.0 as
API will change.
 =||= @bric3 @martin-g My bad, I made a plugin for Mockito and forgot to add the dependencies to Hamcrest and Objenesis. Seems to work fine now as far as I can tell..
 =||= Would be nice to at least upgrade to hamcrest 1.3 (latest version I think).
 =||= @philipwhiuk Maybe in version 2.0. Maybe we could eventually drop the dependency (at this time nothing yet decided)
 =||= Working on this. We will use hamcrest 1.3, too.
 =||= This is completed on master.
 =||= ",0
1573,1568,Eclipse project setup doesn't work out-of-the-box,"When importing this project into eclipse there are a few issues:
- The `extTest` subproject apparently doesn't depend on the `mockito` main project
- `org.mockito.AnnotationsAreCopiedFromMockedTypeTest` indirectly references `java.nio.file.Path`, however the project's compiler level is set to 1.6. (`Path` was added in 1.7)
- The encoding for the eclipse project isn't set to UTF-8 by default
- The subprojects' project names aren't prepended with 'mockito'. This creates a lot of workspace clutter

Am I doing something wrong or is the project not set up properly?
I think I'm able to fix *some* of these things, and I'll be happy to provide a PR for this.","> The extTest subproject apparently doesn't depend on the mockito main project

:+1: 

> org.mockito.AnnotationsAreCopiedFromMockedTypeTest indirectly references java.nio.file.Path, however the project's compiler level is set to 1.6. (Path was added in 1.7)

I don't see this is in the source code. In what way is it depending on it?

> The encoding for the eclipse project isn't set to UTF-8 by default

:+1: 

> The subprojects' project names aren't prepended with 'mockito'. This creates a lot of workspace clutter

I would prefer to not make changes here if we can. Can we improve the names with some Eclipse specific files maybe? Also, could you post a screenshot of what your workspace looks like?

Thanks! =||= > I don't see this is in the source code. In what way is it depending on it?

Eclipse reports that [this](https://github.com/mockito/mockito/blob/7a3569e987c16bc74e21329e95f9954e40b38cfb/src/test/java/org/mockito/AnnotationsAreCopiedFromMockedTypeTest.java#L31) line indirectly references it from required `.class`-files.
I did some digging, `org.assertj.core.api.Assertions` from assertj-core [uses](https://github.com/joel-costigliola/assertj-core/blob/17de1de155e6d44da32aac825b19041c839bc790/src/main/java/org/assertj/core/api/Assertions.java#L27) it.

> Can we improve the names with some Eclipse specific files maybe?

Certainly! I'll create a PR.

> Also, could you post a screenshot of what your workspace looks like

![Cluttered workspace](https://i.imgur.com/91JOjTc.png)

What about the subproject not depending correctly? Seems to me that that's an issue that should come forward during build time too. =||= Did some more digging, [this](https://github.com/mockito/mockito/blob/aa3775ac1178b8e97435484360516a5d69d5e333/subprojects/extTest/extTest.gradle#L19) line might be causing the weird dependency. I of course have never published the core to a local maven repository, which causes this dependency to fail. Is there a reason why we can't just depend on the subproject? =||= > I did some digging, org.assertj.core.api.Assertions from assertj-core uses it.

We use these APIs in a lot of tests, so I think Eclipse is in the wrong here.

> I of course have never published the core to a local maven repository, which causes this dependency to fail.

When you compile `extTest`, it should publish publish Mockito core to your local maven repository per https://github.com/mockito/mockito/blob/aa3775ac1178b8e97435484360516a5d69d5e333/subprojects/extTest/extTest.gradle#L8-L12

However, we probably should just fix this and use the same method as in our other subprojects: https://github.com/mockito/mockito/blob/aa3775ac1178b8e97435484360516a5d69d5e333/subprojects/junit-jupiter/junit-jupiter.gradle#L9 =||= > We use these APIs in a lot of tests, so I think Eclipse is in the wrong here.

How can eclipse be wrong? It's a fact that `java.nio.file.Path` wasn't there yet in 1.6.
Upon further investigation I found that eclipse doesn't even try to build the whole project because of this missing dependency. This makes it look like it's only that line, but it's actually the whole project that can't be build because of it.
I think that because most people don't actually use a 1.6 JDK while developing/testing this one slipped through. `assertj-core` does mention in it's readme that it requires at least 1.7.
I see 2 simple solutions:
- Put the tests in their own subproject with compiler level 1.7 (or 1.8).
- Raise the core compiler level to 1.7 (which is probably a no-go).

> However, we probably should just fix this and use the same method as in our other subprojects: 

I'll include it in my PR. =||= We locally build with JDK 1.8 and then enforce 1.6 compatibility with https://github.com/mockito/mockito/blob/0c4e494a16141a65f22605a57382a222040f340b/gradle/root/java-compatibility-check.gradle =||= I tried building the project while using obviously non-1.6 compatible code to test if that test actually runs, but I discovered I can't actually build the project. Something with checkstyle not being able to process the files.
Maybe animal sniffer doesn't check included dependencies correctly? =||= This was addressed in #1573. =||= ",0
1576,1551,ClassCastException with generics and smart nulls,"Hello. 

I am trying to migrate my JUnit4 tests (Java version is 1.8.0_74) from Mockito v1.10.19 to v2.0.10 and I have the following exception: 

```java
java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$220764719 cannot be cast to com.solanteq.solar.fp.dao.scheme.MockitoTest$Entity
```

when I mock my objects using `Answers.RETURNS_SMART_NULLS`.

However, when I change the answer to default, or change the stubbing to do..when approach, the exception disappears. Before version upgrade, everything worked fine.

Test case to reproduce the issue: 
 
```java
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Answers;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;

@RunWith(MockitoJUnitRunner.class)
public class MockitoTest {

    @Mock(answer = Answers.RETURNS_SMART_NULLS)
    private ConcreteDao concreteDao;

    @Before
    public void setUp() {
        Mockito.when(concreteDao.findById(1L))
                .thenReturn(new Entity(1L));
    }

    @Test
    public void testMockito() {
        assertEquals(1L, concreteDao.findById(1L).id);
    }

    public static class AbstractDao<T> {
        T findById(final long id) {
            throw new UnsupportedOperationException(""Not implemented"");
        }
    }

    public static class Entity {
        private final long id;

        public Entity(long id) {
            this.id = id;
        }
    }

    public static class ConcreteDao extends AbstractDao<Entity> {
    }
}
```

Thanks in advance.
","Thank you for reporting! Based on your test I created a minimal test that reproduces the issue: #1552. I marked this ticket with ""please contribute"" hoping you or someone from the community can help. The issue is tricky and it is caused by Java generics combined with smart nulls. =||= Hello !

If you're agree with that, I can work on this. I've start watching how it works and how it can be solve. I  also think that it can be pretty tricky but I can even try ;) ! =||= Feel free to! =||= ",0
1582,1577,IllegalAccessError on Java 11 when using module path,"Mockito cannot mock package private class when tests running with module path. It trying to use reflection and defineClass method by default and this does not work on Java 11. I've found PR #1355 and tried to use org.mockito.internal.simulateJava11 system property but it doesn't works either.

I'm using:
Java 11 (release), Maven 3.6.0, surefire-maven-plugin 3.0.0-M3, JUnit 5.3.2, Mockito 2.23.4 (2.23.11 have same issue).

With this configuration mockito and byte buddy are included in classpath, my modular jar is included in module path, and module system is configured correctly (I suppose :)).

You can check this on minimal sample project: [mockito-java11-jpms-example.zip](https://github.com/mockito/mockito/files/2712255/mockito-java11-jpms-example.zip) - just run `mvn clean test`.


Stacktrace
```
Underlying exception : java.lang.IllegalStateException: Error invoking java.lang.invoke.MethodHandles$Lookup#defineClass                                                                              
        at test.marx.mockito/test.marx.mockito.ServiceTest.testMockito(ServiceTest.java:17)                                                                                                           
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)                                                                                                             
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)                                                                                           
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)                                                                                   
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)                                                                                                                                 
        at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:532)                                                                                                     
        at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)                                                                                                    
        at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:171)                                                                  
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)                                                                                      
        at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:167)                                                                           
        at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:114)                                                                                    
        at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:59)                                                                                     
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$4(NodeTestTask.java:108)                                                                             
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)                                                                                      
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:98)                                                                                       
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:74)                                                                                                  
        at java.base/java.util.ArrayList.forEach(ArrayList.java:1540)                                                                                                                                 
        at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)                                      
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$4(NodeTestTask.java:112)                                                                             
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)                                                                                      
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:98)                                                                                       
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:74)                                                                                                  
        at java.base/java.util.ArrayList.forEach(ArrayList.java:1540)                                                                                                                                 
        at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)                                      
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$4(NodeTestTask.java:112)                                                                             
        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)                                                                                      
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:98)                                                                                       
        at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:74)                                                                                                  
        at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)                                         
        at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)                                                                          
        at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)                                                                              
        at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220)                                                                                                         
        at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188)                                                                                                
        at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202)                                                                                          
        at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181)                                                                                                         
        at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)                                                                                                         
        at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:150)                                                                               
        at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:124)                                                                                       
        at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:384)                                                                                       
        at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:345)                                                                                                    
        at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:126)                                                                                                               
        at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:418)                                                                                                                  
Caused by: java.lang.IllegalStateException: Error invoking java.lang.invoke.MethodHandles$Lookup#defineClass                                                                                          
        at net.bytebuddy.dynamic.loading.ClassInjector$UsingLookup$Dispatcher$ForJava9CapableVm.defineClass(ClassInjector.java:1686)                                                                  
        at net.bytebuddy.dynamic.loading.ClassInjector$UsingLookup.injectRaw(ClassInjector.java:1415)                                                                                                 
        at net.bytebuddy.dynamic.loading.ClassInjector$AbstractBase.inject(ClassInjector.java:111)                                                                                                    
        at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$UsingLookup.load(ClassLoadingStrategy.java:466)                                                                                         
        at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:100)                                                                                           
        at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:5623)                                                                                                             
        at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:129)                                                                            
        at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)                                                                          
        at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)                                                                          
        at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:152)                                                                                                                                   
        at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:365)                                                                                                              
        at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:174)                                                                                                                                   
        at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:376)                                                                                                              
        at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)                                                                       
        at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)                                                                      
        at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)                                                                          
        at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)                                                                                          
        at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)                                                                                                                            
        at org.mockito.internal.MockitoCore.mock(MockitoCore.java:69)                                                                                                                                 
        at org.mockito.Mockito.mock(Mockito.java:1896)                                                                                                                                                
        at org.mockito.Mockito.mock(Mockito.java:1805)                                                                                                                                                
        ... 42 more                                                                                                                                                                                   
Caused by: java.lang.IllegalAccessError: class org.mockito.codegen.IDependency$MockitoMock$1828864830 cannot access its superinterface test.marx.mockito.Service$IDependency (org.mockito.codegen.IDependency$MockitoMock$1828864830 is in unnamed module of loader 'app'; test.marx.mockito.Service$IDependency is in module test.marx.mockito of loader 'app')                                            
        at java.base/java.lang.ClassLoader.defineClass1(Native Method)                                                                                                                                
        at java.base/java.lang.System$2.defineClass(System.java:2123)                                                                                                                                 
        at java.base/java.lang.invoke.MethodHandles$Lookup.defineClass(MethodHandles.java:962)                                                                                                        
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)                                                                                                             
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)                                                                                           
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)                                                                                   
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)                                                                                                                                 
        at net.bytebuddy.dynamic.loading.ClassInjector$UsingLookup$Dispatcher$ForJava9CapableVm.defineClass(ClassInjector.java:1682)                                                                  
        ... 62 more                                                                                                                                                                                   ```
","you have to open your module to the unnamed module where mockito is set to make this work.  =||= @raphw I'm using this configuration:

```
            <plugin>
                <artifactId>maven-surefire-plugin</artifactId>
                <configuration>
                    <!-- test code needs access to package private level, so we use add-opens -->
                    <argLine>
                        --add-opens test.marx.mockito/test.marx.mockito=ALL-UNNAMED
                    </argLine>
                    <systemPropertyVariables>
                        <!-- this hidden property force mockito to use method lookup -->
                        <org.mockito.internal.simulateJava11>true</org.mockito.internal.simulateJava11>
                    </systemPropertyVariables>
                </configuration>
            </plugin>
```

Maybe I'm missing something... 

BTW, adding `--add-opens java.base/java.lang=ALL-UNNAMED` does not helps too.  =||= I see what the problem is now. Java considers all packages that belong to a named module to be sealed. Therefore, our mock creation strategy is oversensitive and defines the mock in another package such that the super type is no longer visible.

Let me look into this for a bit. We will fix this in an upcoming release. =||= @marx-freedom Could you check out this branch, build Mockito and see if it works? =||= @raphw I've tried it today, but it doesn't works as expected.
With -Dorg.mockito.internal.simulateJava11=true test throws exception:

```
org.mockito.exceptions.base.MockitoException: 

Mockito cannot mock this class: interface test.marx.mockito.Service$IDependency.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : Oracle Corporation
JVM vendor version : 11+28
JVM name           : OpenJDK 64-Bit Server VM
JVM version        : 11+28
JVM info           : mixed mode
OS name            : Windows 10
OS version         : 10.0


Underlying exception : java.lang.IllegalStateException: Error invoking java.lang.invoke.MethodHandles$Lookup#defineClass
	at test.marx.mockito/test.marx.mockito.ServiceTest.testMockito(ServiceTest.java:17)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:532)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:171)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:167)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:114)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:59)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$4(NodeTestTask.java:108)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:98)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:74)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$4(NodeTestTask.java:112)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:98)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:74)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$4(NodeTestTask.java:112)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:98)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:74)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220)
	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188)
	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:150)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:124)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:384)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:345)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:126)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:418)
Caused by: java.lang.IllegalStateException: Error invoking java.lang.invoke.MethodHandles$Lookup#defineClass
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingLookup$Dispatcher$ForJava9CapableVm.defineClass(ClassInjector.java:1686)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingLookup.injectRaw(ClassInjector.java:1415)
	at net.bytebuddy.dynamic.loading.ClassInjector$AbstractBase.inject(ClassInjector.java:111)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$UsingLookup.load(ClassLoadingStrategy.java:466)
	at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:100)
	at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:5623)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:129)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:152)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:365)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:174)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:376)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:62)
	at org.mockito.Mockito.mock(Mockito.java:1896)
	at org.mockito.Mockito.mock(Mockito.java:1805)
	... 42 more
Caused by: java.lang.IllegalAccessError: class org.mockito.codegen.IDependency$MockitoMock$2018315156 cannot access its superinterface test.marx.mockito.Service$IDependency (org.mockito.codegen.IDependency$MockitoMock$2018315156 is in unnamed module of loader 'app'; test.marx.mockito.Service$IDependency is in module test.marx.mockito of loader 'app')
	at java.base/java.lang.ClassLoader.defineClass1(Native Method)
	at java.base/java.lang.System$2.defineClass(System.java:2123)
	at java.base/java.lang.invoke.MethodHandles$Lookup.defineClass(MethodHandles.java:962)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingLookup$Dispatcher$ForJava9CapableVm.defineClass(ClassInjector.java:1682)
	... 62 more

```


Should I use system property org.mockito.internal.simulateJava11 or there is any other setup tasks I'm missing?


One little idea. I've wrote something like this recently, it works with module path and custom module layers. But I've tested it only for custom classes, not in standard packages like `java.*`.  

```
class SomeFactory {

    public <C> C createDynamicSubclass(Class<C> clazz) {

        getClass().getModule().addReads(clazz.getModule());

        var dynamicClass = new ByteBuddy()
                .subclass(clazz, ConstructorStrategy.Default.IMITATE_SUPER_CLASS)
                .defineField(...)
                ...
                .make()
                .load(clazz.getClassLoader(), ClassLoadingStrategy.UsingLookup.of(
                        MethodHandles.privateLookupIn(clazz, MethodHandles.lookup()))
                )
                .getLoaded();

        return dynamicClass.getConstructor(new Class<?>[] {}).newInstance();
    }
```




 =||= I have worked quite a bit on this over the last days. I just checked in several changes in the last hour. I also managed to write a bunch of unit tests now and hope that it works as I expect it. =||= @raphw Thank you very much! Mockito 2.23.16 works perfectly, problem solved. =||= ",0
1585,1584,ClassLoader built by mockito is not able to load declared types in the hierarchy in OSGi,"We develop in OSGi environment and we are using latest version of mockito available on maven central 2.23.4

We got an issue when we mock classes given to guice (sisu) for injection. Sisu/Guice analyse all declared fields and methods for the input type and its super classes to built a sort of index of known types. In OSGi it fails with ClassNotFoundException on mocked classes. The reason is that the mocked class built with `SubclassBytecodeGenerator` has a classloader not able to load types reachable only by supertypes. In OSGi this does not happen because each class has associated the classloader from which is loaded. This guarantee that the class is able to reach/load each type it declares (by its methods, fields or annotations).

Example:

- Bundle A
`foo.Class1` has a protected method that returns foo.impl.OtherClass
`foo.impl.OtherClass`

- Bundle B (imports only `foo` package from bundle A)
`acme.Class2 extends Class1`

`Mockito.mock(foo.Class1).getDeclaredMethods()` will fails. To fix this issue `SubclassBytecodeGenerator` should compose a classloader (`MultipleParentClassLoader`) with also the classloader of superclass the mocked type (`features.mockedType`).",@raphw FYI =||= ,0
1588,1587,InjectingAnnotationEngine does an unnecessary loop.,"processInjectMocks method of InjectingAnnotationEngine does unnecessary work. It might call injectMocks several times while it is sufficient to call injectMocks once.

    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {
        Class<?> classContext = clazz;
        while (classContext != Object.class) {
            injectMocks(testInstance);
            classContext = classContext.getSuperclass();
        }
    }

Inside, injectMocks loops classes by himself.

    public void injectMocks(final Object testClassInstance) {
        Class<?> clazz = testClassInstance.getClass();
        Set<Field> mockDependentFields = new HashSet<Field>();
        Set<Object> mocks = newMockSafeHashSet();

        while (clazz != Object.class) {
            new InjectMocksScanner(clazz).addTo(mockDependentFields);
            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);
            onInjection(testClassInstance, clazz, mockDependentFields, mocks);
            clazz = clazz.getSuperclass();
        }

        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);
    }

Why not delete the unnecessary loop?",nan,0
1596,1578,UnfinishedMockingSessionException with inner test classes,"This appears to be a regression from 1.10.19 and 2.x-beta since it was reported as fixed in #353, but I was unable to get the sample test class to work in the release/2.x branch (also reported to fail in 2.13.0, 2.1.0-beta.125, and master too). The root cause is JUnitRule attempting to add a UniversalTestListener a second time to a ThreadSafeMockingProcess.

Sample Test class
```
@RunWith(HierarchicalContextRunner.class)
public class HierarchicalMockitoTest {
    @Rule
    public MockitoRule mockitoRule = MockitoJUnit.rule();

    @Mock
    private Runnable runnable;

    public class Context {
        @Test
        public void test() throws Exception {
            runnable.run();
        }
    }
}
```

Exception Thrown
```
org.mockito.exceptions.misusing.UnfinishedMockingSessionException: 
Unfinished mocking session detected.
Previous MockitoSession was not concluded with 'finishMocking()'.
For examples of correct usage see javadoc for MockitoSession class.
	at org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:42)
	at org.mockito.internal.junit.JUnitRule$1.evaluateSafely(JUnitRule.java:52)
	at org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:43)
	at de.bechte.junit.runners.context.statements.StatementExecutor.execute(StatementExecutor.java:28)
	at de.bechte.junit.runners.context.processing.MethodExecutor.run(MethodExecutor.java:83)
	at de.bechte.junit.runners.context.processing.MethodExecutor.run(MethodExecutor.java:57)
	at de.bechte.junit.runners.context.statements.RunChildren.evaluate(RunChildren.java:38)
	at de.bechte.junit.runners.context.statements.RunAll.evaluate(RunAll.java:27)
	at de.bechte.junit.runners.context.statements.StatementExecutor.execute(StatementExecutor.java:28)
	at de.bechte.junit.runners.context.HierarchicalContextRunner.run(HierarchicalContextRunner.java:134)
	at de.bechte.junit.runners.context.processing.ContextExecutor.run(ContextExecutor.java:26)
	at de.bechte.junit.runners.context.processing.ContextExecutor.run(ContextExecutor.java:15)
	at de.bechte.junit.runners.context.statements.RunChildren.evaluate(RunChildren.java:38)
	at de.bechte.junit.runners.context.statements.RunAll.evaluate(RunAll.java:27)
	at de.bechte.junit.runners.context.statements.StatementExecutor.execute(StatementExecutor.java:28)
	at de.bechte.junit.runners.context.HierarchicalContextRunner.run(HierarchicalContextRunner.java:134)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
```

I have a fix in progress which involves lazy initialization (
https://github.com/mouyang/mockito/commit/540ad11d5a0d4066a73b3e46a932733d7ed816df).  I haven’t submitted a PR yet because I’m waiting for the library I used to reproduce the issue to make a new release with a required fix bechte/junit-hierarchicalcontextrunner#32. Also I need to clean up the commit to use reference this issue instead of 353. I suppose I can move forward with a PR if there was a way to reproduce the issue without using that library but I haven’t thought of a way to do that.

Thanks to @UrsMetz for verifying the regression and providing a sample test class.",nan,0
1596,353,@Mock-annotated fields are null for inner test classes (e.g. when using junit-hierarchicalcontextrunner),"Using the two current versions of Mockito (1.10.19 and 2.x-beta) and the JUnit-Mockito-Rule together with JUnit extensions like [junit-hierarchicalcontextrunner](https://github.com/bechte/junit-hierarchicalcontextrunner/) that use inner classes causes fails with `NullPointerException`s:

``` java
@RunWith(HierarchicalContextRunner.class)
public class HierarchicalMockitoTest {
    @Rule
    public MockitoRule mockitoRule = MockitoJUnit.rule();

    @Mock
    private Runnable runnable;

    public class Context {
        @Test
        public void test() throws Exception {
            runnable.run();
        }
    }
}
```

With older 1.x versions that didn't not contain the new JUnit rule API (e.g. where `MockitoJUnitRule` was not deprecated yet) the above test pass. I guess the reason is that the old rule's constructor had the current test instance passed in. In newer versions the rule uses the `target` from `org.junit.rules.MethodRule#apply()` which in this example is an instance of `HierarchicalMockitoTest.Context` so the `@Mock`-annotated fields of the outer classes are not seen and the mocks won't get instantiated.","@UrsMetz This is not yet supported, feel free to craft a pull request for that ;)
 =||= @bric3 I will look into that and eventually craft a pull request.

Maybe it was not clear from my original post: This is a regression because when updating to the latest 1.x release tests like the one above will fail: when though the constructor of `MockitoJUnitRule` gets the target (e.h. `this`) passed it doesn't use it in the newest version and as a consequence the test fails with a `NullPointerExeception`. Earlier version used the parameter so that the mocks got initiated and the test was green. So even when the old now deprecated API is used tests start to fail after updating Mockito. So maybe a back port to the 1.x branch should be considered too?
 =||= Oh I didn't get that indeed. Actually the this was removed because JUnit passes the target when the rule is applied see [MockitoJunitRule](https://github.com/bric3/mockito/blob/master/src/main/java/org/mockito/junit/MockitoJUnitRule.java#L39-L39). With these _exotic_ JUnit runners I'm not sure how to solve this in a proper way, maybe adding a hierarchical mockito rule.
 =||= Or maybe with such exotic runner, the PR could be on their project ? https://github.com/bechte/junit-hierarchicalcontextrunner/
 =||= I was also thinking whether it is not a issue with the junit-hierarchicalcontextrunner. I will investigate this and either raise an issue over there (and reference this issue) or take a stab at a fix and pull request for Mockito. I'm not one hundred percent sure whether it worked in all corner case with the old version where the parameter of `MockitoJUnitRule` was used instead of the parameter `target` of the `apply` method of the rule. I will also look into that.
 =||= @bric3 After playing a bit around with the example above and different versions of Mockito (pre 1.10.17 where the internal implementation of the JUnit rule changed and >= 1.10.17) I figured out that only some corner cases worked in the old version (exactly those we are using right now in my team at work); now different case work and the old cases stopped working. As you said it seems to be an issue with junit-hierarchicalcontextrunner. I raised the issue bechte/junit-hierarchicalcontextrunner#26 over there.
 =||= @UrsMetz Cool if you're ok with that let's close the issue there ?
 =||= Sure, I'm closing it.
 =||= Cool thanks :)
 =||= I think there is still a bug with JUnitRule.  I built the master branch of the project which includes @UrsMetz's pull request in that project and ran the sample test class at the top, but I received the following exception prior to reaching the code that causes the NullPointerException.  The root cause is JUnitRule attempting to add a UniversalTestListener a second time to a ThreadSafeMockingProcess (Mockito currently does not readily provide the full stack trace at this time).

```
org.mockito.exceptions.misusing.UnfinishedMockingSessionException: 
Unfinished mocking session detected.
Previous MockitoSession was not concluded with 'finishMocking()'.
For examples of correct usage see javadoc for MockitoSession class.
	at org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:42)
	at org.mockito.internal.junit.JUnitRule$1.evaluateSafely(JUnitRule.java:52)
	at org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:43)
	at de.bechte.junit.runners.context.statements.StatementExecutor.execute(StatementExecutor.java:28)
	at de.bechte.junit.runners.context.processing.MethodExecutor.run(MethodExecutor.java:83)
	at de.bechte.junit.runners.context.processing.MethodExecutor.run(MethodExecutor.java:57)
	at de.bechte.junit.runners.context.statements.RunChildren.evaluate(RunChildren.java:38)
	at de.bechte.junit.runners.context.statements.RunAll.evaluate(RunAll.java:27)
	at de.bechte.junit.runners.context.statements.StatementExecutor.execute(StatementExecutor.java:28)
	at de.bechte.junit.runners.context.HierarchicalContextRunner.run(HierarchicalContextRunner.java:134)
	at de.bechte.junit.runners.context.processing.ContextExecutor.run(ContextExecutor.java:26)
	at de.bechte.junit.runners.context.processing.ContextExecutor.run(ContextExecutor.java:15)
	at de.bechte.junit.runners.context.statements.RunChildren.evaluate(RunChildren.java:38)
	at de.bechte.junit.runners.context.statements.RunAll.evaluate(RunAll.java:27)
	at de.bechte.junit.runners.context.statements.StatementExecutor.execute(StatementExecutor.java:28)
	at de.bechte.junit.runners.context.HierarchicalContextRunner.run(HierarchicalContextRunner.java:134)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
``` =||= The HierarchicalMockitoTest fails even with @UrsMetz's fix for [bechte/junit-hierarchicalcontextrunner#26](https://github.com/bechte/junit-hierarchicalcontextrunner/issues/26).  Since a new version of the dependency has not been released, the test failure can be demonstrated by following the steps below (after a new version of the dependency has been released, building my feature branch will be sufficient):

1. Build and install (requires Maven) https://github.com/bechte/junit-hierarchicalcontextrunner/tree/master.  This pulls in @UrsMetz's fix with a version 4.12.2-SNAPSHOT.
1. Clone https://github.com/mouyang/mockito/tree/mouyang-gh-353.  In build.gradle, change [this line](https://github.com/mockito/mockito/compare/release/2.x...mouyang:mouyang-gh-353?expand=1#diff-c197962302397baf3a4cc36463dce5eaR81) to `testCompile 'de.bechte.junit:junit-hierarchicalcontextrunner:4.12.2-SNAPSHOT'` to match the artifact produced previously.
1. `./gradlew build` as-is results in a pass.
1. `./gradlew build` with my change to JUnitRule reverted results in HierarchicalJUnitRuleTest.java failing due to the UnfinishedMockingSessionException I cited previously.

This issue would have happened with any Runner that enabled hierarchical test classes ([such as the NitorCreations NestedRunner](https://github.com/NitorCreations/CoreComponents/tree/master/junit-runners)).  JUnitRule overwrites the MockitoSession instantiated in the outer call in the nested case; this seems wrong and it seems reasonable to augment the existing session with the mocks from the inner class.

I haven't submitted a PR at this time, eventhough the test suite passed, because I have no idea if my changes are oblivious to other exception cases.  But I would like to re-open a discussion on this ticket since I still believe this is a legitimate issue.  Thanks. =||= @mouyang I had a quick look at it (I don't know why but I had to tweak `gradle.build` in your repo a bit further so that the `junit-hierarchicalcontextrunner` SNAPSHOT version in my local Maven repository was found as a `testCompile` dependency: I had to add a top level `repositories` section with `mavenLocal()` in it).

I can reproduce your error when using some 2.x versions of Mockito (I tried 2.13.0, 2.1.0-beta.125, and the master).
With a Mockito version 1.x and 2.0.0-beta.118 I cannot reproduce the failure.
So at the time when I was working on this it worked(tm) ;-), but with the current 2.x version it is broken. So I think you're right that there is an issue (please note that I'm not a maintainer of Mockito. I just saw that there was some activity on an old issue I once created). =||= From your clarifications it makes more sense to keep this ticket closed, and for me to create a new ticket for my issue as it is clearly different. Thanks @UrsMetz! =||= ",0
1602,1595,Gradle javadoc plugin fails with latest JDK 11 release ,The javadoc plugin fails with a status code 1 on current JVM 11.0.2 releases.,My machine is still on JVM 11.0.1. Going to have to go through Travis this time around to debug this issue... =||= ,0
1612,357,ClassCastExceptions with JDK9 javac,"JDK 9 fixes a javac bug ([JDK-8058199](https://bugs.openjdk.java.net/browse/JDK-8058199)) that was causing checkcast intructions to be skipped. Previously javac used the parameter types of a method symbol's erased type as targets when translating the arguments. In JDK 9, javac has been fixed to use the inferred types as targets. The fix causes additional checkcasts to be generated if the inferred types do not have the same erasure.

The fix breaks Mockito answer strategies that pick types based on the erased method signature's return type, and causes tests to fail with ClassCastExceptions when compiled with the JDK 9 javac.

---

Example 1

``` java
class Super<T> {
  T g() {
    return null;
  }
}

class Sub extends Super<Boolean> {}
```

``` java
@Mock Sub s;
when(s.g()).thenReturn(false);
```

compiled with javac 8

```
INVOKEVIRTUAL Sub.g ()Ljava/lang/Object;
INVOKESTATIC org/mockito/Mockito.when (Ljava/lang/Object;)Lorg/mockito/stubbing/OngoingStubbing;
```

compiled with javac 9

```
INVOKEVIRTUAL Sub.g ()Ljava/lang/Object;
CHECKCAST java/lang/Boolean
INVOKESTATIC org/mockito/Mockito.when (Ljava/lang/Object;)Lorg/mockito/stubbing/OngoingStubbing;
```

The erased return type of `Super.g` is `Object`, but the expected return type of `Sub.g` is `Boolean`. If the answer strategy returns `Object` the checkcast fails.

---

Example 2

``` java
class Foo {
  <T> T getFirst(Iterable<T> xs) { return xs.iterator().next(); }
}
```

``` java
@Mock Foo f;
Iterable<Boolean> it = Arrays.asList(false);
when(f.getFirst(it)).thenReturn(false)
```

compiled with javac 8

```
INVOKEVIRTUAL Foo.getFirst (Ljava/lang/Iterable;)Ljava/lang/Object;
INVOKESTATIC org/mockito/Mockito.when (Ljava/lang/Object;)Lorg/mockito/stubbing/OngoingStubbing;
```

compiled with javac 9

```
INVOKEVIRTUAL Foo.getFirst (Ljava/lang/Iterable;)Ljava/lang/Object;
CHECKCAST java/lang/Boolean
INVOKESTATIC org/mockito/Mockito.when (Ljava/lang/Object;)Lorg/mockito/stubbing/OngoingStubbing;
```

The erased return type of `Foo.getFirst` is `Object`, but the inferred return type of `getFirst(Iterable<Boolean>)` is `Boolean`. If the answer strategy returns `Object` the checkcast fails.

---

The first example could be fixed by using [`GenericMetadataSupport`](https://github.com/mockito/mockito/blob/9b838461abf93670d123109f7e3d8871f182767a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java) in all of the answer implementations instead of `invocation.getMethod().getReturnType()`.

It gets more difficult if the mock's type is an instantiation of a generic type (e.g. `@Mock Foo<Bar> x;`), since the field's type arguments get dropped. I think fixing that would require adding support for mocking types, not just classes.

For the second example, returning the right answer requires considering the generic signature of the invoked method, and performing type inference using the argument types. Unfortunately the runtime type of the argument is going to be a raw `Iterable` and the inference depends on knowing it's `Iterable<Boolean>`, so I'm not sure what to do there.","This problem is also the cause for https://github.com/mockito/mockito/issues/304
 =||= The test from #304 passes on current master https://github.com/mockito/mockito/commit/d6480148b28defa299b25230abe7f463f850350a so maybe this issue is also solved?
 =||= Closing this issue as it seems to be resolved.
 =||= I don't think this is fixed, both of the examples in the original report still fail with `v2.0.78-beta` and jdk `9-ea+116`.

Full repro: https://gist.github.com/cushon/b5c5e3995e9ad68ed3df8fd8626daf09

```
java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1914109206 (in module: Unnamed Module) cannot be cast to java.lang.Boolean (in module: java.base)
```

```
java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1914109206 (in module: Unnamed Module) cannot be cast to java.lang.Boolean (in module: java.base)
```
 =||= Thanks, I check this out prior to release.
 =||= Sorry - do you mean that you verified it's fixed at head, or that you will take another look before the next release? If it's the second one, do you mind re-opening the issue to make sure it doesn't get lost? I'm seeing the same behaviour at head. 
 =||= @cushon I think it's more that we'll look at it ;)

Typically using `GenericMetadataSupport` for `@Mock` fields has been on my mind for some time already. However note that using `mock()`style would not work unless we use some `TypeReference` trick.

> It gets more difficult if the mock's type is an instantiation of a generic type (e.g. @Mock Foo<Bar> x;), since the field's type arguments get dropped. I think fixing that would require adding support for mocking types, not just classes.

@raphw I think we should not delay 2.0 for that one, JDK9 is not yet out. We can still release fixes later.
 =||= @cushon I have just completed testing Mockito against Java 9 and everything works as expected. The examples that you provide work without any problems.

Thinking about how this would work, also makes sense. If not configured to return a different value, Mockito returns `null` during the configuration what passes the _checkcast_. Only if a user specifies an illegal value to the generic signature (heap pollution), a problem occurs but this is not really Mockito's responsibility.

Did you test a recent version?
 =||= > If not configured to return a different value, Mockito returns null during the configuration what passes the checkcast.

What about `RETURNS_SMART_NULLS` and `RETURNS_DEEP_STUBS`?
 =||= Ah, of course. Sorry for that, I did another mistake in my test. This problem is actually already reproduceable on recent versions of Java 8.
 =||= Ok, I have now finally looked into this in detail. There are three scenarios:
1. For generic return types, it suffices to resolve those return types properly by using `GenericMetadataSupport`. This can simply be added, I already tried this.
2. For locally inferred generic return types, there is not much we can do. For example, if we mocked some method `public <T> T foo() { ... }` there is no information preserved within the method that would allow us to know the expected type for `T`. We could only parse any method from where `foo` was called to contextually determine the return type. This would add a whole new layer of complexity to Mockito and I do not think we should support this case. We should probably add a warning to the docs.
3. For generic fields, we could find ways to preserve this information. We should probably refactor the `RETURN_SMART_NULLS` option to allow its binding to a generic base type rather than using the mock instance's (raw) type.
 =||= #639 builds on Java 9 which still has 3 test failures (but they seem to be related to `AssertJ` rather than our code). @cushon could you check out that branch and test if your usecases have been fixed with JDK9?
 =||= > could you check out that branch and test if your usecases have been fixed with JDK9?

@TimvdLippe it has not been fixed, I turned the repro into a unit test in #664.

Those tests fail in the jdk9 branch:

```
org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest > inferred_generic_type FAILED
    java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1081761404 (in module: Unnamed Module) cannot be cast to java.lang.Boolean (in module: java.base)
        at org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest.inferred_generic_type(ReturnsSmartNullsTest.java:122)

org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest > generic_return_type_erasure FAILED
    java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1081761404 (in module: Unnamed Module) cannot be cast to java.lang.Boolean (in module: java.base)
        at org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest.generic_return_type_erasure(ReturnsSmartNullsTest.java:105)
```
 =||= > For generic return types, it suffices to resolve those return types properly by using `GenericMetadataSupport`. This can simply be added, I already tried this.

That sounds good to me. I skipped the original `class Sub extends Super<Boolean> {}` example in #664 because it's no longer broken by the JDK9 javac change; it hasn't worked since 7fabd84fdfb2f80f8c135fe3865263c684c0d4e7. Is it worth splitting this into a separate bug?

``` java
    @Test
    public void generic_return_type_checkcast() throws Throwable {
        class Super<T> {
            T get() {
                return null;
            }
        }

        class Sub extends Super<Boolean> {}

        Sub sub = Mockito.mock(Sub.class, Answers.RETURNS_SMART_NULLS);
        Mockito.when(sub.get()).thenReturn(true);
        assertTrue(sub.get());
    }
```

```
generic_return_type_checkcast FAILED
    java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1200321394 cannot be cast to java.lang.Boolean
        at org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest$1Sub$MockitoMock$412017289.get(Unknown Source)
        at org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest$1Sub$MockitoMock$412017289.get(Unknown Source)
        at org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest.generic_return_type_checkcast(ReturnsSmartNullsTest.java:94)
```
 =||= Careful as `GenericMetadataSupport` requires more CPU and memory.
 =||= We might be able to get around these issues with a solution like #643 
 =||= Note that this also fails with Eclipse's Java compiler (running under a Java 8 JRE) in Eclipse Neon (4.5), with the same ClassCastException. =||= @cushon @raphw @ePaul What is the status of this issue?
**Java 9 has been released today!**

I am getting the following error in all my tests that use Mockito:

```java
java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1574589819 cannot be cast to org.hibernate.Session
``` =||= As said, there is not much we can do. The information of the required type lies outside of the class we instrument. We simply do not have this information available. I am afraid that this chained mocking is something we cannot fully support and you will have to mock your method chanes manually to supply this information.  =||= @raphw Thank you!

Well, does it mean that mockito will never work with Java 9? Omg, it's an epic disaster... :(  =||= Only when returning automatic mocks from mocks with generic return types, maybe we should add a warning for this to make the error more intuitive. =||= @raphw Yes, the warning would be very helpful. 
So, do I correctly understand that people will need to rewrite their tests in order to upgrade to Java 9? Probably a lot of tests?   =||= There's an Error Prone check that detects this problem at compile-time: http://errorprone.info/bugpattern/MockitoCast. It can also be run as a [refactoring](http://errorprone.info/docs/patching) to add work-arounds to affected code. =||= ",0
1617,1615,"Issue with mocking type in ""java.util.*"", Java 12","After upgrading Mockito from `2.23.4` to `2.24.0` we can't run JUnit 5's tests anymore. The error message reads:
```
    org.mockito.exceptions.base.MockitoException: 
    Mockito cannot mock this class: interface java.util.concurrent.locks.Lock.
    Mockito can only mock non-private & non-final classes.
    If you're not sure why you're getting this error, please report to the mailing list.
```
Find the complete stacktrace here: https://travis-ci.org/junit-team/junit5/jobs/488684907

Note, that using Mockito `2.24.0` using Java 11 (and 13 locally) did work out! See this build matrix: https://travis-ci.org/junit-team/junit5/builds/488684905

Workaround: revert to Mockito `2.23.4` for the time being via https://github.com/junit-team/junit5/commit/754f1eb0f106ab043d79de546d49769690a731b6
","Suspiciously, the type is again in the `java.util` package. That leads me to believe any type definitive in there can't be mocked. =||= > That leads me to believe any type definitive in there can't be mocked.

Using `2.24.0`. It works with the older version. =||= The package should not be an issue, but I'll check.  =||= There is a dot missing after the package name.... =||= Haha well spotted! Might be a simple String concatenation typo. =||= This is probably the mistake: https://github.com/mockito/mockito/blob/00cc06b387c3af8aaaed3a14fcb38df7d69db6c1/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L101

Should be:

```java
 typeName = InjectionBase.class.getPackage().getName() +""."" + features.mockedType.getSimpleName();
``` =||= Yes, very much.

Can it be that we don't have a test case for mocking a 'java.' type?

Are yoilu on your machine? I'll fix it next week otherwise.  =||= Sadly not. I can work on it tomorrow as well. Luckily we have a test suite now 🎉  =||= Or if @sormuras is available to make that PR, that would be amazing as well 😄 Our tests are specified in https://github.com/mockito/mockito/blob/f11705be91ee3545bc006908b34425f1fc359898/subprojects/module-test/src/test/java/org/mockito/moduletest/ModuleHandlingTest.java =||= Great, Tim!

Any plans to sync current release to Maven Central, soon? 2.24.0 is the latest one that was uploaded: http://central.maven.org/maven2/org/mockito/mockito-core/maven-metadata.xml =||= I wanted to do so, but I first wanted to get some other issues resolved with @raphw Hopefully we can get to that next week. (but seems like we hit a JDK bug 🎉 ) =||= Mockito 2.24.5 should be available on Maven central later today. =||= Looks good on 12: https://travis-ci.org/junit-team/junit5/jobs/495011557 =||= ",0
1619,1614,Memory leak in mockito-inline calling method on mock with at least a mock as parameter,"# Summary
We found a memory leak with mockito-inline. A short example is shown as below. A more detailed example can be found at the end.

```java
class BigClass {
  void accept(SmallClass small) {}
}

class SmallClass {
  void accept(BigClass big) {}
}

void leak() {
  BigClass a = Mockito.mock(BigClass.class);
  SmallClass b = Mockito.mock(SmallClass.class);

  // Remove any one of the 2 lines below will stop leaking
  a.accept(b);
  b.accept(a);
}

```

# Analysis
Looking at the [memory dump][MemDump]. Mock of `BigClass` and `SmallClass` are held as a weak ref in a map of type `WeakConcurrentMap$WithInlinedExpunction` used to map the mock and its invocation handler. When the mock can be reclaimed by GC the map will remove the record from it.

In the case with memory leak, the mock instance of `BigClass` was held as a strong reference by `rawArguments` and `arguments` in [`InvocationMatcher`][InvocationMatcher],  as `invocation` in [`InterceptedInvocation`][InterceptedInvocation], as `invocationForStubbing` in [`InvocationContainerImpl`][InvocationContainerImpl], as `invocationContainer` in [`MockHandlerImpl`][MockHandlerImpl]. That eventually leads to a value in the `WeakConcurrentMap` for `SmallClass`. Similar thing happens to the mock instance of `SmallClass`. That creates a ring of reference and no mock can be reclaimed by GC because they are all referenced transitively by a value in the map.

Similar things can also happen for stubbed methods, saved in `stubbed` in `InvocationContainerImpl`.

Subclass mock makers don't suffer from it because there is no map from mock to handler -- it's just a strong reference. GC can handle non-accessible rings well, but GC doesn't know the mock map purging semantic in inline mock makers.

# Potential Solution
Unlike #1533 where converting `spiedInstance` to a weak reference may be an acceptable solution, we can't convert arguments in stubbing method calls into weak references because there are stubbing calls with an object (or a mock) that doesn't have strong ref anywhere else than arguments in Mockito.

Therefore I failed to see a solution that's transparent to callers. The possible solution below is the one that I think has the least change.

The possible solution is we can somehow reset the mock when their lives end, which clears the stubbing records. Maybe we can tie their lives to a `MockitoSession`. We can track all mocks created after a session is created, and reset them when the session is finished. Now we only have events for mock creation in the same thread, we may need to expand that to include other threads.

We may be able to set `spiedInstance` to `null` when their lives end, which should also be able to fix #1532 and #1533. That would be a solution with least risk.

Of course any solution that's transparent to callers is still more desirable.

# A Detailed Example
See GitHub project [MockitoMethodCallMemLeak][MockitoMethodCallMemLeak]. One can open it in IntelliJ and the run configuration is already configured (with mem dump at OOM and 4M java heap size).

[MemDump]: https://github.com/ttanxu/MockitoMethodCallMemLeak/blob/master/java_pid13027.hprof
[InvocationMatcher]: https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java
[InterceptedInvocation]: https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java
[InvocationContainerImpl]: https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java
[MockHandlerImpl]: https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/handler/MockHandlerImpl.java
[MockitoMethodCallMemLeak]: https://github.com/ttanxu/MockitoMethodCallMemLeak","Thanks for the detailed explanation!

> We may be able to set `spiedInstance` to `null` when their lives end, which should also be able to fix #1532 and #1533. That would be a solution with least risk.

Sounds like the best plan forward. Do you mind opening a PR with regression test to get that fixed? =||= It seems to be rather hard to convert all listeners to listen to events from all threads due to current test setup.

However it's pretty important to capture mocks from other threads to make this solution work, because JUnit has failOnTimeout impl which basically runs each individual test case in its own thread. That means we need start a session in each test case, rather than in setUp and tearDown, which is rather inconvenient.

I'll add a global listener that captures all mock events from all threads, but disable the feature unless caller explicitly enables in session builders.

It would be a hard refactor to make `ThreadsRunAllTestsHalfManualTest` pass with this. =||= Actually we probably shouldn't refactor those tests, since they probably represent part of current API. But it should be just OK to stick to the plan in my previous comment. =||= Thanks! I added documentation about this as it was having a big impact on a project and was hard to find. https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2#mockito-2250 =||= we just updated our testing dependencies to latest version and ran into this OOM. 
how is adding an '@After'-annotated function to 3000+ tests practical, of which some already have their own implementation '@After' implementation? Or maybe I'm missing something? =||= There was a lot of discussion about this feature in the corresponding PR: #1619. That should hopefully clear up why we were forced to implement it this way 😢  =||= got it. so is there a way, that you know of, to invoke that for all tests, without me going into every test and adding that code? Maybe via some Test Listener or reflection? =||= You can write your own test runner that extends from the default Mockito runner and implements the logic.

We might actually consider that as part of the default mockito runner implementation. Do you mind opening a PR to start that discussion? It will mostly revolve around potential issues with multithreaded code. =||= > we just updated our testing dependencies to latest version and ran into this OOM.
> how is adding an '@after'-annotated function to 3000+ tests practical, of which some already have their own implementation '@after' implementation? Or maybe I'm missing something?

Classes can have as many `@After` functions as they want. In my case we had a base class that all classes inherited from. =||= ",0
1619,1532,Nested spies cause memory leaks ,"Seems like nested spies can cause memory leaks since such objects are kept in memory without purging. Not sure if it can be resolved at all. Should it be avoided? Is there a mention about this in docs? Anyway, the code speaks better and fortunately I’ve been able to create a self-contained sample.

BTW I can provide a `.hprof` file if you are interested.

#### Versions

```
org.mockito:mockito-core:2.22.0
org.mockito:mockito-inline:2.22.0
```
```
java version ""1.8.0_181""
Java(TM) SE Runtime Environment (build 1.8.0_181-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
```

#### Gradle

Heap is set to 64 MB.

```groovy
tasks.withType<Test> {
    maxHeapSize = ""64m""
    jvmArgs(""-XX:+HeapDumpOnOutOfMemoryError"")

    failFast = true
}
```
```
$ ./gradlew :module:cleanTestDebugUnitTest :module:testDebugUnitTest --tests ""com.github.sample.NestedSpiesMemoryLeakSpec""
```

#### Code

```kotlin
package com.github.sample

import com.jakewharton.rxrelay2.BehaviorRelay
import io.reactivex.functions.Consumer
import org.jetbrains.spek.api.Spek
import org.jetbrains.spek.api.dsl.it
import org.junit.platform.runner.JUnitPlatform
import org.junit.runner.RunWith
import org.mockito.Mockito

@RunWith(JUnitPlatform::class)
class NestedSpiesMemoryLeakSpec : Spek({

    repeat(10_000) { iteration ->

        it(""iteration [$iteration]"") {
            Mockito.spy(Service())
        }

    }

}) {

    class Service {
        // Remove Mockito.spy and OOM disappears.
        val value = Mockito.spy(Consumer<Int> {
            // This closure keeps a reference to Service.
            streams.size
        })

        // See at as a mass to fill the RAM.
        val streams = (0..1_000).map { BehaviorRelay.create<Int>() }
    }

}
```
```
> Task :module:testDebugUnitTest
java.lang.OutOfMemoryError: GC overhead limit exceeded
Dumping heap to java_pid23350.hprof ...
Heap dump file created [99857779 bytes in 0.356 secs]

com.github.sample.NestedSpiesMemoryLeakSpec > it iteration [187] STANDARD_ERROR
    java.lang.OutOfMemoryError: GC overhead limit exceeded
    	at com.jakewharton.rxrelay2.BehaviorRelay.<init>(BehaviorRelay.java:99)
    	at com.jakewharton.rxrelay2.BehaviorRelay.create(BehaviorRelay.java:77)
    	at com.github.sample.NestedSpiesMemoryLeakSpec$Service.<init>(NestedSpiesMemoryLeakSpec.kt:32)
    	at com.github.sample.NestedSpiesMemoryLeakSpec$1$1$1.invoke(NestedSpiesMemoryLeakSpec.kt:17)
    	at com.github.sample.NestedSpiesMemoryLeakSpec$1$1$1.invoke(NestedSpiesMemoryLeakSpec.kt:12)
    	at org.jetbrains.spek.engine.Scope$Test.execute(Scope.kt:102)
    	at org.jetbrains.spek.engine.Scope$Test.execute(Scope.kt:80)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:105)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$82/547193480.execute(Unknown Source)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)

com.github.sample.NestedSpiesMemoryLeakSpec > it iteration [187] FAILED
    java.lang.OutOfMemoryError

> Task :module:testDebugUnitTest FAILED
```

#### Eclipse Memory Analyzer

<img width=""1238"" alt=""screen shot 2018-11-14 at 19 09 53"" src=""https://user-images.githubusercontent.com/200401/48495384-e574fb00-e840-11e8-886e-c9ae00dcf291.png"">
<img width=""1238"" alt=""screen shot 2018-11-14 at 19 08 59"" src=""https://user-images.githubusercontent.com/200401/48495395-ec9c0900-e840-11e8-9b02-cec1c8db43c0.png"">
<img width=""1238"" alt=""screen shot 2018-11-14 at 19 09 09"" src=""https://user-images.githubusercontent.com/200401/48495404-f291ea00-e840-11e8-8c5f-2680047c6947.png"">

---

Seems like this happens:

* `Service` is a spy.
* `Service` contains a `Consumer`, it is a `spy` as well.
* `Consumer` is a closure and has an implicit reference to `Service`.
* Mockito keeps both spies and cannot remove them from memory since there is a cross-reference (I guess).

","@mockitoguy, sorry for the ping, but the situation gets worse on our side. Is the issue with Mockito or we are just using it the wrong way? =||= CC @raphw  =||= You are right, due to the reference of one mock to another, the weak map is loosing its effect.

Technically, we would need to make the spy reference weak to break the cross reference but I sm not sure how this can be achieved without risking to have the references collected prematurely.  =||= @raphw, thanks for the explanation! If it is more or less intended — maybe let’s document it somewhere? Another option is throwing an exception or printing a warning in such cases. Since we weren’t aware of this and use Mockito quite a lot we got ourselves in a pretty bad OOM situation. Finding nested spies by hand is a tedeous task, not even sure I can automate it without library support. I’m afraid people will continue to do this not understanding the consequences.

Can I ask you to take a look at #1533 as well? I think it is pretty similar or even exactly the same in terms of the root issue. =||= It is surely not expected behavior and I consider it a bug. However, I do not know how to solve this and I even doubt that it is solvable without a data structure that is called an https://en.wikipedia.org/wiki/Ephemeron and which Java does not (currently) support.

But we should definitely document this. =||= Just checked Mockito 2.27.0. Using the new `Mockito.framework().clearInlineMocks()` call does the trick and helps to avoid OOM. Thanks! =||= ",0
1619,1533,Cross-references and a single spy cause memory leak,"Not entirely sure, but I think that Mockito does not handle cross-references well. I have a semi-complex sample that proves this, but at the same time I’m not sure it is a Mockito failure and especially a fixable one. Suggestions how to avoid this behavior in general will be very helpful!

BTW I can provide a `.hprof` file if you are interested.

#### Versions

```
org.mockito:mockito-core:2.22.0
org.mockito:mockito-inline:2.22.0
```
```
java version ""1.8.0_181""
Java(TM) SE Runtime Environment (build 1.8.0_181-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
```

#### Gradle

Heap is set to 64 MB.

```groovy
tasks.withType<Test> {
    maxHeapSize = ""64m""
    jvmArgs(""-XX:+HeapDumpOnOutOfMemoryError"")

    failFast = true
}
```
```
$ ./gradlew :module:cleanTestDebugUnitTest :module:testDebugUnitTest --tests ""com.github.sample.SubscriptionMemoryLeakSpec""
```

#### Code

```kotlin
package com.github.sample

import com.jakewharton.rxrelay2.BehaviorRelay
import com.jakewharton.rxrelay2.PublishRelay
import io.reactivex.disposables.CompositeDisposable
import org.jetbrains.spek.api.Spek
import org.jetbrains.spek.api.dsl.it
import org.junit.platform.runner.JUnitPlatform
import org.junit.runner.RunWith
import org.mockito.Mockito

@RunWith(JUnitPlatform::class)
class SubscriptionMemoryLeakSpec : Spek({

    repeat(1_000) { iteration ->

        it(""iteration $iteration"") {
            // Remove Mockito.spy and OOM disappears (even without component.unbind).
            val service = Mockito.spy(Service())
            val memoryConsumingService = MemoryConsumingService()

            val component = Component(service, memoryConsumingService)

            component.bind()

            // Uncomment the following line and OOM disappears.
            // component.unbind()
        }

    }

}) {

    class Service {
        val stream = PublishRelay.create<Unit>().toSerialized()
    }

    class MemoryConsumingService {
        // See at as a mass to fill the RAM.
        val streams = (0..1_000).map { BehaviorRelay.create<Int>() }
    }

    class Component(
            private val service: Service,
            private val memoryConsumingService: MemoryConsumingService
    ) {

        private val disposable = CompositeDisposable()

        fun bind() {
            disposable += service.stream.subscribe {
                // This closure keeps a reference to Component.
                memoryConsumingService.streams.size
            }
        }

        fun unbind() = disposable.clear()
    }

}
```
```
> Task :module:testDebugUnitTest
java.lang.OutOfMemoryError: GC overhead limit exceeded
Dumping heap to java_pid31753.hprof ...
Heap dump file created [96660586 bytes in 0.332 secs]

com.github.sample.SubscriptionMemoryLeakSpec > it iteration 260 STANDARD_ERROR
    java.lang.OutOfMemoryError: GC overhead limit exceeded
    	at java.util.concurrent.locks.ReentrantReadWriteLock$Sync.<init>(ReentrantReadWriteLock.java:338)
    	at java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync.<init>(ReentrantReadWriteLock.java:669)
    	at java.util.concurrent.locks.ReentrantReadWriteLock.<init>(ReentrantReadWriteLock.java:240)
    	at java.util.concurrent.locks.ReentrantReadWriteLock.<init>(ReentrantReadWriteLock.java:230)
    	at com.jakewharton.rxrelay2.BehaviorRelay.<init>(BehaviorRelay.java:99)
    	at com.jakewharton.rxrelay2.BehaviorRelay.create(BehaviorRelay.java:77)
    	at com.github.sample.SubscriptionMemoryLeakSpec$MemoryConsumingService.<init>(SubscriptionMemoryLeakSpec.kt:41)
*** java.lang.instrument ASSERTION FAILED ***: ""!errorOutstanding"" with message can't create byte arrau at JPLISAgent.c line: 813
    	at com.github.sample.SubscriptionMemoryLeakSpec$1$1$1.invoke(SubscriptionMemoryLeakSpec.kt:21)
    	at com.github.sample.SubscriptionMemoryLeakSpec$1$1$1.invoke(SubscriptionMemoryLeakSpec.kt:14)
    	at org.jetbrains.spek.engine.Scope$Test.execute(Scope.kt:102)
    	at org.jetbrains.spek.engine.Scope$Test.execute(Scope.kt:80)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:105)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$82/1204954813.execute(Unknown Source)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)
    	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService$$Lambda$89/1263089654.accept(Unknown Source)
    	at java.util.ArrayList.forEach(ArrayList.java:1257)
    	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:110)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$82/1204954813.execute(Unknown Source)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)
    	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService$$Lambda$89/1263089654.accept(Unknown Source)
    	at java.util.ArrayList.forEach(ArrayList.java:1257)
    	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:110)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$82/1204954813.execute(Unknown Source)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)

com.github.sample.SubscriptionMemoryLeakSpec > it iteration 260 FAILED
    java.lang.OutOfMemoryError


261 tests completed, 1 failed
> Task :module:testDebugUnitTest FAILED
82 actionable tasks: 5 executed, 77 up-to-date
```

#### Eclipse Memory Analyzer

<img width=""1513"" alt=""screen shot 2018-11-15 at 11 57 52"" src=""https://user-images.githubusercontent.com/200401/48541708-4991d080-e8ce-11e8-9120-7e1b2bfee689.png"">
<img width=""1513"" alt=""screen shot 2018-11-15 at 11 58 42"" src=""https://user-images.githubusercontent.com/200401/48541709-4991d080-e8ce-11e8-8c3c-f427f92b4ca4.png"">
<img width=""1513"" alt=""screen shot 2018-11-15 at 11 59 17"" src=""https://user-images.githubusercontent.com/200401/48541710-4991d080-e8ce-11e8-8927-ee310073996c.png"">
<img width=""1513"" alt=""screen shot 2018-11-15 at 11 59 58"" src=""https://user-images.githubusercontent.com/200401/48541711-4a2a6700-e8ce-11e8-9f1f-40d61ff6e6b8.png"">
<img width=""1513"" alt=""screen shot 2018-11-15 at 12 01 25"" src=""https://user-images.githubusercontent.com/200401/48541712-4a2a6700-e8ce-11e8-864c-287570e8de99.png"">

---

Seems like this happens:

* `Service` is a spy and is being passed to `Component` along with `MemoryConsumingService`.
* Since `Service` is a spy it is being held by Mockito.
* `Component` subscribes to `Service.stream`. The `subscribe` closure captures `Component`, `Service` and `MemoryConsumingService`. Due to RxJava specifics `Service.stream` holds all of these thanks to the closure.
* Since `Service` is being held by Mockito (since it is a spy) and by itself (due to the `subscribe` closure) Mockito does not release it.

However:

* Releasing the subscription via `component.unbind()` removes a reference, so Mockito releases it and there is no OOM.
* Avoiding making `Service` a spy eliminates OOM as well, i. e. cross-references are not an issue for the JVM itself.","The issue is most likely caused by 2 factors:

1. `CreationSettings.spiedInstance` holds a hard reference to spied instance.
https://github.com/mockito/mockito/blob/7799c469390a78b7d28cf222bd275593747aa3cd/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java#L28

2. `InlineByteBuddyMockMaker` puts instance of the settings into a hard-referenced value of `mocks` field.
https://github.com/mockito/mockito/blob/7799c469390a78b7d28cf222bd275593747aa3cd/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java#L187

A solution could be to make `CreationSettings.spiedInstance` a weak reference field.
 =||= @TimvdLippe, @bric3, 🏓  =||= @ming13, @beworker, does anyone of you wants to take a stab at it? Can you write up a short design note how you would like to solve it and pros/cons of adding another weak reference field? Thanks so much! =||= @mockitoguy, hey, thanks for the reply! I think I don’t have enough expertise to do this without breaking something along the way. But just to confirm — is the issue really with Mockito or it is just a bad practices leading to this behavior? =||= Wow, Eclipse =||= Just checked Mockito 2.27.0. Using the new `Mockito.framework().clearInlineMocks()` call does the trick and helps to avoid OOM. Thanks! =||= ",0
1620,1618,Serializable flag doesn't make mock serializable,"I have a simple example test like this (I'm using junit5 with mockito-junit-jupiter extension)

```
@ExtendWith(MockitoExtension.class)
class ExampleTest {
  @Mock(serializable = true) private Iterable<?> it;

  @Test
  void shouldSerializeAndDeserializeIt() throws IOException, ClassNotFoundException {
    // when
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    new ObjectOutputStream(out).writeObject(it);
    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
    Iterable<?> deserializedIt = (Iterable<?>) new ObjectInputStream(in).readObject();

    // then
    assertThat(deserializedIt).isEqualToComparingFieldByFieldRecursively(it);
  }
}
```

And I'm getting this error on during instance serialization:

```
java.io.NotSerializableException: org.mockito.internal.junit.DefaultStubbingLookupListener
	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1185)
	at java.base/java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:349)
	at java.base/java.util.ArrayList.writeObject(ArrayList.java:896)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at java.base/java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:1130)
	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1497)
	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433)
	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179)
	at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1553)
	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1510)
	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433)
	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179)
	at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1553)
	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1510)
	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433)
	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179)
	at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1553)
	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1510)
	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433)
	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179)
	at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1553)
	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1510)
	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433)
	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179)
	at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1553)
	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1510)
	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433)
	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179)
	at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1553)
	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1510)
	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433)
	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179)
	at java.base/java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:349)
``` 
",We have observed similar things before. It seems like a mock is something keeping a hard reference to a listener. @TimvdLippe Do you remember me mentioning to having observed this some times? Were you working with the listener parts originally? =||= Yes I recall that discussion. The listener parts were introduced by @mockitoguy. I have run into this problem myself from time to time and have not figured out where it goes wrong. These listeners should not even be considered when serializing mocks. =||= ,0
1624,1621,"RETURNS_DEEP_STUBS causes ""Raw extraction not supported for : 'null'"" in some cases","When trying to mock the [Hadoop Mapper.Context](https://github.com/apache/hadoop/blob/release-2.6.0/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/Mapper.java#L105) class with Mockito 2.24.0, exception `org.mockito.exceptions.base.MockitoException: Raw extraction not supported for : 'null'` is thrown when calling one of the methods that returns a generic type.  

Actual mocking is taking place inside the [MRUnit library](https://mrunit.apache.org/), as seen in [MockMapContextWrapper](https://github.com/apache/attic-mrunit/blob/release-1.1.0/src/main/java/org/apache/hadoop/mrunit/internal/mapreduce/MockMapContextWrapper.java#L75): 

    final Mapper<KEYIN, VALUEIN, KEYOUT, VALUEOUT>.Context context = mock(org.apache.hadoop.mapreduce.Mapper.Context.class, Mockito.RETURNS_DEEP_STUBS);

Context is an abstract inner class of Mapper, and implements the [MapContext](https://github.com/apache/hadoop/blob/release-2.6.0/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/MapContext.java) interface, which extends the [TaskInputOutputContext](https://github.com/apache/hadoop/blob/release-2.6.0/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/TaskInputOutputContext.java) interface, which extends several other non-generic interfaces. 

Exception is thrown later when calling the [`context.getCurrentKey()`](https://github.com/apache/hadoop/blob/release-2.6.0/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/TaskInputOutputContext.java#L51) method on the mock, which returns generic type `KEYIN`.

This works fine with Mockito 1.

MRUnit project is abandoned, so it is not possible to change the mock.  It by default uses old Mockito 1.9.5, and works with 1.10.19.  I am attempting to exclude its dependencies on old Mockito and Powermock, and instead provide latest Mockito 2.24.0 and Powermock 2.0.0 so that my project using MRUnit and Mockito will not be permanently stuck on Mockito 1. 

The only time these problem methods appear to be [called within MRUnit is to set up stubbing](https://github.com/apache/attic-mrunit/blob/release-1.1.0/src/main/java/org/apache/hadoop/mrunit/internal/mapreduce/MockMapContextWrapper.java#L96), so it doesn't really matter what the return value is in this case.  Should this even work with Mockito, or was this just a bug in Mockito 1 that MRUnit exploited? 

----

Here is a minimal example that reproduces the issue:

```Java
package example;

import org.junit.Before;
import org.junit.Test;

import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
import static org.mockito.Mockito.mock;

public class Example {

    public interface FirstInterface<T> {
        boolean normal();
        T generic();
    }

    public interface SecondInterface<T> extends FirstInterface<T> { }

    public class TestClass<T> {
        public abstract class AbstractInner implements SecondInterface<T> { }
    }

    private TestClass.AbstractInner testMock;

    @Before
    public void setup() {
        testMock = mock(TestClass.AbstractInner.class, RETURNS_DEEP_STUBS);
    }

    @Test
    public void works() {
        testMock.normal();
    }

    @Test
    public void fails() {
        testMock.generic();
    }
}
```

https://github.com/zman0900/mockito-example has this code with a gradle build.

Both tests pass with Mockito 1.10.19, but one fails with 2.24.0.  Changing TestClass.AbstractInner to implement FirstInterface instead of SecondInterface causes the same failure with both Mockito 1 and 2.","@zman0900 Hi, nice bug report and reproducible example, it really helped. Indeed that's a bug or a current limitation in mockito's way to handle generics. I'm currently devising a way to improve such scenario. =||= ",0
1644,1642,VerificationCollector doesn't work for invocations with non-matching args,"I found the incubating `VerificationCollector` (#287), which is similar to AssertJ `SoftAssertion`s in that it collects multiple verifications and then asserts on the whole, rather than throwing an exception on the first one and skipping the rest of the verifications. Very useful for complicated testing.

However, I found that the verification collector doesn't work for verifications on method invocations with parameters. I had a quick check of the source code of the test, and I noticed that all of the tests in `VerificationCollectorImplTest` use no-arg invocations.

Hopefully this would be an easy fix, because this looks like an extremely useful feature for my application but I need to verify invocations with arguments. At the moment, my workaround is to wrap each verification call in an AssertJ soft assertion, but this makes writing the tests a bit more tedious and less readable.
","Update: I found that the lazy verification works properly when you use `VerificationCollector` directly. However, if you try and use it as a JUnit rule that's when this bug manifests.

I have updated `VerificationCollectorImplTest` to properly test for this situation and fail as appropriate. I will have a quick look and see if it is an easy fix; otherwise I may submit a PR with the test only and leave a more experienced hand to fix it. =||= Another update: I have gotten to the root of this problem.

>I found that the lazy verification works properly when you use VerificationCollector directly. However, if you try and use it as a JUnit rule that's when this bug manifests.

This wasn't quite correct. The distinguishing feature wasn't the JUnit rule, but if you do a verification for an invocation that tries to match on an argument while running under JUnit.

There is code in `org.mockito.internal.junit.ExceptionFactory` that checks to see if JUnit is on the classpath - if so, then it will throw `org.mockito.exceptions.verification.junit.ArgumentsAreDifferent` rather than `org.mockito.exceptions.verification.ArgumentsAreDifferent`. The JUnit version inherits from `junit.framework.ComparisonFailure` whereas the basic version inherits from `org.mockito.exceptions.base.MockitoAssertionError`.

It seems that the purpose of this is to help JUnit-aware GUIs to produce more helpful diagnostic output. This makes sense (although it would make more sense to derive from a more-up-to-date version of `ComparisonFailure` if it is available, like `org.junit.ComparisonFailure` - perhaps this could be the subject of a different issue/PR). However, because it is not a subclass of `MockitoAssertionError`, it skips out of the try/catch in `VerificationCollectorImpl` (see https://github.com/mockito/mockito/blob/b745b5d48e9c110fa419fd007b3159ff612b8643/src/main/java/org/mockito/internal/junit/VerificationCollectorImpl.java#L92).

There are two possible solutions:

1. Add another `catch()` to catch `ComparisonFailure` as well.
2. Broaden the catch for `MockitoAssertionError` to a common superclass (like `AssertionError`).

The second probably has more generic appeal and would future-proof the solution if other types of argument comparison were used (eg, a custom argument matcher). I will submit a PR for this shortly. =||= ",0
1647,1645,Release build is failing,"After the latest Shipkit update, our Travis is failing: https://travis-ci.org/mockito/mockito/jobs/501397895#L1693 It fails with

```
[commit]  2 files changed, 11 insertions(+), 2 deletions(-)
[performRelease]   External process [commit] completed.
[performRelease] [tag] fatal: tag 'v2.24.8' already exists
```

@mstachniuk could you take a look?","@TimvdLippe it looks like we fixed this one in https://github.com/mockito/shipkit/pull/782.
I can do some local testing and provide a PR for this one soon (shipkit version update). =||= Thanks for that @epeee Looking forward to that PR. =||= Thank you guys! =||= ",0
1665,166,UnfinishedStubbingException when thenReturn contains mock which is used in when,"Hi, I've found something strange and would like to ask you to explain, what is the reason UnfinishedStubbingException is thrown here? My understanding is that using mock in thenReturn is forbidden when it is a part of when as well, but frankly... I don't get why :-)

```
@Test
public void shouldMockMethodButDoesNot() {
    TestInterface mock = Mockito.mock(TestInterface.class);
    when(mock.getObject()).thenReturn(Mockito.mock(Object.class));
    when(mock.returnSomething()).thenReturn(new TestInterfaceUser(mock));
}

static interface TestInterface {
    public TestInterfaceUser returnSomething();
    public Object getObject();
}

static class TestInterfaceUser {

    Object obj;

    public TestInterfaceUser( TestInterface t) {
        this.obj = t.getObject();
    }
}
```","If you slightly change your code to the next form:

``` java
@Test
public void shouldMockMethodButDoesNot() {
    TestInterface mock = Mockito.mock(TestInterface.class);
    when(mock.getObject()).thenReturn(Mockito.mock(Object.class));
    TestInterfaceUser t = new TestInterfaceUser(mock);
    when(mock.returnSomething()).thenReturn(t);
}
```

it is working correctly.
Alternatively if you do next thing:

``` java
@Test
public void shouldMockMethodButDoesNot() {
    TestInterface mock = Mockito.mock(TestInterface.class);
    when(mock.getObject()).thenReturn(Mockito.mock(Object.class));
    when(mock.returnSomething()).thenReturn(new TestInterfaceUser(mock));
}

static interface TestInterface {
    public TestInterfaceUser returnSomething();
    public Object getObject();
}

static class TestInterfaceUser {

    TestInterface obj;

    public TestInterfaceUser( TestInterface t) {
        this.obj = t;
    }
}
```

it also behave in expected way.

Your problem is connected to the fact that in one place you are trying to register mock behaviour for selected method `when(mock.returnSomething())` - as a result mock is in state for registering answer , and then you are interacting with the same mock by invoking method `getObj()`. As a result mock is moved from waiting for answer state to some other one without receiving answer.

I am not sure whether I explain it to you in enough clear way but I think that you should more or less catch it. I think that provided workaround should be sufficient for you.

As far as I know there is no easy way to handle exactly the same cases described by you (but maybe I am wrong).
 =||= Thanks alberskib for your reply. I know how to build such a workaround :), what is more, I was almost sure that ""incorrect state"" is the reason why exception is thrown. Nothing new for me, but the question is if it is a desired behavior or just a bug? In my opinion it is at least weird...
 =||= > the question is if it is a desired behavior or just a bug?

It is really good question but unfortunately I am not able to answer to it.
I think that @szczepiq or @bric3 will be able to answer it.
 =||= Hi @mplewka,

For this kind of code it is expected, i.e. a mock is being used while the other mock is not yet stubbed.

Mock stubbing wasn't really designed to be _intertwined_. Things are already complicated but when mocks call another while being stubbed it becomes very difficult to actually detect the correct arguments for the correct call in intertwined mocks. I don't remember the details but if we relax this part it may blow in the wrong way for some other cases.

Also if you want I can give more precise detail on what's really going on in the snippet you provided.
 =||= ",0
1667,1663,Improve IDE UX comparison failure for JUnit5,"When JUnit4 is used and the test is invoked from IDE (IDEA or Eclipse), and we are getting ""arguments are different"" MockitoVerificationError, the IDE gets nice ""click to see the difference"" link in the test failure, providing neat comparison pop-up.

We want to provide this feature for JUnit5, too. We do not want to add a new dependency on mockito (e.g. OpenTest4J). Rather, we can use reflection just like we do it now for JUnit4 or how AssertJ integrates with JUnit5.

Spin-off from #1656","Changing the exception type is an incompatible change in a strict sense. However, we need to be able to improve the framework by tweaking the exceptions if needed. We always strive to be compatible. There are no known legit use cases why our users would want to catch & handle specific Mockito exceptions. It's OK to change the type of ArgumentsAreDifferent exception. =||= I'm happy to take this on, per your request. The hardest part was the question of whether/how to handle backward compatibility. Should have a PR submitted by Monday. =||= > The hardest part was the question of whether/how to handle backward compatibility

We are OK with this incompatible change (see my other comment). Thanks for taking this on!!!

 =||= ",0
1669,166,UnfinishedStubbingException when thenReturn contains mock which is used in when,"Hi, I've found something strange and would like to ask you to explain, what is the reason UnfinishedStubbingException is thrown here? My understanding is that using mock in thenReturn is forbidden when it is a part of when as well, but frankly... I don't get why :-)

```
@Test
public void shouldMockMethodButDoesNot() {
    TestInterface mock = Mockito.mock(TestInterface.class);
    when(mock.getObject()).thenReturn(Mockito.mock(Object.class));
    when(mock.returnSomething()).thenReturn(new TestInterfaceUser(mock));
}

static interface TestInterface {
    public TestInterfaceUser returnSomething();
    public Object getObject();
}

static class TestInterfaceUser {

    Object obj;

    public TestInterfaceUser( TestInterface t) {
        this.obj = t.getObject();
    }
}
```","If you slightly change your code to the next form:

``` java
@Test
public void shouldMockMethodButDoesNot() {
    TestInterface mock = Mockito.mock(TestInterface.class);
    when(mock.getObject()).thenReturn(Mockito.mock(Object.class));
    TestInterfaceUser t = new TestInterfaceUser(mock);
    when(mock.returnSomething()).thenReturn(t);
}
```

it is working correctly.
Alternatively if you do next thing:

``` java
@Test
public void shouldMockMethodButDoesNot() {
    TestInterface mock = Mockito.mock(TestInterface.class);
    when(mock.getObject()).thenReturn(Mockito.mock(Object.class));
    when(mock.returnSomething()).thenReturn(new TestInterfaceUser(mock));
}

static interface TestInterface {
    public TestInterfaceUser returnSomething();
    public Object getObject();
}

static class TestInterfaceUser {

    TestInterface obj;

    public TestInterfaceUser( TestInterface t) {
        this.obj = t;
    }
}
```

it also behave in expected way.

Your problem is connected to the fact that in one place you are trying to register mock behaviour for selected method `when(mock.returnSomething())` - as a result mock is in state for registering answer , and then you are interacting with the same mock by invoking method `getObj()`. As a result mock is moved from waiting for answer state to some other one without receiving answer.

I am not sure whether I explain it to you in enough clear way but I think that you should more or less catch it. I think that provided workaround should be sufficient for you.

As far as I know there is no easy way to handle exactly the same cases described by you (but maybe I am wrong).
 =||= Thanks alberskib for your reply. I know how to build such a workaround :), what is more, I was almost sure that ""incorrect state"" is the reason why exception is thrown. Nothing new for me, but the question is if it is a desired behavior or just a bug? In my opinion it is at least weird...
 =||= > the question is if it is a desired behavior or just a bug?

It is really good question but unfortunately I am not able to answer to it.
I think that @szczepiq or @bric3 will be able to answer it.
 =||= Hi @mplewka,

For this kind of code it is expected, i.e. a mock is being used while the other mock is not yet stubbed.

Mock stubbing wasn't really designed to be _intertwined_. Things are already complicated but when mocks call another while being stubbed it becomes very difficult to actually detect the correct arguments for the correct call in intertwined mocks. I don't remember the details but if we relax this part it may blow in the wrong way for some other cases.

Also if you want I can give more precise detail on what's really going on in the snippet you provided.
 =||= ",0
1672,1599,Master,"> Hey, 
> 
> Thanks for the contribution, this is awesome.
> As you may have read, project members have somehow an opinionated view on what and how should be
> Mockito, e.g. we don't want mockito to be a feature bloat.
> There may be a thorough review, with feedback -> code change loop.
> 
> Which branch : 
> - On mockito 2.x, make your pull request target `release/2.x`
> - On next mockito version make your pull request target `master`
>
> _This block can be removed_
> _Something wrong in the template fix it here `.github/PULL_REQUEST_TEMPLATE.md`


check list

 - [ ] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/2.x/.github/CONTRIBUTING.md)
 - [ ] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [ ] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [ ] Avoid other runtime dependencies
 - [ ] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [ ] The pull request follows coding style
 - [ ] Mention `Fixes #<issue number>` in the description _if relevant_
 - [ ] At least one commit should mention `Fixes #<issue number>` _if relevant_
",This should not be merged. =||= ,0
1693,1692,The new Error Prone plugin isn't service-loadable,"The `MockitoNotExtensible` plugin added in #1669 is pretty cool. However, when `mockito-errorprone` is added to the annotation processor classpath, Error Prone does not recognize/find the plugin. This is because `MockitoNotExtensible` is not declared in a `META-INF/services/com.google.errorprone.bugpatterns.BugChecker` file on the classpath.",nan,0
1699,1689,Coverage report is broken since Gradle 5,"We upgraded to Gradle 5 in #1683 to fix our Java 11 build. However, this has now broken our coverage computation because of a breaking change in Gradle 4.10: https://github.com/gradle/gradle/pull/6419

There is no guidance from the Gradle team on how to migrate to a proper configuration. I have spend a couple of hours today to try to fix it, with no result. The TLDR is that Gradle now throws away the `test.exec` after executing the tests in a subproject. Thus, it will only have the coverage from the last subproject it ran.

I have looked online and there are other projects that do something similar (https://github.com/grpc/grpc-java/blob/master/all/build.gradle, https://github.com/groovy/groovy-core/blob/master/gradle/jacoco/jacoco.gradle) but none of the approaches worked for us.","Per https://github.com/gradle/gradle/pull/6419#issuecomment-484178277

> Why can't you use the JacocoMerge task and have one execution file per test task?

I suppose we can use this task, but I am not sure how to configure it properly. =||= So you wan't a coverage report which calculates the aggregated test-coverage over all subprojects? =||= That is correct. This was working as intended, but was broken in Gradle 5: https://github.com/gradle/gradle/pull/6419 The appropriate solution is `JacocoMerge`, but I was not able to make that work. =||= I'm looking into it. =||= JacocoMerge alone won't help. You'd also need an additional JacocoReport task.

I can write a grade plugin for this an provide a PR which uses this plugin to solve the problem. =||= > I'm looking into it.

Awesome thanks!

> You'd also need an additional JacocoReport task.

We currently already have a custom task in https://github.com/mockito/mockito/blob/0ad4efbeedac050f416c48f22c9a561e31f3cb05/gradle/root/coverage.gradle, so I don't think a plugin is strictly necessary. =||= You don't need nor merge, nor additional report, nor custom plugin:

https://github.com/gradle/gradle/pull/6419 states

> separate tasks now cannot use the same coverage file

which is about test tasks, however task `JacocoReport` can use data from multiple files.

Was about to open PR after seen https://twitter.com/TimvdLippe/status/1123244630491979776 , however @marcphilipp was faster 😆 :thumbsup: =||= ",0
1701,1556,Fixes Issue #1542: When verify fails show all method invocations,"This PR fixes issue #1542 (when mock is called multiple times, and verify fails, the error message reports only the first invocation). From the issue, the idea is that showing all invocation would make it easier to see why something failed.

I have changed the behavior of the exception thrown and it's message now contains all method invocations instead of only the first one.
New format: 
```
Argument(s) are different! Wanted:
exampleBuilder.with(""key1"", ""wrongValue"");
-> at org.mockitousage.verification.VerifyPrintsAllInvocationsOnErrorTest.shouldPrintAllInvocationsOnError(VerifyPrintsAllInvocationsOnErrorTest.java:23)
Actual invocations have different arguments:
exampleBuilder.with(""key1"", ""val1"");
-> at org.mockitousage.verification.VerifyPrintsAllInvocationsOnErrorTest.shouldPrintAllInvocationsOnError(VerifyPrintsAllInvocationsOnErrorTest.java:20)
exampleBuilder.with(""key2"", ""val2"");
-> at org.mockitousage.verification.VerifyPrintsAllInvocationsOnErrorTest.shouldPrintAllInvocationsOnError(VerifyPrintsAllInvocationsOnErrorTest.java:21)
```","Working on fixing the failing tests. =||= # [Codecov](https://codecov.io/gh/mockito/mockito/pull/1556?src=pr&el=h1) Report
> Merging [#1556](https://codecov.io/gh/mockito/mockito/pull/1556?src=pr&el=desc) into [release/2.x](https://codecov.io/gh/mockito/mockito/commit/18990118a96da215a28feccf709d86025d04a06b?src=pr&el=desc) will **increase** coverage by `0.1%`.
> The diff coverage is `94.87%`.

[![Impacted file tree graph](https://codecov.io/gh/mockito/mockito/pull/1556/graphs/tree.svg?width=650&token=MX80sLdeR0&height=150&src=pr)](https://codecov.io/gh/mockito/mockito/pull/1556?src=pr&el=tree)

```diff
@@               Coverage Diff                @@
##             release/2.x    #1556     +/-   ##
================================================
+ Coverage          88.52%   88.63%   +0.1%     
- Complexity          2407     2414      +7     
================================================
  Files                299      299             
  Lines               6056     6087     +31     
  Branches             737      740      +3     
================================================
+ Hits                5361     5395     +34     
+ Misses               514      510      -4     
- Partials             181      182      +1
```


| [Impacted Files](https://codecov.io/gh/mockito/mockito/pull/1556?src=pr&el=tree) | Coverage Δ | Complexity Δ | |
|---|---|---|---|
| [...erification/checkers/MissingInvocationChecker.java](https://codecov.io/gh/mockito/mockito/pull/1556/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC92ZXJpZmljYXRpb24vY2hlY2tlcnMvTWlzc2luZ0ludm9jYXRpb25DaGVja2VyLmphdmE=) | `84.21% <100%> (+1.85%)` | `5 <0> (ø)` | :arrow_down: |
| [...a/org/mockito/internal/reporting/SmartPrinter.java](https://codecov.io/gh/mockito/mockito/pull/1556/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9yZXBvcnRpbmcvU21hcnRQcmludGVyLmphdmE=) | `100% <100%> (ø)` | `9 <8> (+4)` | :arrow_up: |
| [...java/org/mockito/internal/exceptions/Reporter.java](https://codecov.io/gh/mockito/mockito/pull/1556/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9leGNlcHRpb25zL1JlcG9ydGVyLmphdmE=) | `93.23% <89.47%> (-0.45%)` | `91 <2> (+1)` | |
| [...rg/mockito/internal/util/collections/ListUtil.java](https://codecov.io/gh/mockito/mockito/pull/1556/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC91dGlsL2NvbGxlY3Rpb25zL0xpc3RVdGlsLmphdmE=) | `91.66% <0%> (+41.66%)` | `5% <0%> (+2%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/mockito/mockito/pull/1556?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/mockito/mockito/pull/1556?src=pr&el=footer). Last update [1899011...b81db53](https://codecov.io/gh/mockito/mockito/pull/1556?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= I realized that this doesn't list out the locations as well as all the calls. I'll push something to improve that. =||= Thank you. Let us know when you got this completed.

Can you test the behavior in IDEA? ArgumentsAreDifferent exception integrates with IDEA and shows the diff/comparison in a pop-up. =||= @mockitoguy This should have all the changes completed now.
I used IntelliJ when I was developing this and I believe the pop up works but I will double check later today. =||= @mockitoguy Here's the current behavior on IntelliJ. The diff is shown. However it shows all invocations in one diff and I'm not sure if that's the behavior we want or not. Should we have separated diffs for each invocation?

![screen shot 2018-12-03 at 11 48 41 am](https://user-images.githubusercontent.com/6812932/49398248-9a892d80-f6f2-11e8-8856-eb4f5ca7adae.png)
![screen shot 2018-12-03 at 11 48 55 am](https://user-images.githubusercontent.com/6812932/49398253-9d841e00-f6f2-11e8-8e3c-5597ba660e03.png)
 =||= @bric3 Updated the PR. Let me know if you need more detail on anything.
I'm not sure what I should do to clean up the commit messages themselves. I guess I could always squash them into one commit. =||= @bric3 Tried to just rebase and clean up the commit history.  =||= @mockitoguy @bric3 Can this still be merged or should I just close this? =||= I will manually merge this in a new PR. Thanks for the initial contribution! =||= ",0
1701,1542,"when mock is called multiple times, and verify fails, the error message reports only the first invocation","AS A diligent dev,
I WANT TO verify that a mock will eventually get called with the specified parameters,
SO THAT I can properly test my builder class

SCENARIO
I have a builder class exposing a .with(String key, String value) method.
I created a test for testing that at a certain point the method gets called with 'foo', 'valueFoo'
I'd like to follow a test pattern where 1 test case has only 1 assertion

```
builderMock.with('bar','valueBar');
builderMock.with('foo','notValueFoo');
verify(builderMock).with('foo','valueFoo');
```

WHAT'S WRONG
Verify reports only the first invocation in the test failed logs.

```
Arguments are different! Wanted: 
builderMock.with('foo','valueFoo');
at ...
Actual invocation has different arguments:
builderMock.with('bar','valueBar');
at ...
``` 

IMO should be a list of invocation for that methods, something like:

```
// Actual invocations have different arguments:
// builderMock.with('bar','valueBar');
// at ...
// builderMock.with('foo','notValueFoo');
// at ...
```

NOTE
For anybody else having this problem, I'm rethrowing the exception raised with something like this:
```
    public static ArgumentsAreDifferent createExceptionWithEnhancedVerifyLogsFor(
            Object mockedObject,
            String invokedMethod,
            ArgumentsAreDifferent ex
    ) {
        String newline = System.getProperty(""line.separator"");
        String wanted = ex.getExpected();
        String actualTitle = MessageFormat.format(
                ""Interactions of {0}.{1}():"",
                mockedObject.getClass().getCanonicalName(), invokedMethod
        );
        String actual = mockingDetails(mockedObject).getInvocations().stream()
                .filter(invocation -> invocation.getMethod().getName().equals(invokedMethod))
                .map(Object::toString)
                .collect(Collectors.joining( newline ));
        String message = String.join(newline,
                ex.getClass().getCanonicalName(),
                ""Wanted: "" + wanted,
                actualTitle, actual
        );
        ArgumentsAreDifferent enhancedEx = new ArgumentsAreDifferent(message, wanted, actual);
        enhancedEx.setStackTrace(ex.getStackTrace());
        return enhancedEx;
    }
```","Nice report, thank you! Do you want to take a stub at fixing it? I suspect that we need to tweak the reporting, so that we print other interactions, too. We do something like that for regular verification failures (as opposed to verification failures due to mismatched arguments) =||= I can try and take a look at this. =||= hi @mockitoguy
sorry my email is bleeding with spam and I've been caught up with some deadlines
it would be an interesting piece of work that I'd like to take but I don't have the time right now for
it's going into my todo list, though =||= Just started working on this today. Doesn't seem like too bad of a change. I should have something to show later today or tomorrow. =||= ",0
1702,137,Promote incubating features,"Promote incubating features so that they are not longer @Incubating and they are a part of regular API:
- MockMaker extension point, fundamental for android testing
- mockingDetails API: Mockito.mockingDetails(mock);
- StackTraceCleaner and StackTraceCleanerProvider extension point
- Various public APIs: Invocation, DescribedInvocation, Location, MockHandler, StubInfo, MockCreationSettings",nan,0
1708,1623,Consider renaming TooLittleActualInvocations,"I agree with the commenter [here](https://github.com/mockito/mockito/issues/1088#issuecomment-303374289) that the exception name `TooLittleActualInvocations` is not ideal.

The correct English would be `TooFewActualInvocations` (where ""few"" is the opposite of ""many"" - as used in `TooManyActualInvocations`).

I appreciate this isn't the most critical issue ever raised, but it would make this assertion failure more readable!

As the existing class is non-final, I imagine it could be changed without breaking existing client code via subclassing and deprecating the original. Please let me know if it would be helpful for me to pick this up (or instead if the change wouldn't be desirable, or I'm otherwise missing something).

Thanks
",I would welcome a PR for this :smile:  =||= ,0
1714,1713,Typo in Mockito.java javadoc,"The following javadocs refer to `verifyNoMoreInvocations` but link to `verifyNoMoreInteractions`.

```
    /**
     * Creates {@link org.mockito.InOrder} object that allows verifying mocks in order.
     *
     * <pre class=""code""><code class=""java"">
     *   InOrder inOrder = inOrder(firstMock, secondMock);
     *
     *   inOrder.verify(firstMock).add(""was called first"");
     *   inOrder.verify(secondMock).add(""was called second"");
     * </code></pre>
     *
     * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one
     * but only those that you are interested in testing in order.
     * <p>
     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.
     * <p>
     * <code>InOrder</code> verification is 'greedy', but you will hardly ever notice it.
     * If you want to find out more, read
     * <a href=""https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verfication-InOrder"">this wiki page</a>.
     * <p>
     * As of Mockito 1.8.4 you can verifyNoMoreInvocations() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mocks to be verified in order
     *
     * @return InOrder object to be used to verify in order
     */
    @CheckReturnValue
    public static InOrder inOrder(Object... mocks) {
        return MOCKITO_CORE.inOrder(mocks);
    }
```

```
    /**
     * Allows checking if given method was the only one invoked. E.g:
     * <pre class=""code""><code class=""java"">
     *   verify(mock, only()).someMethod();
     *   //above is a shorthand for following 2 lines of code:
     *   verify(mock).someMethod();
     *   verifyNoMoreInvocations(mock);
     * </code></pre>
     *
     * <p>
     * See also {@link Mockito#verifyNoMoreInteractions(Object...)}
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    @CheckReturnValue
    public static VerificationMode only() {
        return VerificationModeFactory.only();
    }
```

Javadoc should be corrected to `verifyNoMoreInteractions`.",nan,0
1715,298,ObjenesisHelper references in MockMaker-independent code,"A couple of references to org.objenesis classes in code that is otherwise independent of bytecode-based mocks:

src/main/java/org/mockito/internal/stubbing/answers/ClonesArguments.java
src/main/java/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java

Both of these classes use ObjenesisHelper.newInstance(Class), which differs from Class.newInstance() in that no constructors are called. Is that necessary for these classes? If not, then updating to Class.newInstance() makes Mockito fully platform-independent (at least for platforms that define a MockMaker). If it is necessary, can this call be moved into MockMaker?

I'm happy to make the changes once the team decides on the best approach.","I'm with you.

The interactions with objenesis should be better isolated. MockMaker might be a reasonable idea. Technically, creating instances of things is not MockMaker's responsibility. So perhaps there is a better way? A different extension point? Check out org.mockito.plugins package.
 =||= It looks like you already did most of the work! The org.mockito.internal.creation.instance package defines Instantiator with the correct method, so it looks like all that's to be done to make this cross-platform is to move Instantiator to org.mockito.plugins, and update InstantiatorProvider to check for a plugin before assigning a ObjenesisInstantiator to InstantiatorProvider.INSTANCE.

If you're comfortable with that approach, I'll make the changes and submit a pull request.
 =||= Any updates on this?
 =||= Fixed in [current source](https://github.com/mockito/mockito/commit/e8640baba7eeaf4d333696492b6868feb115094f). Mockito's TravisCI continuous build successfully built the change, but for some reason since late last June CI builds can't be posted to [Mockito's releases page](https://github.com/mockito/mockito/releases). I guess someone from the project will need to hand-roll the next release, or fix the project's Travis CI configuration.
 =||= Thanks @tomball !
 =||= New ObjenesisHelper references were added in release/2.x branch to org/mockito/internal/stubbing/BaseStubbing.java and org/mockito/internal/stubbing/StubberImpl.java. =||= ",0
1718,1717,Incompatibility between the inline mocks and JaCoCo 0.8.4,"# Versions

Mockito 2.27.0
JaCoCo 0.8.4

# Problem

JaCoCo 0.8.4 introduced the use of the Conditional Dynamic instruction when running with Java 11+, which triggers an exception in the [`MethodVisitor`](https://github.com/mockito/mockito/blob/v2.27.0/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java#L314) used to strip the parameters, because it's not configured for the correct ASM API version:

    Mockito cannot mock this class: class com.ekino.mockito.B.
    
    If you're not sure why you're getting this error, please report to the mailing list.
    
    
    Java               : 11
    JVM vendor name    : AdoptOpenJDK
    JVM vendor version : 11.0.3+7
    JVM name           : OpenJDK 64-Bit Server VM
    JVM version        : 11.0.3+7
    JVM info           : mixed mode
    OS name            : Mac OS X
    OS version         : 10.14.5
    
    
    You are seeing this disclaimer because Mockito is configured to create inlined mocks.
    You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.
    
    Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class com.ekino.mockito.B]
    org.mockito.exceptions.base.MockitoException: 
    Mockito cannot mock this class: class com.ekino.mockito.B.
    
    If you're not sure why you're getting this error, please report to the mailing list.
    
    
    Java               : 11
    JVM vendor name    : AdoptOpenJDK
    JVM vendor version : 11.0.3+7
    JVM name           : OpenJDK 64-Bit Server VM
    JVM version        : 11.0.3+7
    JVM info           : mixed mode
    OS name            : Mac OS X
    OS version         : 10.14.5
    
    
    You are seeing this disclaimer because Mockito is configured to create inlined mocks.
    You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.
    
    Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class com.ekino.mockito.B]
    	at com.ekino.mockito.ATest.should_call_b(ATest.java:10)
    	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:628)
    	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:117)
    	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:184)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:180)
    	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:127)
    	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
    	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
    	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540)
    	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
    	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
    	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540)
    	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
    	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
    	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
    	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
    	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
    	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220)
    	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188)
    	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202)
    	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181)
    	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)
    	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:102)
    	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:82)
    	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:78)
    	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61)
    	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
    	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
    	at com.sun.proxy.$Proxy5.stop(Unknown Source)
    	at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:132)
    	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:175)
    	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:157)
    	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404)
    	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
    	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
    	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
    	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
    	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
    	at java.base/java.lang.Thread.run(Thread.java:834)
    Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class com.ekino.mockito.B]
    	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:152)
    	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:365)
    	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:174)
    	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:376)
    	... 77 more
    Caused by: java.lang.IllegalStateException: 
    Byte Buddy could not instrument all classes within the mock's type hierarchy
    
    This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
     - Compiled by older versions of scalac
     - Classes that are part of the Android distribution
    	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:177)
    	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:153)
    	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
    	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
    	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:152)
    	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:365)
    	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:174)
    	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:376)
    	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
    	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:197)
    	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:178)
    	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
    	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:62)
    	at org.mockito.Mockito.mock(Mockito.java:1907)
    	at org.mockito.Mockito.mock(Mockito.java:1816)
    	... 77 more
    Caused by: java.lang.UnsupportedOperationException: This feature requires ASM7
    	at net.bytebuddy.jar.asm.MethodVisitor.visitLdcInsn(MethodVisitor.java:542)
    	at net.bytebuddy.jar.asm.ClassReader.readCode(ClassReader.java:2181)
    	at net.bytebuddy.jar.asm.ClassReader.readMethod(ClassReader.java:1275)
    	at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:679)
    	at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:391)
    	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:3393)
    	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1930)
    	at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:217)
    	at net.bytebuddy.dynamic.scaffold.inline.AbstractInliningDynamicTypeBuilder.make(AbstractInliningDynamicTypeBuilder.java:120)
    	at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:3396)
    	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:254)
    	at java.instrument/java.lang.instrument.ClassFileTransformer.transform(ClassFileTransformer.java:246)
    	at java.instrument/sun.instrument.TransformerManager.transform(TransformerManager.java:188)
    	at java.instrument/sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:563)
    	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
    	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:167)
    	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:174)
    	... 91 more

# Example

I've pushed an [example](https://github.com/fpavageau/mockito-jacoco-condy) demonstrating the problem.

# Fix

I believe the fix is simply to configure the visitor with the ASM 7 API version, since that _is_ the version used by Mockito.","For reference, the change was introduced in JaCoCo with jacoco/jacoco#845. =||= ",0
1723,1716,mockito-android 2.26+ tries to use missing opentest4j exceptions,"It appears that Mockito `2.26+` on Android tries to use exceptions from OpenTest4j, even when OpenTest4j is not used, resulting in tests crashing due to exceptions classes not being found.

Steps to reproduce:

1. Open [MockitoAndroidDemo](https://github.com/mockito/mockito/files/3215946/MockitoAndroidDemo.zip) project in Android Studio
2. Run `ExampleInstrumentedTest.java` test on android device/emulator
3. Test will crash with `java.lang.NoClassDefFoundError: Failed resolution of: Lorg/opentest4j/AssertionFailedError`

Lowering version to `2.25.0` fixes the issue


","@kriegfrj do you mind taking a look at this? =||= I can't promise to look at it swiftly. I've never run an Android emulator before, it'll take me a while to get set up.

In the meantime, @matejdro , if you could post the stack trace of the error that would help. I might be able to get a clue without seeing up the whole environment. =||= Here you go:

[stacktrace.txt](https://github.com/mockito/mockito/files/3216729/stacktrace.txt)
 =||= Thanks.

Looks like you've got some funky ClassLoader in there doing something odd. I'll try and look more closely later, possibly later in the weekend. =||= I've had a quick look and I haven't been able to get the emulator running easily to reproduce it myself. However, having had a closer look at the stack trace, I suspect that it is some kind of feature in the test harness (perhaps in AndroidJUnitRunner) that is supposed to detect and warn when your code tries to load classes that it can't find on its classpath. Attempting to load the OpenTest4J class is perfectly normal behaviour for this version of Mockito though, and the attempt is surrounded by a <tt>catch()</tt> which ordinarily would catch any error thrown.

As a workaround, you could try putting OpenTest4J on your classpath. You might lose the visual diff in case of failure though. =||= Here is my guess on what happens:

Exceptions catching for missing classes only [surrounds factory creation, not the actual exception creation](https://github.com/mockito/mockito/blob/28012a49cb1b1aab1b957ac5e7507dd8b807a47e/src/main/java/org/mockito/internal/junit/ExceptionFactory.java#L23). It is possible that Desktop JVM verifies all methods on class creation, but Android's runtime does not. And thus no exception is thrown there. Instead Android's runtime throws missing class exception when `create()` method is executed for the first time, which does not have`try/catch` around it. =||= I thought about your suggestion, but I don't think it fits with the stack trace that you provided. In the stack trace, it's clear that the line it's complaining about is line 24, in the static initializer for `ExceptionFactory`, when the factory implementation is actually created:

at org.mockito.internal.junit.ExceptionFactory.<clinit>(ExceptionFactory.java:24)

I expect a `ClassNotFoundError` to get thrown here when OpenTest4J is not on the class path. What is not expected is that this isn't caught by the surrounding `catch(Throwable)` statement. Which is why I think the android test framework is doing something funky.

If what you're suggesting were true, I'd expect line 27 to appear at the top of the stack trace, but it doesn't appear at all. According to the stack trace, it is failing before `create()` is even called, This scenario would also be contrary to the JVM spec (which, from memory, specifies that all the class's linkages should be resolved when the class is loaded, and not when a method is executed).

One way to test this would be to package up a JUnit test and deploy it as an APK into the emulator and run it directly, rather than as part of an instrumentation test. If you want to give that a try and let me know how you go we can analyse the result. =||= Ok @matejdro , I still haven't been able to get the Android Studio stuff working, but based on the above educated guess I've made a change that might do the trick. You can find this change under branch `1716-opentest4j-under-android` in my fork of Mockito (https://github.com/kriegfrj/mockito). If you could download, build and install this and give it a try and let me know if it fixes your problem, that would be much appreciated.

If it does fix your problem, I'll create a PR from this branch so that @TimvdLippe  or @mockitoguy can merge it. If not, I guess I'll go back to the drawing board... =||= Sorry for the delay. Any tips on how to build `mockito-android`? Running `gradlew build` only procudes `mockito-core` and I cannot find a way to switch it to android.

P.S.: there appear to be checkstyle errors in the branch (I had to disable checkstyle to even get core to build) =||= Never mind, figured it out (android project is in the `subprojects` folder). 

It appears that using your branch fixes the issue. I no longer get the crash. =||= Thanks for verifying @matejdro. I have created a PR for this issue now (#1723).

Thank you so much for your help - I was dreading having to go through the process of getting the Android emulator working! I'm sure it would have been fun to try but (like most people) I'm a bit time poor... =||= I am also having this issue. I was running v3.0.0, but switching back to 2.25.0 fixed it.  =||= > I am also having this issue. I was running v3.0.0, but switching back to 2.25.0 fixed it.

Sorry @johnmahlon, the fix for this was supposed to get merged into 3.0 but I dropped the ball. Hopefully it will get merged soon.

In the meantime, as a workaround, if you need Mockito >2.25.0 then you should be able to run it with any version of Mockito if you just put `org.opentest4j` on your runtime classpath. =||= @kriegfrj no problem. Our app isn’t production yet, so using 2.25 is definitely fine for now.  =||= ",0
1733,977,Misleading documentation of verifyZeroInteractions,"## Problem

The current behavior of verifyZeroInteractions can be misleading, see the #989.

In current version of Mockito (2.x), we can improve the javadoc for verifyZeroInteractions to clearly describe how it works (and mention the behavior of strict stubs, too).

Please contribute!

## Original report

Original issue reported by @ffissore:

According to the [docs](http://static.javadoc.io/org.mockito/mockito-core/2.7.13/org/mockito/Mockito.html#verifyZeroInteractions(java.lang.Object...)) `verifyZeroInteractions` is like `verify(mock, never()).method()` when the mock has only one method.

The tests below should both raise an exception. Instead, `testVerifyZeroInteractions` raises none and fails

```java
package test;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import org.mockito.quality.Strictness;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.*;

public class MockitoTest {

   private static class Collaborator {

      public String doStuff(int number) {
         throw new RuntimeException();
      }

   }

   private static class Container {

      private final Collaborator collaborator;

      public Container(Collaborator collaborator) {
         this.collaborator = collaborator;
      }

      public String doStuff(int number) {
         return collaborator.doStuff(number);
      }

   }


   @Rule
   public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);

   @Mock
   private Collaborator collaborator;

   @Before
   public void setUp() throws Exception {
      MockitoAnnotations.initMocks(this);
   }

   // passes
   @Test(expected = NeverWantedButInvoked.class)
   public void testVerifyNever() throws Exception {
      Container container = new Container(collaborator);
      when(collaborator.doStuff(42)).thenReturn(""yeah"");

      String output = container.doStuff(42);
      assertEquals(""yeah"", output);

      verify(collaborator, never()).doStuff(42);
   }

   // fails
   @Test(expected = NoInteractionsWanted.class)
   public void testVerifyZeroInteractions() throws Exception {
      Container container = new Container(collaborator);
      when(collaborator.doStuff(42)).thenReturn(""yeah"");

      String output = container.doStuff(42);
      assertEquals(""yeah"", output);

      verifyZeroInteractions(collaborator);
   }
}
```","Forgot to say: I'm using version 2.7.13 =||= Looking into it... =||= Thank you for reporting and your patience waiting for the reply!!!

It's a really good report - I was able to reproduce the problem easily. Also, THANKS a lot for using strict stubbing - I'm really happy to see it in use!

At the moment, ""verifyZeroInteractions"" is an alias to ""verifyNoMoreInteractions"", intended to be used to improve readability of tests. Let me illustrate it on a couple of examples:

Example 1 - verifyNoMoreInteractions

```java
mock.foo();
verify(mock).foo();
verifyNoMoreInteractions(mock); //pretty clear I think
```

Example 2 - verifyZeroInteractions

```java
mock.foo();
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
//and we already have verified the only method invoked on the mock
```

Example 3 - verifyZeroInteractions with regular stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
```

Example 4 - verifyZeroInteractions with new strict stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());

verifyZeroInteractions(mock);
//above passes because with strict stubbing
//stubbed method are implicitly verified when they are ""used""
//this is one of key features of strict stubbing (DRY, don't repeat yourself)
```

We're happy to listen to suggestions about above and the API. I think that better documentation is needed for ""verifyZeroInteractions"", too. =||= Thank you for the clarification. Then I guess the problem is with the [javadoc](https://static.javadoc.io/org.mockito/mockito-core/2.7.17/org/mockito/Mockito.html#verifyZeroInteractions(java.lang.Object...)) which states ""Verifies that no interactions happened on given mocks."". This made sense to me: a class X may have a number of mocked collaborators and I want to be sure that some of them have not taken part when I called X.method()

I ended up writing my version
```java
public static void verifyZeroInteractions(Object... objects) {
  for (int i = 0; i < objects.length; i++) {
    assertEquals(""Expected 0 interactions with object at index "" + i + "" ("" + objects[i].getClass() + "")"", 0, Mockito.mockingDetails(objects[i]).getInvocations().size());
  }
}
```

Also thanks for the hint about implicit verification when in strict mode: I didn't get it and it will allow me to delete some tens of lines of code =||= Interesting idea!

Let's keep this ticket to improve the documentation (want to help out? submit a PR :). I created ticket for discussing change of verifyZeroInteractions: #989 =||= ",0
1733,989,Misleading behavior of Mockito.verifyZeroInteractions(),"## Problem

Mockito.verifyZeroInteractions() actually does not do what it advertises. The purpose of this ticket is to discuss whether to change the behavior of this method in Mockito 3.

## Details

Based on user feedback at #977, from @ffissore, ""verifyZeroInteractions"" API can be misleading. When you read that method in test code, you expect zero interactions with specified mocks. However, ""verifyZeroInteractions"" is only an alias to ""verifyNoMoreInteractions"" and in fact, it **does not** guarantee that there were zero interactions. Let's use examples to illustrate the problem

## Feedback needed

Please comment / vote / state your opinion about changing the behavior of ""verifyZeroInteractions"" so that it actually ensures that there were **zero** interactions with the mock (regardless if previously verified or not).

## Examples

Below examples illustrate current behavior of Mockito 2.x, in case you are puzzled what this ticket is about.

Example 1 - verifyNoMoreInteractions

```java
mock.foo();
verify(mock).foo();
verifyNoMoreInteractions(mock); //pretty clear I think
```

Example 2 - verifyZeroInteractions

```java
mock.foo();
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
//and we already have verified the only method invoked on the mock
```

Example 3 - verifyZeroInteractions with regular stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
```

Example 4 - verifyZeroInteractions with new strict stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());

verifyZeroInteractions(mock);
//above passes because with strict stubbing
//stubbed method are implicitly verified when they are ""used""
//this is one of key features of strict stubbing (DRY, don't repeat yourself)
```",This was fixed in #989 =||= ,0
1733,977,Misleading documentation of verifyZeroInteractions,"## Problem

The current behavior of verifyZeroInteractions can be misleading, see the #989.

In current version of Mockito (2.x), we can improve the javadoc for verifyZeroInteractions to clearly describe how it works (and mention the behavior of strict stubs, too).

Please contribute!

## Original report

Original issue reported by @ffissore:

According to the [docs](http://static.javadoc.io/org.mockito/mockito-core/2.7.13/org/mockito/Mockito.html#verifyZeroInteractions(java.lang.Object...)) `verifyZeroInteractions` is like `verify(mock, never()).method()` when the mock has only one method.

The tests below should both raise an exception. Instead, `testVerifyZeroInteractions` raises none and fails

```java
package test;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import org.mockito.quality.Strictness;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.*;

public class MockitoTest {

   private static class Collaborator {

      public String doStuff(int number) {
         throw new RuntimeException();
      }

   }

   private static class Container {

      private final Collaborator collaborator;

      public Container(Collaborator collaborator) {
         this.collaborator = collaborator;
      }

      public String doStuff(int number) {
         return collaborator.doStuff(number);
      }

   }


   @Rule
   public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);

   @Mock
   private Collaborator collaborator;

   @Before
   public void setUp() throws Exception {
      MockitoAnnotations.initMocks(this);
   }

   // passes
   @Test(expected = NeverWantedButInvoked.class)
   public void testVerifyNever() throws Exception {
      Container container = new Container(collaborator);
      when(collaborator.doStuff(42)).thenReturn(""yeah"");

      String output = container.doStuff(42);
      assertEquals(""yeah"", output);

      verify(collaborator, never()).doStuff(42);
   }

   // fails
   @Test(expected = NoInteractionsWanted.class)
   public void testVerifyZeroInteractions() throws Exception {
      Container container = new Container(collaborator);
      when(collaborator.doStuff(42)).thenReturn(""yeah"");

      String output = container.doStuff(42);
      assertEquals(""yeah"", output);

      verifyZeroInteractions(collaborator);
   }
}
```","Forgot to say: I'm using version 2.7.13 =||= Looking into it... =||= Thank you for reporting and your patience waiting for the reply!!!

It's a really good report - I was able to reproduce the problem easily. Also, THANKS a lot for using strict stubbing - I'm really happy to see it in use!

At the moment, ""verifyZeroInteractions"" is an alias to ""verifyNoMoreInteractions"", intended to be used to improve readability of tests. Let me illustrate it on a couple of examples:

Example 1 - verifyNoMoreInteractions

```java
mock.foo();
verify(mock).foo();
verifyNoMoreInteractions(mock); //pretty clear I think
```

Example 2 - verifyZeroInteractions

```java
mock.foo();
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
//and we already have verified the only method invoked on the mock
```

Example 3 - verifyZeroInteractions with regular stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
```

Example 4 - verifyZeroInteractions with new strict stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());

verifyZeroInteractions(mock);
//above passes because with strict stubbing
//stubbed method are implicitly verified when they are ""used""
//this is one of key features of strict stubbing (DRY, don't repeat yourself)
```

We're happy to listen to suggestions about above and the API. I think that better documentation is needed for ""verifyZeroInteractions"", too. =||= Thank you for the clarification. Then I guess the problem is with the [javadoc](https://static.javadoc.io/org.mockito/mockito-core/2.7.17/org/mockito/Mockito.html#verifyZeroInteractions(java.lang.Object...)) which states ""Verifies that no interactions happened on given mocks."". This made sense to me: a class X may have a number of mocked collaborators and I want to be sure that some of them have not taken part when I called X.method()

I ended up writing my version
```java
public static void verifyZeroInteractions(Object... objects) {
  for (int i = 0; i < objects.length; i++) {
    assertEquals(""Expected 0 interactions with object at index "" + i + "" ("" + objects[i].getClass() + "")"", 0, Mockito.mockingDetails(objects[i]).getInvocations().size());
  }
}
```

Also thanks for the hint about implicit verification when in strict mode: I didn't get it and it will allow me to delete some tens of lines of code =||= Interesting idea!

Let's keep this ticket to improve the documentation (want to help out? submit a PR :). I created ticket for discussing change of verifyZeroInteractions: #989 =||= ",0
1733,989,Misleading behavior of Mockito.verifyZeroInteractions(),"## Problem

Mockito.verifyZeroInteractions() actually does not do what it advertises. The purpose of this ticket is to discuss whether to change the behavior of this method in Mockito 3.

## Details

Based on user feedback at #977, from @ffissore, ""verifyZeroInteractions"" API can be misleading. When you read that method in test code, you expect zero interactions with specified mocks. However, ""verifyZeroInteractions"" is only an alias to ""verifyNoMoreInteractions"" and in fact, it **does not** guarantee that there were zero interactions. Let's use examples to illustrate the problem

## Feedback needed

Please comment / vote / state your opinion about changing the behavior of ""verifyZeroInteractions"" so that it actually ensures that there were **zero** interactions with the mock (regardless if previously verified or not).

## Examples

Below examples illustrate current behavior of Mockito 2.x, in case you are puzzled what this ticket is about.

Example 1 - verifyNoMoreInteractions

```java
mock.foo();
verify(mock).foo();
verifyNoMoreInteractions(mock); //pretty clear I think
```

Example 2 - verifyZeroInteractions

```java
mock.foo();
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
//and we already have verified the only method invoked on the mock
```

Example 3 - verifyZeroInteractions with regular stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
```

Example 4 - verifyZeroInteractions with new strict stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());

verifyZeroInteractions(mock);
//above passes because with strict stubbing
//stubbed method are implicitly verified when they are ""used""
//this is one of key features of strict stubbing (DRY, don't repeat yourself)
```",This was fixed in #989 =||= ,0
1745,1743,"Clarify Javadoc of RETURNS_SMART_NULLS, default answer in Mockito 3.0.0?","[Javadoc for Mockito.RETURNS_SMART_NULLS](https://static.javadoc.io/org.mockito/mockito-core/3.0.0/org/mockito/Mockito.html#RETURNS_SMART_NULLS) in version 3.0.0 still says:

> ReturnsSmartNulls will be probably the default return values strategy in Mockito 3.0.0

As Mockito 3.0.0 has been released this could now be clarified. I see #971 is still open, so it looks like the default answer has not been changed?","Yes that should be updated to 4.0.0 now, as we decided not to make any API changes in 3.0.0. =||= ",0
1760,1747,Typo in error message ,"https://github.com/mockito/mockito/blob/885e69420baa2a382f4394b85dc84cb6fe17fff6/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java#L219

""VM does not not support modification of given type""
should be 
""VM does not support modification of given type""",Feel free to open a PR with a fix. =||= ,0
1760,1513,Mockito docs / javadocs - monospaced font all over the place after point 44,"The brilliant Mockito javadocs are less brilliant than usual, because after
[44. Deprecated org.mockito.plugins.InstantiatorProvider as it was leaking internal API. it was replaced by org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)](https://static.javadoc.io/org.mockito/mockito-core/2.23.0/org/mockito/Mockito.html#mockito_instantiator_provider_deprecation)
almost everything is written with monospaced font which reduces readability. Apparently some closing tag is missing.",This probably broke in #1439 with the dangling `<p>` on line 2540. Do you mind opening a PR to fix it? =||= ,0
1762,1758,Method GenericTypeExtractor#findGenericInterface always returns first  interface,"The Method `findGenericInterface` of `GenericTypeExtractor` ( <https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/util/reflection/GenericTypeExtractor.java>) always returns the first generic interface.

The relevant line seems to be:
<https://github.com/mockito/mockito/blob/220494473031298300a4c47c247c8b778cc39164/src/main/java/org/mockito/internal/util/reflection/GenericTypeExtractor.java#L64>

Maybe instead of 
`return sourceClass.getGenericInterfaces()[0];` 
it should be 
`return sourceClass.getGenericInterfaces()[i];`

Example:
```java
interface MyInterface extends Runnable, Consumer<Double> {
}

Type result = GenericTypeExtractor.findGenericInterface(MyInterface.class, Consumer.class);
System.out.println(result);
// output: interface java.lang.Runnable
// expected output: java.util.function.Consumer<java.lang.Double>
```
Mockito version: 2.x 3.x
Java version: jdk8u202-b08

",nan,0
1773,1769,Are strict stubs really the default in v3?,"The Strictness.STRICT_STUBS javadoc reads: ""Planned as default for Mockito v3."".

I'm using ""org.mockito:mockito-core:3.0.0"" and strict stubs do not seem to be the default behaviour. Are they actually going to be the default in any release soon?","It is not. Mockito 3 only requires Java 8 as minimum. No other api changes were made. Could you submit a PR (similar to #1745) thats updates the doc? =||= What would be the easiest way of enabling it in Junit 5 given that I’m already using another Junit extension and lifecycle Per class?

`@ExtendWith(VertxExtension.class)`
`@TestInstance(TestInstance.Lifecycle.PER_CLASS)` =||= @TimvdLippe I just sent the PR. Any chance you could help me with the previous question? Also, is there an ETA for v4? Thanks very much. =||= The Junit 5 extension should already use strict stubs by default, does it not? =||= It does in fact seem to use strict stubs but I just double-checked and it does not throw UnnecessaryStubbingException when it should. PotentialStubbingProblem does work perfectly though. =||= ",0
1781,1780,File-handle leak in InlineByteBuddyMockMaker,"Using [file-leak-detector](https://file-leak-detector.kohsuke.org/) when running unit-tests using mockito-3.0.0 we see a file-handle-leak being reported in `InlineByteBuddyMockMaker.<clinit>` which can easily be fixed by closing the JarFile after usage properly.

I'll send a PR shortly.

```#2 ...\mockitoboot2606807734337514236.jar by thread:main on Tue Sep 17 15:55:43 CEST 2019
	at java.util.zip.ZipFile.<init>(ZipFile.java:156)
	at java.util.jar.JarFile.<init>(JarFile.java:166)
	at java.util.jar.JarFile.<init>(JarFile.java:130)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.<clinit>(InlineByteBuddyMockMaker.java:138)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)```",nan,0
1781,178,"Mockito matchers used in ""when"" impact the ""there was one""","If you use an `any` matcher in a `when`, then if you later try and verify another method was called on the same mock it passes regardless of whether the arguments matched.

Example when it (wrongly) passes, as the method ""shouldBeCalled"" is called, but not with the given argument:

``` scala
val mockedService = mock[MockedService]

when(mockedService.myMethod(any).thenReturn(""Response"")

serviceBeingTested.methodBeingTested

there was one(mockedService).shouldBeCalled(""Incorrect Argument"")
```

Example when it fails as it should:

``` scala
val mockedService = mock[MockedService]

when(mockedService.myMethod(""actualArgumentBeingUsed"").thenReturn(""Response)

serviceBeingTested.methodBeingTested

there was one(mockedService).shouldBeCalled(""Incorrect Argument"")
```","Hi @timgent 

I'm not reproducing, could you write a JUnit test reproducing the faced issue, with the latest version of mockito and in java please.
 =||= Hi,

I'll close this issue as, there's no feedback and no reproducible errors.
 =||= ",0
1787,1786,Difference between 'timeout' and 'after' not immediately clear,"The first few lines of the JavaDoc for both methods do not exactly specify their difference. From `timeout` you have to jump to `after` where at the end of the JavaDoc the difference is explained.

I think this can be improved. The first sentence in `timeout` could be more specific to highlight the difference directly.",nan,0
1788,1630,Mockito JUnit Jupiter extension does not correctly support parallel test execution,"Sorry for not being able to provide the required information, but we just noticed that the MockitoExtension (mockito-junit-jupiter 2.24.5) leads to spurious test failures (e.g. due to calls to mocks not being recorded) when using ""junit.jupiter.execution.parallel.enabled=true"" with surefire. Prior we used our much simpler MockitoExtension which works fine in the same situation:

```java
public class MockitoExtension implements Extension, TestInstancePostProcessor, AfterEachCallback {
   @Override
   public void postProcessTestInstance(Object testInstance, ExtensionContext context) {
      MockitoAnnotations.initMocks(testInstance);
   }

   @Override
   public void afterEach(ExtensionContext extensionContext) throws Exception {
      Mockito.validateMockitoUsage();
   }
}
```","Hey! Can you take a look at our FAQ wiki. We documented how Mockito supports parallel execution. =||= I took a look at the wiki, but found just a very short section about parallel testing in the FAQ section. I issued the bug, because the parallel execution of whole test cases with JUnit 5 seems to be broken. I do not have any complex tests which use mocks in combination with multithreading.

Anyway this seems to be a problem of the MockitoExtension, not Mockito itself. Because with our simple JUnit 5 extension for Mockito, parallel execution of test cases which use mocks with JUnit 5 works fine. =||= I got a similar issue. 
I have got a workaround, if only a few of your ""Mockito""-test-classes in you testsuite are failing when running JUnit jupiter in parallel. You can execute those problematic tests using ""SAME_THREAD"" for avoiding Mockito concurrency issues.

```
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
@Execution(ExecutionMode.SAME_THREAD) // <--- Workaround
class SomeTest {
``` =||= To be a bit more specific, WantedButNotInvoked exceptions are thrown by verification calls failing, because of not recorded invocations: ""Actually, there were zero interactions with this mock."". =||= The main difference between the current and the simple implementation above is, that the simple one inits the mocks in postProcessTestInstance() whereas the current one inits them in beforeEach(). Any ideas why that might be a problem? 

I tried the failing tests with a modified version of the current MockitoExtension which was just altered to init the mocks in postProcessTestInstance() and disabled the init in beforeEach() and the tests do no longer fail. So this seems to be the source of the problems. =||= Hey guys, can you provide us a test that reproduces the problem? Thanks! =||= @mockitoguy Here you go: https://github.com/SchulteMarkus/mockito.bug1630

I am not sure, if I reduced the example as much as possible, but, well, the project is not large. =||= Thank you! The sample project looks great!

I looked at the code but I haven't had time to debug it. How does the JUnit5 parallel execution work? Are we sharing the test instance (and thus, sharing mocks, SUTs?). =||= You are welcome :-) 
I don't know details about JUnit's parallelization. =||= > How does the JUnit5 parallel execution work? Are we sharing the test instance (and thus, sharing mocks, SUTs?).

By default not, and the user must be very explicit to enable sharing of the same test class instance with parallel execution enabled. I.e., even if parallel execution mode is enabled by default, and a test class is annotated with `Lifecycle.PER_CLASS`, its tests will still be executed sequentially _unless_ it is also annotated with `@Execution(CONCURRENT)`: https://junit.org/junit5/docs/current/user-guide/#writing-tests-parallel-execution

I also bumped into this issue in our codebase, with some tests using `MockitoExtension` failing in parallel mode, and some working fine. Could not spot anything particularly special about the failing ones.
 =||= I can confirm, that the problem exists. I also have tests using MockitoExtension and they fail in a non-deterministic way randomly only if Junit5 parralelization is used. =||= Scenario:

1. JUnit 5 creates a single `ClassExtensionContext `for a multithreaded test, but each thread becomes an instance of the test class
2. Each thread will come into `postProcessTestInstance `where they put their test instance in the same `ClassExtensionContext.getStore(MOCKITO)` map with the same key (`TEST_INSTANCE`)
3. Each thread then will get into `beforeEach`. They get a thread unique `MethodExtensionContext`, but each of them contain the same instance of `ClassExtensionContext`. Then they fetch the the last updated `TEST_INSTANCE `from the parent `ClassExtensionContext `inside the `collectParentTestInstances `method. Each thread gets quasi a random Test Instance depending on the fact which thread was before inside the `postProcessTestInstance `method. Then they prepare their broken Session inside the store of the current `MethodExtensionContext `with a random Test Instance included.

That is the explanation. I am thinking about how to solve this.

It is not 100% clear to me why the parent context test instance is included. I will check how this scenario looks like in a singlethreaded environment. =||= This is really painful to debug but I'm making progress. What I found out is that ""collectParentTestInstances()"" is non-deterministic:

```
Thread[16] collectParentTestInstances() - returns: [org.mockito.AnotherTest@2bf588f6]
Thread[13] collectParentTestInstances() - returns: [org.mockito.AnotherTest@240da1f5, org.mockito.AnotherTest@6646267a]
Thread[17] collectParentTestInstances() - returns: [org.mockito.AnotherTest@6646267a]
Thread[14] collectParentTestInstances() - returns: [org.mockito.AnotherTest@f9b9d48]
```

Notice that AnotherTest@6646267a is processed twice. Effectively, initMocks() is called twice for that test instance, clearing up the invocations.

Do you have an idea how to fix collectParentTestInstances()? =||= Perhaps we drop the collectParentTestInstances() complexity and just keep the test instances in static ThreadLocal object in the extension. postProcessTestInstance() feeds the thread local state, beforeEach() consumes it. I don't know enough about the ""context store"" API, though. =||= I have a plan how to fix it. First, we need to upgrade junit-jupiter (#1788) =||= @mockitoguy I am not sure why you have closed the issue. In the attached commit I cannot see the fix for the problem.

Context store API seems to be pretty simple to me, it is just a map in the context to store some information. The real question is what is this kind of context hierarchy used for in Junit 5 and how it behaves in case of nested tests or multithreaded tests, or even in multithreaded nested tests. I guess it could have some interesting beahaviour in case of parameterized (dynamic) tests. Probably it would be a good idea simply to ask the JUnit developers about this issue. Maybe they could provide some valuable feedback. =||= PR #1789 fixes the problem. This ticket got closed by accident. Thanks for looking into it! =||= Looking forward to the next release!
I would like to confirm the bug is gone, but I don't know how to do it in https://github.com/SchulteMarkus/mockito.bug1630.
Can someone add a PR to https://github.com/SchulteMarkus/mockito.bug1630 using Mockito 3.0.12 (at least)?  =||= Release have been already published. See https://bintray.com/mockito/maven/mockito-development =||= @mockitoguy when will this fix be released to maven central? =||= I will publish a release today =||= I updated https://github.com/SchulteMarkus/mockito.bug1630 - seems to work without problems using Mockito v.3.1.0, thanks a lot!
I will delete https://github.com/SchulteMarkus/mockito.bug1630 within a few weeks. =||= Publish to Maven Central failed yet again. I will need to contact sonatype again... =||= (Although https://repo1.maven.org/maven2/org/mockito/mockito-core/3.1.0/ does exist, so it might just work) =||= I can confirm, that the solution of 3.1.0 version works for all of the tests in my project. Still I don't understand how JUnit works, but it is fine now, since the tests work.

Thanks for your fast fix & release! =||= ",0
1789,1630,Mockito JUnit Jupiter extension does not correctly support parallel test execution,"Sorry for not being able to provide the required information, but we just noticed that the MockitoExtension (mockito-junit-jupiter 2.24.5) leads to spurious test failures (e.g. due to calls to mocks not being recorded) when using ""junit.jupiter.execution.parallel.enabled=true"" with surefire. Prior we used our much simpler MockitoExtension which works fine in the same situation:

```java
public class MockitoExtension implements Extension, TestInstancePostProcessor, AfterEachCallback {
   @Override
   public void postProcessTestInstance(Object testInstance, ExtensionContext context) {
      MockitoAnnotations.initMocks(testInstance);
   }

   @Override
   public void afterEach(ExtensionContext extensionContext) throws Exception {
      Mockito.validateMockitoUsage();
   }
}
```","Hey! Can you take a look at our FAQ wiki. We documented how Mockito supports parallel execution. =||= I took a look at the wiki, but found just a very short section about parallel testing in the FAQ section. I issued the bug, because the parallel execution of whole test cases with JUnit 5 seems to be broken. I do not have any complex tests which use mocks in combination with multithreading.

Anyway this seems to be a problem of the MockitoExtension, not Mockito itself. Because with our simple JUnit 5 extension for Mockito, parallel execution of test cases which use mocks with JUnit 5 works fine. =||= I got a similar issue. 
I have got a workaround, if only a few of your ""Mockito""-test-classes in you testsuite are failing when running JUnit jupiter in parallel. You can execute those problematic tests using ""SAME_THREAD"" for avoiding Mockito concurrency issues.

```
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
@Execution(ExecutionMode.SAME_THREAD) // <--- Workaround
class SomeTest {
``` =||= To be a bit more specific, WantedButNotInvoked exceptions are thrown by verification calls failing, because of not recorded invocations: ""Actually, there were zero interactions with this mock."". =||= The main difference between the current and the simple implementation above is, that the simple one inits the mocks in postProcessTestInstance() whereas the current one inits them in beforeEach(). Any ideas why that might be a problem? 

I tried the failing tests with a modified version of the current MockitoExtension which was just altered to init the mocks in postProcessTestInstance() and disabled the init in beforeEach() and the tests do no longer fail. So this seems to be the source of the problems. =||= Hey guys, can you provide us a test that reproduces the problem? Thanks! =||= @mockitoguy Here you go: https://github.com/SchulteMarkus/mockito.bug1630

I am not sure, if I reduced the example as much as possible, but, well, the project is not large. =||= Thank you! The sample project looks great!

I looked at the code but I haven't had time to debug it. How does the JUnit5 parallel execution work? Are we sharing the test instance (and thus, sharing mocks, SUTs?). =||= You are welcome :-) 
I don't know details about JUnit's parallelization. =||= > How does the JUnit5 parallel execution work? Are we sharing the test instance (and thus, sharing mocks, SUTs?).

By default not, and the user must be very explicit to enable sharing of the same test class instance with parallel execution enabled. I.e., even if parallel execution mode is enabled by default, and a test class is annotated with `Lifecycle.PER_CLASS`, its tests will still be executed sequentially _unless_ it is also annotated with `@Execution(CONCURRENT)`: https://junit.org/junit5/docs/current/user-guide/#writing-tests-parallel-execution

I also bumped into this issue in our codebase, with some tests using `MockitoExtension` failing in parallel mode, and some working fine. Could not spot anything particularly special about the failing ones.
 =||= I can confirm, that the problem exists. I also have tests using MockitoExtension and they fail in a non-deterministic way randomly only if Junit5 parralelization is used. =||= Scenario:

1. JUnit 5 creates a single `ClassExtensionContext `for a multithreaded test, but each thread becomes an instance of the test class
2. Each thread will come into `postProcessTestInstance `where they put their test instance in the same `ClassExtensionContext.getStore(MOCKITO)` map with the same key (`TEST_INSTANCE`)
3. Each thread then will get into `beforeEach`. They get a thread unique `MethodExtensionContext`, but each of them contain the same instance of `ClassExtensionContext`. Then they fetch the the last updated `TEST_INSTANCE `from the parent `ClassExtensionContext `inside the `collectParentTestInstances `method. Each thread gets quasi a random Test Instance depending on the fact which thread was before inside the `postProcessTestInstance `method. Then they prepare their broken Session inside the store of the current `MethodExtensionContext `with a random Test Instance included.

That is the explanation. I am thinking about how to solve this.

It is not 100% clear to me why the parent context test instance is included. I will check how this scenario looks like in a singlethreaded environment. =||= This is really painful to debug but I'm making progress. What I found out is that ""collectParentTestInstances()"" is non-deterministic:

```
Thread[16] collectParentTestInstances() - returns: [org.mockito.AnotherTest@2bf588f6]
Thread[13] collectParentTestInstances() - returns: [org.mockito.AnotherTest@240da1f5, org.mockito.AnotherTest@6646267a]
Thread[17] collectParentTestInstances() - returns: [org.mockito.AnotherTest@6646267a]
Thread[14] collectParentTestInstances() - returns: [org.mockito.AnotherTest@f9b9d48]
```

Notice that AnotherTest@6646267a is processed twice. Effectively, initMocks() is called twice for that test instance, clearing up the invocations.

Do you have an idea how to fix collectParentTestInstances()? =||= Perhaps we drop the collectParentTestInstances() complexity and just keep the test instances in static ThreadLocal object in the extension. postProcessTestInstance() feeds the thread local state, beforeEach() consumes it. I don't know enough about the ""context store"" API, though. =||= I have a plan how to fix it. First, we need to upgrade junit-jupiter (#1788) =||= @mockitoguy I am not sure why you have closed the issue. In the attached commit I cannot see the fix for the problem.

Context store API seems to be pretty simple to me, it is just a map in the context to store some information. The real question is what is this kind of context hierarchy used for in Junit 5 and how it behaves in case of nested tests or multithreaded tests, or even in multithreaded nested tests. I guess it could have some interesting beahaviour in case of parameterized (dynamic) tests. Probably it would be a good idea simply to ask the JUnit developers about this issue. Maybe they could provide some valuable feedback. =||= PR #1789 fixes the problem. This ticket got closed by accident. Thanks for looking into it! =||= Looking forward to the next release!
I would like to confirm the bug is gone, but I don't know how to do it in https://github.com/SchulteMarkus/mockito.bug1630.
Can someone add a PR to https://github.com/SchulteMarkus/mockito.bug1630 using Mockito 3.0.12 (at least)?  =||= Release have been already published. See https://bintray.com/mockito/maven/mockito-development =||= @mockitoguy when will this fix be released to maven central? =||= I will publish a release today =||= I updated https://github.com/SchulteMarkus/mockito.bug1630 - seems to work without problems using Mockito v.3.1.0, thanks a lot!
I will delete https://github.com/SchulteMarkus/mockito.bug1630 within a few weeks. =||= Publish to Maven Central failed yet again. I will need to contact sonatype again... =||= (Although https://repo1.maven.org/maven2/org/mockito/mockito-core/3.1.0/ does exist, so it might just work) =||= I can confirm, that the solution of 3.1.0 version works for all of the tests in my project. Still I don't understand how JUnit works, but it is fine now, since the tests work.

Thanks for your fast fix & release! =||= ",0
1798,1791,"Typo in Mockito.java Javadoc: ""verification"" in wiki link","https://github.com/mockito/mockito/blob/f8581c6e875dc3fb587fe31e85d025ef4d110a3f/src/main/java/org/mockito/Mockito.java#L2579

There's a missing ""i"" in the wiki link:

```
https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verfication-InOrder
https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verification-InOrder
```",Feel free to send a PR! =||= ,0
1810,1587,InjectingAnnotationEngine does an unnecessary loop.,"processInjectMocks method of InjectingAnnotationEngine does unnecessary work. It might call injectMocks several times while it is sufficient to call injectMocks once.

    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {
        Class<?> classContext = clazz;
        while (classContext != Object.class) {
            injectMocks(testInstance);
            classContext = classContext.getSuperclass();
        }
    }

Inside, injectMocks loops classes by himself.

    public void injectMocks(final Object testClassInstance) {
        Class<?> clazz = testClassInstance.getClass();
        Set<Field> mockDependentFields = new HashSet<Field>();
        Set<Object> mocks = newMockSafeHashSet();

        while (clazz != Object.class) {
            new InjectMocksScanner(clazz).addTo(mockDependentFields);
            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);
            onInjection(testClassInstance, clazz, mockDependentFields, mocks);
            clazz = clazz.getSuperclass();
        }

        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);
    }

Why not delete the unnecessary loop?",nan,0
1810,1587,InjectingAnnotationEngine does an unnecessary loop.,"processInjectMocks method of InjectingAnnotationEngine does unnecessary work. It might call injectMocks several times while it is sufficient to call injectMocks once.

    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {
        Class<?> classContext = clazz;
        while (classContext != Object.class) {
            injectMocks(testInstance);
            classContext = classContext.getSuperclass();
        }
    }

Inside, injectMocks loops classes by himself.

    public void injectMocks(final Object testClassInstance) {
        Class<?> clazz = testClassInstance.getClass();
        Set<Field> mockDependentFields = new HashSet<Field>();
        Set<Object> mocks = newMockSafeHashSet();

        while (clazz != Object.class) {
            new InjectMocksScanner(clazz).addTo(mockDependentFields);
            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);
            onInjection(testClassInstance, clazz, mockDependentFields, mocks);
            clazz = clazz.getSuperclass();
        }

        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);
    }

Why not delete the unnecessary loop?",nan,0
1813,1771,Upgrade byte-buddy to a 1.10.x release,"Currently mockito uses an older build of byte-buddy. I don't see any documentation or issues suggesting that there's a reason to avoid using a newer version, though the contribution documentation doesn't mention dependency upgrades.",":+1:  it should be officially upgraded to newer version of byte-buddy.

I am experiencing ""Unsupported class file major version 57"" (=Java 13) =||= We had an attempt in #1772 but Travis was unhappy. If someone could revive that PR and fix the build, that would be greatly appreciated! =||= ",0
1818,181,Warning when multiple instances of Mock exist,"I've ran into this a few times now and think that an error/warning message could be used. The situation is having two interfaces of the same type being mocked via annotations, then injecting via @InjectMocks. 

It seems at run/test time, that there is some probability either will be chosen.

Admittedly, this is an edge case, but would be faster to track down if there was a warning perhaps that multiple instances of the same interface were found, but no injection point (Constructor, Property, etc) was found that applies. 

I put together an example which is reproducible easily on my machine under the following:
- JDK 1.6 + Mockito 1.9.0

I don't mind looking into providing a fix for this myself, but wanted to formalize it here before looking into it.

If you run the following a few times, you'll get different assertion errors each time, depending on which MyService gets injected.

```
package example;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import static org.mockito.Mockito.verify;

@RunWith(MockitoJUnitRunner.class)
public class ExampleTest {

    @Service
    public static class MyService {

        public void doSomething() {
        }

    }

    @Service
    public static class MyClass {

        private final MyService myService;

        @Autowired
        public MyClass(MyService myService) {
            this.myService = myService;
        }

        public void doSomethingWithService() {
            myService.doSomething();
        }

    }

    @Mock
    private MyService myServiceInstance1;
    @Mock
    private MyService myServiceInstance2;
    @InjectMocks
    private MyClass myClass;

    @Test
    public void test1() throws Exception {
        myClass.doSomethingWithService();
        verify(myServiceInstance1).doSomething();
        verify(myServiceInstance2).doSomething();
    }
}
```","Hi,

This is a known, documented and wanted behavior. If by warning you mean writing a line to the console, this could probably done, however if it's about raising an exception then I'm not sure this is the smart move.
 =||= Since the current behavior is intermittent why it is considered wanted?

Cheers!

On Fri, Apr 3, 2015, 07:28 Brice Dutheil notifications@github.com wrote:

> Hi,
> 
> This is a known, documented and wanted behavior. If by warning you mean
> writing a line to the console, this could probably done, however if it's
> about raising an exception then I'm not sure this is the smart move.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/181#issuecomment-89303477.
 =||= Also @joshes I think more recent version of mockito have a more reproducible behavior (i.e. not intermittent) (check 1.9.5, 1.10.19)

The wanted behavior I'm speaking about is **to not fail if injection cannot happen**, because a developper **may choose to inject them afterward**. This is especially useful with objects that have exotic way of injections.
 =||= Thanks for the explanation @bric3  - that makes sense. 
 =||= ",0
1819,181,Warning when multiple instances of Mock exist,"I've ran into this a few times now and think that an error/warning message could be used. The situation is having two interfaces of the same type being mocked via annotations, then injecting via @InjectMocks. 

It seems at run/test time, that there is some probability either will be chosen.

Admittedly, this is an edge case, but would be faster to track down if there was a warning perhaps that multiple instances of the same interface were found, but no injection point (Constructor, Property, etc) was found that applies. 

I put together an example which is reproducible easily on my machine under the following:
- JDK 1.6 + Mockito 1.9.0

I don't mind looking into providing a fix for this myself, but wanted to formalize it here before looking into it.

If you run the following a few times, you'll get different assertion errors each time, depending on which MyService gets injected.

```
package example;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import static org.mockito.Mockito.verify;

@RunWith(MockitoJUnitRunner.class)
public class ExampleTest {

    @Service
    public static class MyService {

        public void doSomething() {
        }

    }

    @Service
    public static class MyClass {

        private final MyService myService;

        @Autowired
        public MyClass(MyService myService) {
            this.myService = myService;
        }

        public void doSomethingWithService() {
            myService.doSomething();
        }

    }

    @Mock
    private MyService myServiceInstance1;
    @Mock
    private MyService myServiceInstance2;
    @InjectMocks
    private MyClass myClass;

    @Test
    public void test1() throws Exception {
        myClass.doSomethingWithService();
        verify(myServiceInstance1).doSomething();
        verify(myServiceInstance2).doSomething();
    }
}
```","Hi,

This is a known, documented and wanted behavior. If by warning you mean writing a line to the console, this could probably done, however if it's about raising an exception then I'm not sure this is the smart move.
 =||= Since the current behavior is intermittent why it is considered wanted?

Cheers!

On Fri, Apr 3, 2015, 07:28 Brice Dutheil notifications@github.com wrote:

> Hi,
> 
> This is a known, documented and wanted behavior. If by warning you mean
> writing a line to the console, this could probably done, however if it's
> about raising an exception then I'm not sure this is the smart move.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/181#issuecomment-89303477.
 =||= Also @joshes I think more recent version of mockito have a more reproducible behavior (i.e. not intermittent) (check 1.9.5, 1.10.19)

The wanted behavior I'm speaking about is **to not fail if injection cannot happen**, because a developper **may choose to inject them afterward**. This is especially useful with objects that have exotic way of injections.
 =||= Thanks for the explanation @bric3  - that makes sense. 
 =||= ",0
1821,1767,'MismatchReportingTestListener' has already been added and not removed using MockitoJUnitRunner," - [x] The mockito message in the stacktrace have useful information, but it didn't help
 - [x] The problematic code (if that's possible) is copied here;
```
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.hasProperty;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.hamcrest.MockitoHamcrest.argThat;

import java.io.File;
import java.io.IOException;
import java.util.function.Consumer;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.pdfsam.support.params.SingleOutputTaskParametersBuilder;
import org.pdfsam.test.InitializeAndApplyJavaFxThreadRule;

@RunWith(MockitoJUnitRunner.class)
public class BrowsablePdfOutputFieldTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder();
    @Rule
    public InitializeAndApplyJavaFxThreadRule fxThread = new InitializeAndApplyJavaFxThreadRule();
    @Mock
    private SingleOutputTaskParametersBuilder<?> builder;
    @Mock
    private Consumer<String> onError;

    @Test
    public void valid() throws IOException {
        BrowsablePdfOutputField victim = new BrowsablePdfOutputField();
        File value = folder.newFile(""test.pdf"");
        victim.getTextField().setText(value.getAbsolutePath());
        victim.apply(builder, onError);
        verify(builder).output(argThat(hasProperty(""destination"", equalTo(value))));
        verify(onError, never()).accept(anyString());
    }

    @Test
    public void invalid() {
        BrowsablePdfOutputField victim = new BrowsablePdfOutputField();
        victim.enforceValidation(true, true);
        victim.getTextField().setText(""ChuckNorris"");
        victim.apply(builder, onError);
        verify(builder, never()).output(any());
        verify(onError).accept(anyString());
    }
}
```
 - [x] Provide versions (mockito / jdk / os / any other relevant information)
Mockito 3.0.0, AdoptOpenJDK 11.0.4, Linux Mint
 - [ ] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)

I migrated from 1.10.19 to the 3.0.0 version and I have few tests using the MockitoJUnitRunner which are failing with the following stacktrace:

```
org.mockito.exceptions.misusing.RedundantListenerException: 
Problems adding Mockito listener.
Listener of type 'MismatchReportingTestListener' has already been added and not removed.
It indicates that previous listener was not removed according to the API.
When you add a listener, don't forget to remove the listener afterwards:
  Mockito.framework().removeListener(myListener);
For more information, see the javadoc for RedundantListenerException class.
	at org.mockito.internal.runners.DefaultInternalRunner$1$1.evaluate(DefaultInternalRunner.java:41)
	at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:48)
	at org.pdfsam.test.JavaFXThreadRule$1.lambda$evaluate$0(JavaFXThreadRule.java:48)
	at com.sun.javafx.application.PlatformImpl.lambda$runLater$10(PlatformImpl.java:428)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:389)
	at com.sun.javafx.application.PlatformImpl.lambda$runLater$11(PlatformImpl.java:427)
	at com.sun.glass.ui.InvokeLaterDispatcher$Future.run(InvokeLaterDispatcher.java:96)
	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method)
	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:277)
	at java.base/java.lang.Thread.run(Thread.java:835)
```
It seems something internal, I didn't add or remove any `MismatchReportingTestListener` and moreover the same code was working with the 1.10.19 and is working if I remove the `MockitoJUnitRunner` and replace the `@Mock` annotation with a `Mockito.mock` in a `@Before` method.


","A lot of updates exist between 1.10.19 and 3.0.0. Could you bisect the versions and figure out which minor version introduced the issue? =||= 2.26.0 looks like the one introducing this issue, all green in 2.25.1 =||= @torakiki, can you provide us a simpler test that reproduces the issue? We are looking for a test without dependencies such as InitializeAndApplyJavaFxThreadRule, so that we can run & reproduce it in Mockito project.

Thanks for reporting!  =||= @torakiki any luck? I'm having the same issue, upgrading from 2.23.4

@mockitoguy here's a simple test reproducing the issue in my case:
```java
@RunWith(MockitoJUnitRunner.class)
public class UuidHelperTest {


    @Test
    public void should_Get_16_Bytes_From_a_UUID() {
        UUID uuid = UUID.randomUUID();

        byte[] result = UuidHelper.getBytesFromUUID(uuid);

        assertThat(result.length, is(16));
    }

}

public class UuidHelper {

    public static final int UUID_SIZE_IN_BYTES = 16;


    public static byte[] getBytesFromUUID(UUID uuid) {
        ByteBuffer bb = ByteBuffer.wrap(new byte[UUID_SIZE_IN_BYTES]);
        bb.putLong(uuid.getMostSignificantBits());
        bb.putLong(uuid.getLeastSignificantBits());

        return bb.array();
    }

}
``` =||= @SharonHart, this test works fine with current Mockito (3.0). Can you provide a test that fails with current Mockito? Thank you! =||= @mockitoguy It works with the current Mockito version for me as well, on a clean project.
 But in one specific project it doesn't, after a similar upgrade, as the one mentioned in this issue.  =||= @marcphilipp, @TimvdLippe Maybe this PR is related?
https://github.com/mockito/mockito/pull/1672/files#diff-f266327a2222bf41843bb64e18ba766eL59
It was merged between the versions @torakiki mentioned [here](https://github.com/mockito/mockito/issues/1767#issuecomment-527094823). 
Used to removeListener in case of test failure during setup, the same thing as the exception states that needs to be done.

Edit: I've reverted the commit locally and published to m2. Everything works now. Can this be reverted or checked for root cause? =||= @SharonHart Which version of JUnit are you using? We had a regression since 4.13 which is why we made the changes. See https://github.com/junit-team/junit4/pull/1599 =||= @TimvdLippe JUnit 4.12

By the way, seems like what's causing the regression for me is the withBefores statement part, not the 'started' field removal in the RunListener. But, the regression you've mention was with the prior, right? =||= @SharonHart Could you please provide a sample project so we can reproduce the issue? =||= @marcphilipp Unfortunately, I can't. I tried to copy the test to a clean project and it didn't reproduce.
Happening only in command line build, in one project which I can't share due to size and internal dependencies. 
I can verify if a fix works though, the same way I've managed to check if reverting the commit fixed the issue. =||= Are you running tests in parallel or anything like that? =||= Yes, in our CI pipeline. But reproduced locally with a single executor. It might be that the single one is running modules in parallel. I'm not sure.  =||= How are you running those tests? Maven Surefire? =||= No, with gradle, without extra plugins =||= What happens when you upgrade to JUnit 4.13-rc-1? =||= Same. =||= While I cannot provide a sample project to reproduce this issue, here are some observations that I made when running into the same issue:
1. I seems to be related one of the `@Rule`: I use a similar rule to what @torakiki has in his example:
<pre>
public class JavaFXThreadingRule implements TestRule {

        /**
        * Flag for setting up the JavaFX, we only need to do this once for all tests.
        */
        private static boolean jfxIsSetup;

        @Override
        public Statement apply(Statement statement, Description description) {

            return new OnJFXThreadStatement(statement);
        }

        private static class OnJFXThreadStatement extends Statement {

            private final Statement statement;

            public OnJFXThreadStatement(Statement aStatement) {
                statement = aStatement;
            }

            private Throwable rethrownException = null;

            @Override
            public void evaluate() throws Throwable {

                if(!jfxIsSetup) {
                    setupJavaFX();

                    jfxIsSetup = true;
                }

                final CountDownLatch countDownLatch = new CountDownLatch(1);

                Platform.runLater(() -> {
                    try {
                        statement.evaluate();
                    } catch (Throwable e) {
                        rethrownException = e;
                    }
                    countDownLatch.countDown();
                });

                countDownLatch.await();

                // if an exception was thrown by the statement during evaluation,
                // then re-throw it to fail the test
                if(rethrownException != null) {
                    throw rethrownException;
                }
            }

            protected void setupJavaFX() throws InterruptedException {

                long timeMillis = System.currentTimeMillis();

                final CountDownLatch latch = new CountDownLatch(1);

                SwingUtilities.invokeLater(() -> {
                    // initializes JavaFX environment
                    new JFXPanel();

                    latch.countDown();
                });

                System.out.println(""javafx initialising..."");
                latch.await();
                System.out.println(""javafx is initialised in "" + (System.currentTimeMillis() - timeMillis) + ""ms"");
            }

        }
}</pre>
2. My test class contains multiple test methods. Running them separately woks, when running them in combination (from within the IDE) the first one succeeds and then the remaining fail with this exception.
3. Removing the rule makes all tests succeed safe the ones that actually require the rule. =||= @hotzst Nice! I have managed to find that for me as well, a MethodRule we're implementing is what caused this. Question is, how should it be changed for the updated Mockito version.

```java

import org.joda.time.DateTimeZone;
import org.junit.rules.MethodRule;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;
import org.mockito.Mockito;
import org.mockito.internal.junit.MockitoTestListener;

import java.util.TimeZone;

/*
* When adding this rule to a Junit test, any @Test method annotated with @TimeZoned will be ran multiple times, each time
* with a different system timezone.
* This rule is useful to ensure you are handling all timezones correctly.
* Note: for Mockito, you may need to use Mockito.reset() if you are using verify().
* */
public class TimeZoneUpdateRule implements MethodRule {

    final private TimeZone timeZone;
    final private DateTimeZone dateTimeZone;
    private final static String[] allTimeZones = {""UTC"", ""Asia/Jerusalem"", ""Europe/London"", ""US/Pacific"", ""EST5EDT"", ""US/Eastern"",
            ""Australia/Sydney"", ""US/Central"", ""Asia/Tokyo"", ""America/Chicago"", ""GMT"",
            ""Europe/Amsterdam"", ""Europe/Berlin"", ""Brazil/East"", ""Asia/Jakarta"", ""Europe/Athens"",
            ""Australia/Queensland"", ""Asia/Singapore"", ""Asia/Bangkok"", ""America/Bogota"",
            ""America/Los_Angeles"", ""Asia/Hong_Kong"", ""America/New_York"",
            ""America/Argentina/Buenos_Aires""};

    public TimeZoneUpdateRule() {
        timeZone = TimeZone.getDefault();
        dateTimeZone = DateTimeZone.getDefault();
    }

    public void reset() {
        setTimeZone(timeZone, dateTimeZone);
    }

    protected void after() {
        reset();
    }

    private void setTimeZone(String timeZoneID) {
        setTimeZone(TimeZone.getTimeZone(timeZoneID), DateTimeZone.forID(timeZoneID));
    }

    private void setTimeZone(TimeZone timeZone, DateTimeZone dateTimeZone) {
        System.setProperty(""user.timezone"", timeZone.getID());
        TimeZone.setDefault(timeZone);
        DateTimeZone.setDefault(dateTimeZone);
    }

    private static String[] getTimeZones() {
        return allTimeZones;
    }


    @Override
    public Statement apply(final Statement st, final FrameworkMethod method, Object target) {
        return new Statement() {
            public void evaluate() throws Throwable {
                TimeZoned timeZoned = method.getAnnotation(TimeZoned.class);
                if(timeZoned !=null){
                    String[] timeZones =  timeZoned.timeZones().length > 0  ? timeZoned.timeZones() : getTimeZones();
                    applyAllTimeZones(st, timeZones);
                }else{
                    st.evaluate();
                }
            }

        };
    }

    private void applyAllTimeZones(Statement st, String[] timezones) throws Throwable {
        try {
            for (String tz : timezones) {
                setTimeZone(tz);
                st.evaluate();
            }
        }catch (AssertionError t){
            throw new AssertionError(getMessage(), t);
        }catch (Exception e){
            throw new RuntimeException(getMessage(), e);
        }
        finally {
            after();
        }
    }

    private String getMessage() {
        return ""test failed for timezone ["" + TimeZone.getDefault().getID()+ ""]"";
    }
}
``` =||= Thanks for the additional info. I think #1821 should restore the old behavior. =||= Thanks! =||= ",0
1828,1827,Cannot mock this class: class java.io.InputStream with Java 13,"## Versions
* Mockito: 3.1.0
* JDK: 13.0.1+9
* OS: macOS 10.13
* XCode: 10.1-19

## Code causing the error
```
InputStream in = mock(InputStream.class);
```

## Error:
```
[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.015 s <<< FAILURE! - in uk.gov.nationalarchives.droid.core.interfaces.archive.ZipEntryRequestFactoryTest
[ERROR] testNewZipRequest(uk.gov.nationalarchives.droid.core.interfaces.archive.ZipEntryRequestFactoryTest)  Time elapsed: 0.005 s  <<< ERROR!
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: class java.io.InputStream.
If you're not sure why you're getting this error, please report to the mailing list.
Java               : 13
JVM vendor name    : Oracle Corporation
JVM vendor version : 13.0.1+9
JVM name           : OpenJDK 64-Bit Server VM
JVM version        : 13.0.1+9
JVM info           : mixed mode, sharing
OS name            : Mac OS X
OS version         : 10.13.6
You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.
Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class java.io.InputStream, interface java.lang.AutoCloseable, interface java.io.Closeable]
	at uk.gov.nationalarchives.droid.core.interfaces.archive.ZipEntryRequestFactoryTest.testNewZipRequest(ZipEntryRequestFactoryTest.java:70)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class java.io.InputStream, interface java.lang.AutoCloseable, interface java.io.Closeable]
	at uk.gov.nationalarchives.droid.core.interfaces.archive.ZipEntryRequestFactoryTest.testNewZipRequest(ZipEntryRequestFactoryTest.java:70)
Caused by: java.lang.IllegalStateException: 
Byte Buddy could not instrument all classes within the mock's type hierarchy
This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
 - Compiled by older versions of scalac
 - Classes that are part of the Android distribution
	at uk.gov.nationalarchives.droid.core.interfaces.archive.ZipEntryRequestFactoryTest.testNewZipRequest(ZipEntryRequestFactoryTest.java:70)
Caused by: java.lang.IllegalArgumentException: Unsupported class file major version 57
	at uk.gov.nationalarchives.droid.core.interfaces.archive.ZipEntryRequestFactoryTest.testNewZipRequest(ZipEntryRequestFactoryTest.java:70)
```
","We had same issues with Java 13. I just overrode Mockito Byte Buddy dependency to a newer version (1.10.3), and it solved inline mock failures in our tests.

Submitted the upgrade in Mockito itself: #1828 =||= Please do not mock Inputstream, but create a real example with fake data instead. That said, we will update Byte Buddy to be compatible with Java 13. =||= Thank you @TimvdLippe ! Would it be possible please to push this release to Maven Central? Creating inline mocks of _any_ classes compiled with javac 13 does not work, not just platform classes like InputStream, so I think this release can be considered 'notable' according to the release policy. =||= It is being released: https://github.com/mockito/mockito/commit/d7c5ac446f156ba6fa913e041441ba4f566f3749 =||= Wonderful, thanks! =||= Thanks everyone for the quick response :-) =||= ",0
1840,1839,Bintray badge is out of date,"The badges in README.md show:
```
maven-central 3.2.0 Download 3.1.13
```
That makes the project looks sloppy, as if the developers forgot to update their downloads. ""Download"" is actually a link to Bintray, which should be clarified.

Bintray does have version 3.2.0. The old version is shown because the package name in the link is wrong. It should be ""mockito"", not ""mockito-development""",nan,0
1842,1841,Update byte-buddy to 1.10.5,"Hi,

Byte-buddy had a bug that prevented running tests in IntelliJ due to space in the executable name: https://github.com/raphw/byte-buddy/issues/732 This was fixed in [1.10.5](https://github.com/raphw/byte-buddy/releases/tag/byte-buddy-1.10.5) so it would make sense to update it in Mockito as well.",nan,0
1845,1815,FR: add Mockito.timeout(java.time.Duration) and after(java.time.Duration),"Representing durations as `long`'s is very error prone. We've seen (and fixed) hundreds of unit mismatch bugs inside of Google.

We (Guava) have recently updated most of our public APIs to add `java.time.Duration`-based overloads. [Caffeine](https://github.com/ben-manes/caffeine/issues/221) and [Selenium](https://github.com/SeleniumHQ/selenium/issues/7187) have done so as well.

Basically, I'd like to see the following APIs added:
`Mockito.after(java.time.Duration)`
`Mockito.timeout(java.time.Duration)`

And ideally the `long`-accepting APIs would be deprecated.","That would makes sense to me. Feel free to open a PR to add these methods.

@mockito/developers We have a lot of evidence of `long`s being misused in common API's. Do you have any concerns if we deprecate the `after(long)` in favor of `after(java.time.Duration)` (and the same for `timeout`)? =||= Ideally we'd plumb the `Duration` all the way through the various layers of Mockito:

- `org.mockito.verification.After`
- `org.mockito.verification.Timeout`
- `org.mockito.internal.verification.VerificationOverTimeImpl`
- `org.mockito.internal.util.Timer`

I assume `After` and `Timeout` need to maintain backwards compatibility, but the latter 2 are in an `internal` package - does that mean I don't need to maintain backwards compatibility? Am I free to make breaking changes to those APIs?
 =||= Yes, any API in `org.mockito.internal` is not included in our semver policy and we are free to change. =||= I second that, now that mockito 3 is java 8 based ! =||= ",0
1847,1846,Broken unused stubbing reporting when matching previous stubbed call,"When stubbing the same method call twice, and the second stub setup matches to first stubbed call, the first stub is not reported as unused, because Mockito detects the next stub setup as a usage of the previous stub setup. This is an example test:
```
public class UnnecessaryStubbingWithImplicitEqMatchers {
    @Mock IMethods mock;
    MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();

    @After public void after() {
        mockito.finishMocking();
    }

    @Test public void unnecessary_stubbing() {
        given(mock.simpleMethod(""1"")).willReturn(""one"");
        given(mock.simpleMethod(""2"")).willReturn(""three"");
        given(mock.simpleMethod(""1"")).willReturn(""two"");
        given(mock.simpleMethod(""1"")).willReturn(""four"");

        mock.simpleMethod(""1"");
        mock.simpleMethod(""2"");
    }
}
```

The test above should fail with `UnnecessaryStubbingException` containing two unused stubs, but it does not.

Mockito version: v3.2.4","Nice catch! I'll review the PR! =||= Hey @mockitoguy @andreisilviudragnea, I think this PR has introduced a new bug (or a regression if you like).

The problem arises when using Deep Stubs, as every call in a deep stub counts as used stubbing, but if you end up stubbing that mock for real this change will change the state of the original stubbing and your test will fail with an `UnnecessaryStubbingException`

The following example is in Scala, I don't have a running Java project at hand, but I can provide a 100% Java example if this is not enough to explain the problem

```scala
  class Foo {
    def userClass: Bar = {...}
  }
  class Bar {
    def callMeMaybe: Baz = {...}
  }
  class Baz {
    def callMe: Option[String] = {...}
  }

val aFoo = mock[Foo](DefaultAnswers.ReturnsDeepStubs)
aFoo.userClass.callMeMaybe.callMe returns Some(""my number"")
aFoo.userClass.callMeMaybe.callMe.value shouldBe ""my number""
```

That code will fail as there are 2 stubbings for `callMe`, one automatically created by the deep stub (see `ReturnsDeepStubs.class` line 67) and one for the actual stubbing I'm making to return `Some(""my number"")`.
 =||= This also breaks tests that needs to legitimately stub the same invocation multiple times. Particularly with invocations that have to arguments (since all invocations will match a previous stub). See https://github.com/mockito/mockito/commit/ce1632ddd6c55a7e85bec606536aa582a3b3aea1#diff-90b7e8e4bd136ee96421dc2adde3a918R71.

A simple common example is when stubbing a `Clock`:
```
@Mock
private Clock clock;

@Test 
void test() {
    Instant instant1 = Instant.ofEpochMillis(...);
    Instant instant2 = instant1.plus(...);

    when(clock.instant()).thenReturn(instant1);
    // do something at instant1

    when(clock.instant()).thenReturn(instant2);
    // do something at instant2
}
``` =||= @pkoenig10 yes, although that may not be the best example as you could use a chain of `thenReturn()` and have a single stubbing.
That said, for a non-experienced user that may not be obvious at all, so we'd have to weight it. =||= It's not obvious to me how you would work around this if your code calls `clock.instant()` a large or variable number of times. I find the suggested work around to be pretty verbose and unergonomic:
```
when(clock.instant())
    .thenReturn(instant1)
    .thenReturn(instant1)
    // repeat however many times is necessary
    .thenReturn(instant2)
    .thenReturn(instant2)
    // repeat however many times is necessary
```

I think the best and simplest way to improve this behavior is to not unmark the previous stubbing if it has been used. If the stubbing has not previously been used, then I think the current behavior is appropriate. Unfortunately this does seem like it will be a simple fix since the a second stubbing causes a previous stubbing to be marked as used. =||= @pkoenig10 I fail to see how that is less verbose than multiple stubbings, but in any case, that's not the point.
I think this change should be reverted until it can be given a deeper thought. do you agree? @mockito/developers ? =||= Revert in progress: https://github.com/mockito/mockito/pull/1878 =||= ",0
1849,1848,Use Method.getParameterCount() where possible,"Hi,

as of Mockito 3.x and its Java 8 requirement we could make use of `Method.getParameterCount()` to avoid unnecessary cloning caused by `Method.getParameterTypes()`.

I will shortly open a PR with the proposed changes.

Cheers,
Christoph",nan,0
1850,522,Provide OSGi test project to validate OSGi headers automatically.,"As stated in #82, we should provide a project for OSGi to validate correct exports.",nan,0
1850,678,OSGI bundle problem - incorrect version range syntax in manifest file,"The mockito-core version 2.1.0 has an incorrect version range syntax for the Byte Buddy dependencies  in the _META-INF/MANIFEST.MF_ file. Consequently, the bundle cannot be loaded by OSGi (tested with equinox R-4.6). 

Actual: 

> net.bytebuddy;version=""[1.4.26"",...

Expected: 

> net.bytebuddy;version=""[1.4.26,2.0)"",...

On the other hand, the version ranges for Objensis dependencies are specified correctly. 

The problem originates from missing double quotes around the version specification in https://github.com/mockito/mockito/blob/v2.1.0/gradle/osgi.gradle#L19 

Stacktrace: 

> !MESSAGE Error installing bundle: reference:file:plugins/mockito-core.jar
> !STACK 0
> org.osgi.framework.BundleException: Error occurred installing a bundle.
>     at org.eclipse.osgi.storage.Storage.install(Storage.java:562)
>     at org.eclipse.osgi.internal.framework.BundleContextImpl.installBundle(BundleContextImpl.java:146)
>     at org.eclipse.core.runtime.adaptor.EclipseStarter.installBundles(EclipseStarter.java:974)
>     at org.eclipse.core.runtime.adaptor.EclipseStarter.loadBasicBundles(EclipseStarter.java:583)
>     at org.eclipse.core.runtime.adaptor.EclipseStarter.startup(EclipseStarter.java:319)
>     at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:239)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
>     at java.lang.reflect.Method.invoke(Unknown Source)
>     at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
>     at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
>     at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
>     at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
> Caused by: java.lang.IllegalArgumentException: invalid range ""[1.4.26"": invalid format
>     at org.osgi.framework.VersionRange.<init>(VersionRange.java:173)
>     at org.eclipse.osgi.container.builders.OSGiManifestBuilderFactory.addPackageImports(OSGiManifestBuilderFactory.java:360)
>     at org.eclipse.osgi.container.builders.OSGiManifestBuilderFactory.getPackageImports(OSGiManifestBuilderFactory.java:339)
>     at org.eclipse.osgi.container.builders.OSGiManifestBuilderFactory.createBuilder(OSGiManifestBuilderFactory.java:87)
>     at org.eclipse.osgi.container.builders.OSGiManifestBuilderFactory.createBuilder(OSGiManifestBuilderFactory.java:54)
>     at org.eclipse.osgi.storage.Storage.getBuilder(Storage.java:604)
>     at org.eclipse.osgi.storage.Storage.install(Storage.java:531)
>     ... 13 more
> Caused by: java.util.NoSuchElementException
>     at java.util.StringTokenizer.nextToken(Unknown Source)
>     at org.osgi.framework.VersionRange.<init>(VersionRange.java:157)
>     ... 19 more","OK thank you for the report ! And fix in #679 
 =||= Now that #679 is closed this one can be closed too I guess.
 =||= ",0
1854,1853,Allow @MockitoSettings to be inherited," - [X] The mockito message in the stacktrace have useful information, but it didn't help
 - [X] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [X] Provide versions (mockito / jdk / os / any other relevant information)
 - [X] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [X] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)

I have a base test class which among other things mocks a ""serviceLocator"" and a very common class used by many other services:

```java
@ExtendWith(MockitoExtension.class)
public abstract class DomainServiceTests<T> {
	@Mock
	protected ServiceLocator sl;

	@Spy
	protected UserEnvironmentService userEnvironment;

	@BeforeEach
	public void setup() throws Exception {
		Mockito.when(sl.get(UserEnvironmentService.class)).thenReturn(userEnvironment);
	}
}
```

But whenever any test try to mock the get method of this serviceLocator with a different class I get an UnnecessaryStubbingException:

```
org.mockito.exceptions.misusing.UnnecessaryStubbingException:
    Unnecessary stubbings detected.
    Clean & maintainable test code requires zero unnecessary code.
    Following stubbings are unnecessary (click to navigate to relevant line of code):
      1. -> at *.DomainServiceTests.setup(DomainServiceTests.java:24)
    Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class.
```

Then I specify the strictness in the base test class 

```java
@MockitoSettings(strictness = Strictness.WARN)
public abstract class DomainServiceTests<T> {
```
But even though the strictness is not seen by mockito.

I have debugged the code and found that the strictness is retrieved by searching the annotation on the method and the class of the test

https://github.com/mockito/mockito/blob/b2b66f430a5bf890135c0c25872bf9869eb09aec/subprojects/junit-jupiter/src/main/java/org/mockito/junit/jupiter/MockitoExtension.java#L143-L145

This eventually calls 

https://github.com/junit-team/junit5/blob/5e41ebe612fd67e905f96f1dd3184a071b65be17/junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java#L108-L112
```java
public static <A extends Annotation> Optional<A> findAnnotation(AnnotatedElement element, Class<A> annotationType) {
	Preconditions.notNull(annotationType, ""annotationType must not be null"");
	boolean inherited = annotationType.isAnnotationPresent(Inherited.class);
	return findAnnotation(element, annotationType, inherited, new HashSet<>());
}
```

So if you annotate `MockitoSettings` with `java.lang.annotation.Inherited` it will work (I turned the inherited variable to true using the debugger to confirm).


For now I will have to annotate every test class with
```java
@MockitoSettings(strictness = Strictness.WARN)
```

I am using  Gradle 7.0 with JUnit 5.5.2

Thanks","Feel free to send a PR with a fix. Awesome issue description :) =||= Hi @TimvdLippe 

I am currently using the **mockito-junit-jupiter v3.2.4** and I can see that `@MockitoSettings` still does not have inheritance support:

```
@ExtendWith(MockitoExtension.class)
@Retention(RUNTIME)
public @interface MockitoSettings {
   ...
}
```
Do you know when, or, if there is any plans to release a new version of mockito-junit-jupiter containing this improvement?

For now I am including the annotation on each test, but it would be great to refactor and keep it on just my AbstractTest class. =||= New version should be pushing to Maven Central as we speak: https://github.com/mockito/mockito/commit/0a3064df2cbfcbf3145db54320c704971600ac6d =||= @TimvdLippe That's awesome!

Unfortunately Travis is not very happy:

```
[performRelease] > Could not sync 'mockito/maven/mockito/3.3.0' to Maven Central: HTTP/1.1 400 Bad Request [status:Sync Failed, messages:[Failed to close repository: orgmockito-1399. Server response:
[performRelease]    <nexus-error>
[performRelease]     <errors>
[performRelease]       <error>
[performRelease]         <id>*</id>
[performRelease]         <msg>Unhandled: Repository: orgmockito-1399 has invalid state: closed</msg>
[performRelease]       </error>
[performRelease]     </errors>
[performRelease]   </nexus-error>, Dropping existing partial staging repository.]]
```
 =||= That's sadly a known issue with Maven Central, but the artifact should be installable for you: https://repo1.maven.org/maven2/org/mockito/mockito-core/3.3.0/ =||= ",0
1878,1877,Regression: Overriding stubbing,"Hi,

There seems to be a regression in 3.3.0 from 3.2.4 (published on Maven Central).
The documentation states : 
> Stubbing can be overridden: for example common stubbing can go to fixture setup but the test methods can override it. Please note that overridding stubbing is a potential code smell that points out too much stubbing

But by simply making a copy of a stub by duplicating its line (or more realistically returning a different value in the second stub), an `UnnecessaryStubbingException` is thrown :

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class ATest {

  @Mock
  private ByteArrayInputStream stream;

  @Test
  public void duplicate() throws IOException {
    Mockito.when(stream.read(any())).thenReturn(1337);
    Mockito.when(stream.read(any())).thenReturn(1337); // duplicate line
    int value = stream.read(new byte[2048]);
    assertEquals(1337, value);
  }
}
```

```
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected.
Clean & maintainable test code requires zero unnecessary code.
There are 1 unnecessary stubbing (click to navigate to relevant line of code):
  1. -> at ATest.duplicate(ATest.java:21)
Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class.
	at org.mockito.junit.jupiter.MockitoExtension.afterEach(MockitoExtension.java:181)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeAfterEachCallbacks$11(TestMethodTestDescriptor.java:248)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeAllAfterMethodsOrCallbacks$13(TestMethodTestDescriptor.java:268)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeAllAfterMethodsOrCallbacks$14(TestMethodTestDescriptor.java:268)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeAllAfterMethodsOrCallbacks(TestMethodTestDescriptor.java:267)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeAfterEachCallbacks(TestMethodTestDescriptor.java:247)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:143)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:71)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:115)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:115)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171)
	at java.base/java.util.concurrent.RecursiveAction.exec(RecursiveAction.java:189)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1020)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1656)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1594)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:177)
```

 - [x] The mockito message in the stacktrace have useful information, but it didn't help
 - [x] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [x] Provide versions (mockito / jdk / os / any other relevant information)
 - [x] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)",nan,0
1881,1880,Unbalanced HTML tags in Javadoc of UnnecessaryStubbingException,"In the [Javadoc of that class](https://javadoc.io/static/org.mockito/mockito-core/3.3.1/org/mockito/exceptions/misusing/UnnecessaryStubbingException.html), the `<code` is not closed properly. Because of this, the following paragraphs are rendered in monospace font as well.

While here, `effect not` should be `effect of not`.","Could you send us a PR to fix this? =||= Wouldn't it be easier if you just added the missing `</code>` and `of`? It's just two words. =||= Yeah, if you could open a PR to make that change we can fix it 😄  =||= Closed due to too complicated workflow. =||= Let's reopen so that someone else can make the PR. =||= ",0
1890,1875,thenThrow(Class) no longer creates new instances,"As of #1162, `thenThrow(Class)` no longer creates new instances for each invocation.  We had tests that were reliant on that behavior; for example:
```
	@Test
	public void thenThrow() {
		Supplier<Object> r = mock(Supplier.class);
		when(r.get()).thenThrow(RuntimeException.class);
		RuntimeException first = null;
		for (int i = 0; i < 2; i++) {
			try {
				r.get();
			} catch (RuntimeException e) {
				if (first == null) {
					first = e;
				} else {
					first.addSuppressed(e);
				}
			}
		}
		if (first != null) {
			throw first;
		}
	}
```
These tests now fail:
```
java.lang.IllegalArgumentException: Self-suppression not permitted
	at java.lang.Throwable.addSuppressed(Throwable.java:1043)
	at example.Test.thenThrow(Test.java:10)
```","Hello, I've taken a look at the issue and it is still apparent in commit 560adf377677a4a2c658a0b24e2f9c2e0b373c20. It appears to be that `thenThrow(Class)` instantiates the Throwable when it is called rather than instantiating it upon mock interaction.

### Background
To why this leads to the behaviour described in the issue is that the Throwable is passed to `thenThrow(Throwable)` which instantiates a custom Answer with `new ThrowsException(throwable)` and passes into `thenAnswer(Answer)`. This Answer, of course, stores the Throwable and throws it with every repeat mock interaction.

Before the merge, `thenThrow(Class)` used to call `thenAnswer(Answer)` directly with its own custom Answer, ThrowsExceptionClass. This Answer instantiated the Exception with each mock interaction.

### Suggested Solution
My suggestion is to introduce an Answer similar to ThrowsExceptionClass described above (or a modified version of ThrowsException) and have `thenThrow(Class)` create that and call `thenAnswer(Answer)`.

I can think of two ways to implement the suggestion. Both ways involve storing the Class\<Throwable\> and using Objenesis to instantiate the Throwable in the new Answer class, however:

1. Create the new Answer class with similar code to ThrowsException but instead of throwing the stored Throwable it uses a new instance based of the stored Class\<Throwable\>.
2. Modify ThrowsException to use a protected getter method for the Throwable. Then extend ThrowsException with the new Answer for Class\<Throwable\> which overrides the getter method to instantiate a new Throwable.

Option 1 doesn't modify existing behaviour that works but has more duplicate code. Option 2 offers less duplicate code but modifies existing behaviour that works.

I prefer option 2.
 =||= Happy to review a PR for this. We probably need to make a few iterations on the design, but agreed we can fix this issue.

However, if the necessary changes appear to be complicated, I am inclined to close this as working as intended. =||= ",0
1892,1891,Build is not reproducible,"Repeated subsequent builds of the project create outputs which are not byte-for-byte identical, and so cannot be reproduced locally (see: [Reproducible Builds](https://reproducible-builds.org/))

This is due to:
 * File modification timestamps in JARs.
 * Non-deterministic file ordering in JARs.
 * OSGi bundle embedding timestamps in JAR manifests.

Given the build environment under which a version was created, I would like to be able to compare the checksums published on Bintray and/or Maven Central with a locally built version against the same environment, to assure myself that the artifact being pulled has actually been generated from this source code.

(I have a PR to address this which I am happy to raise)
",Feel free to open a PR and we can take a look 😄  =||= ,0
1895,1894,Checkstyle error on windows,"Hi, I can't build the project on windows. It ends with error:

<details>
$ ./gradlew clean build --parallel

> Configure project :
  Building version '2.28.3' (value loaded from 'version.properties' file).

> Task :deprecatedPluginsTest:checkstyleTest FAILED
> Task :android:checkstyleMain FAILED
> Task :errorprone:checkstyleMain FAILED
> Task :junit-jupiter:checkstyleMain FAILED
> Task :inline:checkstyleTest FAILED
w: Detected multiple Kotlin daemon sessions at build\kotlin\sessions

FAILURE: Build completed with 5 failures.

1: Task failed with an exception.
-----------
* What went wrong:
Execution failed for task ':deprecatedPluginsTest:checkstyleTest'.
> Unable to create Root Module: config {G:\programowanie\forki\mockito\config\checkstyle\checkstyle.xml}, classpath {G:\programowanie\forki\mockito\subprojects\deprecatedPluginsTest\build\classes\java\test;G:\programowanie\forki\mockito\subprojects\deprecatedPluginsTest\build\resources\test;G:\programowanie\forki\mockito\subprojects\deprecatedPluginsTest\build\classes\java\main;G:\programowanie\forki\mockito\subprojects\deprecatedPluginsTest\build\resources\main;G:\programowanie\forki\mockito\build\libs\mockito-core-2.28.3.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\junit\junit\4.12\2973d150c0dc1fefe998f834810d68f278ea58ec\junit-4.12.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy\1.9.10\211a2b4d3df1eeef2a6cacf78d74a1f725e7a840\byte-buddy-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy-agent\1.9.10\9674aba5ee793e54b864952b001166848da0f26b\byte-buddy-agent-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.objenesis\objenesis\2.6\639033469776fd37c08358c6b92a4761feb2af4b\objenesis-2.6.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.hamcrest\hamcrest-core\1.3\42a25dc3219429f0e5d060061f71acb49bf010a0\hamcrest-core-1.3.jar}.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
==============================================================================

2: Task failed with an exception.
-----------
* What went wrong:
Execution failed for task ':android:checkstyleMain'.
> Unable to create Root Module: config {G:\programowanie\forki\mockito\config\checkstyle\checkstyle.xml}, classpath {G:\programowanie\forki\mockito\subprojects\android\build\classes\java\main;G:\programowanie\forki\mockito\subprojects\android\build\resources\main;G:\programowanie\forki\mockito\build\libs\mockito-core-2.28.3.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy-android\1.9.10\fda8cb1715f7063c6177b0b3e9c09096b13b4bbb\byte-buddy-android-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy\1.9.10\211a2b4d3df1eeef2a6cacf78d74a1f725e7a840\byte-buddy-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy-agent\1.9.10\9674aba5ee793e54b864952b001166848da0f26b\byte-buddy-agent-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.objenesis\objenesis\2.6\639033469776fd37c08358c6b92a4761feb2af4b\objenesis-2.6.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.jakewharton.android.repackaged\dalvik-dx\1\5344672f614ef1df39f7a9d88a5aa0e44d74d4d9\dalvik-dx-1.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.jakewharton.android.repackaged\libcore-dex\2\1d3c98644912295ca8cb80069b1cdea4389085b2\libcore-dex-2.jar}.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
==============================================================================

3: Task failed with an exception.
-----------
* What went wrong:
Execution failed for task ':errorprone:checkstyleMain'.
> Unable to create Root Module: config {G:\programowanie\forki\mockito\config\checkstyle\checkstyle.xml}, classpath {G:\programowanie\forki\mockito\subprojects\errorprone\build\classes\java\main;G:\programowanie\forki\mockito\subprojects\errorprone\build\resources\main;G:\programowanie\forki\mockito\build\libs\mockito-core-2.28.3.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.errorprone\error_prone_core\2.3.2\d5d121a23bcd48df2fe42dc3f1424cd05872993\error_prone_core-2.3.2.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.auto.service\auto-service\1.0-rc5\d25246bae325b4bcc63b55d6d782515fac32215a\auto-service-1.0-rc5.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy\1.9.10\211a2b4d3df1eeef2a6cacf78d74a1f725e7a840\byte-buddy-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy-agent\1.9.10\9674aba5ee793e54b864952b001166848da0f26b\byte-buddy-agent-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.objenesis\objenesis\2.6\639033469776fd37c08358c6b92a4761feb2af4b\objenesis-2.6.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.errorprone\error_prone_check_api\2.3.2\7415438c00adec8ba707689ec4168c8484d8403b\error_prone_check_api-2.3.2.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.errorprone\error_prone_annotation\2.3.2\7c554c59dd2ea8c4e9e36b3308f8bf92db83e70c\error_prone_annotation-2.3.2.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.errorprone\error_prone_type_annotations\2.3.2\e79e88b9051888c8ea806f49c86fa7e3e3728180\error_prone_type_annotations-2.3.2.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.github.stephenc.jcip\jcip-annotations\1.0-1\ef31541dd28ae2cefdd17c7ebf352d93e9058c63\jcip-annotations-1.0-1.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.pcollections\pcollections\2.1.2\15925fd6c32a29fe3f40a048d238c5ca58cb8362\pcollections-2.1.2.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.auto\auto-common\0.10\c8f153ebe04a17183480ab4016098055fb474364\auto-common-0.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.guava\guava\27.0.1-jre\bd41a290787b5301e63929676d792c507bbc00ae\guava-27.0.1-jre.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.code.findbugs\jFormatString\3.0.0\d3995f9be450813bc2ccee8f0774c1a3033a0f30\jFormatString-3.0.0.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.code.findbugs\jsr305\3.0.2\25ea2e8b0c338a877313bd4672d3fe056ea78f0d\jsr305-3.0.2.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.checkerframework\dataflow\2.5.3\edf284e0838290d661b22483ecf648065e7ec440\dataflow-2.5.3.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.errorprone\javac\9+181-r4173-1\bdf4c0aa7d540ee1f7bf14d47447aea4bbf450c5\javac-9+181-r4173-1.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.errorprone\error_prone_annotations\2.3.2\d1a0c5032570e0f64be6b4d9c90cdeb103129029\error_prone_annotations-2.3.2.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.protobuf\protobuf-java\3.4.0\b32aba0cbe737a4ca953f71688725972e3ee927c\protobuf-java-3.4.0.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.auto.service\auto-service-annotations\1.0-rc5\6ea999af2b6262a7179a09c51a3d54e7b40a3833\auto-service-annotations-1.0-rc5.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.googlecode.java-diff-utils\diffutils\1.3.0\7e060dd5b19431e6d198e91ff670644372f60fbd\diffutils-1.3.0.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.github.kevinstern\software-and-algorithms\1.0\5e77666b72c6c5dd583c36148d17fc47f944dfb5\software-and-algorithms-1.0.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.checkerframework\javacutil\2.5.3\c545ca6fc7a57e3bc65d46e8e9438376f0db35ea\javacutil-2.5.3.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.checkerframework\checker-qual\2.5.3\4fe154d21bd734fe8c94ada37cdc41a9a6d61776\checker-qual-2.5.3.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.guava\failureaccess\1.0.1\1dcf1de382a0bf95a3d8b0849546c88bac1292c9\failureaccess-1.0.1.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.guava\listenablefuture\9999.0-empty-to-avoid-conflict-with-guava\b421526c5f297295adef1c886e5246c39d4ac629\listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\com.google.j2objc\j2objc-annotations\1.1\ed28ded51a8b1c6b112568def5f4b455e6809019\j2objc-annotations-1.1.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.codehaus.mojo\animal-sniffer-annotations\1.17\f97ce6decaea32b36101e37979f8b647f00681fb\animal-sniffer-annotations-1.17.jar}.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
==============================================================================

4: Task failed with an exception.
-----------
* What went wrong:
Execution failed for task ':junit-jupiter:checkstyleMain'.
> Unable to create Root Module: config {G:\programowanie\forki\mockito\config\checkstyle\checkstyle.xml}, classpath {G:\programowanie\forki\mockito\subprojects\junit-jupiter\build\classes\java\main;G:\programowanie\forki\mockito\subprojects\junit-jupiter\build\resources\main;G:\programowanie\forki\mockito\build\libs\mockito-core-2.28.3.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.junit.jupiter\junit-jupiter-api\5.1.1\fcca73c9c2825c9a966380c6d146a71acba233ca\junit-jupiter-api-5.1.1.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy\1.9.10\211a2b4d3df1eeef2a6cacf78d74a1f725e7a840\byte-buddy-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy-agent\1.9.10\9674aba5ee793e54b864952b001166848da0f26b\byte-buddy-agent-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.objenesis\objenesis\2.6\639033469776fd37c08358c6b92a4761feb2af4b\objenesis-2.6.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.junit.platform\junit-platform-commons\1.1.1\36fca464a84454cf56ae2759a8ba18d6d99d1113\junit-platform-commons-1.1.1.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.apiguardian\apiguardian-api\1.0.0\3ef5276905e36f4d8055fe3cb0bdcc7503ffc85d\apiguardian-api-1.0.0.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.opentest4j\opentest4j\1.0.0\6f09c598e9ff64bf0ce2fa7e7de49a99ba83c0b4\opentest4j-1.0.0.jar}.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
==============================================================================

5: Task failed with an exception.
-----------
* What went wrong:
Execution failed for task ':inline:checkstyleTest'.
> Unable to create Root Module: config {G:\programowanie\forki\mockito\config\checkstyle\checkstyle.xml}, classpath {G:\programowanie\forki\mockito\subprojects\inline\build\classes\java\test;G:\programowanie\forki\mockito\subprojects\inline\build\resources\test;G:\programowanie\forki\mockito\subprojects\inline\build\classes\java\main;G:\programowanie\forki\mockito\subprojects\inline\build\resources\main;G:\programowanie\forki\mockito\build\libs\mockito-core-2.28.3.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\junit\junit\4.12\2973d150c0dc1fefe998f834810d68f278ea58ec\junit-4.12.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy\1.9.10\211a2b4d3df1eeef2a6cacf78d74a1f725e7a840\byte-buddy-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\net.bytebuddy\byte-buddy-agent\1.9.10\9674aba5ee793e54b864952b001166848da0f26b\byte-buddy-agent-1.9.10.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.objenesis\objenesis\2.6\639033469776fd37c08358c6b92a4761feb2af4b\objenesis-2.6.jar;F:\programowanie\gradleCache\caches\modules-2\files-2.1\org.hamcrest\hamcrest-core\1.3\42a25dc3219429f0e5d060061f71acb49bf010a0\hamcrest-core-1.3.jar}.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
==============================================================================

* Get more help at https://help.gradle.org

Deprecated Gradle features were used in this build, making it incompatible with Gradle 6.0.
Use '--warning-mode all' to show the individual deprecation warnings.
See https://docs.gradle.org/5.3.1/userguide/command_line_interface.html#sec:command_line_warnings

BUILD FAILED in 38s
108 actionable tasks: 87 executed, 7 from cache, 14 up-to-date
</details>

I've fixed this issue but just need an issue for PR.","Could you paste the full build output? You can wrap it in `<details></details>` here on github to prevent a wall of text.

Also, feel free to open your PR and happy to take a look. =||= PR created - https://github.com/mockito/mockito/pull/1895 
please verify on unix

(there are 2 commits because at first I didnt know that v2 is in maintenance only, so I created new branch from release/3.x hence the second commit) =||= ",0
1911,1910,Documentation of ArgumentMatchers any() is confusing,"https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/ArgumentMatchers.html#any--

The doc says that 
> any() is an alias of: anyObject() and any(java.lang.Class).

But in the note, it says that 
> Since mockito 2.1.0 any(Class) is not anymore an alias of this method.

This is confusing, so the alias in the doc should exclude any(java.lang.Class) to simply be 
> any() is an alias of: anyObject()

The doc of anyObject() also has the same confusing issue.

",nan,0
1914,1905,ArgumentMatchers.matches not working,"* Ver. mockito-core:3.3.3
* Java Pattern and java Matcher

```java
Pattern pat = Pattern.compile(""^zman-server-"");
Matcher mat = pat.matcher(""zman-server-store.properties"");
mat.find() // return true
```

* Mockito matcher not wrking:

```
when(streamer.load( matches(pat))).thenReturn(stream);

Output:
- this invocation of 'load' method:
    streamer.load(
    ""zman-server-store.properties""
);
 - has following stubbing(s) with different arguments:
    1. streamer.load("""");

```","Hello,

I've taken a look at the issue and after doing some digging I found that `matches(Pattern)` uses [`java.util.regex.Matchers.matches()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Matcher.html#matches()) in `org.mockito.internal.matchers.Matches.matches(Object)` which requires the entire region to match, not just some sub-region like [`Matchers.find()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Matcher.html#find()) does. This means that your matcher fail when testing to see if your answer, `thenReturn(stream)`, is suitable for the mock's `load(...)` invocation.

I'll probably make a PR with the solution, appropriate acceptance testing and any needed documentation changes.

 =||= Thx, that explain a lot. =||= ",0
1914,190,Build Fails with NoClassDefFoundError on CglibMockMaker,"Hi,
   my maven build fails when I try to mock a class with the error below. I am beginner with mockito. Can someone please help with this? I am trying to build from command line. I am trying to build a scala project. 

Java version: 1.7
Project type: scala project
mockito version: 

``` xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-all</artifactId>
    <version>1.10.19</version>
</dependency>
```

Error that I get during maven build:

```
←[31m*** RUN ABORTED ***←[0m
←[31m  java.lang.NoClassDefFoundError: org/mockito/internal/creation/CglibMockMaker←[0m
←[31m  at org.powermock.api.mockito.internal.mockmaker.PowerMockMaker.<init>(PowerMockMaker.java:40)←[0m
←[31m  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)←[0m
←[31m  at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)←[0m
←[31m  at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)←[0m
←[31m  at java.lang.reflect.Constructor.newInstance(Constructor.java:526)←[0m
←[31m  at java.lang.Class.newInstance(Class.java:374)←[0m
←[31m  at org.mockito.internal.configuration.plugins.PluginLoader.loadImpl(PluginLoader.java:61)←[0m
←[31m  at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:24)←[0m
←[31m  at org.mockito.internal.configuration.plugins.PluginRegistry.<init>(PluginRegistry.java:12)←[0m
←[31m  at org.mockito.internal.configuration.plugins.Plugins.<clinit>(Plugins.java:11)←[0m
←[31m  ...←[0m
←[31m  Cause: java.lang.ClassNotFoundException: org.mockito.internal.creation.CglibMockMaker←[0m
←[31m  at java.net.URLClassLoader$1.run(URLClassLoader.java:366)←[0m
←[31m  at java.net.URLClassLoader$1.run(URLClassLoader.java:355)←[0m
←[31m  at java.security.AccessController.doPrivileged(Native Method)←[0m
←[31m  at java.net.URLClassLoader.findClass(URLClassLoader.java:354)←[0m
←[31m  at java.lang.ClassLoader.loadClass(ClassLoader.java:425)←[0m
←[31m  at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)←[0m
←[31m  at java.lang.ClassLoader.loadClass(ClassLoader.java:358)←[0m
←[31m  at org.powermock.api.mockito.internal.mockmaker.PowerMockMaker.<init>(PowerMockMaker.java:40)←[0m
←[31m  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)←[0m
←[31m  at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)←[0m
←[31m  ...←[0m
```","Hi,

We are happy that you are using mockito, but for support please use the [mockito mailing-list](http://groups.google.com/group/mockito) or [stackoverflow](http://stackoverflow.com) :)

With the given info there's not enough info to diagnose the issue, it seems to be related to classpath though. 
 =||= Oh I just identified the issue, this project is using powermock, which is depending / hacking in mockito internals, those have change in version 1.10.8. However there's a new version of powermock 1.6.2 that work with mockito 1.10.19
 =||= Thanks...It did the trick  and saved my time!! :)
 =||= This trick saved my life
 =||= You saved the day bro!
Thanks. :) =||= Thanks a lot bric3 :) =||= ",0
1942,1898,RETURNS_DEEP_STUBS override a mock's toString to `null`,"This example describes the issue:

```
  @Test
  public void mocksWithDeepStubsReturnNameOnToString() {
    Object proudMock = Mockito.mock(
        Object.class,
        Mockito.withSettings()
            .name(""I'm a mock!"")
            .defaultAnswer(Mockito.RETURNS_DEEP_STUBS));

    // fails, toString() returns null
    assertThat(proudMock.toString()).isEqualTo(""I'm a mock!"");
  }
```

I'm experiencing this on 2.26.0, (looking at [ReturnsDeepStubs](https://github.com/mockito/mockito/blame/release/3.x/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java) looks like it hasn't changed much since then).

I think toString should still return the mock's name, right now it returns a `null`.",nan,0
1942,189,Compatibility of BDDMockito.then() with AssertJ and Catch-Exception,"Mockito's `BDDMockito.then()` clashes with AssertJ's `BDDAssertions.then()` and Catch-Exception's `BDDCatchException.then()`, meaning that in a same test class it is not possible to use BDD style to assert simultaneously:
- a mock's behaviour (BDDMockito: `then(dependency).delete(1)`)
- a return value (BDDAssertions: `then(result).isEqualTo(""value"")`)
- an exception throw (BDDCatchException: `then(caughtException()).isInstanceOf(BlahException.class)`)

It is not clear which library exactly could resolve this issue, but currently this conflict reduces the usability of all three of them. If they are all needed within a same test class, then static import cannot be used, and even when used in separate test classes, the developer can get quite easily confused as to which static import is required.","Correction ;

> it is not possible to use BDD style to assert simultaneously **when using static imports**

_catch-exception_ lib will no more be updated as stated by his author. Then I don't see any reasonable way to fix this in any lib as they are not coupled and they have no reason to. We won't remove or rename this API `BDDMockito.then`, and I'd rather not introduce too many aliases.

In the mean time the only sensible thing to do would be to create a class that can serve as an API dispatcher, in pseudo code something like:

``` java
BDDDispatcher { 
    assertjThen(...)
    thenVerify(...)
    ...
}
```
 =||= > catch-exception lib will no more be updated as stated by his author

Could you show where this is stated? https://github.com/Codearte/catch-exception is currently active. Or what system should be used instead to test exceptions in BDD style?

> In the mean time the only sensible thing to do would be to create a class that can serve as an API dispatcher

What do you mean by 'in the meantime'? What is the long-term solution to cleanly test mocks, exceptions and return values in BDD style? `assertjThen` and `thenVerify` are quite less readable than `then` and this places the maintenance burden on the developer.

Maybe I will try the Spock library to avoid these limitations.
 =||= > > catch-exception lib will no more be updated as stated by his author
> 
> Could you show where this is stated? https://github.com/Codearte/catch-exception is currently active. Or what system should be used instead to test exceptions in BDD style?

I remember I saw it at some point last year on GC at their old home : https://code.google.com/p/catch-exception/ but it seem they have changed their plan, I didn't even know they migrated to GH. Actually I prefer AssertJ for assertions, with version 2.0.0 there's nifty API on that matter.

> > In the mean time the only sensible thing to do would be to create a class that can serve as an API dispatcher
> 
> What do you mean by 'in the meantime'?

I mean that until mockito team reach consensus on this API change, this issue is on hold.

> What is the long-term solution to cleanly test mocks, exceptions and return values in BDD style?

It's probably a question of taste, but I don't see any clarity problem if not using _static imports_, note that the little pseudo code is just random ideas, but this can of course be renamed according to your taste. Maybe asking on the mockito mailing list can help on that matter.

Spock is indeed a great tool, I don't know they integrate stuff still. If you have feedback I'm interested.
 =||= Im a guy from catch-exception team :) I would recommend to use `BDDAssertions.then` instead of `BDDCatchException.then`. This combo works fine for Java6 and Java7. `BDDCatchException.then` is here only for compatibility with Java8

<del>Java8 has some problem with generics (bug? or feature) and do not compile. I would recommend using AssertJ `BDDAssertions.thenThrownBy` alone (without catch-exception)</del>

Issue with Java8 is fixed in latest catch-exception. `BDDCatchException.then` is deprecated now, use `BDDAssertions.then` instead.
 =||= OK great :) I use Java 8 and your solution works, so things are settled regarding catch-exception by using the AssertJ API (`BDDAssertions.then()`).

Now the solution on Mockito side should IMHO be the same: use the AssertJ API (a nifty API as you mentioned). Otherwise we are stuck with using `verify()` instead of `then().should...()` to check mock interactions and thus cannot use BDD style.

I also tested Spock 1.0 (spock-core + spock-spring) to write unit tests and Spring integration tests (including with `MockMvc` and transactions) and I can recommend it so far, as it covers everything I asked here and much more with a clean BDD style. Just need some patience to learn Groovy and some things which are approached in a different way (e.g. ""Mocking and stubbing of the same method call has to happen in the same interaction"" cfr. http://spockframework.github.io/spock/docs/1.0/interaction_based_testing.html).
 =||= OK, thanks for the feedback @mariuszs. And Thanks for the feedback on Spock too :)

> Now the solution on Mockito side should IMHO be the same: use the AssertJ API.

I don't follow you there. The only possible thing to do is to add other _tactical_ aliases, @szczepiq and I have mixed feelings about that. That's why I proposed to create a custom _dispatch_ api with those tactical aliases, e.g.

``` java
then(bike).contains(a_handlebar)
thenA(person).should(times(2)).ride(bike);
```
 =||= From my user's endpoint, I see that Catch-Exception has been able to resolve this issue of conflicting `then()`s by checking caught exceptions through the AssertJ API. So all I'm saying is that Mockito should IMHO do the same, so that the only `then()` that the user should call would be AssertJ's (which makes sense, it _is_ an assertion API).
 =||= Indeed, but AssertJ has nothing to do with mocks ;)
It's not the role of AssertJ to know mockito internals to check the interactions. Also current mockito matchers API is based on hamcrest. And for several reason upgrading hamcrest has proven to be a difficult task, we now even want to remove the dependency on external framework as much as possible including hamcrest.
 =||= ",0
1948,192,Added a default answer for java.util.Optional,"I've introduced a new default answer for `java.util.Optional` that returns an empty optional.

The code uses reflection, so it should compile and run cleanly in older versions than Java 8.

---

**EDIT by mockito team** : fixes #191 ","For reference this would help on #191 .

Thanks for the PR :sunglasses: 
A nice start to suport Java 8, I had something like that in mind, however I'd like to go a bit further :
- On types because there's other Java 8 types as well
- Introducing something like `Platform.saneDefaults()` that provide empty values, but maybe other _service_ as well

I won't have time until next weeks though to work on it.
 =||= What other Java 8 types would you like to support? Maybe `java.util.Stream`? I can't really see default null values for the new `java.time` types.

I personally really dislike the class `JavaEightUtil` that I introduced, but couldn't think of a better way to encapsulate the reflection magic.

And I have no idea why the build is failing. Works on my machine, as always, and the travis output is not really helpful. :-/

I'm going to be on a two-week vacation from now on, but I would like to help after that. :-)
 =||= Don't worry about the build, it's broken for a unknown reason.

Also I'm quite overwhelmed at the moment, 2 real life projects are in a critical phase. So I won't be able to work on this as soon as possible, and as I would like.

> What other Java 8 types would you like to support? Maybe java.util.Stream? I can't really see default null values for the new java.time types.

Actually I would like to first return default values for `Iterable`, `Iterator`, `Stream`, `BigInteger`, `BigDecimal`.

For time related classes, I have mixed feelings, I'd like to not return `null` but I'm not sure about the default value, `now` seems reasonable though. Thoughts ?
 =||= I guess the collection and number types should be quite easy. I can work on that, adding support by reflection depending on the Java version.

Looking at the date and time classes, i don't see a sensible default value. ""now"" is not the right way to go IMHO. It feels like always returning 1 for an integer... I guess `null` is quite ok, possibly failing tests to force people to actually mock this specific method.

I'll also have a look at how much trouble would it be to upgrade the build process to Java 8 while maintaining backwards compatibility.
 =||= I wanted to work on such things in few weeks. I wanted to have integration modules, with possible different versions of library JDK. Specifically of the JDK 8 I had this idea of using [JavaVersion](http://gradle.org/docs/current/javadoc/org/gradle/api/JavaVersion.html).

``` java
JavaVersion.current().isJava8Compatible()
```

and disable the module if false, I don't know well gradle, maybe something like that could work (it's almost pseudo code)

``` java
subprojects {
    afterEvaluate { project ->
        if (project.name.equals(""java8-integration-tests"")) 
            && !JavaVersion.current().isJava8Compatible()) {
            test.disabled = true
        }
    }
}
```
 =||= Back from vacation. :-)

I don't think it is advisable to do the destinction at build time. No need for gradle from my point of view.

How about introducing the following interface:

```
public interface DefaultAnswerProvider {
    boolean isApplicable(Class<?> type);
    <T> T provideDefaultAnswer(Class<T> type);
}
```

All the different strategies to create empty values in `ReturnsEmptyValues` would be moved to one individual implementation of this interface. For example:

```
public class PrimitiveOrWrapperDefaultAnswerProvider implement DefaultAnswerProvider {
    public boolean isAcceptable(Class<?> type) {
        return Primitives.isPrimitiveOrWrapper(type);
    }

    public <T> T provideDefaultAnswer(Class<T> type) {
        return Primitives.defaultValueForPrimitiveOrWrapper(type);
    }
}
```

`ReturnsEmptyValues` would contain a list of these providers, select the first one applicable to a given type and return the default answer.

Any provider that requires an external library or specific java version (`OptionalDefaultAnserProvider`, `Stream` etc.) would use reflection to check for acceptability (`""java.util.Stream"".equals(type.getName())`) and for the creation of the default answer.

Throw in some caching to speed up provider resolution.

This approach has the following benefits:
- separates different strategies to create default values
- keeps nasty reflection logic isolated
- allows default values for external libraries, e.g. `commons-collections`

I can think of more ways to enhance this:
- allow users to register their own default answer providers
- allow JARs to automatically register default answer providers by use of the SPI. This would lead to the possibility for third-party libraries to extend mockito like `mockito-java8.jar` or `mockito-commons-collections.jar`

I would be happy to contribute, if you are interested.
 =||= @phjardas Sorry for late reply. Yes for runtime I had this idea ;)

But I was specifically speaking about a java 8 integration testing. The idea of plugin in a _default answer_ provider is interesting, that may be part of mockito plugins.
 =||= Allright, then I'll just wait. If you need any help, let me know! :-)
 =||= Reopening, so we'll keep track of it, when done ;)
 =||= This has landed in master with https://github.com/mockito/mockito/commit/c992dde1cedbb890b6bb56493e2e67926398445d
 =||= ",0
1949,1712,"""description"" not printing when verify args don't match","Mockito version 2.27.0

I have a test that uses `description` inside a `verify` method. The `description` is correctly printing when the test fails because we don't interact with the mock

```
import static org.mockito.Mockito.description;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;

import org.junit.Test;

public class ExampleTest {
    @Test
    public void shouldFailWithDescription() {
        Dependency dependency = spy(Dependency.class);
        SystemUnderTest systemUnderTest = new SystemUnderTest();
        systemUnderTest.doSomething(dependency);
        verify(dependency, description(""Failed to call doSomethingElse"")).doSomethingElse(false);
    }

    static class SystemUnderTest {
        void doSomething(Dependency dependency) {
            // dependency.doSomethingElse(true); // <---- TEST FAILS BECAUSE WE DON'T INTERACT WITH MOCK
        }
    }

    static class Dependency {
        void doSomethingElse(boolean value) {
            // ...
        }
    }
}
```

Results in this failure message:

```
org.mockito.exceptions.base.MockitoAssertionError: Failed to call doSomethingElse <---- SEE OUR DESCRIPTION

Wanted but not invoked:
dependency.doSomethingElse(false);
-> at com.example.ExampleTest$Dependency.doSomethingElse(ExampleTest.java:28)
Actually, there were zero interactions with this mock.
```

In this case the test failed because there were no interactions with this mock. However if we update the SUT so that it calls the method with the wrong argument:

```
public class ExampleTest {
    @Test
    public void shouldFailWithDescription() {
        Dependency dependency = spy(Dependency.class);
        SystemUnderTest systemUnderTest = new SystemUnderTest();
        systemUnderTest.doSomething(dependency);
        verify(dependency, description(""Failed to call doSomethingElse"")).doSomethingElse(false);
    }

    static class SystemUnderTest {
        void doSomething(Dependency dependency) {
             dependency.doSomethingElse(true);  // <---- TEST FAILS BECAUSE WE PASS WRONG ARGS
        }
    }

    static class Dependency {
        void doSomethingElse(boolean value) {
            // ...
        }
    }
}
```

The test still fails. But this time it **does not include the description**:

```
Argument(s) are different! Wanted: <----- WE SHOULD SEE DESCRIPTION
dependency.doSomethingElse(false);
-> at com.example.ExampleTest$Dependency.doSomethingElse(ExampleTest.java:28)
Actual invocation has different arguments:
dependency.doSomethingElse(true);
-> at com.example.ExampleTest$SystemUnderTest.doSomething(ExampleTest.java:21)

Comparison Failure: 
Expected :dependency.doSomethingElse(false);
Actual   :dependency.doSomethingElse(true);
```","Not pretty but this seems to work if I use a `VerificationListener` and manually log the error:


```
import static org.mockito.Mockito.description;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;

import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.MockitoFramework;
import org.mockito.listeners.VerificationListener;

public class ExampleTest {
    @Test
    public void shouldFailWithDescription() {
        MockitoFramework framework = Mockito.framework();
        String failureMessage = ""Failed to call doSomethingElse"";

        // not all test failures will print the description so we have to manually log it =(
        VerificationListener listener = verificationEvent -> {
            if (verificationEvent.getVerificationError() != null) {
                System.out.println(""FAILURE: "" + failureMessage);
            }
        };
        framework.addListener(listener);

        Dependency dependency = spy(Dependency.class);
        SystemUnderTest systemUnderTest = new SystemUnderTest();
        systemUnderTest.doSomething(dependency);
        verify(dependency, description(failureMessage)).doSomethingElse(false);

        // not sure if we need to remove for next test, or if mockito will auto-clear
        framework.removeListener(listener);
    }

    static class SystemUnderTest {
        void doSomething(Dependency dependency) {
            dependency.doSomethingElse(true);  // <---- TEST FAILS BECAUSE WE PASS WRONG ARGS
        }
    }

    static class Dependency {
        void doSomethingElse(boolean value) {
            // ...
        }
    }
}
```

now prints out 

```
FAILURE: Failed to call doSomethingElse

Argument(s) are different! Wanted:
dependency.doSomethingElse(false);
-> at com.example.ExampleTest$Dependency.doSomethingElse(ExampleTest.java:47)
Actual invocation has different arguments:
dependency.doSomethingElse(true);
-> at com.example.ExampleTest$SystemUnderTest.doSomething(ExampleTest.java:40)

Comparison Failure: 
Expected :dependency.doSomethingElse(false);
Actual   :dependency.doSomethingElse(true);
``` =||= I would like to analyze this issue and eventually provide fixes.  =||= I can also verify the same issue. =||= Seems like a bug. Please submit a PR. Thanks! =||= The cause of this is that Reporter.argumentsAreDifferent() can return

-  an org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent, a subclass of org.opentest4j.AssertionFailedError
- an org.mockito.exceptions.verification.junit.ArgumentsAreDifferent, a subclass of junit.framework.ComparisonFailure

according to whether opentest or junit is available in the classpath. Neither of these, crucially, extends MockitoAssertionError. Hence the exception is not caught in Description.verify and wrapped in a MockitoAssertionError with the description. That would only happen if neither opentest nor junit were in the classpath.

I think the catch block there should also catch these other exceptions and handle them in a similar way to include the description text. =||= It's extending those because of tooling and IDE support, I believe. In IntelliJ IDEA for example, this error is displayed really nice. You can see and compare the differences on the arguments. =||= The various ArgumentsAreDifferent exceptions come from org.mockito.internal.junit.ExceptionFactory, which deals solely with that condition. The header comment of MockitoAssertionError suggests it should be the base of all verification errors triggered by verify() methods. So maybe some refactoring is required. 

I don't know enough to say whether the solution is to handle the exceptions which are actually being thrown or change to throw subclasses of MockitoAssertionError which would then fix the issue. =||= Created a PR with a possible solution: https://github.com/mockito/mockito/pull/1949 =||= ",0
1955,1013,Enable mocking static methods in Mockito,"# Static methods mocking with Mockito

This is a placeholder ticket for enabling mocking static methods in Mockito. Example action items that are totally negotiable and can ran in parallel. We're looking for someone who can lead this effort.

- [x] Research + discuss whether it is a good idea to enable static methods mocking in Mockito. The theory is that it is useful for legacy code, which is most code in the world.
- [x] Research on how other mocking frameworks do that and whether it is considered useful feature for their users.
- [x] Design and present for discussion an API for static mocking (slightly relevant ticket: #643)
- [x] Work with @raphw / ByteBuddy to come up with hacky prototype (the hackier, the better!)
- [x] Mold the prototype with the API, remove enough rough edges so that the feature is good enough for incubating rollout
- [x] SHIP IT!","I am torn on this one. If we provide this possibility, we might invite developers into bad practices. Every time a developer uses this feature, it should be very explicit that it is bad practice imo. Would it be possible to come up with a solution that is clear on this front, but still allows the developer to opt-in? =||= Great feedback. That's the first thing to figure out when working on this ticket :) =||= the way I saw mocking of static methods for myself was to only mock calls to static methods that happen within a mock. This would be useful, for example, for implementing spies in a situation like:

```java
class Foo {
  String bar() { return Util.makeString(); }
}
```
With Mockito, I would like to see something like:
```java
Foo foo = spy(new Foo());
doReturn(""foo"").when(foo).invokesStatic(Util.class).makeString();
assertThat(foo.bar()).isEqualTo(""foo"");
```

What do you think? As for a hack, I am missing a component in Byte Buddy which I was supposed to write for a customer at some point what did however not pull through. I am not currently in a position to spend so much time to build this component, due to my personal situation, but please prototype away. I think the API and spec work is crucial to make this a success. =||= Great feedback! Thank you Rafael for sharing your thoughts.

Is the component you mentioned a lot of work in ByteBuddy? Is this something that we can ask the community to help out or you're the best person to take on?

I'd rather see more robust API but your API idea is certainly workable. Mocking statics should be rare and our API should be optimized for common use cases and not edge/rare cases. We can always iterate based on feedback :)

Here's my preference as of today:

```java
//setup
mockStatic(Util.class);

//then
doAnswer().when(() -> Util.foo());
when(Util.foo()).thenReturn(""foo"");
verify(() -> Util.foo());
verify(never(), () -> Util.foo());
```

If we choose to support mocking static methods, I'd rather offer API that is robust enough to support all kinds of use cases. I like when tools are separated from policies and are opinionated but not dogmatic :) If we think that mocking static is disgusting, we can ship it in a different jar called ""mockito-for-crappy-code"", loosely following @TimvdLippe idea.

The main use cases for mocking statics I see are:
 - legacy code (I really, really want to write a unit test but I don't dare to change some ancient ugly code)
 - dealing with some awkward static 3rd party APIs. This scenario is currently workable by developing some injectable API layer on top of 3rd party statics. However, the workaround could be cumbersome and can spoil the clarity of codebase.

Without addressing above 2 use cases, developers around the world will be looking for help in tools like Powermockito, and such.

The biggest downside of offering static mocking is making it too easy to test crappy, procedural code full of static methods. We would remove a motivation to refactor the code into clean OO / DI.

 =||= Should we also send out a Tweet to gather some community insights? =||= If this feature uses the Java Instrumentation API, it will not work on Android devices, so it might confuse Android developers.
If so, I think it should not be integrated into the `mockito-core` artifact. =||= I came across this issue by chance (I was just curious to know what you were planning for Mockito 3), but I'd like to share my experiences of working with static method mocking.

I used to work on several large codebases that made extensive use of static methods and used PowerMock (and PowerMockito) heavily for testing. My main memories of that time were that the tests were really slow to run (in some cases tests that use PowerMock were literally ten times slower than those that didn't) and that we ultimately had to remove all usages of PowerMock because it wasn't compatible with newer versions of Java. I also recall there being incompatibilities with some libraries were using that required special setup in the tests to make them pass, although I no longer remember the details of that.

I can understand concerns about promoting bad code, but as a Mockito user I'd be more worried about the impact on performance and robustness. Not all of the code we were using PowerMock for was legacy. Some of it was new code written by an inexperienced team (of which I was part of) and knowing that Mockito devs disapproved of our design patterns probably wouldn't have made any difference.

This was a few years ago now and techniques for mocking static methods may have improved significantly since then. If you think there's a performant and robust way to implement this feature then I'd welcome it (even though I'd hope I never have to use it). =||= Really good feedback, thank you guys. I helps us make good decisions about the features/API we plan. =||= In my opinion in general testing static methods is a bad idea and it would be better to refactor the code, however, sometimes it's something that is needed. For instance, testing a default method `given()` in [mockito-java8 interface](https://github.com/szpak/mockito-java8/blob/master/src/main/java/info/solidsoft/mockito/java8/api/WithBDDMockito.java#L68) delegating to a static method in `BDDMockito.given()` the easiest solution I see is to generate in runtime a list of static methods in `BDDMockito` and execute parameterized test for every of them verifying that a corresponding method in `WithBDDMockito` interface delegates to it with proper parameters. In that case static method mocking would be beneficial. Maybe I will wait for PowerMockito for Mockito v2 to test Mockito itself...

Alternatively I would need to play with AOP and load-time weaving, code generation in runtime or some other not very pleasant to use technique (unless you have some good ideas how to do it easier). =||= @szpak, thank you for the feedback! Interesting use case.

I think we all agree that mocking statics is a bad practice and an anti-pattern in general. The question is whether we enforce the ""no mocking statics"" policy (e.g. not offer the feature in the tool) or let the user decide to enforce it or not (e.g. offer the feature). =||= Please, consider the legacy code issue. Sometimes you don't have any choice. 
Enforcing or not a practice shouldn't be the decision of a framework but of the team.
Also, for now, we're using Powermock as a workaround for this need but it's not compliant with the last versions of Mockito. We're blocked with 1.9.x version of Mockito.
It's another good reason to get this feature: Limit dependencies.

We already need all these libraries to get decent unit test in pure Java world:
JUnit,
JUnitParams as Junit Parametrized are awfull
AssertJ for expressive and clear assertions
Mockito ... and Powermock

and i shouldn't mention other peripheral libraries:
DBUnit,
SpringDBunit
JBehave, JGiven for BDD style .... 

Then you can write all your testing stuf in Groovy and you only need ... Spock


Please! Let user choose. Othewise, why did you provide private method mocking in the recent versions athough it's considered as a ""bad"" practice for TDD purists ? 

Finally, thanks for your great work. Mockito is really a nice framework  =||= Mocking static methods is a different use case, maybe that means it should be a different tool. 

Answer the following questions (to yourself):
- Do you want to support a double tool in the long term? 
- Does it use the same set of dependencies and only those? 
- Does mocking static methods fall nicely into the current design?

If you answer all 3 with ""Yes"", then go ahead. If at least one is a ""No"" consider the alternatives:
- Build a Mockito extension
- Build a new tool and call it Mackarita
- Leave the other tool to someone else

Just my two cents. =||= I agree with most of you and think that mocking static methods is not a good idea.
If some method uses static method provided by legacy library/framework, then it can be easily wrapped in object and provided as mockable dependency. It's not perfect solution, but is educational - shows developers that writing too complex static util methods hurts and makes code hard to test. If Mockito had such feature, many of developers would consider it as acceptable practise and produce bad code.
Another issue is parallel tests execution. In my current project we used to use PowerMockito to mock static methods and after some time our tests started to fail because of concurrency issues:
1. Thread A mocked static method X.y and stopped.
2. Thread B mocked static method X.y and stopped.
3. Thread A was awaken and run test - it failed because thread B overwritten static method's behaviour expected in test run by A.

We ended up with wrapping static methods in injectable objects and removed PowerMockito from project dependencies. =||= I had asked about this at some point in the past and was told it was being considered. Glad to see that's actually happening.

In my opinion, support for mocking static methods is a good idea for the simple reason that the standard Java classes that ship with the JRE have tons of static methods. Consider the NIO.2 API as an example. If you want to read a file using that API, you might do something like:
```java
Files.readAllLines(Paths.get(""myfile""));
```

Now, is there a way to test this without mocking static methods? Obviously yes; you could make a IFiles interface and then make a JREFilesImpl that passes the calls through to the static methods. But that's a bunch of extra effort, it adds complexity to your code, and obscures the methods that are actually being called. In my opinion, I shouldn't need to do that to test my code's ability to properly read some file.

So +1 for the ability to mock static methods. =||= > Now, is there a way to test this without mocking static methods?

Well, in my opinion file name/path from your example is good candidate for passing it to method/setter/constructor instead of hardcoding it and you can just create test file in filesystem. Such Java API methods are considered as simple and reliable and there is no need to mock them like you wouldn't mock `java.util.List` if your method operated on data from given list. You would just create actual list with test data. =||= There are at least 2 problems with that argument: a) you can't test behavior when exceptions occur, and b) you can't test behavior if the path is for a different OS. I realize the latter is an esoteric use case, but I actually am working on a project that is developed on Windows but runs exclusively on Linux. =||= I think the recurring theme right now is: either you are pro or you are strictly against it. Personally, I am for clean tests and therefore consider static mocking very bad practice. However, our users apparently have usecases that require (intrusive?) solutions such as PowerMock. Given that these users opt for such solutions signals that the other solution would be no tests at all, and that is probably what we would never want.

Given that solutions like PowerMock are built not only on Mockito, but also other libraries, they can not be easily updated like Mockito can. This incentives Mockito to solve static mocking, if users opt-in for it.

Even though I inherently disagree with static mocking, I think it is only fair that we as Mockito developers offer users the option to opt-in a less intrusive and upgrade-compatible solution. Therefore, I would vouch for a different artifact (probably called `mockito-legacy`), which offers static mocking. This should signal our users that this is for legacy purposes and should be strictly discouraged, but at least gives them a way out. This particular solution would tick off all points of @jlink

In the end, no matter which outcome, there will always be disappointed developers. We will not be able to find a golden solution for this particular problem and I am fairly convinced it will never happen either.

We can always try it out with the new artifact and discontinue it later if it is significantly misused.

One sidenote: putting everything in a new artifact would scatter the mockito ecosystem. We should probably find a better solution for this, potentially in Mockito 3. =||= I disagree with @TimvdLippe.  I don't believe that in an open source world you can ""try it out with the new artifact and discontinue it later if it is significantly misused."". Once it's there in the library users will require it to be there. You'll have to support that feature etc. Either it's there or not. Not often can you easily deprecate sth and roll it back afterwards. Typically it requires a couple of release cycles.

@TimvdLippe you're mentioning this "" However, our users apparently have usecases that require (intrusive?) solutions such as PowerMock"". I have a comment on that. As an exercise from time to time I'm trying to answer PowerMock questions on StackOverflow. Typically someone says that there's a static method somewhere that they're calling and it does some logic that they want to stub. The question I often ask to those people is ""Why are you doing this?"". Would you really want to stub a call to `StringUtils` ? Another frequent problem is that the design is flawed and that's why one is looking for hacks. (e.g. http://stackoverflow.com/questions/37059406/how-can-i-get-powermock-to-return-the-expected-value-from-a-static-method/37066436#37066436 , http://stackoverflow.com/questions/37052069/program-termination-during-quartz-scheduler-verification-using-power-mockito/37066521#37066521 , http://stackoverflow.com/questions/31840964/powermock-private-method-with-null-pointer-exception/37066400#37066400 or http://stackoverflow.com/questions/32195928/getting-powermockito-to-mock-a-static-method-on-an-interface/32537392#32537392)

That's why I fully agree with @karollewandowski . ""Every problem can be solved with a layer of abstraction"" ;) You can't mock a static method? Ok then, wrap it in a class which you can stub. Is it wrong? Quite the contrary. Rarely should you call static methods directly and if you do, most likely these are utils that you don't want to stub. You should encapsulate the logic of a static method in an object that makes business sense to use it.

Summing it up giving people a tool to stub static methods is making them even easier to write bad code. Instead of thinking of how to fix the design they'll be able to make the design even worse.  =||= @TimvdLippe Just one thing: If you create a new artifact like ""mockito-legacy"" communicate clearly if you're planning to support it mid/long-term or if it's just an experiment. Some people are willing to experiment together with you, others will be pissed off when you quit support after they have heavily used it. =||= @rdicroce I completely disagree with this statement:

> Now, is there a way to test this without mocking static methods? Obviously yes; you could make a IFiles interface and then make a JREFilesImpl that passes the calls through to the static methods. But that's a bunch of extra effort, it adds complexity to your code, and obscures the methods that are actually being called. In my opinion, I shouldn't need to do that to test my code's ability to properly read some file.

You're design is wrong. If you had 

```
Files.readAllLines(Paths.get(myFilePath));
```

You could via a constructor inject `myFilePath` to point to your test resources. You don't even need to create any additional classes. =||= The Android community would like mock static methods, well at least me.
Why? : The Android SDK provides many static utility methods with classes like TextUtils. The downside is that there implementation is only provided on the device or emulator. When users run Unit-Test on there local machine they will get the famous ""Method not mocked"" exception.

> The android.jar file that is used to run unit tests does not contain any actual code - that is provided by the Android system image on real devices. Instead, all methods throw exceptions (by default). This is to make sure your unit tests only test your code and do not depend on any particular behaviour of the Android platform (that you have not explicitly mocked e.g. using Mockito). 

They are many workarounds for this issue like PowerMock or Roboelectric. Roboelectric is a great testing framework but it is damn slow and maintainance intensiv. PowerMock is not stable state to be used with Mockito 2. So I think at least Android users will love this feature. 
  =||= @ChristianSchwarz I do not agree, using Android static utils or Android framework in your business logic is a bad smell. Well structured Android app do not need mocking static methods, nor Roboelectric. Calls to Android framework must be abstracted and current Mockito implementation helps to enforce that. If you want to test view layer then go with Instrumentation tests and Espresso. =||= @dbacinski, I am not an expert on Android so bear with me, please :) Adding extra layer introduces more method calls which can be problematic on large apps that hit dex method limit, right? =||= @szczepiq you are right that you need additional methods to abstract Android apis, but this is a cost of good architecture. Dex method limit is not a huge problem anymore because now there is native platform support for multidex apps. =||= @marcingrzejszczak Your response a) does not address the call to readAllLines(), and b) does not address either of the issues I raised in https://github.com/mockito/mockito/issues/1013#issuecomment-291602703

To all: it seems to me there's a fundamental divide in this thread between people who are of the opinion that it's fine to just make a wrapper class for static calls, and people who are of the opinion that wrapper classes add bloat and shouldn't be necessary. I don't see either side convincing the other, so I'm not sure where that leaves us. =||= > Your response a) does not address the call to readAllLines(), and b) does not address either of the issues I raised in #1013 (comment)

@rdicroce I haven't explicitly but the answer is simple

> a) does not address the call to readAllLines(),

If the path is a parameter you don't have to mock the call at all. You can pass 

a) a path that exists - to test the positive scenario
b) a path that doesn't exist - that way it will blow up and you'll test an exception

> . I realize the latter is an esoteric use case, but I actually am working on a project that is developed on Windows but runs exclusively on Linux.

You can write a couple of tests that are exclusively executed depending on the OS (example for Windows - http://stackoverflow.com/questions/23410738/run-unit-tests-only-on-windows ). Again, if you use parameters instead of magic values then you can do basically whatever you want.

> To all: it seems to me there's a fundamental divide in this thread between people who are of the opinion that it's fine to just make a wrapper class for static calls, and people who are of the opinion that wrapper classes add bloat and shouldn't be necessary. I don't see either side convincing the other, so I'm not sure where that leaves us.

I'd say that the divide is between people who want to design their code properly and those who want to take the path of least resistance (which isn't a wrong choice sometimes).
 =||= >I'd say that the divide is between people who want to design their code properly and those who want to take the path of least resistance.

Static members aren't something good, I hope it's quite obvious. But Java has them and will support them, whether we like it or not. So I'd say that educating and influencing is good, forcing might be not. It's like ""oooh, your code is using statics, so it can't be tested with Mockito"".
(Not to mention that some people would like to have nice unclebobish tests but aren't allowed to refactor the code they have to maintain. I know it's sick, but hey, this is reality sometimes.) =||= @marcingrzejszczak 

> If the path is a parameter you don't have to mock the call at all. You can pass
>
> a) a path that exists - to test the positive scenario
> b) a path that doesn't exist - that way it will blow up and you'll test an exception

That may solve this particular case. What about other static APIs that can throw a variety of different exceptions? Are you saying users should go through the hassle of setting up every possible scenario? What happens if there are scenarios the user can't set up? You may as well not bother with a mocking framework at all in that case.

> You can write a couple of tests that are exclusively executed depending on the OS (example for Windows - http://stackoverflow.com/questions/23410738/run-unit-tests-only-on-windows ). Again, if you use parameters instead of magic values then you can do basically whatever you want.

This makes it impossible to run the tests in the environment where the code is developed. Again, I know this is an esoteric use case, but it is a valid one IMO.

> I'd say that the divide is between people who want to design their code properly and those who want to take the path of least resistance.

I won't speak for anyone else in favor of mocking static methods, but I don't see that as designing code improperly. Adding a whole extra layer of abstraction that's completely unnecessary outside of testing? That does strike me as being improper. =||= This will be my last answer cause obviously we are not going anywhere with this.

@pioorg

> Static members aren't something good, I hope it's quite obvious. But Java has them and will support them, whether we like it or not...

Yes it's obvious. Someone has to afterwards maintain that code. Both the business and the library. Another thing is that you don't have to mock all of those calls. Why would you stub a `StringUtils` class ? Makes absolutely no sense. 

@rdicroce

>  Are you saying users should go through the hassle of setting up every possible scenario? What happens if there are scenarios the user can't set up...

Of course not. You can catch a generic exception and that's enough. 

> This makes it impossible to run the tests in the environment where the code is developed

That's false. Some of your tests will be executed only on Windows. Some others on Linux etc. 

> I won't speak for anyone else in favor of mocking static methods, but I don't see that as designing code improperly

That's why I would just call the static method. If in your static method you have a lot of complex logic then it should get wrapped.

All in all - I think that this is a wrong decision for Mockito. But that's only my opinion. =||= > Yes it's obvious. Someone has to afterwards maintain that code. Both the business and the library. Another thing is that you don't have to mock all of those calls. Why would you stub a StringUtils class ? Makes absolutely no sense.

With all the respect, I don't care about any *Utils classes or any other particular code snippets.
What I mean is that:

1. statics are valid from syntax PoV
2. they already exist in legacy code 
3. some folks can't change that code ""only because we'd like to have Mockito in tests""

So if one can't change the code, refactor it and add the wrappers around the static calls, they also can't use Mockito because ""Mockito doesn't support statics"". To me it comes to ""bad code -> bad tests"". Sorry ;-)
While I perfectly understand there are reasons not to include it in ""standard"" distribution artefact, having another one being mockito-extension-for-ppl-who-dont-have-nice-code.jar might be acceptable.
 =||= Just some toughts about  the prevailing opinion ""statics methods are evil"". 
From my experience there are 2 different kinds of static methods ""good"" and ""evil"", i wouldn't say that all static methods are evil.

 * Static methods are ""evil""  when they alter the state of a of a static member or in other words they depend on a state. When such a method is called the result may be an other when called in the future with the same input.
E.g:
```java
 class LogManager {
     static LoggerPlugin plugin = ...
     static void logInfo(String message){
        plugin.write(INFO,message);
     }
 }
```
 When the LoggerPlugin changes during runtime the result may be different, e.g logged to a different media.

 *  Static methods are also ""evil"" when they call a static method that is ""evil"" as described above, cause they inherit the nasty side effects.
E.g:
```java
 class Log{
  static void info(String message){
      LoggerMananger.logInfo(message); 
  }
 }
```


 * Static methods are are ""good"" when they don't depend on a state / access a static member and thus have the same result on every call.
E.g:  `Math.max(int,int) `


In the java eco system exists both evil and good static methods. I don't see a much points to mock ""good"" static methods. It makes only sense when they do quite complex stuff and you don't want to mock all bits of there input to satisfy there implementation. Even in famous frameworks we are faced with ""evil"" static methods (hello `Singleton.getInstance()`). To handle these evil cases mockito can do it's part and support the poor devs among us who have to deal with it. I wouldn't blame mockito if devs start to introduce the ""evil's""  to there code base. Mockito is a mocking framework, not a good style enforcement tool, thats the task for the team and/or lead developer.



 =||= @ChristianSchwarz 
> Static methods are are ""good"" when they don't depend on a state / access a static member and thus have the same result on every call.

True, there are even some schools in which all private methods should be static, don't depend on anything apart arguments, don't change the state of any object and don't do anything beside computing the result. So they're functions, just like sin(angle) is: the angle isn't changed, and sin is only the result of the angle, always the same (provided the geometry is always the same ;-) )
I find this functional style of programming very good, but in fact it has rather not much to do with statics as such. IMHO sometimes it's better to tell newbies ""don't use statics, 'couse they're generally bad""... It's a kind of ""lie for children"". =||= Unfortunately as history has shown multiple times, when developers see a tool and its use cases, they do not always understand the impact and weight of its features. They consider all features equal and do not understand that some of them should only be used as a last resort.

The canonical example in the Java world is the abuse of Java introspection/reflection and AOP for even trivial scenarios. Even outside the Java world we see the misuse of advanced features by developers who use them ""simply because they are there"". 

If we are to go forward with this (and I am strongly against this, as I considered a major advantage of Mockito the fact that it did not allow testing of static methods) I would suggest the following:

- Create a ""mockito-legacy"" artifact/extension/add-on 
- Require a configuration file option for Mockito to actually enable this add-on
- Print in the log file when the test runs a huge warning (similar to what Maven does when you don't define a version) that using this add-on is an anti-pattern and a code-smell
- Provide a link to the user that has a page with common refactoring scenarios that show how we can get rid of static methods.

Maybe I am missing something, but I really would like some examples on how legacy code cannot be refactored to remove the static dependency. Unless of course you cannot change the code at all, which for me makes the creation of unit tests questionable (because if a unit test fails what are you going to do then?) =||= @kkapelon: I also wish all Java code was pure OO design and that everyone actually knows what that means ;-) I hope such a huge warning ""you're doing it wrong"" could educate and maybe convert a few folks.

> Maybe I am missing something, but I really would like some examples on how legacy code cannot be refactored to remove the static dependency.

It's not about the code itself. I've seen big name companies enforcing policies in which before bugfixing, the case has to be replicated in tests. (Kinda TDD, they claim sometimes.) Then, once the test fails just like the ticket describes, the support team is allowed to change the code to make it pass (and sadly, usually minimum changes). It's rather difficult to make a test to cover statics if your testing tool set doesn't allow that. Chicken and egg problem.

It's like all these The Daily WTF stories in which ""don't change it, it ain't broke, 'couse it works!"", so the code is like Java 1.4...
 =||= This would be great! We could finally stop bikeshedding ""static is *eeevil*"" because not testable. =||= > We could finally stop bikeshedding ""static is eeevil"" because not testable.

Well, IMHO static is eeevil in many cases not only because not testable :-D =||= The mocking framework shouldn't restrict the design options - it's just not the job of a mocking framework! I've seen a lot of code polluted with mocking-only interfaces. And there are a lot of cases where a simple static method is a perfect design decision. `final` is also rarely used, because mocking frameworks (besides the great [JMockit](http://jmockit.org/)) have trouble with it. =||= DONT DO IT!  PowerMockito exists for those cases where you absolutely need to mock static methods.  Right now Mockito conforms to the commonly held opinion that static is for methods that are testable without mocks (think: StringUtils).  Static for other stuff should be discouraged (there are exceptions, obviously) - in those situations, encapsulating the static calls in a protected @VisibleForTesting method should suffice for unit testing and for those other ""legacy or not"" situations, there's always PowerMockito.   =||= @trumpetx I just wanted to note that the reason we are investigating this change is that some companies are in the legacy code situation, where adopting PowerMockito would be too disruptive. Therefore, these companies would be unable to test their classes. Even if they could adopt PowerMockito, the tests become significantly more difficult to understand, just to be able to test their legacy code.

The question is: should we as Mockito give the opt-in for these situations, as other options are too invasive? I think every Mockito core developer agrees that static mocking is bad and should not be done, but sadly we can not dictate what the industry does or has to deal with.

Just wanted to give perspective on why we are opening this issue. =||= @TimvdLippe , I can't see how Powermockito would be disruptive for tests (certainly no more disruptive than adding MockitoStaticWhatever.)

Additionally, too difficult to understand?  Seriously?  If someone has static mocks in their tests, and they're too difficult to understand, they probably need to find a new career.  I'm not saying this to be mean spirited or whatnot, but it sounds like you're just making reasons to adopt this change. =||= Also for reference, I cross-posted this issue on Reddit and there some other arguments/viewpoints posted there: https://www.reddit.com/r/java/comments/64pdk1/mockito_discussion_on_introduction_of_mocking/ =||= @TimvdLippe 
Thanks for your link. The recent posts have led me to another...
http://mvnrepository.com/artifact/org.powermock/powermock-api-mockito/usages
I'm just wondering why so many of them... =||= I haven't had experience with ByteBuddy but I'd be willing to give it a shot. As far as names, how do we feel about `mockito-gore` to really indicate you need a strong reason to use this jar? =||= Just a few more words from me, maybe last ones ;-)
There's a method in Mockito:
`org.mockito.Matchers#isNull(java.lang.Class<T>)`
Isn't NULL considered to be ""The Billion Dollar Mistake""? Shouldn't the programmers all around the world be educated that passing a null reference (instead of a `java.util.Optional`) is a very bad practice?
Maybe this `isNull` method should be deprecated and eventually removed in future versions?

I've seen a lot of code being polluted by `if (reference == null)` and `catch (NullPointerException e)`... More than by ""incorrect use of statics"". (But YMMV.)
If supporting statics is going to create such bad habits among programmers AND Mockito is meant to be a forced education, then I guess support for NULLs should be removed in future versions and people should write wrappers to handle NULLs from their legacy code, as NULL is worse habit IMHO. ;-)

Unless Mockito is meant to be a testing/mocking framework, not forced education course.
Thank you. =||= I would like to add some comments from my own experience. I completely understand the people that are saying to add an abstraction to the static methods that you are invoking. However, in a legacy code that is expensive and requires a lot of effort. 

Additionally, there are frameworks like [GWT](http://www.gwtproject.org/) that support polymorphism, but not like you would think. One needs to call a static method that will do the creation of the object on runtime and runtime there is Javascript. There ware ways that you can write tests that will emulated the client code for GWT, but they are really slow. Currently, we use PowerMockito with Mockito 1.9.5, because we can't update to a later Mockito. However, if Mockito had this support it would be much easier to do the testing. =||= This discussion has been very active and helpful, thank you everyone for participating!

I think we have sufficient background information to make a final decision @mockito/core Shall we discuss this on Slack and write a wiki page on our full analysis and final verdict? Then we can inform the community for a final review (of a potential implementation) and round up this feature. =||= > Shall we discuss this on Slack and write a wiki page on our full analysis and final verdict? Then we can inform the community for a final review (of a potential implementation) and round up this feature.

Has the verdict on static support been reached?

 =||= We have not. Every single core member has been swamped with various IRL activities. Probably this fall we will be back in full force. This is one of the features that we will be addressing :smile:  =||= The team was not actively working on this. The ticket is marked ""please contribute"" for a reason ;) Currently I work with @thekingnothing on creating Mockito APIs so that Powermock can cleanly integrate (#1110) this will effectively provide reasonable support for static mocking. 

Hope this clarifies the status! Thank you for reminder - this is useful for us to manage our priorities. =||= Static methods are totally OK. You just have to know when to use them.

I think the following code is entirely correct and sufficiently abstracted for the purpose of a modern-day application:

    // guava imports
    class ApplicationResources {
      // points to a file in the .war
      private static final CharSource DEFAULT_CONFIG_SOURCE = Resources.asCharSource(Resources.get(""etc/default.config""), UTF_8);
      static CharSource defaultConfigSource() {
        return DEFAULT_CONFIG_SOURCE;
      }
    }

I need to access a static value in my application. But for the purpose of proper testing, I need to test various default values, so it makes sense to provide another `CharSource` during the tests than at runtime.

Just imagine that this is embedded in some JEE application. There is no sense in writing this method as non-static. I could write `new ApplicationResources().defaultConfigSource()`. What is that code? Is it real? Others might imagine I make this class a (singleton) bean. A bean requires the class to be public. I don't want any of its method to be accessed outside of the package, so there are no reasons to make this class public, so this class has no reasons to be a bean.

However I still have to test classes that use this class. But I'm stuck in the testing because I just can't mock its methods (besides using all the workarounds mentioned above).

I agree that mocking static method should be used very, very rarely, but it should exist for those rare cases. =||= Personally, I plan to add this feature. I still need to do some ground work in Byte Buddy to make this feasible. It is not as easy as I hoped, unfortunately and it might take some time. The same goes for the seamless integration with PowerMock.

If anybody would be willing to sponsor the development, I am happy to use paid hours, within my open source commitment, this might take a few more month to complete but I am certain to finish this at some point. Java 9 compatibility takes priority at the moment. =||= **tl;dr:** mocking static methods can be implemented mostly like regular mocking with [a few quirks when spying on static methods with side-effects](https://github.com/moltmann/dexmaker/wiki/Experiments-with-mocking-static-methods-via-mockito#spying-and-doreturn).

I implemented a [prototype](https://github.com/linkedin/dexmaker/compare/master...moltmann:staticMock) of this for the dexmaker based mocking used on Android. Examples and tests can be found in [MockStatic.java in the diff](https://github.com/linkedin/dexmaker/compare/master...moltmann:staticMock#diff-923767ff4d088765b531f9151e31b1c3R127).

I summarized my observations on a [wiki page](https://github.com/moltmann/dexmaker/wiki/Experiments-with-mocking-static-methods-via-mockito). =||= I think I found a [nicer version for mocking static methods via `doReturn().when()`](https://github.com/moltmann/dexmaker/wiki/Experiments-with-mocking-static-methods-via-mockito#create-temporary-object-just-for-calling-static-methods). So the total interface for static methods could be designed as:

    try (StaticMockingInProgress<MyClass> token = spyStatic(MyClass.class)) {
        when(MyClass.aStaticMethod()).thenReturn(“mockedValue”);
        assertEquals(“mockedValue”, MyClass.aStaticMethod());
        
        doReturn(“fakeValue”).whenStatic(MyClass.class).anotherStaticMethod();
        assertEquals(“fakeValue”, MyClass.anotherStaticMethod());
    }
    
    assertEquals(“originalValue”, MyClass.aStaticMethod());
    assertEquals(“originalValue”, MyClass.anotherStaticMethod());

In Summary we could limit the necessary changed to:
- `mockStatic`/`spyStatic` instead of `mock`/`spy`. This is required as `mockStatic`/`spyStatic` needs to return a token to define the scope of the mocking instead of a mocked object
- `doReturn(...).whenStatic(Class)` instead of `doReturn(...).when(Object)`. This is necessary as when mocking a static method, there is no mocked object =||= Addendum to previous comment. I think we should also have a `resetStatic(Class<T> class)` method. Then using the StaticMockingInProgress object becomes optional but recommended. =||= Hey @moltmann, thank you for taking a stab at the prototype!

Given that we provide an API for mocking statics in mockito-core, will you be able to come up with the implementation in dexmaker? 

Can you implement static mocking in dexmaker right now, with current version of mockito-core API? For example, can you add ```MockitoStatic``` class to dexmaker and offer static mocking to dexmaker users? If not, what are the problems with mockito-core API that block you. =||= I am trying to sum up all discussion I had and what I learnt from this thread.

I updated my prototype at https://github.com/moltmann/dexmaker/tree/staticMock using 
- whenStatic 
- explicit finishStaticMocking

# Stubbing

How does ""when"" work for static methods?

## when(λambda)

### Suggested APIs

```
when(() -> MyClass.myMethod()).thenReturn(""mocked return value"");

doReturn(""mocked return value"").when(() -> MyClass.myMethod());

verify(() -> MyClass.myMethod());
```

### Problems

#### Not clear what method is called

If the lambda calls two methods, e.g.:

```
doReturn(""mocked return value"").when(() -> MyClass.firstMethod().secondMethod());
```

or 

```
doReturn(""mocked return value"").when(() -> {
    Object o = MyClass.firstMethod();
    return o.secondMethod()
});
```

Which method should we set up mocking for? `MyClass#firstMethod()` or `?#secondMethod()`.

- We need to make sure the return type matches the parameter of doReturn. We only know the return type of the the lambda, i.e. the return value of secondMethod. Hence we have to set up mocking for the second method.
  We don't set up mocking for `MyClass.firstMethod()`. What should `MyClass.firstMethod()` do? Call the real method? Return null? To make the code above work `MyClass.firstMethod()` has to call the real method. But this might have side effects. The point of the `doReturn(...).when(...)` syntax is to avoid side-effects.
- The second method is most likely an instance (non static) method. Should we allow setup for instance methods using the when-with-lambda?

I think we need to enforce only a single mocked method call on a mock in the lambda. Hence we have to listen to all possible methods calls, and intercept them. Once a second one or one of the wrong return type is intercepted we need to throw an exception. Hence above examples will throw an exception.

##### Possible extension

One possible extension would be do declare a restriction on what to intercept like

```
doReturn(""mocked return value"").when(MyOtherClass.class, () -> {
    MyOtherClass o = MyClass.firstMethod();
    return o.secondMethod()
});
```

Which declares that we want to set up mocking for `MyOtherClass`, not `MyClass`.

#### Conflict between old and new doReturn-when

```
doReturn(() -> ""A"").when(() -> MyClass.firstMethod());
```

In above case Mockito needs to decide if this is the new setup method or an incomplete version of 

```
Supplier<String> m = mock(Supplier.class);

doReturn(() -> ""A"").when(m).get();
```

it can do this by checking if the parameter to m is a mock during runtime, but the when(λambda) API needs to support both cases, hence when(λambda) has to return a lambda type, i.e.

```
LambdaStubber<Supplier<T>> doReturn(Supplier<T> ret) {
    return new LambdaStubber<Supplier<T>>(ret);
}

public static class LambdaStubber<T> implements Stubber {
    Supplier<T> when(Supplier<T>) {
        ....
    }
}
```

##### Possible extension

This issue might be mitigated by introducing

```
doReturn(() -> ""A"").whenStatic(() -> MyClass.firstMethod());
```

## `T whenStatic(Class<T>)`

```
doReturn(""mocked return value"").whenStatic(MyClass.class).myStaticMethod();

verifyStatic(MyClass.class).myStaticMethod();
```

`doReturn(...).whenStatic(MyClass.class)` returns a mock instance of `MyClass` with all instance methods throwing a stubbing exception. So the user will not accidentally call a instance method on this special stubbing-mock.

### Problems

`doReturn(...).whenStatic(MyClass.class)` returns a mock instance of `MyClass`. Hence calling `doReturn(...).whenStatic(MyClass.class).myStaticMethod()` is equivalent to

```
MyClass m = mock(Myclass.class);
m.myStaticMethod();
```

While it is valid Java to call static methods on instances, all IDE code checkers, linters and tools like errorprone will light up like a christmas tree and tell you not to do it.

# Life-time of static mocking

Regular instance mocking is tied to an object's lifetime. Static methods do not have such a life-time, hence when to know when to reset the methods and stop collecting invocations.

## `mockStatic(Class)` -> `finishStaticMocking(Class)`

This is the most basic solution. The advantage is that this works with every possible test-framework and if someone wants to have a nicer API they can e.g. build a `AutoClosable` that automatically calls `finishStaticMocking(...)` when a try-with-resources block is exited.

## MockitoSessions

As far as I understood there can only be one session at a time. Hence scenarios with interleaved life-cycles of static mocking can not be supported. Example:

```
mockStatic(A.class)
mockStatic(B.class)

when(A.m()).thenReturn(""mockA"")
when(B.m()).thenReturn(""mockB"")

assertEquals(""mockA"", A.m());

finishStaticMocking(A.class)

assertEquals(""mockB"", B.m());

finishStaticMocking(A.class)
```

Of course if the user wants to use sessions (or other session like tools, such as the Mockito JUnit runner) they should apply to static mocking too. =||= I implemented the recommendation of https://github.com/mockito/mockito/issues/1013#issuecomment-291045005 in :
- Code: https://github.com/moltmann/dexmaker/tree/staticMock
- JavaDoc: https://moltmann.github.io/dexmaker/com/android/dx/mockito/inline/extended/package-summary.html
- Example: https://github.com/moltmann/dexmaker/blob/staticMock/dexmaker-mockito-inline-extended-tests/src/androidTest/java/com/android/dx/mockito/inline/extended/tests/MockStatic.java#L76

It mostly works even though some parts of the implementation use nasty reflection. =||= @moltmann Could you please open PR for your changes?  =||= @avanathan My code is currently based on [dexmaker-mockito](https://github.com/linkedin/dexmaker) and does not work with the bytebuddy mock maker used by vanilla Mockito. I think we should first agree on the interface before trying to make this work with bytebuddy. =||= @moltmann, thank you for working on this! I plan to re-engage soon. =||= I didn't see it discussed, but the main use case for me wanting to mock a static field is logging.   Popular logging frameworks (especially SLF4J) store a log object in a static field `private static final Logger logger = LoggerFactory.getLogger(MyClass.class)`.

In tests I would like to mock this field, so I can validate logging calls at critical places in the business logic, for business reasons of audit trails and operations support. =||= Imo you shouldn't mock the logger but assert whether the logging output contains the desired value  =||= @binkley Can we go one step back?
If you have business reasons to write some audit logs, they _might_ be part of your business. Ergo: your model and your domain. That's perfectly fine in banks, insurance, security, other areas.
Are you really sure _techy_ logs are the way to satisfy the business needs?
E.g. in SLF4J/Logback it's a matter of the configuration for the precise runtime in production. So even if you test static calls, there's no guarantee that this will happen in real business. Someone may misconfigure SLF4J. So again, _maybe_ the audit should become explicit part of your model? =||= @binkley 
>I didn't see it discussed, but the main use case for me wanting to mock a static field is logging. 

> In tests I would like to mock this [static] field

This feature is not intended to set mocks on fields neither with modifer static, private or final. It is meant to enable mocking for static methods. In other words this feature would enable you to stub the static logger factory method, e.g like: `when(LoggerFactory.getLogger(MyClass.class)).thenReturn(mockedLogger)` =||= There are some use cases where I've to mock the third party code while running unit tests. 

`IOUtils.toString(File file, ...)`
or 
`RequestContext.getCurrentContext()`

I'm not sure how and why should I refactor this code. 
 =||= @ghsatpute - The standard way is with a wrapper; e.g. 

```
public interface IOUtilsWrapper {
    default String toString(File file, ....) {
        return IOUtils.toString(File file, ...);
    }
}
```

And pass in either a mock of IOUtilsWrapper, or the real thing. =||= @GregDThomas  
Are you suggesting that in my actual code I should use `IOUtilsWrapper` class? That would be an overkill if I have too many such methods? Or am I missing something?  =||= @ghsatpute  - in the absence of the ability to mock a static, yes. Alternatively, consider the user of PowerMock - https://github.com/powermock/powermock/wiki/Mockito#mocking-static-method =||= I already wrote an extension on top of Mockito+AspectJ, with syntax like
```
when(() -> YourClass.staticMethod(...)).thenReturn(...)
```
It's available here: https://github.com/iirekm/varia/tree/develop/ajmock

Maybe the good way of thinking is:
- pure Mockito - for new, pretty, shiny, testable code
- AjMock - for legacy, untestable code to be able to add tests to it without modifying the source code (which is hard and may break something) =||= With all of the text expended on the horrors of static methods, I have yet to read any solid justification for these strongly held opinions.   It really appears, to me, to be pure dogma and not engineering.

As a software developer, static methods have a great appeal.  The explicitly disavow any state.  That's a big deal and a very, very good thing.   Fwiw, in part due to their lack of state, static methods are themselves _more_ easily covered in JUnit tests.

The _only_ down sides to static methods, that I can see, are a) they cannot be overridden by derived classes, which leads to b) they are more difficult to mock in unit tests.

Downside a) is actually a good thing and easily worked around using a non-static wrapper (as illustrated above) in use cases that require such.

Which leaves mocking.   And only mocking.

So, if there is a good way to help deliver well tested code, I'm all for it.  So, please, add support for mocking static calls directly to Mockito core as soon as is convenient. =||= ""The explicitly disavow any state.""
so what's the point to mock/stub them, if it is just a pure logic.
Static methods actually allow state modification of any accessible part of app, that's the main problem why ppl would like to override its behaviour. =||= From my point of view Mockito is a mocking tool, not a linter, it should not tell you whether your code is good or bad, or dictate how to write it. It's all a matter of taste, like the endless ""tabs vs spaces"" debate and you won't find 2 developpers with the same coding style, so just let people setting up their linting tool the way they want. And even if you think that static is evil, since static methods are allowed in Java anyway, your software can possibly use 3rd party librairies that use them and that you would like to mock, and wrapping everything is overkill (but that's also a matter of taste :) ) =||= @dbacinski sometimes even though they contain pure logic they sometimes use the hardware/network resources. For example, reading some file, or getting something over the Internet would probably be better represented as a static method, as they don't contain any state, but I'd like to mock them when I'm running the test case. 

I agree with @anthofo . I'm using `IOUtils.toString(classpathFile)`. I could right away use this method in my code, but because of this limitation, 
1. I've had to write a wrapper class
2. Create an instance of that class in my caller method 
3. Mock when doing testing. 
And just because I cannot mock the static third-party method. I could write less code/classes if I was able to mock static methods.  =||= I'd argue that a static method that uses the network or disk isn't a good static method - it relies too much on external inputs for it to be a pure function. But, that's personal preference, clearly many people do this, and as such I do think Mockito should offer the option to mock statics. =||= > I am torn on this one. If we provide this possibility, we might invite developers into bad practices. Every time a developer uses this feature, it should be very explicit that it is bad practice imo. Would it be possible to come up with a solution that is clear on this front, but still allows the developer to opt-in?

IMHO, 

1. mockito should not be used as an enforcer for avoiding static methods. May be some other tools need to take care of this. 
1. If we add static method testing feature in mockito - we could use mockito to test legacy code.  =||= >> ""The explicitly disavow any state.""
> so what's the point to mock/stub them, if it is just a pure logic.
> Static methods actually allow state modification of any accessible part of app, that's the main problem why ppl would like to override its behaviour.

In my case, we have a directory structure that contains hundreds of thousands of files.  These files were created by a complex, analytical application executed repeatedly over several years.  Different versions of that software wrote different flavors of the files in varying sub-directory structures.  I have a static class that builds paths to those files based on a small number of inputs.  All of the ""state"", which is based on known behavior of different versions of the analytic software, is known at compile time and has almost no dependencies.

To unit test software that consumes these files, without re-creating the runtime environment, it's really helpful to mock the results of the path generating static methods to point to files packaged as test resources.

Again, the _only_ case against static methods is that Mockito doesn't support mocking them (or is preventing PowerMock from doing so)!!   Every other argument against boils down to a style preference.

Otherwise, there are any number of valid use cases where all state is known at compile time, but that it is very helpful to mock the results for unit test purposes.

 =||= > I'd argue that a static method that uses the network or disk isn't a good static method - it relies too much on external inputs for it to be a pure function. But, that's personal preference, clearly many people do this, and as such I do think Mockito should offer the option to mock statics.

@GregDThomas 
I think, people use static methods because they don't have any state. Sure, there are too many external inputs, but there is _**no state**_. If I read the file a thousand times, I'll get the same output. And I don't think that if we make it no-static those _external inputs_ automatically gets solved. Basically I've to write the same piece of code. 

For stateful code, use class methods and for stateless methods use static.  =||= > > To all: it seems to me there's a fundamental divide in this thread between people who are of the opinion that it's fine to just make a wrapper class for static calls, and people who are of the opinion that wrapper classes add bloat and shouldn't be necessary. I don't see either side convincing the other, so I'm not sure where that leaves us.
> 
> I'd say that the divide is between people who want to design their code properly and those who want to take the path of least resistance (which isn't a wrong choice sometimes).

This really highlights the difference between discussing the needs of the feature and judging the development choices of other teams.

I think @rdicroce got it right. What we see in this issue is that many people are perfectly comfortable buidling wrapper classes for this single, exclusive need [or even PowerMock, which does a bunch stuff, but again for this single purpose] and others wish they could just test the code they already got.

For the first group of people, no action is needed, but also nothing would be lost -- They'd just keep using Mockito while skipping the static mocking. For the second group, I think Mockito [core, by the way] is lacking a feature that could genuinely help them.

In any case, thanks to the team for even investigating this. I hope it gets implemented. =||= what is the current state of this FR? is there any progress is there any decision? =||= This is not currently pursued. It is technically possible but it is a bigger venture and I am currently lacking the time for it. I'd love to do it but I would need at least three full time weeks for it and between projects and other open source work, I cannot currently find that much space. =||= So, any plans on supporting this? =||= As @raphw said it is technically possible. I managed to write [a prototype to stub static methods](https://github.com/ChristianSchwarz/mockito-lambda/commit/a0101976f7af5db5effa39269ec69538eb6f2b78), it also allows to stub `static void` methods using a lambda like that:

```
Mockito.mockStatic(StaticUtil.class);
when(()->StaticUtil.voidFoo()).thenThrow(new RuntimeException());

// or  equivalent 
when(StaticUtil::voidFoo).thenThrow(new RuntimeException());
```

Unfortunatly the idea to use lambda as `when`  argument was rejected years ago (#828 ). 

Therefore the first step should be to define a scope and an API that needs to be accept by the mockito-core developers. 
 =||= The issue exists for about 3 years, So any plan to support it? =||= > So any plan to support it?

The OP of this issue is the founder of mockito, so the answer is yes. Due to the lack of time non of the core developers can't work on it.  
I would like to work on it but I am afraid that a PR won't get reviewed or merged due to the shortage of time of the core mockito developers. An other option would be to fork mockito, but that undertaking is to much effort for me alone since you need to setup the whole release infrastructure.

Nevertheless everyone reading this is invited to participate, either by API discussion, prototypes or other toppics to drive this. =||= Getting this feature right takes a lot of effort and time, as Rafael pointed out. Moreover, in the current situation with the pandemic, we are finding ourselves with less time on our hands and are dealing with problems not related to programming 😢 

There is consensus in the core team that we do want this feature. We have written prototypes and explored this space. Based on these explorations, we had to conclude that it was more challenging than we initially expected. This is not something you can implement in 1 PR and has implications on the larger architecture of Mockito.

While you of course have the option to fork, these problems would remain. We expect you will have a difficult time implementing proper static method support in the current project structure. That's to say: it is probably possible to hack it in, but that is not good for longterm maintenance of the project. Given that Mockito is a mature project used by a lot of users, implementing these hacks would not be the appropriate decision for the large majority of our users.

In my personal judgement, this feature points to the issue that Mockito has matured over time, but we are now finding shortcomings in the current architecture. A better look at the internal implementation and a potential overhaul would help us plan support for this feature. However, I think we are obligated to maintain API stability and prevent a Mockito 2 upgrade scenario, where customers face a large cost of upgrading. Getting that balance right is difficult and time-consuming. Time that we do not have at this moment in time, given the state of the world and the effect that has on our mental/physical health. =||= What is the state of Mockito + PowerMock?   Mostly, I use Mockito.  I end up using different versions on different projects.  My recollection is that, with newer versions of Mockito, it _intentionally_ no longer plays nice with PowerMock.   I.e. all that is required is to re-enable an API or two to re-nable PowerMock.  No need to duplicate that feature set. =||= I am not sure where you got that information from, but that is not our intention. If Powermock 2 and Mockito 3 don't work together, that is a bug. =||= @CharlieReitzel I personally don't like using PowerMockito since Coverage tools show zero coverage for the classes in which we've used PowerMockito.  =||= @ghsatpute Hi Ganesh, I have heard that complaint in the past.  But have had a problem getting coverage measurements for the class under test while using PowerMock.    I am assuming, of course, you don't apply PowerMock to the class under test. =||= @TimvdLippe Forgive me if I have lost the specifics.  It's been a couple years.  Last I checked, I could not use any version of PowerMock with any 2.x version of Mockito and the reason was that certain methods that were public in 1.x became private in 2.x.   If that issue has been resolved in the meantime, I would suggest the following:

1. Verify it is, in fact, possible mock static methods using PowerMock 2 and Mockito 3.
2. Close this issue as ""Won't fix"" with the guidance to use PowerMock for that purpose.

Personally, I agree that, if you find yourself wanting to mock a static method, first think hard about it and see if there isn't a better way to get the job done.   But, sometimes, you just need a sledgehammer!  :--) =||= @CharlieReitzel https://mvnrepository.com/artifact/org.powermock/powermock-api-mockito2 should be compatible with Mockito 2/3. For more info see https://github.com/powermock/powermock/wiki/Mockito-2-Maven

This ticket is about supporting static method mocking in Mockito, without having to rely on Powermock. Since we see merit in supporting that use case in Mockito, we will keep this issue open. =||= I just had a look at the suggestion of @ChristianSchwarz - nicely done! (Could you squash the commits and remove the formatting/import changes?)

I will try to make this my summer project. I know a lot of people want this and I just had too much Byte Buddy maintenance lately to commit to it but I still really want to do it. I have to have a deeper look at Christian's solution and check all edge cases but I think the API makes sense and after some clean up, this might be the way to go! =||= Alright, something bit me yesterday and I built a POC with a slightly different approach. What always bothered me about static mocks was their potential inferrence with parallel test cases and so forth, but all of this is solvable. I put the working prototype on a branch and suggest this API:

https://github.com/mockito/mockito/blob/static-mock/subprojects/inline/src/test/java/org/mockitoinline/StaticMockTest.java

I'll clean it up and add documentation. Feedback welcome! =||= Hi Rafael,  I like the scoping of the mock via Closable interface.   +1.   Also, Java 8 method references make a lot of sense in this context.  

Just out of interest, this looks a bit different than Christian's use of lambdas.  Or does it work out the the same thing (w/ the Java compiler handing Mockito a `Function`  to mock, either way)? =||= Thanks @raphw  for that and glad to see some progress on it. I do want to reiterate that you should not take this project on if you do not have the mental/physical capacity to do so. As a fellow maintainer, I would prefer if you stay in the running, rather than overloading you with this project.

Let us know if we can assist you in any matter possible. Very glad to see an elegant solution this problem, so props for figuring this out! Evidence yet again we can be lucky we have you on our side working on these problems 😄  =||= @raphw glad you took some inspiration and motivation out of my attempt. I had quick look into  your branch, looks like you are going full steam ahead. 

Some questions and toughts:

-  The scope meant to automatically reset the static mock after usage, right?
   - It is safe when used with ""try with resource"" but people might use it without, its not possible to enforce it.
   - The try with resource adds noise / ceremony to the test it self , an other option is to do the reset automatically after a test.
   - How to mock multiple static classes?
   - Can I stub a static method in a before-each so it is not required to stub it in every test?

 - On twitter you wrote the static mocks are thread local
   - What if I am testing a larger component that runs code in multiple threads, how to do that?


  
   

 =||= Hi Christian,

thanks for your prototype. It helped me to put the last bits of the puzzle on its place. The thing that bothers me the most with static method mocks is the inability to run tests in parallel. It can really add a lot of confusion since not everybody expects it, for example when adjusting a build script. This way, it is fully safe. I think for now, we leave it this way; it would however not be difficult to add a `MockSettings` option to include additional threads or to even make the mock global. I still think we leave it out of the first version and consider it for later.

Mocking multiple classes for static methods is fully possible:

```
try (
  MockedStatic<Foo> foo = Mockito.mockStatic(Foo.class);
  MockedStatic<Bar> bar = Mockito.mockStatic(Bar.class)
) {
  // ...
}
```

The only thing that is not allowed is to mock the same class twice but Mockito will detect this and throw an exception. I also adjusted the JUnit integration to make the ceremony superfluous. You can simply do:

```java
@Mock 
MockedStatic<Foo> foo;
```

in a JUnit test when using the rule or extension and the same works in JUnit 5's extension for method parameters. Mockito will then take care of the lifecycle. If the explicit model is used and the mock is not closed, it is currently unsafe. We could however add functionality to clear all mocks on a thread within the runner and rules where I do however expect the annotations to be used mostly.  =||= @raphw I know I am a little late to the party. Is it possible to simplify the API a bit so users are not forced to use the MockStatic instance like this:


```
try(MockedStatic<Dummy> ignore = Mockito.mockStatic(Dummy.class)) {
            when(Dummy::foo).thenReturn(""bar"");
            verify(Dummy::foo);
            
}
```

Once the `Verification`-Lambda is executed you know that `Dummy.foo()` was called. Then you can map the `Dummy.class` to the corresponding `MockedStatic` object. This way users don't need to reference the `MockedStatic` object. This also allows to simplify futher by obmitting the try-with-resource. E.g:

```
Mockito.mockStatic(Dummy.class, ()=>{  //Note: The lambda defines the scope of the static mock
  when(Dummy::foo).thenReturn(""bar"");
  verify(Dummy::foo);
});
```

 =||= I can see for myself that we add something like: 

```java
Mockito.mockStatic(Dummy.class).scope(() -> { 
  ... 
});
```

`mockStatic` is already overloaded, I would like to avoid another overload to keep it synchronous with `mock`. Not sure if I like the lambda syntax. It works nicely with no-arg methods but not so much otherwise. I think at least that introducing it into the standard API should be another ticket, if accepted. =||= Thank Rafael you for the constuctive discussion and considering other opinions and approches. Such a behaviour is rarly found !

> Not sure if I like the lambda syntax.
Yes I know what you mean, it adds noise.

Talking about the scope: An other option is to enable static mocks via`@StaticMock` or `staticMock(Class)` and then reset/disable them automatically after each test. If required users can call `resetStatic(Class)` in the test.

 =||= I don't think I would support a lambda-solution or a solution that relies on a return type. If we would return a special interaction method, where you later have to call `close()` yourself, then you can assign this to any variable/field and make it longlived. This opens up a whole can of worms with working with static method mocking.

Therefore, for me, one requirement for static method mocking is that it is explicitly limited to scope and can't escape that scope. The `try`-solution addresses this point, but the lambda return call does not. =||= When you use the lambda you will be safe, the static mock will only life in the scope of the lambda.

```
Mockito.mockStatic(Dummy.class).scope(() -> { 
  ... 
});
```
The mock is generated when you call the `scope(..)` method, then the lambda/scope is executed.After that the mock will be closed/reset. There is no way to escape the scope. But this extra method and lamda add complexity, same goes for the overloaded mockStatic method that accepts the scope/lambda. 

----

The `MockedStatic` approach don't give you guarantees if the user doesn't use try-with resource like this:

```
var dummy= Mockito.mockStatic(Dummy.class);
dummy.when(Dummy.foo()).thenXXX();
```
The mocking/stubbing/verifing will work as expected but leaves the Class in a mocked state. 


The automatic close/reset at the end of a test is an option that can be considered. =||= Replacing `Mockito.mockStatic(klass, () -> { … })` with the fluent `Mockito.mockStatic(klass).scope(() -> { … })` may look nice (to others, not necessarily to me :-)), but then the compiler won't complain when the scope is missing.
If you want to force a scope, please make it a parameter of (all overloaded) `mockStatic`. =||= The problem with only allowing it in a given lambda scope is that any alternartive life-cyle management approaches are not supported. Having the construct available for example allows for the use in Junit extensions and rules.

The try-with-resources construct can be forgotten but it is also the most flexible option. I suggest we stick to it for the first release.  =||= I'm late to this conversation, and I'm glad to see that there is some movement on this. I am firmly in support of the addition of static method mocking to Mockito. It is true that there are workarounds - someone wrote: ""Every problem can be solved with a layer of abstraction"" - but then there is the corollary that seems to be forgotten: ""...except for the problem of too many layers of abstraction."" Simplicity should be a goal of code - we shouldn't add complexity without good reason, and layers of abstraction add complexity at all levels (in development and at runtime). In the case of mocking statics, it is certainly *possible* to get around this problem (to an extent) by adding a new layer of abstraction - but this adds complexity. We may often decide the trade-off is worth it to make our code testable, but wouldn't it be better if you didn't have to make the trade-off? If you could mock statics without paying the price of adding an extra level of indirection? Also, adding a layer of abstraction is only possible in code that I have control over. What if I'm using a third-party library? `System.currentTimeMillis()` is a classic example - there's no good way to reliably simulate code running at different system times without mocking this static method (you can use wrappers in your own code, but there's no guarantee that all the 3rd-party libraries you might want to use will).

I also wanted to throw a couple of things into the mix, in commentary on the current implementation-in-progress:

1. _constructors are effectively static methods_. I think it would be great if whatever mechanism is implemented here to mock static methods can also be used to mock constructors. Doing so gives you a way to inject mock instances of dependencies into your class-under-test without requiring you to rewrite the class-under-test for this purpose. JMockit provides such a capability, and I would love to see Mockito have it too (as JMockit doesn't play will with OSGi, whereas Mockito does).
2. There has been talk about the temporal scope of the static mock, but I think that consideration also needs to be given to the caller scope: which classes will see the mocked method and which will see the original. I'm thinking here in particular the case of mocking methods of common classes (eg, JDK classes) that might also be in use by the test framework. The test framework will rely on the normal behaviour of the mocked class while you will want the class-under-test (and its dependencies) to see the mocked behaviour. It wouldn't be a good idea to mock (eg) `System.currentTimeMillis()` if it was going to be seen by the test framework as it will mess up the running of the test, but it would be great to be able to mock it for the code-under-test. =||= Thanks, this is about my train of thought. Additionally, it is sometimes just not feasible to refactor code. Either the code is not yours or you cannot change a legacy code base (immediately). In these cases, it is very convenient to have the possibility to mock static methods, also to give you safety if you are changing code in intermediate steps to finally remove them. 

Construction mocks are in the making and will be part of 3.5.0. You can have a look at my open PRs if you want to give it a test run. It's fully working and I am only waiting for the Mockito team members to return from their vacations to get some feedback from them before merging.

Finally note that Mockito forbids mocking the static methods of `System` (and `Thread`). Those methods are to much cemented into class loading which happens in the same thread. At some point, we might add instrumentation to class loading to temporarily disable the static mocks within it to make mocking these classes, too, where we also would need to disable their intensification properties. You can however easily mock `Instant.now()`. =||= ",0
1961,1960,Documentation: `@Mock` on method parameters,"While writing [an article about using `@Mock` as a method parameter](https://www.jvt.me/posts/2020/06/27/mockito-mock-parameter/), I noticed that the [JavaDoc for Mockito](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#mock_annotation) doesn't mention the ability to use `@Mock` as a parameter to a test method.

How would be best to add that as a PR, given it's dependent on the test runner?

I was thinking something like:

```
 * <h3 id=""9"">9. <a class=""meaningful_link"" href=""#mock_annotation"" name=""mock_annotation"">Shorthand for mocks creation - <code>&#064;Mock</code> annotation</a></h3>
 *
 * <ul>
 * <li>Minimizes repetitive mock creation code.</li>
 * <li>Makes the test class more readable.</li>
 * <li>Makes the verification error easier to read because the <b>field name</b>
 * is used to identify the mock.</li>
 * </ul>
 *
 * <pre class=""code""><code class=""java"">
 *   public class ArticleManagerTest {
 *
 *       &#064;Mock private ArticleCalculator calculator;
 *       &#064;Mock private ArticleDatabase database;
 *       &#064;Mock private UserProvider userProvider;
 *
 *       private ArticleManager manager;
 *
 *       @Test
 *       void testSomething(@Mock ArticleDatabase database) {
 * </code></pre>
```","We mention that information in https://javadoc.io/doc/org.mockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/MockitoExtension.html as we don't support initiating Mocks on parameters with JUnit4. Therefore, we should add a parameter something like:

```java
 *       @Test
 *       void testSomething(@Mock ArticleDatabase canOnlyBeInstantiatedWithJUnit5) {
```

Other than that, please open a PR 😄  =||= Oh I didn't realise that, thanks! I'll amend my article with that knowledge too.

Am I OK to add a PR for both the v2 and v3 documentation, given it works on both versions? =||= We no longer publish v2 updates, so v3 only. =||= ",0
1968,1967,Static method mocks incompatible with MockitoExtension (NotAMockException),"Hello,

I am experimenting with the newly released functionality of mocking static methods.
It appears that static mocks are not compatible with the `MockitoExtension` designed for JUnit 5.
Following error message is produced when using the extension:
```
org.mockito.exceptions.misusing.NotAMockException: Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Class!
```
Full Stacktrace: [static-mock-mockito-extension-stacktrace.txt](https://github.com/mockito/mockito/files/4908237/static-mock-mockito-extension-stacktrace.txt)

I have created following minimal example which is composed of a `Utils` class (containing the static method) and a `UtilsUser` class (calls the static Utils method). `UtilsUserTest` tests the functionality of the `UtilsUser` class.

```java
public class Utils {
    public static long millis() {
        return System.currentTimeMillis();
    }
}
```

```java
public class UtilsUser {
    public long use() {
        return Utils.millis();
    }
}
```

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;

@ExtendWith(MockitoExtension.class)
class UtilsUserTest {
    @InjectMocks
    private UtilsUser utilsUser;

    @Test
    void use() {
        try (MockedStatic<Utils> mockedUtils = Mockito.mockStatic(Utils.class)) {
            mockedUtils.when(Utils::millis).thenReturn(17L);
            assertEquals(17L, utilsUser.use());
        }
    }
}
```
When converting this test to a test which does not use the extension (removing `@ExtendWith`, removing `@InjectMocks`, adding `= new UtilsUser()` after the field declaration), the test passes.

Can you tell me if there is something special I have to accomodate for when using the static mocks in JUnit Jupiter?
Or is this indeed a bug (which you can hopefully reproduce)?

I am using mockito-inline and mockito-junit-jupiter in version 3.4.0.

Thanks in advance and thanks for the new static mocks functionality!
David","Thanks for reporting. We already found the error, it slipped us. I think we can have a release ready fairly soon. =||= ",0
1973,1972,Update dependency to byte buddy version 1.10.13,"https://github.com/mockito/mockito/blob/release/3.x/gradle/dependencies.gradle#L7

1.10.13 is available: https://github.com/raphw/byte-buddy/releases/tag/byte-buddy-1.10.13",Feel free to open a PR with the version bump 😄  =||= ,0
1974,1855,javax.tools.ToolProvider could not be found in InlineByteBuddyMockMaker,"Hi guys

I'm encountering a crash when I run `AndroidTest` that contain mocking class cause the ByteBuddy didn't found `javax.tools.ToolProvider`. I tried to reinstall JDK 8 but doesn't work. It seems to be `javax.tools.ToolProvider` not existing in it. 

Could you guys help me please?

Cheer,

Natthawut

## Environment
------------------------------------------------------------
Gradle 5.4.1
------------------------------------------------------------

Build time:   2019-04-26 08:14:42 UTC
Revision:     261d171646b36a6a28d5a19a69676cd098a4c19d

Kotlin:       1.3.21
Groovy:       2.5.4
Ant:          Apache Ant(TM) version 1.9.13 compiled on July 10 2018
JVM:          1.8.0_231 (Oracle Corporation 25.231-b11)
OS:           Mac OS X 10.15.2 x86_64

## Dependencies

```
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation""org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version""
    implementation 'androidx.appcompat:appcompat:1.1.0'
    implementation 'androidx.core:core-ktx:1.1.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    testImplementation 'org.mockito:mockito-core:3.2.4'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
    androidTestImplementation 'org.mockito:mockito-android:3.2.4'
    androidTestImplementation ""io.mockk:mockk-android:1.9.3.kotlin12""
```

## Strack trace

```
E/TestRunner: failed: mockFoo(co.sample.mockitoandroid.MockWithMockitoTest)
    ----- begin exception -----
E/TestRunner: java.lang.IllegalStateException: Could not initialize plugin: interface org.mockito.plugins.MockMaker (alternate: null)
        at org.mockito.internal.configuration.plugins.PluginLoader$1.invoke(PluginLoader.java:74)
        at java.lang.reflect.Proxy.invoke(Proxy.java:1006)
        at $Proxy3.isTypeMockable(Unknown Source)
        at org.mockito.internal.util.MockUtil.typeMockabilityOf(MockUtil.java:29)
        at org.mockito.internal.util.MockCreationValidator.validateType(MockCreationValidator.java:22)
        at org.mockito.internal.creation.MockSettingsImpl.validatedSettings(MockSettingsImpl.java:241)
        at org.mockito.internal.creation.MockSettingsImpl.build(MockSettingsImpl.java:229)
        at org.mockito.internal.MockitoCore.mock(MockitoCore.java:62)
        at org.mockito.Mockito.mock(Mockito.java:1908)
        at org.mockito.Mockito.mock(Mockito.java:1817)
        at co.sample.mockitoandroid.MockWithMockitoTest.<init>(MockWithMockitoTest.kt:17)
        at java.lang.reflect.Constructor.newInstance0(Native Method)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:343)
        at org.junit.runners.BlockJUnit4ClassRunner.createTest(BlockJUnit4ClassRunner.java:217)
        at org.junit.runners.BlockJUnit4ClassRunner$1.runReflectiveCall(BlockJUnit4ClassRunner.java:266)
        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
        at org.junit.runners.BlockJUnit4ClassRunner.methodBlock(BlockJUnit4ClassRunner.java:263)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
        at androidx.test.ext.junit.runners.AndroidJUnit4.run(AndroidJUnit4.java:104)
        at org.junit.runners.Suite.runChild(Suite.java:128)
        at org.junit.runners.Suite.runChild(Suite.java:27)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
        at androidx.test.internal.runner.TestExecutor.execute(TestExecutor.java:56)
        at androidx.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:392)
        at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2145)
     Caused by: java.lang.NoClassDefFoundError: Failed resolution of: Ljavax/tools/ToolProvider;
        at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.<init>(InlineByteBuddyMockMaker.java:172)
        at java.lang.Class.newInstance(Native Method)
        at org.mockito.internal.configuration.plugins.PluginInitializer.loadImpl(PluginInitializer.java:49)
        at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:57)
        at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:44)
        at org.mockito.internal.configuration.plugins.PluginRegistry.<init>(PluginRegistry.java:22)
        at org.mockito.internal.configuration.plugins.Plugins.<clinit>(Plugins.java:19)
        at org.mockito.internal.configuration.plugins.Plugins.getMockMaker(Plugins.java:35)
        at org.mockito.internal.util.MockUtil.<clinit>(MockUtil.java:24)
        at org.mockito.internal.util.MockUtil.typeMockabilityOf(MockUtil.java:29) 
        at org.mockito.internal.util.MockCreationValidator.validateType(MockCreationValidator.java:22) 
        at org.mockito.internal.creation.MockSettingsImpl.validatedSettings(MockSettingsImpl.java:241) 
        at org.mockito.internal.creation.MockSettingsImpl.build(MockSettingsImpl.java:229) 
        at org.mockito.internal.MockitoCore.mock(MockitoCore.java:62) 
        at org.mockito.Mockito.mock(Mockito.java:1908) 
        at org.mockito.Mockito.mock(Mockito.java:1817) 
        at co.sample.mockitoandroid.MockWithMockitoTest.<init>(MockWithMockitoTest.kt:17) 
        at java.lang.reflect.Constructor.newInstance0(Native Method) 
        at java.lang.reflect.Constructor.newInstance(Constructor.java:343) 
        at org.junit.runners.BlockJUnit4ClassRunner.createTest(BlockJUnit4ClassRunner.java:217) 
        at org.junit.runners.BlockJUnit4ClassRunner$1.runReflectiveCall(BlockJUnit4ClassRunner.java:266) 
        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 
        at org.junit.runners.BlockJUnit4ClassRunner.methodBlock(BlockJUnit4ClassRunner.java:263) 
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) 
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) 
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) 
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) 
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) 
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) 
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) 
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363) 
        at androidx.test.ext.junit.runners.AndroidJUnit4.run(AndroidJUnit4.java:104) 
        at org.junit.runners.Suite.runChild(Suite.java:128) 
        at org.junit.runners.Suite.runChild(Suite.java:27) 
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) 
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) 
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) 
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) 
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) 
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363) 
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137) 
        at org.junit.runner.JUnitCore.run(JUnitCore.java:115) 
        at androidx.test.internal.runner.TestExecutor.execute(TestExecutor.java:56) 
        at androidx.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:392) 
        at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2145) 
     Caused by: java.lang.ClassNotFoundException: Didn't find class ""javax.tools.ToolProvider"" on path: DexPathList[[zip file ""/system/framework/android.test.runner.jar"", zip file ""/system/framework/android.test.mock.jar"", zip file ""/data/app/co.sample.mockitoandroid.test-ZJFawUg-
    ----- end exception -----
```
<img width=""968"" alt=""Screen Shot 2563-01-07 at 12 45 26"" src=""https://user-images.githubusercontent.com/2638321/71871412-a93ee100-314b-11ea-9815-31a5d95056d4.png"">


[MockitoAndroid.zip](https://github.com/mockito/mockito/files/4029049/MockitoAndroid.zip)




","I think this commit is part of the problem: https://github.com/mockito/mockito/pull/1567/files =||= > I think this commit is part of the problem: https://github.com/mockito/mockito/pull/1567/files

I tried with mockito 2.22.0, which should be a release before  the commit, but the error is still there. https://github.com/mockito/mockito/releases?after=v2.23.0

edit: what fixed the issue for me was removing the `mock-maker-inline` resource file =||= The inline mockmaker is not supported on Android (as listed in the exception). However, we should probably not crash before we can show that message to the user. I would welcome a PR to fix this problem. =||= @TimvdLippe What should people do for android then? Kotlin uses final classes only. =||= @raphw What is our advice for Android? I don't remember what our final resolution was for inline + android for Kotlin. =||= I just started using https://mockk.io/. Its Kotlin friendly also =||= On Android, the inline mock maker won't work (neither will Mockk which uses the same approach as we do). It does not support the instrumentation API alltogether.

I do agree that the error message is misleading. Currently preparing a PR to improve this. =||= You can achieve this by using com.linkedin.dexmaker:dexmaker-mockito-inline for APIs >= 28 =||= ",0
1986,1985,README should refer the latest available documentation,"**Actual:**
README contains link `latest documentation` 
http://javadoc.io/page/org.mockito/mockito-core/2/org/mockito/Mockito.html 
which redirects to 
https://javadoc.io/static/org.mockito/mockito-core/2.9.0/org/mockito/Mockito.html 
(Note: version is `2.9.0`)

**Expected:**
The link `latest documentation` should point to the latest available documentation 
http://javadoc.io/page/org.mockito/mockito-core/3/org/mockito/Mockito.html
which redirects to 
https://javadoc.io/static/org.mockito/mockito-core/3.4.4/org/mockito/Mockito.html 
at the current moment (Note: version is `3.4.4`).",Feel free to open a PR :) =||= ,0
1989,1988,MockitoJUnitRunner causes NPE when using @Mock on MockedStatic fields,"check that

 - [x] The mockito message in the stacktrace have useful information, but it didn't help
 - [x] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [x] Provide versions (mockito / jdk / os / any other relevant information)
 - [x] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)

**Versions:**
 - mockito: 3.4.4
 - junit: 4.12
 - jdk: 1.8
 - os: windows 10

**Example:**

1. [MockitoJUnitRunnerWithMockedStaticTest](https://github.com/Cybermite/mockito-static-npe-example/blob/bdd30465632b21c36ce7635929e7825c5878ee83/src/test/java/org/mockito/example/MockitoJUnitRunnerWithMockedStaticTest.java)
    * Reproduces the problem documented in this issue.
1. [MockitoOpenMocksMockedStaticTest](https://github.com/Cybermite/mockito-static-npe-example/blob/bdd30465632b21c36ce7635929e7825c5878ee83/src/test/java/org/mockito/example/MockitoOpenMocksMockedStaticTest.java)
    * Same tests but manually opens and closes the mocks (doesn't use the runner). Shows the tests are ran as expected.

**Problem:**

The `MockitoJUnitRunner` is causing a `NullPointerException` when the test class contains a `@Mock` instance field with a type of `MockedStatic`. This exception only occurs for tests that are ran after a prior test fails. If all the tests pass, there are no issues.

Stack Trace (Test 1):

```
java.lang.AssertionError: intentional failure
	at org.junit.Assert.fail(Assert.java:88)
	at org.mockito.example.MockitoJUnitRunnerWithMockedStaticTest.testName1(MockitoJUnitRunnerWithMockedStaticTest.java:40)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.mockito.internal.runners.DefaultInternalRunner$1$1.evaluate(DefaultInternalRunner.java:54)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.mockito.internal.runners.DefaultInternalRunner$1.run(DefaultInternalRunner.java:99)
	at org.mockito.internal.runners.DefaultInternalRunner.run(DefaultInternalRunner.java:105)
	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:40)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:163)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:538)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:760)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:206)

org.mockito.exceptions.misusing.NotAMockException: Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Class!
	at org.mockito.internal.runners.DefaultInternalRunner$1$2.testFinished(DefaultInternalRunner.java:81)
	at org.junit.runner.notification.SynchronizedRunListener.testFinished(SynchronizedRunListener.java:56)
	at org.junit.runner.notification.RunNotifier$7.notifyListener(RunNotifier.java:190)
	at org.junit.runner.notification.RunNotifier$SafeNotifier.run(RunNotifier.java:72)
	at org.junit.runner.notification.RunNotifier.fireTestFinished(RunNotifier.java:187)
	at org.junit.internal.runners.model.EachTestNotifier.fireTestFinished(EachTestNotifier.java:38)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:331)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.mockito.internal.runners.DefaultInternalRunner$1.run(DefaultInternalRunner.java:99)
	at org.mockito.internal.runners.DefaultInternalRunner.run(DefaultInternalRunner.java:105)
	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:40)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:163)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:538)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:760)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:206)
```

Stack Trace (Test 2):

```
java.lang.NullPointerException
	at org.mockito.example.MockitoJUnitRunnerWithMockedStaticTest.testName2(MockitoJUnitRunnerWithMockedStaticTest.java:54)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.mockito.internal.runners.DefaultInternalRunner$1$1.evaluate(DefaultInternalRunner.java:54)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.mockito.internal.runners.DefaultInternalRunner$1.run(DefaultInternalRunner.java:99)
	at org.mockito.internal.runners.DefaultInternalRunner.run(DefaultInternalRunner.java:105)
	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:40)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:163)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:538)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:760)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:206)
```

**Investigation:**

After some investigation, it appears the first test is failing twice (once in the test and once in the testFinished listener). This code:

https://github.com/mockito/mockito/blob/573bf0df389964d7fdeb4de486882d4599b8033c/src/main/java/org/mockito/internal/runners/DefaultInternalRunner.java#L75-L96

Line 81 is where it fails the second time. If we navigate down the call hierarchy, it appears it fails because the static mock has already been cleaned up so the framework doesn't think it's a mock and fails with a `NotAMockException`.  Since it fails there, it doesn't set the listener to null which will in-turn result in the mocks not being initialized on the next test that's ran (hits line 51):

https://github.com/mockito/mockito/blob/573bf0df389964d7fdeb4de486882d4599b8033c/src/main/java/org/mockito/internal/runners/DefaultInternalRunner.java#L42-L59

Since the mocks are not initialized for the second test, it ultimately causes the `NullPointerException`.

It's also causing the remaining tests after the first test failure to bounce back and forth between `NullPointerException` and `NotAMockException`. The reason for this appears to be because [this failure](https://github.com/mockito/mockito/blob/573bf0df389964d7fdeb4de486882d4599b8033c/src/main/java/org/mockito/internal/runners/DefaultInternalRunner.java#L67) object never gets reset after it's processed so it keeps restarting the chain of throwing the two exceptions back and forth.

Also, I did include a sample test that manually opens and closes the mocks (doesn't use MockitoJUnitRunner) and everything is working as expected. Using the try-with-resource works fine as well.

I did investigate further and noticed something related to this might have been addressed in [this PR](https://github.com/mockito/mockito/pull/1968/files?file-filters%5B%5D=.java#diff-d24b5a756bdb953f5effcddac2b17b72R42). It only updated the findStubbings method to skip the static mocks, though. Was the AllInvocationsFinder.find(...) method intentional left out of that or just an oversight?","Just tried the tests with using MockitoRule and it's working as expected as well. =||= @raphw this issue still exists in 3.4.6. Was the PR supposed to fix all of this or only a part of it? The linked example above still causes NPE. This one: [MockitoJUnitRunnerWithMockedStaticTest](https://github.com/Cybermite/mockito-static-npe-example/blob/bdd30465632b21c36ce7635929e7825c5878ee83/src/test/java/org/mockito/example/MockitoJUnitRunnerWithMockedStaticTest.java) =||= I was under the impression that I fixed it but I will take another look if it is not. I refactored your test and added it to the built but maybe I broke it in the process. =||= I just ran the test with the latest Mocktio and it works as expected. Are you sure that you are running the right version?  =||= Yep, just doubled checked. It's using 3.4.6. Are you running my test class (without modification) or your refactored version of it? If you modified it, can you send me modified one and I'll double check it. =||= Copy pasted it as it is i to the release/3.x branch.  =||= Okay, sorry for the confusion. When I was investigating this issue on July 25, I must have installed into locally and it got shoved into my local .m2 repo as 3.4.6 without the fix. Then when you fixed it and I updated the pom version to point to 3.4.6 it didn't redownload it because it was already in my local repo.

I deleted it from my local .m2 repo and redownloaded it from maven-central. Everything is good now. Thanks! =||= Perfect, Gradle does not work with snapshot versions, happened to me a few times, too.  =||= ",0
1998,1992,Update to org.objenesis 3.x,"Hi all,

we are slowly updating our product to Java 11; we've managed to move to Java 11 runtime, now we are trying to also compile with Java 11.

We ran into a problem with `org.easymock` (it doesn't work with Java 11 compiled classes, https://github.com/easymock/easymock/issues/218). The problem is resolved in 4.x versions.

Unfortunately, 4.x versions of `org.easymock` run only with `org.objenesis` 3.x, which `mockito` so far does not accept (upper bound for `org.objenesis` is 2.6).

Are there plans to update `mockito` to run with `org.objenesis` and if so are there known timelines?

Some more background:

We essentially wished to update to latest `mockito` and `easymock` earlier (during the Java 11 runtime move), but were unable to do so due to conflicting `org.objenesis` requirements. If we want to compile with Java 11 however, we are made to choose between  `easymock` or `mockito`, or waiting. We would prefer to wait, if a `mockito` update that runs with `org.objenesis` 3.x would be available soon.

Sorry if this should be an e-mail message and not an issue in the tracker, or if this is a duplicate (I didn't find much about `org.objenesis` in the issue list).

Best regards and thanks,
Simeon","I would be happy to review a PR that updates our version of Objenesis 😄  =||= I'll check the contribution guide, though I can't promise much. So far Java 11 compile is not top priority in my team. =||= ",0
2017,2015,Issues mocking Java framework classes in Robolectric with mockito-inline,"Hi Mockito folks,

Currently it is not possible to mock a Java framework class (e.g. java.io.File) in Robolectric when mockito-inline is used. This issue has come up a bunch of times in Robolectric, mostly when Kotlin is used to write Robolectric tests.

https://github.com/robolectric/robolectric/issues/5522
https://github.com/robolectric/robolectric/issues/5638
https://github.com/robolectric/robolectric/issues/5865

For instance, if a trivial tests is run with the Robolectric test runner with mockito-inline:

```java
  @Test
  public void file_getAbsolutePath_isMockable() throws Exception {
    File file = mock(File.class);
    doReturn(""absolute/path"").when(file).getAbsolutePath();
    assertThat(file.getAbsolutePath()).isEqualTo(""absolute/path"");
  }
```

An NPE will result:
```
java.lang.NullPointerException
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.isConstructorMock(MockMethodDispatcher.java:41)
	at java.base/java.io.File.<init>(File.java)
	at java.base/sun.net.www.protocol.file.Handler.openConnection(Handler.java:80)
	at java.base/sun.net.www.protocol.file.Handler.openConnection(Handler.java:72)
	at java.base/java.net.URL.openConnection(URL.java:1063)
	at java.base/sun.net.www.protocol.jar.JarURLConnection.<init>(JarURLConnection.java:84)
	at java.base/sun.net.www.protocol.jar.Handler.openConnection(Handler.java:41)
	at java.base/java.net.URL.openConnection(URL.java:1063)
	at java.base/java.net.URLClassLoader.getResourceAsStream(URLClassLoader.java:327)
	at org.robolectric.internal.bytecode.SandboxClassLoader.getClassBytesAsStreamPreferringLocalUrls(SandboxClassLoader.java:101)
	at org.robolectric.internal.bytecode.SandboxClassLoader.getByteCode(SandboxClassLoader.java:172)
	at org.robolectric.internal.bytecode.SandboxClassLoader.maybeInstrumentClass(SandboxClassLoader.java:129)
	at org.robolectric.internal.bytecode.SandboxClassLoader.lambda$loadClass$0(SandboxClassLoader.java:115)
	at org.robolectric.util.PerfStatsCollector.measure(PerfStatsCollector.java:53)
	at org.robolectric.internal.bytecode.SandboxClassLoader.loadClass(SandboxClassLoader.java:115)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.robolectric.Shadows.reset(Shadows.java:2298)
	at org.robolectric.android.internal.AndroidTestEnvironment.resetState(AndroidTestEnvironment.java:518)
	at org.robolectric.RobolectricTestRunner.lambda$finallyAfterTest$0(RobolectricTestRunner.java:349)
	at org.robolectric.util.PerfStatsCollector.measure(PerfStatsCollector.java:75)
	at org.robolectric.RobolectricTestRunner.finallyAfterTest(RobolectricTestRunner.java:347)
	at org.robolectric.internal.SandboxTestRunner$2.lambda$evaluate$0(SandboxTestRunner.java:272)
	at org.robolectric.internal.bytecode.Sandbox.lambda$runOnMainThread$0(Sandbox.java:89)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
```

Robolectric uses an instrumenting ClassLoader that transforms Android classes to use real implementations:
https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java#L105

Here is a fork of Robolectric that has a test that captures the issue:
https://github.com/hoisie/robolectric/tree/mockito-inline-test

You can see the failure using the following command:
`./gradlew  :integration_tests:mockito-experimental:test`

Any tips/help debugging would be greatly appreciated. It would be nice to figure out what Robolectric is doing to prevent this from working.



","Are you moving `org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher` to another class loader? Normally, Mockito injects this class into the bootstrap class loader and then initializes this dispatcher with a random identifier. All inline mocks call this class with the very same identifier to communicate with Mockito. The bootstrap loader is used to avoid any issues with class loader hierarchies.

The null pointer exception suggests that the class `org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher` exists on multiple class loaders and that the initialization hit another class loader then the dispatcher. The easiest would be to build something into Robolectric that makes sure that the class loader tricks you apply never targets the `MockMethodDispatcher`. It must only exist in the boot loader at all times. =||= This is indeed the problem, the loader of `MockMethodDispatcher` if resolved from the mock type is `org.robolectric.internal.AndroidSandbox$SdkSandboxClassLoader`. The dispatcher must always be loaded by the bootstrap class loader. You need to exclude it from your class loader shadowing for it to work with boot classes, otherwise the boot classes cannot communicate with Mockito. =||= Can you try again with the release from just now? I defined the window of intercpting construction as narrowly as possible. =||= Thanks for taking a look! I'm excited to give this a shot. Seems like [3.5.4](http://dl.bintray.com/mockito/maven/org/mockito/mockito-inline/3.5.4) hasn't been pushed completely to the maven repo, so I may do a local build if it doesn't show up.

Robolectric does indeed instrument the `org.mockito.*` classes, so I'll make sure that org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher is not being instrumented. Do any other Mockito classes have to be excluded from instrumentation? I tried to exclude all Mockito classes from being instrumented, but then it became impossible to use Mockito to mock Android classes, which is another use case that we would like to support. If we do not instrument org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher, do you see any issues with using Mockito to mock classes instrumented in the Robolectric class loader? =||= That seemed to work! Thanks!! =||= We struggled with Bintray for a while and releases got broken.

It's all about the mock being able to communicate with Mockito. A class on the bootstrap loader can only communicate with classes on the boot loader. I assume your class loaders are child-first? Even those should be parent first for the boot loader, normally.  This way, frameworks dispatching via the bootloader would generally function with Robolectric. =||= ",0
2018,2015,Issues mocking Java framework classes in Robolectric with mockito-inline,"Hi Mockito folks,

Currently it is not possible to mock a Java framework class (e.g. java.io.File) in Robolectric when mockito-inline is used. This issue has come up a bunch of times in Robolectric, mostly when Kotlin is used to write Robolectric tests.

https://github.com/robolectric/robolectric/issues/5522
https://github.com/robolectric/robolectric/issues/5638
https://github.com/robolectric/robolectric/issues/5865

For instance, if a trivial tests is run with the Robolectric test runner with mockito-inline:

```java
  @Test
  public void file_getAbsolutePath_isMockable() throws Exception {
    File file = mock(File.class);
    doReturn(""absolute/path"").when(file).getAbsolutePath();
    assertThat(file.getAbsolutePath()).isEqualTo(""absolute/path"");
  }
```

An NPE will result:
```
java.lang.NullPointerException
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.isConstructorMock(MockMethodDispatcher.java:41)
	at java.base/java.io.File.<init>(File.java)
	at java.base/sun.net.www.protocol.file.Handler.openConnection(Handler.java:80)
	at java.base/sun.net.www.protocol.file.Handler.openConnection(Handler.java:72)
	at java.base/java.net.URL.openConnection(URL.java:1063)
	at java.base/sun.net.www.protocol.jar.JarURLConnection.<init>(JarURLConnection.java:84)
	at java.base/sun.net.www.protocol.jar.Handler.openConnection(Handler.java:41)
	at java.base/java.net.URL.openConnection(URL.java:1063)
	at java.base/java.net.URLClassLoader.getResourceAsStream(URLClassLoader.java:327)
	at org.robolectric.internal.bytecode.SandboxClassLoader.getClassBytesAsStreamPreferringLocalUrls(SandboxClassLoader.java:101)
	at org.robolectric.internal.bytecode.SandboxClassLoader.getByteCode(SandboxClassLoader.java:172)
	at org.robolectric.internal.bytecode.SandboxClassLoader.maybeInstrumentClass(SandboxClassLoader.java:129)
	at org.robolectric.internal.bytecode.SandboxClassLoader.lambda$loadClass$0(SandboxClassLoader.java:115)
	at org.robolectric.util.PerfStatsCollector.measure(PerfStatsCollector.java:53)
	at org.robolectric.internal.bytecode.SandboxClassLoader.loadClass(SandboxClassLoader.java:115)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.robolectric.Shadows.reset(Shadows.java:2298)
	at org.robolectric.android.internal.AndroidTestEnvironment.resetState(AndroidTestEnvironment.java:518)
	at org.robolectric.RobolectricTestRunner.lambda$finallyAfterTest$0(RobolectricTestRunner.java:349)
	at org.robolectric.util.PerfStatsCollector.measure(PerfStatsCollector.java:75)
	at org.robolectric.RobolectricTestRunner.finallyAfterTest(RobolectricTestRunner.java:347)
	at org.robolectric.internal.SandboxTestRunner$2.lambda$evaluate$0(SandboxTestRunner.java:272)
	at org.robolectric.internal.bytecode.Sandbox.lambda$runOnMainThread$0(Sandbox.java:89)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
```

Robolectric uses an instrumenting ClassLoader that transforms Android classes to use real implementations:
https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java#L105

Here is a fork of Robolectric that has a test that captures the issue:
https://github.com/hoisie/robolectric/tree/mockito-inline-test

You can see the failure using the following command:
`./gradlew  :integration_tests:mockito-experimental:test`

Any tips/help debugging would be greatly appreciated. It would be nice to figure out what Robolectric is doing to prevent this from working.



","Are you moving `org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher` to another class loader? Normally, Mockito injects this class into the bootstrap class loader and then initializes this dispatcher with a random identifier. All inline mocks call this class with the very same identifier to communicate with Mockito. The bootstrap loader is used to avoid any issues with class loader hierarchies.

The null pointer exception suggests that the class `org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher` exists on multiple class loaders and that the initialization hit another class loader then the dispatcher. The easiest would be to build something into Robolectric that makes sure that the class loader tricks you apply never targets the `MockMethodDispatcher`. It must only exist in the boot loader at all times. =||= This is indeed the problem, the loader of `MockMethodDispatcher` if resolved from the mock type is `org.robolectric.internal.AndroidSandbox$SdkSandboxClassLoader`. The dispatcher must always be loaded by the bootstrap class loader. You need to exclude it from your class loader shadowing for it to work with boot classes, otherwise the boot classes cannot communicate with Mockito. =||= Can you try again with the release from just now? I defined the window of intercpting construction as narrowly as possible. =||= Thanks for taking a look! I'm excited to give this a shot. Seems like [3.5.4](http://dl.bintray.com/mockito/maven/org/mockito/mockito-inline/3.5.4) hasn't been pushed completely to the maven repo, so I may do a local build if it doesn't show up.

Robolectric does indeed instrument the `org.mockito.*` classes, so I'll make sure that org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher is not being instrumented. Do any other Mockito classes have to be excluded from instrumentation? I tried to exclude all Mockito classes from being instrumented, but then it became impossible to use Mockito to mock Android classes, which is another use case that we would like to support. If we do not instrument org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher, do you see any issues with using Mockito to mock classes instrumented in the Robolectric class loader? =||= That seemed to work! Thanks!! =||= We struggled with Bintray for a while and releases got broken.

It's all about the mock being able to communicate with Mockito. A class on the bootstrap loader can only communicate with classes on the boot loader. I assume your class loaders are child-first? Even those should be parent first for the boot loader, normally.  This way, frameworks dispatching via the bootloader would generally function with Robolectric. =||= ",0
2023,2011,Stackoverflow error when upgrading to v3.5.2,"I tried to upgrade from Mockito v3.4.6 to v3.5.2 and I'm getting a stackoverflow error (same error with v3.5.0) when running some tests (not all of them, just a few ; even in the same class : some tests pass and others don't).

Stacktrace :
```
java.lang.StackOverflowError
	at java.base/java.lang.ThreadLocal.get(ThreadLocal.java:163)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:260)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:53)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
        ...
```

I didn't succeed in reproduce the error in a small project, but I'll spend more time to try and post the sources here when/if I have a reproducible case.

Environment :
- Mockito v3.5.2
- JUnit v5.6.2
- Java :
> openjdk version ""11.0.8"" 2020-07-14
> OpenJDK Runtime Environment (build 11.0.8+10-post-Ubuntu-0ubuntu118.04.1)
> OpenJDK 64-Bit Server VM (build 11.0.8+10-post-Ubuntu-0ubuntu118.04.1, mixed mode, sharing)
- Maven : v3.6.0 (tests are run by the maven-surefire plugin)","I just discovered that the error happens when I launch all my unit tests in the Maven module, but it's fine if I run the test or the test class only.

```sh
$ cd myproject/my-mvn-module-1
$ mvn test
#
# [ERROR]   MyBeanTest.test1 » StackOverflow
#
$ mvn -Dtest=MyBeanTest test
# 
# Tests run: 7, Failures: 0, Errors: 0, Skipped: 0
#
$ mvn -Dtest=MyBeanTest#test1 test
# 
# Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
#
```

Maven configuration (in the root pom.xml) :
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.22.2</version>
    <configuration>
        <skipTests>${skip.unit.tests}</skipTests>
        <includes>
            <include>**/*Test.java</include>
        </includes>
        <argLine>-Dnet.bytebuddy.experimental=true @{argLine} -Dfile.encoding=${project.reporting.outputEncoding}</argLine>
        <trimStackTrace>false</trimStackTrace>
    </configuration>
</plugin>
``` =||= Thanks for reporting. Can you supply an example test case? It looks like an exception is supposed to be thrown but the constructor mocking intercepts its creation where something causes another exception which is again passed to the handler.

Do you mock exceptions somewhere?

Also, could you share the bottom of the stack trace which is where the circularity is introduced. =||= Seeing the same thing myself, although I don't have a stable reproduction scenario. The same was observed with `3.5.0` =||= Could you try the latest release to see if the problem still occurs? =||= Sorry I was not clear originally, I saw the problem at first on `3.5.0` but still see it with `3.5.2`. =||= @raphw 

Yes I mock some exceptions in other test classes but the ones who ends with StackoverflowError. I will take some time today or next week to try to reproduce the bug in a small project.

The full stacktrace :
```
java.lang.StackOverflowError
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:53)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	/* [...] */
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	/* end of stacktrace */
``` =||= This can't be the full stack trace since it needs to origin somewhere. Maybe it's cut off in the print?

I think I know the problem and tried to fix it. Unfortunately, we have some release issues but you could build *release/3.x* locally and try if the problem still occurs. =||= I'm seeing the same error when trying to go from 3.4.6 to 3.5.0.
```
java.lang.StackOverflowError
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.isConstructorMock(MockMethodDispatcher.java:57)
	at java.base/java.lang.Exception.<init>(Exception.java)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
... 
```
seems to be related to using a @Spy in the test class, when I change the @Spy to an @Mock the error goes away.  What seems odd in my case is everything is ok until there are more than 15 tests in the class.  15 tests will pass and any additional tests will fail.

The message of the first exception is `Unexpected spy for java.util.AbstractMap on instance of java.util.concurrent.ConcurrentHashMap`    =||= @raphw Same issue with v3.5.5.

Stacktrace :
```
java.lang.StackOverflowError
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
        [...]
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
``` =||= @jdussouillez That gets us one step closer but I needed to add an exception for when the error is thrown. Could you build the *constructor-dispatch* branch locally and see what exception you get in your setup? =||= @raphw I installed v3.5.6 from the *constructor-dispatch* branch : no more errors, all the tests were executed and passed. So I guess commit https://github.com/mockito/mockito/commit/eaa12bfc018ed00fcd35588dc900d657a9740e32 fixes the issue.

Feel free to ask if you want me to do more tests. =||= That's strange since the exception indicates a scenario that should not occur. I merely fixed the recursion.

Can you set a breakppint to see why this happens? What instance is created during spy construction?  =||= @raphw I didn't succeed in setting breakpoints but I added some logs (before [this line](https://github.com/mockito/mockito/blob/constructor-dispatch/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java#L268)).

Patch : 
```diff
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
index 96477f477..6b37ea09e 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
@@ -265,6 +265,9 @@ public class InlineByteBuddyMockMaker
                         } else if (type.isInstance(spy)) {
                             return spy;
                         } else {
+                            System.out.println(""type = "" + type.getName());
+                            System.out.println(""object = "" + object);
+                            System.out.println(""spy = "" + spy.getClass().getName());
                             isSuspended.set(true);
                             try {
                                 // Unexpected construction of non-spied object
```

Logs (type is always `java.util.AbstractMap`):
```
type = java.util.AbstractMap
object = {}
spy = com.myproject.bean.MyBean1

type = java.util.AbstractMap
object = {}
spy = com.myproject.bean.MyBean2

type = java.util.AbstractMap
object = {}
spy = com.myproject.bean.MyBean3
[...]
``` =||= Could you also add a stack trace at the same spot? (`Thread.dump()`) =||= Code snippet to dump : 
```java
try {
    Thread.dumpStack();
} catch (Throwable t) {
    System.out.println(""error while dumping stack: "" + t.getMessage());
}
```


1. Logs using [`Thread.dumpStack()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#dumpStack()) **after** `isSuspended.set(true);`

```
type = java.util.AbstractMap
object = {}
spy = com.myproject.bean.MyBeanTest$TestClass
<dump>
java.lang.Exception: Stack trace
	at java.base/java.lang.Thread.dumpStack(Thread.java:1388)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:272)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.util.AbstractMap.<init>(AbstractMap.java)
	at java.base/java.util.concurrent.ConcurrentHashMap.<init>(ConcurrentHashMap.java:828)
	at java.base/java.lang.ClassLoader.<init>(ClassLoader.java:333)
	at java.base/java.lang.ClassLoader.<init>(ClassLoader.java:457)
	at java.base/jdk.internal.reflect.DelegatingClassLoader.<init>(ClassDefiner.java:72)
	at java.base/jdk.internal.reflect.ClassDefiner$1.run(ClassDefiner.java:60)
	at java.base/jdk.internal.reflect.ClassDefiner$1.run(ClassDefiner.java:58)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/jdk.internal.reflect.ClassDefiner.defineClass(ClassDefiner.java:57)
	at java.base/jdk.internal.reflect.MethodAccessorGenerator$1.run(MethodAccessorGenerator.java:400)
	at java.base/jdk.internal.reflect.MethodAccessorGenerator$1.run(MethodAccessorGenerator.java:394)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/jdk.internal.reflect.MethodAccessorGenerator.generate(MethodAccessorGenerator.java:393)
	at java.base/jdk.internal.reflect.MethodAccessorGenerator.generateConstructor(MethodAccessorGenerator.java:92)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:55)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at org.mockito.internal.util.reflection.ReflectionMemberAccessor.lambda$newInstance$0(ReflectionMemberAccessor.java:26)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$newInstance$4(InlineByteBuddyMockMaker.java:631)
	at org.mockito.internal.util.reflection.ReflectionMemberAccessor.newInstance(ReflectionMemberAccessor.java:26)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.newInstance(InlineByteBuddyMockMaker.java:626)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.doCreateMock(InlineByteBuddyMockMaker.java:373)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createSpy(InlineByteBuddyMockMaker.java:349)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:44)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:61)
	at org.mockito.Mockito.spy(Mockito.java:2033)
	at com.myproject.bean.MyBeanTest.test1(MyBeanTest.java:274)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:686)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)
	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:212)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:208)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:137)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:71)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220)
	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188)
	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:150)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:124)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:384)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:345)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:126)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:418)
</dump>
```

2. Logs using [`Thread.dumpStack()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#dumpStack()) **before** `isSuspended.set(true);`

```
type = java.util.AbstractMap
object = {}
spy = com.myproject.library.LibraryBean1
<dump>
type = java.lang.Throwable
object = java.lang.Exception
spy = com.myproject.library.LibraryBean1
<dump>
type = java.lang.Throwable
object = java.lang.Exception
spy = com.myproject.library.LibraryBean1

[...]

error while dumping stack: Unexpected spy for java.lang.Throwable on instance of java.lang.Exception
</dump>
error while dumping stack: Unexpected spy for java.lang.Throwable on instance of java.lang.Exception
</dump>
error while dumping stack: Unexpected spy for java.lang.Throwable on instance of java.lang.Exception
</dump>
error while dumping stack: Unexpected spy for java.lang.Throwable on instance of java.lang.Exception
</dump>
error while dumping stack: Unexpected spy for java.lang.Throwable on instance of java.lang.Exception
</dump>
``` =||= I thought it would be related to class loading.

I am curious however how you end uo with the reflection member accessor. It should be the instrumentation based one. Are you using the latest build?  =||= > Are you using the latest build?

I pulled the *constructor-dispatch* branch this morning before giving you the `Thread.dumpStack()` output. I just switched to branch *release/3.x* (3.5.6, next 3.5.7), applied my logs and run my tests again : same results.
 =||= Strange, I'll investigate. Could you make sure that you don't have a stale version? You are using *mockito-inline* or are you configuring the mock maker manually?  =||= > Could you make sure that you don't have a stale version?

I already checked using `mvn dependency:tree` but it says I'm using 3.5.7 (I'm using the *release/3.x* branch).
I will try to copy my project, use v3.5.2 and remove code step by step until I can reproduce the bug with only a few files so I can provide you a reproducible example.

----

> You are using mockito-inline or are you configuring the mock maker manually?

I'm using mockito-core :

```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>3.5.7</version>
    <scope>test</scope>
</dependency>
```

And I do not configure anything manually. I just have the `src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker` config file which contains
```
mock-maker-inline
```
 =||= That explains it. You can drop the config and just use the inline artifact which defines the nock maker for you. The member accessor is another plugin which requires manual activation using a similar file if you don't use the other artifact.  =||= > You can drop the config and just use the inline artifact which defines the nock maker for you.

I used mockito-inline v3.5.6, all tests passed but 3. The 3 that fails are new ones (not the ones who failed before) and none of them use Mockito (but all of them are on enums, apparently `MyEnum.values()` returns an array with null values inside). But they're executed correctly when running them manually, class by class ([like I did before](https://github.com/mockito/mockito/issues/2011#issuecomment-677610343))

Do you know how can I generate the inline JAR from the sources ? I can't provide you the logs I added in the source with mockito-inline because the JAR is not generated by `./gradlew -x check clean build`. =||= @raphw Thank you for the fix and the time spent on this. It works great ! =||= ",0
2024,2007,Android instrumentation test packaging fails for mockito-android 3.5.0 with minSdk < 26,"We've upgraded from `mockito-android:3.4.6` to `mockito-android:3.5.0`. I'm attempting to package up my instrumented tests by running the `assembleAndroidTest` gradle task. The task fails with the following errors:
```
/Users/<me>/.gradle/caches/transforms-2/files-2.1/fb7959dc5bfc8ebb26ad0660efa1929e/jetified-mockito-core-3.5.0.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
/Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
/Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
```

and with root cause:
```
com.android.tools.r8.utils.b: Error: /Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar:org/objenesis/instantiator/util/DefineClassHelper$Java8.class, java.lang.Class org.objenesis.instantiator.util.DefineClassHelper$Java8.defineClass(java.lang.String, byte[], int, int, java.lang.Class, java.lang.ClassLoader, java.security.ProtectionDomain), MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.utils.y0.a(:21)
        at com.android.tools.r8.utils.O.a(:51)
        ... 35 more
```
","Should be fixed with #2006 =||= We still have issues with 3.5.2. We are unable to update to new version and use `assembleAndroidTest` task.

```
/usr/local/gradle/caches/transforms-2/files-2.1/225c46d0e9f10ff5ef3f4d9a009c4924/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)

com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)

``` =||= @kozaxinan Are you certain that you are using 3.5.2 and aren't accidentally using an older version of either Mockito or ByteBuddy? We have had confirmations from other users that 3.5.2 fixed the issue you are seeing, so it would be good to double check that you have the correct version. =||= @TimvdLippe I confirm the issue still occurs also in our project with the exact same error.
- mockito-core 3.5.2
- mockito-android 3.5.2
- mockito-inline 3.5.2
- objenesis 3.1
- bytebuddy 1.10.13 =||= Looks like the issue was introduced in objenesis 3.x (upgraded in https://github.com/mockito/mockito/pull/1998)
Forcing objenesis to 2.6 makes `assembleAndroidTest` task succeed. =||= Aha, thanks for letting us know. I will create a revert. =||= Still getting this error with 3.5.7 =||= Here's the stacktrace that I get when using 3.5.7:

```
/Users/azizbekian/.gradle/caches/transforms-2/files-2.1/63e24576c0e1d1e5b675c1c61e4e5727/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
Stack trace:
com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.errors.a.a(:7)
        at com.android.tools.r8.ir.conversion.O.b(:58)
        at com.android.tools.r8.ir.conversion.O.a(:104)
        at com.android.tools.r8.ir.conversion.O.a(:53)
        at com.android.tools.r8.graph.C.b(:43)
        at com.android.tools.r8.ir.conversion.O.b(:35)
        at com.android.tools.r8.utils.U0.a(:10)
        at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:125)
        at com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:69)
        at com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:78)
        at com.google.common.util.concurrent.MoreExecutors$DirectExecutorService.execute(MoreExecutors.java:322)
        at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134)
        at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:66)
        at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:36)
        at com.android.tools.r8.utils.U0.a(:3)
        at com.android.tools.r8.ir.conversion.O.a(:10)
        at com.android.tools.r8.D8.d(:29)
        at com.android.tools.r8.D8.b(:1)
        at com.android.tools.r8.utils.W.a(:30)
        at com.android.tools.r8.D8.run(:11)
        at com.android.builder.dexing.D8DexArchiveBuilder.convert(D8DexArchiveBuilder.java:116)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.process(DexingTransform.kt:296)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.processNonIncrementally(DexingTransform.kt:243)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.doTransform(DexingTransform.kt:153)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.access$doTransform(DexingTransform.kt:69)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform$transform$1.invoke(DexingTransform.kt:104)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform$transform$1.invoke(DexingTransform.kt:69)
        at com.android.build.gradle.internal.tasks.BlocksUtilsKt.recordArtifactTransformSpan(BlocksUtils.kt:33)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.transform(DexingTransform.kt:100)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformer.transform(DefaultTransformer.java:193)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$TransformerExecution.execute(DefaultTransformerInvocationFactory.java:332)
        at org.gradle.internal.execution.steps.ExecuteStep.lambda$execute$0(ExecuteStep.java:32)
        at java.util.Optional.map(Optional.java:215)
        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:32)
        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:26)
        at org.gradle.internal.execution.steps.CleanupOutputsStep.execute(CleanupOutputsStep.java:67)
        at org.gradle.internal.execution.steps.CleanupOutputsStep.execute(CleanupOutputsStep.java:36)
        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:49)
        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:34)
        at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:43)
        at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:73)
        at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:54)
        at org.gradle.internal.execution.steps.CatchExceptionStep.execute(CatchExceptionStep.java:34)
        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:44)
        at org.gradle.internal.execution.steps.SnapshotOutputsStep.execute(SnapshotOutputsStep.java:54)
        at org.gradle.internal.execution.steps.SnapshotOutputsStep.execute(SnapshotOutputsStep.java:38)
        at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:49)
        at org.gradle.internal.execution.steps.CacheStep.executeWithoutCache(CacheStep.java:159)
        at org.gradle.internal.execution.steps.CacheStep.execute(CacheStep.java:72)
        at org.gradle.internal.execution.steps.CacheStep.execute(CacheStep.java:43)
        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:44)
        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:33)
        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:38)
        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:24)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:92)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$0(SkipUpToDateStep.java:85)
        at java.util.Optional.map(Optional.java:215)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:39)
        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:76)
        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:37)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:36)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:26)
        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:94)
        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:49)
        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:79)
        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:53)
        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:74)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.lambda$execute$2(SkipEmptyWorkStep.java:78)
        at java.util.Optional.orElseGet(Optional.java:267)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:78)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:34)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:39)
        at org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:40)
        at org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:28)
        at org.gradle.internal.execution.impl.DefaultWorkExecutor.execute(DefaultWorkExecutor.java:33)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.lambda$call$2(DefaultTransformerInvocationFactory.java:200)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.fireTransformListeners(DefaultTransformerInvocationFactory.java:269)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.access$300(DefaultTransformerInvocationFactory.java:79)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.call(DefaultTransformerInvocationFactory.java:178)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.call(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:409)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:399)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:94)
        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.call(DelegatingBuildOperationExecutor.java:36)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.lambda$doTransform$0(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.api.internal.artifacts.transform.ImmutableTransformationWorkspaceProvider.lambda$withWorkspace$0(ImmutableTransformationWorkspaceProvider.java:81)
        at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.withFileLock(LockOnDemandCrossProcessCacheAccess.java:90)
        at org.gradle.cache.internal.DefaultCacheAccess.withFileLock(DefaultCacheAccess.java:191)
        at org.gradle.cache.internal.DefaultPersistentDirectoryStore.withFileLock(DefaultPersistentDirectoryStore.java:177)
        at org.gradle.cache.internal.DefaultCacheFactory$ReferenceTrackingCache.withFileLock(DefaultCacheFactory.java:201)
        at org.gradle.api.internal.artifacts.transform.ImmutableTransformationWorkspaceProvider.withWorkspace(ImmutableTransformationWorkspaceProvider.java:76)
        at org.gradle.api.internal.artifacts.transform.AbstractCachingTransformationWorkspaceProvider.lambda$withWorkspace$0(AbstractCachingTransformationWorkspaceProvider.java:55)
        at com.google.common.cache.LocalCache$LocalManualCache$1.load(LocalCache.java:4718)
        at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3445)
        at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2194)
        at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2153)
        at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2043)
        at com.google.common.cache.LocalCache.get(LocalCache.java:3851)
        at com.google.common.cache.LocalCache$LocalManualCache.get(LocalCache.java:4713)
        at org.gradle.api.internal.artifacts.transform.AbstractCachingTransformationWorkspaceProvider.withWorkspace(AbstractCachingTransformationWorkspaceProvider.java:55)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.doTransform(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.access$000(DefaultTransformerInvocationFactory.java:79)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$1.invoke(DefaultTransformerInvocationFactory.java:141)
        at org.gradle.api.internal.artifacts.transform.CacheableInvocation$1.invoke(CacheableInvocation.java:58)
        at org.gradle.api.internal.artifacts.transform.TransformationOperation.run(TransformationOperation.java:39)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:395)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:387)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.access$1500(DefaultBuildOperationExecutor.java:49)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$ParentPreservingQueueWorker.execute(DefaultBuildOperationExecutor.java:437)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runOperation(DefaultBuildOperationQueue.java:231)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.access$600(DefaultBuildOperationQueue.java:173)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.create(DefaultBuildOperationQueue.java:210)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.create(DefaultBuildOperationQueue.java:204)
        at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:180)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runBatch(DefaultBuildOperationQueue.java:204)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.run(DefaultBuildOperationQueue.java:178)
        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
        at java.lang.Thread.run(Thread.java:748)
        Suppressed: java.util.concurrent.ExecutionException: com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
                at com.google.common.util.concurrent.AbstractFuture.getDoneValue(AbstractFuture.java:552)
                at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:513)
                at com.google.common.util.concurrent.FluentFuture$TrustedFuture.get(FluentFuture.java:86)
                at com.android.tools.r8.utils.U0.a(:14)
                at com.android.tools.r8.utils.U0.a(:9)
                ... 114 more
        [CIRCULAR REFERENCE:com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)]
Caused by: com.android.tools.r8.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.ir.conversion.N.a(:633)
        at com.android.tools.r8.ir.conversion.N.a(:674)
        at com.android.tools.r8.r.n.A.a(:236)
        at com.android.tools.r8.ir.conversion.o.a(:153)
        at com.android.tools.r8.ir.conversion.N.a(:133)
        at com.android.tools.r8.graph.l.a(:93)
        at com.android.tools.r8.graph.l.a(:71)
        at com.android.tools.r8.graph.l.buildIR(:1)
        at com.android.tools.r8.graph.C0.buildIR(:1)
        at com.android.tools.r8.graph.T.a(:152)
        at com.android.tools.r8.ir.conversion.O.a(:412)
        at com.android.tools.r8.ir.conversion.O.b(:53)
        ... 127 more


``` =||= I updated all mockito packages to 3.5.9 but unfortunately I do get still the same error as above. =||= This still seems to fail for me:
```
Execution failed for task ':mergeDexGplayDebugAndroidTest'.
> Could not resolve all files for configuration ':gplayDebugAndroidTestRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=18, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /home/tobi/.gradle/caches/transforms-2/files-2.1/66df4f0b18795a51947f8881933478f9/jetified-objenesis-3.1.jar.
         > Error while dexing.

```

I removed     
`androidTestImplementation ""org.mockito:mockito-core:$mockitoVersion""`
and changed:
```
testImplementation (""com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0"") {
        exclude group: ""org.mockito"", module: ""mockito-core""
    }
```

If you want to test it: https://github.com/nextcloud/android/pull/6768
 =||= This is still happening in 3.5.10:

- https://pastebin.ubuntu.com/p/rKzc6MVhBf/
- https://github.com/relaycorp/relaynet-gateway-android/pull/120 =||= @gnarea You are depending on Objenesis 3, which is incompatible with Android <26. Please downgrade to Objenesis 2 and depend on `mockito-android`. For more info, see the context in #2024 =||= @TimvdLippe looks like `mockito-core` still has objenesis 3.1 as a dependency. 
```
+--- project :my-project
|    \--- org.mockito:mockito-core:3.5.10
|         +--- net.bytebuddy:byte-buddy:1.10.13
|         +--- net.bytebuddy:byte-buddy-agent:1.10.13
|         \--- org.objenesis:objenesis:3.1

+--- org.mockito:mockito-android:3.5.10
|    +--- org.mockito:mockito-core:3.5.10 (*)
|    +--- net.bytebuddy:byte-buddy-android:1.10.13
|    |    +--- net.bytebuddy:byte-buddy:1.10.13
|    |    \--- com.jakewharton.android.repackaged:dalvik-dx:9.0.0_r3
|    \--- org.objenesis:objenesis:[2.6, 3.0) -> 3.1
``` =||= @francescocervone That is correct. For non-Android projects, they can use Objenesis 3 just fine. =||= @TimvdLippe it's pretty common for Android projects having some pure JVM Gradle modules, not depending on Android. In that case we must depend on `mockito-core` which depends on Objenesis 3. What do you suggest in that case?

Anyway, even if we don't depend directly on `mockito-core`, we get the same error on `mockito-core` (I suppose that's because `mockito-android` depends on `mockito-core`).
```
> Transform artifact mockito-core-3.5.10.jar (org.mockito:mockito-core:3.5.10) with DexingNoClasspathTransform
D8: Private interface methods are only supported starting with Android N (--min-api 24): java.lang.Object org.mockito.plugins.MemberAccessor.lambda$newInstance$0(java.lang.reflect.Constructor, java.lang.Object[])
Stack trace:
com.android.tools.r8.a: Private interface methods are only supported starting with Android N (--min-api 24): java.lang.Object org.mockito.plugins.MemberAccessor.lambda$newInstance$0(java.lang.reflect.Constructor, java.lang.Object[])

[ stacktrace ]

* What went wrong:
Execution failed for task ':app:mergeExtDexDebugAndroidTest'.
> Could not resolve all files for configuration ':app:debugAndroidTestRuntimeClasspath'.
   > Failed to transform mockito-core-3.5.10.jar (org.mockito:mockito-core:3.5.10) to match attributes {artifactType=android-dex, dexing-enable-desugaring=false, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingNoClasspathTransform: /Users/me/.gradle/caches/transforms-2/files-2.1/9ebcc121d44dc6f808610b5ee83414a2/jetified-mockito-core-3.5.10.jar.
         > Error while dexing.
```

Do you need an example project? =||= @francescocervone That last stacktrace is yet another issue that is new to me, as it complains about private interface methods. That seems to be unrelated to Objenesis. The code in question is https://github.com/mockito/mockito/blob/b6ae6cf12b93ef9445e524224375aab1eb76129d/src/main/java/org/mockito/plugins/MemberAccessor.java#L24-L28

I guess older versions of Android do not support default interface methods. I am not sure what to do here, as that seems to be a problem where Android did not support all features of Java 8. Since Mockito 3 targets Java 8, that would be incompatible with older versions of Android.

Can you use Mockito 2 solely for tests running on older versions of Android? =||= > Can you use Mockito 2 solely for tests running on older versions of Android?

No, because this is a compilation error which depends on the minimum supported Android version. Almost every Android project should use Mockito 2 until android 26 will be the ""generally accepted"" minimum sdk supported version (probably in at least 5 years 😄). =||= @francescocervone What I mean is that you have 2 test suites. 1 testsuite for all tests >= 26 and 1 testsuite for all tests <26. For the testsuite >= 26 you can use Mockito 3 + Objenesis 3, as they support Java 8+. For the testsuite <26 you can use Mockito 2 + Objenesis 2, as they support Java 6+. By splitting up the test suites, you can use modern Mockito for modern Android and older Mockito for older Android. That should work right? =||= Also to reiterate, we have introduced Animal Sniffer to ensure we don't break Android again. We set the target to 24 per https://github.com/mockito/mockito/pull/2006/files#diff-c197962302397baf3a4cc36463dce5eaR104 which seemed the most reasonable cut-off for Java 8 support that Mockito 3 relies on. Therefore, rather than having a cut-off at 26, we would be talking about a cut-off at 24. I am not sure when the Android community moves past that cut-off? =||= @TimvdLippe as far as I know you cannot have 2 test suites in the same android project compiling against 2 Android versions. The minimum Android supported version is a property (`minSdkVersion`) defined in the android project's `build.gradle` file through the Android Gradle Plugin.

> I am not sure when the Android community moves past that cut-off? 

Maybe [this chart](https://gs.statcounter.com/android-version-market-share/mobile-tablet/worldwide) can be helpful? In my case, we currently support Android 21 as min SDK. =||= We could try to update Animal Sniffer to level 21 and see what the effect is. If we can make `mockito-core` compatible with that, without introducing breaking changes for the wider Java ecosystem, then I am open to that. However, when @raphw tried that previously, it turned out that a large portion of `mockito-core` was *already* incompatible. This led us to believe that we would have already broken our users and (since we hadn't received complaints before), 24 felt like the best option.

3.5.0 was a big release and a lot of work went into it to support modern Java, which is probably the reason we have hit numerous issues with it. I wonder how many changes in 3.5.0 affect compatibility compared to previous Mockito releases. Could you clone Mockito and try to work out what changes are required to make Mockito compatible with 21? Then we can assess breakages and go from there. =||= Reopening this issue, as I think it is clear by now we are going to need support from developers working in the Android ecosystem on figuring out how to resolve these issues. =||= FYI: at least in my case, the workaround suggested above worked: https://github.com/relaycorp/relaynet-gateway-android/pull/120. But that project doesn't have JVM modules (they're all external deps). We're also supporting API 21+. =||= @TimvdLippe 
>Could you clone Mockito and try to work out what changes are required to make Mockito compatible with 21?

I will. =||= If I remember correctly, types like predicate and function are not available which are part of our public API. This can be fixed but requires breaking public API.  =||= @gnarea , that didn't work for my setup, minSdk = 21:

```
* What went wrong:
Execution failed for task ':app:mergeExtDexDevDebugAndroidTest'.
> Could not resolve all files for configuration ':app:devDebugAndroidTestRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /Users/azizbekian/.gradle/caches/transforms-2/files-2.1/adb8b362b2ccf145263475708478d34b/jetified-objenesis-3.1.jar.
         > Error while dexing.
``` =||= @raphw If I remember correctly, we are already shipping `Optional` and `Function` in our public API prior to 3.5.0. Since Android tests were passing with 3.4.0, I don't think including these symbols in our public API is problematic. Therefore, I don't think we should be changing these types in our API. (This is also what confuses me the most, as to why some parts work and why other parts don't work, even though Animal Sniffer is claiming nothing should in theory work) =||= I'm not an Android expert. `DefineClassHelper` is only used by specific instantiators that are not used in Android. So ideally this class can be excluded from the compilation by Dex it should solve the problem. =||= @TimvdLippe I played a little bit with mockito and the issue I mentioned [in this comment](https://github.com/mockito/mockito/issues/2007#issuecomment-688321579) is solved by adding in the android project's build.gradle:
```gradle
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
```
Android Gradle Plugin 3.0 and higher [supports default interface methods](https://developer.android.com/studio/releases/gradle-plugin#j8-library-desugaring).

---

The objenesis 3.x issue included in `mockito-core` mentioned [here](https://github.com/mockito/mockito/issues/2007#issuecomment-688252464) instead can be avoided by excluding objenesis from `mockito-core` or any library/project depending on `mockito-core`:
```gradle
dependencies {
    androidTestImplementation 'org.mockito:mockito-android:3.5.10'
    androidTestImplementation('org.mockito:mockito-core:3.5.10') {
        exclude group: 'org.objenesis'
    }
    androidTestImplementation(project(':depending-on-mockito-core')) {
        exclude group: 'org.objenesis'
    }
}
```
This workaround is a little bit inconvenient IMHO, but solves the issue. =||= @francescocervone Thanks for the investigation. With regards to your first solution, can we automatically apply that to `mockito-android` or do users of that artifact need to specify it in their `build.gradle`? For the latter, if you solely depend on `mockito-android` you should be good to go. If that is inconvenient, maybe it can be solved in Objenesis 3 instead (not sure if that is possible). =||= @TimvdLippe 
> can we automatically apply that to mockito-android or do users of that artifact need to specify it in their build.gradle?

Users need to specify it in their `build.gradle`.

---

> if you solely depend on mockito-android you should be good to go

True, but I think this ""solution"" is pretty weak. For example, if the project declares [`mockito-kotlin`](https://github.com/nhaarman/mockito-kotlin) dependency, objenesis must be excluded since `mockito-kotlin` depends on `mockito-core`. In general, if the android project depends on some module/project/library depending on `mockito-core`, the workaround must be applied. =||= Again, I'm not sure but can't you just exclude `DefineClassHelper`? That will solve the problem and no need to remove Objenesis. I don't think I can solve it from the Objenesis side. If I can please tell me why? Deploy an objenesis-android excluding these classes will just make everything really messy. =||= @henri-tremblay is there a way to exclude a class from the compilation of a library? How can we exclude `DefineClassHelper`?
Even if we were able to exclude that class: Objenesis is built with Java 8 and it's likely to introduce similar issues in future. This circle will end when one of these classes using some unsupported Java 8 feature, will be part of the Objenesis core and we will not be able to just ""exclude"" it. =||= @TimvdLippe there is a handier workaround for objenesis 3.x, without excluding it from `mockito-core`.
In root `build.gradle` we can add:
```gradle
allprojects {
    configurations.all {
        resolutionStrategy.force 'org.objenesis:objenesis:2.6'
    }
}
``` =||= @francescocervone I don't know. That's why I was saying ""Not an Android expert"" :-) Let me ask around. It's sad to downgrade to Android 2. The other solution would be to split objenesis in 2. One with the core instantiators and one with the exotic ones. Can you hack the objenesis jar to remote this class and just compile with the new jar to tell me if it works? =||= Ok. I had some feedback from @mhausherr. The error is in R8. So we could ignore like this in `proguard-rules.pro`:
```
-assumenosideeffects class org.objenesis.instanciator.util.DefineClassHelper {
    *;
}
``` =||= @henri-tremblay 🤔 It cannot be R8. R8 obfuscates, optimizes and shrinks the code in release builds. It doesn't run in test unless you don't explicitly enable it also for debug builds.
More info here -> https://developer.android.com/studio/build/shrink-code =||= @jakewharton (if I remember correctly, you know a lot more about minification, R8 and problems like this. If that's not the case, please let me know and feel free to ignore this message)

Hey Jake,

Please see the above messages regarding problems with Mockito transitively depending on Objenesis 3 which broke Android compatibility. However, Objenesis compilation broke, despite the class in question not being used in Android tests. As such, the class could be removed with the proguard configuration @henri-tremblay (maintainer of Objenesis) posted.

@francescocervone thinks that is not the appropriate solution, as R8 should not be performing these kind of cleanups.

Sadly I am lacking the knowledge to figure out what is the appropriate solution here and how we can move forward and I had hoped you would be able to help us figuring out.

Thanks in advance for your time and once again, if you prefer not to be involved, feel free to say so and I will try to find another domain expert 😄  =||= @TimvdLippe I didn't say that R8 should not be performing these kind of cleanups. I said that R8 is not involved at all, therefore the R8 rule suggested by @henri-tremblay is not a valid workaround.  =||= @TimvdLippe I created #2053 to fix this issue. With range usage in `strictly` tag, gradle fails to force dependency. I verified with our project. For androidTest, If we just use moctiko-android and exclude mockito-core from mockito-kotlin (or any dependency that has  mockito-core), there shouldnt be any issue. 
This fix still not great but until objenesis supports android sdk < 26, it should work. =||= For anyone who is looking to contribute, please check out the upstream issue at https://github.com/easymock/objenesis/issues/79 =||= I am going to close this issue in favor of https://github.com/easymock/objenesis/issues/79 =||= I have pushed the changes moving some instantiators in a new project. Could you please check if it works? =||= Release 3.2 was done. It should work now. =||= Using version 3.8.0:

```
Execution failed for task ':App:mergeExtDexDebug'.
> Could not resolve all files for configuration ':App:debugRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-transform=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /home/circleci/.gradle/caches/modules-2/files-2.1/org.objenesis/objenesis/3.1/48f12deaae83a8dfc3775d830c9fd60ea59bbbca/objenesis-3.1.jar.
         > Error while dexing.
``` =||= Release 3.2 of _Objenesis_ was done, Mockito still needs to have its dependency updated to 3.2. 

This can be worked around by declaring the Objenesis dependency yourself like `implementation 'org.objenesis:objenesis:3.2` and rely on gradle's dependency resolution to go with the 3.2 version instead of the 3.1 currently included with Mockito =||= @PaulKlauser Do you mind sending us a PR which updates the version? =||= https://github.com/mockito/mockito/pull/2249 =||= Could you consider publishing this to Maven as well? =||= Mockito 3.9.0 should be published to Maven Central: https://github.com/mockito/mockito/runs/2288011033?check_suite_focus=true =||= Thanks! It's still at 3.8.0 on [mvnrepository](https://mvnrepository.com/artifact/org.mockito/mockito-core) and [maven](https://search.maven.org/search?q=a:mockito-core) but I suppose it can take several hours for the change to propagate. =||= Yes these systems take a while to obtain the new information. 3.9.0 is published here: https://repo1.maven.org/maven2/org/mockito/mockito-core/3.9.0/ =||= Just mentioning that I had [this exact crash](https://github.com/mockito/mockito/issues/2007#issuecomment-686925445) and upgrading to 3.9.0 from 3.8.0 fixed it.

 However, it might be worth mentioning that any Android project that is just using `JCenter` as a repository will not return the right information for latest version. Android projects need to begin adding `mavenCentral()` as a repository, which previously was unnecessary because JCenter mirrored Maven Central. That's changing and it's because of this that my particular project didn't recognize the 3.9.0 update.
```
repositories {
    google()
    mavenCentral()  <-- many projects need to add this, explicitly
    jcenter()
    maven { url 'https://jitpack.io' }
}
``` =||= https://blog.gradle.org/jcenter-shutdown =||= ",0
2034,1802,"Exception ""The mock object was garbage collected.""","We received the following exception while running tests using Mockito, either version 3.0.0 or 3.1.0, and I'm filing this bug as requested:
```
Exception in thread ""main"" java.lang.IllegalStateException: The mock object was garbage collected. This should not happen in normal circumstances when using public API. Typically, the test class keeps strong reference to the mock object and it prevents getting the mock collected. Mockito internally needs to keep weak references to mock objects to avoid memory leaks for certain types of MockMaker implementations. If you see this exception using Mockito public API, please file a bug. For more information see issue #1313.
	at org.mockito.internal.invocation.mockref.MockWeakReference.get(MockWeakReference.java:32)
	at org.mockito.internal.invocation.InterceptedInvocation.getMock(InterceptedInvocation.java:106)
	at org.mockito.internal.stubbing.InvocationContainerImpl.invokedMock(InvocationContainerImpl.java:157)
	at org.mockito.internal.stubbing.OngoingStubbingImpl.<init>(OngoingStubbingImpl.java:22)
	at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:83)
	at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
	at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:35)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:61)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:49)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:126)
	at org.mockito.codegen.Runnable$MockitoMock$1840149894.run(Unknown Source)
	at MockitoTest.runTest(MockitoTest.java:13)
	at MockitoTest.main(MockitoTest.java:6)
```

I've reduced the problem to the following test program:
```java
import org.mockito.*;

public class MockitoTest {

  public static void main(String[] args) {
    while (true) runTest();
  }

  private static void runTest() {
    Node list = createList();
    while (list != null) {
      Node next = list.next;
      list.object.run();
      list = next;
    }
  }

  private static Node createList() {
    Node node = null;
    for (int i = 0; i < 1000; ++i) {
      Node next = new Node();
      next.next = node;
      node = next;
    }
    return node;
  }

  private static class Node {
    final Runnable object = Mockito.mock(Runnable.class);
    Node next;
  }
}
```

Whether the problem occurs depends on what exactly the JVM does with the code. It looks like the mock object can be garbage collected between the call to the mocked method and Mockito trying to use the weak reference to it. I'm using AdoptOpenJDK 11.0.3.7-hotspot on Windows. My test program more often than not reproduces the exception within a few seconds, but occasionally it can run forever without failing.","I tried bisecting. This issue happens after this PR.
https://github.com/mockito/mockito/pull/1544 =||= That makes sence, if the `BaseStubbing` instance wraps the mocks and the latter instance is referenced via a weak reference then that latter instance can be GC-ed even if the actual mock instance is still in use.

Thanks for the test, since we both have a test for the ""too weak"" and the ""not sufficiently weak"" mock applications, I hope that I can come up with a scenario that satisfies both conditions. =||= This issue just came up as we tried to upgrade from 3.3.3 to either 3.4.6 or 3.5.9. A large chunk of our unit tests became flaky as a result. Holding onto a strong reference of `MockitoAnnotations.openMocks()` does not seem to have any impact. The only thing that seemed to rectify the issue was creating and retaining a `MockitoSession` like via `MockitoJUnit.rule()` (Using the `MockspressoJUnitRunner` shows the same flakiness as no session is initialized in it). 

Considering that `Mockito.mockitoSession()` is labeled as optional and `@Incubating`, and considering that the junit rule & TestRunner have always been optional historically, this seems like a legitimate bug that will block mockito upgrades in many large codebases (especially those relying on mockito-kotlin's inline `mock()` method). =||= Yes, this needs to be addressed. The alternatives right now are unfortunately a leak or premature discarding. I think a leak is the better alternative, though since you can explicitly clear Mockito's mock store.

The updates within 3 should not have an impact but can have one as a result of changed GC cycles.

I will try to solve this one the next time I find some free time to work on Mockito. =||= Awesome! Thanks so much for addressing this! =||= ",0
2042,198,Add matchers for scala value classes containing primitives ,"The complete details are here
https://groups.google.com/d/msg/mockito/m_Ptz8eVH58/wS2czEAaD-oJ","Hi,

Actually that will probably never happen as these classes are in the scala library, which we cannot depend upon. If this lib is not there then the class won't even load. Instead I'd rather suggest that it should be mockito sugar to declare them.
 =||= I think that there is possibility. I know that NPE in any[SomeValueClass] happens because of trying to assign null to value that looks like object but is primitive.  Maybe there is possibility to add some reflection checks in runtime. Instead of null just try to assign default primitive value as in HandyReturnValues.java.
The same could be applied to other matchers as Matcher.equal . There could be introduced some reflection check if given class has method .equals() in runtime. If not the comparison should be done as for primitives.
Thats why the hack anyObject().asInstanceOf[SomeValueClassWithStringValue] works. The String is simply not a primitive but has equals.
 =||= I do not think we will put scala specific inside mockito, as we just don't add groovy / android / JEE specific stuffs. Because we'd like to keep the working set as simple and focused as possible. Also there's the reason that we are not able to maintain stuff that we don't use in the team in our daily job, this is especially true for scala / groovy and android.

What you are asking certainly could be implemented in the mockito sugar library, by changing the default answer of a mock at creation time (if not overridden by a user).
As for matchers these would probably have to be handled by mockito sugar as well. 

I just google and found that it is part of scalatest and that their project is host on GH too, you should report to them IMHO : https://github.com/scalatest/scalatest
 =||= I understand that, thank you.
 =||= @ppiotrow Thx to you for the interest in mockito ;)
 =||= ",0
2046,2040,Mockito.spy(Activity).getBaseContext() returns null on Robolectric 4.4 and Java8,"### Description
Since robolectric 4.4, Mockito.spy(Activity).getBaseContext() returns null

### Steps to Reproduce
```
$ git clone -b mockito_spy_robolectric_4_4 https://github.com/ganadist/VersionCodeDemo demo
$ cd demo

// switch to robolectric 4.3.1
$ git checkout HEAD~1
$ ./gradlew :app:testDevelopDebugUnitTest
BUILD SUCCESSFUL in 14s
28 actionable tasks: 28 executed

// switch to robolectric 4.4
$ git checkout mockito_spy_robolectric_4_4
$ ./gradlew :app:testDevelopDebugUnitTest
> Task :app:testDevelopDebugUnitTest FAILED
FAILURE: Build failed with an exception.
* What went wrong:
Execution failed for task ':app:testDevelopDebugUnitTest'.
```
Failed unittest result : https://scans.gradle.com/s/wbmmbnzatcyai/tests/:app:testDevelopDebugUnitTest/com.example.myapplication.UnitTest1/test1#1

### Robolectric & Android Version
- Compile Sdk : 29
- Target Sdk : 28
- Robolectric : 4.4 
- Mockito : 3.5.10
- Jvm : OpenJDK 8

### Link to a public git repo demonstrating the problem:
https://github.com/ganadist/VersionCodeDemo/blob/mockito_spy_robolectric_4_4/app/src/test/java/com/example/myapplication/UnitTest1.java#L27-L38


This issue is copied from https://github.com/robolectric/robolectric/issues/5916","This seems to work with slightly older versions of mockito-inline, e.g. 3.4.2. I'll try a bisect and see what commit may have broken it. =||= I did a bisect and this seems to have started failing in 47ef05814784183cd5c1d297078e2ad7e31cce34, `Adds support for creating spies from within a mock instance's constructor, thus avoiding reflection on final fields.`

The workaround is to use mockito-inline < 3.5.0 I believe. =||= I just had a look and the problem is likely with Robolectric. Maybe they can have a look at the problem?
Mockito simply invokes the constructor chain and per class and within the constructor, it copies all values field by field. I am wondering if Robolectric does some explicit initialization where this approach now fails.

I am to foreign to both Android and Robolectric to really understand why this no longer works but it likely is related to the timing of the field copy.

Worst case, we need to offer a switch to create spies using reflection if required but if we can get a hint why this timing is a problem, we might be able to address this.
 =||= Thanks for the initial investigation @raphw, I am one of the Robolectric maintainers and can try investigating this. It's odd that on Java 11 this occasionally works (but it is flaky according to robolectric/robolectric#5916), but on Java 8 it seems to always fail. =||= I'd like to understand in what field value the two objects differ to produce this result. They should be identical unless some field is not discoverable.

If you could check what state difference is responsible, I can probably find out how it occurred.  =||= Out of curiosity is there some kind of helper/debug util in Mockito to dump an object to a String? In the meantime I'll try to just serialize it to a json-type format. =||= No, we can dump class files but you could likely use a serializer such as Jackson for this? =||= Weird, out of 269 fields, the only difference is a field called 'mBase'. On the spy object it is null.

```diff
132c132
< class android.content.ContextWrapper:mBase: android.app.ContextImpl@6d340ec8
---
> class android.content.ContextWrapper:mBase: null
269a270
>
```
MainActivity: https://gist.github.com/hoisie/5a7b93acc90a68917fc97de1c8364fc5
SpyActivity:  https://gist.github.com/hoisie/76bbd478520f0bd7ec6f89fe74c0e163

Is there a way to turn on debug logs during this field copy to see how 'mBase' is being copied?
 =||= This is the class that contains the 'mBase' field:
http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/content/ContextWrapper.java

FWIW, it's a long class hierarchy, `MainActivity > AppCompatActivity > FragmentActivity > ComponentActivity > Activity > ContextThemeWrapper > ContextWrapper > Context` =||= I just noticed [ContextThemeWrapper](http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/view/ContextThemeWrapper.java), which is the parent of ContextWrapper, calls the ContextWrapper(null) constructor, which could be setting mBase to null in ContextWrapper:
```
    public ContextThemeWrapper() {
        super(null);
    }
```


```
    public ContextWrapper(Context base) {
        mBase = base;
    }
```


Could this be causing `mBase` to be set to null? =||= How does one dump the class bytecode of the transient spy class created? I am curious what that looks like. =||= -Dnet.bytebuddy.dump=/some/folder =||= > Mockito simply invokes the constructor chain and per class and within the constructor, it copies all values field by field.

For some reason, when I do `spy(object)`, I am not seeing the constructors being invoked. What constructors does mockito invoke? Are there some new/hidden constructors being generated? =||= No, the constructors are prefixed and then the original chain is shortcut. Basically:

```java
public MyClass { MyClass() {
  // some code
} }
```

Is turned into:

```java
public MyClass { MyClass() {
  if (Mockito.isMockConstruction()) {
    // Mockito stuff, basically copy all fields of the spied at object
    return;
  }
  // some code
} }
```

As a consequence, you cannot set a constructor breakpoint. I had a look at the field state and for both *activity* and *mockActivity*, `ContextWrapper.mBase` is set to the same instance but only *activity* returns the field's value. =||= Out of curiosity how do you inject print statements to the field copy ByteBuddy logic? I wanted to add some print statements to verify that the 'mBase' before/after values are the same.

> I had a look at the field state and for both activity and mockActivity, ContextWrapper.mBase is set to the same instance but only activity returns the field's value.

How can you tell that? From what I see, it seems like 'mBase' is null for the spy activity:

![image](https://user-images.githubusercontent.com/125547/93143770-6f8c8580-f69d-11ea-9a48-29c7ac4fbc33.png)

Do you think it's initially non-null and then gets set to null? =||= You are right, I did not debug properly (IntelliJ refuses to run the sample project for me, I am back on the command line).

When I inspect the transformed `ContextWrapper` constructor, I do however see that the field is copied within it:

```
        69: getfield      #40                 // Field mBase:Landroid/content/Context;
        72: aload_0
        73: dup_x1
        74: pop
        75: putfield      #40                 // Field mBase:Landroid/content/Context;
```

When is the `mBase` field populated? Is this something done after object construction? =||= I created a special debug build (*println-constructor*, you can run it by using your local Maven repo and the *publishToMavenLocal* task of Mockito) which shows what is happening by printing all field assignments. It follows the pattern

```
<class name> // for each in hierarchy
<mock object>
<field name> // for each field
<spied field value>
<mock field value after setting>
```

This verifies that the field is actually set. It's very strange that the field is null again once it is used. Since this problem occurs only with Robolectric, there must be some mechanism where the value disappears.

I also added a statement for the spy when it is constructed in its entirety and the field seems to be set correctly:

```
    DEBUG ROBOLECTICS: android.app.ContextImpl@51ad277e - original android.app.ContextImpl@51ad277e
```

```
    class android.content.Context
    com.example.myapplication.MainActivity@6219c42b
    public java.lang.Object android.content.Context.__robo_data__
    null
    null
    class android.content.ContextWrapper
    com.example.myapplication.MainActivity@6219c42b
    public java.lang.Object android.content.ContextWrapper.__robo_data__
    null
    null
    android.content.Context android.content.ContextWrapper.mBase
    android.app.ContextImpl@51ad277e
    android.app.ContextImpl@51ad277e
    ....
``` =||= It's very strange, I optimized the example for output now and the fields seem to be set now that I changed the code:

```java
        Field field = Class.forName(""android.content.ContextWrapper"").getDeclaredField(""mBase"");
        field.setAccessible(true);

        MainActivity activity = Robolectric.buildActivity(MainActivity.class).setup().get();
        Object fieldBefore = field.get(activity);
        Object methodBefore = activity.getBaseContext();

        MainActivity spyActivity = Mockito.spy(activity);

        throw new AssertionError(""activity field: "" + field.get(activity)
                        + "" - mock activity field: "" + field.get(spyActivity)
                        + "" - activity getter: "" + activity.getBaseContext()
                        + "" - mock activity getter: "" + spyActivity.getBaseContext()
                        + "" - activity field before: "" + fieldBefore
                        + "" - activity getter before: "" + methodBefore
                        + "" - original: "" + activity
                        + "" - mock: "" + spyActivity);
```

My gutt fealing is that that's some sort of initialization issue for the original object that is triggered later then Mockito expects it. =||= Maybe I turned blind but simply running:

```java
MainActivity activity = Robolectric.buildActivity(MainActivity.class).setup().get();
MainActivity spyActivity = Mockito.spy(activity);
throw new AssertionError(activity.getBaseContext() + "" - "" + spyActivity.getBaseContext());
```

of the current *release/3.x* branch yields both fields being set correctly. Maybe this is something we already fixed in Mockito by accident? =||= Okay, I verified that Mockito creates the spy correctly in any case. But something happens to the object if passed through Robolectics's runner logic.

This test will function correctly:

```
@Test
public void test1() {
  MainActivity activity = Robolectric.buildActivity(MainActivity.class).setup().get();
  MainActivity mockActivity = spy(activity);
  assertEquals(""compare base context between activity and mockActivity"",
     activity.getBaseContext(),
     mockActivity.getBaseContext());
    }
```

While this test will yield yield an empty spy:

```java
private MainActivity activity;
private MainActivity mockActivity;

@Before
public void setup() {
   activity = Robolectric.buildActivity(MainActivity.class).setup().get();
   mockActivity = spy(activity);
}

@Test
public void test1() {
 assertEquals(""compare base context between activity and mockActivity"",
   activity.getBaseContext(),    
   mockActivity.getBaseContext());
}
```

How can that be? =||= Comparing the output of the println branch: if the mock is created in the `@Before` method, the `ContextWrapper` constructor is never invoked what seems dubious. Something must be done differently here. =||= I added a simpler test case to the Robolectric tree (currently `@Ignored`).

https://github.com/robolectric/robolectric/blob/master/integration_tests/mockito-experimental/src/test/java/org/robolectric/integrationtests/mockito/experimental/MockitoSpyTest.java

It is very strange, I've also seen situations where the test starts passing randomly, and I usually have to do a `clean` to get it to start failing again. It seems to fail more consistently when running through Gradle vs. running through intellij. This sometimes indicates a classpath issue.

Thanks for all your investigation and putting up that println branch, I'll try some print debugging as well. =||= After adding some additional debug statements, it seems like the mockito instrumentation for `ContextWrapper` constructor is skipped So `ContextThemeWrapper` tries to call the  `ContextWrapper` constructor, but it calls a non-instrumented one. 
Maybe the default empty constructor is private?

```
Start of constructor for 'class android.app.Activity'
Invoking super constructor 'class android.app.Activity' -> 'android/view/ContextThemeWrapper'
Start of constructor for 'class android.view.ContextThemeWrapper'
Invoking super constructor 'class android.view.ContextThemeWrapper' -> 'android/content/ContextWrapper'
Start of constructor for 'class android.content.Context'
Invoking super constructor 'class android.content.Context' -> 'java/lang/Object'
```
 =||= From looking at the bytecode, I see that ContextThemeWrapper calls ContextWrapper():

```
  public android.view.ContextThemeWrapper();
      ...
      31: invokespecial #317                // Method android/content/ContextWrapper.""<init>"":()V
```

However, in ContextWrapper, the no-arg constructor is not insrumented:

```
  public android.content.ContextWrapper();
    Code:
       0: aload_0
       1: invokespecial #816                // Method android/content/Context.""<init>"":()V
       4: aload_0
       5: invokevirtual #819                // Method $$robo$init:()V
       8: return
```

The one-arg ContextWrapper constructor is instrumented. though:
```
  public android.content.ContextWrapper(android.content.Context);
```

 =||= This seems to be a simpler repro of the issue (non-Robolectric):

** EDIT **

NVM, still looking into a non-Robolectric repro:
 =||= The issue seems to be that mockito is not instrumenting the no-arg `public android.content.ContextWrapper()` constructor, yet it is the one being selected to be called from the base class `ContextThemeWrapper`. 

The one-arg `public android.content.ContextWrapper(Context)` does get instrumented, but the no-arg one is preferred as the one to be called from the base class.

Do you know what might cause Mockito to skip over the no-arg `public android.content.ContextWrapper()` constructor? =||= Is that constructor added later by Robolectrics? Maybe there's some confusion around the creation order. It instruments the constructors in-flight but takes basis on the reflective model. You can set a breakpoint in the `ConstructorShortcut`'s `wrap` method.  Does the no-arg constructor ever arrive here? If not, walk a bit down the stack into Byte Buddy to see if Byte Buddy was able to resolve this constructor to begin with. =||= Yes, it does seem like Robolectric adds the no-arg constructor:
https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java#L141-L153

(why does it do this? I cannot say exactly, that code was added many years ago...)


 =||= It's certainly related to that. Byte Buddy uses the reflection API to process the members. How is it even possible that the reflection API is unaware of a constructor? A class cannot add members after its loaded, the JVM does not allow it. 

I assume this also explains why it makes a difference where the mock is created. Does Robolectrics transform classes from one class loader into another? I have a feeling this is somewhat related to parallel versions of the same class.  =||= As a workaround, Mockito could prefer non-synthetic constructors for the time being.  =||= Another possible solution: could Mockito only select super-constructors to call that are known to be instrumented? It should be possible to keep track of that. =||= `ConstructorShortcut.wrap` never hits the no-arg `ContextWrapper()` constructor. I am not sure how to check if ByteBuddy ever resolved it, but I do not believe it did. =||= > I have a feeling this is somewhat related to parallel versions of the same class

Yes, I believe this is happening. When an Android test is run, initially the Android SDK stubs are on the classpath, which contains a small subset of the real Android framework Jar that are all no-ops. Robolectric, during runtime, pulls in the real Android framework JARs and instruments the Android classes to use the real Android code (plus mixes in the shadows, which override the framework method implementations). =||= BTW I think preferring non-synthetic constructors seems like a fine workaround for now. I will attempt to stop adding the no-arg constructor to Android objects. I'm not sure to what extent it is still being used. =||= Actually, ByteBuddy does seem to find the no-arg ContextWrapper constructor, but `methodDescription` is null, so the `wrap` method does not get invoked:

![image](https://user-images.githubusercontent.com/125547/93295297-83b9ab00-f7a1-11ea-86e6-38abf11f3642.png)
 =||= Yes, it's in the changed class file but I wonder why the reflection API does not contain those constructors, that's why Byte Buddy cannot map them. I assume that the class is reloaded somehow into another class loader what then causes this mismatch.

The problem in short is that ContectWrapper. class.getDeclaredConstructors() does not add the added no argument constructor.  =||= Thanks for all your hard work @raphw! I am glad this is fixed. =||= Right back at you! Thanks for your patient debugging help!  =||= ",0
2047,1997,MockitoExtension cannot be used with JUnit 5 in OSGi integration tests,"The Mockito junit-jupiter JAR is missing OSGi bundle manifest entries so it cannot be used in OSGi integration tests.

We run some OSGi integration tests (using bnd) that have `@Mock`s so it would be easier if these mocks can be initialized by annotating classes with `@MockitoExtension` instead of using `MockitoAnnotations.openMocks(this)`, see for example this [FirmwareUpdateServiceTest](https://github.com/openhab/openhab-core/blob/43cb68c9d753faf3a88cfd19c4fc015c8289f880/itests/org.openhab.core.thing.tests/src/main/java/org/openhab/core/thing/internal/firmware/FirmwareUpdateServiceTest.java).

What may complicate adding the manifest entries is that `MockitoExtension` is [importing](https://github.com/mockito/mockito/blob/b87fad310bf59b94035028dc478089ded2a9198a/subprojects/junit-jupiter/src/main/java/org/mockito/junit/jupiter/MockitoExtension.java#L27-L29) internal classes which [aren't exported](https://github.com/mockito/mockito/blob/b87fad310bf59b94035028dc478089ded2a9198a/gradle/mockito-core/osgi.gradle#L19) by the mockito-core bundle. What may help is to make junit-jupiter a bundle fragment with mockito-core as host.","Fragments can be a bit of a pain.

@rotty3000 could offer some advice here - he did the OSGi metadata port for the JUnit 5 project itself. They had a similar problem, in that some of the bundles relied on internal packages of other bundles. I think that they ended up exporting the ""internal"" packages, but flagged them with an attribute to mark them as ""internal use only"". =||= I would also like to see a solution to this issue. Making the mockito-junit-jupiter jar into a fragment which exports the `MockitoExtension` package and attaches to mockito-core does sound like a good plan. =||= I've got a set of changes that makes mockito-junit-jupiter work in OSGi using the same strategy that junit5 used to identify ""friend"" packages that are exported but not intended for public use outside of _mockito_.

@raphw do you think your team would be interested? =||= Looks good to me, I had a look at the build and I know too little about OSGi to understand the effect the API guardian dependencies have but since the classes only carry annotations and the dependency is not required, I do not see any chance of a regression.

@TimvdLippe - could you have a second look, you know the build better then me. To me it looks like a good merge. =||= For your edification:
a) apiguardian does not bring with it any runtime dependencies (confirmed by the OSGi metadata)
b) the interaction between [API guardian and bnd is explained here](https://bnd.bndtools.org/instructions/export-apiguardian.html)
c) the build adds a `verifyOSGi` gradle task glued onto `check` to make sure that future changes do not break the relationship required between mockito-core and mockito-junit-jupiter such that they continue working together in OSGi =||= ",0
2050,2039,Failed to mock after upgrading Mockito to version v3.4.x or higher,"Upgrading Mockito to version v3.4.x or higher break the test.

```
private val stripe = Mockito.mock(Stripe::class.java)
```

I mock a Stripe SDK class (https://github.com/stripe/stripe-android) in my test.
On Mockito v3.4.x or higher the mock is failed. 

```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: class com.stripe.android.Stripe.
Can not mock final classes with the following settings :
 - explicit serialization (e.g. withSettings().serializable())
 - extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : java.lang.IllegalArgumentException: Could not create type
```

with trace

```
at com.x.y.z.domain.PaymentUseCaseTest.<init>(PaymentUseCaseTest.kt:24)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at org.junit.platform.commons.util.ReflectionUtils.newInstance(ReflectionUtils.java:511)
	at org.junit.jupiter.engine.execution.ConstructorInvocation.proceed(ConstructorInvocation.java:56)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.api.extension.InvocationInterceptor.interceptTestClassConstructor(InvocationInterceptor.java:72)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:77)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeTestClassConstructor(ClassBasedTestDescriptor.java:333)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.instantiateTestClass(ClassBasedTestDescriptor.java:280)
	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.instantiateTestClass(ClassTestDescriptor.java:77)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.instantiateAndPostProcessTestInstance(ClassBasedTestDescriptor.java:262)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$2(ClassBasedTestDescriptor.java:256)
	at java.util.Optional.orElseGet(Optional.java:267)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$3(ClassBasedTestDescriptor.java:255)
	at org.junit.jupiter.engine.execution.TestInstancesProvider.getTestInstances(TestInstancesProvider.java:29)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$prepare$0(TestMethodTestDescriptor.java:108)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:107)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:71)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$prepare$1(NodeTestTask.java:107)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.prepare(NodeTestTask.java:107)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:75)
	at java.util.ArrayList.forEach(ArrayList.java:1257)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at java.util.ArrayList.forEach(ArrayList.java:1257)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248)
	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211)
	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132)
	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)
Caused by: java.lang.IllegalArgumentException: Could not create type
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:154)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:365)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:174)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:376)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:36)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:379)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.doCreateMock(InlineByteBuddyMockMaker.java:339)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:318)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:52)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:61)
	at org.mockito.Mockito.mock(Mockito.java:1949)
	at org.mockito.Mockito.mock(Mockito.java:1860)
	... 64 more
Caused by: java.lang.VerifyError
	at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:260)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:211)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:46)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:43)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:152)
```

I am interested to know what changes from 3.3.x to 3.4.x that causing this

Edit: Added bytebuddy dump from `-Dnet.bytebuddy.dump` command
dump: [bytebuddy.zip](https://github.com/mockito/mockito/files/5193173/bytebuddy.zip)","Could you run with - Dnet.bytebuddy.dump=/some/folder and add the dumped class files to this ticket?  =||= @raphw Added bytebuddy dump =||= Thanks, this is a very strange error and I struggle to see how Byte Buddy could even emmit this bytecode. The library stores an integer where this should be impossible.

Could you force your Byte Buddy dependency to 1.10.14 manually just to see if this fixes the problem? =||= That is interesting 🤔 
I tried your suggestion and force ByteBuddy to v1.10.14 , unfortunately it does not solve the issue. 
I attach new bytebuddy dump with ByteBuddy to v1.10.14
Dump: [bytebuddy-1.10.14.zip](https://github.com/mockito/mockito/files/5200600/bytebuddy-1.10.14.zip)

Not sure this will help but when I put breakpoint here: 
https://github.com/raphw/byte-buddy/blob/master/byte-buddy-dep/src/main/java/net/bytebuddy/TypeCache.java#L366

Before the exception thrown.The first evaluation of the statement throw the exception but the second evaluation produce something.

First Execution | Second Execution
------------ | -------------
<img width=""586"" alt=""first"" src=""https://user-images.githubusercontent.com/8171574/92712274-b440b580-f359-11ea-864b-b923ae4b3e1a.png"">|<img width=""586"" alt=""second"" src=""https://user-images.githubusercontent.com/8171574/92712280-b7d43c80-f359-11ea-9754-9bac831c181f.png"">

 =||= I reconstructed the problem, the issue is that the method `getAdvancedFraudSignalsEnabled` pushes two values onto the stack but only pops one return value off. This byte code cannot be created by javac and is technically incorrect while the JVM forgives the excess value:

```
  // access flags 0x19
  public final static getAdvancedFraudSignalsEnabled()Z
    GETSTATIC com/stripe/android/Stripe.Companion : Lcom/stripe/android/Stripe$Companion;
    GETSTATIC com/stripe/android/Stripe.advancedFraudSignalsEnabled : Z
    IRETURN
    MAXSTACK = 2
    MAXLOCALS = 0
```
I need to see why this distracts the byte code enhancer but it is certainly fixable. =||= Fixed on master of Byte Buddy, will be fixed in the next release and then updated upstream. =||= Thanks for the explanation and fixes! =||= @raphw it looks like this one is very much related to :  https://github.com/mockito/mockito/issues/2090 ...  =||= ",0
2053,2007,Android instrumentation test packaging fails for mockito-android 3.5.0 with minSdk < 26,"We've upgraded from `mockito-android:3.4.6` to `mockito-android:3.5.0`. I'm attempting to package up my instrumented tests by running the `assembleAndroidTest` gradle task. The task fails with the following errors:
```
/Users/<me>/.gradle/caches/transforms-2/files-2.1/fb7959dc5bfc8ebb26ad0660efa1929e/jetified-mockito-core-3.5.0.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
/Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
/Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
```

and with root cause:
```
com.android.tools.r8.utils.b: Error: /Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar:org/objenesis/instantiator/util/DefineClassHelper$Java8.class, java.lang.Class org.objenesis.instantiator.util.DefineClassHelper$Java8.defineClass(java.lang.String, byte[], int, int, java.lang.Class, java.lang.ClassLoader, java.security.ProtectionDomain), MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.utils.y0.a(:21)
        at com.android.tools.r8.utils.O.a(:51)
        ... 35 more
```
","Should be fixed with #2006 =||= We still have issues with 3.5.2. We are unable to update to new version and use `assembleAndroidTest` task.

```
/usr/local/gradle/caches/transforms-2/files-2.1/225c46d0e9f10ff5ef3f4d9a009c4924/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)

com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)

``` =||= @kozaxinan Are you certain that you are using 3.5.2 and aren't accidentally using an older version of either Mockito or ByteBuddy? We have had confirmations from other users that 3.5.2 fixed the issue you are seeing, so it would be good to double check that you have the correct version. =||= @TimvdLippe I confirm the issue still occurs also in our project with the exact same error.
- mockito-core 3.5.2
- mockito-android 3.5.2
- mockito-inline 3.5.2
- objenesis 3.1
- bytebuddy 1.10.13 =||= Looks like the issue was introduced in objenesis 3.x (upgraded in https://github.com/mockito/mockito/pull/1998)
Forcing objenesis to 2.6 makes `assembleAndroidTest` task succeed. =||= Aha, thanks for letting us know. I will create a revert. =||= Still getting this error with 3.5.7 =||= Here's the stacktrace that I get when using 3.5.7:

```
/Users/azizbekian/.gradle/caches/transforms-2/files-2.1/63e24576c0e1d1e5b675c1c61e4e5727/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
Stack trace:
com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.errors.a.a(:7)
        at com.android.tools.r8.ir.conversion.O.b(:58)
        at com.android.tools.r8.ir.conversion.O.a(:104)
        at com.android.tools.r8.ir.conversion.O.a(:53)
        at com.android.tools.r8.graph.C.b(:43)
        at com.android.tools.r8.ir.conversion.O.b(:35)
        at com.android.tools.r8.utils.U0.a(:10)
        at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:125)
        at com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:69)
        at com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:78)
        at com.google.common.util.concurrent.MoreExecutors$DirectExecutorService.execute(MoreExecutors.java:322)
        at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134)
        at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:66)
        at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:36)
        at com.android.tools.r8.utils.U0.a(:3)
        at com.android.tools.r8.ir.conversion.O.a(:10)
        at com.android.tools.r8.D8.d(:29)
        at com.android.tools.r8.D8.b(:1)
        at com.android.tools.r8.utils.W.a(:30)
        at com.android.tools.r8.D8.run(:11)
        at com.android.builder.dexing.D8DexArchiveBuilder.convert(D8DexArchiveBuilder.java:116)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.process(DexingTransform.kt:296)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.processNonIncrementally(DexingTransform.kt:243)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.doTransform(DexingTransform.kt:153)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.access$doTransform(DexingTransform.kt:69)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform$transform$1.invoke(DexingTransform.kt:104)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform$transform$1.invoke(DexingTransform.kt:69)
        at com.android.build.gradle.internal.tasks.BlocksUtilsKt.recordArtifactTransformSpan(BlocksUtils.kt:33)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.transform(DexingTransform.kt:100)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformer.transform(DefaultTransformer.java:193)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$TransformerExecution.execute(DefaultTransformerInvocationFactory.java:332)
        at org.gradle.internal.execution.steps.ExecuteStep.lambda$execute$0(ExecuteStep.java:32)
        at java.util.Optional.map(Optional.java:215)
        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:32)
        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:26)
        at org.gradle.internal.execution.steps.CleanupOutputsStep.execute(CleanupOutputsStep.java:67)
        at org.gradle.internal.execution.steps.CleanupOutputsStep.execute(CleanupOutputsStep.java:36)
        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:49)
        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:34)
        at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:43)
        at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:73)
        at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:54)
        at org.gradle.internal.execution.steps.CatchExceptionStep.execute(CatchExceptionStep.java:34)
        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:44)
        at org.gradle.internal.execution.steps.SnapshotOutputsStep.execute(SnapshotOutputsStep.java:54)
        at org.gradle.internal.execution.steps.SnapshotOutputsStep.execute(SnapshotOutputsStep.java:38)
        at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:49)
        at org.gradle.internal.execution.steps.CacheStep.executeWithoutCache(CacheStep.java:159)
        at org.gradle.internal.execution.steps.CacheStep.execute(CacheStep.java:72)
        at org.gradle.internal.execution.steps.CacheStep.execute(CacheStep.java:43)
        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:44)
        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:33)
        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:38)
        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:24)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:92)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$0(SkipUpToDateStep.java:85)
        at java.util.Optional.map(Optional.java:215)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:39)
        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:76)
        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:37)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:36)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:26)
        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:94)
        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:49)
        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:79)
        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:53)
        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:74)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.lambda$execute$2(SkipEmptyWorkStep.java:78)
        at java.util.Optional.orElseGet(Optional.java:267)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:78)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:34)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:39)
        at org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:40)
        at org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:28)
        at org.gradle.internal.execution.impl.DefaultWorkExecutor.execute(DefaultWorkExecutor.java:33)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.lambda$call$2(DefaultTransformerInvocationFactory.java:200)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.fireTransformListeners(DefaultTransformerInvocationFactory.java:269)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.access$300(DefaultTransformerInvocationFactory.java:79)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.call(DefaultTransformerInvocationFactory.java:178)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.call(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:409)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:399)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:94)
        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.call(DelegatingBuildOperationExecutor.java:36)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.lambda$doTransform$0(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.api.internal.artifacts.transform.ImmutableTransformationWorkspaceProvider.lambda$withWorkspace$0(ImmutableTransformationWorkspaceProvider.java:81)
        at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.withFileLock(LockOnDemandCrossProcessCacheAccess.java:90)
        at org.gradle.cache.internal.DefaultCacheAccess.withFileLock(DefaultCacheAccess.java:191)
        at org.gradle.cache.internal.DefaultPersistentDirectoryStore.withFileLock(DefaultPersistentDirectoryStore.java:177)
        at org.gradle.cache.internal.DefaultCacheFactory$ReferenceTrackingCache.withFileLock(DefaultCacheFactory.java:201)
        at org.gradle.api.internal.artifacts.transform.ImmutableTransformationWorkspaceProvider.withWorkspace(ImmutableTransformationWorkspaceProvider.java:76)
        at org.gradle.api.internal.artifacts.transform.AbstractCachingTransformationWorkspaceProvider.lambda$withWorkspace$0(AbstractCachingTransformationWorkspaceProvider.java:55)
        at com.google.common.cache.LocalCache$LocalManualCache$1.load(LocalCache.java:4718)
        at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3445)
        at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2194)
        at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2153)
        at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2043)
        at com.google.common.cache.LocalCache.get(LocalCache.java:3851)
        at com.google.common.cache.LocalCache$LocalManualCache.get(LocalCache.java:4713)
        at org.gradle.api.internal.artifacts.transform.AbstractCachingTransformationWorkspaceProvider.withWorkspace(AbstractCachingTransformationWorkspaceProvider.java:55)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.doTransform(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.access$000(DefaultTransformerInvocationFactory.java:79)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$1.invoke(DefaultTransformerInvocationFactory.java:141)
        at org.gradle.api.internal.artifacts.transform.CacheableInvocation$1.invoke(CacheableInvocation.java:58)
        at org.gradle.api.internal.artifacts.transform.TransformationOperation.run(TransformationOperation.java:39)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:395)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:387)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.access$1500(DefaultBuildOperationExecutor.java:49)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$ParentPreservingQueueWorker.execute(DefaultBuildOperationExecutor.java:437)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runOperation(DefaultBuildOperationQueue.java:231)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.access$600(DefaultBuildOperationQueue.java:173)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.create(DefaultBuildOperationQueue.java:210)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.create(DefaultBuildOperationQueue.java:204)
        at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:180)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runBatch(DefaultBuildOperationQueue.java:204)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.run(DefaultBuildOperationQueue.java:178)
        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
        at java.lang.Thread.run(Thread.java:748)
        Suppressed: java.util.concurrent.ExecutionException: com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
                at com.google.common.util.concurrent.AbstractFuture.getDoneValue(AbstractFuture.java:552)
                at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:513)
                at com.google.common.util.concurrent.FluentFuture$TrustedFuture.get(FluentFuture.java:86)
                at com.android.tools.r8.utils.U0.a(:14)
                at com.android.tools.r8.utils.U0.a(:9)
                ... 114 more
        [CIRCULAR REFERENCE:com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)]
Caused by: com.android.tools.r8.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.ir.conversion.N.a(:633)
        at com.android.tools.r8.ir.conversion.N.a(:674)
        at com.android.tools.r8.r.n.A.a(:236)
        at com.android.tools.r8.ir.conversion.o.a(:153)
        at com.android.tools.r8.ir.conversion.N.a(:133)
        at com.android.tools.r8.graph.l.a(:93)
        at com.android.tools.r8.graph.l.a(:71)
        at com.android.tools.r8.graph.l.buildIR(:1)
        at com.android.tools.r8.graph.C0.buildIR(:1)
        at com.android.tools.r8.graph.T.a(:152)
        at com.android.tools.r8.ir.conversion.O.a(:412)
        at com.android.tools.r8.ir.conversion.O.b(:53)
        ... 127 more


``` =||= I updated all mockito packages to 3.5.9 but unfortunately I do get still the same error as above. =||= This still seems to fail for me:
```
Execution failed for task ':mergeDexGplayDebugAndroidTest'.
> Could not resolve all files for configuration ':gplayDebugAndroidTestRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=18, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /home/tobi/.gradle/caches/transforms-2/files-2.1/66df4f0b18795a51947f8881933478f9/jetified-objenesis-3.1.jar.
         > Error while dexing.

```

I removed     
`androidTestImplementation ""org.mockito:mockito-core:$mockitoVersion""`
and changed:
```
testImplementation (""com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0"") {
        exclude group: ""org.mockito"", module: ""mockito-core""
    }
```

If you want to test it: https://github.com/nextcloud/android/pull/6768
 =||= This is still happening in 3.5.10:

- https://pastebin.ubuntu.com/p/rKzc6MVhBf/
- https://github.com/relaycorp/relaynet-gateway-android/pull/120 =||= @gnarea You are depending on Objenesis 3, which is incompatible with Android <26. Please downgrade to Objenesis 2 and depend on `mockito-android`. For more info, see the context in #2024 =||= @TimvdLippe looks like `mockito-core` still has objenesis 3.1 as a dependency. 
```
+--- project :my-project
|    \--- org.mockito:mockito-core:3.5.10
|         +--- net.bytebuddy:byte-buddy:1.10.13
|         +--- net.bytebuddy:byte-buddy-agent:1.10.13
|         \--- org.objenesis:objenesis:3.1

+--- org.mockito:mockito-android:3.5.10
|    +--- org.mockito:mockito-core:3.5.10 (*)
|    +--- net.bytebuddy:byte-buddy-android:1.10.13
|    |    +--- net.bytebuddy:byte-buddy:1.10.13
|    |    \--- com.jakewharton.android.repackaged:dalvik-dx:9.0.0_r3
|    \--- org.objenesis:objenesis:[2.6, 3.0) -> 3.1
``` =||= @francescocervone That is correct. For non-Android projects, they can use Objenesis 3 just fine. =||= @TimvdLippe it's pretty common for Android projects having some pure JVM Gradle modules, not depending on Android. In that case we must depend on `mockito-core` which depends on Objenesis 3. What do you suggest in that case?

Anyway, even if we don't depend directly on `mockito-core`, we get the same error on `mockito-core` (I suppose that's because `mockito-android` depends on `mockito-core`).
```
> Transform artifact mockito-core-3.5.10.jar (org.mockito:mockito-core:3.5.10) with DexingNoClasspathTransform
D8: Private interface methods are only supported starting with Android N (--min-api 24): java.lang.Object org.mockito.plugins.MemberAccessor.lambda$newInstance$0(java.lang.reflect.Constructor, java.lang.Object[])
Stack trace:
com.android.tools.r8.a: Private interface methods are only supported starting with Android N (--min-api 24): java.lang.Object org.mockito.plugins.MemberAccessor.lambda$newInstance$0(java.lang.reflect.Constructor, java.lang.Object[])

[ stacktrace ]

* What went wrong:
Execution failed for task ':app:mergeExtDexDebugAndroidTest'.
> Could not resolve all files for configuration ':app:debugAndroidTestRuntimeClasspath'.
   > Failed to transform mockito-core-3.5.10.jar (org.mockito:mockito-core:3.5.10) to match attributes {artifactType=android-dex, dexing-enable-desugaring=false, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingNoClasspathTransform: /Users/me/.gradle/caches/transforms-2/files-2.1/9ebcc121d44dc6f808610b5ee83414a2/jetified-mockito-core-3.5.10.jar.
         > Error while dexing.
```

Do you need an example project? =||= @francescocervone That last stacktrace is yet another issue that is new to me, as it complains about private interface methods. That seems to be unrelated to Objenesis. The code in question is https://github.com/mockito/mockito/blob/b6ae6cf12b93ef9445e524224375aab1eb76129d/src/main/java/org/mockito/plugins/MemberAccessor.java#L24-L28

I guess older versions of Android do not support default interface methods. I am not sure what to do here, as that seems to be a problem where Android did not support all features of Java 8. Since Mockito 3 targets Java 8, that would be incompatible with older versions of Android.

Can you use Mockito 2 solely for tests running on older versions of Android? =||= > Can you use Mockito 2 solely for tests running on older versions of Android?

No, because this is a compilation error which depends on the minimum supported Android version. Almost every Android project should use Mockito 2 until android 26 will be the ""generally accepted"" minimum sdk supported version (probably in at least 5 years 😄). =||= @francescocervone What I mean is that you have 2 test suites. 1 testsuite for all tests >= 26 and 1 testsuite for all tests <26. For the testsuite >= 26 you can use Mockito 3 + Objenesis 3, as they support Java 8+. For the testsuite <26 you can use Mockito 2 + Objenesis 2, as they support Java 6+. By splitting up the test suites, you can use modern Mockito for modern Android and older Mockito for older Android. That should work right? =||= Also to reiterate, we have introduced Animal Sniffer to ensure we don't break Android again. We set the target to 24 per https://github.com/mockito/mockito/pull/2006/files#diff-c197962302397baf3a4cc36463dce5eaR104 which seemed the most reasonable cut-off for Java 8 support that Mockito 3 relies on. Therefore, rather than having a cut-off at 26, we would be talking about a cut-off at 24. I am not sure when the Android community moves past that cut-off? =||= @TimvdLippe as far as I know you cannot have 2 test suites in the same android project compiling against 2 Android versions. The minimum Android supported version is a property (`minSdkVersion`) defined in the android project's `build.gradle` file through the Android Gradle Plugin.

> I am not sure when the Android community moves past that cut-off? 

Maybe [this chart](https://gs.statcounter.com/android-version-market-share/mobile-tablet/worldwide) can be helpful? In my case, we currently support Android 21 as min SDK. =||= We could try to update Animal Sniffer to level 21 and see what the effect is. If we can make `mockito-core` compatible with that, without introducing breaking changes for the wider Java ecosystem, then I am open to that. However, when @raphw tried that previously, it turned out that a large portion of `mockito-core` was *already* incompatible. This led us to believe that we would have already broken our users and (since we hadn't received complaints before), 24 felt like the best option.

3.5.0 was a big release and a lot of work went into it to support modern Java, which is probably the reason we have hit numerous issues with it. I wonder how many changes in 3.5.0 affect compatibility compared to previous Mockito releases. Could you clone Mockito and try to work out what changes are required to make Mockito compatible with 21? Then we can assess breakages and go from there. =||= Reopening this issue, as I think it is clear by now we are going to need support from developers working in the Android ecosystem on figuring out how to resolve these issues. =||= FYI: at least in my case, the workaround suggested above worked: https://github.com/relaycorp/relaynet-gateway-android/pull/120. But that project doesn't have JVM modules (they're all external deps). We're also supporting API 21+. =||= @TimvdLippe 
>Could you clone Mockito and try to work out what changes are required to make Mockito compatible with 21?

I will. =||= If I remember correctly, types like predicate and function are not available which are part of our public API. This can be fixed but requires breaking public API.  =||= @gnarea , that didn't work for my setup, minSdk = 21:

```
* What went wrong:
Execution failed for task ':app:mergeExtDexDevDebugAndroidTest'.
> Could not resolve all files for configuration ':app:devDebugAndroidTestRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /Users/azizbekian/.gradle/caches/transforms-2/files-2.1/adb8b362b2ccf145263475708478d34b/jetified-objenesis-3.1.jar.
         > Error while dexing.
``` =||= @raphw If I remember correctly, we are already shipping `Optional` and `Function` in our public API prior to 3.5.0. Since Android tests were passing with 3.4.0, I don't think including these symbols in our public API is problematic. Therefore, I don't think we should be changing these types in our API. (This is also what confuses me the most, as to why some parts work and why other parts don't work, even though Animal Sniffer is claiming nothing should in theory work) =||= I'm not an Android expert. `DefineClassHelper` is only used by specific instantiators that are not used in Android. So ideally this class can be excluded from the compilation by Dex it should solve the problem. =||= @TimvdLippe I played a little bit with mockito and the issue I mentioned [in this comment](https://github.com/mockito/mockito/issues/2007#issuecomment-688321579) is solved by adding in the android project's build.gradle:
```gradle
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
```
Android Gradle Plugin 3.0 and higher [supports default interface methods](https://developer.android.com/studio/releases/gradle-plugin#j8-library-desugaring).

---

The objenesis 3.x issue included in `mockito-core` mentioned [here](https://github.com/mockito/mockito/issues/2007#issuecomment-688252464) instead can be avoided by excluding objenesis from `mockito-core` or any library/project depending on `mockito-core`:
```gradle
dependencies {
    androidTestImplementation 'org.mockito:mockito-android:3.5.10'
    androidTestImplementation('org.mockito:mockito-core:3.5.10') {
        exclude group: 'org.objenesis'
    }
    androidTestImplementation(project(':depending-on-mockito-core')) {
        exclude group: 'org.objenesis'
    }
}
```
This workaround is a little bit inconvenient IMHO, but solves the issue. =||= @francescocervone Thanks for the investigation. With regards to your first solution, can we automatically apply that to `mockito-android` or do users of that artifact need to specify it in their `build.gradle`? For the latter, if you solely depend on `mockito-android` you should be good to go. If that is inconvenient, maybe it can be solved in Objenesis 3 instead (not sure if that is possible). =||= @TimvdLippe 
> can we automatically apply that to mockito-android or do users of that artifact need to specify it in their build.gradle?

Users need to specify it in their `build.gradle`.

---

> if you solely depend on mockito-android you should be good to go

True, but I think this ""solution"" is pretty weak. For example, if the project declares [`mockito-kotlin`](https://github.com/nhaarman/mockito-kotlin) dependency, objenesis must be excluded since `mockito-kotlin` depends on `mockito-core`. In general, if the android project depends on some module/project/library depending on `mockito-core`, the workaround must be applied. =||= Again, I'm not sure but can't you just exclude `DefineClassHelper`? That will solve the problem and no need to remove Objenesis. I don't think I can solve it from the Objenesis side. If I can please tell me why? Deploy an objenesis-android excluding these classes will just make everything really messy. =||= @henri-tremblay is there a way to exclude a class from the compilation of a library? How can we exclude `DefineClassHelper`?
Even if we were able to exclude that class: Objenesis is built with Java 8 and it's likely to introduce similar issues in future. This circle will end when one of these classes using some unsupported Java 8 feature, will be part of the Objenesis core and we will not be able to just ""exclude"" it. =||= @TimvdLippe there is a handier workaround for objenesis 3.x, without excluding it from `mockito-core`.
In root `build.gradle` we can add:
```gradle
allprojects {
    configurations.all {
        resolutionStrategy.force 'org.objenesis:objenesis:2.6'
    }
}
``` =||= @francescocervone I don't know. That's why I was saying ""Not an Android expert"" :-) Let me ask around. It's sad to downgrade to Android 2. The other solution would be to split objenesis in 2. One with the core instantiators and one with the exotic ones. Can you hack the objenesis jar to remote this class and just compile with the new jar to tell me if it works? =||= Ok. I had some feedback from @mhausherr. The error is in R8. So we could ignore like this in `proguard-rules.pro`:
```
-assumenosideeffects class org.objenesis.instanciator.util.DefineClassHelper {
    *;
}
``` =||= @henri-tremblay 🤔 It cannot be R8. R8 obfuscates, optimizes and shrinks the code in release builds. It doesn't run in test unless you don't explicitly enable it also for debug builds.
More info here -> https://developer.android.com/studio/build/shrink-code =||= @jakewharton (if I remember correctly, you know a lot more about minification, R8 and problems like this. If that's not the case, please let me know and feel free to ignore this message)

Hey Jake,

Please see the above messages regarding problems with Mockito transitively depending on Objenesis 3 which broke Android compatibility. However, Objenesis compilation broke, despite the class in question not being used in Android tests. As such, the class could be removed with the proguard configuration @henri-tremblay (maintainer of Objenesis) posted.

@francescocervone thinks that is not the appropriate solution, as R8 should not be performing these kind of cleanups.

Sadly I am lacking the knowledge to figure out what is the appropriate solution here and how we can move forward and I had hoped you would be able to help us figuring out.

Thanks in advance for your time and once again, if you prefer not to be involved, feel free to say so and I will try to find another domain expert 😄  =||= @TimvdLippe I didn't say that R8 should not be performing these kind of cleanups. I said that R8 is not involved at all, therefore the R8 rule suggested by @henri-tremblay is not a valid workaround.  =||= @TimvdLippe I created #2053 to fix this issue. With range usage in `strictly` tag, gradle fails to force dependency. I verified with our project. For androidTest, If we just use moctiko-android and exclude mockito-core from mockito-kotlin (or any dependency that has  mockito-core), there shouldnt be any issue. 
This fix still not great but until objenesis supports android sdk < 26, it should work. =||= For anyone who is looking to contribute, please check out the upstream issue at https://github.com/easymock/objenesis/issues/79 =||= I am going to close this issue in favor of https://github.com/easymock/objenesis/issues/79 =||= I have pushed the changes moving some instantiators in a new project. Could you please check if it works? =||= Release 3.2 was done. It should work now. =||= Using version 3.8.0:

```
Execution failed for task ':App:mergeExtDexDebug'.
> Could not resolve all files for configuration ':App:debugRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-transform=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /home/circleci/.gradle/caches/modules-2/files-2.1/org.objenesis/objenesis/3.1/48f12deaae83a8dfc3775d830c9fd60ea59bbbca/objenesis-3.1.jar.
         > Error while dexing.
``` =||= Release 3.2 of _Objenesis_ was done, Mockito still needs to have its dependency updated to 3.2. 

This can be worked around by declaring the Objenesis dependency yourself like `implementation 'org.objenesis:objenesis:3.2` and rely on gradle's dependency resolution to go with the 3.2 version instead of the 3.1 currently included with Mockito =||= @PaulKlauser Do you mind sending us a PR which updates the version? =||= https://github.com/mockito/mockito/pull/2249 =||= Could you consider publishing this to Maven as well? =||= Mockito 3.9.0 should be published to Maven Central: https://github.com/mockito/mockito/runs/2288011033?check_suite_focus=true =||= Thanks! It's still at 3.8.0 on [mvnrepository](https://mvnrepository.com/artifact/org.mockito/mockito-core) and [maven](https://search.maven.org/search?q=a:mockito-core) but I suppose it can take several hours for the change to propagate. =||= Yes these systems take a while to obtain the new information. 3.9.0 is published here: https://repo1.maven.org/maven2/org/mockito/mockito-core/3.9.0/ =||= Just mentioning that I had [this exact crash](https://github.com/mockito/mockito/issues/2007#issuecomment-686925445) and upgrading to 3.9.0 from 3.8.0 fixed it.

 However, it might be worth mentioning that any Android project that is just using `JCenter` as a repository will not return the right information for latest version. Android projects need to begin adding `mavenCentral()` as a repository, which previously was unnecessary because JCenter mirrored Maven Central. That's changing and it's because of this that my particular project didn't recognize the 3.9.0 update.
```
repositories {
    google()
    mavenCentral()  <-- many projects need to add this, explicitly
    jcenter()
    maven { url 'https://jitpack.io' }
}
``` =||= https://blog.gradle.org/jcenter-shutdown =||= ",0
2053,2007,Android instrumentation test packaging fails for mockito-android 3.5.0 with minSdk < 26,"We've upgraded from `mockito-android:3.4.6` to `mockito-android:3.5.0`. I'm attempting to package up my instrumented tests by running the `assembleAndroidTest` gradle task. The task fails with the following errors:
```
/Users/<me>/.gradle/caches/transforms-2/files-2.1/fb7959dc5bfc8ebb26ad0660efa1929e/jetified-mockito-core-3.5.0.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
/Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
/Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
```

and with root cause:
```
com.android.tools.r8.utils.b: Error: /Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar:org/objenesis/instantiator/util/DefineClassHelper$Java8.class, java.lang.Class org.objenesis.instantiator.util.DefineClassHelper$Java8.defineClass(java.lang.String, byte[], int, int, java.lang.Class, java.lang.ClassLoader, java.security.ProtectionDomain), MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.utils.y0.a(:21)
        at com.android.tools.r8.utils.O.a(:51)
        ... 35 more
```
","Should be fixed with #2006 =||= We still have issues with 3.5.2. We are unable to update to new version and use `assembleAndroidTest` task.

```
/usr/local/gradle/caches/transforms-2/files-2.1/225c46d0e9f10ff5ef3f4d9a009c4924/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)

com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)

``` =||= @kozaxinan Are you certain that you are using 3.5.2 and aren't accidentally using an older version of either Mockito or ByteBuddy? We have had confirmations from other users that 3.5.2 fixed the issue you are seeing, so it would be good to double check that you have the correct version. =||= @TimvdLippe I confirm the issue still occurs also in our project with the exact same error.
- mockito-core 3.5.2
- mockito-android 3.5.2
- mockito-inline 3.5.2
- objenesis 3.1
- bytebuddy 1.10.13 =||= Looks like the issue was introduced in objenesis 3.x (upgraded in https://github.com/mockito/mockito/pull/1998)
Forcing objenesis to 2.6 makes `assembleAndroidTest` task succeed. =||= Aha, thanks for letting us know. I will create a revert. =||= Still getting this error with 3.5.7 =||= Here's the stacktrace that I get when using 3.5.7:

```
/Users/azizbekian/.gradle/caches/transforms-2/files-2.1/63e24576c0e1d1e5b675c1c61e4e5727/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
Stack trace:
com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.errors.a.a(:7)
        at com.android.tools.r8.ir.conversion.O.b(:58)
        at com.android.tools.r8.ir.conversion.O.a(:104)
        at com.android.tools.r8.ir.conversion.O.a(:53)
        at com.android.tools.r8.graph.C.b(:43)
        at com.android.tools.r8.ir.conversion.O.b(:35)
        at com.android.tools.r8.utils.U0.a(:10)
        at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:125)
        at com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:69)
        at com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:78)
        at com.google.common.util.concurrent.MoreExecutors$DirectExecutorService.execute(MoreExecutors.java:322)
        at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134)
        at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:66)
        at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:36)
        at com.android.tools.r8.utils.U0.a(:3)
        at com.android.tools.r8.ir.conversion.O.a(:10)
        at com.android.tools.r8.D8.d(:29)
        at com.android.tools.r8.D8.b(:1)
        at com.android.tools.r8.utils.W.a(:30)
        at com.android.tools.r8.D8.run(:11)
        at com.android.builder.dexing.D8DexArchiveBuilder.convert(D8DexArchiveBuilder.java:116)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.process(DexingTransform.kt:296)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.processNonIncrementally(DexingTransform.kt:243)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.doTransform(DexingTransform.kt:153)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.access$doTransform(DexingTransform.kt:69)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform$transform$1.invoke(DexingTransform.kt:104)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform$transform$1.invoke(DexingTransform.kt:69)
        at com.android.build.gradle.internal.tasks.BlocksUtilsKt.recordArtifactTransformSpan(BlocksUtils.kt:33)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.transform(DexingTransform.kt:100)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformer.transform(DefaultTransformer.java:193)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$TransformerExecution.execute(DefaultTransformerInvocationFactory.java:332)
        at org.gradle.internal.execution.steps.ExecuteStep.lambda$execute$0(ExecuteStep.java:32)
        at java.util.Optional.map(Optional.java:215)
        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:32)
        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:26)
        at org.gradle.internal.execution.steps.CleanupOutputsStep.execute(CleanupOutputsStep.java:67)
        at org.gradle.internal.execution.steps.CleanupOutputsStep.execute(CleanupOutputsStep.java:36)
        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:49)
        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:34)
        at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:43)
        at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:73)
        at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:54)
        at org.gradle.internal.execution.steps.CatchExceptionStep.execute(CatchExceptionStep.java:34)
        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:44)
        at org.gradle.internal.execution.steps.SnapshotOutputsStep.execute(SnapshotOutputsStep.java:54)
        at org.gradle.internal.execution.steps.SnapshotOutputsStep.execute(SnapshotOutputsStep.java:38)
        at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:49)
        at org.gradle.internal.execution.steps.CacheStep.executeWithoutCache(CacheStep.java:159)
        at org.gradle.internal.execution.steps.CacheStep.execute(CacheStep.java:72)
        at org.gradle.internal.execution.steps.CacheStep.execute(CacheStep.java:43)
        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:44)
        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:33)
        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:38)
        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:24)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:92)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$0(SkipUpToDateStep.java:85)
        at java.util.Optional.map(Optional.java:215)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:39)
        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:76)
        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:37)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:36)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:26)
        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:94)
        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:49)
        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:79)
        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:53)
        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:74)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.lambda$execute$2(SkipEmptyWorkStep.java:78)
        at java.util.Optional.orElseGet(Optional.java:267)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:78)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:34)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:39)
        at org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:40)
        at org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:28)
        at org.gradle.internal.execution.impl.DefaultWorkExecutor.execute(DefaultWorkExecutor.java:33)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.lambda$call$2(DefaultTransformerInvocationFactory.java:200)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.fireTransformListeners(DefaultTransformerInvocationFactory.java:269)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.access$300(DefaultTransformerInvocationFactory.java:79)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.call(DefaultTransformerInvocationFactory.java:178)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.call(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:409)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:399)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:94)
        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.call(DelegatingBuildOperationExecutor.java:36)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.lambda$doTransform$0(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.api.internal.artifacts.transform.ImmutableTransformationWorkspaceProvider.lambda$withWorkspace$0(ImmutableTransformationWorkspaceProvider.java:81)
        at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.withFileLock(LockOnDemandCrossProcessCacheAccess.java:90)
        at org.gradle.cache.internal.DefaultCacheAccess.withFileLock(DefaultCacheAccess.java:191)
        at org.gradle.cache.internal.DefaultPersistentDirectoryStore.withFileLock(DefaultPersistentDirectoryStore.java:177)
        at org.gradle.cache.internal.DefaultCacheFactory$ReferenceTrackingCache.withFileLock(DefaultCacheFactory.java:201)
        at org.gradle.api.internal.artifacts.transform.ImmutableTransformationWorkspaceProvider.withWorkspace(ImmutableTransformationWorkspaceProvider.java:76)
        at org.gradle.api.internal.artifacts.transform.AbstractCachingTransformationWorkspaceProvider.lambda$withWorkspace$0(AbstractCachingTransformationWorkspaceProvider.java:55)
        at com.google.common.cache.LocalCache$LocalManualCache$1.load(LocalCache.java:4718)
        at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3445)
        at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2194)
        at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2153)
        at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2043)
        at com.google.common.cache.LocalCache.get(LocalCache.java:3851)
        at com.google.common.cache.LocalCache$LocalManualCache.get(LocalCache.java:4713)
        at org.gradle.api.internal.artifacts.transform.AbstractCachingTransformationWorkspaceProvider.withWorkspace(AbstractCachingTransformationWorkspaceProvider.java:55)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.doTransform(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.access$000(DefaultTransformerInvocationFactory.java:79)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$1.invoke(DefaultTransformerInvocationFactory.java:141)
        at org.gradle.api.internal.artifacts.transform.CacheableInvocation$1.invoke(CacheableInvocation.java:58)
        at org.gradle.api.internal.artifacts.transform.TransformationOperation.run(TransformationOperation.java:39)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:395)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:387)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.access$1500(DefaultBuildOperationExecutor.java:49)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$ParentPreservingQueueWorker.execute(DefaultBuildOperationExecutor.java:437)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runOperation(DefaultBuildOperationQueue.java:231)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.access$600(DefaultBuildOperationQueue.java:173)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.create(DefaultBuildOperationQueue.java:210)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.create(DefaultBuildOperationQueue.java:204)
        at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:180)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runBatch(DefaultBuildOperationQueue.java:204)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.run(DefaultBuildOperationQueue.java:178)
        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
        at java.lang.Thread.run(Thread.java:748)
        Suppressed: java.util.concurrent.ExecutionException: com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
                at com.google.common.util.concurrent.AbstractFuture.getDoneValue(AbstractFuture.java:552)
                at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:513)
                at com.google.common.util.concurrent.FluentFuture$TrustedFuture.get(FluentFuture.java:86)
                at com.android.tools.r8.utils.U0.a(:14)
                at com.android.tools.r8.utils.U0.a(:9)
                ... 114 more
        [CIRCULAR REFERENCE:com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)]
Caused by: com.android.tools.r8.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.ir.conversion.N.a(:633)
        at com.android.tools.r8.ir.conversion.N.a(:674)
        at com.android.tools.r8.r.n.A.a(:236)
        at com.android.tools.r8.ir.conversion.o.a(:153)
        at com.android.tools.r8.ir.conversion.N.a(:133)
        at com.android.tools.r8.graph.l.a(:93)
        at com.android.tools.r8.graph.l.a(:71)
        at com.android.tools.r8.graph.l.buildIR(:1)
        at com.android.tools.r8.graph.C0.buildIR(:1)
        at com.android.tools.r8.graph.T.a(:152)
        at com.android.tools.r8.ir.conversion.O.a(:412)
        at com.android.tools.r8.ir.conversion.O.b(:53)
        ... 127 more


``` =||= I updated all mockito packages to 3.5.9 but unfortunately I do get still the same error as above. =||= This still seems to fail for me:
```
Execution failed for task ':mergeDexGplayDebugAndroidTest'.
> Could not resolve all files for configuration ':gplayDebugAndroidTestRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=18, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /home/tobi/.gradle/caches/transforms-2/files-2.1/66df4f0b18795a51947f8881933478f9/jetified-objenesis-3.1.jar.
         > Error while dexing.

```

I removed     
`androidTestImplementation ""org.mockito:mockito-core:$mockitoVersion""`
and changed:
```
testImplementation (""com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0"") {
        exclude group: ""org.mockito"", module: ""mockito-core""
    }
```

If you want to test it: https://github.com/nextcloud/android/pull/6768
 =||= This is still happening in 3.5.10:

- https://pastebin.ubuntu.com/p/rKzc6MVhBf/
- https://github.com/relaycorp/relaynet-gateway-android/pull/120 =||= @gnarea You are depending on Objenesis 3, which is incompatible with Android <26. Please downgrade to Objenesis 2 and depend on `mockito-android`. For more info, see the context in #2024 =||= @TimvdLippe looks like `mockito-core` still has objenesis 3.1 as a dependency. 
```
+--- project :my-project
|    \--- org.mockito:mockito-core:3.5.10
|         +--- net.bytebuddy:byte-buddy:1.10.13
|         +--- net.bytebuddy:byte-buddy-agent:1.10.13
|         \--- org.objenesis:objenesis:3.1

+--- org.mockito:mockito-android:3.5.10
|    +--- org.mockito:mockito-core:3.5.10 (*)
|    +--- net.bytebuddy:byte-buddy-android:1.10.13
|    |    +--- net.bytebuddy:byte-buddy:1.10.13
|    |    \--- com.jakewharton.android.repackaged:dalvik-dx:9.0.0_r3
|    \--- org.objenesis:objenesis:[2.6, 3.0) -> 3.1
``` =||= @francescocervone That is correct. For non-Android projects, they can use Objenesis 3 just fine. =||= @TimvdLippe it's pretty common for Android projects having some pure JVM Gradle modules, not depending on Android. In that case we must depend on `mockito-core` which depends on Objenesis 3. What do you suggest in that case?

Anyway, even if we don't depend directly on `mockito-core`, we get the same error on `mockito-core` (I suppose that's because `mockito-android` depends on `mockito-core`).
```
> Transform artifact mockito-core-3.5.10.jar (org.mockito:mockito-core:3.5.10) with DexingNoClasspathTransform
D8: Private interface methods are only supported starting with Android N (--min-api 24): java.lang.Object org.mockito.plugins.MemberAccessor.lambda$newInstance$0(java.lang.reflect.Constructor, java.lang.Object[])
Stack trace:
com.android.tools.r8.a: Private interface methods are only supported starting with Android N (--min-api 24): java.lang.Object org.mockito.plugins.MemberAccessor.lambda$newInstance$0(java.lang.reflect.Constructor, java.lang.Object[])

[ stacktrace ]

* What went wrong:
Execution failed for task ':app:mergeExtDexDebugAndroidTest'.
> Could not resolve all files for configuration ':app:debugAndroidTestRuntimeClasspath'.
   > Failed to transform mockito-core-3.5.10.jar (org.mockito:mockito-core:3.5.10) to match attributes {artifactType=android-dex, dexing-enable-desugaring=false, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingNoClasspathTransform: /Users/me/.gradle/caches/transforms-2/files-2.1/9ebcc121d44dc6f808610b5ee83414a2/jetified-mockito-core-3.5.10.jar.
         > Error while dexing.
```

Do you need an example project? =||= @francescocervone That last stacktrace is yet another issue that is new to me, as it complains about private interface methods. That seems to be unrelated to Objenesis. The code in question is https://github.com/mockito/mockito/blob/b6ae6cf12b93ef9445e524224375aab1eb76129d/src/main/java/org/mockito/plugins/MemberAccessor.java#L24-L28

I guess older versions of Android do not support default interface methods. I am not sure what to do here, as that seems to be a problem where Android did not support all features of Java 8. Since Mockito 3 targets Java 8, that would be incompatible with older versions of Android.

Can you use Mockito 2 solely for tests running on older versions of Android? =||= > Can you use Mockito 2 solely for tests running on older versions of Android?

No, because this is a compilation error which depends on the minimum supported Android version. Almost every Android project should use Mockito 2 until android 26 will be the ""generally accepted"" minimum sdk supported version (probably in at least 5 years 😄). =||= @francescocervone What I mean is that you have 2 test suites. 1 testsuite for all tests >= 26 and 1 testsuite for all tests <26. For the testsuite >= 26 you can use Mockito 3 + Objenesis 3, as they support Java 8+. For the testsuite <26 you can use Mockito 2 + Objenesis 2, as they support Java 6+. By splitting up the test suites, you can use modern Mockito for modern Android and older Mockito for older Android. That should work right? =||= Also to reiterate, we have introduced Animal Sniffer to ensure we don't break Android again. We set the target to 24 per https://github.com/mockito/mockito/pull/2006/files#diff-c197962302397baf3a4cc36463dce5eaR104 which seemed the most reasonable cut-off for Java 8 support that Mockito 3 relies on. Therefore, rather than having a cut-off at 26, we would be talking about a cut-off at 24. I am not sure when the Android community moves past that cut-off? =||= @TimvdLippe as far as I know you cannot have 2 test suites in the same android project compiling against 2 Android versions. The minimum Android supported version is a property (`minSdkVersion`) defined in the android project's `build.gradle` file through the Android Gradle Plugin.

> I am not sure when the Android community moves past that cut-off? 

Maybe [this chart](https://gs.statcounter.com/android-version-market-share/mobile-tablet/worldwide) can be helpful? In my case, we currently support Android 21 as min SDK. =||= We could try to update Animal Sniffer to level 21 and see what the effect is. If we can make `mockito-core` compatible with that, without introducing breaking changes for the wider Java ecosystem, then I am open to that. However, when @raphw tried that previously, it turned out that a large portion of `mockito-core` was *already* incompatible. This led us to believe that we would have already broken our users and (since we hadn't received complaints before), 24 felt like the best option.

3.5.0 was a big release and a lot of work went into it to support modern Java, which is probably the reason we have hit numerous issues with it. I wonder how many changes in 3.5.0 affect compatibility compared to previous Mockito releases. Could you clone Mockito and try to work out what changes are required to make Mockito compatible with 21? Then we can assess breakages and go from there. =||= Reopening this issue, as I think it is clear by now we are going to need support from developers working in the Android ecosystem on figuring out how to resolve these issues. =||= FYI: at least in my case, the workaround suggested above worked: https://github.com/relaycorp/relaynet-gateway-android/pull/120. But that project doesn't have JVM modules (they're all external deps). We're also supporting API 21+. =||= @TimvdLippe 
>Could you clone Mockito and try to work out what changes are required to make Mockito compatible with 21?

I will. =||= If I remember correctly, types like predicate and function are not available which are part of our public API. This can be fixed but requires breaking public API.  =||= @gnarea , that didn't work for my setup, minSdk = 21:

```
* What went wrong:
Execution failed for task ':app:mergeExtDexDevDebugAndroidTest'.
> Could not resolve all files for configuration ':app:devDebugAndroidTestRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /Users/azizbekian/.gradle/caches/transforms-2/files-2.1/adb8b362b2ccf145263475708478d34b/jetified-objenesis-3.1.jar.
         > Error while dexing.
``` =||= @raphw If I remember correctly, we are already shipping `Optional` and `Function` in our public API prior to 3.5.0. Since Android tests were passing with 3.4.0, I don't think including these symbols in our public API is problematic. Therefore, I don't think we should be changing these types in our API. (This is also what confuses me the most, as to why some parts work and why other parts don't work, even though Animal Sniffer is claiming nothing should in theory work) =||= I'm not an Android expert. `DefineClassHelper` is only used by specific instantiators that are not used in Android. So ideally this class can be excluded from the compilation by Dex it should solve the problem. =||= @TimvdLippe I played a little bit with mockito and the issue I mentioned [in this comment](https://github.com/mockito/mockito/issues/2007#issuecomment-688321579) is solved by adding in the android project's build.gradle:
```gradle
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
```
Android Gradle Plugin 3.0 and higher [supports default interface methods](https://developer.android.com/studio/releases/gradle-plugin#j8-library-desugaring).

---

The objenesis 3.x issue included in `mockito-core` mentioned [here](https://github.com/mockito/mockito/issues/2007#issuecomment-688252464) instead can be avoided by excluding objenesis from `mockito-core` or any library/project depending on `mockito-core`:
```gradle
dependencies {
    androidTestImplementation 'org.mockito:mockito-android:3.5.10'
    androidTestImplementation('org.mockito:mockito-core:3.5.10') {
        exclude group: 'org.objenesis'
    }
    androidTestImplementation(project(':depending-on-mockito-core')) {
        exclude group: 'org.objenesis'
    }
}
```
This workaround is a little bit inconvenient IMHO, but solves the issue. =||= @francescocervone Thanks for the investigation. With regards to your first solution, can we automatically apply that to `mockito-android` or do users of that artifact need to specify it in their `build.gradle`? For the latter, if you solely depend on `mockito-android` you should be good to go. If that is inconvenient, maybe it can be solved in Objenesis 3 instead (not sure if that is possible). =||= @TimvdLippe 
> can we automatically apply that to mockito-android or do users of that artifact need to specify it in their build.gradle?

Users need to specify it in their `build.gradle`.

---

> if you solely depend on mockito-android you should be good to go

True, but I think this ""solution"" is pretty weak. For example, if the project declares [`mockito-kotlin`](https://github.com/nhaarman/mockito-kotlin) dependency, objenesis must be excluded since `mockito-kotlin` depends on `mockito-core`. In general, if the android project depends on some module/project/library depending on `mockito-core`, the workaround must be applied. =||= Again, I'm not sure but can't you just exclude `DefineClassHelper`? That will solve the problem and no need to remove Objenesis. I don't think I can solve it from the Objenesis side. If I can please tell me why? Deploy an objenesis-android excluding these classes will just make everything really messy. =||= @henri-tremblay is there a way to exclude a class from the compilation of a library? How can we exclude `DefineClassHelper`?
Even if we were able to exclude that class: Objenesis is built with Java 8 and it's likely to introduce similar issues in future. This circle will end when one of these classes using some unsupported Java 8 feature, will be part of the Objenesis core and we will not be able to just ""exclude"" it. =||= @TimvdLippe there is a handier workaround for objenesis 3.x, without excluding it from `mockito-core`.
In root `build.gradle` we can add:
```gradle
allprojects {
    configurations.all {
        resolutionStrategy.force 'org.objenesis:objenesis:2.6'
    }
}
``` =||= @francescocervone I don't know. That's why I was saying ""Not an Android expert"" :-) Let me ask around. It's sad to downgrade to Android 2. The other solution would be to split objenesis in 2. One with the core instantiators and one with the exotic ones. Can you hack the objenesis jar to remote this class and just compile with the new jar to tell me if it works? =||= Ok. I had some feedback from @mhausherr. The error is in R8. So we could ignore like this in `proguard-rules.pro`:
```
-assumenosideeffects class org.objenesis.instanciator.util.DefineClassHelper {
    *;
}
``` =||= @henri-tremblay 🤔 It cannot be R8. R8 obfuscates, optimizes and shrinks the code in release builds. It doesn't run in test unless you don't explicitly enable it also for debug builds.
More info here -> https://developer.android.com/studio/build/shrink-code =||= @jakewharton (if I remember correctly, you know a lot more about minification, R8 and problems like this. If that's not the case, please let me know and feel free to ignore this message)

Hey Jake,

Please see the above messages regarding problems with Mockito transitively depending on Objenesis 3 which broke Android compatibility. However, Objenesis compilation broke, despite the class in question not being used in Android tests. As such, the class could be removed with the proguard configuration @henri-tremblay (maintainer of Objenesis) posted.

@francescocervone thinks that is not the appropriate solution, as R8 should not be performing these kind of cleanups.

Sadly I am lacking the knowledge to figure out what is the appropriate solution here and how we can move forward and I had hoped you would be able to help us figuring out.

Thanks in advance for your time and once again, if you prefer not to be involved, feel free to say so and I will try to find another domain expert 😄  =||= @TimvdLippe I didn't say that R8 should not be performing these kind of cleanups. I said that R8 is not involved at all, therefore the R8 rule suggested by @henri-tremblay is not a valid workaround.  =||= @TimvdLippe I created #2053 to fix this issue. With range usage in `strictly` tag, gradle fails to force dependency. I verified with our project. For androidTest, If we just use moctiko-android and exclude mockito-core from mockito-kotlin (or any dependency that has  mockito-core), there shouldnt be any issue. 
This fix still not great but until objenesis supports android sdk < 26, it should work. =||= For anyone who is looking to contribute, please check out the upstream issue at https://github.com/easymock/objenesis/issues/79 =||= I am going to close this issue in favor of https://github.com/easymock/objenesis/issues/79 =||= I have pushed the changes moving some instantiators in a new project. Could you please check if it works? =||= Release 3.2 was done. It should work now. =||= Using version 3.8.0:

```
Execution failed for task ':App:mergeExtDexDebug'.
> Could not resolve all files for configuration ':App:debugRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-transform=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /home/circleci/.gradle/caches/modules-2/files-2.1/org.objenesis/objenesis/3.1/48f12deaae83a8dfc3775d830c9fd60ea59bbbca/objenesis-3.1.jar.
         > Error while dexing.
``` =||= Release 3.2 of _Objenesis_ was done, Mockito still needs to have its dependency updated to 3.2. 

This can be worked around by declaring the Objenesis dependency yourself like `implementation 'org.objenesis:objenesis:3.2` and rely on gradle's dependency resolution to go with the 3.2 version instead of the 3.1 currently included with Mockito =||= @PaulKlauser Do you mind sending us a PR which updates the version? =||= https://github.com/mockito/mockito/pull/2249 =||= Could you consider publishing this to Maven as well? =||= Mockito 3.9.0 should be published to Maven Central: https://github.com/mockito/mockito/runs/2288011033?check_suite_focus=true =||= Thanks! It's still at 3.8.0 on [mvnrepository](https://mvnrepository.com/artifact/org.mockito/mockito-core) and [maven](https://search.maven.org/search?q=a:mockito-core) but I suppose it can take several hours for the change to propagate. =||= Yes these systems take a while to obtain the new information. 3.9.0 is published here: https://repo1.maven.org/maven2/org/mockito/mockito-core/3.9.0/ =||= Just mentioning that I had [this exact crash](https://github.com/mockito/mockito/issues/2007#issuecomment-686925445) and upgrading to 3.9.0 from 3.8.0 fixed it.

 However, it might be worth mentioning that any Android project that is just using `JCenter` as a repository will not return the right information for latest version. Android projects need to begin adding `mavenCentral()` as a repository, which previously was unnecessary because JCenter mirrored Maven Central. That's changing and it's because of this that my particular project didn't recognize the 3.9.0 update.
```
repositories {
    google()
    mavenCentral()  <-- many projects need to add this, explicitly
    jcenter()
    maven { url 'https://jitpack.io' }
}
``` =||= https://blog.gradle.org/jcenter-shutdown =||= ",0
2069,395,"Fixed method name to ""verifyNoMoreInteractions""","> Hey, 
> 
> Thanks for the contribution, this is awesome.
> As you may have read, project members have somehow an opinionated view on what and how should be
> Mockito, e.g. we don't want mockito to be a feature bloat.
> There may be a thorough review, with feedback -> code change loop.
> 
> _This block can be removed_
> _Something wrong in the template fix it here `.github/PULL_REQUEST_TEMPLATE.md`

check list
- [ ] PR should be motivated, i.e. what does it fix, why, and if relevant how
- [ ] If possible / relevant include an example in the description, that could help all readers
     including project members to get a better picture of the change
- [ ] Avoid other runtime dependencies
- [ ] Meaningful commit history ; intention is important please rebase your commit history so that each
     commit is meaningful and help the people that will explore a change in 2 years
- [ ] Read the [contributing guide](https://github.com/mockito/mockito/blob/master/.github/CONTRIBUTING.md)
- [ ] Mention `Fixes #<issue number>` in the description _if relevant_
- [ ] At least one commit should mention `Fixes #<issue number>` _if relevant_","## [Current coverage](https://codecov.io/github/mockito/mockito?ref=be5efdaa7bad8fa06bd1c659a7652ab8d192c4cd) is `86.10%`

> Merging **#395** into **master** will increase coverage by **+0.12%** as of [`be5efda`](https://codecov.io/github/mockito/mockito/commit/be5efdaa7bad8fa06bd1c659a7652ab8d192c4cd)

``` diff
@@            master   #395   diff @@
=====================================
  Files          266    266       
  Stmts         4689   4714    +25
  Branches       759    764     +5
  Methods          0      0       
=====================================
+ Hit           4032   4059    +27
  Partial        167    167       
+ Missed         490    488     -2
```

> Review entire [Coverage Diff](https://codecov.io/github/mockito/mockito/compare/27a375a94026430e7a799c53813be7721700426f...be5efdaa7bad8fa06bd1c659a7652ab8d192c4cd) as of [`be5efda`](https://codecov.io/github/mockito/mockito/commit/be5efdaa7bad8fa06bd1c659a7652ab8d192c4cd)

---

### [Uncovered Suggestions](https://codecov.io/github/mockito/mockito/features/suggestions?ref=be5efdaa7bad8fa06bd1c659a7652ab8d192c4cd)
1. `+0.15%` via [...ializableMethod.java#97...103](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/invocation/SerializableMethod.java?ref=be5efdaa7bad8fa06bd1c659a7652ab8d192c4cd#97) 
2. `+0.11%` via [...ns/PluginLoader.java#60...64](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java?ref=be5efdaa7bad8fa06bd1c659a7652ab8d192c4cd#60) 
3. `+0.11%` via [...lizationSupport.java#122...126](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java?ref=be5efdaa7bad8fa06bd1c659a7652ab8d192c4cd#122) 
4. _[See 7 more...](https://codecov.io/github/mockito/mockito/features/suggestions?ref=be5efdaa7bad8fa06bd1c659a7652ab8d192c4cd)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 =||= I think it is better to group this change together with your other two pull requests. Could you resubmit in 1 commit with the 3 fixes you did? Thanks!
 =||= Tim,

It's done.

On Mon, May 16, 2016 at 4:09 PM, Tim van der Lippe <notifications@github.com

> wrote:
> 
> I think it is better to group this change together with your other two
> pull requests. Could you resubmit in 1 commit with the 3 fixes you did?
> Thanks!
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/395#issuecomment-219434273

## 

Krzysztof Wolny
 =||= ",0
2071,2061,Lambda used as ArgumentMatcher causes decamelized lambda name to appear in error message,"### Version
Mockito version: 3.5.13

### Description
Relates to #1932

When using a lambda or method reference expression as `ArgumentMatcher` and the matcher fails, the error message contains the lambda / method reference class name in ""decamelized"" form which is rather irritating, e.g.:
> myInterface.doSomething(
    <Mockito test$$ lambda$ 4 8/ 0x 0 0 0 0 0 0 0 8 0 0c 8f 4 4 0>
);

Expected would be that similar to anonymous classes the error output says ""\<custom argument matcher\>"". This could probably be achieved by testing for `Class.isSynthetic()` in `org.mockito.internal.matchers.text.MatcherToString.toString(ArgumentMatcher<?>)` before calling `decamelizeMatcher` there.

### Test case
```java
public class MockitoTest {
    interface MyInterface {
        void doSomething(String s);
    }
    
    private static boolean matches(String s) {
        return false;
    }
    
    public static void main(String[] args) {
        MyInterface mock = mock(MyInterface.class);
        try {
            verify(mock).doSomething(argThat(arg -> false));
        } catch (Error e) {
            e.printStackTrace();
        }
        try {
            verify(mock).doSomething(argThat(MockitoTest::matches));
        } catch (Error e) {
            e.printStackTrace();
        }
        
        // When an anonymous class is used the output is '<custom argument matcher>'
        // (as expected)
        verify(mock).doSomething(argThat(new ArgumentMatcher<>() {
            @Override
            public boolean matches(String argument) {
                return false;
            }
        }));
    }
}
```","> This could probably be achieved by testing for Class.isSynthetic() in

Sounds like a good idea. Do you want to submit a PR? Thanks! =||= Sorry for the delay, have submitted the pull request: #2071
Feedback is appreciated! =||= ",0
2071,206,NoJUnitDependenciesTest is failing on Windows machine.,"I found NoJUnitDependenciesTest unit test is the only unit test that fails when you run the build on windows machine (I have also Ubuntu, and it is fine for some reason on Unix platform).

Root cause: Caused by: java.lang.NoClassDefFoundError: org\mockito\internal\invocation\InvocationMarker (wrong name: org/mockito/internal/invocation/InvocationMarker)

Full Stacktrace:

java.lang.AssertionError: 'org\mockito\internal\invocation\InvocationMarker' has some dependency to JUnit
    at org.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:36)
    at org.mockitointegration.NoJUnitDependenciesTest.pure_mockito_should_not_depend_JUnit(NoJUnitDependenciesTest.java:28)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:86)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:49)
    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)
    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:48)
    at sun.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:105)
    at sun.reflect.GeneratedMethodAccessor36.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:360)
    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:64)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:722)
Caused by: java.lang.NoClassDefFoundError: org\mockito\internal\invocation\InvocationMarker (wrong name: org/mockito/internal/invocation/InvocationMarker)
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:791)
    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
    at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
    at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at org.mockitoutil.ClassLoaders$LocalExcludingURLClassLoader.findClass(ClassLoaders.java:156)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:423)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:356)
    at java.lang.Class.forName0(Native Method)
    at java.lang.Class.forName(Class.java:266)
    at org.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:34)
    ... 41 more","Hi,

Thanks for reporting, I don't own a Windows box, so I don't know if I will fix this one asap.
This has probably something to do with the path, that's the only thing that come to me at that time.
 =||= I reproduced problem and found solution - in a sec I will create PR
 =||= ",0
2084,2083,Issue with Bundle-Version manifest header when used in Eclipse PDE development,"The MANIFEST.MF currently contains e.g.: `Bundle-version: 3.6.0`

Due to the lowercase 'v' this appears to not be properly recognised by Eclipse PDE so is giving me errors on min versioned require bundle directives.

The standard headers at  https://www.osgi.org/bundle-headers-reference/ define it as `Bundle-Version` (capital V).

After a small amount of research it looks like OSGi specification possibly does accept case insensitive headers but haven't found definitive source.

In any case, changing it would keep it consistant with the other headers.","Seems like we hit this issue after we fixed an initial typo in #2070. Do you mind sending a PR to change it to a capital V? =||= Done, thanks for quick response! =||= ",0
2096,209,Mocks are not injected in Spring AOP proxies,"Mocks are not injected in fields that are Spring AOP proxies. To solve it you can modify PropertyAndSetterInjection:

```
public boolean processInjection(Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {
    // Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);
    FieldInitializationReport report = initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);

    // for each field in the class hierarchy
    boolean injectionOccurred = false;
    Class<?> fieldClass = report.fieldClass();
    Object fieldInstanceNeedingInjection = report.fieldInstance();
    // Unwrap proxy to allow field injection
    fieldInstanceNeedingInjection = unwrapProxy(fieldInstanceNeedingInjection);
    fieldClass = fieldInstanceNeedingInjection.getClass();
    while (fieldClass != Object.class) {
        injectionOccurred |= injectMockCandidates(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);
        fieldClass = fieldClass.getSuperclass();
    }
    return injectionOccurred;
}

public static Object unwrapProxy(Object bean) {
    if (AopUtils.isAopProxy(bean) && bean instanceof Advised) {
        Advised advised = (Advised) bean;
        try {
            bean = advised.getTargetSource().getTarget();
        } catch (Exception e) {
            LOG.error(""Exception unwrapping proxy object"", e);
        }
    }
    return bean;
}
```","Hi,

Thanks for providing a solution however we won't include Spring specific code in mockito.
This seems to be a problem quite specific to how is the test crafted. This is probably wrong to create an object then inject mocks (then overriding exisiting wired dependencies), a better approach would probably be to let spring wire the mocks.
 =||= FYI, I've run into this too and have filed an upstream issue with Spring:

https://jira.spring.io/browse/SPR-14083
 =||= I have also run into this issue, and while it is rare, rewriting the test to no use `@InjectMocks` does make the configuration quite a bit more verbose. It appears like the fundamental flaw in the injection filtering is that there is an assumption that there is a one-to-one between a field and a getter/setter pair. When a proxy is in usage, particularly a CGLIB proxy, this is obviously not the case.

A solution could be provided that did not couple to Spring, but I believe it would require adjusting the filtering strategy for setter injection to find candidate injectables but setter method declaration, not field declaration.
 =||= You can use the new Spring Boot feature - http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-mocking-beans
 =||= ",0
2101,209,Mocks are not injected in Spring AOP proxies,"Mocks are not injected in fields that are Spring AOP proxies. To solve it you can modify PropertyAndSetterInjection:

```
public boolean processInjection(Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {
    // Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);
    FieldInitializationReport report = initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);

    // for each field in the class hierarchy
    boolean injectionOccurred = false;
    Class<?> fieldClass = report.fieldClass();
    Object fieldInstanceNeedingInjection = report.fieldInstance();
    // Unwrap proxy to allow field injection
    fieldInstanceNeedingInjection = unwrapProxy(fieldInstanceNeedingInjection);
    fieldClass = fieldInstanceNeedingInjection.getClass();
    while (fieldClass != Object.class) {
        injectionOccurred |= injectMockCandidates(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);
        fieldClass = fieldClass.getSuperclass();
    }
    return injectionOccurred;
}

public static Object unwrapProxy(Object bean) {
    if (AopUtils.isAopProxy(bean) && bean instanceof Advised) {
        Advised advised = (Advised) bean;
        try {
            bean = advised.getTargetSource().getTarget();
        } catch (Exception e) {
            LOG.error(""Exception unwrapping proxy object"", e);
        }
    }
    return bean;
}
```","Hi,

Thanks for providing a solution however we won't include Spring specific code in mockito.
This seems to be a problem quite specific to how is the test crafted. This is probably wrong to create an object then inject mocks (then overriding exisiting wired dependencies), a better approach would probably be to let spring wire the mocks.
 =||= FYI, I've run into this too and have filed an upstream issue with Spring:

https://jira.spring.io/browse/SPR-14083
 =||= I have also run into this issue, and while it is rare, rewriting the test to no use `@InjectMocks` does make the configuration quite a bit more verbose. It appears like the fundamental flaw in the injection filtering is that there is an assumption that there is a one-to-one between a field and a getter/setter pair. When a proxy is in usage, particularly a CGLIB proxy, this is obviously not the case.

A solution could be provided that did not couple to Spring, but I believe it would require adjusting the filtering strategy for setter injection to find candidate injectables but setter method declaration, not field declaration.
 =||= You can use the new Spring Boot feature - http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-mocking-beans
 =||= ",0
2103,209,Mocks are not injected in Spring AOP proxies,"Mocks are not injected in fields that are Spring AOP proxies. To solve it you can modify PropertyAndSetterInjection:

```
public boolean processInjection(Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {
    // Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);
    FieldInitializationReport report = initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);

    // for each field in the class hierarchy
    boolean injectionOccurred = false;
    Class<?> fieldClass = report.fieldClass();
    Object fieldInstanceNeedingInjection = report.fieldInstance();
    // Unwrap proxy to allow field injection
    fieldInstanceNeedingInjection = unwrapProxy(fieldInstanceNeedingInjection);
    fieldClass = fieldInstanceNeedingInjection.getClass();
    while (fieldClass != Object.class) {
        injectionOccurred |= injectMockCandidates(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);
        fieldClass = fieldClass.getSuperclass();
    }
    return injectionOccurred;
}

public static Object unwrapProxy(Object bean) {
    if (AopUtils.isAopProxy(bean) && bean instanceof Advised) {
        Advised advised = (Advised) bean;
        try {
            bean = advised.getTargetSource().getTarget();
        } catch (Exception e) {
            LOG.error(""Exception unwrapping proxy object"", e);
        }
    }
    return bean;
}
```","Hi,

Thanks for providing a solution however we won't include Spring specific code in mockito.
This seems to be a problem quite specific to how is the test crafted. This is probably wrong to create an object then inject mocks (then overriding exisiting wired dependencies), a better approach would probably be to let spring wire the mocks.
 =||= FYI, I've run into this too and have filed an upstream issue with Spring:

https://jira.spring.io/browse/SPR-14083
 =||= I have also run into this issue, and while it is rare, rewriting the test to no use `@InjectMocks` does make the configuration quite a bit more verbose. It appears like the fundamental flaw in the injection filtering is that there is an assumption that there is a one-to-one between a field and a getter/setter pair. When a proxy is in usage, particularly a CGLIB proxy, this is obviously not the case.

A solution could be provided that did not couple to Spring, but I believe it would require adjusting the filtering strategy for setter injection to find candidate injectables but setter method declaration, not field declaration.
 =||= You can use the new Spring Boot feature - http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-mocking-beans
 =||= ",0
2109,2108,JarInputStream fails to get Manifest from published mockito-core,"Using mockito-core in a JPMS based gradle build fails due to a known but odd behaviour of JarInputStream. The latter only provides access to the Jar's manifest if it is the 1st or 2nd entry in the Jar. As discussed in:

* https://bugs.openjdk.java.net/browse/JDK-8031748
* https://bugs.openjdk.java.net/browse/JDK-8211917

As gradle uses the JarInputStream to get the manifest and to determine whether the Automatic-Module-Name attribute is set, it fails to add mockito-core to the module path (see GRADLE [#15270](https://github.com/gradle/gradle/issues/15270). Same issue was observed for Quarkus [#5399](https://github.com/quarkusio/quarkus/issues/5399). The attached example code [example.zip](https://github.com/mockito/mockito/files/5585881/example.zip) shows this issue.

An optimal solution would be to make sure the manifest file is kept at the Jar's beginning during the publication process.

Used versions:
* mockito-core-3.6.0.jar
* java version ""11.0.6"" 2020-01-14 LTS 
Java(TM) SE Runtime Environment 18.9 (build 11.0.6+8-LTS)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.6+8-LTS, mixed mode)","@mockitoguy might be able to provide more insight, but I think we create our Jar on this line: https://github.com/mockito/mockito/blob/78b22fcf814c33e87585afed387cd9db0b6d36a5/gradle/java-publication.gradle#L32

We would welcome PRs for this issue. Hopefully the link provides enough context to figure out how to resolve the problem? =||= The commit message for fde5abb includes [ci maven-central-release] - should this cause a release to be published to maven central?
I can't see a new release there at the moment, not sure if there is usually a delay? =||= It should have, but it seems like it incorrectly concluded it didn't include the message. Filed #2110 =||= On it. =||= ",0
2124,1671,Unable to migrate from Mockito 2.23.4 to 2.24.x or 2.25.x,"Hi,
while trying to upgrade mockito from 2.23.4 to 2.24 or 2.25, whe have tge following error :

```
testXXXs(xxx.TestXXX)  Time elapsed: 0.093 s  <<< ERROR!
org.mockito.exceptions.base.MockitoException: 

Mockito cannot mock this class: interface org.springframework.security.core.context.SecurityContext.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 1.8
JVM vendor name    : Oracle Corporation
JVM vendor version : 25.161-b12
JVM name           : Java HotSpot(TM) 64-Bit Server VM
JVM version        : 1.8.0_161-b12
JVM info           : mixed mode
OS name            : Windows 7
OS version         : 6.1


Underlying exception : java.lang.IllegalArgumentException: Could not create type
	at testXXXs(xxx.TestXXX).java:66)
Caused by: java.lang.IllegalArgumentException: Could not create type
	at testXXXs(xxx.TestXXX).java:66)
Caused by: java.lang.NoSuchMethodError: net.bytebuddy.dynamic.loading.MultipleParentClassLoader$Builder.appendMostSpecific(Ljava/util/Collection;)Lnet/bytebuddy/dynamic/loading/MultipleParentClassLoader$Builder;
	at testXXXs(xxx.TestXXX).java:66)
```

In the java code the error is here (line 66):
```
// Mock for SpringContext
SecurityContext securityContext = Mockito.mock(SecurityContext.class);
```

Many thanks for your help,

Marc ",Closing as duplicate of #1606. You need to use a more recent version of ByteBuddy. =||= ,0
2126,1442,NPE occurs when the same type of ArgumentMatcher is used more than once," - [x] The mockito message in the stacktrace have useful information, but it didn't help
 - [x] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [x] Provide versions (mockito / jdk / os / any other relevant information)
 - [x] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/master/.github/CONTRIBUTING.md)

Hi,

I report an NPE issue.
The case is when the same type of `ArgumentMatcher` is used more than once in a test.
It happens with `when`.`thenReturn`, but not with `doReturn`.`when`.
Is it a know issue?
I'm recently reading the Mockito docs carefully but couldn't find anything about this case.
Please check the following test case and log.

```Java
private final class ContainsFoo implements ArgumentMatcher<String> { // Line 25
    public boolean matches(String arg) {
        return arg.contains(""foo""); // Line 27
    }
}

private final class ContainsBar implements ArgumentMatcher<String> {
    public boolean matches(String arg) {
        return arg.contains(""bar"");
    }
}

@Test
public void foobarTest() {
    // NPE occurs
    when(mock.oneArg(argThat(new ContainsFoo()))).thenReturn(""foo"");
    when(mock.oneArg(argThat(new ContainsBar()))).thenReturn(""bar""); // Line 41

    // Works fine
    // doReturn(""foo"").when(mock).oneArg(argThat(new ContainsFoo()));
    // doReturn(""bar"").when(mock).oneArg(argThat(new ContainsBar()));

    assertEquals(""foo"", mock.oneArg(""foo""));
    assertEquals(""bar"", mock.oneArg(""bar""));
}
```
```Java
java.lang.NullPointerException
	at org.mockitousage.matchers.CustomMatchersTest$ContainsFoo.matches(CustomMatchersTest.java:27)
	at org.mockitousage.matchers.CustomMatchersTest$ContainsFoo.matches(CustomMatchersTest.java:25)
	at org.mockito.internal.invocation.TypeSafeMatching.apply(TypeSafeMatching.java:24)
	at org.mockito.internal.invocation.MatcherApplicationStrategy.forEachMatcherAndArgument(MatcherApplicationStrategy.java:83)
	at org.mockito.internal.invocation.InvocationMatcher.argumentsMatch(InvocationMatcher.java:152)
	at org.mockito.internal.invocation.InvocationMatcher.matches(InvocationMatcher.java:81)
	at org.mockito.internal.stubbing.InvocationContainerImpl.findAnswerFor(InvocationContainerImpl.java:85)
	at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:90)
	at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
	at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:35)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:63)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:49)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:128)
	at org.mockitousage.IMethods$MockitoMock$1726084737.oneArg(Unknown Source)
	at org.mockitousage.matchers.CustomMatchersTest.foobarTest(CustomMatchersTest.java:41)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
```

Thanks,
Sangwoo","Your matcher implementation needs to handle null because matcher cannot assume that the ""arg"" will never be null.

You're getting an NPE because ""when().then()"" syntax actually invokes the stubbed method. It's a caveat of the API. In your second stubbing, you actually call method 'oneArg' that triggers the first stubbing to be evaluated. 1st stubbing has a matcher that does not handle nulls properly. All argument matching methods such as 'argThat' return null.

Hope that explanation makes sense! There's nothing we can fix about it. =||= Thanks @mockitoguy for the explanation!
Now I understand a little bit how stubbing works.
I'm closing it.
Thanks! =||= ",0
2126,2316,Mockito 3.11.0 seems to fail in Android instrumentation tests,"After upgrading from 3.10.0 to 3.11.0, our instrumentation tests started failing with a strange error about Mockito plugins:
```
java.lang.IllegalStateException: Could not initialize plugin: interface org.mockito.plugins.MockMaker (alternate: null)
	at org.mockito.internal.configuration.plugins.PluginLoader$1.invoke(PluginLoader.java:84)
	at java.lang.reflect.Proxy.invoke(Proxy.java:1006)
	at $Proxy12.isTypeMockable(Unknown Source)
	at org.mockito.internal.util.MockUtil.typeMockabilityOf(MockUtil.java:33)
	at org.mockito.internal.util.MockCreationValidator.validateType(MockCreationValidator.java:22)
	at org.mockito.internal.creation.MockSettingsImpl.validatedSettings(MockSettingsImpl.java:250)
	at org.mockito.internal.creation.MockSettingsImpl.build(MockSettingsImpl.java:232)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:83)
	at org.mockito.Mockito.mock(Mockito.java:1954)
	at org.mockito.Mockito.mock(Mockito.java:1865)
	at com.blueapron.service.mock.ServiceTestApplication$1.mock(ServiceTestApplication.java:29)
	at com.blueapron.testcommon.StaticMock.provide(StaticMock.java:42)
	at com.blueapron.service.mock.InstrumentAppModule.provideClock_impl(InstrumentAppModule.java:55)
	at com.blueapron.service.dagger.ApplicationModule.provideClock(ApplicationModule.java:230)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.provideClock(ApplicationModule_ProvideClockFactory.java:35)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.get(ApplicationModule_ProvideClockFactory.java:27)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.get(ApplicationModule_ProvideClockFactory.java:9)
	at dagger.internal.DoubleCheck.get(DoubleCheck.java:47)
	at com.blueapron.service.mock.DaggerInstrumentApplicationComponent.injectTimeUtils(DaggerInstrumentApplicationComponent.java:653)
	at com.blueapron.service.mock.DaggerInstrumentApplicationComponent.inject(DaggerInstrumentApplicationComponent.java:345)
	at com.blueapron.marinator.generated.MarinadeHelper.inject(MarinadeHelper.java:254)
	at com.blueapron.marinator.Marinator.inject(Marinator.java:50)
	at com.blueapron.service.util.TimeUtils.<init>(TimeUtils.java:34)
	at com.blueapron.service.util.TimeUtils.getInstance(TimeUtils.java:40)
	at com.blueapron.service.util.TimeUtils.getClock(TimeUtils.java:47)
	at com.blueapron.service.BaseInstrumentationTest.setDateForTest(BaseInstrumentationTest.java:54)
	at com.blueapron.service.BaseInstrumentationTest.initBase(BaseInstrumentationTest.java:71)
	at java.lang.reflect.Method.invoke(Native Method)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at androidx.test.internal.runner.junit4.statement.RunBefores.evaluate(RunBefores.java:76)
	at androidx.test.internal.runner.junit4.statement.RunAfters.evaluate(RunAfters.java:61)
	at com.blueapron.testcommon.FlakyTestRule$1.evaluate(FlakyTestRule.java:30)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:61)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at androidx.test.ext.junit.runners.AndroidJUnit4.run(AndroidJUnit4.java:154)
	at org.junit.runners.Suite.runChild(Suite.java:128)
	at org.junit.runners.Suite.runChild(Suite.java:27)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
	at androidx.test.internal.runner.TestExecutor.execute(TestExecutor.java:56)
	at androidx.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:395)
	at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2189)
Caused by: java.lang.IllegalStateException: Failed to load interface org.mockito.plugins.MockMaker implementation declared in sun.misc.CompoundEnumeration@f915e73
	at org.mockito.internal.configuration.plugins.PluginInitializer.loadImpl(PluginInitializer.java:57)
	at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:65)
	at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:50)
	at org.mockito.internal.configuration.plugins.PluginRegistry.<init>(PluginRegistry.java:26)
	at org.mockito.internal.configuration.plugins.Plugins.<clinit>(Plugins.java:20)
	at org.mockito.internal.configuration.plugins.Plugins.getMockMaker(Plugins.java:36)
	at org.mockito.internal.util.MockUtil.<clinit>(MockUtil.java:28)
	... 59 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.lang.reflect.Constructor.newInstance0(Native Method)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:343)
	at org.mockito.internal.configuration.plugins.PluginInitializer.loadImpl(PluginInitializer.java:52)
	... 65 more
Caused by: java.lang.IllegalStateException: Failed to resolve the class file version of the current VM: This JVM's version string does not seem to be valid: 0
	at net.bytebuddy.ClassFileVersion$VersionLocator$Unresolved.resolve(ClassFileVersion.java:558)
	at net.bytebuddy.ClassFileVersion.ofThisVm(ClassFileVersion.java:276)
	at net.bytebuddy.description.method.ParameterList$ForLoadedExecutable.of(ParameterList.java:205)
	at net.bytebuddy.description.method.MethodDescription$ForLoadedMethod.getParameters(MethodDescription.java:1179)
	at net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.compile(TargetMethodAnnotationDrivenBinder.java:82)
	at net.bytebuddy.implementation.MethodDelegation$ImplementationDelegate$ForStaticMethod.of(MethodDelegation.java:948)
	at net.bytebuddy.implementation.MethodDelegation$WithCustomProperties.to(MethodDelegation.java:1512)
	at net.bytebuddy.implementation.MethodDelegation$WithCustomProperties.to(MethodDelegation.java:1493)
	at net.bytebuddy.implementation.MethodDelegation.to(MethodDelegation.java:271)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.<init>(SubclassBytecodeGenerator.java:63)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.<init>(SubclassBytecodeGenerator.java:73)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.<init>(SubclassByteBuddyMockMaker.java:37)
	at org.mockito.android.internal.creation.AndroidByteBuddyMockMaker.<init>(AndroidByteBuddyMockMaker.java:22)
	... 68 more
```

It looks like something may not *quite* play nicely with the Android ByteBuddy MockMaker in the newest versions?

In our instrumentation tests, we're using `androidTestImplementation org.mockito:mockito-android:3.11.0`. Our unit tests using `testImplementation org:mockito:mockito-core:3.11.0` appear to be working just fine, which is why I suspect something is off in the Android specific implementation.

I'm not sure how best to debug this further - is there additional information that would be useful?","This is most likely https://github.com/raphw/byte-buddy/commit/f20b8362bad45ab45133264394c4573cc4850300 which was included in ByteBuddy 1.11.1 which we rolled into Mockito 3.11.0.

What is the value of `java.version` when you run your tests? =||= I'm not 100% which value you're looking for - feels like it should be a simple question, but I'm just not sure I'm quite parsing it. Can you clarify a little? (Maybe I just haven't had enough coffee today!)

The JVM version is 11, if that's what you're looking for:
```
$ java -version
Picked up _JAVA_OPTIONS: -Dapple.awt.UIElement=true
openjdk version ""11.0.8"" 2020-07-14
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.8+10)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.8+10, mixed mode)
``` =||= Ah I was referring to the `java.version` System property that is retrieved here: https://github.com/raphw/byte-buddy/commit/f20b8362bad45ab45133264394c4573cc4850300#diff-3038b635c974b9bfe4d1cbeef13bbe83c7bd779479bcde42d4f429d2481b5202R490 It appears from the exception that this value is `0`, which is not a valid Java version. =||= Ah, gotcha - that is coming back as ""0"" which confirms your hypothesis. And that definitely explains the behavior! I'm not sure *why* this value is ""0"", though, or whether that's a bug in the byte buddy stack or a configuration problem somehow. =||= @raphw Should we consider relaxing the check in `public VersionLocator run` to return `VersionLocator.ForLegacyVm.INSTANCE` for Android versions that run `mockito-android`? =||= I faced with the same error, how I can fix it? =||= I changed the version resolution to be done within the class initializer rather then on the first call. I wonder if there's a confusion. Could somebody provide me with the value of `System.getProperty(""java.version"")` on Android, both being called from a static initializer and from a regular method? Ideally in one of these failing scenarios. =||= I fixed the issue on master and will release a new version of Byte Buddy. The problem is that the `java.version` property is set to `0` on Android what the parser did not expect. I improved the mechanism to no longer rely on the version on the place where the exception occurs and added a version fallback everywhere else. I also added an explicit version resolution if the version is set to `0`. =||= Mockito 3.11.1 is being published to Maven Central and should solve this issue. =||= ",0
2126,2159,Mockito published maven artifact is missing .module files,"Around Gradle 5.3 new Gradle metadata was introduced (see https://docs.gradle.org/current/userguide/publishing_gradle_module_metadata.html) This allows Gradle builds to publish more detail about dependencies than the lagacy maven pom.

Mockito is generating those files, but they aren't getting uploaded to Maven Central see: https://repo1.maven.org/maven2/org/mockito/mockito-junit-jupiter/3.6.28/

However in the [pom.xml](https://repo1.maven.org/maven2/org/mockito/mockito-junit-jupiter/3.6.28/mockito-junit-jupiter-3.6.28.pom) it contains the comment that tells Gradle to check for the `.module` files:

```
<!--
 This module was also published with a richer model, Gradle metadata,  
-->
<!--
 which should be used instead. Do not delete the following line which  
-->
<!--
 is to indicate to Gradle or any Gradle module metadata file consumer  
-->
<!-- that they should prefer consuming it instead. -->
<!-- do_not_remove: published-with-gradle-metadata -->
```

## Solution 1 [Disable metadata](https://docs.gradle.org/current/userguide/publishing_gradle_module_metadata.html#sub:disabling-gmm-publication ): 

This will remove the comment from the pom.xml and so Gradle won't continue to check for the `.module` file.

```
    tasks.withType<GenerateModuleMetadata> {
        enabled = false
    }
```

## Solution 2- Update the maven publishing to include the missing files

This is the better long-term solution. However I don't have a direct recommendation since I don't have experience in that regard and don't know what is mis-configured.


## Why hasn't this been a problem before?

When using `mavenCentral()` as a repo directly, it serves up a 404 for the missing `.module` file and Gradle recovers fine. However when using an internal repository like Artifactory, it is common to configure it to return `403` for missing files to try to obscure data that shouldn't be accessible.

So to reproduce this you would need to use Gradle > 5.3, Using Mockito as a dependency, when using a locked down Maven repository that is configured to serve 403 instead of exposing 404 for missing artifacts.",nan,0
2126,1743,"Clarify Javadoc of RETURNS_SMART_NULLS, default answer in Mockito 3.0.0?","[Javadoc for Mockito.RETURNS_SMART_NULLS](https://static.javadoc.io/org.mockito/mockito-core/3.0.0/org/mockito/Mockito.html#RETURNS_SMART_NULLS) in version 3.0.0 still says:

> ReturnsSmartNulls will be probably the default return values strategy in Mockito 3.0.0

As Mockito 3.0.0 has been released this could now be clarified. I see #971 is still open, so it looks like the default answer has not been changed?","Yes that should be updated to 4.0.0 now, as we decided not to make any API changes in 3.0.0. =||= ",0
2126,2316,Mockito 3.11.0 seems to fail in Android instrumentation tests,"After upgrading from 3.10.0 to 3.11.0, our instrumentation tests started failing with a strange error about Mockito plugins:
```
java.lang.IllegalStateException: Could not initialize plugin: interface org.mockito.plugins.MockMaker (alternate: null)
	at org.mockito.internal.configuration.plugins.PluginLoader$1.invoke(PluginLoader.java:84)
	at java.lang.reflect.Proxy.invoke(Proxy.java:1006)
	at $Proxy12.isTypeMockable(Unknown Source)
	at org.mockito.internal.util.MockUtil.typeMockabilityOf(MockUtil.java:33)
	at org.mockito.internal.util.MockCreationValidator.validateType(MockCreationValidator.java:22)
	at org.mockito.internal.creation.MockSettingsImpl.validatedSettings(MockSettingsImpl.java:250)
	at org.mockito.internal.creation.MockSettingsImpl.build(MockSettingsImpl.java:232)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:83)
	at org.mockito.Mockito.mock(Mockito.java:1954)
	at org.mockito.Mockito.mock(Mockito.java:1865)
	at com.blueapron.service.mock.ServiceTestApplication$1.mock(ServiceTestApplication.java:29)
	at com.blueapron.testcommon.StaticMock.provide(StaticMock.java:42)
	at com.blueapron.service.mock.InstrumentAppModule.provideClock_impl(InstrumentAppModule.java:55)
	at com.blueapron.service.dagger.ApplicationModule.provideClock(ApplicationModule.java:230)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.provideClock(ApplicationModule_ProvideClockFactory.java:35)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.get(ApplicationModule_ProvideClockFactory.java:27)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.get(ApplicationModule_ProvideClockFactory.java:9)
	at dagger.internal.DoubleCheck.get(DoubleCheck.java:47)
	at com.blueapron.service.mock.DaggerInstrumentApplicationComponent.injectTimeUtils(DaggerInstrumentApplicationComponent.java:653)
	at com.blueapron.service.mock.DaggerInstrumentApplicationComponent.inject(DaggerInstrumentApplicationComponent.java:345)
	at com.blueapron.marinator.generated.MarinadeHelper.inject(MarinadeHelper.java:254)
	at com.blueapron.marinator.Marinator.inject(Marinator.java:50)
	at com.blueapron.service.util.TimeUtils.<init>(TimeUtils.java:34)
	at com.blueapron.service.util.TimeUtils.getInstance(TimeUtils.java:40)
	at com.blueapron.service.util.TimeUtils.getClock(TimeUtils.java:47)
	at com.blueapron.service.BaseInstrumentationTest.setDateForTest(BaseInstrumentationTest.java:54)
	at com.blueapron.service.BaseInstrumentationTest.initBase(BaseInstrumentationTest.java:71)
	at java.lang.reflect.Method.invoke(Native Method)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at androidx.test.internal.runner.junit4.statement.RunBefores.evaluate(RunBefores.java:76)
	at androidx.test.internal.runner.junit4.statement.RunAfters.evaluate(RunAfters.java:61)
	at com.blueapron.testcommon.FlakyTestRule$1.evaluate(FlakyTestRule.java:30)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:61)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at androidx.test.ext.junit.runners.AndroidJUnit4.run(AndroidJUnit4.java:154)
	at org.junit.runners.Suite.runChild(Suite.java:128)
	at org.junit.runners.Suite.runChild(Suite.java:27)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
	at androidx.test.internal.runner.TestExecutor.execute(TestExecutor.java:56)
	at androidx.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:395)
	at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2189)
Caused by: java.lang.IllegalStateException: Failed to load interface org.mockito.plugins.MockMaker implementation declared in sun.misc.CompoundEnumeration@f915e73
	at org.mockito.internal.configuration.plugins.PluginInitializer.loadImpl(PluginInitializer.java:57)
	at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:65)
	at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:50)
	at org.mockito.internal.configuration.plugins.PluginRegistry.<init>(PluginRegistry.java:26)
	at org.mockito.internal.configuration.plugins.Plugins.<clinit>(Plugins.java:20)
	at org.mockito.internal.configuration.plugins.Plugins.getMockMaker(Plugins.java:36)
	at org.mockito.internal.util.MockUtil.<clinit>(MockUtil.java:28)
	... 59 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.lang.reflect.Constructor.newInstance0(Native Method)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:343)
	at org.mockito.internal.configuration.plugins.PluginInitializer.loadImpl(PluginInitializer.java:52)
	... 65 more
Caused by: java.lang.IllegalStateException: Failed to resolve the class file version of the current VM: This JVM's version string does not seem to be valid: 0
	at net.bytebuddy.ClassFileVersion$VersionLocator$Unresolved.resolve(ClassFileVersion.java:558)
	at net.bytebuddy.ClassFileVersion.ofThisVm(ClassFileVersion.java:276)
	at net.bytebuddy.description.method.ParameterList$ForLoadedExecutable.of(ParameterList.java:205)
	at net.bytebuddy.description.method.MethodDescription$ForLoadedMethod.getParameters(MethodDescription.java:1179)
	at net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.compile(TargetMethodAnnotationDrivenBinder.java:82)
	at net.bytebuddy.implementation.MethodDelegation$ImplementationDelegate$ForStaticMethod.of(MethodDelegation.java:948)
	at net.bytebuddy.implementation.MethodDelegation$WithCustomProperties.to(MethodDelegation.java:1512)
	at net.bytebuddy.implementation.MethodDelegation$WithCustomProperties.to(MethodDelegation.java:1493)
	at net.bytebuddy.implementation.MethodDelegation.to(MethodDelegation.java:271)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.<init>(SubclassBytecodeGenerator.java:63)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.<init>(SubclassBytecodeGenerator.java:73)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.<init>(SubclassByteBuddyMockMaker.java:37)
	at org.mockito.android.internal.creation.AndroidByteBuddyMockMaker.<init>(AndroidByteBuddyMockMaker.java:22)
	... 68 more
```

It looks like something may not *quite* play nicely with the Android ByteBuddy MockMaker in the newest versions?

In our instrumentation tests, we're using `androidTestImplementation org.mockito:mockito-android:3.11.0`. Our unit tests using `testImplementation org:mockito:mockito-core:3.11.0` appear to be working just fine, which is why I suspect something is off in the Android specific implementation.

I'm not sure how best to debug this further - is there additional information that would be useful?","This is most likely https://github.com/raphw/byte-buddy/commit/f20b8362bad45ab45133264394c4573cc4850300 which was included in ByteBuddy 1.11.1 which we rolled into Mockito 3.11.0.

What is the value of `java.version` when you run your tests? =||= I'm not 100% which value you're looking for - feels like it should be a simple question, but I'm just not sure I'm quite parsing it. Can you clarify a little? (Maybe I just haven't had enough coffee today!)

The JVM version is 11, if that's what you're looking for:
```
$ java -version
Picked up _JAVA_OPTIONS: -Dapple.awt.UIElement=true
openjdk version ""11.0.8"" 2020-07-14
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.8+10)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.8+10, mixed mode)
``` =||= Ah I was referring to the `java.version` System property that is retrieved here: https://github.com/raphw/byte-buddy/commit/f20b8362bad45ab45133264394c4573cc4850300#diff-3038b635c974b9bfe4d1cbeef13bbe83c7bd779479bcde42d4f429d2481b5202R490 It appears from the exception that this value is `0`, which is not a valid Java version. =||= Ah, gotcha - that is coming back as ""0"" which confirms your hypothesis. And that definitely explains the behavior! I'm not sure *why* this value is ""0"", though, or whether that's a bug in the byte buddy stack or a configuration problem somehow. =||= @raphw Should we consider relaxing the check in `public VersionLocator run` to return `VersionLocator.ForLegacyVm.INSTANCE` for Android versions that run `mockito-android`? =||= I faced with the same error, how I can fix it? =||= I changed the version resolution to be done within the class initializer rather then on the first call. I wonder if there's a confusion. Could somebody provide me with the value of `System.getProperty(""java.version"")` on Android, both being called from a static initializer and from a regular method? Ideally in one of these failing scenarios. =||= I fixed the issue on master and will release a new version of Byte Buddy. The problem is that the `java.version` property is set to `0` on Android what the parser did not expect. I improved the mechanism to no longer rely on the version on the place where the exception occurs and added a version fallback everywhere else. I also added an explicit version resolution if the version is set to `0`. =||= Mockito 3.11.1 is being published to Maven Central and should solve this issue. =||= ",0
2126,2325,Fixes #2311 : print the fully qualified class names.,"<!-- Hey,
Thanks for the contribution, this is awesome.
As you may have read, project members have somehow an opinionated view on what and how should be
Mockito, e.g. we don't want mockito to be a feature bloat.
There may be a thorough review, with feedback -> code change loop.
-->
<!--
If you have a suggestion for this template you can fix it in the .github/PULL_REQUEST_TEMPLATE.md file
-->
## Checklist

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/main/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [x] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_

-. replace getName() with getSimpleName() ","We no longer use the `release/3.x` branch, so #2320 suffices for now. I think I will have a chance tomorrow to review the PR. =||= I'm just showing that I'm a complete beginner.
Using the release branch for PR... I'm sorry for wasting your time. =||= Don't worry about it, our branch naming was confusing! It's an easy mistake to make, so no worries at all 😄  =||= thank you~ :) =||= ",0
2126,2303,"""The type is not public and its mock class is loaded by a different class loader"" with a context classloader that delegates","Repro case:
```java
package com.google.clm.mockitobug;

import static org.mockito.Mockito.mock;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * My goal is to create a context classloader that is identical in every way to the existing one,
 * except that it has a different object identity and possibly some extra fields. However, even a
 * basic classloader that always delegates causes problems for mockito.
 */
@RunWith(JUnit4.class)
public final class ClassLoaderTest {

  @Test
  public void mockPackagePrivateInterface() {
    ClassLoader old = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(new ClassLoader(old) {});
    // fails
    Object unused = mock(PackagePrivate.class);
  }

  @Test
  public void mockPublicInterface() {
    ClassLoader old = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(new ClassLoader(old) {});
    // succeeds
    Object unused = mock(Public.class);
  }

  interface PackagePrivate {}

  public interface Public {}
}
```
Error:
```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : Google Inc.
JVM vendor version : 11.0.10+9-google-release-371350251
JVM name           : OpenJDK 64-Bit Server VM
JVM version        : 11.0.10+9-google-release-371350251
JVM info           : mixed mode, sharing
OS name            : Linux
OS version         : 4.15.0-smp-912.23.0.0


Underlying exception : org.mockito.exceptions.base.MockitoException: 
Cannot create mock for interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate

The type is not public and its mock class is loaded by a different class loader.
This can have multiple reasons:
 - You are mocking a class with additional interfaces of another class loader
 - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)
 - The thread's context class loader is different than the mock's class loader
	at com.google.clm.mockitobug.ClassLoaderTest.mockPackagePrivateInterface(ClassLoaderTest.java:21)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:57)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:59)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:81)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:327)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:84)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:292)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:73)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:290)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:60)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:270)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:370)
	at com.google.testing.junit.runner.internal.junit4.CancellableRequestFactory$CancellableRunner.run(CancellableRequestFactory.java:108)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
	at com.google.testing.junit.runner.junit4.JUnit4Runner.run(JUnit4Runner.java:104)
	at com.google.testing.junit.runner.RunnerShell$2.run(RunnerShell.java:34)
	at com.google.testing.junit.runner.GoogleTestRunner.runTestsInSuite(GoogleTestRunner.java:200)
	at com.google.testing.junit.runner.GoogleTestRunner.runTestsInSuite(GoogleTestRunner.java:184)
	at com.google.testing.junit.runner.GoogleTestRunner.main(GoogleTestRunner.java:137)
Caused by: org.mockito.exceptions.base.MockitoException: 
Cannot create mock for interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate

The type is not public and its mock class is loaded by a different class loader.
This can have multiple reasons:
 - You are mocking a class with additional interfaces of another class loader
 - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)
 - The thread's context class loader is different than the mock's class loader
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:153)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:366)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:175)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:377)
	... 27 more

```

If mockito actually tried to use the classloader, I think it would work. Since we don't see an interesting exception deep in the stack, my guess is that mockito is doing some extra validation to avoid generating bytecode it thinks would fail.","Rafael, I took a look at this code and it wasn't completely clear to my why we are failing here. The reason that is probably happening is that Mockito first adds the mocked type (https://github.com/mockito/mockito/blob/6f9108b833323345bd926f10914224d3e0a11b80/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L97) in this case `PackagePrivate` before adding the current classloader: https://github.com/mockito/mockito/blob/6f9108b833323345bd926f10914224d3e0a11b80/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L99

So it looks up the classloader for the mocked type, which is the old classloader. Then it looks up the current classloader (which you changed) and then determines that they don't match. Thus `localMock == false`.

This code landed as part of supporting Java 9+ modules: https://github.com/mockito/mockito/pull/1582 It wouldn't surprise me if there is an edge case we are missing.

Since the new classloader delegates to the former, I would have expected the classes to match and thus pass the checks, but they don't. Presumably because of the classloader equality check. Can we be lenient here and allow for child classloaders to be valid as well? =||= The reason we fail is that a package-private type is not visible outside of its own class loader. Even if we defined the subclass in the same nominal package, if it was loaded by a different class loader, it could not see its superclass. To avoid this visibility issue, we fail before even attempting to create the mock.

We could consider to drop the context class loader if a mocked class is package-private. I am not sure why we need the context class loader to begin with but I assume its related to serialization what tends to be an edge case. =||= I can think of a few options:

1. Ignore the context classloader if the type is package-private. It could have failed anyway... so if it succeeds, might as well reap the benefit.
2. Ignore the package-private restriction for classloaders that are not participating in the java module system, by checking isSealed on the class's package
3. Check to see if the context classloader is a child of the originating classloader, although if a classloader is declaring a parent but not following the delegation patter this might cause a false negative or positive.
4. Just load the stuff as you would, and check each relevant class you load and error if the defining classloader doesn't match. =||= I'll mess around a bit more and report back if I figure out what the issue is. =||= OK, I have a the minimal fix (as in, it will only affect cases that would have broken before):

If the mocked type is a non-interface or non-public, or any of the extra interfaces are non-public, don't include the context classloader in MultipleParentsClassLoader iff the context classloader is a child of the classloader we'd use if it wasn't included.

This fixes my issue, and in general likely fixes cases where a context classloader is set that follows the parent-first delegation pattern. I thought about simply removing the context loader entirely, but test authors who hit this can set and unset it in a try-finally block around their mock calls if necessary, and since there's no comments about why it's included I'd be wary of breaking somebody depending on the existing behavior.

I am going to run this fix through google's internal suite of tests to see if it breaks anything.  =||= 1. The problem is that it might fail delayed upon deserialization. This might be non-trivial to understand and we should document this restriction somewhere. 
2. That won't work. Sealing only affects jars on the same class loader that are defining the same package, this won't work with modules anymore anyways and is taken care of. Package-private classes are however never visible on other class loaders, therefore we must retain the class loader.
3. Is already done to some extend.
4. This is implicit by the multiple parent loader.

I think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition.  =||= > I think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition.

It's not just package-private classes - mocking a public non-final-non-interface class also poses problems, since that will break stubbing/verification of package-private methods (#796).

My proposed fix:
```java
private static boolean needsSamePackageClassLoader(MockFeatures<?> features) {
  if (!Modifier.isPublic(features.mockedType.getModifiers())
                              || !features.mockedType.isInterface()) {
    // The mocked type is package private or is not an interface and thus may contain package
    // private methods.
    return true;
  }
  for (Class<?> iface : features.interfaces) {
    if (!Modifier.isPublic(iface.getModifiers())) {
      return true;
    }
  }
  return false;
}
...
MultipleParentClassLoader.Builder loaderBuilder = new MultipleParentClassLoader.Builder()
                  .appendMostSpecific(getAllTypes(features.mockedType))
                  .appendMostSpecific(features.interfaces)
                  .appendMostSpecific(MockAccess.class);
ClassLoader contextLoader = currentThread().getContextClassLoader();
boolean shouldIncludeContextLoader = true;
if (needsSamePackageClassLoader(features)) {
    // For the generated class to access package-private methods, it must be defined by the
    // same classloader as its type. All the other added classloaders are required to load
    // the type; if the context classloader is a child of the mocked type's defining
    // classloader, it will break a mock that would have worked. Check if the context class
    // loader is a child of the classloader we'd otherwise use, and possibly skip it.
    ClassLoader candidateLoader = loaderBuilder.build();
    for (ClassLoader parent = contextLoader; parent != null; parent = parent.getParent()) {
      if (parent == candidateLoader) {
        shouldIncludeContextLoader = false;
        break;
      }
    }
}
if (shouldIncludeContextLoader) {
  loaderBuilder = loaderBuilder.appendMostSpecific(contextLoader);
}
ClassLoader classLoader = loaderBuilder.build();
```

The focus was on only changing behavior for cases that failed before. Since we verify that the classloader we define in is a parent of the context classloader, we shouldn't see any problems with serialization, right? Or at least no new problems, as the existing `MultipleParentsClassLoader` relies on `getParent()` to infer the delegation order. =||= @charlesmunger Do you mind opening a PR that includes your proposed fix and adds a regression test for your use case? If all tests pass, I am inclined to merge as-is. If we end up breaking anybody else, we should add regression tests for their use cases and modify the implementation accordingly. =||= ",0
2126,1442,NPE occurs when the same type of ArgumentMatcher is used more than once," - [x] The mockito message in the stacktrace have useful information, but it didn't help
 - [x] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [x] Provide versions (mockito / jdk / os / any other relevant information)
 - [x] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/master/.github/CONTRIBUTING.md)

Hi,

I report an NPE issue.
The case is when the same type of `ArgumentMatcher` is used more than once in a test.
It happens with `when`.`thenReturn`, but not with `doReturn`.`when`.
Is it a know issue?
I'm recently reading the Mockito docs carefully but couldn't find anything about this case.
Please check the following test case and log.

```Java
private final class ContainsFoo implements ArgumentMatcher<String> { // Line 25
    public boolean matches(String arg) {
        return arg.contains(""foo""); // Line 27
    }
}

private final class ContainsBar implements ArgumentMatcher<String> {
    public boolean matches(String arg) {
        return arg.contains(""bar"");
    }
}

@Test
public void foobarTest() {
    // NPE occurs
    when(mock.oneArg(argThat(new ContainsFoo()))).thenReturn(""foo"");
    when(mock.oneArg(argThat(new ContainsBar()))).thenReturn(""bar""); // Line 41

    // Works fine
    // doReturn(""foo"").when(mock).oneArg(argThat(new ContainsFoo()));
    // doReturn(""bar"").when(mock).oneArg(argThat(new ContainsBar()));

    assertEquals(""foo"", mock.oneArg(""foo""));
    assertEquals(""bar"", mock.oneArg(""bar""));
}
```
```Java
java.lang.NullPointerException
	at org.mockitousage.matchers.CustomMatchersTest$ContainsFoo.matches(CustomMatchersTest.java:27)
	at org.mockitousage.matchers.CustomMatchersTest$ContainsFoo.matches(CustomMatchersTest.java:25)
	at org.mockito.internal.invocation.TypeSafeMatching.apply(TypeSafeMatching.java:24)
	at org.mockito.internal.invocation.MatcherApplicationStrategy.forEachMatcherAndArgument(MatcherApplicationStrategy.java:83)
	at org.mockito.internal.invocation.InvocationMatcher.argumentsMatch(InvocationMatcher.java:152)
	at org.mockito.internal.invocation.InvocationMatcher.matches(InvocationMatcher.java:81)
	at org.mockito.internal.stubbing.InvocationContainerImpl.findAnswerFor(InvocationContainerImpl.java:85)
	at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:90)
	at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
	at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:35)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:63)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:49)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:128)
	at org.mockitousage.IMethods$MockitoMock$1726084737.oneArg(Unknown Source)
	at org.mockitousage.matchers.CustomMatchersTest.foobarTest(CustomMatchersTest.java:41)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
```

Thanks,
Sangwoo","Your matcher implementation needs to handle null because matcher cannot assume that the ""arg"" will never be null.

You're getting an NPE because ""when().then()"" syntax actually invokes the stubbed method. It's a caveat of the API. In your second stubbing, you actually call method 'oneArg' that triggers the first stubbing to be evaluated. 1st stubbing has a matcher that does not handle nulls properly. All argument matching methods such as 'argThat' return null.

Hope that explanation makes sense! There's nothing we can fix about it. =||= Thanks @mockitoguy for the explanation!
Now I understand a little bit how stubbing works.
I'm closing it.
Thanks! =||= ",0
2126,2316,Mockito 3.11.0 seems to fail in Android instrumentation tests,"After upgrading from 3.10.0 to 3.11.0, our instrumentation tests started failing with a strange error about Mockito plugins:
```
java.lang.IllegalStateException: Could not initialize plugin: interface org.mockito.plugins.MockMaker (alternate: null)
	at org.mockito.internal.configuration.plugins.PluginLoader$1.invoke(PluginLoader.java:84)
	at java.lang.reflect.Proxy.invoke(Proxy.java:1006)
	at $Proxy12.isTypeMockable(Unknown Source)
	at org.mockito.internal.util.MockUtil.typeMockabilityOf(MockUtil.java:33)
	at org.mockito.internal.util.MockCreationValidator.validateType(MockCreationValidator.java:22)
	at org.mockito.internal.creation.MockSettingsImpl.validatedSettings(MockSettingsImpl.java:250)
	at org.mockito.internal.creation.MockSettingsImpl.build(MockSettingsImpl.java:232)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:83)
	at org.mockito.Mockito.mock(Mockito.java:1954)
	at org.mockito.Mockito.mock(Mockito.java:1865)
	at com.blueapron.service.mock.ServiceTestApplication$1.mock(ServiceTestApplication.java:29)
	at com.blueapron.testcommon.StaticMock.provide(StaticMock.java:42)
	at com.blueapron.service.mock.InstrumentAppModule.provideClock_impl(InstrumentAppModule.java:55)
	at com.blueapron.service.dagger.ApplicationModule.provideClock(ApplicationModule.java:230)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.provideClock(ApplicationModule_ProvideClockFactory.java:35)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.get(ApplicationModule_ProvideClockFactory.java:27)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.get(ApplicationModule_ProvideClockFactory.java:9)
	at dagger.internal.DoubleCheck.get(DoubleCheck.java:47)
	at com.blueapron.service.mock.DaggerInstrumentApplicationComponent.injectTimeUtils(DaggerInstrumentApplicationComponent.java:653)
	at com.blueapron.service.mock.DaggerInstrumentApplicationComponent.inject(DaggerInstrumentApplicationComponent.java:345)
	at com.blueapron.marinator.generated.MarinadeHelper.inject(MarinadeHelper.java:254)
	at com.blueapron.marinator.Marinator.inject(Marinator.java:50)
	at com.blueapron.service.util.TimeUtils.<init>(TimeUtils.java:34)
	at com.blueapron.service.util.TimeUtils.getInstance(TimeUtils.java:40)
	at com.blueapron.service.util.TimeUtils.getClock(TimeUtils.java:47)
	at com.blueapron.service.BaseInstrumentationTest.setDateForTest(BaseInstrumentationTest.java:54)
	at com.blueapron.service.BaseInstrumentationTest.initBase(BaseInstrumentationTest.java:71)
	at java.lang.reflect.Method.invoke(Native Method)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at androidx.test.internal.runner.junit4.statement.RunBefores.evaluate(RunBefores.java:76)
	at androidx.test.internal.runner.junit4.statement.RunAfters.evaluate(RunAfters.java:61)
	at com.blueapron.testcommon.FlakyTestRule$1.evaluate(FlakyTestRule.java:30)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:61)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at androidx.test.ext.junit.runners.AndroidJUnit4.run(AndroidJUnit4.java:154)
	at org.junit.runners.Suite.runChild(Suite.java:128)
	at org.junit.runners.Suite.runChild(Suite.java:27)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
	at androidx.test.internal.runner.TestExecutor.execute(TestExecutor.java:56)
	at androidx.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:395)
	at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2189)
Caused by: java.lang.IllegalStateException: Failed to load interface org.mockito.plugins.MockMaker implementation declared in sun.misc.CompoundEnumeration@f915e73
	at org.mockito.internal.configuration.plugins.PluginInitializer.loadImpl(PluginInitializer.java:57)
	at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:65)
	at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:50)
	at org.mockito.internal.configuration.plugins.PluginRegistry.<init>(PluginRegistry.java:26)
	at org.mockito.internal.configuration.plugins.Plugins.<clinit>(Plugins.java:20)
	at org.mockito.internal.configuration.plugins.Plugins.getMockMaker(Plugins.java:36)
	at org.mockito.internal.util.MockUtil.<clinit>(MockUtil.java:28)
	... 59 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.lang.reflect.Constructor.newInstance0(Native Method)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:343)
	at org.mockito.internal.configuration.plugins.PluginInitializer.loadImpl(PluginInitializer.java:52)
	... 65 more
Caused by: java.lang.IllegalStateException: Failed to resolve the class file version of the current VM: This JVM's version string does not seem to be valid: 0
	at net.bytebuddy.ClassFileVersion$VersionLocator$Unresolved.resolve(ClassFileVersion.java:558)
	at net.bytebuddy.ClassFileVersion.ofThisVm(ClassFileVersion.java:276)
	at net.bytebuddy.description.method.ParameterList$ForLoadedExecutable.of(ParameterList.java:205)
	at net.bytebuddy.description.method.MethodDescription$ForLoadedMethod.getParameters(MethodDescription.java:1179)
	at net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.compile(TargetMethodAnnotationDrivenBinder.java:82)
	at net.bytebuddy.implementation.MethodDelegation$ImplementationDelegate$ForStaticMethod.of(MethodDelegation.java:948)
	at net.bytebuddy.implementation.MethodDelegation$WithCustomProperties.to(MethodDelegation.java:1512)
	at net.bytebuddy.implementation.MethodDelegation$WithCustomProperties.to(MethodDelegation.java:1493)
	at net.bytebuddy.implementation.MethodDelegation.to(MethodDelegation.java:271)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.<init>(SubclassBytecodeGenerator.java:63)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.<init>(SubclassBytecodeGenerator.java:73)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.<init>(SubclassByteBuddyMockMaker.java:37)
	at org.mockito.android.internal.creation.AndroidByteBuddyMockMaker.<init>(AndroidByteBuddyMockMaker.java:22)
	... 68 more
```

It looks like something may not *quite* play nicely with the Android ByteBuddy MockMaker in the newest versions?

In our instrumentation tests, we're using `androidTestImplementation org.mockito:mockito-android:3.11.0`. Our unit tests using `testImplementation org:mockito:mockito-core:3.11.0` appear to be working just fine, which is why I suspect something is off in the Android specific implementation.

I'm not sure how best to debug this further - is there additional information that would be useful?","This is most likely https://github.com/raphw/byte-buddy/commit/f20b8362bad45ab45133264394c4573cc4850300 which was included in ByteBuddy 1.11.1 which we rolled into Mockito 3.11.0.

What is the value of `java.version` when you run your tests? =||= I'm not 100% which value you're looking for - feels like it should be a simple question, but I'm just not sure I'm quite parsing it. Can you clarify a little? (Maybe I just haven't had enough coffee today!)

The JVM version is 11, if that's what you're looking for:
```
$ java -version
Picked up _JAVA_OPTIONS: -Dapple.awt.UIElement=true
openjdk version ""11.0.8"" 2020-07-14
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.8+10)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.8+10, mixed mode)
``` =||= Ah I was referring to the `java.version` System property that is retrieved here: https://github.com/raphw/byte-buddy/commit/f20b8362bad45ab45133264394c4573cc4850300#diff-3038b635c974b9bfe4d1cbeef13bbe83c7bd779479bcde42d4f429d2481b5202R490 It appears from the exception that this value is `0`, which is not a valid Java version. =||= Ah, gotcha - that is coming back as ""0"" which confirms your hypothesis. And that definitely explains the behavior! I'm not sure *why* this value is ""0"", though, or whether that's a bug in the byte buddy stack or a configuration problem somehow. =||= @raphw Should we consider relaxing the check in `public VersionLocator run` to return `VersionLocator.ForLegacyVm.INSTANCE` for Android versions that run `mockito-android`? =||= I faced with the same error, how I can fix it? =||= I changed the version resolution to be done within the class initializer rather then on the first call. I wonder if there's a confusion. Could somebody provide me with the value of `System.getProperty(""java.version"")` on Android, both being called from a static initializer and from a regular method? Ideally in one of these failing scenarios. =||= I fixed the issue on master and will release a new version of Byte Buddy. The problem is that the `java.version` property is set to `0` on Android what the parser did not expect. I improved the mechanism to no longer rely on the version on the place where the exception occurs and added a version fallback everywhere else. I also added an explicit version resolution if the version is set to `0`. =||= Mockito 3.11.1 is being published to Maven Central and should solve this issue. =||= ",0
2126,2159,Mockito published maven artifact is missing .module files,"Around Gradle 5.3 new Gradle metadata was introduced (see https://docs.gradle.org/current/userguide/publishing_gradle_module_metadata.html) This allows Gradle builds to publish more detail about dependencies than the lagacy maven pom.

Mockito is generating those files, but they aren't getting uploaded to Maven Central see: https://repo1.maven.org/maven2/org/mockito/mockito-junit-jupiter/3.6.28/

However in the [pom.xml](https://repo1.maven.org/maven2/org/mockito/mockito-junit-jupiter/3.6.28/mockito-junit-jupiter-3.6.28.pom) it contains the comment that tells Gradle to check for the `.module` files:

```
<!--
 This module was also published with a richer model, Gradle metadata,  
-->
<!--
 which should be used instead. Do not delete the following line which  
-->
<!--
 is to indicate to Gradle or any Gradle module metadata file consumer  
-->
<!-- that they should prefer consuming it instead. -->
<!-- do_not_remove: published-with-gradle-metadata -->
```

## Solution 1 [Disable metadata](https://docs.gradle.org/current/userguide/publishing_gradle_module_metadata.html#sub:disabling-gmm-publication ): 

This will remove the comment from the pom.xml and so Gradle won't continue to check for the `.module` file.

```
    tasks.withType<GenerateModuleMetadata> {
        enabled = false
    }
```

## Solution 2- Update the maven publishing to include the missing files

This is the better long-term solution. However I don't have a direct recommendation since I don't have experience in that regard and don't know what is mis-configured.


## Why hasn't this been a problem before?

When using `mavenCentral()` as a repo directly, it serves up a 404 for the missing `.module` file and Gradle recovers fine. However when using an internal repository like Artifactory, it is common to configure it to return `403` for missing files to try to obscure data that shouldn't be accessible.

So to reproduce this you would need to use Gradle > 5.3, Using Mockito as a dependency, when using a locked down Maven repository that is configured to serve 403 instead of exposing 404 for missing artifacts.",nan,0
2126,1743,"Clarify Javadoc of RETURNS_SMART_NULLS, default answer in Mockito 3.0.0?","[Javadoc for Mockito.RETURNS_SMART_NULLS](https://static.javadoc.io/org.mockito/mockito-core/3.0.0/org/mockito/Mockito.html#RETURNS_SMART_NULLS) in version 3.0.0 still says:

> ReturnsSmartNulls will be probably the default return values strategy in Mockito 3.0.0

As Mockito 3.0.0 has been released this could now be clarified. I see #971 is still open, so it looks like the default answer has not been changed?","Yes that should be updated to 4.0.0 now, as we decided not to make any API changes in 3.0.0. =||= ",0
2126,2316,Mockito 3.11.0 seems to fail in Android instrumentation tests,"After upgrading from 3.10.0 to 3.11.0, our instrumentation tests started failing with a strange error about Mockito plugins:
```
java.lang.IllegalStateException: Could not initialize plugin: interface org.mockito.plugins.MockMaker (alternate: null)
	at org.mockito.internal.configuration.plugins.PluginLoader$1.invoke(PluginLoader.java:84)
	at java.lang.reflect.Proxy.invoke(Proxy.java:1006)
	at $Proxy12.isTypeMockable(Unknown Source)
	at org.mockito.internal.util.MockUtil.typeMockabilityOf(MockUtil.java:33)
	at org.mockito.internal.util.MockCreationValidator.validateType(MockCreationValidator.java:22)
	at org.mockito.internal.creation.MockSettingsImpl.validatedSettings(MockSettingsImpl.java:250)
	at org.mockito.internal.creation.MockSettingsImpl.build(MockSettingsImpl.java:232)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:83)
	at org.mockito.Mockito.mock(Mockito.java:1954)
	at org.mockito.Mockito.mock(Mockito.java:1865)
	at com.blueapron.service.mock.ServiceTestApplication$1.mock(ServiceTestApplication.java:29)
	at com.blueapron.testcommon.StaticMock.provide(StaticMock.java:42)
	at com.blueapron.service.mock.InstrumentAppModule.provideClock_impl(InstrumentAppModule.java:55)
	at com.blueapron.service.dagger.ApplicationModule.provideClock(ApplicationModule.java:230)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.provideClock(ApplicationModule_ProvideClockFactory.java:35)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.get(ApplicationModule_ProvideClockFactory.java:27)
	at com.blueapron.service.dagger.ApplicationModule_ProvideClockFactory.get(ApplicationModule_ProvideClockFactory.java:9)
	at dagger.internal.DoubleCheck.get(DoubleCheck.java:47)
	at com.blueapron.service.mock.DaggerInstrumentApplicationComponent.injectTimeUtils(DaggerInstrumentApplicationComponent.java:653)
	at com.blueapron.service.mock.DaggerInstrumentApplicationComponent.inject(DaggerInstrumentApplicationComponent.java:345)
	at com.blueapron.marinator.generated.MarinadeHelper.inject(MarinadeHelper.java:254)
	at com.blueapron.marinator.Marinator.inject(Marinator.java:50)
	at com.blueapron.service.util.TimeUtils.<init>(TimeUtils.java:34)
	at com.blueapron.service.util.TimeUtils.getInstance(TimeUtils.java:40)
	at com.blueapron.service.util.TimeUtils.getClock(TimeUtils.java:47)
	at com.blueapron.service.BaseInstrumentationTest.setDateForTest(BaseInstrumentationTest.java:54)
	at com.blueapron.service.BaseInstrumentationTest.initBase(BaseInstrumentationTest.java:71)
	at java.lang.reflect.Method.invoke(Native Method)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at androidx.test.internal.runner.junit4.statement.RunBefores.evaluate(RunBefores.java:76)
	at androidx.test.internal.runner.junit4.statement.RunAfters.evaluate(RunAfters.java:61)
	at com.blueapron.testcommon.FlakyTestRule$1.evaluate(FlakyTestRule.java:30)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:61)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at androidx.test.ext.junit.runners.AndroidJUnit4.run(AndroidJUnit4.java:154)
	at org.junit.runners.Suite.runChild(Suite.java:128)
	at org.junit.runners.Suite.runChild(Suite.java:27)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
	at androidx.test.internal.runner.TestExecutor.execute(TestExecutor.java:56)
	at androidx.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:395)
	at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2189)
Caused by: java.lang.IllegalStateException: Failed to load interface org.mockito.plugins.MockMaker implementation declared in sun.misc.CompoundEnumeration@f915e73
	at org.mockito.internal.configuration.plugins.PluginInitializer.loadImpl(PluginInitializer.java:57)
	at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:65)
	at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:50)
	at org.mockito.internal.configuration.plugins.PluginRegistry.<init>(PluginRegistry.java:26)
	at org.mockito.internal.configuration.plugins.Plugins.<clinit>(Plugins.java:20)
	at org.mockito.internal.configuration.plugins.Plugins.getMockMaker(Plugins.java:36)
	at org.mockito.internal.util.MockUtil.<clinit>(MockUtil.java:28)
	... 59 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.lang.reflect.Constructor.newInstance0(Native Method)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:343)
	at org.mockito.internal.configuration.plugins.PluginInitializer.loadImpl(PluginInitializer.java:52)
	... 65 more
Caused by: java.lang.IllegalStateException: Failed to resolve the class file version of the current VM: This JVM's version string does not seem to be valid: 0
	at net.bytebuddy.ClassFileVersion$VersionLocator$Unresolved.resolve(ClassFileVersion.java:558)
	at net.bytebuddy.ClassFileVersion.ofThisVm(ClassFileVersion.java:276)
	at net.bytebuddy.description.method.ParameterList$ForLoadedExecutable.of(ParameterList.java:205)
	at net.bytebuddy.description.method.MethodDescription$ForLoadedMethod.getParameters(MethodDescription.java:1179)
	at net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.compile(TargetMethodAnnotationDrivenBinder.java:82)
	at net.bytebuddy.implementation.MethodDelegation$ImplementationDelegate$ForStaticMethod.of(MethodDelegation.java:948)
	at net.bytebuddy.implementation.MethodDelegation$WithCustomProperties.to(MethodDelegation.java:1512)
	at net.bytebuddy.implementation.MethodDelegation$WithCustomProperties.to(MethodDelegation.java:1493)
	at net.bytebuddy.implementation.MethodDelegation.to(MethodDelegation.java:271)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.<init>(SubclassBytecodeGenerator.java:63)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.<init>(SubclassBytecodeGenerator.java:73)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.<init>(SubclassByteBuddyMockMaker.java:37)
	at org.mockito.android.internal.creation.AndroidByteBuddyMockMaker.<init>(AndroidByteBuddyMockMaker.java:22)
	... 68 more
```

It looks like something may not *quite* play nicely with the Android ByteBuddy MockMaker in the newest versions?

In our instrumentation tests, we're using `androidTestImplementation org.mockito:mockito-android:3.11.0`. Our unit tests using `testImplementation org:mockito:mockito-core:3.11.0` appear to be working just fine, which is why I suspect something is off in the Android specific implementation.

I'm not sure how best to debug this further - is there additional information that would be useful?","This is most likely https://github.com/raphw/byte-buddy/commit/f20b8362bad45ab45133264394c4573cc4850300 which was included in ByteBuddy 1.11.1 which we rolled into Mockito 3.11.0.

What is the value of `java.version` when you run your tests? =||= I'm not 100% which value you're looking for - feels like it should be a simple question, but I'm just not sure I'm quite parsing it. Can you clarify a little? (Maybe I just haven't had enough coffee today!)

The JVM version is 11, if that's what you're looking for:
```
$ java -version
Picked up _JAVA_OPTIONS: -Dapple.awt.UIElement=true
openjdk version ""11.0.8"" 2020-07-14
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.8+10)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.8+10, mixed mode)
``` =||= Ah I was referring to the `java.version` System property that is retrieved here: https://github.com/raphw/byte-buddy/commit/f20b8362bad45ab45133264394c4573cc4850300#diff-3038b635c974b9bfe4d1cbeef13bbe83c7bd779479bcde42d4f429d2481b5202R490 It appears from the exception that this value is `0`, which is not a valid Java version. =||= Ah, gotcha - that is coming back as ""0"" which confirms your hypothesis. And that definitely explains the behavior! I'm not sure *why* this value is ""0"", though, or whether that's a bug in the byte buddy stack or a configuration problem somehow. =||= @raphw Should we consider relaxing the check in `public VersionLocator run` to return `VersionLocator.ForLegacyVm.INSTANCE` for Android versions that run `mockito-android`? =||= I faced with the same error, how I can fix it? =||= I changed the version resolution to be done within the class initializer rather then on the first call. I wonder if there's a confusion. Could somebody provide me with the value of `System.getProperty(""java.version"")` on Android, both being called from a static initializer and from a regular method? Ideally in one of these failing scenarios. =||= I fixed the issue on master and will release a new version of Byte Buddy. The problem is that the `java.version` property is set to `0` on Android what the parser did not expect. I improved the mechanism to no longer rely on the version on the place where the exception occurs and added a version fallback everywhere else. I also added an explicit version resolution if the version is set to `0`. =||= Mockito 3.11.1 is being published to Maven Central and should solve this issue. =||= ",0
2126,2325,Fixes #2311 : print the fully qualified class names.,"<!-- Hey,
Thanks for the contribution, this is awesome.
As you may have read, project members have somehow an opinionated view on what and how should be
Mockito, e.g. we don't want mockito to be a feature bloat.
There may be a thorough review, with feedback -> code change loop.
-->
<!--
If you have a suggestion for this template you can fix it in the .github/PULL_REQUEST_TEMPLATE.md file
-->
## Checklist

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/main/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [x] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_

-. replace getName() with getSimpleName() ","We no longer use the `release/3.x` branch, so #2320 suffices for now. I think I will have a chance tomorrow to review the PR. =||= I'm just showing that I'm a complete beginner.
Using the release branch for PR... I'm sorry for wasting your time. =||= Don't worry about it, our branch naming was confusing! It's an easy mistake to make, so no worries at all 😄  =||= thank you~ :) =||= ",0
2126,2303,"""The type is not public and its mock class is loaded by a different class loader"" with a context classloader that delegates","Repro case:
```java
package com.google.clm.mockitobug;

import static org.mockito.Mockito.mock;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * My goal is to create a context classloader that is identical in every way to the existing one,
 * except that it has a different object identity and possibly some extra fields. However, even a
 * basic classloader that always delegates causes problems for mockito.
 */
@RunWith(JUnit4.class)
public final class ClassLoaderTest {

  @Test
  public void mockPackagePrivateInterface() {
    ClassLoader old = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(new ClassLoader(old) {});
    // fails
    Object unused = mock(PackagePrivate.class);
  }

  @Test
  public void mockPublicInterface() {
    ClassLoader old = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(new ClassLoader(old) {});
    // succeeds
    Object unused = mock(Public.class);
  }

  interface PackagePrivate {}

  public interface Public {}
}
```
Error:
```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : Google Inc.
JVM vendor version : 11.0.10+9-google-release-371350251
JVM name           : OpenJDK 64-Bit Server VM
JVM version        : 11.0.10+9-google-release-371350251
JVM info           : mixed mode, sharing
OS name            : Linux
OS version         : 4.15.0-smp-912.23.0.0


Underlying exception : org.mockito.exceptions.base.MockitoException: 
Cannot create mock for interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate

The type is not public and its mock class is loaded by a different class loader.
This can have multiple reasons:
 - You are mocking a class with additional interfaces of another class loader
 - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)
 - The thread's context class loader is different than the mock's class loader
	at com.google.clm.mockitobug.ClassLoaderTest.mockPackagePrivateInterface(ClassLoaderTest.java:21)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:57)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:59)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:81)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:327)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:84)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:292)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:73)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:290)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:60)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:270)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:370)
	at com.google.testing.junit.runner.internal.junit4.CancellableRequestFactory$CancellableRunner.run(CancellableRequestFactory.java:108)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
	at com.google.testing.junit.runner.junit4.JUnit4Runner.run(JUnit4Runner.java:104)
	at com.google.testing.junit.runner.RunnerShell$2.run(RunnerShell.java:34)
	at com.google.testing.junit.runner.GoogleTestRunner.runTestsInSuite(GoogleTestRunner.java:200)
	at com.google.testing.junit.runner.GoogleTestRunner.runTestsInSuite(GoogleTestRunner.java:184)
	at com.google.testing.junit.runner.GoogleTestRunner.main(GoogleTestRunner.java:137)
Caused by: org.mockito.exceptions.base.MockitoException: 
Cannot create mock for interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate

The type is not public and its mock class is loaded by a different class loader.
This can have multiple reasons:
 - You are mocking a class with additional interfaces of another class loader
 - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)
 - The thread's context class loader is different than the mock's class loader
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:153)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:366)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:175)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:377)
	... 27 more

```

If mockito actually tried to use the classloader, I think it would work. Since we don't see an interesting exception deep in the stack, my guess is that mockito is doing some extra validation to avoid generating bytecode it thinks would fail.","Rafael, I took a look at this code and it wasn't completely clear to my why we are failing here. The reason that is probably happening is that Mockito first adds the mocked type (https://github.com/mockito/mockito/blob/6f9108b833323345bd926f10914224d3e0a11b80/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L97) in this case `PackagePrivate` before adding the current classloader: https://github.com/mockito/mockito/blob/6f9108b833323345bd926f10914224d3e0a11b80/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L99

So it looks up the classloader for the mocked type, which is the old classloader. Then it looks up the current classloader (which you changed) and then determines that they don't match. Thus `localMock == false`.

This code landed as part of supporting Java 9+ modules: https://github.com/mockito/mockito/pull/1582 It wouldn't surprise me if there is an edge case we are missing.

Since the new classloader delegates to the former, I would have expected the classes to match and thus pass the checks, but they don't. Presumably because of the classloader equality check. Can we be lenient here and allow for child classloaders to be valid as well? =||= The reason we fail is that a package-private type is not visible outside of its own class loader. Even if we defined the subclass in the same nominal package, if it was loaded by a different class loader, it could not see its superclass. To avoid this visibility issue, we fail before even attempting to create the mock.

We could consider to drop the context class loader if a mocked class is package-private. I am not sure why we need the context class loader to begin with but I assume its related to serialization what tends to be an edge case. =||= I can think of a few options:

1. Ignore the context classloader if the type is package-private. It could have failed anyway... so if it succeeds, might as well reap the benefit.
2. Ignore the package-private restriction for classloaders that are not participating in the java module system, by checking isSealed on the class's package
3. Check to see if the context classloader is a child of the originating classloader, although if a classloader is declaring a parent but not following the delegation patter this might cause a false negative or positive.
4. Just load the stuff as you would, and check each relevant class you load and error if the defining classloader doesn't match. =||= I'll mess around a bit more and report back if I figure out what the issue is. =||= OK, I have a the minimal fix (as in, it will only affect cases that would have broken before):

If the mocked type is a non-interface or non-public, or any of the extra interfaces are non-public, don't include the context classloader in MultipleParentsClassLoader iff the context classloader is a child of the classloader we'd use if it wasn't included.

This fixes my issue, and in general likely fixes cases where a context classloader is set that follows the parent-first delegation pattern. I thought about simply removing the context loader entirely, but test authors who hit this can set and unset it in a try-finally block around their mock calls if necessary, and since there's no comments about why it's included I'd be wary of breaking somebody depending on the existing behavior.

I am going to run this fix through google's internal suite of tests to see if it breaks anything.  =||= 1. The problem is that it might fail delayed upon deserialization. This might be non-trivial to understand and we should document this restriction somewhere. 
2. That won't work. Sealing only affects jars on the same class loader that are defining the same package, this won't work with modules anymore anyways and is taken care of. Package-private classes are however never visible on other class loaders, therefore we must retain the class loader.
3. Is already done to some extend.
4. This is implicit by the multiple parent loader.

I think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition.  =||= > I think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition.

It's not just package-private classes - mocking a public non-final-non-interface class also poses problems, since that will break stubbing/verification of package-private methods (#796).

My proposed fix:
```java
private static boolean needsSamePackageClassLoader(MockFeatures<?> features) {
  if (!Modifier.isPublic(features.mockedType.getModifiers())
                              || !features.mockedType.isInterface()) {
    // The mocked type is package private or is not an interface and thus may contain package
    // private methods.
    return true;
  }
  for (Class<?> iface : features.interfaces) {
    if (!Modifier.isPublic(iface.getModifiers())) {
      return true;
    }
  }
  return false;
}
...
MultipleParentClassLoader.Builder loaderBuilder = new MultipleParentClassLoader.Builder()
                  .appendMostSpecific(getAllTypes(features.mockedType))
                  .appendMostSpecific(features.interfaces)
                  .appendMostSpecific(MockAccess.class);
ClassLoader contextLoader = currentThread().getContextClassLoader();
boolean shouldIncludeContextLoader = true;
if (needsSamePackageClassLoader(features)) {
    // For the generated class to access package-private methods, it must be defined by the
    // same classloader as its type. All the other added classloaders are required to load
    // the type; if the context classloader is a child of the mocked type's defining
    // classloader, it will break a mock that would have worked. Check if the context class
    // loader is a child of the classloader we'd otherwise use, and possibly skip it.
    ClassLoader candidateLoader = loaderBuilder.build();
    for (ClassLoader parent = contextLoader; parent != null; parent = parent.getParent()) {
      if (parent == candidateLoader) {
        shouldIncludeContextLoader = false;
        break;
      }
    }
}
if (shouldIncludeContextLoader) {
  loaderBuilder = loaderBuilder.appendMostSpecific(contextLoader);
}
ClassLoader classLoader = loaderBuilder.build();
```

The focus was on only changing behavior for cases that failed before. Since we verify that the classloader we define in is a parent of the context classloader, we shouldn't see any problems with serialization, right? Or at least no new problems, as the existing `MultipleParentsClassLoader` relies on `getParent()` to infer the delegation order. =||= @charlesmunger Do you mind opening a PR that includes your proposed fix and adds a regression test for your use case? If all tests pass, I am inclined to merge as-is. If we end up breaking anybody else, we should add regression tests for their use cases and modify the implementation accordingly. =||= ",0
2127,489,Remove Whitebox class,"The original question stems from #422 where additional changes were requested. This class seems to stimulate bad testing practices. Mockito only uses this class in [JUnitFailureHacker](https://github.com/mockito/mockito/blob/196ff979da156caa07e19f57e4849637d8bede1a/src/main/java/org/mockito/internal/util/junit/JUnitFailureHacker.java) which consequently is only used in [VerboseMockitoJUnitRunner](https://github.com/mockito/mockito/blob/196ff979da156caa07e19f57e4849637d8bede1a/src/main/java/org/mockito/runners/VerboseMockitoJUnitRunner.java). Given the nature of this class and only 1 usage in the library, I think we should remove it to prevent users from obtaining bad testing habits.","Oh yeah - please do :P
 =||= Usages on GitHub code derived with Google BigQuery: https://bigquery.cloud.google.com/results/eco-silicon-124112:bquijob_30e42d3_155cf5a5f13?pli=1

``` sql
SELECT
  cont.sample_repo_name,
  repo.watch_count
FROM
  [fh-bigquery:github_extracts.contents_java_2016] as cont
JOIN [bigquery-public-data:github_repos.sample_repos] as repo
  ON cont.sample_repo_name = repo.repo_name  
WHERE
  cont.content CONTAINS 'import org.mockito.internal.util.reflection.Whitebox'
GROUP BY cont.sample_repo_name, repo.watch_count
ORDER BY repo.watch_count DESC
LIMIT
  500;
```

Most of the repositories seem to rely on PowerMock instead, which already has a different Whitebox class defined. Therefore I think it is safe to say we can deprecate and remove the class and those users who are explicitly relying on the behavior are likely users of PowerMock too.
 =||= Yes go on.
 =||= Thanks for removing this class. It's an internal class. People should never depend it. If they did, they need handle the problem ;)
 =||= ",0
2127,477,Refactored class Checker to staitic utility classes,Description is comming soon,nan,0
2129,245,Serializable check is too harsh,"Hi, apologies if this has been discussed.

While upgrading my company's Mockito to 1.10.19, I ran into a lot of this error:

```
org.mockito.exceptions.base.MockitoException: 
You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'OpportunityClient'
do not implement Serializable AND do not have a no-arg constructor.
This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized
```

In summary, there are two cases triggering this error.
1. The SubjectUnderTest accepts an object Foo and requires it to be Serializable. And yet Foo doesn't implement Serializable nor has a default constructor.
2. Foo itself is Serializable. But the test calls `when(foo.createBar()).thenReturn(bar)`, which behind the scene puts the `bar` mock onto the state of foo, which requires bar itself to be Serializable. In production, bar isn't required to be Serializable.

I feel case 1 is possibly reasonable (although it's still kind of harsh. I'll get to it in a bit).

Case 2 should not require Bar to be Serializable as it does today. In version 1.9.5, our tests worked around it by using `mock(Bar.class, withSettings().serilizable()`. But in version 1.10.19, this workaround breaks if Bar has no default constructor.

Possibly the [Serializable Proxy Pattern](http://stackoverflow.com/questions/702357/what-is-the-serialization-proxy-pattern) could be used to solve this nicely by stashing the ""mock specifications"" into a proxy object that can later on deserialize itself back into a mock Bar with the same number of when().thenReturn().

Now let me try to explain why I think even case 1 is too harsh.

Philosophically, I feel that it's not Mockito's job to ensure the mocked object works in real life. It's a mock object after all. It isn't expected to meet all required specification of the real object.

When in a test I say `@Mock(serializable=true) Foo foo;`, I'm explicitly asking Mockito to ""please pretend my object be Serializable. I don't want to worry about the real object in this test"". Would the real object be serializable when I pass it into SubjectUnderTest? Well:
1. There is nothing guaranteeing that production code passes Foo to SubjectUnderTest. It could likely pass a cousin class RealFoo2 that implements Serializable just fine (or not, but the test doesn't help me with that). It needs to be tested, but IMHO not against a mock foo, especially when Mockito's when().thenReturn() syntax adds non-existent Serializable requirement to the mock object.
2. Given the proxy pattern, that Foo doesn't _look like_ a serializable class isn't a guarantee that it can't be. So by throwing this error, Mockito enforces stricter constraint than what's technically necessary.

I agree that checking basic Serializable requirement in Mockito can catch some bugs. If case 2 can be fixed, it's likely that case 1 would not have triggered so many false positives.

But with all our workarounds already added because of case 2 and the fair number of our tests triggering this error, the amount of work to fix all of them before we can upgrade Mockito looks daunting.

So, I guess my question is: **can we do away with MockCreationValidator.validateSerializable() or make it an opt-in?**

Sorry for the long message.","Here's a real example. The subject under test looks like this:

```
class SubjectUnderTest implements Serializable {
  private final FooFactory factory;

  SubjectUnderTest(FooFactory factory) {
    this.factory= factory;
  }

  ...
  Foo foo = factory.createFoo();
  ...
}
```

The testing framework actually tries to serialize SubjectUnderTest so FooFactory needs to be Serializable too.

The test using Mockito looks like this:

```
Foo foo = mock(Foo.class);
FooFactory mockFactory = mock(FooFactory.class, withSettings().serializable());
when(mockFactory.createFoo()).thenReturn(foo);
SubjectUnderTest subject = new SubjectUnderTest(mockFactory);
```

But when the framework serializes `subject`, we get an exception, because the line of `when(mockFactory.createFoo()).thenReturn(foo)` implicitly adds 'foo' as part of `mockFactory` state.

To work around the problem, our tests had to make foo serializable too:

```
Foo foo = mock(Foo.class, withSettings().serializable());
...
```

Again, production code doesn't need Foo to be Serializable and it may not have a default constructor.

That's status quo.

Now with v1.10.19, the above work-around breaks, because Foo doesn't implement Serializable nor has a default constructor.

Back to square one, if I had the choice, I would strongly discourage the code that mocks either FooFactory or Foo. Instead, it should just be a plain old FooFactory subclass that returns Foo. With Java 8, the syntax would actually become more concise than the mockito syntax. 

But I can't go back and fix so many teams' code. As it stands today, this is the biggest issue blocking the upgrade.

Hopefully I've made a clear case.
 =||= Thanks for reporting.

I'm ok with removing the check or making it smarter. It seems to be a legit
use case. Brice?

Cheers!

On Fri, Jul 3, 2015 at 2:50 PM, Ben Yu notifications@github.com wrote:

> Here's a real example. The subject under test looks like this:
> 
> class SubjectUnderTest implements Serializable {
>   private final FooFactory factory;
> 
>   SubjectUnderTest(FooFactory factory) {
>     this.factory= factory;
>   }
> 
>   ...
>   Foo foo = factory.createFoo();
>   ...
> }
> 
> The testing framework actually tries to serialize SubjectUnderTest so
> FooFactory needs to be Serializable too.
> 
> The test using Mockito looks like this:
> 
> Foo foo = mock(Foo.class);
> FooFactory mockFactory = mock(FooFactory.class, withSettings().serializable());
> when(mockFactory.createFoo()).thenReturn(foo);
> SubjectUnderTest subject = new SubjectUnderTest(mockFactory);
> 
> But when the framework serializes subject, we get an exception, because
> the line of when(mockFactory.createFoo()).thenReturn(foo) implicitly adds
> 'foo' as part of mockFactory state.
> 
> To work around the problem, our tests had to make foo serializable too:
> 
> Foo foo = mock(Foo.class, withSettings().serializable());
> ...
> 
> Again, production code doesn't need Foo to be Serializable and it may not
> have a default constructor.
> 
> That's status quo.
> 
> Now with v1.10.19, the above work-around breaks, because Foo doesn't
> implement Serializable nor has a default constructor.
> 
> Back to square one, if I had the choice, I would strongly discourage the
> code that mocks either FooFactory or Foo. Instead, it should just be a
> plain old FooFactory subclass that returns Foo. With Java 8, the syntax
> would actually become more concise than the mockito syntax.
> 
> But I can't go back and fix so many teams' code. As it stands today, this
> is the biggest issue blocking the upgrade.
> 
> Hopefully I've made a clear case.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/245#issuecomment-118431952.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Hi, is this reasonable? I can send a PR to remove this check, if it's okay with you guys.
 =||= Let's remove the check unless Brice objects ;)

On Fri, Sep 18, 2015 at 9:08 PM, Ben Yu notifications@github.com wrote:

> Hi, is this reasonable? I can send a PR to remove this check, if it's okay
> with you guys.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/245#issuecomment-141618665.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= @szczepiq @fluentfuture is this fix available in any of the mockito releases?
 =||= @vikkyrk since 2.0.31-beta
 =||= Thanks 
 =||= ",0
2129,256,task mockitoJavadoc fails when compiling in windows,"When compiling the mockito project using gradle in a command line in Windows following compile error occurs:

javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/jdk6-project-version-insert.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/jquery-1.7.min.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/highlight-8.6-java/highlight.pack.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<link""
javadoc: error - Illegal package name: ""rel=""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/css""
javadoc: error - Illegal package name: ""href=""
javadoc: error - Illegal package name: ""{@docRoot}/js/highlight-8.6-java/styles/obsidian.css""
javadoc: error - Illegal package name: ""/>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: ""=""
javadoc: error - Illegal package name: ""&&""
javadoc: error - Illegal package name: ""parseInt($.browser.version)""
javadoc: error - Illegal package name: ""<""
javadoc: error - Illegal package name: ""9;""
javadoc: error - Illegal package name: ""if(!usingOldIE)""
javadoc: error - Illegal package name: ""{""
javadoc: error - Illegal package name: ""$(""
javadoc: error - Illegal package name: "").append(""
javadoc: error - Illegal package name: ""<link rel=\""
javadoc: error - Illegal package name: ""icon\\""
javadoc: error - Illegal package name: "" href=\""
javadoc: error - Illegal package name: ""{@docRoot}/favicon.ico?v=cafebabe\\""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: "")""
javadoc: error - Illegal package name: ""$(""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""window.parent.document).append(""
javadoc: error - Illegal package name: ""<link rel=\""
javadoc: error - Illegal package name: ""icon\\""
javadoc: error - Illegal package name: "" href=\""
javadoc: error - Illegal package name: ""{@docRoot}/favicon.ico?v=cafebabe\\""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: "")""
javadoc: error - Illegal package name: ""hljs.initHighlightingOnLoad();""
javadoc: error - Illegal package name: ""injectProjectVersionForJavadocJDK6(""
javadoc: error - Illegal package name: ""Mockito 2.0.29-beta API""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""em#mockito-version-header-javadoc7-header""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""em#mockito-version-header-javadoc7-footer""
javadoc: error - Illegal package name: "");""
javadoc: error - Illegal package name: ""}""
javadoc: error - Illegal package name: ""</script>""
javadoc: error - Illegal package name: """"
javadoc: warning - No source files for package stylesheet
javadoc: warning - No source files for package var
javadoc: warning - No source files for package usingOldIE
javadoc: warning - No source files for package $.browser.msie
javadoc: warning - No source files for package head
javadoc: warning - No source files for package shortcut
javadoc: warning - No source files for package head
javadoc: warning - No source files for package shortcut
64 errors
8 warnings

I tracked the issue down to gradle/javadoc.gradle where the gradle scripts sets the bottom property to a java script with multiple lines. 

Changing that to a single line seems to be make it possible to complete the mockitoJavaDoc task without any errors.","I think most of us work on Linux/OSX, it probably has to do with the JDK
version and windows line endings.

So minifying this javascript code may work ?

-- Brice

On Fri, Jul 10, 2015 at 8:19 AM, Meang Akira Tanaka <
notifications@github.com> wrote:

> When compiling the mockito project using gradle in a command line in
> Windows following compile error occurs:
> 
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/jdk6-project-version-insert.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name: ""{@docRoot}/js/jquery-1.7.min.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/highlight-8.6-java/highlight.pack.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""rel=""
> javadoc: error - Illegal package name: ""type=""
> javadoc: error - Illegal package name: ""text/css""
> javadoc: error - Illegal package name: ""href=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/highlight-8.6-java/styles/obsidian.css""
> javadoc: error - Illegal package name: ""/>""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: ""=""
> javadoc: error - Illegal package name: ""&&""
> javadoc: error - Illegal package name: ""parseInt($.browser.version)""
> javadoc: error - Illegal package name: ""<""
> javadoc: error - Illegal package name: ""9;""
> javadoc: error - Illegal package name: ""if(!usingOldIE)""
> javadoc: error - Illegal package name: ""{""
> javadoc: error - Illegal package name: ""$(""
> javadoc: error - Illegal package name: "").append(""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""icon\""
> javadoc: error - Illegal package name: "" href=\""
> javadoc: error - Illegal package name:
> ""{@docRoot}/favicon.ico?v=cafebabe\""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "")""
> javadoc: error - Illegal package name: ""$(""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name: ""window.parent.document).append(""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""icon\""
> javadoc: error - Illegal package name: "" href=\""
> javadoc: error - Illegal package name:
> ""{@docRoot}/favicon.ico?v=cafebabe\""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "")""
> javadoc: error - Illegal package name: ""hljs.initHighlightingOnLoad();""
> javadoc: error - Illegal package name:
> ""injectProjectVersionForJavadocJDK6(""
> javadoc: error - Illegal package name: ""Mockito 2.0.29-beta API""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name:
> ""em#mockito-version-header-javadoc7-header""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name:
> ""em#mockito-version-header-javadoc7-footer""
> javadoc: error - Illegal package name: "");""
> javadoc: error - Illegal package name: ""}""
> javadoc: error - Illegal package name: """"
> javadoc: error - Illegal package name: """"
> javadoc: warning - No source files for package stylesheet
> javadoc: warning - No source files for package var
> javadoc: warning - No source files for package usingOldIE
> javadoc: warning - No source files for package $.browser.msie
> javadoc: warning - No source files for package head
> javadoc: warning - No source files for package shortcut
> javadoc: warning - No source files for package head
> javadoc: warning - No source files for package shortcut
> 64 errors
> 8 warnings
> 
> I tracked the issue down to gradle/javadoc.gradle where the gradle scripts
> sets the bottom property to a java script with multiple lines.
> 
> Changing that to a single line seems to be make it possible to complete
> the mockitoJavaDoc task without any errors.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/256.
 =||= Fixed via 34f8c69
 =||= Hi Brice

Unfortunately it did not work... I have submitted an alternative suggestion

br

Meang
 =||= ",0
2129,254,Fixes #253 create unsynchronized interceptors for mocks,nan,"This causes both the loss of meta data as well as inherited, synchronized methods. In my understanding, Mockito is not supposed to be thread-safe. But I see the point. I will adress this in some future release of Byte Buddy.
 =||= Yeah the implementation is kinda sketchy.
According to the [FAQ](https://github.com/mockito/mockito/wiki/FAQ) Mockito should support this kind of verification especially in timeout scenarios (timeout() is a sign of a concurrency tests). This kind of verification used to work in Mockito 1.x.
 =||= Indeed. I will have a look at it. Ideally, Byte Buddy would allow to register a transformer that allows a modifier to be changed. I am currently down the rabbit hole to support generic types so I m not yet sure when I'll be able to tackle this. @bric3, is this a blocker? Or should methods even purposely retain their synchronizity even for mocks? (Eventually, Mockito mocks an instance's API. If a user of a mock instance expects its thread to block on a method call of this instance, this would change the API as it is not longer true for the mock instance compared to the actual use case.) Either way, this should be adressed in the FAQ to specify a particular behavior.
 =||= I'd rather not release 2.0 final if we regress on the thread-safety front.
There's still some time to get this sorted out, though.

On Wed, Jul 8, 2015 at 11:57 PM, Rafael Winterhalter <
notifications@github.com> wrote:

> Indeed. I will have a look at it. Ideally, Byte Buddy would be able to
> register a transformer that allows a modifier to be changed. I am currently
> down the rabbit hole to support generic types so I wonder when I'll be able
> to tackle this. @bric3 https://github.com/bric3, is this a blocker?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/254#issuecomment-119846695.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= I addressed the issue by slightly extending Byte Buddy's API. Pull request: https://github.com/mockito/mockito/pull/257 - I'd recommend adding a test case similar to the one of this pull request for future reference.
 =||= Belatle answer yes that should a major drawback of 2.0. @raphw I'll look at #257 
Also thanks for reporting and crafting a fix with this PR @bonifaido :)
 =||= Closing as #257 should fix the issue.
 =||= ",0
2129,255,Mockito plugin annotation,nan,"## [Current coverage](https://codecov.io/github/mockito/mockito?ref=9e363724818455398b8145cc268159d82d1faa8d) is `83.72%`

> Merging **#255** into **master** will change coverage by **+0.02%** by [`9e36372`](https://github.com/mockito/mockito/commit/9e363724818455398b8145cc268159d82d1faa8d)

#### Coverage Diff

``` diff
@@            master    #255   diff @@
======================================
  Files          270     270       
  Stmts         4583    4602    +19
  Branches       745     748     +3
  Methods          0       0       
======================================
+ Hit           3836    3853    +17
- Partial        220     221     +1
- Missed         527     528     +1
```

---

### [Uncovered Suggestions](https://codecov.io/github/mockito/mockito/features/suggestions?ref=9e363724818455398b8145cc268159d82d1faa8d)
1. `+0.16%` via [...ializableMethod.java#97...103](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/invocation/SerializableMethod.java?ref=9e363724818455398b8145cc268159d82d1faa8d#97) 
2. `+0.11%` via [...lizationSupport.java#122...126](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java?ref=9e363724818455398b8145cc268159d82d1faa8d#122) 
3. `+0.11%` via [...ns/PluginLoader.java#60...64](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java?ref=9e363724818455398b8145cc268159d82d1faa8d#60) 
4. _[See 7 more...](https://codecov.io/github/mockito/mockito/features/suggestions?ref=9e363724818455398b8145cc268159d82d1faa8d)_

> Powered by [Codecov](https://codecov.io)
 =||= I found another issue

The class GlobalConfiguration contains a ThreadLocal which contains the latest global configuration, and when running the test the TestBase invokes ConfigurationAccess.getConfig which casts the GlobalConfiguration to a MockitoConfiguration, which is not the case when using the @MockitoPlugin. 

I guess the GlobalConfiguration is meant to serve as a singleton, however I guess that is not possible when you have a annotation engine for each test instance.

Are there any special reason why global configuration has to use a ThreadLocal ?
 =||= > Are there any special reason why global configuration has to use a ThreadLocal ?

I don't remember. @szczepiq do you?

Nice feature overall :)
 =||= By the way your commits should be squashed ;)
 =||= > By the way your commits should be squashed ;)

I tried let's see if I did it correctly :p 
 =||= I moved the removeIt from the globalconfiguration to ConfigurationAccess instead, I think there is an issue with the global configuration that it can only be instantiated once. thereby it will not be possible to have different annotation engine for different test cases.

I think it would make sense to do that so I change the new constructor in GlobalConfiguraton which I implemented to _always_ instantiate a new configuration with the provided annotation engine.
 =||= > > By the way your commits should be squashed ;)
> 
> I tried let's see if I did it correctly :p

Nope, you have imported commits from master , and you somehow did some merge commits from another branch. On _pull request_ branches it is better to keep a clean _flat_ history.

I'm not sure why you needed those merges, but you definitely want to avoid those. _Squashing_ means to put commits together in order to have a clean and meaningful history. This is done via a `git rebase --interactive <the commit references>`. Check our [wiki](https://github.com/mockito/mockito/wiki/Using-git-to-prepare-your-PR-to-have-a-clean-history) on that matter, it contains the bare minimum to understand how to have a clean history. Nevertheless there's better and more complete tutorial out there.

Don't worry I know git is a bit hard when beginning, but once you know your way and why it matters, you won't regret it :)
 =||= So should I make a new branch and transfer all the changes into the new
branch rather than continue working on this messy branch?

Br

Meang

On Sun, Jul 12, 2015, 19:50 Brice Dutheil notifications@github.com wrote:

> By the way your commits should be squashed ;)
> 
> I tried let's see if I did it correctly :p
> 
>  Nope, you have imported commits from master , and you somehow did some
> merge commits from another branch. On _pull request_ branches it is
> better to keep a clean _flat_ history.
> 
> I'm not sure why you needed those merges, but you definitely want to avoid
> those. _Squashing_ means to put commits together in order to have a clean
> and meaningful history. This is done via a git rebase --interactive <the
> commit references>. Check our wiki
> https://github.com/mockito/mockito/wiki/Using-git-to-prepare-your-PR-to-have-a-clean-history
> on that matter, it contains the bare minimum to understand how to have a
> clean history. Nevertheless there's better and more complete tutorial out
> there.
> 
> Don't worry I know git is a bit hard when beginning, but once you know
> your way and why it matters, you won't regret it :)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/255#issuecomment-120750213.
 =||= Yes you can.
Can you close this one when you are ready :)
 =||= Killed it as it the branch was messed up. Have created a new PR and branch for that feature
 =||= ",0
2129,267,bintray upload broken ?,"Yet the binaries seems to be uploaded to bintray and maven (2.0.29-beta is missing on maven). But there's this failure reported during the build.

https://travis-ci.org/mockito/mockito/builds/71779411#L270-L359

```
:bintrayUpload
Error parsing 'text/html' response
groovy.json.JsonException: Unable to determine the current character, it is not a string, number, array, or object
The current character read is '<' with an int value of 60
Unable to determine the current character, it is not a string, number, array, or object
line number 1
index number 0
<html>
^
    at groovy.json.internal.JsonParserCharArray.decodeValueInternal(JsonParserCharArray.java:216)
    at groovy.json.internal.JsonParserCharArray.decodeValue(JsonParserCharArray.java:166)
    at groovy.json.internal.JsonParserCharArray.decodeFromChars(JsonParserCharArray.java:45)
    at groovy.json.internal.JsonParserCharArray.parse(JsonParserCharArray.java:409)
    at groovy.json.internal.BaseJsonParser.parse(BaseJsonParser.java:121)
    at groovy.json.JsonSlurper.parse(JsonSlurper.java:224)
    at groovyx.net.http.ParserRegistry.parseJSON(ParserRegistry.java:280)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1206)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1073)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
    at groovy.lang.Closure.call(Closure.java:423)
    at groovy.lang.Closure.call(Closure.java:439)
    at groovyx.net.http.HTTPBuilder.parseResponse(HTTPBuilder.java:560)
    at groovyx.net.http.HTTPBuilder$1.handleResponse(HTTPBuilder.java:489)
    at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1070)
    at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1044)
    at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:515)
    at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:434)
    at groovyx.net.http.HTTPBuilder.request(HTTPBuilder.java:383)
    at groovyx.net.http.HTTPBuilder$request$0.call(Unknown Source)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
    at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy:358)
    at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
    at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
    at com.jfrog.bintray.gradle.BintrayUploadTask.bintrayUpload(BintrayUploadTask.groovy:392)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:226)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:219)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:208)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:589)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:572)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
    at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
    at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:310)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
    at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
    at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:745)
:bintrayUpload FAILED
FAILURE: Build failed with an exception.
* What went wrong:
Execution failed for task ':bintrayUpload'.
> groovyx.net.http.ResponseParseException: Not Allowed
```","I have seen this. For some reason automatic publish to central fails. Can
be synced manually from bintray api. Javadoc and release notes are not
updated, too. I will look into it.

On Mon, Jul 20, 2015, 17:01 Brice Dutheil notifications@github.com wrote:

> https://travis-ci.org/mockito/mockito/builds/71779411#L270-L359
> 
> Yet the binaries seems to be uploaded to bintray but not maven
> (2.0.29-beta is missing, waiting for 2.0.30-beta to sync)
> 
> :bintrayUpload
> Error parsing 'text/html' response
> groovy.json.JsonException: Unable to determine the current character, it is not a string, number, array, or object
> The current character read is '<' with an int value of 60
> Unable to determine the current character, it is not a string, number, array, or object
> line number 1
> index number 0
> <html>
> ^
>     at groovy.json.internal.JsonParserCharArray.decodeValueInternal(JsonParserCharArray.java:216)
>     at groovy.json.internal.JsonParserCharArray.decodeValue(JsonParserCharArray.java:166)
>     at groovy.json.internal.JsonParserCharArray.decodeFromChars(JsonParserCharArray.java:45)
>     at groovy.json.internal.JsonParserCharArray.parse(JsonParserCharArray.java:409)
>     at groovy.json.internal.BaseJsonParser.parse(BaseJsonParser.java:121)
>     at groovy.json.JsonSlurper.parse(JsonSlurper.java:224)
>     at groovyx.net.http.ParserRegistry.parseJSON(ParserRegistry.java:280)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
>     at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1206)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1073)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
>     at groovy.lang.Closure.call(Closure.java:423)
>     at groovy.lang.Closure.call(Closure.java:439)
>     at groovyx.net.http.HTTPBuilder.parseResponse(HTTPBuilder.java:560)
>     at groovyx.net.http.HTTPBuilder$1.handleResponse(HTTPBuilder.java:489)
>     at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1070)
>     at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1044)
>     at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:515)
>     at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:434)
>     at groovyx.net.http.HTTPBuilder.request(HTTPBuilder.java:383)
>     at groovyx.net.http.HTTPBuilder$request$0.call(Unknown Source)
>     at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
>     at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy:358)
>     at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
>     at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
>     at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
>     at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
>     at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
>     at com.jfrog.bintray.gradle.BintrayUploadTask.bintrayUpload(BintrayUploadTask.groovy:392)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:226)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:219)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:208)
>     at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:589)
>     at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:572)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
>     at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
>     at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
>     at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
>     at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
>     at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
>     at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
>     at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
>     at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:310)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
>     at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
>     at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
>     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
>     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
>     at java.lang.Thread.run(Thread.java:745)
> :bintrayUpload FAILED
> FAILURE: Build failed with an exception.
> - What went wrong:
>   Execution failed for task ':bintrayUpload'.
>   > groovyx.net.http.ResponseParseException: Not Allowed
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/267.
 =||= gc old tickets. We will reopen if this happens again.
 =||= ",0
2129,217,Merge pull request #1 from mockito/master,sync with mockito master,"sorry - my mistake
 =||= ",0
2129,247,Fixes #244 StackOverflowError in MockitoSerializationIssue.java,Fixes #244 It looked to me that the getStackTrace() method in MockitoSerializationIssue.java was unneeded. Deleting it solves the problem with Stackoverflow. ,"## [Current coverage](https://codecov.io/github/mockito/mockito?ref=cf08a7032c2124307b28d9da025c52d372ffae62) is `83.77%`

> Merging **#247** into **master** will change coverage by **+0.30%** by [`cf08a70`](https://github.com/mockito/mockito/commit/cf08a7032c2124307b28d9da025c52d372ffae62)

#### Coverage Diff

``` diff
@@            master    #247   diff @@
======================================
  Files          270     270       
  Stmts         4585    4583     -2
  Branches       745     745       
  Methods          0       0       
======================================
+ Hit           3827    3839    +12
  Partial        220     220       
+ Missed         538     524    -14
```

---

### [Uncovered Suggestions](https://codecov.io/github/mockito/mockito/features/suggestions?ref=cf08a7032c2124307b28d9da025c52d372ffae62)
1. `+0.15%` via [...ializableMethod.java#97...103](https://codecov.io/github/mockito/mockito/src/org/mockito/internal/invocation/SerializableMethod.java?ref=cf08a7032c2124307b28d9da025c52d372ffae62#97) 
2. `+0.11%` via [...ns/PluginLoader.java#60...64](https://codecov.io/github/mockito/mockito/src/org/mockito/internal/configuration/plugins/PluginLoader.java?ref=cf08a7032c2124307b28d9da025c52d372ffae62#60) 
3. `+0.11%` via [...lizationSupport.java#122...126](https://codecov.io/github/mockito/mockito/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java?ref=cf08a7032c2124307b28d9da025c52d372ffae62#122) 
4. _[See 7 more...](https://codecov.io/github/mockito/mockito/features/suggestions?ref=cf08a7032c2124307b28d9da025c52d372ffae62)_

> Powered by [Codecov](https://codecov.io)
 =||= Closed via fa0ebda114afefedea340077b60bc1d8474c7767

Thanks @BartoszMiller 
 =||= ",0
2129,259,Removing new line in bottom script. it seems that javadoc…,"… on windows are considering each new line as an argument rather than considering the entire parameter as an argument

The fix that BRIC13 applied in relation to https://github.com/mockito/mockito/issues/256. Did not resolve the issue I have submitted an alternative suggestion, which seems to be working (At least it worked on my machine :p)","## [Current coverage](https://codecov.io/github/mockito/mockito?ref=596d2f5afa0fcf9f3c575577c9549b084296b356) is `83.7%`

> Merging **#259** into **master** will change coverage by **0%** by [`596d2f5`](https://github.com/mockito/mockito/commit/596d2f5afa0fcf9f3c575577c9549b084296b356)

#### Coverage Diff

``` diff
@@            master   #259   diff @@
=====================================
  Files          270    270       
  Stmts         4583   4583       
  Branches       745    745       
  Methods          0      0       
=====================================
  Hit           3836   3836       
  Partial        220    220       
  Missed         527    527       
```

---

### [Uncovered Suggestions](https://codecov.io/github/mockito/mockito/features/suggestions?ref=596d2f5afa0fcf9f3c575577c9549b084296b356)
1. `+0.15%` via [...ializableMethod.java#97...103](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/invocation/SerializableMethod.java?ref=596d2f5afa0fcf9f3c575577c9549b084296b356#97) 
2. `+0.11%` via [...lizationSupport.java#122...126](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java?ref=596d2f5afa0fcf9f3c575577c9549b084296b356#122) 
3. `+0.11%` via [...ns/PluginLoader.java#60...64](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java?ref=596d2f5afa0fcf9f3c575577c9549b084296b356#60) 
4. _[See 7 more...](https://codecov.io/github/mockito/mockito/features/suggestions?ref=596d2f5afa0fcf9f3c575577c9549b084296b356)_

> Powered by [Codecov](https://codecov.io)
 =||= ok I'd rather not do what you propose this way then. Which version of JDK are you running exactly ?
 =||= Hi Brice

I am running java 8 build 45.

Br

Meang

On Sat, Jul 11, 2015, 11:27 Brice Dutheil notifications@github.com wrote:

> ok I'd rather not do what you propose this way then. Which version of JDK
> are you running exactly ?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/259#issuecomment-120598324.
 =||= OK, I'll see what can be done, inlining this script here really hurts readability.
 =||= Fixed by #342 
 =||= ",0
2129,260,Typo in documentation,"Very minor thing, there's an extra ""at"" (@) in the documentation.

If you go to http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#33

![image](https://cloud.githubusercontent.com/assets/338917/8634099/6c7f5264-27b8-11e5-93d9-98b725c9f749.png)",nan,0
2129,269,"Add ""Download"" section to menu in http://mockito.org/","I don't understand why it wasn't done previously.
Now it's look strange to not have searchable Download links with last/stable version at main site page.","you can click on the badges
 =||= @bric3 It's counterintuitive. Badge shows only latest version (not stable). I'm unable to find badge when I search ""download""
 =||= Github project shows both I'll sync the website. However I don't see that as counter intuitive, quite the contrary. Bintray and maven are our distribution platforms.
 =||= Unfortunately at the moment badge service is having a hard time, it will get back up sometime later.
 =||= ",0
2129,245,Serializable check is too harsh,"Hi, apologies if this has been discussed.

While upgrading my company's Mockito to 1.10.19, I ran into a lot of this error:

```
org.mockito.exceptions.base.MockitoException: 
You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'OpportunityClient'
do not implement Serializable AND do not have a no-arg constructor.
This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized
```

In summary, there are two cases triggering this error.
1. The SubjectUnderTest accepts an object Foo and requires it to be Serializable. And yet Foo doesn't implement Serializable nor has a default constructor.
2. Foo itself is Serializable. But the test calls `when(foo.createBar()).thenReturn(bar)`, which behind the scene puts the `bar` mock onto the state of foo, which requires bar itself to be Serializable. In production, bar isn't required to be Serializable.

I feel case 1 is possibly reasonable (although it's still kind of harsh. I'll get to it in a bit).

Case 2 should not require Bar to be Serializable as it does today. In version 1.9.5, our tests worked around it by using `mock(Bar.class, withSettings().serilizable()`. But in version 1.10.19, this workaround breaks if Bar has no default constructor.

Possibly the [Serializable Proxy Pattern](http://stackoverflow.com/questions/702357/what-is-the-serialization-proxy-pattern) could be used to solve this nicely by stashing the ""mock specifications"" into a proxy object that can later on deserialize itself back into a mock Bar with the same number of when().thenReturn().

Now let me try to explain why I think even case 1 is too harsh.

Philosophically, I feel that it's not Mockito's job to ensure the mocked object works in real life. It's a mock object after all. It isn't expected to meet all required specification of the real object.

When in a test I say `@Mock(serializable=true) Foo foo;`, I'm explicitly asking Mockito to ""please pretend my object be Serializable. I don't want to worry about the real object in this test"". Would the real object be serializable when I pass it into SubjectUnderTest? Well:
1. There is nothing guaranteeing that production code passes Foo to SubjectUnderTest. It could likely pass a cousin class RealFoo2 that implements Serializable just fine (or not, but the test doesn't help me with that). It needs to be tested, but IMHO not against a mock foo, especially when Mockito's when().thenReturn() syntax adds non-existent Serializable requirement to the mock object.
2. Given the proxy pattern, that Foo doesn't _look like_ a serializable class isn't a guarantee that it can't be. So by throwing this error, Mockito enforces stricter constraint than what's technically necessary.

I agree that checking basic Serializable requirement in Mockito can catch some bugs. If case 2 can be fixed, it's likely that case 1 would not have triggered so many false positives.

But with all our workarounds already added because of case 2 and the fair number of our tests triggering this error, the amount of work to fix all of them before we can upgrade Mockito looks daunting.

So, I guess my question is: **can we do away with MockCreationValidator.validateSerializable() or make it an opt-in?**

Sorry for the long message.","Here's a real example. The subject under test looks like this:

```
class SubjectUnderTest implements Serializable {
  private final FooFactory factory;

  SubjectUnderTest(FooFactory factory) {
    this.factory= factory;
  }

  ...
  Foo foo = factory.createFoo();
  ...
}
```

The testing framework actually tries to serialize SubjectUnderTest so FooFactory needs to be Serializable too.

The test using Mockito looks like this:

```
Foo foo = mock(Foo.class);
FooFactory mockFactory = mock(FooFactory.class, withSettings().serializable());
when(mockFactory.createFoo()).thenReturn(foo);
SubjectUnderTest subject = new SubjectUnderTest(mockFactory);
```

But when the framework serializes `subject`, we get an exception, because the line of `when(mockFactory.createFoo()).thenReturn(foo)` implicitly adds 'foo' as part of `mockFactory` state.

To work around the problem, our tests had to make foo serializable too:

```
Foo foo = mock(Foo.class, withSettings().serializable());
...
```

Again, production code doesn't need Foo to be Serializable and it may not have a default constructor.

That's status quo.

Now with v1.10.19, the above work-around breaks, because Foo doesn't implement Serializable nor has a default constructor.

Back to square one, if I had the choice, I would strongly discourage the code that mocks either FooFactory or Foo. Instead, it should just be a plain old FooFactory subclass that returns Foo. With Java 8, the syntax would actually become more concise than the mockito syntax. 

But I can't go back and fix so many teams' code. As it stands today, this is the biggest issue blocking the upgrade.

Hopefully I've made a clear case.
 =||= Thanks for reporting.

I'm ok with removing the check or making it smarter. It seems to be a legit
use case. Brice?

Cheers!

On Fri, Jul 3, 2015 at 2:50 PM, Ben Yu notifications@github.com wrote:

> Here's a real example. The subject under test looks like this:
> 
> class SubjectUnderTest implements Serializable {
>   private final FooFactory factory;
> 
>   SubjectUnderTest(FooFactory factory) {
>     this.factory= factory;
>   }
> 
>   ...
>   Foo foo = factory.createFoo();
>   ...
> }
> 
> The testing framework actually tries to serialize SubjectUnderTest so
> FooFactory needs to be Serializable too.
> 
> The test using Mockito looks like this:
> 
> Foo foo = mock(Foo.class);
> FooFactory mockFactory = mock(FooFactory.class, withSettings().serializable());
> when(mockFactory.createFoo()).thenReturn(foo);
> SubjectUnderTest subject = new SubjectUnderTest(mockFactory);
> 
> But when the framework serializes subject, we get an exception, because
> the line of when(mockFactory.createFoo()).thenReturn(foo) implicitly adds
> 'foo' as part of mockFactory state.
> 
> To work around the problem, our tests had to make foo serializable too:
> 
> Foo foo = mock(Foo.class, withSettings().serializable());
> ...
> 
> Again, production code doesn't need Foo to be Serializable and it may not
> have a default constructor.
> 
> That's status quo.
> 
> Now with v1.10.19, the above work-around breaks, because Foo doesn't
> implement Serializable nor has a default constructor.
> 
> Back to square one, if I had the choice, I would strongly discourage the
> code that mocks either FooFactory or Foo. Instead, it should just be a
> plain old FooFactory subclass that returns Foo. With Java 8, the syntax
> would actually become more concise than the mockito syntax.
> 
> But I can't go back and fix so many teams' code. As it stands today, this
> is the biggest issue blocking the upgrade.
> 
> Hopefully I've made a clear case.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/245#issuecomment-118431952.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Hi, is this reasonable? I can send a PR to remove this check, if it's okay with you guys.
 =||= Let's remove the check unless Brice objects ;)

On Fri, Sep 18, 2015 at 9:08 PM, Ben Yu notifications@github.com wrote:

> Hi, is this reasonable? I can send a PR to remove this check, if it's okay
> with you guys.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/245#issuecomment-141618665.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= @szczepiq @fluentfuture is this fix available in any of the mockito releases?
 =||= @vikkyrk since 2.0.31-beta
 =||= Thanks 
 =||= ",0
2129,256,task mockitoJavadoc fails when compiling in windows,"When compiling the mockito project using gradle in a command line in Windows following compile error occurs:

javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/jdk6-project-version-insert.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/jquery-1.7.min.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/highlight-8.6-java/highlight.pack.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<link""
javadoc: error - Illegal package name: ""rel=""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/css""
javadoc: error - Illegal package name: ""href=""
javadoc: error - Illegal package name: ""{@docRoot}/js/highlight-8.6-java/styles/obsidian.css""
javadoc: error - Illegal package name: ""/>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: ""=""
javadoc: error - Illegal package name: ""&&""
javadoc: error - Illegal package name: ""parseInt($.browser.version)""
javadoc: error - Illegal package name: ""<""
javadoc: error - Illegal package name: ""9;""
javadoc: error - Illegal package name: ""if(!usingOldIE)""
javadoc: error - Illegal package name: ""{""
javadoc: error - Illegal package name: ""$(""
javadoc: error - Illegal package name: "").append(""
javadoc: error - Illegal package name: ""<link rel=\""
javadoc: error - Illegal package name: ""icon\\""
javadoc: error - Illegal package name: "" href=\""
javadoc: error - Illegal package name: ""{@docRoot}/favicon.ico?v=cafebabe\\""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: "")""
javadoc: error - Illegal package name: ""$(""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""window.parent.document).append(""
javadoc: error - Illegal package name: ""<link rel=\""
javadoc: error - Illegal package name: ""icon\\""
javadoc: error - Illegal package name: "" href=\""
javadoc: error - Illegal package name: ""{@docRoot}/favicon.ico?v=cafebabe\\""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: "")""
javadoc: error - Illegal package name: ""hljs.initHighlightingOnLoad();""
javadoc: error - Illegal package name: ""injectProjectVersionForJavadocJDK6(""
javadoc: error - Illegal package name: ""Mockito 2.0.29-beta API""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""em#mockito-version-header-javadoc7-header""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""em#mockito-version-header-javadoc7-footer""
javadoc: error - Illegal package name: "");""
javadoc: error - Illegal package name: ""}""
javadoc: error - Illegal package name: ""</script>""
javadoc: error - Illegal package name: """"
javadoc: warning - No source files for package stylesheet
javadoc: warning - No source files for package var
javadoc: warning - No source files for package usingOldIE
javadoc: warning - No source files for package $.browser.msie
javadoc: warning - No source files for package head
javadoc: warning - No source files for package shortcut
javadoc: warning - No source files for package head
javadoc: warning - No source files for package shortcut
64 errors
8 warnings

I tracked the issue down to gradle/javadoc.gradle where the gradle scripts sets the bottom property to a java script with multiple lines. 

Changing that to a single line seems to be make it possible to complete the mockitoJavaDoc task without any errors.","I think most of us work on Linux/OSX, it probably has to do with the JDK
version and windows line endings.

So minifying this javascript code may work ?

-- Brice

On Fri, Jul 10, 2015 at 8:19 AM, Meang Akira Tanaka <
notifications@github.com> wrote:

> When compiling the mockito project using gradle in a command line in
> Windows following compile error occurs:
> 
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/jdk6-project-version-insert.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name: ""{@docRoot}/js/jquery-1.7.min.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/highlight-8.6-java/highlight.pack.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""rel=""
> javadoc: error - Illegal package name: ""type=""
> javadoc: error - Illegal package name: ""text/css""
> javadoc: error - Illegal package name: ""href=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/highlight-8.6-java/styles/obsidian.css""
> javadoc: error - Illegal package name: ""/>""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: ""=""
> javadoc: error - Illegal package name: ""&&""
> javadoc: error - Illegal package name: ""parseInt($.browser.version)""
> javadoc: error - Illegal package name: ""<""
> javadoc: error - Illegal package name: ""9;""
> javadoc: error - Illegal package name: ""if(!usingOldIE)""
> javadoc: error - Illegal package name: ""{""
> javadoc: error - Illegal package name: ""$(""
> javadoc: error - Illegal package name: "").append(""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""icon\""
> javadoc: error - Illegal package name: "" href=\""
> javadoc: error - Illegal package name:
> ""{@docRoot}/favicon.ico?v=cafebabe\""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "")""
> javadoc: error - Illegal package name: ""$(""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name: ""window.parent.document).append(""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""icon\""
> javadoc: error - Illegal package name: "" href=\""
> javadoc: error - Illegal package name:
> ""{@docRoot}/favicon.ico?v=cafebabe\""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "")""
> javadoc: error - Illegal package name: ""hljs.initHighlightingOnLoad();""
> javadoc: error - Illegal package name:
> ""injectProjectVersionForJavadocJDK6(""
> javadoc: error - Illegal package name: ""Mockito 2.0.29-beta API""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name:
> ""em#mockito-version-header-javadoc7-header""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name:
> ""em#mockito-version-header-javadoc7-footer""
> javadoc: error - Illegal package name: "");""
> javadoc: error - Illegal package name: ""}""
> javadoc: error - Illegal package name: """"
> javadoc: error - Illegal package name: """"
> javadoc: warning - No source files for package stylesheet
> javadoc: warning - No source files for package var
> javadoc: warning - No source files for package usingOldIE
> javadoc: warning - No source files for package $.browser.msie
> javadoc: warning - No source files for package head
> javadoc: warning - No source files for package shortcut
> javadoc: warning - No source files for package head
> javadoc: warning - No source files for package shortcut
> 64 errors
> 8 warnings
> 
> I tracked the issue down to gradle/javadoc.gradle where the gradle scripts
> sets the bottom property to a java script with multiple lines.
> 
> Changing that to a single line seems to be make it possible to complete
> the mockitoJavaDoc task without any errors.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/256.
 =||= Fixed via 34f8c69
 =||= Hi Brice

Unfortunately it did not work... I have submitted an alternative suggestion

br

Meang
 =||= ",0
2129,254,Fixes #253 create unsynchronized interceptors for mocks,nan,"This causes both the loss of meta data as well as inherited, synchronized methods. In my understanding, Mockito is not supposed to be thread-safe. But I see the point. I will adress this in some future release of Byte Buddy.
 =||= Yeah the implementation is kinda sketchy.
According to the [FAQ](https://github.com/mockito/mockito/wiki/FAQ) Mockito should support this kind of verification especially in timeout scenarios (timeout() is a sign of a concurrency tests). This kind of verification used to work in Mockito 1.x.
 =||= Indeed. I will have a look at it. Ideally, Byte Buddy would allow to register a transformer that allows a modifier to be changed. I am currently down the rabbit hole to support generic types so I m not yet sure when I'll be able to tackle this. @bric3, is this a blocker? Or should methods even purposely retain their synchronizity even for mocks? (Eventually, Mockito mocks an instance's API. If a user of a mock instance expects its thread to block on a method call of this instance, this would change the API as it is not longer true for the mock instance compared to the actual use case.) Either way, this should be adressed in the FAQ to specify a particular behavior.
 =||= I'd rather not release 2.0 final if we regress on the thread-safety front.
There's still some time to get this sorted out, though.

On Wed, Jul 8, 2015 at 11:57 PM, Rafael Winterhalter <
notifications@github.com> wrote:

> Indeed. I will have a look at it. Ideally, Byte Buddy would be able to
> register a transformer that allows a modifier to be changed. I am currently
> down the rabbit hole to support generic types so I wonder when I'll be able
> to tackle this. @bric3 https://github.com/bric3, is this a blocker?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/254#issuecomment-119846695.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= I addressed the issue by slightly extending Byte Buddy's API. Pull request: https://github.com/mockito/mockito/pull/257 - I'd recommend adding a test case similar to the one of this pull request for future reference.
 =||= Belatle answer yes that should a major drawback of 2.0. @raphw I'll look at #257 
Also thanks for reporting and crafting a fix with this PR @bonifaido :)
 =||= Closing as #257 should fix the issue.
 =||= ",0
2129,255,Mockito plugin annotation,nan,"## [Current coverage](https://codecov.io/github/mockito/mockito?ref=9e363724818455398b8145cc268159d82d1faa8d) is `83.72%`

> Merging **#255** into **master** will change coverage by **+0.02%** by [`9e36372`](https://github.com/mockito/mockito/commit/9e363724818455398b8145cc268159d82d1faa8d)

#### Coverage Diff

``` diff
@@            master    #255   diff @@
======================================
  Files          270     270       
  Stmts         4583    4602    +19
  Branches       745     748     +3
  Methods          0       0       
======================================
+ Hit           3836    3853    +17
- Partial        220     221     +1
- Missed         527     528     +1
```

---

### [Uncovered Suggestions](https://codecov.io/github/mockito/mockito/features/suggestions?ref=9e363724818455398b8145cc268159d82d1faa8d)
1. `+0.16%` via [...ializableMethod.java#97...103](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/invocation/SerializableMethod.java?ref=9e363724818455398b8145cc268159d82d1faa8d#97) 
2. `+0.11%` via [...lizationSupport.java#122...126](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java?ref=9e363724818455398b8145cc268159d82d1faa8d#122) 
3. `+0.11%` via [...ns/PluginLoader.java#60...64](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java?ref=9e363724818455398b8145cc268159d82d1faa8d#60) 
4. _[See 7 more...](https://codecov.io/github/mockito/mockito/features/suggestions?ref=9e363724818455398b8145cc268159d82d1faa8d)_

> Powered by [Codecov](https://codecov.io)
 =||= I found another issue

The class GlobalConfiguration contains a ThreadLocal which contains the latest global configuration, and when running the test the TestBase invokes ConfigurationAccess.getConfig which casts the GlobalConfiguration to a MockitoConfiguration, which is not the case when using the @MockitoPlugin. 

I guess the GlobalConfiguration is meant to serve as a singleton, however I guess that is not possible when you have a annotation engine for each test instance.

Are there any special reason why global configuration has to use a ThreadLocal ?
 =||= > Are there any special reason why global configuration has to use a ThreadLocal ?

I don't remember. @szczepiq do you?

Nice feature overall :)
 =||= By the way your commits should be squashed ;)
 =||= > By the way your commits should be squashed ;)

I tried let's see if I did it correctly :p 
 =||= I moved the removeIt from the globalconfiguration to ConfigurationAccess instead, I think there is an issue with the global configuration that it can only be instantiated once. thereby it will not be possible to have different annotation engine for different test cases.

I think it would make sense to do that so I change the new constructor in GlobalConfiguraton which I implemented to _always_ instantiate a new configuration with the provided annotation engine.
 =||= > > By the way your commits should be squashed ;)
> 
> I tried let's see if I did it correctly :p

Nope, you have imported commits from master , and you somehow did some merge commits from another branch. On _pull request_ branches it is better to keep a clean _flat_ history.

I'm not sure why you needed those merges, but you definitely want to avoid those. _Squashing_ means to put commits together in order to have a clean and meaningful history. This is done via a `git rebase --interactive <the commit references>`. Check our [wiki](https://github.com/mockito/mockito/wiki/Using-git-to-prepare-your-PR-to-have-a-clean-history) on that matter, it contains the bare minimum to understand how to have a clean history. Nevertheless there's better and more complete tutorial out there.

Don't worry I know git is a bit hard when beginning, but once you know your way and why it matters, you won't regret it :)
 =||= So should I make a new branch and transfer all the changes into the new
branch rather than continue working on this messy branch?

Br

Meang

On Sun, Jul 12, 2015, 19:50 Brice Dutheil notifications@github.com wrote:

> By the way your commits should be squashed ;)
> 
> I tried let's see if I did it correctly :p
> 
>  Nope, you have imported commits from master , and you somehow did some
> merge commits from another branch. On _pull request_ branches it is
> better to keep a clean _flat_ history.
> 
> I'm not sure why you needed those merges, but you definitely want to avoid
> those. _Squashing_ means to put commits together in order to have a clean
> and meaningful history. This is done via a git rebase --interactive <the
> commit references>. Check our wiki
> https://github.com/mockito/mockito/wiki/Using-git-to-prepare-your-PR-to-have-a-clean-history
> on that matter, it contains the bare minimum to understand how to have a
> clean history. Nevertheless there's better and more complete tutorial out
> there.
> 
> Don't worry I know git is a bit hard when beginning, but once you know
> your way and why it matters, you won't regret it :)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/255#issuecomment-120750213.
 =||= Yes you can.
Can you close this one when you are ready :)
 =||= Killed it as it the branch was messed up. Have created a new PR and branch for that feature
 =||= ",0
2129,267,bintray upload broken ?,"Yet the binaries seems to be uploaded to bintray and maven (2.0.29-beta is missing on maven). But there's this failure reported during the build.

https://travis-ci.org/mockito/mockito/builds/71779411#L270-L359

```
:bintrayUpload
Error parsing 'text/html' response
groovy.json.JsonException: Unable to determine the current character, it is not a string, number, array, or object
The current character read is '<' with an int value of 60
Unable to determine the current character, it is not a string, number, array, or object
line number 1
index number 0
<html>
^
    at groovy.json.internal.JsonParserCharArray.decodeValueInternal(JsonParserCharArray.java:216)
    at groovy.json.internal.JsonParserCharArray.decodeValue(JsonParserCharArray.java:166)
    at groovy.json.internal.JsonParserCharArray.decodeFromChars(JsonParserCharArray.java:45)
    at groovy.json.internal.JsonParserCharArray.parse(JsonParserCharArray.java:409)
    at groovy.json.internal.BaseJsonParser.parse(BaseJsonParser.java:121)
    at groovy.json.JsonSlurper.parse(JsonSlurper.java:224)
    at groovyx.net.http.ParserRegistry.parseJSON(ParserRegistry.java:280)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1206)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1073)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
    at groovy.lang.Closure.call(Closure.java:423)
    at groovy.lang.Closure.call(Closure.java:439)
    at groovyx.net.http.HTTPBuilder.parseResponse(HTTPBuilder.java:560)
    at groovyx.net.http.HTTPBuilder$1.handleResponse(HTTPBuilder.java:489)
    at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1070)
    at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1044)
    at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:515)
    at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:434)
    at groovyx.net.http.HTTPBuilder.request(HTTPBuilder.java:383)
    at groovyx.net.http.HTTPBuilder$request$0.call(Unknown Source)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
    at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy:358)
    at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
    at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
    at com.jfrog.bintray.gradle.BintrayUploadTask.bintrayUpload(BintrayUploadTask.groovy:392)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:226)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:219)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:208)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:589)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:572)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
    at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
    at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:310)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
    at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
    at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:745)
:bintrayUpload FAILED
FAILURE: Build failed with an exception.
* What went wrong:
Execution failed for task ':bintrayUpload'.
> groovyx.net.http.ResponseParseException: Not Allowed
```","I have seen this. For some reason automatic publish to central fails. Can
be synced manually from bintray api. Javadoc and release notes are not
updated, too. I will look into it.

On Mon, Jul 20, 2015, 17:01 Brice Dutheil notifications@github.com wrote:

> https://travis-ci.org/mockito/mockito/builds/71779411#L270-L359
> 
> Yet the binaries seems to be uploaded to bintray but not maven
> (2.0.29-beta is missing, waiting for 2.0.30-beta to sync)
> 
> :bintrayUpload
> Error parsing 'text/html' response
> groovy.json.JsonException: Unable to determine the current character, it is not a string, number, array, or object
> The current character read is '<' with an int value of 60
> Unable to determine the current character, it is not a string, number, array, or object
> line number 1
> index number 0
> <html>
> ^
>     at groovy.json.internal.JsonParserCharArray.decodeValueInternal(JsonParserCharArray.java:216)
>     at groovy.json.internal.JsonParserCharArray.decodeValue(JsonParserCharArray.java:166)
>     at groovy.json.internal.JsonParserCharArray.decodeFromChars(JsonParserCharArray.java:45)
>     at groovy.json.internal.JsonParserCharArray.parse(JsonParserCharArray.java:409)
>     at groovy.json.internal.BaseJsonParser.parse(BaseJsonParser.java:121)
>     at groovy.json.JsonSlurper.parse(JsonSlurper.java:224)
>     at groovyx.net.http.ParserRegistry.parseJSON(ParserRegistry.java:280)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
>     at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1206)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1073)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
>     at groovy.lang.Closure.call(Closure.java:423)
>     at groovy.lang.Closure.call(Closure.java:439)
>     at groovyx.net.http.HTTPBuilder.parseResponse(HTTPBuilder.java:560)
>     at groovyx.net.http.HTTPBuilder$1.handleResponse(HTTPBuilder.java:489)
>     at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1070)
>     at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1044)
>     at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:515)
>     at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:434)
>     at groovyx.net.http.HTTPBuilder.request(HTTPBuilder.java:383)
>     at groovyx.net.http.HTTPBuilder$request$0.call(Unknown Source)
>     at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
>     at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy:358)
>     at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
>     at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
>     at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
>     at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
>     at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
>     at com.jfrog.bintray.gradle.BintrayUploadTask.bintrayUpload(BintrayUploadTask.groovy:392)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:226)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:219)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:208)
>     at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:589)
>     at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:572)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
>     at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
>     at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
>     at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
>     at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
>     at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
>     at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
>     at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
>     at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:310)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
>     at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
>     at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
>     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
>     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
>     at java.lang.Thread.run(Thread.java:745)
> :bintrayUpload FAILED
> FAILURE: Build failed with an exception.
> - What went wrong:
>   Execution failed for task ':bintrayUpload'.
>   > groovyx.net.http.ResponseParseException: Not Allowed
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/267.
 =||= gc old tickets. We will reopen if this happens again.
 =||= ",0
2129,217,Merge pull request #1 from mockito/master,sync with mockito master,"sorry - my mistake
 =||= ",0
2129,247,Fixes #244 StackOverflowError in MockitoSerializationIssue.java,Fixes #244 It looked to me that the getStackTrace() method in MockitoSerializationIssue.java was unneeded. Deleting it solves the problem with Stackoverflow. ,"## [Current coverage](https://codecov.io/github/mockito/mockito?ref=cf08a7032c2124307b28d9da025c52d372ffae62) is `83.77%`

> Merging **#247** into **master** will change coverage by **+0.30%** by [`cf08a70`](https://github.com/mockito/mockito/commit/cf08a7032c2124307b28d9da025c52d372ffae62)

#### Coverage Diff

``` diff
@@            master    #247   diff @@
======================================
  Files          270     270       
  Stmts         4585    4583     -2
  Branches       745     745       
  Methods          0       0       
======================================
+ Hit           3827    3839    +12
  Partial        220     220       
+ Missed         538     524    -14
```

---

### [Uncovered Suggestions](https://codecov.io/github/mockito/mockito/features/suggestions?ref=cf08a7032c2124307b28d9da025c52d372ffae62)
1. `+0.15%` via [...ializableMethod.java#97...103](https://codecov.io/github/mockito/mockito/src/org/mockito/internal/invocation/SerializableMethod.java?ref=cf08a7032c2124307b28d9da025c52d372ffae62#97) 
2. `+0.11%` via [...ns/PluginLoader.java#60...64](https://codecov.io/github/mockito/mockito/src/org/mockito/internal/configuration/plugins/PluginLoader.java?ref=cf08a7032c2124307b28d9da025c52d372ffae62#60) 
3. `+0.11%` via [...lizationSupport.java#122...126](https://codecov.io/github/mockito/mockito/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java?ref=cf08a7032c2124307b28d9da025c52d372ffae62#122) 
4. _[See 7 more...](https://codecov.io/github/mockito/mockito/features/suggestions?ref=cf08a7032c2124307b28d9da025c52d372ffae62)_

> Powered by [Codecov](https://codecov.io)
 =||= Closed via fa0ebda114afefedea340077b60bc1d8474c7767

Thanks @BartoszMiller 
 =||= ",0
2129,259,Removing new line in bottom script. it seems that javadoc…,"… on windows are considering each new line as an argument rather than considering the entire parameter as an argument

The fix that BRIC13 applied in relation to https://github.com/mockito/mockito/issues/256. Did not resolve the issue I have submitted an alternative suggestion, which seems to be working (At least it worked on my machine :p)","## [Current coverage](https://codecov.io/github/mockito/mockito?ref=596d2f5afa0fcf9f3c575577c9549b084296b356) is `83.7%`

> Merging **#259** into **master** will change coverage by **0%** by [`596d2f5`](https://github.com/mockito/mockito/commit/596d2f5afa0fcf9f3c575577c9549b084296b356)

#### Coverage Diff

``` diff
@@            master   #259   diff @@
=====================================
  Files          270    270       
  Stmts         4583   4583       
  Branches       745    745       
  Methods          0      0       
=====================================
  Hit           3836   3836       
  Partial        220    220       
  Missed         527    527       
```

---

### [Uncovered Suggestions](https://codecov.io/github/mockito/mockito/features/suggestions?ref=596d2f5afa0fcf9f3c575577c9549b084296b356)
1. `+0.15%` via [...ializableMethod.java#97...103](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/invocation/SerializableMethod.java?ref=596d2f5afa0fcf9f3c575577c9549b084296b356#97) 
2. `+0.11%` via [...lizationSupport.java#122...126](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java?ref=596d2f5afa0fcf9f3c575577c9549b084296b356#122) 
3. `+0.11%` via [...ns/PluginLoader.java#60...64](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java?ref=596d2f5afa0fcf9f3c575577c9549b084296b356#60) 
4. _[See 7 more...](https://codecov.io/github/mockito/mockito/features/suggestions?ref=596d2f5afa0fcf9f3c575577c9549b084296b356)_

> Powered by [Codecov](https://codecov.io)
 =||= ok I'd rather not do what you propose this way then. Which version of JDK are you running exactly ?
 =||= Hi Brice

I am running java 8 build 45.

Br

Meang

On Sat, Jul 11, 2015, 11:27 Brice Dutheil notifications@github.com wrote:

> ok I'd rather not do what you propose this way then. Which version of JDK
> are you running exactly ?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/259#issuecomment-120598324.
 =||= OK, I'll see what can be done, inlining this script here really hurts readability.
 =||= Fixed by #342 
 =||= ",0
2129,260,Typo in documentation,"Very minor thing, there's an extra ""at"" (@) in the documentation.

If you go to http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#33

![image](https://cloud.githubusercontent.com/assets/338917/8634099/6c7f5264-27b8-11e5-93d9-98b725c9f749.png)",nan,0
2129,269,"Add ""Download"" section to menu in http://mockito.org/","I don't understand why it wasn't done previously.
Now it's look strange to not have searchable Download links with last/stable version at main site page.","you can click on the badges
 =||= @bric3 It's counterintuitive. Badge shows only latest version (not stable). I'm unable to find badge when I search ""download""
 =||= Github project shows both I'll sync the website. However I don't see that as counter intuitive, quite the contrary. Bintray and maven are our distribution platforms.
 =||= Unfortunately at the moment badge service is having a hard time, it will get back up sometime later.
 =||= ",0
2129,245,Serializable check is too harsh,"Hi, apologies if this has been discussed.

While upgrading my company's Mockito to 1.10.19, I ran into a lot of this error:

```
org.mockito.exceptions.base.MockitoException: 
You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'OpportunityClient'
do not implement Serializable AND do not have a no-arg constructor.
This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized
```

In summary, there are two cases triggering this error.
1. The SubjectUnderTest accepts an object Foo and requires it to be Serializable. And yet Foo doesn't implement Serializable nor has a default constructor.
2. Foo itself is Serializable. But the test calls `when(foo.createBar()).thenReturn(bar)`, which behind the scene puts the `bar` mock onto the state of foo, which requires bar itself to be Serializable. In production, bar isn't required to be Serializable.

I feel case 1 is possibly reasonable (although it's still kind of harsh. I'll get to it in a bit).

Case 2 should not require Bar to be Serializable as it does today. In version 1.9.5, our tests worked around it by using `mock(Bar.class, withSettings().serilizable()`. But in version 1.10.19, this workaround breaks if Bar has no default constructor.

Possibly the [Serializable Proxy Pattern](http://stackoverflow.com/questions/702357/what-is-the-serialization-proxy-pattern) could be used to solve this nicely by stashing the ""mock specifications"" into a proxy object that can later on deserialize itself back into a mock Bar with the same number of when().thenReturn().

Now let me try to explain why I think even case 1 is too harsh.

Philosophically, I feel that it's not Mockito's job to ensure the mocked object works in real life. It's a mock object after all. It isn't expected to meet all required specification of the real object.

When in a test I say `@Mock(serializable=true) Foo foo;`, I'm explicitly asking Mockito to ""please pretend my object be Serializable. I don't want to worry about the real object in this test"". Would the real object be serializable when I pass it into SubjectUnderTest? Well:
1. There is nothing guaranteeing that production code passes Foo to SubjectUnderTest. It could likely pass a cousin class RealFoo2 that implements Serializable just fine (or not, but the test doesn't help me with that). It needs to be tested, but IMHO not against a mock foo, especially when Mockito's when().thenReturn() syntax adds non-existent Serializable requirement to the mock object.
2. Given the proxy pattern, that Foo doesn't _look like_ a serializable class isn't a guarantee that it can't be. So by throwing this error, Mockito enforces stricter constraint than what's technically necessary.

I agree that checking basic Serializable requirement in Mockito can catch some bugs. If case 2 can be fixed, it's likely that case 1 would not have triggered so many false positives.

But with all our workarounds already added because of case 2 and the fair number of our tests triggering this error, the amount of work to fix all of them before we can upgrade Mockito looks daunting.

So, I guess my question is: **can we do away with MockCreationValidator.validateSerializable() or make it an opt-in?**

Sorry for the long message.","Here's a real example. The subject under test looks like this:

```
class SubjectUnderTest implements Serializable {
  private final FooFactory factory;

  SubjectUnderTest(FooFactory factory) {
    this.factory= factory;
  }

  ...
  Foo foo = factory.createFoo();
  ...
}
```

The testing framework actually tries to serialize SubjectUnderTest so FooFactory needs to be Serializable too.

The test using Mockito looks like this:

```
Foo foo = mock(Foo.class);
FooFactory mockFactory = mock(FooFactory.class, withSettings().serializable());
when(mockFactory.createFoo()).thenReturn(foo);
SubjectUnderTest subject = new SubjectUnderTest(mockFactory);
```

But when the framework serializes `subject`, we get an exception, because the line of `when(mockFactory.createFoo()).thenReturn(foo)` implicitly adds 'foo' as part of `mockFactory` state.

To work around the problem, our tests had to make foo serializable too:

```
Foo foo = mock(Foo.class, withSettings().serializable());
...
```

Again, production code doesn't need Foo to be Serializable and it may not have a default constructor.

That's status quo.

Now with v1.10.19, the above work-around breaks, because Foo doesn't implement Serializable nor has a default constructor.

Back to square one, if I had the choice, I would strongly discourage the code that mocks either FooFactory or Foo. Instead, it should just be a plain old FooFactory subclass that returns Foo. With Java 8, the syntax would actually become more concise than the mockito syntax. 

But I can't go back and fix so many teams' code. As it stands today, this is the biggest issue blocking the upgrade.

Hopefully I've made a clear case.
 =||= Thanks for reporting.

I'm ok with removing the check or making it smarter. It seems to be a legit
use case. Brice?

Cheers!

On Fri, Jul 3, 2015 at 2:50 PM, Ben Yu notifications@github.com wrote:

> Here's a real example. The subject under test looks like this:
> 
> class SubjectUnderTest implements Serializable {
>   private final FooFactory factory;
> 
>   SubjectUnderTest(FooFactory factory) {
>     this.factory= factory;
>   }
> 
>   ...
>   Foo foo = factory.createFoo();
>   ...
> }
> 
> The testing framework actually tries to serialize SubjectUnderTest so
> FooFactory needs to be Serializable too.
> 
> The test using Mockito looks like this:
> 
> Foo foo = mock(Foo.class);
> FooFactory mockFactory = mock(FooFactory.class, withSettings().serializable());
> when(mockFactory.createFoo()).thenReturn(foo);
> SubjectUnderTest subject = new SubjectUnderTest(mockFactory);
> 
> But when the framework serializes subject, we get an exception, because
> the line of when(mockFactory.createFoo()).thenReturn(foo) implicitly adds
> 'foo' as part of mockFactory state.
> 
> To work around the problem, our tests had to make foo serializable too:
> 
> Foo foo = mock(Foo.class, withSettings().serializable());
> ...
> 
> Again, production code doesn't need Foo to be Serializable and it may not
> have a default constructor.
> 
> That's status quo.
> 
> Now with v1.10.19, the above work-around breaks, because Foo doesn't
> implement Serializable nor has a default constructor.
> 
> Back to square one, if I had the choice, I would strongly discourage the
> code that mocks either FooFactory or Foo. Instead, it should just be a
> plain old FooFactory subclass that returns Foo. With Java 8, the syntax
> would actually become more concise than the mockito syntax.
> 
> But I can't go back and fix so many teams' code. As it stands today, this
> is the biggest issue blocking the upgrade.
> 
> Hopefully I've made a clear case.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/245#issuecomment-118431952.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Hi, is this reasonable? I can send a PR to remove this check, if it's okay with you guys.
 =||= Let's remove the check unless Brice objects ;)

On Fri, Sep 18, 2015 at 9:08 PM, Ben Yu notifications@github.com wrote:

> Hi, is this reasonable? I can send a PR to remove this check, if it's okay
> with you guys.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/245#issuecomment-141618665.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= @szczepiq @fluentfuture is this fix available in any of the mockito releases?
 =||= @vikkyrk since 2.0.31-beta
 =||= Thanks 
 =||= ",0
2129,256,task mockitoJavadoc fails when compiling in windows,"When compiling the mockito project using gradle in a command line in Windows following compile error occurs:

javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/jdk6-project-version-insert.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/jquery-1.7.min.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: ""src=""
javadoc: error - Illegal package name: ""{@docRoot}/js/highlight-8.6-java/highlight.pack.js""
javadoc: error - Illegal package name: ""></script>""
javadoc: error - Illegal package name: ""<link""
javadoc: error - Illegal package name: ""rel=""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/css""
javadoc: error - Illegal package name: ""href=""
javadoc: error - Illegal package name: ""{@docRoot}/js/highlight-8.6-java/styles/obsidian.css""
javadoc: error - Illegal package name: ""/>""
javadoc: error - Illegal package name: ""<script""
javadoc: error - Illegal package name: ""type=""
javadoc: error - Illegal package name: ""text/javascript""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: ""=""
javadoc: error - Illegal package name: ""&&""
javadoc: error - Illegal package name: ""parseInt($.browser.version)""
javadoc: error - Illegal package name: ""<""
javadoc: error - Illegal package name: ""9;""
javadoc: error - Illegal package name: ""if(!usingOldIE)""
javadoc: error - Illegal package name: ""{""
javadoc: error - Illegal package name: ""$(""
javadoc: error - Illegal package name: "").append(""
javadoc: error - Illegal package name: ""<link rel=\""
javadoc: error - Illegal package name: ""icon\\""
javadoc: error - Illegal package name: "" href=\""
javadoc: error - Illegal package name: ""{@docRoot}/favicon.ico?v=cafebabe\\""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: "")""
javadoc: error - Illegal package name: ""$(""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""window.parent.document).append(""
javadoc: error - Illegal package name: ""<link rel=\""
javadoc: error - Illegal package name: ""icon\\""
javadoc: error - Illegal package name: "" href=\""
javadoc: error - Illegal package name: ""{@docRoot}/favicon.ico?v=cafebabe\\""
javadoc: error - Illegal package name: "">""
javadoc: error - Illegal package name: "")""
javadoc: error - Illegal package name: ""hljs.initHighlightingOnLoad();""
javadoc: error - Illegal package name: ""injectProjectVersionForJavadocJDK6(""
javadoc: error - Illegal package name: ""Mockito 2.0.29-beta API""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""em#mockito-version-header-javadoc7-header""
javadoc: error - Illegal package name: "",""
javadoc: error - Illegal package name: ""em#mockito-version-header-javadoc7-footer""
javadoc: error - Illegal package name: "");""
javadoc: error - Illegal package name: ""}""
javadoc: error - Illegal package name: ""</script>""
javadoc: error - Illegal package name: """"
javadoc: warning - No source files for package stylesheet
javadoc: warning - No source files for package var
javadoc: warning - No source files for package usingOldIE
javadoc: warning - No source files for package $.browser.msie
javadoc: warning - No source files for package head
javadoc: warning - No source files for package shortcut
javadoc: warning - No source files for package head
javadoc: warning - No source files for package shortcut
64 errors
8 warnings

I tracked the issue down to gradle/javadoc.gradle where the gradle scripts sets the bottom property to a java script with multiple lines. 

Changing that to a single line seems to be make it possible to complete the mockitoJavaDoc task without any errors.","I think most of us work on Linux/OSX, it probably has to do with the JDK
version and windows line endings.

So minifying this javascript code may work ?

-- Brice

On Fri, Jul 10, 2015 at 8:19 AM, Meang Akira Tanaka <
notifications@github.com> wrote:

> When compiling the mockito project using gradle in a command line in
> Windows following compile error occurs:
> 
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/jdk6-project-version-insert.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name: ""{@docRoot}/js/jquery-1.7.min.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: ""src=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/highlight-8.6-java/highlight.pack.js""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""rel=""
> javadoc: error - Illegal package name: ""type=""
> javadoc: error - Illegal package name: ""text/css""
> javadoc: error - Illegal package name: ""href=""
> javadoc: error - Illegal package name:
> ""{@docRoot}/js/highlight-8.6-java/styles/obsidian.css""
> javadoc: error - Illegal package name: ""/>""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""type=""
> javadoc: error - Illegal package name: ""text/javascript""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: ""=""
> javadoc: error - Illegal package name: ""&&""
> javadoc: error - Illegal package name: ""parseInt($.browser.version)""
> javadoc: error - Illegal package name: ""<""
> javadoc: error - Illegal package name: ""9;""
> javadoc: error - Illegal package name: ""if(!usingOldIE)""
> javadoc: error - Illegal package name: ""{""
> javadoc: error - Illegal package name: ""$(""
> javadoc: error - Illegal package name: "").append(""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""icon\""
> javadoc: error - Illegal package name: "" href=\""
> javadoc: error - Illegal package name:
> ""{@docRoot}/favicon.ico?v=cafebabe\""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "")""
> javadoc: error - Illegal package name: ""$(""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name: ""window.parent.document).append(""
> javadoc: error - Illegal package name: "" javadoc: error - Illegal package
> name: ""icon\""
> javadoc: error - Illegal package name: "" href=\""
> javadoc: error - Illegal package name:
> ""{@docRoot}/favicon.ico?v=cafebabe\""
> javadoc: error - Illegal package name: "">""
> javadoc: error - Illegal package name: "")""
> javadoc: error - Illegal package name: ""hljs.initHighlightingOnLoad();""
> javadoc: error - Illegal package name:
> ""injectProjectVersionForJavadocJDK6(""
> javadoc: error - Illegal package name: ""Mockito 2.0.29-beta API""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name:
> ""em#mockito-version-header-javadoc7-header""
> javadoc: error - Illegal package name: "",""
> javadoc: error - Illegal package name:
> ""em#mockito-version-header-javadoc7-footer""
> javadoc: error - Illegal package name: "");""
> javadoc: error - Illegal package name: ""}""
> javadoc: error - Illegal package name: """"
> javadoc: error - Illegal package name: """"
> javadoc: warning - No source files for package stylesheet
> javadoc: warning - No source files for package var
> javadoc: warning - No source files for package usingOldIE
> javadoc: warning - No source files for package $.browser.msie
> javadoc: warning - No source files for package head
> javadoc: warning - No source files for package shortcut
> javadoc: warning - No source files for package head
> javadoc: warning - No source files for package shortcut
> 64 errors
> 8 warnings
> 
> I tracked the issue down to gradle/javadoc.gradle where the gradle scripts
> sets the bottom property to a java script with multiple lines.
> 
> Changing that to a single line seems to be make it possible to complete
> the mockitoJavaDoc task without any errors.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/256.
 =||= Fixed via 34f8c69
 =||= Hi Brice

Unfortunately it did not work... I have submitted an alternative suggestion

br

Meang
 =||= ",0
2129,254,Fixes #253 create unsynchronized interceptors for mocks,nan,"This causes both the loss of meta data as well as inherited, synchronized methods. In my understanding, Mockito is not supposed to be thread-safe. But I see the point. I will adress this in some future release of Byte Buddy.
 =||= Yeah the implementation is kinda sketchy.
According to the [FAQ](https://github.com/mockito/mockito/wiki/FAQ) Mockito should support this kind of verification especially in timeout scenarios (timeout() is a sign of a concurrency tests). This kind of verification used to work in Mockito 1.x.
 =||= Indeed. I will have a look at it. Ideally, Byte Buddy would allow to register a transformer that allows a modifier to be changed. I am currently down the rabbit hole to support generic types so I m not yet sure when I'll be able to tackle this. @bric3, is this a blocker? Or should methods even purposely retain their synchronizity even for mocks? (Eventually, Mockito mocks an instance's API. If a user of a mock instance expects its thread to block on a method call of this instance, this would change the API as it is not longer true for the mock instance compared to the actual use case.) Either way, this should be adressed in the FAQ to specify a particular behavior.
 =||= I'd rather not release 2.0 final if we regress on the thread-safety front.
There's still some time to get this sorted out, though.

On Wed, Jul 8, 2015 at 11:57 PM, Rafael Winterhalter <
notifications@github.com> wrote:

> Indeed. I will have a look at it. Ideally, Byte Buddy would be able to
> register a transformer that allows a modifier to be changed. I am currently
> down the rabbit hole to support generic types so I wonder when I'll be able
> to tackle this. @bric3 https://github.com/bric3, is this a blocker?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/254#issuecomment-119846695.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= I addressed the issue by slightly extending Byte Buddy's API. Pull request: https://github.com/mockito/mockito/pull/257 - I'd recommend adding a test case similar to the one of this pull request for future reference.
 =||= Belatle answer yes that should a major drawback of 2.0. @raphw I'll look at #257 
Also thanks for reporting and crafting a fix with this PR @bonifaido :)
 =||= Closing as #257 should fix the issue.
 =||= ",0
2129,255,Mockito plugin annotation,nan,"## [Current coverage](https://codecov.io/github/mockito/mockito?ref=9e363724818455398b8145cc268159d82d1faa8d) is `83.72%`

> Merging **#255** into **master** will change coverage by **+0.02%** by [`9e36372`](https://github.com/mockito/mockito/commit/9e363724818455398b8145cc268159d82d1faa8d)

#### Coverage Diff

``` diff
@@            master    #255   diff @@
======================================
  Files          270     270       
  Stmts         4583    4602    +19
  Branches       745     748     +3
  Methods          0       0       
======================================
+ Hit           3836    3853    +17
- Partial        220     221     +1
- Missed         527     528     +1
```

---

### [Uncovered Suggestions](https://codecov.io/github/mockito/mockito/features/suggestions?ref=9e363724818455398b8145cc268159d82d1faa8d)
1. `+0.16%` via [...ializableMethod.java#97...103](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/invocation/SerializableMethod.java?ref=9e363724818455398b8145cc268159d82d1faa8d#97) 
2. `+0.11%` via [...lizationSupport.java#122...126](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java?ref=9e363724818455398b8145cc268159d82d1faa8d#122) 
3. `+0.11%` via [...ns/PluginLoader.java#60...64](https://codecov.io/github/mockito/mockito/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java?ref=9e363724818455398b8145cc268159d82d1faa8d#60) 
4. _[See 7 more...](https://codecov.io/github/mockito/mockito/features/suggestions?ref=9e363724818455398b8145cc268159d82d1faa8d)_

> Powered by [Codecov](https://codecov.io)
 =||= I found another issue

The class GlobalConfiguration contains a ThreadLocal which contains the latest global configuration, and when running the test the TestBase invokes ConfigurationAccess.getConfig which casts the GlobalConfiguration to a MockitoConfiguration, which is not the case when using the @MockitoPlugin. 

I guess the GlobalConfiguration is meant to serve as a singleton, however I guess that is not possible when you have a annotation engine for each test instance.

Are there any special reason why global configuration has to use a ThreadLocal ?
 =||= > Are there any special reason why global configuration has to use a ThreadLocal ?

I don't remember. @szczepiq do you?

Nice feature overall :)
 =||= By the way your commits should be squashed ;)
 =||= > By the way your commits should be squashed ;)

I tried let's see if I did it correctly :p 
 =||= I moved the removeIt from the globalconfiguration to ConfigurationAccess instead, I think there is an issue with the global configuration that it can only be instantiated once. thereby it will not be possible to have different annotation engine for different test cases.

I think it would make sense to do that so I change the new constructor in GlobalConfiguraton which I implemented to _always_ instantiate a new configuration with the provided annotation engine.
 =||= > > By the way your commits should be squashed ;)
> 
> I tried let's see if I did it correctly :p

Nope, you have imported commits from master , and you somehow did some merge commits from another branch. On _pull request_ branches it is better to keep a clean _flat_ history.

I'm not sure why you needed those merges, but you definitely want to avoid those. _Squashing_ means to put commits together in order to have a clean and meaningful history. This is done via a `git rebase --interactive <the commit references>`. Check our [wiki](https://github.com/mockito/mockito/wiki/Using-git-to-prepare-your-PR-to-have-a-clean-history) on that matter, it contains the bare minimum to understand how to have a clean history. Nevertheless there's better and more complete tutorial out there.

Don't worry I know git is a bit hard when beginning, but once you know your way and why it matters, you won't regret it :)
 =||= So should I make a new branch and transfer all the changes into the new
branch rather than continue working on this messy branch?

Br

Meang

On Sun, Jul 12, 2015, 19:50 Brice Dutheil notifications@github.com wrote:

> By the way your commits should be squashed ;)
> 
> I tried let's see if I did it correctly :p
> 
>  Nope, you have imported commits from master , and you somehow did some
> merge commits from another branch. On _pull request_ branches it is
> better to keep a clean _flat_ history.
> 
> I'm not sure why you needed those merges, but you definitely want to avoid
> those. _Squashing_ means to put commits together in order to have a clean
> and meaningful history. This is done via a git rebase --interactive <the
> commit references>. Check our wiki
> https://github.com/mockito/mockito/wiki/Using-git-to-prepare-your-PR-to-have-a-clean-history
> on that matter, it contains the bare minimum to understand how to have a
> clean history. Nevertheless there's better and more complete tutorial out
> there.
> 
> Don't worry I know git is a bit hard when beginning, but once you know
> your way and why it matters, you won't regret it :)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/255#issuecomment-120750213.
 =||= Yes you can.
Can you close this one when you are ready :)
 =||= Killed it as it the branch was messed up. Have created a new PR and branch for that feature
 =||= ",0
2129,267,bintray upload broken ?,"Yet the binaries seems to be uploaded to bintray and maven (2.0.29-beta is missing on maven). But there's this failure reported during the build.

https://travis-ci.org/mockito/mockito/builds/71779411#L270-L359

```
:bintrayUpload
Error parsing 'text/html' response
groovy.json.JsonException: Unable to determine the current character, it is not a string, number, array, or object
The current character read is '<' with an int value of 60
Unable to determine the current character, it is not a string, number, array, or object
line number 1
index number 0
<html>
^
    at groovy.json.internal.JsonParserCharArray.decodeValueInternal(JsonParserCharArray.java:216)
    at groovy.json.internal.JsonParserCharArray.decodeValue(JsonParserCharArray.java:166)
    at groovy.json.internal.JsonParserCharArray.decodeFromChars(JsonParserCharArray.java:45)
    at groovy.json.internal.JsonParserCharArray.parse(JsonParserCharArray.java:409)
    at groovy.json.internal.BaseJsonParser.parse(BaseJsonParser.java:121)
    at groovy.json.JsonSlurper.parse(JsonSlurper.java:224)
    at groovyx.net.http.ParserRegistry.parseJSON(ParserRegistry.java:280)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1206)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1073)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
    at groovy.lang.Closure.call(Closure.java:423)
    at groovy.lang.Closure.call(Closure.java:439)
    at groovyx.net.http.HTTPBuilder.parseResponse(HTTPBuilder.java:560)
    at groovyx.net.http.HTTPBuilder$1.handleResponse(HTTPBuilder.java:489)
    at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1070)
    at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1044)
    at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:515)
    at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:434)
    at groovyx.net.http.HTTPBuilder.request(HTTPBuilder.java:383)
    at groovyx.net.http.HTTPBuilder$request$0.call(Unknown Source)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
    at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy:358)
    at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
    at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
    at com.jfrog.bintray.gradle.BintrayUploadTask.bintrayUpload(BintrayUploadTask.groovy:392)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:226)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:219)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:208)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:589)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:572)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
    at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
    at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:310)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
    at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
    at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:745)
:bintrayUpload FAILED
FAILURE: Build failed with an exception.
* What went wrong:
Execution failed for task ':bintrayUpload'.
> groovyx.net.http.ResponseParseException: Not Allowed
```","I have seen this. For some reason automatic publish to central fails. Can
be synced manually from bintray api. Javadoc and release notes are not
updated, too. I will look into it.

On Mon, Jul 20, 2015, 17:01 Brice Dutheil notifications@github.com wrote:

> https://travis-ci.org/mockito/mockito/builds/71779411#L270-L359
> 
> Yet the binaries seems to be uploaded to bintray but not maven
> (2.0.29-beta is missing, waiting for 2.0.30-beta to sync)
> 
> :bintrayUpload
> Error parsing 'text/html' response
> groovy.json.JsonException: Unable to determine the current character, it is not a string, number, array, or object
> The current character read is '<' with an int value of 60
> Unable to determine the current character, it is not a string, number, array, or object
> line number 1
> index number 0
> <html>
> ^
>     at groovy.json.internal.JsonParserCharArray.decodeValueInternal(JsonParserCharArray.java:216)
>     at groovy.json.internal.JsonParserCharArray.decodeValue(JsonParserCharArray.java:166)
>     at groovy.json.internal.JsonParserCharArray.decodeFromChars(JsonParserCharArray.java:45)
>     at groovy.json.internal.JsonParserCharArray.parse(JsonParserCharArray.java:409)
>     at groovy.json.internal.BaseJsonParser.parse(BaseJsonParser.java:121)
>     at groovy.json.JsonSlurper.parse(JsonSlurper.java:224)
>     at groovyx.net.http.ParserRegistry.parseJSON(ParserRegistry.java:280)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
>     at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1206)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1073)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
>     at groovy.lang.Closure.call(Closure.java:423)
>     at groovy.lang.Closure.call(Closure.java:439)
>     at groovyx.net.http.HTTPBuilder.parseResponse(HTTPBuilder.java:560)
>     at groovyx.net.http.HTTPBuilder$1.handleResponse(HTTPBuilder.java:489)
>     at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1070)
>     at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1044)
>     at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:515)
>     at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:434)
>     at groovyx.net.http.HTTPBuilder.request(HTTPBuilder.java:383)
>     at groovyx.net.http.HTTPBuilder$request$0.call(Unknown Source)
>     at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
>     at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy:358)
>     at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
>     at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
>     at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
>     at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
>     at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
>     at com.jfrog.bintray.gradle.BintrayUploadTask.bintrayUpload(BintrayUploadTask.groovy:392)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:226)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:219)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:208)
>     at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:589)
>     at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:572)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
>     at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
>     at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
>     at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
>     at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
>     at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
>     at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
>     at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
>     at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:310)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
>     at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
>     at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
>     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
>     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
>     at java.lang.Thread.run(Thread.java:745)
> :bintrayUpload FAILED
> FAILURE: Build failed with an exception.
> - What went wrong:
>   Execution failed for task ':bintrayUpload'.
>   > groovyx.net.http.ResponseParseException: Not Allowed
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/267.
 =||= gc old tickets. We will reopen if this happens again.
 =||= ",0
2129,217,Merge pull request #1 from mockito/master,sync with mockito master,"sorry - my mistake
 =||= ",0
2129,247,Fixes #244 StackOverflowError in MockitoSerializationIssue.java,Fixes #244 It looked to me that the getStackTrace() method in MockitoSerializationIssue.java was unneeded. Deleting it solves the problem with Stackoverflow. ,"## [Current coverage](https://codecov.io/github/mockito/mockito?ref=cf08a7032c2124307b28d9da025c52d372ffae62) is `83.77%`

> Merging **#247** into **master** will change coverage by **+0.30%** by [`cf08a70`](https://github.com/mockito/mockito/commit/cf08a7032c2124307b28d9da025c52d372ffae62)

#### Coverage Diff

``` diff
@@            master    #247   diff @@
======================================
  Files          270     270       
  Stmts         4585    4583     -2
  Branches       745     745       
  Methods          0       0       
======================================
+ Hit           3827    3839    +12
  Partial        220     220       
+ Missed         538     524    -14
```

---

### [Uncovered Suggestions](https://codecov.io/github/mockito/mockito/features/suggestions?ref=cf08a7032c2124307b28d9da025c52d372ffae62)
1. `+0.15%` via [...ializableMethod.java#97...103](https://codecov.io/github/mockito/mockito/src/org/mockito/internal/invocation/SerializableMethod.java?ref=cf08a7032c2124307b28d9da025c52d372ffae62#97) 
2. `+0.11%` via [...ns/PluginLoader.java#60...64](https://codecov.io/github/mockito/mockito/src/org/mockito/internal/configuration/plugins/PluginLoader.java?ref=cf08a7032c2124307b28d9da025c52d372ffae62#60) 
3. `+0.11%` via [...lizationSupport.java#122...126](https://codecov.io/github/mockito/mockito/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java?ref=cf08a7032c2124307b28d9da025c52d372ffae62#122) 
4. _[See 7 more...](https://codecov.io/github/mockito/mockito/features/suggestions?ref=cf08a7032c2124307b28d9da025c52d372ffae62)_

> Powered by [Codecov](https://codecov.io)
 =||= Closed via fa0ebda114afefedea340077b60bc1d8474c7767

Thanks @BartoszMiller 
 =||= ",0
2129,267,bintray upload broken ?,"Yet the binaries seems to be uploaded to bintray and maven (2.0.29-beta is missing on maven). But there's this failure reported during the build.

https://travis-ci.org/mockito/mockito/builds/71779411#L270-L359

```
:bintrayUpload
Error parsing 'text/html' response
groovy.json.JsonException: Unable to determine the current character, it is not a string, number, array, or object
The current character read is '<' with an int value of 60
Unable to determine the current character, it is not a string, number, array, or object
line number 1
index number 0
<html>
^
    at groovy.json.internal.JsonParserCharArray.decodeValueInternal(JsonParserCharArray.java:216)
    at groovy.json.internal.JsonParserCharArray.decodeValue(JsonParserCharArray.java:166)
    at groovy.json.internal.JsonParserCharArray.decodeFromChars(JsonParserCharArray.java:45)
    at groovy.json.internal.JsonParserCharArray.parse(JsonParserCharArray.java:409)
    at groovy.json.internal.BaseJsonParser.parse(BaseJsonParser.java:121)
    at groovy.json.JsonSlurper.parse(JsonSlurper.java:224)
    at groovyx.net.http.ParserRegistry.parseJSON(ParserRegistry.java:280)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1206)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1073)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
    at groovy.lang.Closure.call(Closure.java:423)
    at groovy.lang.Closure.call(Closure.java:439)
    at groovyx.net.http.HTTPBuilder.parseResponse(HTTPBuilder.java:560)
    at groovyx.net.http.HTTPBuilder$1.handleResponse(HTTPBuilder.java:489)
    at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1070)
    at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1044)
    at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:515)
    at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:434)
    at groovyx.net.http.HTTPBuilder.request(HTTPBuilder.java:383)
    at groovyx.net.http.HTTPBuilder$request$0.call(Unknown Source)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
    at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy:358)
    at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
    at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
    at com.jfrog.bintray.gradle.BintrayUploadTask.bintrayUpload(BintrayUploadTask.groovy:392)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:226)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:219)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:208)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:589)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:572)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
    at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
    at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:310)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
    at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
    at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:745)
:bintrayUpload FAILED
FAILURE: Build failed with an exception.
* What went wrong:
Execution failed for task ':bintrayUpload'.
> groovyx.net.http.ResponseParseException: Not Allowed
```","I have seen this. For some reason automatic publish to central fails. Can
be synced manually from bintray api. Javadoc and release notes are not
updated, too. I will look into it.

On Mon, Jul 20, 2015, 17:01 Brice Dutheil notifications@github.com wrote:

> https://travis-ci.org/mockito/mockito/builds/71779411#L270-L359
> 
> Yet the binaries seems to be uploaded to bintray but not maven
> (2.0.29-beta is missing, waiting for 2.0.30-beta to sync)
> 
> :bintrayUpload
> Error parsing 'text/html' response
> groovy.json.JsonException: Unable to determine the current character, it is not a string, number, array, or object
> The current character read is '<' with an int value of 60
> Unable to determine the current character, it is not a string, number, array, or object
> line number 1
> index number 0
> <html>
> ^
>     at groovy.json.internal.JsonParserCharArray.decodeValueInternal(JsonParserCharArray.java:216)
>     at groovy.json.internal.JsonParserCharArray.decodeValue(JsonParserCharArray.java:166)
>     at groovy.json.internal.JsonParserCharArray.decodeFromChars(JsonParserCharArray.java:45)
>     at groovy.json.internal.JsonParserCharArray.parse(JsonParserCharArray.java:409)
>     at groovy.json.internal.BaseJsonParser.parse(BaseJsonParser.java:121)
>     at groovy.json.JsonSlurper.parse(JsonSlurper.java:224)
>     at groovyx.net.http.ParserRegistry.parseJSON(ParserRegistry.java:280)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
>     at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1206)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1073)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
>     at groovy.lang.Closure.call(Closure.java:423)
>     at groovy.lang.Closure.call(Closure.java:439)
>     at groovyx.net.http.HTTPBuilder.parseResponse(HTTPBuilder.java:560)
>     at groovyx.net.http.HTTPBuilder$1.handleResponse(HTTPBuilder.java:489)
>     at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1070)
>     at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:1044)
>     at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:515)
>     at groovyx.net.http.HTTPBuilder.doRequest(HTTPBuilder.java:434)
>     at groovyx.net.http.HTTPBuilder.request(HTTPBuilder.java:383)
>     at groovyx.net.http.HTTPBuilder$request$0.call(Unknown Source)
>     at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
>     at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy:358)
>     at com.jfrog.bintray.gradle.BintrayUploadTask$_bintrayUpload_closure10.doCall(BintrayUploadTask.groovy)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
>     at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
>     at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
>     at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1015)
>     at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
>     at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
>     at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
>     at com.jfrog.bintray.gradle.BintrayUploadTask.bintrayUpload(BintrayUploadTask.groovy:392)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:226)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:219)
>     at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:208)
>     at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:589)
>     at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:572)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
>     at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
>     at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
>     at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
>     at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
>     at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
>     at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
>     at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
>     at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
>     at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:310)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
>     at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
>     at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
>     at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
>     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
>     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
>     at java.lang.Thread.run(Thread.java:745)
> :bintrayUpload FAILED
> FAILURE: Build failed with an exception.
> - What went wrong:
>   Execution failed for task ':bintrayUpload'.
>   > groovyx.net.http.ResponseParseException: Not Allowed
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/267.
 =||= gc old tickets. We will reopen if this happens again.
 =||= ",0
2132,2031,Fixes #2030 : DOCS Added reference to requirements to Java 8 support in Android,"Hi Guys

This is my first contribution here, let me know if this can be improved in some way.  

check list
 - [X] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)
 - [X] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [X] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [X] Avoid other runtime dependencies
 - [X] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [X] The pull request follows coding style
 - [X] Mention `Fixes #<issue number>` in the description _if relevant_
 - [X] At least one commit should mention `Fixes #<issue number>` _if relevant_
","# [Codecov](https://codecov.io/gh/mockito/mockito/pull/2031?src=pr&el=h1) Report
> Merging [#2031](https://codecov.io/gh/mockito/mockito/pull/2031?src=pr&el=desc) into [release/3.x](https://codecov.io/gh/mockito/mockito/commit/a8b156509fc8e35cf122e1abe8c36d1e196ed041?el=desc) will **increase** coverage by `0.02%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/mockito/mockito/pull/2031/graphs/tree.svg?width=650&height=150&src=pr&token=MX80sLdeR0)](https://codecov.io/gh/mockito/mockito/pull/2031?src=pr&el=tree)

```diff
@@                Coverage Diff                @@
##             release/3.x    #2031      +/-   ##
=================================================
+ Coverage          84.88%   84.91%   +0.02%     
  Complexity          2703     2703              
=================================================
  Files                325      325              
  Lines               8198     8198              
  Branches             979      979              
=================================================
+ Hits                6959     6961       +2     
  Misses               968      968              
+ Partials             271      269       -2     
```


| [Impacted Files](https://codecov.io/gh/mockito/mockito/pull/2031?src=pr&el=tree) | Coverage Δ | Complexity Δ | |
|---|---|---|---|
| [src/main/java/org/mockito/Mockito.java](https://codecov.io/gh/mockito/mockito/pull/2031/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9Nb2NraXRvLmphdmE=) | `91.02% <ø> (ø)` | `55.00 <0.00> (ø)` | |
| [...to/internal/util/concurrent/WeakConcurrentMap.java](https://codecov.io/gh/mockito/mockito/pull/2031/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC91dGlsL2NvbmN1cnJlbnQvV2Vha0NvbmN1cnJlbnRNYXAuamF2YQ==) | `41.48% <0.00%> (+2.12%)` | `11.00% <0.00%> (ø%)` | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/mockito/mockito/pull/2031?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/mockito/mockito/pull/2031?src=pr&el=footer). Last update [a8b1565...ec000cf](https://codecov.io/gh/mockito/mockito/pull/2031?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= We kind of resolved this but got stuck on the Objenesis version. I think the best way to address this is the fixation of the Objenesis version for the *mockito-android* bundle as suggested elsewhere. =||= Great @raphw. Do you refer to set objenesis version to 2.6 in the android module? =||= Yes, I think that's the way to go. Setting these requirements gives the wrong impression since it can be so easily avoided.  =||= Ok, well, I think that with something like this it could be fixed:
In dependencies.gradle:
`libraries.objenesisCompatibleAndroid = '2.6'`
In android.gradle:
```
dependencies {
    compile project.rootProject
    compile libraries.bytebuddyandroid
    compile(""org.objenesis:objenesis"") {
        version {
            strictly libraries.objenesisCompatibleAndroid
        }
        because(""MethodHandle class dependency breaks on Android with minSdkVersion<26"")
    }
}
```
Also the output of ./gradlew -q dependencies for the android module show this:

```
compileClasspath - Compile classpath for source set 'main'.
+--- project :
|    +--- net.bytebuddy:byte-buddy:1.10.13
|    +--- net.bytebuddy:byte-buddy-agent:1.10.13
|    \--- org.objenesis:objenesis:3.1 -> 2.6
+--- net.bytebuddy:byte-buddy-android:1.10.13
|    +--- net.bytebuddy:byte-buddy:1.10.13
|    \--- com.jakewharton.android.repackaged:dalvik-dx:9.0.0_r3
\--- org.objenesis:objenesis:{strictly 2.6} -> 2.6

```
If you are ok with this, I can send it on a new PR.
 =||= @earth001 Thanks for your investigation! We have a PR open already (#2024) could you take a look at that? Also ping @raphw for reviewing that one, it is fine by me to be merged. =||= @TimvdLippe Thanks for pointing me that! also that PR looks more complete.  So, I think this PR is not needed.

If you like I can add a small reference to Java 8 requirements for Android in the previous paragraph, something like:

... on Android due to limitations in the Android VM ([See Java 8 support](https://developer.android.com/studio/write/java8-support)).  

If you think is not necessary I can close the PR instead. =||= Hi guys, I see the PR #2024 was already merged. What do you think about this one? 
In my point of view, It would be helpful to add a reference to the limitations of Java Android VM. =||= It is a well-known limitation of the Android VMs, so I don't think it is necessary. The build system should prevent users from building the project and they will see an explanatory message. I would therefore like to wait with adding additional documentation. If there is further confusion, we could add a clarifying message to our main documentation indeed. =||= Nice @TimvdLippe , so I close this one. Please let me know if there something I can help. =||= ",0
2160,2159,Mockito published maven artifact is missing .module files,"Around Gradle 5.3 new Gradle metadata was introduced (see https://docs.gradle.org/current/userguide/publishing_gradle_module_metadata.html) This allows Gradle builds to publish more detail about dependencies than the lagacy maven pom.

Mockito is generating those files, but they aren't getting uploaded to Maven Central see: https://repo1.maven.org/maven2/org/mockito/mockito-junit-jupiter/3.6.28/

However in the [pom.xml](https://repo1.maven.org/maven2/org/mockito/mockito-junit-jupiter/3.6.28/mockito-junit-jupiter-3.6.28.pom) it contains the comment that tells Gradle to check for the `.module` files:

```
<!--
 This module was also published with a richer model, Gradle metadata,  
-->
<!--
 which should be used instead. Do not delete the following line which  
-->
<!--
 is to indicate to Gradle or any Gradle module metadata file consumer  
-->
<!-- that they should prefer consuming it instead. -->
<!-- do_not_remove: published-with-gradle-metadata -->
```

## Solution 1 [Disable metadata](https://docs.gradle.org/current/userguide/publishing_gradle_module_metadata.html#sub:disabling-gmm-publication ): 

This will remove the comment from the pom.xml and so Gradle won't continue to check for the `.module` file.

```
    tasks.withType<GenerateModuleMetadata> {
        enabled = false
    }
```

## Solution 2- Update the maven publishing to include the missing files

This is the better long-term solution. However I don't have a direct recommendation since I don't have experience in that regard and don't know what is mis-configured.


## Why hasn't this been a problem before?

When using `mavenCentral()` as a repo directly, it serves up a 404 for the missing `.module` file and Gradle recovers fine. However when using an internal repository like Artifactory, it is common to configure it to return `403` for missing files to try to obscure data that shouldn't be accessible.

So to reproduce this you would need to use Gradle > 5.3, Using Mockito as a dependency, when using a locked down Maven repository that is configured to serve 403 instead of exposing 404 for missing artifacts.",nan,0
2176,2092,The target server failed to respond CI issue,"Find solution to this problem on CI:

```
Execution failed for task ':android:bintrayUpload'.
133 actionable tasks: 117 executed, 16 up-to-date
> org.apache.http.NoHttpResponseException: The target server failed to respond
```

Build failure: https://github.com/mockito/mockito/pull/2089/checks?check_run_id=1370793325",I think we were able to resolve this issue in the mean time. =||= ,0
2176,2094,Refactor Gradle wrapper validation workflow to CI workflow,"Refactor Gradle wrapper validation workflow to CI workflow. This way, we CI feedback on PRs is cleaner and easier to use.",nan,0
2176,2105,StackOverFlow trying Mock java.lang.Math,"<img width=""741"" alt=""Captura de Tela 2020-11-20 às 19 59 15"" src=""https://user-images.githubusercontent.com/16955808/99857930-20664380-2b6b-11eb-8643-29ce2ad9eeaf.png"">
At this point, seems we get a loop in calls that causes StackOverFlow when trying to static mock java.lang.Math","Please do not mock `java.lang.*` classes, as Mockito us built on top of these. Please use the real method/class. =||= ",0
2176,2092,The target server failed to respond CI issue,"Find solution to this problem on CI:

```
Execution failed for task ':android:bintrayUpload'.
133 actionable tasks: 117 executed, 16 up-to-date
> org.apache.http.NoHttpResponseException: The target server failed to respond
```

Build failure: https://github.com/mockito/mockito/pull/2089/checks?check_run_id=1370793325",I think we were able to resolve this issue in the mean time. =||= ,0
2176,2094,Refactor Gradle wrapper validation workflow to CI workflow,"Refactor Gradle wrapper validation workflow to CI workflow. This way, we CI feedback on PRs is cleaner and easier to use.",nan,0
2176,2105,StackOverFlow trying Mock java.lang.Math,"<img width=""741"" alt=""Captura de Tela 2020-11-20 às 19 59 15"" src=""https://user-images.githubusercontent.com/16955808/99857930-20664380-2b6b-11eb-8643-29ce2ad9eeaf.png"">
At this point, seems we get a loop in calls that causes StackOverFlow when trying to static mock java.lang.Math","Please do not mock `java.lang.*` classes, as Mockito us built on top of these. Please use the real method/class. =||= ",0
2179,2173,Feature request: Unify order of parameters,"Hello,

I just stumbled accross the switched order of the VerificationMode parameter

    org.mockito.Mockito.verify(T, VerificationMode)
vs

    org.mockito.MockedStatic.verify(VerificationMode, Verification)

Is there a reason, the VerificationMode from MockitoStatic is at first position?","No, this might be a simple oversight. @raphw I think we can reverse the order? We would need to add an overload and then deprecate the existing one, which we can delete in Mockito 4.0.0. =||= No, I don't think I had an intention with the order, possibly to have the lambda last what often works better with languages like Kotlin. But I think consistency is the better goal.  =||= @bohni Do you mind sending us a PR with the added method + deprecation? =||= OK, I will take a look =||= ",0
2193,2154,`toString()` seems to be broken on 3.6.28,"Hi guys, I think the `toString()` method was broken recently, I have a test for mockito-scala that checks a mock `toString` invocation returns its name, but if I try to update to said version it returns the standard `Object` implementation of `toString`.

I tried with the ""pure"" Java API of Mockito and the same thing happens

Thanks!

","The release diff (https://github.com/mockito/mockito/compare/v3.6.0...v3.6.28) points to #2098 most likely. Can you do a bisect to figure out if that is indeed the problematic PR? =||= Possibly related and maybe helpful in diagnosing is that attempting to work around this issue by adding an explicit stub for `toString` (e.g. `when(someMock.toString()).thenReturn(""someMock"")`) will cause a `MissingMethodInvocationException`:

```text
org.mockito.exceptions.misusing.MissingMethodInvocationException: 
when() requires an argument which has to be 'a method call on a mock'.
For example:
    when(mock.getArticles()).thenReturn(articles);

Also, this error might show up because:
1. you stub either of: final/private/equals()/hashCode() methods.
   Those methods *cannot* be stubbed/verified.
   Mocking methods declared on non-public parent classes is not supported.
2. inside when() you don't call method on mock but on some other object.
``` =||= Could you try downgrading ByteBuddy to 1.10.15 and see if that resolves the issue? =||= I can confirm. I am facing the same issue when upgrading from 3.2.0 to 3.7.7. =||= Hi there,

I came across this bug and decided to have a look. I cannot reproduce it. Maybe I've got something wrong here. Anyway, I provided a test repository with a test build which we may use to get behind things here.

https://github.com/JanMosigItemis/mockito_issue_2154

Let me know how things go 👋 =||= Hi @JanMosigItemis 

I was able to reproduce the issue with your test repository. Just replace ""mockito-core"" with ""mockito-inline""

```
            <dependency>
                <groupId>org.mockito</groupId>
                <artifactId>mockito-core</artifactId>
                <version>${mockito.version}</version>
                <scope>test</scope>
            </dependency>
```

```
            <dependency>
                <groupId>org.mockito</groupId>
                <artifactId>mockito-inline</artifactId>
                <version>${mockito.version}</version>
                <scope>test</scope>
            </dependency>
```

You should get:
```
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running de.itemis.jmo.mockito.issue2154.MockitoIssue2154JUnit5Test
[ERROR] Tests run: 2, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 1.526 s <<< FAILURE! - in de.itemis.jmo.mockito.issue2154.MockitoIssue2154JUnit5Test
[ERROR] test_stubbed_to_string_works  Time elapsed: 0.054 s  <<< ERROR!
org.mockito.exceptions.misusing.MissingMethodInvocationException: 

when() requires an argument which has to be 'a method call on a mock'.
For example:
    when(mock.getArticles()).thenReturn(articles);

Also, this error might show up because:
1. you stub either of: final/private/equals()/hashCode() methods.
   Those methods *cannot* be stubbed/verified.
   Mocking methods declared on non-public parent classes is not supported.
2. inside when() you don't call method on mock but on some other object.

	at de.itemis.jmo.mockito.issue2154.MockitoIssue2154JUnit5Test.test_stubbed_to_string_works(MockitoIssue2154JUnit5Test.java:26)

[INFO] Running de.itemis.jmo.mockito.issue2154.MockitoIssue2154JUnit4Test
[ERROR] Tests run: 2, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.041 s <<< FAILURE! - in de.itemis.jmo.mockito.issue2154.MockitoIssue2154JUnit4Test
[ERROR] test_stubbed_to_string_works  Time elapsed: 0.018 s  <<< ERROR!
org.mockito.exceptions.misusing.MissingMethodInvocationException: 

when() requires an argument which has to be 'a method call on a mock'.
For example:
    when(mock.getArticles()).thenReturn(articles);

Also, this error might show up because:
1. you stub either of: final/private/equals()/hashCode() methods.
   Those methods *cannot* be stubbed/verified.
   Mocking methods declared on non-public parent classes is not supported.
2. inside when() you don't call method on mock but on some other object.

	at de.itemis.jmo.mockito.issue2154.MockitoIssue2154JUnit4Test.test_stubbed_to_string_works(MockitoIssue2154JUnit4Test.java:26)

[INFO] 
[INFO] Results:
[INFO] 
[ERROR] Errors: 
[ERROR]   MockitoIssue2154JUnit4Test.test_stubbed_to_string_works:26 MissingMethodInvocation
[ERROR]   MockitoIssue2154JUnit5Test.test_stubbed_to_string_works:26 MissingMethodInvocation
[INFO] 
[ERROR] Tests run: 4, Failures: 0, Errors: 2, Skipped: 0
```

Let me know if this info is enough for you or if I should fork your repo. =||= Thx @pitschr I can reproduce now. The problem is also present in the latest mockito-inline release 3.7.7. =||= @TimvdLippe I downgraded to byte buddy 1.10.15 via maven exclusion and got the same result. =||= I had a hunch that in https://github.com/mockito/mockito/pull/2098/files#diff-749d9baac17dc6e18e7db9ee686a840d65ac746dc291b591b37834ba4c8261d1R273 the line `targets.remove(Object.class);` could be the culprit. I removed it on my local machine, build mockito-inline 3.7.9 and used it in my test repo. Works like a charm. Now I've got too few internal mockito knowledge in order to come up with a decent PR on this, bc I don't know exactly why this line has been introduced and if it would be safe to simply remove it. Any thoughts on this? =||= Thanks for the investigation @JanMosigItemis ! In general, if our full test suite passes with that line removed, it should be safe to do so. Please add a regression test to our test suite as well and then feel free to open a PR for it! =||= Ok, I'll try. =||= ",0
2207,2204,Groovy 3.0 internal methods are not ignored as they should be,"Hello,

The following test passes with Groovy 2.4 and 2.5, and fails with Groovy 3.0 (with Mockito 3.7.7 and JUnit 4.13.1 in all cases):

```groovy
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.InjectMocks
import org.mockito.Mock
import org.mockito.junit.MockitoJUnitRunner

import static org.mockito.Mockito.verify

@RunWith(MockitoJUnitRunner)
class GroovyMockitoTest {
    static class Helper {
        void helper() { }
    }

    static class Service {
        private final Helper helper

        Service(Helper helper) {
            this.helper = helper
        }

        void service() {
            helper.helper()
        }
    }

    @Mock Helper helper
    @InjectMocks Service service

    @Test
    void testService() {
        service.service()
        verify(helper).helper()
    }
}
```

The actual error:
```
java.lang.NullPointerException
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:38)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:47)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:130)
	at GroovyMockitoTest$Service.service(GroovyMockitoTest.groovy:24)
	at GroovyMockitoTest$Service$service.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:47)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:130)
	at GroovyMockitoTest.testService(GroovyMockitoTest.groovy:33)
	[... junit ...]
```

I guess this is like #72, where `getMetaClass()` is not ignored and returns `null`.

I think the difference is that in Groovy 3.0, internal methods such as `getMetaClass()` are no longer marked `synthetic`: [GROOVY-8495](https://issues.apache.org/jira/browse/GROOVY-8495). Now they are `@groovy.transform.Generated` and `@groovy.transform.Internal`.

As far as I can tell, Mockito works with Groovy 2.4/2.5 only because ByteBuddy ignores synthetic methods. I see the existing `ignoreAlso(isGroovyMethod())` but as far as I can tell, it has no effect with current versions of Groovy. (I assume it did in the past.)

I think that the fix is to ignore methods annotated with `@groovy.transform.Internal`. I don't know whether that should be done in Mockito or in ByteBuddy. Please let me know if I should report it somewhere else, or if you'd like me to ask the Groovy developers for their input.

Thank you for working on Mockito!",I think the cleanest solution would be to update `isGroovyMethod` to ignore the new annotations. Do you mind sending a PR? =||= ,0
2236,2235,verify() on a wrapped mock fails with UnfinishedVerificationException,"I am currently using the Mock resolver plugin feature (#2042) in my projects, but verify() on a wrapped mock does not work as expected and throws a UnfinishedVerificationException.

A junit5 test case to reproduce this bug is already in the extTest module: [MockResolverTest](https://github.com/mockito/mockito/blob/3fe4a18ba90462e8f6fa5677dfb6d0dc5ab4df17/subprojects/extTest/src/test/java/org/mockitousage/plugins/resolver/MockResolverTest.java,) but it is not executed by default.

https://github.com/mockito/mockito/blob/3fe4a18ba90462e8f6fa5677dfb6d0dc5ab4df17/subprojects/extTest/src/test/java/org/mockitousage/plugins/resolver/MockResolverTest.java#L20-L27

After adding the junitJupiterEngine as test runtime, the MockResolverTest is executed, but fails with following message:
<pre>Missing method call for verify(mock) here:
-> at org.mockitousage.plugins.resolver.MockResolverTest$MockWrapper.doIt(MockResolverTest.java:47)

Example of correct verification:
    verify(mock).doSomething()

Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.
Those methods *cannot* be stubbed/verified.
Mocking methods declared on non-public parent classes is not supported.

org.mockito.exceptions.misusing.UnfinishedVerificationException: 
Missing method call for verify(mock) here:
-> at org.mockitousage.plugins.resolver.MockResolverTest$MockWrapper.doIt(MockResolverTest.java:47)

Example of correct verification:
    verify(mock).doSomething()

Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.
Those methods *cannot* be stubbed/verified.
Mocking methods declared on non-public parent classes is not supported.

	at org.mockito.internal.exceptions.Reporter.unfinishedVerificationException(Reporter.java:115)
	at org.mockito.internal.progress.MockingProgressImpl.validateMostStuff(MockingProgressImpl.java:124)
	at org.mockito.internal.progress.MockingProgressImpl.validateState(MockingProgressImpl.java:105)
	at org.mockito.internal.MockitoCore.validateMockitoUsage(MockitoCore.java:248)
	at org.mockito.Mockito.validateMockitoUsage(Mockito.java:3248)
	at org.mockito.internal.framework.DefaultMockitoSession.finishMocking(DefaultMockitoSession.java:93)
	at org.mockito.junit.jupiter.MockitoExtension.afterEach(MockitoExtension.java:186)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeAfterEachCallbacks$11(TestMethodTestDescriptor.java:253)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeAllAfterMethodsOrCallbacks$12(TestMethodTestDescriptor.java:269)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
...
</pre>

The reason why failing is a missing MockUtil.resolve() before the identity check here:
https://github.com/mockito/mockito/blob/191c0c0051c4f57106c85d3fc1f4151b0e9d2f24/src/main/java/org/mockito/internal/handler/MockHandlerImpl.java#L68

I will provide a PR to fix this issue.
",nan,0
2241,2238,Stacktraces of exceptions are trimmed too much,"Hi,

I'm not sure if this is a bug or an intended behaviour.

When testing a method which throws an exception (checked or unchecked), the causing line is suppressed in the stack coming from Mockito.

Simple example:

```java
package test;

import java.io.IOException;

import org.mockito.Mockito;

public class TestSpy {
    public static void main(String[] args) throws IOException {
        Foo spy = Mockito.spy(new Foo());
        spy.message();
    }

    public static class Foo {
        public void message() throws IOException {
            System.out.println(""Hello 1!""); // line 15
            System.out.println(""Hello 2!"");
            throw new IOException(""fatal""); // line 17
        }
    }
}
```

When calling 'message()' on the spy (same happens on a full mock as well), I would expect to see line 17 in the exception cause.
Instead I see this:
```
Exception in thread ""main"" java.io.IOException: fatal
	at test.TestSpy$Foo.message(TestSpy.java:15)
	at test.TestSpy.main(TestSpy.java:10)
```

Line 15 contains 'System.out.println', which is not causing the exception, but is the first expression inside of the method 'message()'.

I debugged this behaviour and came to `org.mockito.internal.creation.bytebuddy.MockMethodAdvice.hideRecursiveCall(Throwable, int, Class<?>)` 
which seems to be the root cause for this. 
The stack trace given to that method includes the correct line (line 17 in this case). 

My stack trace in this case has 18 entries in total:
```
java.io.IOException: fatal
	at test.TestSpy$Foo.message(TestSpy.java:17)
	at java.base/java.lang.invoke.MethodHandle.invokeWithArguments(MethodHandle.java:710)
	at org.mockito.internal.util.reflection.InstrumentationMemberAccessor$Dispatcher$ByteBuddy$2kmhnFkd.invokeWithArguments(Unknown Source)
	at org.mockito.internal.util.reflection.InstrumentationMemberAccessor.invoke(InstrumentationMemberAccessor.java:230)
	at org.mockito.internal.util.reflection.ModuleMemberAccessor.invoke(ModuleMemberAccessor.java:43)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.tryInvoke(MockMethodAdvice.java:329)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.access$500(MockMethodAdvice.java:56)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice$RealMethodCall.invoke(MockMethodAdvice.java:249)
	at org.mockito.internal.invocation.InterceptedInvocation.callRealMethod(InterceptedInvocation.java:141)
	at org.mockito.internal.stubbing.answers.CallsRealMethods.answer(CallsRealMethods.java:44)
	at org.mockito.Answers.answer(Answers.java:98)
	at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:106)
	at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
	at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:33)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handle(MockMethodAdvice.java:147)
	at test.TestSpy$Foo.message(TestSpy.java:15)
	at test.TestSpy.main(TestSpy.java:10)
```

When the method is finished, 13 entries are left and the most important entry is missing:
```
java.io.IOException: fatal
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.tryInvoke(MockMethodAdvice.java:329)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.access$500(MockMethodAdvice.java:56)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice$RealMethodCall.invoke(MockMethodAdvice.java:249)
	at org.mockito.internal.invocation.InterceptedInvocation.callRealMethod(InterceptedInvocation.java:141)
	at org.mockito.internal.stubbing.answers.CallsRealMethods.answer(CallsRealMethods.java:44)
	at org.mockito.Answers.answer(Answers.java:98)
	at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:106)
	at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
	at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:33)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handle(MockMethodAdvice.java:147)
	at test.TestSpy$Foo.message(TestSpy.java:15)
	at test.TestSpy.main(TestSpy.java:10)
```

Disabling ""cleansStackTrace"" using MockitoConfiguration does not help - hideRecursiveCall is always called.

This bug/feature is very annoying when testing methods which may throw the same type of exception at different locations.
Eg. in my case I know that the exception was thrown in that very method, but I don't know if it happens in e.g. line 20 or 85.

Same thing happens to `RuntimeException`s, which is also annoying... Seeing a NullPointerException without knowing where it happens is not helpful.

Is there any (configuration) option to disable the 'cleaning' of the stack trace completely?
Any chance of getting this fixed?

**Tested Mockito versions:** 3.6.0 and 3.8.0
**OS:** Linux/Ubuntu 20.04 64-Bit
**JDK:** OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.9+11)","Thanks for reporting this issue! We would welcome a patch + regression test for this issue. =||= Thanks for your great work on Mockito and the contribution to open source it continues to make.

I've come across the very same behavior under a similar setup.
I must agree with the OP, this appears to be a bug, and it would be great to see it fixed. =||= ",0
2249,2007,Android instrumentation test packaging fails for mockito-android 3.5.0 with minSdk < 26,"We've upgraded from `mockito-android:3.4.6` to `mockito-android:3.5.0`. I'm attempting to package up my instrumented tests by running the `assembleAndroidTest` gradle task. The task fails with the following errors:
```
/Users/<me>/.gradle/caches/transforms-2/files-2.1/fb7959dc5bfc8ebb26ad0660efa1929e/jetified-mockito-core-3.5.0.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
/Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
/Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
```

and with root cause:
```
com.android.tools.r8.utils.b: Error: /Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar:org/objenesis/instantiator/util/DefineClassHelper$Java8.class, java.lang.Class org.objenesis.instantiator.util.DefineClassHelper$Java8.defineClass(java.lang.String, byte[], int, int, java.lang.Class, java.lang.ClassLoader, java.security.ProtectionDomain), MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.utils.y0.a(:21)
        at com.android.tools.r8.utils.O.a(:51)
        ... 35 more
```
","Should be fixed with #2006 =||= We still have issues with 3.5.2. We are unable to update to new version and use `assembleAndroidTest` task.

```
/usr/local/gradle/caches/transforms-2/files-2.1/225c46d0e9f10ff5ef3f4d9a009c4924/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)

com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)

``` =||= @kozaxinan Are you certain that you are using 3.5.2 and aren't accidentally using an older version of either Mockito or ByteBuddy? We have had confirmations from other users that 3.5.2 fixed the issue you are seeing, so it would be good to double check that you have the correct version. =||= @TimvdLippe I confirm the issue still occurs also in our project with the exact same error.
- mockito-core 3.5.2
- mockito-android 3.5.2
- mockito-inline 3.5.2
- objenesis 3.1
- bytebuddy 1.10.13 =||= Looks like the issue was introduced in objenesis 3.x (upgraded in https://github.com/mockito/mockito/pull/1998)
Forcing objenesis to 2.6 makes `assembleAndroidTest` task succeed. =||= Aha, thanks for letting us know. I will create a revert. =||= Still getting this error with 3.5.7 =||= Here's the stacktrace that I get when using 3.5.7:

```
/Users/azizbekian/.gradle/caches/transforms-2/files-2.1/63e24576c0e1d1e5b675c1c61e4e5727/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
Stack trace:
com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.errors.a.a(:7)
        at com.android.tools.r8.ir.conversion.O.b(:58)
        at com.android.tools.r8.ir.conversion.O.a(:104)
        at com.android.tools.r8.ir.conversion.O.a(:53)
        at com.android.tools.r8.graph.C.b(:43)
        at com.android.tools.r8.ir.conversion.O.b(:35)
        at com.android.tools.r8.utils.U0.a(:10)
        at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:125)
        at com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:69)
        at com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:78)
        at com.google.common.util.concurrent.MoreExecutors$DirectExecutorService.execute(MoreExecutors.java:322)
        at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134)
        at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:66)
        at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:36)
        at com.android.tools.r8.utils.U0.a(:3)
        at com.android.tools.r8.ir.conversion.O.a(:10)
        at com.android.tools.r8.D8.d(:29)
        at com.android.tools.r8.D8.b(:1)
        at com.android.tools.r8.utils.W.a(:30)
        at com.android.tools.r8.D8.run(:11)
        at com.android.builder.dexing.D8DexArchiveBuilder.convert(D8DexArchiveBuilder.java:116)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.process(DexingTransform.kt:296)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.processNonIncrementally(DexingTransform.kt:243)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.doTransform(DexingTransform.kt:153)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.access$doTransform(DexingTransform.kt:69)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform$transform$1.invoke(DexingTransform.kt:104)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform$transform$1.invoke(DexingTransform.kt:69)
        at com.android.build.gradle.internal.tasks.BlocksUtilsKt.recordArtifactTransformSpan(BlocksUtils.kt:33)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.transform(DexingTransform.kt:100)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformer.transform(DefaultTransformer.java:193)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$TransformerExecution.execute(DefaultTransformerInvocationFactory.java:332)
        at org.gradle.internal.execution.steps.ExecuteStep.lambda$execute$0(ExecuteStep.java:32)
        at java.util.Optional.map(Optional.java:215)
        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:32)
        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:26)
        at org.gradle.internal.execution.steps.CleanupOutputsStep.execute(CleanupOutputsStep.java:67)
        at org.gradle.internal.execution.steps.CleanupOutputsStep.execute(CleanupOutputsStep.java:36)
        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:49)
        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:34)
        at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:43)
        at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:73)
        at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:54)
        at org.gradle.internal.execution.steps.CatchExceptionStep.execute(CatchExceptionStep.java:34)
        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:44)
        at org.gradle.internal.execution.steps.SnapshotOutputsStep.execute(SnapshotOutputsStep.java:54)
        at org.gradle.internal.execution.steps.SnapshotOutputsStep.execute(SnapshotOutputsStep.java:38)
        at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:49)
        at org.gradle.internal.execution.steps.CacheStep.executeWithoutCache(CacheStep.java:159)
        at org.gradle.internal.execution.steps.CacheStep.execute(CacheStep.java:72)
        at org.gradle.internal.execution.steps.CacheStep.execute(CacheStep.java:43)
        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:44)
        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:33)
        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:38)
        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:24)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:92)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$0(SkipUpToDateStep.java:85)
        at java.util.Optional.map(Optional.java:215)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:39)
        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:76)
        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:37)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:36)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:26)
        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:94)
        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:49)
        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:79)
        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:53)
        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:74)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.lambda$execute$2(SkipEmptyWorkStep.java:78)
        at java.util.Optional.orElseGet(Optional.java:267)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:78)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:34)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:39)
        at org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:40)
        at org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:28)
        at org.gradle.internal.execution.impl.DefaultWorkExecutor.execute(DefaultWorkExecutor.java:33)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.lambda$call$2(DefaultTransformerInvocationFactory.java:200)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.fireTransformListeners(DefaultTransformerInvocationFactory.java:269)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.access$300(DefaultTransformerInvocationFactory.java:79)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.call(DefaultTransformerInvocationFactory.java:178)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.call(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:409)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:399)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:94)
        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.call(DelegatingBuildOperationExecutor.java:36)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.lambda$doTransform$0(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.api.internal.artifacts.transform.ImmutableTransformationWorkspaceProvider.lambda$withWorkspace$0(ImmutableTransformationWorkspaceProvider.java:81)
        at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.withFileLock(LockOnDemandCrossProcessCacheAccess.java:90)
        at org.gradle.cache.internal.DefaultCacheAccess.withFileLock(DefaultCacheAccess.java:191)
        at org.gradle.cache.internal.DefaultPersistentDirectoryStore.withFileLock(DefaultPersistentDirectoryStore.java:177)
        at org.gradle.cache.internal.DefaultCacheFactory$ReferenceTrackingCache.withFileLock(DefaultCacheFactory.java:201)
        at org.gradle.api.internal.artifacts.transform.ImmutableTransformationWorkspaceProvider.withWorkspace(ImmutableTransformationWorkspaceProvider.java:76)
        at org.gradle.api.internal.artifacts.transform.AbstractCachingTransformationWorkspaceProvider.lambda$withWorkspace$0(AbstractCachingTransformationWorkspaceProvider.java:55)
        at com.google.common.cache.LocalCache$LocalManualCache$1.load(LocalCache.java:4718)
        at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3445)
        at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2194)
        at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2153)
        at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2043)
        at com.google.common.cache.LocalCache.get(LocalCache.java:3851)
        at com.google.common.cache.LocalCache$LocalManualCache.get(LocalCache.java:4713)
        at org.gradle.api.internal.artifacts.transform.AbstractCachingTransformationWorkspaceProvider.withWorkspace(AbstractCachingTransformationWorkspaceProvider.java:55)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.doTransform(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.access$000(DefaultTransformerInvocationFactory.java:79)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$1.invoke(DefaultTransformerInvocationFactory.java:141)
        at org.gradle.api.internal.artifacts.transform.CacheableInvocation$1.invoke(CacheableInvocation.java:58)
        at org.gradle.api.internal.artifacts.transform.TransformationOperation.run(TransformationOperation.java:39)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:395)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:387)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.access$1500(DefaultBuildOperationExecutor.java:49)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$ParentPreservingQueueWorker.execute(DefaultBuildOperationExecutor.java:437)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runOperation(DefaultBuildOperationQueue.java:231)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.access$600(DefaultBuildOperationQueue.java:173)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.create(DefaultBuildOperationQueue.java:210)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.create(DefaultBuildOperationQueue.java:204)
        at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:180)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runBatch(DefaultBuildOperationQueue.java:204)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.run(DefaultBuildOperationQueue.java:178)
        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
        at java.lang.Thread.run(Thread.java:748)
        Suppressed: java.util.concurrent.ExecutionException: com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
                at com.google.common.util.concurrent.AbstractFuture.getDoneValue(AbstractFuture.java:552)
                at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:513)
                at com.google.common.util.concurrent.FluentFuture$TrustedFuture.get(FluentFuture.java:86)
                at com.android.tools.r8.utils.U0.a(:14)
                at com.android.tools.r8.utils.U0.a(:9)
                ... 114 more
        [CIRCULAR REFERENCE:com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)]
Caused by: com.android.tools.r8.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.ir.conversion.N.a(:633)
        at com.android.tools.r8.ir.conversion.N.a(:674)
        at com.android.tools.r8.r.n.A.a(:236)
        at com.android.tools.r8.ir.conversion.o.a(:153)
        at com.android.tools.r8.ir.conversion.N.a(:133)
        at com.android.tools.r8.graph.l.a(:93)
        at com.android.tools.r8.graph.l.a(:71)
        at com.android.tools.r8.graph.l.buildIR(:1)
        at com.android.tools.r8.graph.C0.buildIR(:1)
        at com.android.tools.r8.graph.T.a(:152)
        at com.android.tools.r8.ir.conversion.O.a(:412)
        at com.android.tools.r8.ir.conversion.O.b(:53)
        ... 127 more


``` =||= I updated all mockito packages to 3.5.9 but unfortunately I do get still the same error as above. =||= This still seems to fail for me:
```
Execution failed for task ':mergeDexGplayDebugAndroidTest'.
> Could not resolve all files for configuration ':gplayDebugAndroidTestRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=18, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /home/tobi/.gradle/caches/transforms-2/files-2.1/66df4f0b18795a51947f8881933478f9/jetified-objenesis-3.1.jar.
         > Error while dexing.

```

I removed     
`androidTestImplementation ""org.mockito:mockito-core:$mockitoVersion""`
and changed:
```
testImplementation (""com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0"") {
        exclude group: ""org.mockito"", module: ""mockito-core""
    }
```

If you want to test it: https://github.com/nextcloud/android/pull/6768
 =||= This is still happening in 3.5.10:

- https://pastebin.ubuntu.com/p/rKzc6MVhBf/
- https://github.com/relaycorp/relaynet-gateway-android/pull/120 =||= @gnarea You are depending on Objenesis 3, which is incompatible with Android <26. Please downgrade to Objenesis 2 and depend on `mockito-android`. For more info, see the context in #2024 =||= @TimvdLippe looks like `mockito-core` still has objenesis 3.1 as a dependency. 
```
+--- project :my-project
|    \--- org.mockito:mockito-core:3.5.10
|         +--- net.bytebuddy:byte-buddy:1.10.13
|         +--- net.bytebuddy:byte-buddy-agent:1.10.13
|         \--- org.objenesis:objenesis:3.1

+--- org.mockito:mockito-android:3.5.10
|    +--- org.mockito:mockito-core:3.5.10 (*)
|    +--- net.bytebuddy:byte-buddy-android:1.10.13
|    |    +--- net.bytebuddy:byte-buddy:1.10.13
|    |    \--- com.jakewharton.android.repackaged:dalvik-dx:9.0.0_r3
|    \--- org.objenesis:objenesis:[2.6, 3.0) -> 3.1
``` =||= @francescocervone That is correct. For non-Android projects, they can use Objenesis 3 just fine. =||= @TimvdLippe it's pretty common for Android projects having some pure JVM Gradle modules, not depending on Android. In that case we must depend on `mockito-core` which depends on Objenesis 3. What do you suggest in that case?

Anyway, even if we don't depend directly on `mockito-core`, we get the same error on `mockito-core` (I suppose that's because `mockito-android` depends on `mockito-core`).
```
> Transform artifact mockito-core-3.5.10.jar (org.mockito:mockito-core:3.5.10) with DexingNoClasspathTransform
D8: Private interface methods are only supported starting with Android N (--min-api 24): java.lang.Object org.mockito.plugins.MemberAccessor.lambda$newInstance$0(java.lang.reflect.Constructor, java.lang.Object[])
Stack trace:
com.android.tools.r8.a: Private interface methods are only supported starting with Android N (--min-api 24): java.lang.Object org.mockito.plugins.MemberAccessor.lambda$newInstance$0(java.lang.reflect.Constructor, java.lang.Object[])

[ stacktrace ]

* What went wrong:
Execution failed for task ':app:mergeExtDexDebugAndroidTest'.
> Could not resolve all files for configuration ':app:debugAndroidTestRuntimeClasspath'.
   > Failed to transform mockito-core-3.5.10.jar (org.mockito:mockito-core:3.5.10) to match attributes {artifactType=android-dex, dexing-enable-desugaring=false, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingNoClasspathTransform: /Users/me/.gradle/caches/transforms-2/files-2.1/9ebcc121d44dc6f808610b5ee83414a2/jetified-mockito-core-3.5.10.jar.
         > Error while dexing.
```

Do you need an example project? =||= @francescocervone That last stacktrace is yet another issue that is new to me, as it complains about private interface methods. That seems to be unrelated to Objenesis. The code in question is https://github.com/mockito/mockito/blob/b6ae6cf12b93ef9445e524224375aab1eb76129d/src/main/java/org/mockito/plugins/MemberAccessor.java#L24-L28

I guess older versions of Android do not support default interface methods. I am not sure what to do here, as that seems to be a problem where Android did not support all features of Java 8. Since Mockito 3 targets Java 8, that would be incompatible with older versions of Android.

Can you use Mockito 2 solely for tests running on older versions of Android? =||= > Can you use Mockito 2 solely for tests running on older versions of Android?

No, because this is a compilation error which depends on the minimum supported Android version. Almost every Android project should use Mockito 2 until android 26 will be the ""generally accepted"" minimum sdk supported version (probably in at least 5 years 😄). =||= @francescocervone What I mean is that you have 2 test suites. 1 testsuite for all tests >= 26 and 1 testsuite for all tests <26. For the testsuite >= 26 you can use Mockito 3 + Objenesis 3, as they support Java 8+. For the testsuite <26 you can use Mockito 2 + Objenesis 2, as they support Java 6+. By splitting up the test suites, you can use modern Mockito for modern Android and older Mockito for older Android. That should work right? =||= Also to reiterate, we have introduced Animal Sniffer to ensure we don't break Android again. We set the target to 24 per https://github.com/mockito/mockito/pull/2006/files#diff-c197962302397baf3a4cc36463dce5eaR104 which seemed the most reasonable cut-off for Java 8 support that Mockito 3 relies on. Therefore, rather than having a cut-off at 26, we would be talking about a cut-off at 24. I am not sure when the Android community moves past that cut-off? =||= @TimvdLippe as far as I know you cannot have 2 test suites in the same android project compiling against 2 Android versions. The minimum Android supported version is a property (`minSdkVersion`) defined in the android project's `build.gradle` file through the Android Gradle Plugin.

> I am not sure when the Android community moves past that cut-off? 

Maybe [this chart](https://gs.statcounter.com/android-version-market-share/mobile-tablet/worldwide) can be helpful? In my case, we currently support Android 21 as min SDK. =||= We could try to update Animal Sniffer to level 21 and see what the effect is. If we can make `mockito-core` compatible with that, without introducing breaking changes for the wider Java ecosystem, then I am open to that. However, when @raphw tried that previously, it turned out that a large portion of `mockito-core` was *already* incompatible. This led us to believe that we would have already broken our users and (since we hadn't received complaints before), 24 felt like the best option.

3.5.0 was a big release and a lot of work went into it to support modern Java, which is probably the reason we have hit numerous issues with it. I wonder how many changes in 3.5.0 affect compatibility compared to previous Mockito releases. Could you clone Mockito and try to work out what changes are required to make Mockito compatible with 21? Then we can assess breakages and go from there. =||= Reopening this issue, as I think it is clear by now we are going to need support from developers working in the Android ecosystem on figuring out how to resolve these issues. =||= FYI: at least in my case, the workaround suggested above worked: https://github.com/relaycorp/relaynet-gateway-android/pull/120. But that project doesn't have JVM modules (they're all external deps). We're also supporting API 21+. =||= @TimvdLippe 
>Could you clone Mockito and try to work out what changes are required to make Mockito compatible with 21?

I will. =||= If I remember correctly, types like predicate and function are not available which are part of our public API. This can be fixed but requires breaking public API.  =||= @gnarea , that didn't work for my setup, minSdk = 21:

```
* What went wrong:
Execution failed for task ':app:mergeExtDexDevDebugAndroidTest'.
> Could not resolve all files for configuration ':app:devDebugAndroidTestRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /Users/azizbekian/.gradle/caches/transforms-2/files-2.1/adb8b362b2ccf145263475708478d34b/jetified-objenesis-3.1.jar.
         > Error while dexing.
``` =||= @raphw If I remember correctly, we are already shipping `Optional` and `Function` in our public API prior to 3.5.0. Since Android tests were passing with 3.4.0, I don't think including these symbols in our public API is problematic. Therefore, I don't think we should be changing these types in our API. (This is also what confuses me the most, as to why some parts work and why other parts don't work, even though Animal Sniffer is claiming nothing should in theory work) =||= I'm not an Android expert. `DefineClassHelper` is only used by specific instantiators that are not used in Android. So ideally this class can be excluded from the compilation by Dex it should solve the problem. =||= @TimvdLippe I played a little bit with mockito and the issue I mentioned [in this comment](https://github.com/mockito/mockito/issues/2007#issuecomment-688321579) is solved by adding in the android project's build.gradle:
```gradle
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
```
Android Gradle Plugin 3.0 and higher [supports default interface methods](https://developer.android.com/studio/releases/gradle-plugin#j8-library-desugaring).

---

The objenesis 3.x issue included in `mockito-core` mentioned [here](https://github.com/mockito/mockito/issues/2007#issuecomment-688252464) instead can be avoided by excluding objenesis from `mockito-core` or any library/project depending on `mockito-core`:
```gradle
dependencies {
    androidTestImplementation 'org.mockito:mockito-android:3.5.10'
    androidTestImplementation('org.mockito:mockito-core:3.5.10') {
        exclude group: 'org.objenesis'
    }
    androidTestImplementation(project(':depending-on-mockito-core')) {
        exclude group: 'org.objenesis'
    }
}
```
This workaround is a little bit inconvenient IMHO, but solves the issue. =||= @francescocervone Thanks for the investigation. With regards to your first solution, can we automatically apply that to `mockito-android` or do users of that artifact need to specify it in their `build.gradle`? For the latter, if you solely depend on `mockito-android` you should be good to go. If that is inconvenient, maybe it can be solved in Objenesis 3 instead (not sure if that is possible). =||= @TimvdLippe 
> can we automatically apply that to mockito-android or do users of that artifact need to specify it in their build.gradle?

Users need to specify it in their `build.gradle`.

---

> if you solely depend on mockito-android you should be good to go

True, but I think this ""solution"" is pretty weak. For example, if the project declares [`mockito-kotlin`](https://github.com/nhaarman/mockito-kotlin) dependency, objenesis must be excluded since `mockito-kotlin` depends on `mockito-core`. In general, if the android project depends on some module/project/library depending on `mockito-core`, the workaround must be applied. =||= Again, I'm not sure but can't you just exclude `DefineClassHelper`? That will solve the problem and no need to remove Objenesis. I don't think I can solve it from the Objenesis side. If I can please tell me why? Deploy an objenesis-android excluding these classes will just make everything really messy. =||= @henri-tremblay is there a way to exclude a class from the compilation of a library? How can we exclude `DefineClassHelper`?
Even if we were able to exclude that class: Objenesis is built with Java 8 and it's likely to introduce similar issues in future. This circle will end when one of these classes using some unsupported Java 8 feature, will be part of the Objenesis core and we will not be able to just ""exclude"" it. =||= @TimvdLippe there is a handier workaround for objenesis 3.x, without excluding it from `mockito-core`.
In root `build.gradle` we can add:
```gradle
allprojects {
    configurations.all {
        resolutionStrategy.force 'org.objenesis:objenesis:2.6'
    }
}
``` =||= @francescocervone I don't know. That's why I was saying ""Not an Android expert"" :-) Let me ask around. It's sad to downgrade to Android 2. The other solution would be to split objenesis in 2. One with the core instantiators and one with the exotic ones. Can you hack the objenesis jar to remote this class and just compile with the new jar to tell me if it works? =||= Ok. I had some feedback from @mhausherr. The error is in R8. So we could ignore like this in `proguard-rules.pro`:
```
-assumenosideeffects class org.objenesis.instanciator.util.DefineClassHelper {
    *;
}
``` =||= @henri-tremblay 🤔 It cannot be R8. R8 obfuscates, optimizes and shrinks the code in release builds. It doesn't run in test unless you don't explicitly enable it also for debug builds.
More info here -> https://developer.android.com/studio/build/shrink-code =||= @jakewharton (if I remember correctly, you know a lot more about minification, R8 and problems like this. If that's not the case, please let me know and feel free to ignore this message)

Hey Jake,

Please see the above messages regarding problems with Mockito transitively depending on Objenesis 3 which broke Android compatibility. However, Objenesis compilation broke, despite the class in question not being used in Android tests. As such, the class could be removed with the proguard configuration @henri-tremblay (maintainer of Objenesis) posted.

@francescocervone thinks that is not the appropriate solution, as R8 should not be performing these kind of cleanups.

Sadly I am lacking the knowledge to figure out what is the appropriate solution here and how we can move forward and I had hoped you would be able to help us figuring out.

Thanks in advance for your time and once again, if you prefer not to be involved, feel free to say so and I will try to find another domain expert 😄  =||= @TimvdLippe I didn't say that R8 should not be performing these kind of cleanups. I said that R8 is not involved at all, therefore the R8 rule suggested by @henri-tremblay is not a valid workaround.  =||= @TimvdLippe I created #2053 to fix this issue. With range usage in `strictly` tag, gradle fails to force dependency. I verified with our project. For androidTest, If we just use moctiko-android and exclude mockito-core from mockito-kotlin (or any dependency that has  mockito-core), there shouldnt be any issue. 
This fix still not great but until objenesis supports android sdk < 26, it should work. =||= For anyone who is looking to contribute, please check out the upstream issue at https://github.com/easymock/objenesis/issues/79 =||= I am going to close this issue in favor of https://github.com/easymock/objenesis/issues/79 =||= I have pushed the changes moving some instantiators in a new project. Could you please check if it works? =||= Release 3.2 was done. It should work now. =||= Using version 3.8.0:

```
Execution failed for task ':App:mergeExtDexDebug'.
> Could not resolve all files for configuration ':App:debugRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-transform=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /home/circleci/.gradle/caches/modules-2/files-2.1/org.objenesis/objenesis/3.1/48f12deaae83a8dfc3775d830c9fd60ea59bbbca/objenesis-3.1.jar.
         > Error while dexing.
``` =||= Release 3.2 of _Objenesis_ was done, Mockito still needs to have its dependency updated to 3.2. 

This can be worked around by declaring the Objenesis dependency yourself like `implementation 'org.objenesis:objenesis:3.2` and rely on gradle's dependency resolution to go with the 3.2 version instead of the 3.1 currently included with Mockito =||= @PaulKlauser Do you mind sending us a PR which updates the version? =||= https://github.com/mockito/mockito/pull/2249 =||= Could you consider publishing this to Maven as well? =||= Mockito 3.9.0 should be published to Maven Central: https://github.com/mockito/mockito/runs/2288011033?check_suite_focus=true =||= Thanks! It's still at 3.8.0 on [mvnrepository](https://mvnrepository.com/artifact/org.mockito/mockito-core) and [maven](https://search.maven.org/search?q=a:mockito-core) but I suppose it can take several hours for the change to propagate. =||= Yes these systems take a while to obtain the new information. 3.9.0 is published here: https://repo1.maven.org/maven2/org/mockito/mockito-core/3.9.0/ =||= Just mentioning that I had [this exact crash](https://github.com/mockito/mockito/issues/2007#issuecomment-686925445) and upgrading to 3.9.0 from 3.8.0 fixed it.

 However, it might be worth mentioning that any Android project that is just using `JCenter` as a repository will not return the right information for latest version. Android projects need to begin adding `mavenCentral()` as a repository, which previously was unnecessary because JCenter mirrored Maven Central. That's changing and it's because of this that my particular project didn't recognize the 3.9.0 update.
```
repositories {
    google()
    mavenCentral()  <-- many projects need to add this, explicitly
    jcenter()
    maven { url 'https://jitpack.io' }
}
``` =||= https://blog.gradle.org/jcenter-shutdown =||= ",0
2255,151,Investigate why #125 did not trigger release,Investigate why #125 did not trigger release,"gc old issues
 =||= ",0
2255,150,mockito 1.9.5 or 1.10.17  can not passed junit test when use generic class,"let's has below assumpution test environments :

your can get demo project at:
https://github.com/cloudtrends/jstudy

https://github.com/cloudtrends/jstudy/tree/master/src/com/test
1.  public abstract class ParentClz<T extends ParentClz<T,U>, U> 
2.  public class Child extends ParentClz<Child,String>
3. public class ChildApi 
    just include one method:
   
   public Child addChild(){
       return new Child();
   }
4. test code can not passed:
   ChildApi api = mock(ChildApi.class, RETURNS_DEEP_STUBS );
   Child c = mock(Child.class, withSettings().verboseLogging());
   
   Child cDirect = api.addChild();
   Child cu = cDirect.create();
   when( cu  ).thenReturn(c);
5. errors as :
   java.lang.StackOverflowError
   at sun.reflect.generics.reflectiveObjects.TypeVariableImpl.hashCode(Unknown Source)
   at java.util.HashMap.hash(Unknown Source)
   at java.util.HashMap.getEntry(Unknown Source)
   at java.util.HashMap.get(Unknown Source)
   at org.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:182)

or errors in 1.9.5

java.lang.ClassCastException: com.test.ParentClz$$EnhancerByMockitoWithCGLIB$$c2a01047 cannot be cast to com.test.Child
    at com.test.ChildTest.testCreate(ChildTest.java:56)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)","Hi @cloudtrends,

I'm not how to reproduce your problem from the code snippet (even in the sample project).
Have you tried Mockito 1.10.19, there have been fixes regarding the `StackOverflowError`.

The ClassCastException in 1.9.5 is probably because this version is much less aware of generics, even with deep stubs you need to stub each call returning a parameterized type. Remember that at this time of writing Java has type erasure which means in many cases types are not available at runtime.
 =||= Hi @bric3 

I had switch mockito version from : 1.10.17 to 1.10.19 , the JUnit test result as below:
1. StackOverflowError  is gone 
2. But , ClassCastException still occurred again :
   
   the Child instance call  method  in  ParentClz , in which method return a new instance of child .
   
   java.lang.ClassCastException: com.test.ParentClz$$EnhancerByMockitoWithCGLIB$$eee34e0a cannot be cast to com.test.Child
     at com.test.ChildTest.testCreate(ChildTest.java:56)
     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
     at java.lang.reflect.Method.invoke(Method.java:483)
     at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
     at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
     at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
     at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
     at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
     at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
     at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
     at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
     at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
     at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
     at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
     at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
     at org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.run(JUnit45AndHigherRunnerImpl.java:37)
     at org.mockito.runners.MockitoJUnitRunner.run(MockitoJUnitRunner.java:62)
     at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
     at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)
     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
 =||= Hi,
I don't know exactly your code, the sample project don't don't really show precisely the problem, as you know in Java generics works with erasure, that means they are only known at runtime. If the type is not present in some some way, mockito cannot find the right type. That means that you may have to stub manually this call.
 =||= Closing as no feedback from reporter
 =||= ",0
2255,138,fix proposal for #114,nan,"@bric3, can you take a look at this one? If you don't have time I'll just merge it. All existing tests are passing.

Thanks for the fix!!!
 =||= sorry for the late feedback, it looks good!
anyway you have merged it already in 5a03bf5d0c9aedac9cfbf074833167c1eca6439f ;)
 =||= Fixed in 1.10.18 in 5a03bf5d0c9aedac9cfbf074833167c1eca6439f
 =||= ",0
2255,97,Mockito won't build on a Windows machine,"Executing gradlew pTLM results in the following:

```
(...)
:buildSrc:build UP-TO-DATE
Version: 1.10.45-dev
:compileJava UP-TO-DATE
:processResources UP-TO-DATE
:classes UP-TO-DATE
:allJar FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':allJar'.
> A problem occurred starting process 'command 'ant''

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 24.438 secs
```

The stacktrace ends with this:

```
Caused by: org.gradle.process.internal.ExecException: A problem occurred starting process 'command 'ant''
        at org.gradle.process.internal.DefaultExecHandle.setEndStateInfo(DefaultExecHandle.java:196)
        at org.gradle.process.internal.DefaultExecHandle.failed(DefaultExecHandle.java:325)
        at org.gradle.process.internal.ExecHandleRunner.run(ExecHandleRunner.java:83)
        ... 1 more
Caused by: net.rubygrapefruit.platform.NativeException: Could not start 'ant'
        at net.rubygrapefruit.platform.internal.DefaultProcessLauncher.start(DefaultProcessLauncher.java:27)
        at net.rubygrapefruit.platform.internal.WindowsProcessLauncher.start(WindowsProcessLauncher.java:22)
        at net.rubygrapefruit.platform.internal.WrapperProcessLauncher.start(WrapperProcessLauncher.java:36)
        at org.gradle.process.internal.ExecHandleRunner.run(ExecHandleRunner.java:65)
        ... 1 more
Caused by: java.io.IOException: Cannot run program ""ant"" (in directory ""C:\projects\mockito\src\mockito""): CreateProcess
 error=2, The system cannot find the file specified
        at net.rubygrapefruit.platform.internal.DefaultProcessLauncher.start(DefaultProcessLauncher.java:25)
        ... 4 more
Caused by: java.io.IOException: CreateProcess error=2, The system cannot find the file specified
        ... 5 more
```

Not a big deal, but caused some trouble.","Did you resolve the issue? Does 'ant' work in your windows box? Unfortunately, the build still calls out to ant shell to get the bnd stuff done.
 =||= Yes, I made a dirty quickfix in gradle build. I just call
ant_home/bin/ant.bat on Windows.

Not something to be particularly proud of, but it did the trick.

BR,
JK
8 paź 2014 20:54 ""Szczepan Faber"" notifications@github.com napisał(a):

> Did you resolve the issue? Does 'ant' work in your windows box?
> Unfortunately, the build still calls out to ant shell to get the bnd stuff
> done.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/97#issuecomment-58408133.
 =||= Let's close it for now. We will fix this ant issue at some point.
 =||= See https://github.com/mockito/mockito/pull/102 - ugly but may work until it's completely rewritten.

It looks like `project.exec` won't pick up `ant.bat` when trying to call `ant`.
 =||= Thanks!

On Thu, Oct 9, 2014 at 8:56 PM, jerzykrlk notifications@github.com wrote:

> See #102 https://github.com/mockito/mockito/pull/102 - ugly but may
> work until it's completely rewritten.
> 
> It looks like project.exec won't pick up ant.bat when trying to call ant.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/97#issuecomment-58559558.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= ",0
2255,123,Release Mockito 2.0,"Incompatible changes:
- [x] stop producing mockito-all #153
- [x] stop depending on hamcrest internally #154
- [x] use newer hamcrest #232
- [x] make the anyXxx and any(Xxx) matchers intuitive #134, #194
- ~~fix the site links~~
- [x] push cglib mockmaker to a separate jar #248
- [x] stop using ant for producing OSGi bundles. No more ant in the build #249
- [x] remove jars from source distribution #250
- ~~perhaps introduce is() matcher~~ #246
- ~~richer and smarter stubbing~~ #303
- ~~support java8 features for capturing arguments and matchers~~
- [x] make the JUnitRule and the runner verbose
- [x] ensure release notes can be neatly generated for the RC #582

Possibly compatible (and hence, could be released pre-2.0 if needed)
- [x] drop deprecated code
- [x] unincubate API
- ~~drop serialVersionUID~~","Is it still planned for 2.0 to give users an option to use an alternative to cglib (like Byte Buddy)?
 =||= This kind of feature can be added any time (e.g. it's not a backwards-incompatible change). It's just someone needs to implement it :) 

So short answer is 'no', it's not planned for 2.0 (but I would love to have this feature soon)
 =||= If possible I would really like to replace CGLIB by bytebuddy.

I wanted to craft an external MockMaker but I'm way too much overwhelmed at the moment. The code exists in my clone though.
 =||= @bric3, you mean that you're keen on changing default proxy mechanism in 2.0? I'm fine with this :) I do want to publish 2.0 this year though and I won't be very active it this part of the code. So, if you make it, it can be included :)
 =||= @szczepiq You mean by the end of 2014 ?

What I hoped was to build a mockmaker that could be tested on the 1.x. But the code may replace CGLIB now if necessary. Beta have to be tested by other people though, I especially think about uncommon environment like OSGI, etc...
 =||= 1>You mean by the end of 2014 ?

haha, yeah ;)

> What I hoped was to build a mockmaker that could be tested on the 1.x.

Like an opt-in feature for 1.x?

I definitely think that given we have the bytebuddy impl of MockMaker, we
should make it conveniently pluggable instead of just replacing cglib
completely. You mentioned earlier that you had the ByteBuddy MockMaker
working with Mockito test suite?

Cheers!

On Mon, Nov 24, 2014 at 4:18 PM, Brice Dutheil notifications@github.com
wrote:

> You mean by the end of 2014 ?
> 
> What I hoped was to build a mockmaker that could be tested on the 1.x. But
> the code may replace CGLIB now if necessary. Beta have to be tested by
> other people though, I especially think about uncommon environment like
> OSGI, etc...
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-64208043.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= > > What I hoped was to build a mockmaker that could be tested on the 1.x.
> 
> Like an opt-in feature for 1.x?

Yes. But, meanwhile replacing CGLIB in mockito 2.0.

> You mentioned earlier that you had the ByteBuddy MockMaker working with Mockito test suite?

Yes it does. I just would like to ensure it works with uncommon environment like OSGI.
 =||= Do you think it is worthwhile to keep support for cglib once we have
bytebuddy?

Do you think we should shade bytebuddy? What dependencies bytebuddy brings?

On Mon, Nov 24, 2014 at 6:26 PM, Brice Dutheil notifications@github.com
wrote:

>  What I hoped was to build a mockmaker that could be tested on the 1.x.
> Like an opt-in feature for 1.x?
> 
>  Yes. But, meanwhile replacing CGLIB in mockito 2.0.
> 
> You mentioned earlier that you had the ByteBuddy MockMaker working with
> Mockito test suite?
> 
> Yes it does. I just would like to ensure it works with uncommon
> environment like OSGI.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-64229927.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= No I don't think it is necessary, however we can make a CGLIB mock maker, for people that may depend on it.
 =||= I am curious: Do you guys have a time-line for the 2.0 release? I am more than happy to support any code-generation releated issues. However, my vacation is approaching so I will be gone for a couple of weeks starting mid-August.

In particular, I wonder you guys wanted to try integrating Byte Buddy 0.7 with support for generic type retention already in 2.0 which I hope to complete before my vacation. One word of warning: Generic types are awefully complex. Byte Buddy needs to parse stringified type information and resolve the full type hierarchy, i.e. bind type variables of super types / interfaces to their actual values in order to appropriately resolve a type variable's value while dealing with the possibility of raw types and potentially illegally formatted generic types (the JVM does not verify generic type infromation which simply exists as meta data). There is a chance for corner case errors even though I isolated the functionality pretty much to fall back to type erasure if any illegal type information is disovered. At the same time, mocks would behave better when a generic type is read by a class processing a mock.
 =||= It must happen in 2015. I hope we are ready in the next few months. In
theory, there's not much left work :)

Cheers!

On Fri, Jul 10, 2015 at 5:31 AM, Rafael Winterhalter <
notifications@github.com> wrote:

> I am curious: Do you guys have a time-line for the 2.0 release? I am more
> than happy to support any code-generation releated issues. However, my
> vacation is approaching so I will be gone for a couple of weeks starting
> mid-August.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-120399539.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= I think mockito 2.0 is nearly in shape to be released, most work should go in polishing remaining bits of the public API. IMHO current byte buddy version is fine, and already provide subtitle but needed enhancements.

More specifically on generics I believe current support is OK, after all mockito is a TDD tool for a rapid feedback loop, both on the dev workstation and the ci bots. I believe current generics support in the deepstubs answer is enough. About the issue you mention the support class I wrote is probably incomplete but enough, and I agree parsing this metadata is hard. Anyway at the moment if any extended support should be provided on this front it should be provided via a mockmaker plugin.
 =||= Thanks for the info. I just released Byte Buddy 0.7 but I recommend you to not yet update. Generic types are tricky and I already found a corner case in the bridge method resolution that does not work. I'll try to make it stable until the mid of August, though.
 =||= Any guess on when 2.0 will be released?
 =||= It's been silent for past couple of months, everybody busy, etc. Since
yesterday, I'm focusing my spare time on Mockito. I will not stop until 2.0
is out. We cannot guarantee any dates but 2.0 must be released in 2015.

On Sat, Sep 19, 2015 at 8:40 AM, David J. M. Karlsen <
notifications@github.com> wrote:

> Any guess on when 2.0 will be released?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-141681244.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Any updates on when we might see a 2.0 release?
 =||= 2015 is soon over ;) At some point, we need to do a cut in features. I think everybody is quite budy right now. As always, the time before Christmas are busy month for consultant work.
 =||= Soon. This year for sure. Sorry I was distracted! We will probably deliver
2.0 with what we have, no new fancy features ;)
On Nov 10, 2015 4:52 AM, ""Rafael Winterhalter"" notifications@github.com
wrote:

> 2015 is soon over ;) At some point, we need to do a cut in features. I
> think everybody is quite budy right now. As always, the time before
> Christmas are busy month for consultant work.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-155412454.
 =||= Can this task https://github.com/mockito/mockito/issues/300 be included in 2.0 release?
 =||= Feel free to add #374 to the todo list
 =||= 2.0  is coming so slow.
 =||= It's way too slow. I'm on it. Thank you guys for pushing.
 =||= @szczepiq How can we/the community support the mockito core team ?
 =||= > @szczepiq https://github.com/szczepiq How can we/the community support
> the mockito core team ?
> 
> You already are. You guys are great. Thank you for patience and pushing us
> to deliver.

The lagging of beta is my fault. I've started the beta cycle and I should
have completed it. I'm back in the game, though.

Once 2.x final is out we need clarify how community can drive supporting
and maintaining Mockito.

Note that Mockito is continuously delivered so you can open PR to change
the version to ""2.1.0"", and that's it :)

Cheers!

> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-206757516
 =||= @szczepiq I left a pull request for removing deprecated code which is an 2.0 milestone issue - can you pull it/looks good?
 =||= I haven't reviewed yet. THANKS!
On Sun, Apr 10, 2016 at 03:12 David J. M. Karlsen notifications@github.com
wrote:

> @szczepiq https://github.com/szczepiq I left a pull request for
> removing deprecated code which is an 2.0 milestone issue - can you pull
> it/looks good?
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-207953253
 =||= Per Mockito developers discussion:

We want to target publishing the release on July 31st with a release candidate on June 30th.

There is one issue which must be resolved for that, which is #194. Other than that I just found 1 minor TODO [in the Mockito documentation](https://github.com/mockito/mockito/blob/dff5510cb3e97dae414e58ba85825ad01b273c72/src/main/java/org/mockito/Mockito.java#L1091). The other issues can be fixed in a later minor version.
 =||= @TimvdLippe  what about https://github.com/mockito/mockito/issues/300?
 =||= @skabashnyuk I think that we still want to do this, but is not a blocker for the release. We must do it when we have time, but it is okay in my opinion to release it in a later minor version. I have to be honest that I was not participating in the original discussion so I do not know the exact details. @bric3 is the man to talk to :)
 =||= @TimvdLippe @skabashnyuk Humm I think we should really focus energy on mockito 2, TestNG could come later.
 =||= > TestNG could come later.

@bric3 No problem. But why this can't be done in parallel? Code is ready, looks like this is an infrastructure-deployment issue. Or you are planning to do something bigger than just deploy artifacts?
 =||= @skabashnyuk Currently we are focused on releasing Mockito 2.0. This leaves little to no time for other issues sadly. If you are able to configure the deployment, we are happy to accept your pull request! We can devote some of our time to the TestNG issue after we have released Mockito 2.0.
 =||= Some update.

We're not ready for the release but there's good momentum. Let's plan out
what else needs to be done (announcement information, really documentation
around why to upgrade and how, solid plan what's next after the release
candidate, etc.).

I'm confident the RC will be out in August. I plan to announce everywhere
that we plan RB in August. If we don't meet the date there will high degree
of shame ;) Thoughts?

On Sat, Jun 25, 2016 at 3:59 AM, Tim van der Lippe <notifications@github.com

> wrote:
> 
> @skabashnyuk https://github.com/skabashnyuk Currently we are focused on
> releasing Mockito 2.0. This leaves little to no time for other issues
> sadly. If you are able to configure the deployment, we are happy to accept
> your pull request! We can devote some of our time to the TestNG issue after
> we have released Mockito 2.0.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-228532419,
> or mute the thread
> https://github.com/notifications/unsubscribe/AABgp8m2jG-9Rj7USJ1V2s6GJNHLzbdwks5qPQodgaJpZM4C_fdm
> .

## 

Szczepan Faber
Founder @ mockito.org | Twitter @ szczepiq
Author @ https://www.linkedin.com/today/author/6016386
 =||= I think most of the work should be focused on the upgrade guide, there's not much left for 2.0, follow up tasks can be completed in 2.1
 =||= I think we can publish the release candidate while working on the actual upgrade guide (state this in the github release for users to follow). The only two issues that are non-documentation are #384 with PR #527 of @szczepiq and #489 with PR #491 of myself. #527 has some feedback to be processed and #491 is more of a discussion regarding the runner.

Once these two are resolved, we can merge #483 and the release candidate is published :tada: 

For an up-to-date status, see https://waffle.io/mockito/mockito and https://github.com/mockito/mockito/milestone/1
 =||= This is great stuff!!! Thanks a lot Tim for pushing the release forward & organizing it so well.

I'm making good progress on the warnings stuff for JUnit rule and the listener - will update the PR very soon.
 =||= I'm confused why this ticket is closed. I don't see 2.0 in maven central :)
 =||= @szczepiq because this issue was referenced in #483 which I just merged
 =||= ah, GH smartness :)
 =||= As promised here’s suggested plan to get 2.0 out. Please give feedback, sing up for tasks and commit to ETA so that we get 2.0 out :)

Step 1:
- [ ] prepare RC release notes + announcement (highlights, motivation, request for feedback) - #582
- [ ] review and update documentation for 2.0.0 - #596
- [ ] ensure & test manual Mockito releases - #586
- [ ] update CI / build scripts (releasing betas from branch, etc) - #594

Step 2:
- [ ] branch out / fixes to release / Travis - #594

Step 3:
- [ ] pull the trigger for RC!!!!!, close darn #123 !!!!!!
 =||= ![image](https://cloud.githubusercontent.com/assets/5948271/18092170/97fac1ca-6ecb-11e6-83e0-fd2953833359.png)
 =||= I think we have updated all relevant documentation. @bric3 once you branch out to `release/2.x` we can publish the release candidate :tada: 
 =||= I went ahead and published the release candidate. You can download `2.1.0-RC.1` at https://bintray.com/szczepiq/maven/mockito/2.1.0-RC.1#
 =||= By the way I would prefer to have mockito account on bintray 
 =||= Yes agreed. Let's extract a separate issue for that.
 =||= Mockito 2.1.0 has been released, upgrade today :tada: 
 =||= ",0
2255,122,Problem spying on abstract classes,There's a problem with spying on abstract classes when the real implementation calls out to the abstract method. More details: #121 ,nan,0
2259,218,Regression when mocking a type in a signed package,"I just tried to upgrade from 2.0.8-beta to 2.0.9-beta (and then 2.0.10-beta). One of our tests started failing:

```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface com.microsoft.windowsazure.services.servicebus.ServiceBusContract

Mockito can only mock visible & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.
    at java.lang.ClassLoader.checkCerts(ClassLoader.java:895)
    at java.lang.ClassLoader.preDefineClass(ClassLoader.java:665)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:758)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$ClassLoadingAction.run(ClassInjector.java:336)
    at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$ClassLoadingAction.run(ClassInjector.java:306)
    at java.security.AccessController.doPrivileged(Native Method)
    at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:122)
    at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$5.load(ClassLoadingStrategy.java:144)
    at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:3380)
    at org.mockito.internal.creation.bytebuddy.MockBytecodeGenerator.generateMockClass(MockBytecodeGenerator.java:55)
    at org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator$CachedBytecodeGenerator.generate(CachingMockBytecodeGenerator.java:72)
    at org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator$CachedBytecodeGenerator.getOrGenerateMockClass(CachingMockBytecodeGenerator.java:64)
    at org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator.get(CachingMockBytecodeGenerator.java:27)
    at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createProxyClass(ByteBuddyMockMaker.java:49)
    at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:22)
    at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:33)
    at org.mockito.internal.MockitoCore.mock(MockitoCore.java:59)
    at org.mockito.Mockito.mock(Mockito.java:1378)
    at org.mockito.Mockito.mock(Mockito.java:1256)
```

I thought this was odd, since the mentioned type (`ServiceBusContract`) is a public interface. So I put a breakpoint at `org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator:85`. The underlying error turns out to be:

```
java.lang.SecurityException: class ""com.microsoft.windowsazure.services.servicebus.models.BrokeredMessage$MockitoMock$931493758$auxiliary$gVJxoE2i""'s signer information does not match signer information of other classes in the same package
```

If I understand correctly, Mockito just switched from GCLIB to Byte Buddy. Perhaps this is an edge case that the new library doesn't cover yet?","That is possible or more probable we missed something. Thank you for testing this builds so early ;)

I'd like some integration tests for ""uncommon"" stuff like signed package, OSGI stuff etc.
 =||= This was indeed something I missed, I pushed a possible fix. CI should generate a new beta. That should be propagated first on bintray then maven (sync takes 1 days or so).
 =||= Awesome, thanks!
 =||= Should be in 2.0.11-beta, let me know if that works for your environment
 =||= Just upgraded to 2.0.11-beta. Verified fixed. Thanks again :)
 =||= Cool thanks again for the feedback. Fixed by cb645cfd157eaaed61436dda012d95f2fd7ec7fe.
 =||= By the way, since you're an early beta user, I'd like to warn you that at some point along the 2.0.x beta development there will be breaking changes in the matcher API in 2.0. We'll see how to mitigate impact along the way too.
 =||= ",0
2263,2242,InOrder.verify with non-mock should perhaps give standard non-mock warning,"Minor, but I noticed today when I accidentally passed in a non-mock to an `InOrder.verify` call that it warned me that it can only verify mocks that were passed in during creation of `InOrder`.  While correct, it seems like perhaps using the standard ""non-mock"" warning would be more helpful as it has better hinting for this situation.  In particular, this seems like it would be useful to newer users of the API who might have a hard time figuring out what they did wrong.

## Mockito.verify

```java
List<?> mock = Mockito.mock(List.class);
Mockito.verify(Mockito.mock.get(5));
```

### Output

```text
Argument passed to verify() should be a mock but is null!
Examples of correct verifications:
    verify(mock).someMethod();
    verify(mock, times(10)).someMethod();
    verify(mock, atLeastOnce()).someMethod();
    not: verify(mock.someMethod());
Also, if you use @Mock annotation don't miss initMocks()
```

## inOrder.verify

```java
List<?> mock = Mockito.mock(List.class);
InOrder inOrder = Mockito.inOrder(mock);
inOrder.verify(mock.get(5));
```

### Output

```text
InOrder can only verify mocks that were passed in during creation of InOrder.
For example:
    InOrder inOrder = inOrder(mockOne);
    inOrder.verify(mockOne).doStuff();
```

## Desired behavior

Note that the current `InOrder` message does not give the hint of how to fix the non-mock that was passed in.  Using the standard non-mock warning in this case seems like a more helpful response.  Alternatively, that the hinting could be included in the `InOrder` output when a non-mock is used.",PRs welcome 😄  =||= ,0
2267,2266,Swallowed illegal access exceptions make it harder to debug modularity-related issues,"### Issue Summary

In FieldReader and ReflectionMemberAccessor, if an IllegalAccessException is thrown, it will be suppressed.

At the very least, Mockito should include the original exception. When testing a modular application, it is common to have packages encapsulated by default.

### Stacktrace

In FieldReader, the IllegalAccessException is caught. The exception is re-thrown but the cause is lost.

https://github.com/mockito/mockito/blob/ea000f72444ed4c7e409441aedc3021951b89660/src/main/java/org/mockito/internal/util/reflection/FieldReader.java#L28-L35

Using a debugger, the IllegalAccessException can be observed: https://pastebin.com/GsnU29QV

### Problematic Code

1. Use `module-info` in the project and don't open the package under test to mockito.

2. Use the `MockitoExtension` for JUnit:

```java
@ExtendWith(MockitoExtension.class)
public class MyClassTest {

  private final MyType mock;

  public MyClassTest(@Mock MyType mock) {
    this.mock = mock;
  }
}
```

### Environment
Mockito-Junit-Jupiter 3.9.0
Zulu16.28+11-CA (build 16+36)",nan,0
2274,2273,Example in javadoc of ArgumentMatcher has missing parenthesis,"check that

 - [x] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)



The javadoc for ArgumentMatcher contains some example code which misses a pair of parenthesis in one case at https://github.com/mockito/mockito/blob/c86fe047d557bd2ec364d59a99430792f3920e96/src/main/java/org/mockito/ArgumentMatcher.java#L64",nan,0
2276,941,Improve clarity of release notes,"Let's make Mockito release notes more useful to the community! [Current release notes](https://github.com/mockito/mockito/blob/release/2.x/doc/release-notes/official.md) are automatically generated by [Mockito Continuous Delivery Pipeline](https://github.com/mockito/mockito/wiki/Continuous-Delivery-Overview).

Main use cases for release notes:
 - to make a decision whether it is worth upgrading. This use case is not handled well currently because our [release notes](https://github.com/mockito/mockito/blob/release/2.x/doc/release-notes/official.md) contain too many details (feedback from community: https://github.com/mockito/mockito/issues/618#issuecomment-270038734).
 - to troubleshoot a bug or changed behavior that occurred after upgrading. No direct feedback about it, let's assume that the current release notes satisfy this use case.

Opened a ticket for work on this in https://github.com/mockito/mockito-release-tools/issues/9

Questionable use cases for release notes:
 - to identify if some bug is already fixed. I doubt users will go over release notes to find out if the behavior they see is a bug and if it was fixed in one of the newer versions. Most likely, the user would hit Google, StackOverflow, mailing list and/or create an issue in the tracker.",https://github.com/mockito/mockito/blob/release/2.x/doc/release-notes/official.md looks a lot better now. This was probably fixed during work on https://github.com/mockito/shipkit/issues/9 =||= ,0
2276,1564,No such method error - Mockito,"Hi All,

can anyone help me on the below error of **NoSuchMethodError: Mockito.framework( )?**

```
java.lang.NoSuchMethodError: org.mockito.Mockito.framework()Lorg/mockito/MockitoFramework;
       at org.powermock.api.mockito.mockmaker.MockMakerLoader.doLoad(MockMakerLoader.java:45)
       at org.powermock.api.mockito.mockmaker.MockMakerLoader.load(MockMakerLoader.java:36)
       at org.powermock.api.mockito.mockmaker.PowerMockMaker.<init>(PowerMockMaker.java:36)
       at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
       at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
       at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
       at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:488)
       at java.base/java.lang.Class.newInstance(Class.java:560)

 ```","What versions of PowerMock and Mockito are you using? =||= I have tried using both ```2.0.0-beta.5``` and ```1.7.4 ```  but it didn't work for me. =||= 2.0.0-beta is very old. The latest version is 2.23.4.

On Mon, 17 Dec 2018, 06:34 bharukaRupesh, <notifications@github.com> wrote:

> I have tried using both 2.0.0-beta.5 and 1.7.4 but it didn't work for me.
>
> —
> You are receiving this because you commented.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1564#issuecomment-447727510>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb_5yWu3LjPTFAhoccdQRxJOlKj-Mks5u5yzTgaJpZM4ZNBg7>
> .
>
 =||= Thanks @TimvdLippe ```2.23.4``` version of ```mockito-core``` has worked for me. =||= ",0
2276,974,MockitoJUnitRunner.StrictStubs does not detect 'Unnecessary Stubbing' when inline mock maker is enabled,"- mockito-core 2.7.13
- OpenJDK 1.8.0_121
- Ubuntu 16.10
- Enable `mock-maker-inline` (or use `mockito-inline` artifact)

If running the following test, 'Unnecessary Stubbing' is not detected.

```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    ArrayList<String> mock;

    @Test
    public void should_pass() {
        when(mock.get(0)).thenReturn(""foo"");
        assertEquals(""foo"", mock.get(0));
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.get(1)).thenReturn(""foo"");
    }

}
```

In the above code, 'Unnecessary Stubbing' is detected by changing ArrayList to List.
```java

    @Mock
//    ArrayList<String> mock;
    List<String> mock;

```

This problem does not occur with default mock maker.","This is working as intended. You should not mock Data classes such as `List`. The new mock maker is stricter in this regard as we could not ship another breaking change for the original mock maker.

We could add an explicit exception when we encounter these classes, instead of silently continueing. WDYT @raphw ? =||= I am sorry that my test case was bad.

The following test **passes** using inline mock maker.
This test does not use data classes.
```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    C mock;

    @Test
    public void should_pass() {
        when(mock.doIt()).thenReturn(""foo"");
        assertEquals(""foo"", mock.doIt());
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.doIt()).thenReturn(""foo"");
    }

    public static class C {
        public String doIt() {
            throw new UnsupportedOperationException();
        }
    }

}
```

Using default mock maker, this test **fails**.
This is the result that I expect.
```
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected in test class: MockitoTest
Clean & maintainable test code requires zero unnecessary code.
Following stubbings are unnecessary (click to navigate to relevant line of code):
  1. -> at com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)
Please remove unnecessary stubbings or use 'silent' option. More info: javadoc for UnnecessaryStubbingException class.

	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:49)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:161)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
```

Does **new mock maker** mean **inline mock maker**?
According to the results of this test, inline mock maker seems to be less strict than default mock maker.
Sorry if I have misunderstood.
 =||= Ah that is a better testcase. Definitely a bug! =||= Just tested this on master and the result is the same for both mock makers where neither test detects the unneccessary stubbung. I do not know this part of Mockito too well but I assume there is a bug in this component. =||= I wrote a new test for this issue.

```java
public class StrictStubsRunnerByMockingAbstractClassTest {

    private final JUnitCore jUnitCore = new JUnitCore();

    @Test
    public void test_for_abstract_method_should_detect_unnecessary_stubbings() {
        runTest(ForAbstractMethod.class);
    }

    @Test
    public void test_for_concrete_method_should_detect_unnecessary_stubbings() {
        runTest(ForConcreteMethod.class);
    }

    private void runTest(Class<?> testClass) {
        Result result = jUnitCore.run(testClass);
        List<Failure> failures = result.getFailures();
        assertThat(failures.size(), equalTo(1));
        Failure failure = failures.get(0);
        assertThat(failure.getException(), instanceOf(UnnecessaryStubbingException.class));
    }

    static abstract class TestTarget {

        abstract String abstractMethod();

        String concreteMethod() {
            throw new UnsupportedOperationException();
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForAbstractMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
            mock.abstractMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForConcreteMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
            mock.concreteMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
        }

    }

}
```

To test this test on the master, I put this into the following directory.
1. src/test/java/org/mockitousage/junitrunner (using the default mock maker)
1. inline/src/test/java/org/mockitoinline (using the inline mock maker)

In the first case, this test passed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :test --tests ""org.mockitousage.junitrunner.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:createTestResources
:compileTestJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:removeTestResources
:processTestResources UP-TO-DATE
:testClasses
:test

BUILD SUCCESSFUL

Total time: 5.707 secs
```

However, in the second case it failed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :inline:test --tests ""org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:jar
:inline:compileJava UP-TO-DATE
:inline:processResources
:inline:classes
:inline:compileTestJava
:inline:processTestResources UP-TO-DATE
:inline:testClasses
:inline:test

org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest > test_for_concrete_method_should_detect_unnecessary_stubbings FAILED
    java.lang.AssertionError: 
    Expected: <1>
         but: was <0>
        at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
        at org.junit.Assert.assertThat(Assert.java:956)
        at org.junit.Assert.assertThat(Assert.java:923)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.runTest(StrictStubsRunnerByMockingAbstractClassTest.java:36)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.test_for_concrete_method_should_detect_unnecessary_stubbings(StrictStubsRunnerByMockingAbstractClassTest.java:30)

2 tests completed, 1 failed
:inline:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':inline:test'.
> There were failing tests. See the report at: file:///home/tmura/IdeaProjects/mockito/subprojects/inline/build/reports/tests/index.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 3.505 secs

```

For the abstract method, 'Unnecessary Stubbing' was detected correctly, but it did not detected for the concrete method.
 =||= I thnk I have found the cause of this problem.
When using the inline mock maker, it seems that LocationImpl cannot get the stubbed location of the concrete method correctly.

`UnusedStubbingFinder` which detects 'Unnecessary stubbing' calls `LocationImpl#toString()` to get the stabbed location.

The code below is the implementation of `LocationImpl#toString()`.
```java
StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);
if (filtered.length == 0) {
    return ""-> at <<unknown line>>"";
}
return ""-> at "" + filtered[0].toString();
```

This method filters the stack trace elements of `stackTraceHolder` to get the location.
`stackTraceHolder` is a Throwable object that is created in the constructor of `LocationImpl`.

The stack trace elements of this object are as follows:

- Stubbing the concrete method with the default mock maker
```
0 = {StackTraceElement@1679} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1680} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1681} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1682} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1683} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptSuperCallable(MockMethodInterceptor.java:102)""
5 = {StackTraceElement@1684} ""com.example.MockitoTest$C$MockitoMock$648066763.doIt(Unknown Source)""
6 = {StackTraceElement@1685} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the abstract method with the inline mock maker
```
0 = {StackTraceElement@2201} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@2202} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@2203} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@2204} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@2205} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:120)""
5 = {StackTraceElement@2206} ""com.example.MockitoTest$C$MockitoMock$1683798279.doIt(Unknown Source)""
6 = {StackTraceElement@2207} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the concrete method with the inline mock maker
```
0 = {StackTraceElement@1927} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1928} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1929} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1930} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1931} ""org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handle(MockMethodAdvice.java:76)""
5 = {StackTraceElement@1932} ""com.example.MockitoTest$C.doIt(MockitoTest.java:30)""
6 = {StackTraceElement@1933} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

The resulting location should be `#6`, but in the last case it is `#5`.
Because `stackTraceFilter` does not exclude `#5`.
 =||= Yes, this is expected. The inline mock maker inlines the code and does therefore not add a stack frame. This is a bug in the `UnusedStubbingFinder` which should not rely on the stack shape.

@TimvdLippe Do you have time to look at this? =||= Thank you guys for really thorough debugging!

>This is a bug in the UnusedStubbingFinder which should not rely on the stack shape.

There is a reason why the finder relies on the String representation of line where the unused stub is declared. I documented it in the [Javadoc](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java#L46), hopefully it is more less clear :) I'm not saying we should keep the current implementation, I'm ok changing it, I just wanted to give more data points.

After reading this thread my gut feel tells me that the stack trace filter (different component than unused stubbing detection) may not be coping well with inline mocking. This could also have impact on stack trace filtering in general for inline mocking, the quality of exception messages, etc.

@tmurakami, you made fantastic debugging effort to nail down the problem. Can you investigate if stack trace filter needs adapting for inline mocking and potentially submit a PR? =||= With the stack trace filter, I actually did change the implementation to adjust this behavior such that it works. I was not aware that the stubbing finder replicated something similar. =||= @szczepiq, @raphw, I can submit the PR, but this problem seems to have already been fixed by @raphw.
Should I submit the PR?
 =||= Please submit, I only fixed the issue partially. =||= ",0
2276,1587,InjectingAnnotationEngine does an unnecessary loop.,"processInjectMocks method of InjectingAnnotationEngine does unnecessary work. It might call injectMocks several times while it is sufficient to call injectMocks once.

    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {
        Class<?> classContext = clazz;
        while (classContext != Object.class) {
            injectMocks(testInstance);
            classContext = classContext.getSuperclass();
        }
    }

Inside, injectMocks loops classes by himself.

    public void injectMocks(final Object testClassInstance) {
        Class<?> clazz = testClassInstance.getClass();
        Set<Field> mockDependentFields = new HashSet<Field>();
        Set<Object> mocks = newMockSafeHashSet();

        while (clazz != Object.class) {
            new InjectMocksScanner(clazz).addTo(mockDependentFields);
            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);
            onInjection(testClassInstance, clazz, mockDependentFields, mocks);
            clazz = clazz.getSuperclass();
        }

        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);
    }

Why not delete the unnecessary loop?",nan,0
2276,2262,Illegal reflective access operation,"```
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.mockito.internal.util.reflection.ReflectionMemberAccessor to constructor java.lang.Void()
WARNING: Please consider reporting this to the maintainers of org.mockito.internal.util.reflection.ReflectionMemberAccessor
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
```
I don't know exactly what call causes it. This is with Mockito 3.8.0, Mockito-Kotlin 2.2.0, and
```
﻿openjdk version ""11.0.10"" 2021-01-19
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.10+9)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.10+9, mixed mode)
```


",Duplicate of #1325 =||= ,0
2276,941,Improve clarity of release notes,"Let's make Mockito release notes more useful to the community! [Current release notes](https://github.com/mockito/mockito/blob/release/2.x/doc/release-notes/official.md) are automatically generated by [Mockito Continuous Delivery Pipeline](https://github.com/mockito/mockito/wiki/Continuous-Delivery-Overview).

Main use cases for release notes:
 - to make a decision whether it is worth upgrading. This use case is not handled well currently because our [release notes](https://github.com/mockito/mockito/blob/release/2.x/doc/release-notes/official.md) contain too many details (feedback from community: https://github.com/mockito/mockito/issues/618#issuecomment-270038734).
 - to troubleshoot a bug or changed behavior that occurred after upgrading. No direct feedback about it, let's assume that the current release notes satisfy this use case.

Opened a ticket for work on this in https://github.com/mockito/mockito-release-tools/issues/9

Questionable use cases for release notes:
 - to identify if some bug is already fixed. I doubt users will go over release notes to find out if the behavior they see is a bug and if it was fixed in one of the newer versions. Most likely, the user would hit Google, StackOverflow, mailing list and/or create an issue in the tracker.",https://github.com/mockito/mockito/blob/release/2.x/doc/release-notes/official.md looks a lot better now. This was probably fixed during work on https://github.com/mockito/shipkit/issues/9 =||= ,0
2298,2257,Reinstate CodeCov reporting,"With the migration to GitHub actions, it seems that we have lost the CodeCov reporting on GitHub pull requests. I am assumign that's happening because we are no longer reporting to CodeCov after a successful GitHub action completion.","I just discovered that we do run the coverage reporting as expected, but it is not reporting back on the PR status. =||= Seems like they are back in action. =||= ",0
2298,2260,Fix deprecation label of verifyZeroInteractions,"Documentation change only. I'm pretty sure this is the correct method to move to.

<!-- Hey, 
Thanks for the contribution, this is awesome.
As you may have read, project members have somehow an opinionated view on what and how should be
Mockito, e.g. we don't want mockito to be a feature bloat.
There may be a thorough review, with feedback -> code change loop.
-->
<!--
Which branch : 
- On mockito 3.x, make your pull request target `release/3.x`
- On mockito 2.x, make your pull request target `release/2.x` (2.x is in maintenance mode)
-->
<!--
If you have a suggestion for this template you can fix it in the .github/PULL_REQUEST_TEMPLATE.md file
-->
## Checklist

 - [ ] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)
 - [ ] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [ ] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [ ] Avoid other runtime dependencies
 - [ ] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [ ] The pull request follows coding style
 - [ ] Mention `Fixes #<issue number>` in the description _if relevant_
 - [ ] At least one commit should mention `Fixes #<issue number>` _if relevant_
","Duplicate of #2240 =||= Thanks that makes sense; I might open a PR to put that context in the description, since right now it is confusing and looks very much like a typo. =||= ",0
2298,2282,Mockito fails to work in Java 11 with JPMS modules,"I am migrating Log4j 2 to fully support JPMS. In doing that the unit tests that use Mockito are all failing with

    java.lang.IllegalStateException: Could not initialize plugin: interface org.mockito.plugins.MockMaker (alternate: null)
    Caused by: java.lang.IllegalStateException: Internal problem occurred, please report it. Mockito is unable to load the default implementation of class that is a part of Mockito distribution. Failed to load interface org.mockito.plugins.MockMaker
    Caused by: java.lang.reflect.InvocationTargetException
    Caused by: java.lang.NoClassDefFoundError: net/bytebuddy/dynamic/loading/ClassInjector$UsingReflection
    Caused by: java.lang.ClassNotFoundException: net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection

If is set system property ""org.mockito.internal.noUnsafeInjection"" to true then it fails the same way trying to access $UsingLookup. 

Note that this worked fine with the same versions of Mockito and byte-buddy when a module-info.java wasn't present.

Do I need to add an --add-opens for something?","Are you using mockito-inline? Otherwise you'd need to open your module to Mockito.  =||= No, Log4j does not use mockito-inline. I'm not really sure what that is to be honest. I didn't write any of the stuff that uses Mockito in Log4j. 
I don't understand how opening the module to Mockito will help resolve a class not found exception in byte buddy? Wouuln't Mockito have to open something? =||= Mockito cannot open anything. Modules are fully encapsulated. Try replacing mockito-core with mockito-inline in your dependencies and make sure to use the latest version. Alternatively, do you have a reproducing branch?  =||= I have checked the code into the jpms-mockito-fails branch of https://github.com/apache/logging-log4j2.  Clone the repo, checkout that branch and then run mvn clean install. You will need Java 11  and I believe you will need at least Maven 3.6.1. =||= https://github.com/apache/logging-log4j2/compare/jpms-mockito-fails has the full diff. Since this diff is quite large, would it be possible to separate the directory rename? That would hopefully make it a bit easier for us to digest what the diff is and what the potential culprit could be. Thanks! =||= No, it wouldn't be possible. Prior to this change Log4j-core was an automatic module and the tests were not modules at all. To convert to a JPMS module the tests also had to be converted to comply with JPMS. The tests were being passed downstream for other modules to use in tests but they shared the same package name as the main module. So the tests being passed on had to be split. Plus some of the test classes were using the log4j-api package namespace. 

The diff is that Log4j-core used to have an automatic module name, which meant while it had a name it really wasn't a JPMS module. It didn't have all the restrictions placed on it that named modules do so everything was open. Because of the change, all the tests now run on the module path instead of the class path, which means everything has to conform to JPMS.   =||= The reason is pretty obvious: Byte Buddy is missing from the class path. I do not know how the module path is assembled, but I assume that the tool you are using does not know how to process an automatic module such as Mockito that requires a dependency. I set a breakpoint in the test and class in question and the *net.bytebuddy* module is not on the module path while the class path is empty.

We'll see how to improve the error message in such a case, I assume the tooling around the module system is still lacking a few details so this might just pay off.

If I for example add the line:

    requires transitive net.bytebuddy;

to *logging-log4j2/log4j-core/src/test/java9/module-info.java*, the problem seems to be solved for the `ConsoleAppenderTest` that yielded the error message that you described. =||= Thanks. That is interesting since the class shows up with mvn dependency:tree and clearly is there since just adding the requires for it fixes the problem. I'm not sure why that didn't occur to me. I'd guess it is the surefire plugin setting up the class path and module path, or something it delegates to. It sure would have been nice to have had some kind of warning message that dependencies were being ignored. Anyway, I will close this issue. =||= ",0
2298,2324,Release/3.x,"<!-- Hey,
Thanks for the contribution, this is awesome.
As you may have read, project members have somehow an opinionated view on what and how should be
Mockito, e.g. we don't want mockito to be a feature bloat.
There may be a thorough review, with feedback -> code change loop.
-->
<!--
If you have a suggestion for this template you can fix it in the .github/PULL_REQUEST_TEMPLATE.md file
-->
## Checklist

 - [ ] Read the [contributing guide](https://github.com/mockito/mockito/blob/main/.github/CONTRIBUTING.md)
 - [ ] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [ ] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [ ] Avoid other runtime dependencies
 - [ ] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [ ] The pull request follows coding style
 - [ ] Mention `Fixes #<issue number>` in the description _if relevant_
 - [ ] At least one commit should mention `Fixes #<issue number>` _if relevant_
",nan,0
2298,2257,Reinstate CodeCov reporting,"With the migration to GitHub actions, it seems that we have lost the CodeCov reporting on GitHub pull requests. I am assumign that's happening because we are no longer reporting to CodeCov after a successful GitHub action completion.","I just discovered that we do run the coverage reporting as expected, but it is not reporting back on the PR status. =||= Seems like they are back in action. =||= ",0
2298,2260,Fix deprecation label of verifyZeroInteractions,"Documentation change only. I'm pretty sure this is the correct method to move to.

<!-- Hey, 
Thanks for the contribution, this is awesome.
As you may have read, project members have somehow an opinionated view on what and how should be
Mockito, e.g. we don't want mockito to be a feature bloat.
There may be a thorough review, with feedback -> code change loop.
-->
<!--
Which branch : 
- On mockito 3.x, make your pull request target `release/3.x`
- On mockito 2.x, make your pull request target `release/2.x` (2.x is in maintenance mode)
-->
<!--
If you have a suggestion for this template you can fix it in the .github/PULL_REQUEST_TEMPLATE.md file
-->
## Checklist

 - [ ] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)
 - [ ] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [ ] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [ ] Avoid other runtime dependencies
 - [ ] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [ ] The pull request follows coding style
 - [ ] Mention `Fixes #<issue number>` in the description _if relevant_
 - [ ] At least one commit should mention `Fixes #<issue number>` _if relevant_
","Duplicate of #2240 =||= Thanks that makes sense; I might open a PR to put that context in the description, since right now it is confusing and looks very much like a typo. =||= ",0
2298,2282,Mockito fails to work in Java 11 with JPMS modules,"I am migrating Log4j 2 to fully support JPMS. In doing that the unit tests that use Mockito are all failing with

    java.lang.IllegalStateException: Could not initialize plugin: interface org.mockito.plugins.MockMaker (alternate: null)
    Caused by: java.lang.IllegalStateException: Internal problem occurred, please report it. Mockito is unable to load the default implementation of class that is a part of Mockito distribution. Failed to load interface org.mockito.plugins.MockMaker
    Caused by: java.lang.reflect.InvocationTargetException
    Caused by: java.lang.NoClassDefFoundError: net/bytebuddy/dynamic/loading/ClassInjector$UsingReflection
    Caused by: java.lang.ClassNotFoundException: net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection

If is set system property ""org.mockito.internal.noUnsafeInjection"" to true then it fails the same way trying to access $UsingLookup. 

Note that this worked fine with the same versions of Mockito and byte-buddy when a module-info.java wasn't present.

Do I need to add an --add-opens for something?","Are you using mockito-inline? Otherwise you'd need to open your module to Mockito.  =||= No, Log4j does not use mockito-inline. I'm not really sure what that is to be honest. I didn't write any of the stuff that uses Mockito in Log4j. 
I don't understand how opening the module to Mockito will help resolve a class not found exception in byte buddy? Wouuln't Mockito have to open something? =||= Mockito cannot open anything. Modules are fully encapsulated. Try replacing mockito-core with mockito-inline in your dependencies and make sure to use the latest version. Alternatively, do you have a reproducing branch?  =||= I have checked the code into the jpms-mockito-fails branch of https://github.com/apache/logging-log4j2.  Clone the repo, checkout that branch and then run mvn clean install. You will need Java 11  and I believe you will need at least Maven 3.6.1. =||= https://github.com/apache/logging-log4j2/compare/jpms-mockito-fails has the full diff. Since this diff is quite large, would it be possible to separate the directory rename? That would hopefully make it a bit easier for us to digest what the diff is and what the potential culprit could be. Thanks! =||= No, it wouldn't be possible. Prior to this change Log4j-core was an automatic module and the tests were not modules at all. To convert to a JPMS module the tests also had to be converted to comply with JPMS. The tests were being passed downstream for other modules to use in tests but they shared the same package name as the main module. So the tests being passed on had to be split. Plus some of the test classes were using the log4j-api package namespace. 

The diff is that Log4j-core used to have an automatic module name, which meant while it had a name it really wasn't a JPMS module. It didn't have all the restrictions placed on it that named modules do so everything was open. Because of the change, all the tests now run on the module path instead of the class path, which means everything has to conform to JPMS.   =||= The reason is pretty obvious: Byte Buddy is missing from the class path. I do not know how the module path is assembled, but I assume that the tool you are using does not know how to process an automatic module such as Mockito that requires a dependency. I set a breakpoint in the test and class in question and the *net.bytebuddy* module is not on the module path while the class path is empty.

We'll see how to improve the error message in such a case, I assume the tooling around the module system is still lacking a few details so this might just pay off.

If I for example add the line:

    requires transitive net.bytebuddy;

to *logging-log4j2/log4j-core/src/test/java9/module-info.java*, the problem seems to be solved for the `ConsoleAppenderTest` that yielded the error message that you described. =||= Thanks. That is interesting since the class shows up with mvn dependency:tree and clearly is there since just adding the requires for it fixes the problem. I'm not sure why that didn't occur to me. I'd guess it is the surefire plugin setting up the class path and module path, or something it delegates to. It sure would have been nice to have had some kind of warning message that dependencies were being ignored. Anyway, I will close this issue. =||= ",0
2298,2324,Release/3.x,"<!-- Hey,
Thanks for the contribution, this is awesome.
As you may have read, project members have somehow an opinionated view on what and how should be
Mockito, e.g. we don't want mockito to be a feature bloat.
There may be a thorough review, with feedback -> code change loop.
-->
<!--
If you have a suggestion for this template you can fix it in the .github/PULL_REQUEST_TEMPLATE.md file
-->
## Checklist

 - [ ] Read the [contributing guide](https://github.com/mockito/mockito/blob/main/.github/CONTRIBUTING.md)
 - [ ] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [ ] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [ ] Avoid other runtime dependencies
 - [ ] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [ ] The pull request follows coding style
 - [ ] Mention `Fixes #<issue number>` in the description _if relevant_
 - [ ] At least one commit should mention `Fixes #<issue number>` _if relevant_
",nan,0
2299,974,MockitoJUnitRunner.StrictStubs does not detect 'Unnecessary Stubbing' when inline mock maker is enabled,"- mockito-core 2.7.13
- OpenJDK 1.8.0_121
- Ubuntu 16.10
- Enable `mock-maker-inline` (or use `mockito-inline` artifact)

If running the following test, 'Unnecessary Stubbing' is not detected.

```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    ArrayList<String> mock;

    @Test
    public void should_pass() {
        when(mock.get(0)).thenReturn(""foo"");
        assertEquals(""foo"", mock.get(0));
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.get(1)).thenReturn(""foo"");
    }

}
```

In the above code, 'Unnecessary Stubbing' is detected by changing ArrayList to List.
```java

    @Mock
//    ArrayList<String> mock;
    List<String> mock;

```

This problem does not occur with default mock maker.","This is working as intended. You should not mock Data classes such as `List`. The new mock maker is stricter in this regard as we could not ship another breaking change for the original mock maker.

We could add an explicit exception when we encounter these classes, instead of silently continueing. WDYT @raphw ? =||= I am sorry that my test case was bad.

The following test **passes** using inline mock maker.
This test does not use data classes.
```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    C mock;

    @Test
    public void should_pass() {
        when(mock.doIt()).thenReturn(""foo"");
        assertEquals(""foo"", mock.doIt());
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.doIt()).thenReturn(""foo"");
    }

    public static class C {
        public String doIt() {
            throw new UnsupportedOperationException();
        }
    }

}
```

Using default mock maker, this test **fails**.
This is the result that I expect.
```
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected in test class: MockitoTest
Clean & maintainable test code requires zero unnecessary code.
Following stubbings are unnecessary (click to navigate to relevant line of code):
  1. -> at com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)
Please remove unnecessary stubbings or use 'silent' option. More info: javadoc for UnnecessaryStubbingException class.

	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:49)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:161)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
```

Does **new mock maker** mean **inline mock maker**?
According to the results of this test, inline mock maker seems to be less strict than default mock maker.
Sorry if I have misunderstood.
 =||= Ah that is a better testcase. Definitely a bug! =||= Just tested this on master and the result is the same for both mock makers where neither test detects the unneccessary stubbung. I do not know this part of Mockito too well but I assume there is a bug in this component. =||= I wrote a new test for this issue.

```java
public class StrictStubsRunnerByMockingAbstractClassTest {

    private final JUnitCore jUnitCore = new JUnitCore();

    @Test
    public void test_for_abstract_method_should_detect_unnecessary_stubbings() {
        runTest(ForAbstractMethod.class);
    }

    @Test
    public void test_for_concrete_method_should_detect_unnecessary_stubbings() {
        runTest(ForConcreteMethod.class);
    }

    private void runTest(Class<?> testClass) {
        Result result = jUnitCore.run(testClass);
        List<Failure> failures = result.getFailures();
        assertThat(failures.size(), equalTo(1));
        Failure failure = failures.get(0);
        assertThat(failure.getException(), instanceOf(UnnecessaryStubbingException.class));
    }

    static abstract class TestTarget {

        abstract String abstractMethod();

        String concreteMethod() {
            throw new UnsupportedOperationException();
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForAbstractMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
            mock.abstractMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForConcreteMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
            mock.concreteMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
        }

    }

}
```

To test this test on the master, I put this into the following directory.
1. src/test/java/org/mockitousage/junitrunner (using the default mock maker)
1. inline/src/test/java/org/mockitoinline (using the inline mock maker)

In the first case, this test passed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :test --tests ""org.mockitousage.junitrunner.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:createTestResources
:compileTestJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:removeTestResources
:processTestResources UP-TO-DATE
:testClasses
:test

BUILD SUCCESSFUL

Total time: 5.707 secs
```

However, in the second case it failed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :inline:test --tests ""org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:jar
:inline:compileJava UP-TO-DATE
:inline:processResources
:inline:classes
:inline:compileTestJava
:inline:processTestResources UP-TO-DATE
:inline:testClasses
:inline:test

org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest > test_for_concrete_method_should_detect_unnecessary_stubbings FAILED
    java.lang.AssertionError: 
    Expected: <1>
         but: was <0>
        at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
        at org.junit.Assert.assertThat(Assert.java:956)
        at org.junit.Assert.assertThat(Assert.java:923)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.runTest(StrictStubsRunnerByMockingAbstractClassTest.java:36)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.test_for_concrete_method_should_detect_unnecessary_stubbings(StrictStubsRunnerByMockingAbstractClassTest.java:30)

2 tests completed, 1 failed
:inline:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':inline:test'.
> There were failing tests. See the report at: file:///home/tmura/IdeaProjects/mockito/subprojects/inline/build/reports/tests/index.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 3.505 secs

```

For the abstract method, 'Unnecessary Stubbing' was detected correctly, but it did not detected for the concrete method.
 =||= I thnk I have found the cause of this problem.
When using the inline mock maker, it seems that LocationImpl cannot get the stubbed location of the concrete method correctly.

`UnusedStubbingFinder` which detects 'Unnecessary stubbing' calls `LocationImpl#toString()` to get the stabbed location.

The code below is the implementation of `LocationImpl#toString()`.
```java
StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);
if (filtered.length == 0) {
    return ""-> at <<unknown line>>"";
}
return ""-> at "" + filtered[0].toString();
```

This method filters the stack trace elements of `stackTraceHolder` to get the location.
`stackTraceHolder` is a Throwable object that is created in the constructor of `LocationImpl`.

The stack trace elements of this object are as follows:

- Stubbing the concrete method with the default mock maker
```
0 = {StackTraceElement@1679} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1680} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1681} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1682} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1683} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptSuperCallable(MockMethodInterceptor.java:102)""
5 = {StackTraceElement@1684} ""com.example.MockitoTest$C$MockitoMock$648066763.doIt(Unknown Source)""
6 = {StackTraceElement@1685} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the abstract method with the inline mock maker
```
0 = {StackTraceElement@2201} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@2202} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@2203} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@2204} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@2205} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:120)""
5 = {StackTraceElement@2206} ""com.example.MockitoTest$C$MockitoMock$1683798279.doIt(Unknown Source)""
6 = {StackTraceElement@2207} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the concrete method with the inline mock maker
```
0 = {StackTraceElement@1927} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1928} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1929} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1930} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1931} ""org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handle(MockMethodAdvice.java:76)""
5 = {StackTraceElement@1932} ""com.example.MockitoTest$C.doIt(MockitoTest.java:30)""
6 = {StackTraceElement@1933} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

The resulting location should be `#6`, but in the last case it is `#5`.
Because `stackTraceFilter` does not exclude `#5`.
 =||= Yes, this is expected. The inline mock maker inlines the code and does therefore not add a stack frame. This is a bug in the `UnusedStubbingFinder` which should not rely on the stack shape.

@TimvdLippe Do you have time to look at this? =||= Thank you guys for really thorough debugging!

>This is a bug in the UnusedStubbingFinder which should not rely on the stack shape.

There is a reason why the finder relies on the String representation of line where the unused stub is declared. I documented it in the [Javadoc](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java#L46), hopefully it is more less clear :) I'm not saying we should keep the current implementation, I'm ok changing it, I just wanted to give more data points.

After reading this thread my gut feel tells me that the stack trace filter (different component than unused stubbing detection) may not be coping well with inline mocking. This could also have impact on stack trace filtering in general for inline mocking, the quality of exception messages, etc.

@tmurakami, you made fantastic debugging effort to nail down the problem. Can you investigate if stack trace filter needs adapting for inline mocking and potentially submit a PR? =||= With the stack trace filter, I actually did change the implementation to adjust this behavior such that it works. I was not aware that the stubbing finder replicated something similar. =||= @szczepiq, @raphw, I can submit the PR, but this problem seems to have already been fixed by @raphw.
Should I submit the PR?
 =||= Please submit, I only fixed the issue partially. =||= ",0
2299,1587,InjectingAnnotationEngine does an unnecessary loop.,"processInjectMocks method of InjectingAnnotationEngine does unnecessary work. It might call injectMocks several times while it is sufficient to call injectMocks once.

    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {
        Class<?> classContext = clazz;
        while (classContext != Object.class) {
            injectMocks(testInstance);
            classContext = classContext.getSuperclass();
        }
    }

Inside, injectMocks loops classes by himself.

    public void injectMocks(final Object testClassInstance) {
        Class<?> clazz = testClassInstance.getClass();
        Set<Field> mockDependentFields = new HashSet<Field>();
        Set<Object> mocks = newMockSafeHashSet();

        while (clazz != Object.class) {
            new InjectMocksScanner(clazz).addTo(mockDependentFields);
            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);
            onInjection(testClassInstance, clazz, mockDependentFields, mocks);
            clazz = clazz.getSuperclass();
        }

        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);
    }

Why not delete the unnecessary loop?",nan,0
2299,2262,Illegal reflective access operation,"```
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.mockito.internal.util.reflection.ReflectionMemberAccessor to constructor java.lang.Void()
WARNING: Please consider reporting this to the maintainers of org.mockito.internal.util.reflection.ReflectionMemberAccessor
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
```
I don't know exactly what call causes it. This is with Mockito 3.8.0, Mockito-Kotlin 2.2.0, and
```
﻿openjdk version ""11.0.10"" 2021-01-19
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.10+9)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.10+9, mixed mode)
```


",Duplicate of #1325 =||= ,0
2299,974,MockitoJUnitRunner.StrictStubs does not detect 'Unnecessary Stubbing' when inline mock maker is enabled,"- mockito-core 2.7.13
- OpenJDK 1.8.0_121
- Ubuntu 16.10
- Enable `mock-maker-inline` (or use `mockito-inline` artifact)

If running the following test, 'Unnecessary Stubbing' is not detected.

```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    ArrayList<String> mock;

    @Test
    public void should_pass() {
        when(mock.get(0)).thenReturn(""foo"");
        assertEquals(""foo"", mock.get(0));
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.get(1)).thenReturn(""foo"");
    }

}
```

In the above code, 'Unnecessary Stubbing' is detected by changing ArrayList to List.
```java

    @Mock
//    ArrayList<String> mock;
    List<String> mock;

```

This problem does not occur with default mock maker.","This is working as intended. You should not mock Data classes such as `List`. The new mock maker is stricter in this regard as we could not ship another breaking change for the original mock maker.

We could add an explicit exception when we encounter these classes, instead of silently continueing. WDYT @raphw ? =||= I am sorry that my test case was bad.

The following test **passes** using inline mock maker.
This test does not use data classes.
```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    C mock;

    @Test
    public void should_pass() {
        when(mock.doIt()).thenReturn(""foo"");
        assertEquals(""foo"", mock.doIt());
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.doIt()).thenReturn(""foo"");
    }

    public static class C {
        public String doIt() {
            throw new UnsupportedOperationException();
        }
    }

}
```

Using default mock maker, this test **fails**.
This is the result that I expect.
```
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected in test class: MockitoTest
Clean & maintainable test code requires zero unnecessary code.
Following stubbings are unnecessary (click to navigate to relevant line of code):
  1. -> at com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)
Please remove unnecessary stubbings or use 'silent' option. More info: javadoc for UnnecessaryStubbingException class.

	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:49)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:161)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
```

Does **new mock maker** mean **inline mock maker**?
According to the results of this test, inline mock maker seems to be less strict than default mock maker.
Sorry if I have misunderstood.
 =||= Ah that is a better testcase. Definitely a bug! =||= Just tested this on master and the result is the same for both mock makers where neither test detects the unneccessary stubbung. I do not know this part of Mockito too well but I assume there is a bug in this component. =||= I wrote a new test for this issue.

```java
public class StrictStubsRunnerByMockingAbstractClassTest {

    private final JUnitCore jUnitCore = new JUnitCore();

    @Test
    public void test_for_abstract_method_should_detect_unnecessary_stubbings() {
        runTest(ForAbstractMethod.class);
    }

    @Test
    public void test_for_concrete_method_should_detect_unnecessary_stubbings() {
        runTest(ForConcreteMethod.class);
    }

    private void runTest(Class<?> testClass) {
        Result result = jUnitCore.run(testClass);
        List<Failure> failures = result.getFailures();
        assertThat(failures.size(), equalTo(1));
        Failure failure = failures.get(0);
        assertThat(failure.getException(), instanceOf(UnnecessaryStubbingException.class));
    }

    static abstract class TestTarget {

        abstract String abstractMethod();

        String concreteMethod() {
            throw new UnsupportedOperationException();
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForAbstractMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
            mock.abstractMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForConcreteMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
            mock.concreteMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
        }

    }

}
```

To test this test on the master, I put this into the following directory.
1. src/test/java/org/mockitousage/junitrunner (using the default mock maker)
1. inline/src/test/java/org/mockitoinline (using the inline mock maker)

In the first case, this test passed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :test --tests ""org.mockitousage.junitrunner.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:createTestResources
:compileTestJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:removeTestResources
:processTestResources UP-TO-DATE
:testClasses
:test

BUILD SUCCESSFUL

Total time: 5.707 secs
```

However, in the second case it failed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :inline:test --tests ""org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:jar
:inline:compileJava UP-TO-DATE
:inline:processResources
:inline:classes
:inline:compileTestJava
:inline:processTestResources UP-TO-DATE
:inline:testClasses
:inline:test

org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest > test_for_concrete_method_should_detect_unnecessary_stubbings FAILED
    java.lang.AssertionError: 
    Expected: <1>
         but: was <0>
        at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
        at org.junit.Assert.assertThat(Assert.java:956)
        at org.junit.Assert.assertThat(Assert.java:923)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.runTest(StrictStubsRunnerByMockingAbstractClassTest.java:36)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.test_for_concrete_method_should_detect_unnecessary_stubbings(StrictStubsRunnerByMockingAbstractClassTest.java:30)

2 tests completed, 1 failed
:inline:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':inline:test'.
> There were failing tests. See the report at: file:///home/tmura/IdeaProjects/mockito/subprojects/inline/build/reports/tests/index.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 3.505 secs

```

For the abstract method, 'Unnecessary Stubbing' was detected correctly, but it did not detected for the concrete method.
 =||= I thnk I have found the cause of this problem.
When using the inline mock maker, it seems that LocationImpl cannot get the stubbed location of the concrete method correctly.

`UnusedStubbingFinder` which detects 'Unnecessary stubbing' calls `LocationImpl#toString()` to get the stabbed location.

The code below is the implementation of `LocationImpl#toString()`.
```java
StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);
if (filtered.length == 0) {
    return ""-> at <<unknown line>>"";
}
return ""-> at "" + filtered[0].toString();
```

This method filters the stack trace elements of `stackTraceHolder` to get the location.
`stackTraceHolder` is a Throwable object that is created in the constructor of `LocationImpl`.

The stack trace elements of this object are as follows:

- Stubbing the concrete method with the default mock maker
```
0 = {StackTraceElement@1679} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1680} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1681} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1682} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1683} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptSuperCallable(MockMethodInterceptor.java:102)""
5 = {StackTraceElement@1684} ""com.example.MockitoTest$C$MockitoMock$648066763.doIt(Unknown Source)""
6 = {StackTraceElement@1685} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the abstract method with the inline mock maker
```
0 = {StackTraceElement@2201} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@2202} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@2203} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@2204} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@2205} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:120)""
5 = {StackTraceElement@2206} ""com.example.MockitoTest$C$MockitoMock$1683798279.doIt(Unknown Source)""
6 = {StackTraceElement@2207} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the concrete method with the inline mock maker
```
0 = {StackTraceElement@1927} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1928} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1929} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1930} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1931} ""org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handle(MockMethodAdvice.java:76)""
5 = {StackTraceElement@1932} ""com.example.MockitoTest$C.doIt(MockitoTest.java:30)""
6 = {StackTraceElement@1933} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

The resulting location should be `#6`, but in the last case it is `#5`.
Because `stackTraceFilter` does not exclude `#5`.
 =||= Yes, this is expected. The inline mock maker inlines the code and does therefore not add a stack frame. This is a bug in the `UnusedStubbingFinder` which should not rely on the stack shape.

@TimvdLippe Do you have time to look at this? =||= Thank you guys for really thorough debugging!

>This is a bug in the UnusedStubbingFinder which should not rely on the stack shape.

There is a reason why the finder relies on the String representation of line where the unused stub is declared. I documented it in the [Javadoc](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java#L46), hopefully it is more less clear :) I'm not saying we should keep the current implementation, I'm ok changing it, I just wanted to give more data points.

After reading this thread my gut feel tells me that the stack trace filter (different component than unused stubbing detection) may not be coping well with inline mocking. This could also have impact on stack trace filtering in general for inline mocking, the quality of exception messages, etc.

@tmurakami, you made fantastic debugging effort to nail down the problem. Can you investigate if stack trace filter needs adapting for inline mocking and potentially submit a PR? =||= With the stack trace filter, I actually did change the implementation to adjust this behavior such that it works. I was not aware that the stubbing finder replicated something similar. =||= @szczepiq, @raphw, I can submit the PR, but this problem seems to have already been fixed by @raphw.
Should I submit the PR?
 =||= Please submit, I only fixed the issue partially. =||= ",0
2299,974,MockitoJUnitRunner.StrictStubs does not detect 'Unnecessary Stubbing' when inline mock maker is enabled,"- mockito-core 2.7.13
- OpenJDK 1.8.0_121
- Ubuntu 16.10
- Enable `mock-maker-inline` (or use `mockito-inline` artifact)

If running the following test, 'Unnecessary Stubbing' is not detected.

```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    ArrayList<String> mock;

    @Test
    public void should_pass() {
        when(mock.get(0)).thenReturn(""foo"");
        assertEquals(""foo"", mock.get(0));
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.get(1)).thenReturn(""foo"");
    }

}
```

In the above code, 'Unnecessary Stubbing' is detected by changing ArrayList to List.
```java

    @Mock
//    ArrayList<String> mock;
    List<String> mock;

```

This problem does not occur with default mock maker.","This is working as intended. You should not mock Data classes such as `List`. The new mock maker is stricter in this regard as we could not ship another breaking change for the original mock maker.

We could add an explicit exception when we encounter these classes, instead of silently continueing. WDYT @raphw ? =||= I am sorry that my test case was bad.

The following test **passes** using inline mock maker.
This test does not use data classes.
```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    C mock;

    @Test
    public void should_pass() {
        when(mock.doIt()).thenReturn(""foo"");
        assertEquals(""foo"", mock.doIt());
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.doIt()).thenReturn(""foo"");
    }

    public static class C {
        public String doIt() {
            throw new UnsupportedOperationException();
        }
    }

}
```

Using default mock maker, this test **fails**.
This is the result that I expect.
```
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected in test class: MockitoTest
Clean & maintainable test code requires zero unnecessary code.
Following stubbings are unnecessary (click to navigate to relevant line of code):
  1. -> at com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)
Please remove unnecessary stubbings or use 'silent' option. More info: javadoc for UnnecessaryStubbingException class.

	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:49)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:161)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
```

Does **new mock maker** mean **inline mock maker**?
According to the results of this test, inline mock maker seems to be less strict than default mock maker.
Sorry if I have misunderstood.
 =||= Ah that is a better testcase. Definitely a bug! =||= Just tested this on master and the result is the same for both mock makers where neither test detects the unneccessary stubbung. I do not know this part of Mockito too well but I assume there is a bug in this component. =||= I wrote a new test for this issue.

```java
public class StrictStubsRunnerByMockingAbstractClassTest {

    private final JUnitCore jUnitCore = new JUnitCore();

    @Test
    public void test_for_abstract_method_should_detect_unnecessary_stubbings() {
        runTest(ForAbstractMethod.class);
    }

    @Test
    public void test_for_concrete_method_should_detect_unnecessary_stubbings() {
        runTest(ForConcreteMethod.class);
    }

    private void runTest(Class<?> testClass) {
        Result result = jUnitCore.run(testClass);
        List<Failure> failures = result.getFailures();
        assertThat(failures.size(), equalTo(1));
        Failure failure = failures.get(0);
        assertThat(failure.getException(), instanceOf(UnnecessaryStubbingException.class));
    }

    static abstract class TestTarget {

        abstract String abstractMethod();

        String concreteMethod() {
            throw new UnsupportedOperationException();
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForAbstractMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
            mock.abstractMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForConcreteMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
            mock.concreteMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
        }

    }

}
```

To test this test on the master, I put this into the following directory.
1. src/test/java/org/mockitousage/junitrunner (using the default mock maker)
1. inline/src/test/java/org/mockitoinline (using the inline mock maker)

In the first case, this test passed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :test --tests ""org.mockitousage.junitrunner.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:createTestResources
:compileTestJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:removeTestResources
:processTestResources UP-TO-DATE
:testClasses
:test

BUILD SUCCESSFUL

Total time: 5.707 secs
```

However, in the second case it failed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :inline:test --tests ""org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:jar
:inline:compileJava UP-TO-DATE
:inline:processResources
:inline:classes
:inline:compileTestJava
:inline:processTestResources UP-TO-DATE
:inline:testClasses
:inline:test

org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest > test_for_concrete_method_should_detect_unnecessary_stubbings FAILED
    java.lang.AssertionError: 
    Expected: <1>
         but: was <0>
        at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
        at org.junit.Assert.assertThat(Assert.java:956)
        at org.junit.Assert.assertThat(Assert.java:923)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.runTest(StrictStubsRunnerByMockingAbstractClassTest.java:36)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.test_for_concrete_method_should_detect_unnecessary_stubbings(StrictStubsRunnerByMockingAbstractClassTest.java:30)

2 tests completed, 1 failed
:inline:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':inline:test'.
> There were failing tests. See the report at: file:///home/tmura/IdeaProjects/mockito/subprojects/inline/build/reports/tests/index.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 3.505 secs

```

For the abstract method, 'Unnecessary Stubbing' was detected correctly, but it did not detected for the concrete method.
 =||= I thnk I have found the cause of this problem.
When using the inline mock maker, it seems that LocationImpl cannot get the stubbed location of the concrete method correctly.

`UnusedStubbingFinder` which detects 'Unnecessary stubbing' calls `LocationImpl#toString()` to get the stabbed location.

The code below is the implementation of `LocationImpl#toString()`.
```java
StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);
if (filtered.length == 0) {
    return ""-> at <<unknown line>>"";
}
return ""-> at "" + filtered[0].toString();
```

This method filters the stack trace elements of `stackTraceHolder` to get the location.
`stackTraceHolder` is a Throwable object that is created in the constructor of `LocationImpl`.

The stack trace elements of this object are as follows:

- Stubbing the concrete method with the default mock maker
```
0 = {StackTraceElement@1679} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1680} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1681} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1682} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1683} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptSuperCallable(MockMethodInterceptor.java:102)""
5 = {StackTraceElement@1684} ""com.example.MockitoTest$C$MockitoMock$648066763.doIt(Unknown Source)""
6 = {StackTraceElement@1685} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the abstract method with the inline mock maker
```
0 = {StackTraceElement@2201} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@2202} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@2203} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@2204} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@2205} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:120)""
5 = {StackTraceElement@2206} ""com.example.MockitoTest$C$MockitoMock$1683798279.doIt(Unknown Source)""
6 = {StackTraceElement@2207} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the concrete method with the inline mock maker
```
0 = {StackTraceElement@1927} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1928} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1929} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1930} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1931} ""org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handle(MockMethodAdvice.java:76)""
5 = {StackTraceElement@1932} ""com.example.MockitoTest$C.doIt(MockitoTest.java:30)""
6 = {StackTraceElement@1933} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

The resulting location should be `#6`, but in the last case it is `#5`.
Because `stackTraceFilter` does not exclude `#5`.
 =||= Yes, this is expected. The inline mock maker inlines the code and does therefore not add a stack frame. This is a bug in the `UnusedStubbingFinder` which should not rely on the stack shape.

@TimvdLippe Do you have time to look at this? =||= Thank you guys for really thorough debugging!

>This is a bug in the UnusedStubbingFinder which should not rely on the stack shape.

There is a reason why the finder relies on the String representation of line where the unused stub is declared. I documented it in the [Javadoc](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java#L46), hopefully it is more less clear :) I'm not saying we should keep the current implementation, I'm ok changing it, I just wanted to give more data points.

After reading this thread my gut feel tells me that the stack trace filter (different component than unused stubbing detection) may not be coping well with inline mocking. This could also have impact on stack trace filtering in general for inline mocking, the quality of exception messages, etc.

@tmurakami, you made fantastic debugging effort to nail down the problem. Can you investigate if stack trace filter needs adapting for inline mocking and potentially submit a PR? =||= With the stack trace filter, I actually did change the implementation to adjust this behavior such that it works. I was not aware that the stubbing finder replicated something similar. =||= @szczepiq, @raphw, I can submit the PR, but this problem seems to have already been fixed by @raphw.
Should I submit the PR?
 =||= Please submit, I only fixed the issue partially. =||= ",0
2299,1587,InjectingAnnotationEngine does an unnecessary loop.,"processInjectMocks method of InjectingAnnotationEngine does unnecessary work. It might call injectMocks several times while it is sufficient to call injectMocks once.

    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {
        Class<?> classContext = clazz;
        while (classContext != Object.class) {
            injectMocks(testInstance);
            classContext = classContext.getSuperclass();
        }
    }

Inside, injectMocks loops classes by himself.

    public void injectMocks(final Object testClassInstance) {
        Class<?> clazz = testClassInstance.getClass();
        Set<Field> mockDependentFields = new HashSet<Field>();
        Set<Object> mocks = newMockSafeHashSet();

        while (clazz != Object.class) {
            new InjectMocksScanner(clazz).addTo(mockDependentFields);
            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);
            onInjection(testClassInstance, clazz, mockDependentFields, mocks);
            clazz = clazz.getSuperclass();
        }

        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);
    }

Why not delete the unnecessary loop?",nan,0
2299,2262,Illegal reflective access operation,"```
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.mockito.internal.util.reflection.ReflectionMemberAccessor to constructor java.lang.Void()
WARNING: Please consider reporting this to the maintainers of org.mockito.internal.util.reflection.ReflectionMemberAccessor
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
```
I don't know exactly what call causes it. This is with Mockito 3.8.0, Mockito-Kotlin 2.2.0, and
```
﻿openjdk version ""11.0.10"" 2021-01-19
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.10+9)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.10+9, mixed mode)
```


",Duplicate of #1325 =||= ,0
2306,230,Null Pointer when invoking Whitebox.invokeMethod() with null one of the params null ,"Getting below exceptions when trying to invoke Whitebox.invokeMethod(erxProviderManager, ""setCommand"", Provider, null,retait, mail);

Version used 1.6.2

FAILED: testSetEnrollmentCommandWithUnEnrollmentWithNull
java.lang.NullPointerException
    at java.lang.Class.isAssignableFrom(Native Method)
    at org.powermock.reflect.internal.WhiteboxImpl.checkIfParameterTypesAreSame(WhiteboxImpl.java:2257)
    at org.powermock.reflect.internal.WhiteboxImpl.getMethods(WhiteboxImpl.java:1800)
    at org.powermock.reflect.internal.WhiteboxImpl.getBestMethodCandidate(WhiteboxImpl.java:955)
    at org.powermock.reflect.internal.WhiteboxImpl.findMethodOrThrowException(WhiteboxImpl.java:832)
    at org.powermock.reflect.internal.WhiteboxImpl.doInvokeMethod(WhiteboxImpl.java:770)
    at org.powermock.reflect.internal.WhiteboxImpl.invokeMethod(WhiteboxImpl.java:638)
    at org.powermock.reflect.Whitebox.invokeMethod(Whitebox.java:401)","It's powermock API ;)

Also the code you're mentioning use an **internal** API which is not thought for use outside the library.
 =||= ",0
2309,34,Issue 345 (customAnswer) solution proposal,nan,"[![Coverage Status](https://coveralls.io/builds/471938/badge)](https://coveralls.io/builds/471938)

Coverage remained the same when pulling **7e1f7a6ad363e267b170aac391808b1d37ae8b18 on kretes:master** into **82935114a09390cbab0c6b6df9b6fd6788bf55d9 on mockito:master**.
 =||= Also squashing or rewording the commits would make sense here, _commit for travis_ doesn't look interesting enough ;)
 =||= Code replaced in PR #40 
 =||= ",0
2309,31,"Issue459 - updated hamcrest-core to 1.3.0, JUnit to 4.11","The whole discussion took place here:
https://github.com/mockito/mockito/pull/27","We'll do it but with Mockito 2.0 :)

Thanks for the PR!
 =||= has v2.0 a target date ?
 =||= Not yet.

On Thu, May 29, 2014 at 5:29 AM, Cristiano Gavião notifications@github.com
wrote:

> has v2.0 a target date ?
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/pull/31#issuecomment-44490908.

## 

Szczepan Faber
Principal engineer@gradle; Founder@mockito
Join us for Gradle Summit 2014, June 12th and 13th in Santa Clara, CA:
http://www.gradlesummit.com
 =||= ",0
2312,2303,"""The type is not public and its mock class is loaded by a different class loader"" with a context classloader that delegates","Repro case:
```java
package com.google.clm.mockitobug;

import static org.mockito.Mockito.mock;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * My goal is to create a context classloader that is identical in every way to the existing one,
 * except that it has a different object identity and possibly some extra fields. However, even a
 * basic classloader that always delegates causes problems for mockito.
 */
@RunWith(JUnit4.class)
public final class ClassLoaderTest {

  @Test
  public void mockPackagePrivateInterface() {
    ClassLoader old = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(new ClassLoader(old) {});
    // fails
    Object unused = mock(PackagePrivate.class);
  }

  @Test
  public void mockPublicInterface() {
    ClassLoader old = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(new ClassLoader(old) {});
    // succeeds
    Object unused = mock(Public.class);
  }

  interface PackagePrivate {}

  public interface Public {}
}
```
Error:
```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : Google Inc.
JVM vendor version : 11.0.10+9-google-release-371350251
JVM name           : OpenJDK 64-Bit Server VM
JVM version        : 11.0.10+9-google-release-371350251
JVM info           : mixed mode, sharing
OS name            : Linux
OS version         : 4.15.0-smp-912.23.0.0


Underlying exception : org.mockito.exceptions.base.MockitoException: 
Cannot create mock for interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate

The type is not public and its mock class is loaded by a different class loader.
This can have multiple reasons:
 - You are mocking a class with additional interfaces of another class loader
 - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)
 - The thread's context class loader is different than the mock's class loader
	at com.google.clm.mockitobug.ClassLoaderTest.mockPackagePrivateInterface(ClassLoaderTest.java:21)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:57)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:59)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:81)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:327)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:84)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:292)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:73)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:290)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:60)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:270)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:370)
	at com.google.testing.junit.runner.internal.junit4.CancellableRequestFactory$CancellableRunner.run(CancellableRequestFactory.java:108)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
	at com.google.testing.junit.runner.junit4.JUnit4Runner.run(JUnit4Runner.java:104)
	at com.google.testing.junit.runner.RunnerShell$2.run(RunnerShell.java:34)
	at com.google.testing.junit.runner.GoogleTestRunner.runTestsInSuite(GoogleTestRunner.java:200)
	at com.google.testing.junit.runner.GoogleTestRunner.runTestsInSuite(GoogleTestRunner.java:184)
	at com.google.testing.junit.runner.GoogleTestRunner.main(GoogleTestRunner.java:137)
Caused by: org.mockito.exceptions.base.MockitoException: 
Cannot create mock for interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate

The type is not public and its mock class is loaded by a different class loader.
This can have multiple reasons:
 - You are mocking a class with additional interfaces of another class loader
 - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)
 - The thread's context class loader is different than the mock's class loader
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:153)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:366)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:175)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:377)
	... 27 more

```

If mockito actually tried to use the classloader, I think it would work. Since we don't see an interesting exception deep in the stack, my guess is that mockito is doing some extra validation to avoid generating bytecode it thinks would fail.","Rafael, I took a look at this code and it wasn't completely clear to my why we are failing here. The reason that is probably happening is that Mockito first adds the mocked type (https://github.com/mockito/mockito/blob/6f9108b833323345bd926f10914224d3e0a11b80/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L97) in this case `PackagePrivate` before adding the current classloader: https://github.com/mockito/mockito/blob/6f9108b833323345bd926f10914224d3e0a11b80/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L99

So it looks up the classloader for the mocked type, which is the old classloader. Then it looks up the current classloader (which you changed) and then determines that they don't match. Thus `localMock == false`.

This code landed as part of supporting Java 9+ modules: https://github.com/mockito/mockito/pull/1582 It wouldn't surprise me if there is an edge case we are missing.

Since the new classloader delegates to the former, I would have expected the classes to match and thus pass the checks, but they don't. Presumably because of the classloader equality check. Can we be lenient here and allow for child classloaders to be valid as well? =||= The reason we fail is that a package-private type is not visible outside of its own class loader. Even if we defined the subclass in the same nominal package, if it was loaded by a different class loader, it could not see its superclass. To avoid this visibility issue, we fail before even attempting to create the mock.

We could consider to drop the context class loader if a mocked class is package-private. I am not sure why we need the context class loader to begin with but I assume its related to serialization what tends to be an edge case. =||= I can think of a few options:

1. Ignore the context classloader if the type is package-private. It could have failed anyway... so if it succeeds, might as well reap the benefit.
2. Ignore the package-private restriction for classloaders that are not participating in the java module system, by checking isSealed on the class's package
3. Check to see if the context classloader is a child of the originating classloader, although if a classloader is declaring a parent but not following the delegation patter this might cause a false negative or positive.
4. Just load the stuff as you would, and check each relevant class you load and error if the defining classloader doesn't match. =||= I'll mess around a bit more and report back if I figure out what the issue is. =||= OK, I have a the minimal fix (as in, it will only affect cases that would have broken before):

If the mocked type is a non-interface or non-public, or any of the extra interfaces are non-public, don't include the context classloader in MultipleParentsClassLoader iff the context classloader is a child of the classloader we'd use if it wasn't included.

This fixes my issue, and in general likely fixes cases where a context classloader is set that follows the parent-first delegation pattern. I thought about simply removing the context loader entirely, but test authors who hit this can set and unset it in a try-finally block around their mock calls if necessary, and since there's no comments about why it's included I'd be wary of breaking somebody depending on the existing behavior.

I am going to run this fix through google's internal suite of tests to see if it breaks anything.  =||= 1. The problem is that it might fail delayed upon deserialization. This might be non-trivial to understand and we should document this restriction somewhere. 
2. That won't work. Sealing only affects jars on the same class loader that are defining the same package, this won't work with modules anymore anyways and is taken care of. Package-private classes are however never visible on other class loaders, therefore we must retain the class loader.
3. Is already done to some extend.
4. This is implicit by the multiple parent loader.

I think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition.  =||= > I think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition.

It's not just package-private classes - mocking a public non-final-non-interface class also poses problems, since that will break stubbing/verification of package-private methods (#796).

My proposed fix:
```java
private static boolean needsSamePackageClassLoader(MockFeatures<?> features) {
  if (!Modifier.isPublic(features.mockedType.getModifiers())
                              || !features.mockedType.isInterface()) {
    // The mocked type is package private or is not an interface and thus may contain package
    // private methods.
    return true;
  }
  for (Class<?> iface : features.interfaces) {
    if (!Modifier.isPublic(iface.getModifiers())) {
      return true;
    }
  }
  return false;
}
...
MultipleParentClassLoader.Builder loaderBuilder = new MultipleParentClassLoader.Builder()
                  .appendMostSpecific(getAllTypes(features.mockedType))
                  .appendMostSpecific(features.interfaces)
                  .appendMostSpecific(MockAccess.class);
ClassLoader contextLoader = currentThread().getContextClassLoader();
boolean shouldIncludeContextLoader = true;
if (needsSamePackageClassLoader(features)) {
    // For the generated class to access package-private methods, it must be defined by the
    // same classloader as its type. All the other added classloaders are required to load
    // the type; if the context classloader is a child of the mocked type's defining
    // classloader, it will break a mock that would have worked. Check if the context class
    // loader is a child of the classloader we'd otherwise use, and possibly skip it.
    ClassLoader candidateLoader = loaderBuilder.build();
    for (ClassLoader parent = contextLoader; parent != null; parent = parent.getParent()) {
      if (parent == candidateLoader) {
        shouldIncludeContextLoader = false;
        break;
      }
    }
}
if (shouldIncludeContextLoader) {
  loaderBuilder = loaderBuilder.appendMostSpecific(contextLoader);
}
ClassLoader classLoader = loaderBuilder.build();
```

The focus was on only changing behavior for cases that failed before. Since we verify that the classloader we define in is a parent of the context classloader, we shouldn't see any problems with serialization, right? Or at least no new problems, as the existing `MultipleParentsClassLoader` relies on `getParent()` to infer the delegation order. =||= @charlesmunger Do you mind opening a PR that includes your proposed fix and adds a regression test for your use case? If all tests pass, I am inclined to merge as-is. If we end up breaking anybody else, we should add regression tests for their use cases and modify the implementation accordingly. =||= ",0
2318,2303,"""The type is not public and its mock class is loaded by a different class loader"" with a context classloader that delegates","Repro case:
```java
package com.google.clm.mockitobug;

import static org.mockito.Mockito.mock;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * My goal is to create a context classloader that is identical in every way to the existing one,
 * except that it has a different object identity and possibly some extra fields. However, even a
 * basic classloader that always delegates causes problems for mockito.
 */
@RunWith(JUnit4.class)
public final class ClassLoaderTest {

  @Test
  public void mockPackagePrivateInterface() {
    ClassLoader old = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(new ClassLoader(old) {});
    // fails
    Object unused = mock(PackagePrivate.class);
  }

  @Test
  public void mockPublicInterface() {
    ClassLoader old = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(new ClassLoader(old) {});
    // succeeds
    Object unused = mock(Public.class);
  }

  interface PackagePrivate {}

  public interface Public {}
}
```
Error:
```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : Google Inc.
JVM vendor version : 11.0.10+9-google-release-371350251
JVM name           : OpenJDK 64-Bit Server VM
JVM version        : 11.0.10+9-google-release-371350251
JVM info           : mixed mode, sharing
OS name            : Linux
OS version         : 4.15.0-smp-912.23.0.0


Underlying exception : org.mockito.exceptions.base.MockitoException: 
Cannot create mock for interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate

The type is not public and its mock class is loaded by a different class loader.
This can have multiple reasons:
 - You are mocking a class with additional interfaces of another class loader
 - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)
 - The thread's context class loader is different than the mock's class loader
	at com.google.clm.mockitobug.ClassLoaderTest.mockPackagePrivateInterface(ClassLoaderTest.java:21)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:57)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:59)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:81)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:327)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:84)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:292)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:73)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:290)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:60)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:270)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:370)
	at com.google.testing.junit.runner.internal.junit4.CancellableRequestFactory$CancellableRunner.run(CancellableRequestFactory.java:108)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
	at com.google.testing.junit.runner.junit4.JUnit4Runner.run(JUnit4Runner.java:104)
	at com.google.testing.junit.runner.RunnerShell$2.run(RunnerShell.java:34)
	at com.google.testing.junit.runner.GoogleTestRunner.runTestsInSuite(GoogleTestRunner.java:200)
	at com.google.testing.junit.runner.GoogleTestRunner.runTestsInSuite(GoogleTestRunner.java:184)
	at com.google.testing.junit.runner.GoogleTestRunner.main(GoogleTestRunner.java:137)
Caused by: org.mockito.exceptions.base.MockitoException: 
Cannot create mock for interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate

The type is not public and its mock class is loaded by a different class loader.
This can have multiple reasons:
 - You are mocking a class with additional interfaces of another class loader
 - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)
 - The thread's context class loader is different than the mock's class loader
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:153)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:366)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:175)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:377)
	... 27 more

```

If mockito actually tried to use the classloader, I think it would work. Since we don't see an interesting exception deep in the stack, my guess is that mockito is doing some extra validation to avoid generating bytecode it thinks would fail.","Rafael, I took a look at this code and it wasn't completely clear to my why we are failing here. The reason that is probably happening is that Mockito first adds the mocked type (https://github.com/mockito/mockito/blob/6f9108b833323345bd926f10914224d3e0a11b80/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L97) in this case `PackagePrivate` before adding the current classloader: https://github.com/mockito/mockito/blob/6f9108b833323345bd926f10914224d3e0a11b80/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L99

So it looks up the classloader for the mocked type, which is the old classloader. Then it looks up the current classloader (which you changed) and then determines that they don't match. Thus `localMock == false`.

This code landed as part of supporting Java 9+ modules: https://github.com/mockito/mockito/pull/1582 It wouldn't surprise me if there is an edge case we are missing.

Since the new classloader delegates to the former, I would have expected the classes to match and thus pass the checks, but they don't. Presumably because of the classloader equality check. Can we be lenient here and allow for child classloaders to be valid as well? =||= The reason we fail is that a package-private type is not visible outside of its own class loader. Even if we defined the subclass in the same nominal package, if it was loaded by a different class loader, it could not see its superclass. To avoid this visibility issue, we fail before even attempting to create the mock.

We could consider to drop the context class loader if a mocked class is package-private. I am not sure why we need the context class loader to begin with but I assume its related to serialization what tends to be an edge case. =||= I can think of a few options:

1. Ignore the context classloader if the type is package-private. It could have failed anyway... so if it succeeds, might as well reap the benefit.
2. Ignore the package-private restriction for classloaders that are not participating in the java module system, by checking isSealed on the class's package
3. Check to see if the context classloader is a child of the originating classloader, although if a classloader is declaring a parent but not following the delegation patter this might cause a false negative or positive.
4. Just load the stuff as you would, and check each relevant class you load and error if the defining classloader doesn't match. =||= I'll mess around a bit more and report back if I figure out what the issue is. =||= OK, I have a the minimal fix (as in, it will only affect cases that would have broken before):

If the mocked type is a non-interface or non-public, or any of the extra interfaces are non-public, don't include the context classloader in MultipleParentsClassLoader iff the context classloader is a child of the classloader we'd use if it wasn't included.

This fixes my issue, and in general likely fixes cases where a context classloader is set that follows the parent-first delegation pattern. I thought about simply removing the context loader entirely, but test authors who hit this can set and unset it in a try-finally block around their mock calls if necessary, and since there's no comments about why it's included I'd be wary of breaking somebody depending on the existing behavior.

I am going to run this fix through google's internal suite of tests to see if it breaks anything.  =||= 1. The problem is that it might fail delayed upon deserialization. This might be non-trivial to understand and we should document this restriction somewhere. 
2. That won't work. Sealing only affects jars on the same class loader that are defining the same package, this won't work with modules anymore anyways and is taken care of. Package-private classes are however never visible on other class loaders, therefore we must retain the class loader.
3. Is already done to some extend.
4. This is implicit by the multiple parent loader.

I think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition.  =||= > I think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition.

It's not just package-private classes - mocking a public non-final-non-interface class also poses problems, since that will break stubbing/verification of package-private methods (#796).

My proposed fix:
```java
private static boolean needsSamePackageClassLoader(MockFeatures<?> features) {
  if (!Modifier.isPublic(features.mockedType.getModifiers())
                              || !features.mockedType.isInterface()) {
    // The mocked type is package private or is not an interface and thus may contain package
    // private methods.
    return true;
  }
  for (Class<?> iface : features.interfaces) {
    if (!Modifier.isPublic(iface.getModifiers())) {
      return true;
    }
  }
  return false;
}
...
MultipleParentClassLoader.Builder loaderBuilder = new MultipleParentClassLoader.Builder()
                  .appendMostSpecific(getAllTypes(features.mockedType))
                  .appendMostSpecific(features.interfaces)
                  .appendMostSpecific(MockAccess.class);
ClassLoader contextLoader = currentThread().getContextClassLoader();
boolean shouldIncludeContextLoader = true;
if (needsSamePackageClassLoader(features)) {
    // For the generated class to access package-private methods, it must be defined by the
    // same classloader as its type. All the other added classloaders are required to load
    // the type; if the context classloader is a child of the mocked type's defining
    // classloader, it will break a mock that would have worked. Check if the context class
    // loader is a child of the classloader we'd otherwise use, and possibly skip it.
    ClassLoader candidateLoader = loaderBuilder.build();
    for (ClassLoader parent = contextLoader; parent != null; parent = parent.getParent()) {
      if (parent == candidateLoader) {
        shouldIncludeContextLoader = false;
        break;
      }
    }
}
if (shouldIncludeContextLoader) {
  loaderBuilder = loaderBuilder.appendMostSpecific(contextLoader);
}
ClassLoader classLoader = loaderBuilder.build();
```

The focus was on only changing behavior for cases that failed before. Since we verify that the classloader we define in is a parent of the context classloader, we shouldn't see any problems with serialization, right? Or at least no new problems, as the existing `MultipleParentsClassLoader` relies on `getParent()` to infer the delegation order. =||= @charlesmunger Do you mind opening a PR that includes your proposed fix and adds a regression test for your use case? If all tests pass, I am inclined to merge as-is. If we end up breaking anybody else, we should add regression tests for their use cases and modify the implementation accordingly. =||= ",0
